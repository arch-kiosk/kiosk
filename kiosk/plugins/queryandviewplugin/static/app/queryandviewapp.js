var am = Object.defineProperty;
var lm = (i, e, t) => e in i ? am(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[e] = t;
var Oe = (i, e, t) => (lm(i, typeof e != "symbol" ? e + "" : e, t), t);
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const vs = window, ua = vs.ShadowRoot && (vs.ShadyCSS === void 0 || vs.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, ha = Symbol(), ml = /* @__PURE__ */ new WeakMap();
let fa = class {
  constructor(e, t, r) {
    if (this._$cssResult$ = !0, r !== ha)
      throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = e, this.t = t;
  }
  get styleSheet() {
    let e = this.o;
    const t = this.t;
    if (ua && e === void 0) {
      const r = t !== void 0 && t.length === 1;
      r && (e = ml.get(t)), e === void 0 && ((this.o = e = new CSSStyleSheet()).replaceSync(this.cssText), r && ml.set(t, e));
    }
    return e;
  }
  toString() {
    return this.cssText;
  }
};
const tt = (i) => new fa(typeof i == "string" ? i : i + "", void 0, ha), y = (i, ...e) => {
  const t = i.length === 1 ? i[0] : e.reduce((r, s, o) => r + ((n) => {
    if (n._$cssResult$ === !0)
      return n.cssText;
    if (typeof n == "number")
      return n;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + n + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(s) + i[o + 1], i[0]);
  return new fa(t, i, ha);
}, cm = (i, e) => {
  ua ? i.adoptedStyleSheets = e.map((t) => t instanceof CSSStyleSheet ? t : t.styleSheet) : e.forEach((t) => {
    const r = document.createElement("style"), s = vs.litNonce;
    s !== void 0 && r.setAttribute("nonce", s), r.textContent = t.cssText, i.appendChild(r);
  });
}, gl = ua ? (i) => i : (i) => i instanceof CSSStyleSheet ? ((e) => {
  let t = "";
  for (const r of e.cssRules)
    t += r.cssText;
  return tt(t);
})(i) : i;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var Do;
const Ds = window, _l = Ds.trustedTypes, dm = _l ? _l.emptyScript : "", bl = Ds.reactiveElementPolyfillSupport, xn = { toAttribute(i, e) {
  switch (e) {
    case Boolean:
      i = i ? dm : null;
      break;
    case Object:
    case Array:
      i = i == null ? i : JSON.stringify(i);
  }
  return i;
}, fromAttribute(i, e) {
  let t = i;
  switch (e) {
    case Boolean:
      t = i !== null;
      break;
    case Number:
      t = i === null ? null : Number(i);
      break;
    case Object:
    case Array:
      try {
        t = JSON.parse(i);
      } catch {
        t = null;
      }
  }
  return t;
} }, Ud = (i, e) => e !== i && (e == e || i == i), Oo = { attribute: !0, type: String, converter: xn, reflect: !1, hasChanged: Ud }, Cn = "finalized";
let hr = class extends HTMLElement {
  constructor() {
    super(), this._$Ei = /* @__PURE__ */ new Map(), this.isUpdatePending = !1, this.hasUpdated = !1, this._$El = null, this._$Eu();
  }
  static addInitializer(e) {
    var t;
    this.finalize(), ((t = this.h) !== null && t !== void 0 ? t : this.h = []).push(e);
  }
  static get observedAttributes() {
    this.finalize();
    const e = [];
    return this.elementProperties.forEach((t, r) => {
      const s = this._$Ep(r, t);
      s !== void 0 && (this._$Ev.set(s, r), e.push(s));
    }), e;
  }
  static createProperty(e, t = Oo) {
    if (t.state && (t.attribute = !1), this.finalize(), this.elementProperties.set(e, t), !t.noAccessor && !this.prototype.hasOwnProperty(e)) {
      const r = typeof e == "symbol" ? Symbol() : "__" + e, s = this.getPropertyDescriptor(e, r, t);
      s !== void 0 && Object.defineProperty(this.prototype, e, s);
    }
  }
  static getPropertyDescriptor(e, t, r) {
    return { get() {
      return this[t];
    }, set(s) {
      const o = this[e];
      this[t] = s, this.requestUpdate(e, o, r);
    }, configurable: !0, enumerable: !0 };
  }
  static getPropertyOptions(e) {
    return this.elementProperties.get(e) || Oo;
  }
  static finalize() {
    if (this.hasOwnProperty(Cn))
      return !1;
    this[Cn] = !0;
    const e = Object.getPrototypeOf(this);
    if (e.finalize(), e.h !== void 0 && (this.h = [...e.h]), this.elementProperties = new Map(e.elementProperties), this._$Ev = /* @__PURE__ */ new Map(), this.hasOwnProperty("properties")) {
      const t = this.properties, r = [...Object.getOwnPropertyNames(t), ...Object.getOwnPropertySymbols(t)];
      for (const s of r)
        this.createProperty(s, t[s]);
    }
    return this.elementStyles = this.finalizeStyles(this.styles), !0;
  }
  static finalizeStyles(e) {
    const t = [];
    if (Array.isArray(e)) {
      const r = new Set(e.flat(1 / 0).reverse());
      for (const s of r)
        t.unshift(gl(s));
    } else
      e !== void 0 && t.push(gl(e));
    return t;
  }
  static _$Ep(e, t) {
    const r = t.attribute;
    return r === !1 ? void 0 : typeof r == "string" ? r : typeof e == "string" ? e.toLowerCase() : void 0;
  }
  _$Eu() {
    var e;
    this._$E_ = new Promise((t) => this.enableUpdating = t), this._$AL = /* @__PURE__ */ new Map(), this._$Eg(), this.requestUpdate(), (e = this.constructor.h) === null || e === void 0 || e.forEach((t) => t(this));
  }
  addController(e) {
    var t, r;
    ((t = this._$ES) !== null && t !== void 0 ? t : this._$ES = []).push(e), this.renderRoot !== void 0 && this.isConnected && ((r = e.hostConnected) === null || r === void 0 || r.call(e));
  }
  removeController(e) {
    var t;
    (t = this._$ES) === null || t === void 0 || t.splice(this._$ES.indexOf(e) >>> 0, 1);
  }
  _$Eg() {
    this.constructor.elementProperties.forEach((e, t) => {
      this.hasOwnProperty(t) && (this._$Ei.set(t, this[t]), delete this[t]);
    });
  }
  createRenderRoot() {
    var e;
    const t = (e = this.shadowRoot) !== null && e !== void 0 ? e : this.attachShadow(this.constructor.shadowRootOptions);
    return cm(t, this.constructor.elementStyles), t;
  }
  connectedCallback() {
    var e;
    this.renderRoot === void 0 && (this.renderRoot = this.createRenderRoot()), this.enableUpdating(!0), (e = this._$ES) === null || e === void 0 || e.forEach((t) => {
      var r;
      return (r = t.hostConnected) === null || r === void 0 ? void 0 : r.call(t);
    });
  }
  enableUpdating(e) {
  }
  disconnectedCallback() {
    var e;
    (e = this._$ES) === null || e === void 0 || e.forEach((t) => {
      var r;
      return (r = t.hostDisconnected) === null || r === void 0 ? void 0 : r.call(t);
    });
  }
  attributeChangedCallback(e, t, r) {
    this._$AK(e, r);
  }
  _$EO(e, t, r = Oo) {
    var s;
    const o = this.constructor._$Ep(e, r);
    if (o !== void 0 && r.reflect === !0) {
      const n = (((s = r.converter) === null || s === void 0 ? void 0 : s.toAttribute) !== void 0 ? r.converter : xn).toAttribute(t, r.type);
      this._$El = e, n == null ? this.removeAttribute(o) : this.setAttribute(o, n), this._$El = null;
    }
  }
  _$AK(e, t) {
    var r;
    const s = this.constructor, o = s._$Ev.get(e);
    if (o !== void 0 && this._$El !== o) {
      const n = s.getPropertyOptions(o), a = typeof n.converter == "function" ? { fromAttribute: n.converter } : ((r = n.converter) === null || r === void 0 ? void 0 : r.fromAttribute) !== void 0 ? n.converter : xn;
      this._$El = o, this[o] = a.fromAttribute(t, n.type), this._$El = null;
    }
  }
  requestUpdate(e, t, r) {
    let s = !0;
    e !== void 0 && (((r = r || this.constructor.getPropertyOptions(e)).hasChanged || Ud)(this[e], t) ? (this._$AL.has(e) || this._$AL.set(e, t), r.reflect === !0 && this._$El !== e && (this._$EC === void 0 && (this._$EC = /* @__PURE__ */ new Map()), this._$EC.set(e, r))) : s = !1), !this.isUpdatePending && s && (this._$E_ = this._$Ej());
  }
  async _$Ej() {
    this.isUpdatePending = !0;
    try {
      await this._$E_;
    } catch (t) {
      Promise.reject(t);
    }
    const e = this.scheduleUpdate();
    return e != null && await e, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var e;
    if (!this.isUpdatePending)
      return;
    this.hasUpdated, this._$Ei && (this._$Ei.forEach((s, o) => this[o] = s), this._$Ei = void 0);
    let t = !1;
    const r = this._$AL;
    try {
      t = this.shouldUpdate(r), t ? (this.willUpdate(r), (e = this._$ES) === null || e === void 0 || e.forEach((s) => {
        var o;
        return (o = s.hostUpdate) === null || o === void 0 ? void 0 : o.call(s);
      }), this.update(r)) : this._$Ek();
    } catch (s) {
      throw t = !1, this._$Ek(), s;
    }
    t && this._$AE(r);
  }
  willUpdate(e) {
  }
  _$AE(e) {
    var t;
    (t = this._$ES) === null || t === void 0 || t.forEach((r) => {
      var s;
      return (s = r.hostUpdated) === null || s === void 0 ? void 0 : s.call(r);
    }), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(e)), this.updated(e);
  }
  _$Ek() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = !1;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$E_;
  }
  shouldUpdate(e) {
    return !0;
  }
  update(e) {
    this._$EC !== void 0 && (this._$EC.forEach((t, r) => this._$EO(r, this[r], t)), this._$EC = void 0), this._$Ek();
  }
  updated(e) {
  }
  firstUpdated(e) {
  }
};
hr[Cn] = !0, hr.elementProperties = /* @__PURE__ */ new Map(), hr.elementStyles = [], hr.shadowRootOptions = { mode: "open" }, bl == null || bl({ ReactiveElement: hr }), ((Do = Ds.reactiveElementVersions) !== null && Do !== void 0 ? Do : Ds.reactiveElementVersions = []).push("1.6.3");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var $o;
const Os = window, Cr = Os.trustedTypes, yl = Cr ? Cr.createPolicy("lit-html", { createHTML: (i) => i }) : void 0, kn = "$lit$", ht = `lit$${(Math.random() + "").slice(9)}$`, qd = "?" + ht, um = `<${qd}>`, Yt = document, wi = () => Yt.createComment(""), xi = (i) => i === null || typeof i != "object" && typeof i != "function", Wd = Array.isArray, hm = (i) => Wd(i) || typeof (i == null ? void 0 : i[Symbol.iterator]) == "function", Po = `[ 	
\f\r]`, Wr = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, vl = /-->/g, wl = />/g, Dt = RegExp(`>|${Po}(?:([^\\s"'>=/]+)(${Po}*=${Po}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), xl = /'/g, Cl = /"/g, jd = /^(?:script|style|textarea|title)$/i, fm = (i) => (e, ...t) => ({ _$litType$: i, strings: e, values: t }), p = fm(1), kr = Symbol.for("lit-noChange"), b = Symbol.for("lit-nothing"), kl = /* @__PURE__ */ new WeakMap(), Vt = Yt.createTreeWalker(Yt, 129, null, !1);
function Gd(i, e) {
  if (!Array.isArray(i) || !i.hasOwnProperty("raw"))
    throw Error("invalid template strings array");
  return yl !== void 0 ? yl.createHTML(e) : e;
}
const pm = (i, e) => {
  const t = i.length - 1, r = [];
  let s, o = e === 2 ? "<svg>" : "", n = Wr;
  for (let a = 0; a < t; a++) {
    const l = i[a];
    let c, d, u = -1, h = 0;
    for (; h < l.length && (n.lastIndex = h, d = n.exec(l), d !== null); )
      h = n.lastIndex, n === Wr ? d[1] === "!--" ? n = vl : d[1] !== void 0 ? n = wl : d[2] !== void 0 ? (jd.test(d[2]) && (s = RegExp("</" + d[2], "g")), n = Dt) : d[3] !== void 0 && (n = Dt) : n === Dt ? d[0] === ">" ? (n = s ?? Wr, u = -1) : d[1] === void 0 ? u = -2 : (u = n.lastIndex - d[2].length, c = d[1], n = d[3] === void 0 ? Dt : d[3] === '"' ? Cl : xl) : n === Cl || n === xl ? n = Dt : n === vl || n === wl ? n = Wr : (n = Dt, s = void 0);
    const f = n === Dt && i[a + 1].startsWith("/>") ? " " : "";
    o += n === Wr ? l + um : u >= 0 ? (r.push(c), l.slice(0, u) + kn + l.slice(u) + ht + f) : l + ht + (u === -2 ? (r.push(void 0), a) : f);
  }
  return [Gd(i, o + (i[t] || "<?>") + (e === 2 ? "</svg>" : "")), r];
};
let An = class Yd {
  constructor({ strings: e, _$litType$: t }, r) {
    let s;
    this.parts = [];
    let o = 0, n = 0;
    const a = e.length - 1, l = this.parts, [c, d] = pm(e, t);
    if (this.el = Yd.createElement(c, r), Vt.currentNode = this.el.content, t === 2) {
      const u = this.el.content, h = u.firstChild;
      h.remove(), u.append(...h.childNodes);
    }
    for (; (s = Vt.nextNode()) !== null && l.length < a; ) {
      if (s.nodeType === 1) {
        if (s.hasAttributes()) {
          const u = [];
          for (const h of s.getAttributeNames())
            if (h.endsWith(kn) || h.startsWith(ht)) {
              const f = d[n++];
              if (u.push(h), f !== void 0) {
                const m = s.getAttribute(f.toLowerCase() + kn).split(ht), v = /([.?@])?(.*)/.exec(f);
                l.push({ type: 1, index: o, name: v[2], strings: m, ctor: v[1] === "." ? gm : v[1] === "?" ? bm : v[1] === "@" ? ym : eo });
              } else
                l.push({ type: 6, index: o });
            }
          for (const h of u)
            s.removeAttribute(h);
        }
        if (jd.test(s.tagName)) {
          const u = s.textContent.split(ht), h = u.length - 1;
          if (h > 0) {
            s.textContent = Cr ? Cr.emptyScript : "";
            for (let f = 0; f < h; f++)
              s.append(u[f], wi()), Vt.nextNode(), l.push({ type: 2, index: ++o });
            s.append(u[h], wi());
          }
        }
      } else if (s.nodeType === 8)
        if (s.data === qd)
          l.push({ type: 2, index: o });
        else {
          let u = -1;
          for (; (u = s.data.indexOf(ht, u + 1)) !== -1; )
            l.push({ type: 7, index: o }), u += ht.length - 1;
        }
      o++;
    }
  }
  static createElement(e, t) {
    const r = Yt.createElement("template");
    return r.innerHTML = e, r;
  }
};
function Ar(i, e, t = i, r) {
  var s, o, n, a;
  if (e === kr)
    return e;
  let l = r !== void 0 ? (s = t._$Co) === null || s === void 0 ? void 0 : s[r] : t._$Cl;
  const c = xi(e) ? void 0 : e._$litDirective$;
  return (l == null ? void 0 : l.constructor) !== c && ((o = l == null ? void 0 : l._$AO) === null || o === void 0 || o.call(l, !1), c === void 0 ? l = void 0 : (l = new c(i), l._$AT(i, t, r)), r !== void 0 ? ((n = (a = t)._$Co) !== null && n !== void 0 ? n : a._$Co = [])[r] = l : t._$Cl = l), l !== void 0 && (e = Ar(i, l._$AS(i, e.values), l, r)), e;
}
let mm = class {
  constructor(e, t) {
    this._$AV = [], this._$AN = void 0, this._$AD = e, this._$AM = t;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(e) {
    var t;
    const { el: { content: r }, parts: s } = this._$AD, o = ((t = e == null ? void 0 : e.creationScope) !== null && t !== void 0 ? t : Yt).importNode(r, !0);
    Vt.currentNode = o;
    let n = Vt.nextNode(), a = 0, l = 0, c = s[0];
    for (; c !== void 0; ) {
      if (a === c.index) {
        let d;
        c.type === 2 ? d = new pa(n, n.nextSibling, this, e) : c.type === 1 ? d = new c.ctor(n, c.name, c.strings, this, e) : c.type === 6 && (d = new vm(n, this, e)), this._$AV.push(d), c = s[++l];
      }
      a !== (c == null ? void 0 : c.index) && (n = Vt.nextNode(), a++);
    }
    return Vt.currentNode = Yt, o;
  }
  v(e) {
    let t = 0;
    for (const r of this._$AV)
      r !== void 0 && (r.strings !== void 0 ? (r._$AI(e, r, t), t += r.strings.length - 2) : r._$AI(e[t])), t++;
  }
}, pa = class Zd {
  constructor(e, t, r, s) {
    var o;
    this.type = 2, this._$AH = b, this._$AN = void 0, this._$AA = e, this._$AB = t, this._$AM = r, this.options = s, this._$Cp = (o = s == null ? void 0 : s.isConnected) === null || o === void 0 || o;
  }
  get _$AU() {
    var e, t;
    return (t = (e = this._$AM) === null || e === void 0 ? void 0 : e._$AU) !== null && t !== void 0 ? t : this._$Cp;
  }
  get parentNode() {
    let e = this._$AA.parentNode;
    const t = this._$AM;
    return t !== void 0 && (e == null ? void 0 : e.nodeType) === 11 && (e = t.parentNode), e;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(e, t = this) {
    e = Ar(this, e, t), xi(e) ? e === b || e == null || e === "" ? (this._$AH !== b && this._$AR(), this._$AH = b) : e !== this._$AH && e !== kr && this._(e) : e._$litType$ !== void 0 ? this.g(e) : e.nodeType !== void 0 ? this.$(e) : hm(e) ? this.T(e) : this._(e);
  }
  k(e) {
    return this._$AA.parentNode.insertBefore(e, this._$AB);
  }
  $(e) {
    this._$AH !== e && (this._$AR(), this._$AH = this.k(e));
  }
  _(e) {
    this._$AH !== b && xi(this._$AH) ? this._$AA.nextSibling.data = e : this.$(Yt.createTextNode(e)), this._$AH = e;
  }
  g(e) {
    var t;
    const { values: r, _$litType$: s } = e, o = typeof s == "number" ? this._$AC(e) : (s.el === void 0 && (s.el = An.createElement(Gd(s.h, s.h[0]), this.options)), s);
    if (((t = this._$AH) === null || t === void 0 ? void 0 : t._$AD) === o)
      this._$AH.v(r);
    else {
      const n = new mm(o, this), a = n.u(this.options);
      n.v(r), this.$(a), this._$AH = n;
    }
  }
  _$AC(e) {
    let t = kl.get(e.strings);
    return t === void 0 && kl.set(e.strings, t = new An(e)), t;
  }
  T(e) {
    Wd(this._$AH) || (this._$AH = [], this._$AR());
    const t = this._$AH;
    let r, s = 0;
    for (const o of e)
      s === t.length ? t.push(r = new Zd(this.k(wi()), this.k(wi()), this, this.options)) : r = t[s], r._$AI(o), s++;
    s < t.length && (this._$AR(r && r._$AB.nextSibling, s), t.length = s);
  }
  _$AR(e = this._$AA.nextSibling, t) {
    var r;
    for ((r = this._$AP) === null || r === void 0 || r.call(this, !1, !0, t); e && e !== this._$AB; ) {
      const s = e.nextSibling;
      e.remove(), e = s;
    }
  }
  setConnected(e) {
    var t;
    this._$AM === void 0 && (this._$Cp = e, (t = this._$AP) === null || t === void 0 || t.call(this, e));
  }
}, eo = class {
  constructor(e, t, r, s, o) {
    this.type = 1, this._$AH = b, this._$AN = void 0, this.element = e, this.name = t, this._$AM = s, this.options = o, r.length > 2 || r[0] !== "" || r[1] !== "" ? (this._$AH = Array(r.length - 1).fill(new String()), this.strings = r) : this._$AH = b;
  }
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(e, t = this, r, s) {
    const o = this.strings;
    let n = !1;
    if (o === void 0)
      e = Ar(this, e, t, 0), n = !xi(e) || e !== this._$AH && e !== kr, n && (this._$AH = e);
    else {
      const a = e;
      let l, c;
      for (e = o[0], l = 0; l < o.length - 1; l++)
        c = Ar(this, a[r + l], t, l), c === kr && (c = this._$AH[l]), n || (n = !xi(c) || c !== this._$AH[l]), c === b ? e = b : e !== b && (e += (c ?? "") + o[l + 1]), this._$AH[l] = c;
    }
    n && !s && this.j(e);
  }
  j(e) {
    e === b ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, e ?? "");
  }
}, gm = class extends eo {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(e) {
    this.element[this.name] = e === b ? void 0 : e;
  }
};
const _m = Cr ? Cr.emptyScript : "";
let bm = class extends eo {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(e) {
    e && e !== b ? this.element.setAttribute(this.name, _m) : this.element.removeAttribute(this.name);
  }
}, ym = class extends eo {
  constructor(e, t, r, s, o) {
    super(e, t, r, s, o), this.type = 5;
  }
  _$AI(e, t = this) {
    var r;
    if ((e = (r = Ar(this, e, t, 0)) !== null && r !== void 0 ? r : b) === kr)
      return;
    const s = this._$AH, o = e === b && s !== b || e.capture !== s.capture || e.once !== s.once || e.passive !== s.passive, n = e !== b && (s === b || o);
    o && this.element.removeEventListener(this.name, this, s), n && this.element.addEventListener(this.name, this, e), this._$AH = e;
  }
  handleEvent(e) {
    var t, r;
    typeof this._$AH == "function" ? this._$AH.call((r = (t = this.options) === null || t === void 0 ? void 0 : t.host) !== null && r !== void 0 ? r : this.element, e) : this._$AH.handleEvent(e);
  }
}, vm = class {
  constructor(e, t, r) {
    this.element = e, this.type = 6, this._$AN = void 0, this._$AM = t, this.options = r;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(e) {
    Ar(this, e);
  }
};
const Al = Os.litHtmlPolyfillSupport;
Al == null || Al(An, pa), (($o = Os.litHtmlVersions) !== null && $o !== void 0 ? $o : Os.litHtmlVersions = []).push("2.8.0");
const Kd = (i, e, t) => {
  var r, s;
  const o = (r = t == null ? void 0 : t.renderBefore) !== null && r !== void 0 ? r : e;
  let n = o._$litPart$;
  if (n === void 0) {
    const a = (s = t == null ? void 0 : t.renderBefore) !== null && s !== void 0 ? s : null;
    o._$litPart$ = n = new pa(e.insertBefore(wi(), a), a, void 0, t ?? {});
  }
  return n._$AI(i), n;
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var Mo, zo;
let _t = class extends hr {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    var e, t;
    const r = super.createRenderRoot();
    return (e = (t = this.renderOptions).renderBefore) !== null && e !== void 0 || (t.renderBefore = r.firstChild), r;
  }
  update(e) {
    const t = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(e), this._$Do = Kd(t, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    var e;
    super.connectedCallback(), (e = this._$Do) === null || e === void 0 || e.setConnected(!0);
  }
  disconnectedCallback() {
    var e;
    super.disconnectedCallback(), (e = this._$Do) === null || e === void 0 || e.setConnected(!1);
  }
  render() {
    return kr;
  }
};
_t.finalized = !0, _t._$litElement$ = !0, (Mo = globalThis.litElementHydrateSupport) === null || Mo === void 0 || Mo.call(globalThis, { LitElement: _t });
const El = globalThis.litElementPolyfillSupport;
El == null || El({ LitElement: _t });
((zo = globalThis.litElementVersions) !== null && zo !== void 0 ? zo : globalThis.litElementVersions = []).push("3.3.3");
const Qd = 2, En = 3;
class Jd extends _t {
  constructor() {
    super(), this.kiosk_base_url = "/", this.appErrors = [], this.apiContext = void 0, this.showProgress = !1;
  }
  onAppMessage(e) {
    this.addAppError(e.detail.headline + "<br>" + e.detail.body);
  }
  firstUpdated(e) {
    super.firstUpdated(e), this.addEventListener("send-message", this.onAppMessage);
  }
  updated(e) {
    e.has("apiContext") && (this.showProgress = !1, this.apiContext && this.apiContext.status === En && this.addAppError("Cannot connect to Kiosk API."), !e.apiContext && this.apiContext && this.apiConnected());
  }
  apiConnected() {
  }
  render() {
    let e;
    return this.apiContext && this.apiContext.status === Qd ? e = this.apiRender() : this.apiContext && this.apiContext.status === En ? e = this.renderApiError() : e = this.renderNoContextYet(), p`
            <style>
                .system-message {
                    border-style: solid;
                    border-width: 2px;
                    padding: 2px 1em;
                    position: relative;
                    margin-bottom: 10px;
                    background: linear-gradient(135deg, #882501, #bb3302);
                    color: #fabc02;
                }
                .loading {
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    height: 5px;
                    width: 100vw;
                    background-color: black;
                }
                .loading-progress {
                    height: 5px;
                    width: 100%;
                    border-radius: 3px;
                    background: linear-gradient(
                        90deg,
                        red 0%,
                        yellow 15%,
                        lime 30%,
                        cyan 50%,
                        blue 65%,
                        magenta 80%,
                        red 100%
                    );
                    background-size: 200%;
                    animation: move-gradient 2s ease-in infinite;
                }
                @keyframes move-gradient {
                    0% {
                        background-position: 0% 0%;
                    }
                    100% {
                        background-position: -200% 0%;
                    }
                }
            </style>
            <link rel="stylesheet" href="${this.kiosk_base_url}static/styles.css" />
            ${this.renderProgress()} ${this.renderErrors()} ${e}
        `;
  }
  renderNoContextYet() {
    return p` <link rel="stylesheet" href="${this.kiosk_base_url}static/styles.css" /> `;
  }
  renderApiError() {
  }
  renderErrors() {
    if (this.appErrors.length > 0)
      return p` ${this.appErrors.map((e) => p`<div class="system-message" @click="${this.errorClicked}">${e}</div>`)} `;
  }
  errorClicked(e) {
    this.deleteError(e.target.textContent);
  }
  renderProgress(e = !1) {
    if (e || this.showProgress)
      return p` <div class="loading">
                <div class="loading-progress"></div>
            </div>`;
  }
  addAppError(e) {
    this.appErrors.push(e), this.requestUpdate();
  }
  deleteError(e) {
    let t = -1;
    this.appErrors.find((r, s) => r === e ? (t = s, !0) : !1), t > -1 && (this.appErrors.splice(t, 1), this.appErrors = [...this.appErrors]);
  }
}
Jd.properties = {
  /**
   * The Api Context
   */
  apiContext: { type: Object },
  appErrors: { type: Array },
  showProgress: { type: Boolean }
};
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Xd = Symbol.for(""), wm = (i) => {
  if ((i == null ? void 0 : i.r) === Xd)
    return i == null ? void 0 : i._$litStatic$;
}, xm = (i, ...e) => ({ _$litStatic$: e.reduce((t, r, s) => t + ((o) => {
  if (o._$litStatic$ !== void 0)
    return o._$litStatic$;
  throw Error(`Value passed to 'literal' function must be a 'literal' result: ${o}. Use 'unsafeStatic' to pass non-literal values, but
            take care to ensure page security.`);
})(r) + i[s + 1], i[0]), r: Xd }), Sl = /* @__PURE__ */ new Map(), Cm = (i) => (e, ...t) => {
  const r = t.length;
  let s, o;
  const n = [], a = [];
  let l, c = 0, d = !1;
  for (; c < r; ) {
    for (l = e[c]; c < r && (o = t[c], (s = wm(o)) !== void 0); )
      l += s + e[++c], d = !0;
    c !== r && a.push(o), n.push(l), c++;
  }
  if (c === r && n.push(e[r]), d) {
    const u = n.join("$$lit$$");
    (e = Sl.get(u)) === void 0 && (n.raw = n, Sl.set(u, e = n)), t = a;
  }
  return i(e, ...t);
}, te = Cm(p);
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
let eu = class extends Event {
  constructor(e, t, r) {
    super("context-request", { bubbles: !0, composed: !0 }), this.context = e, this.callback = t, this.subscribe = r != null && r;
  }
};
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
let km = class {
  constructor(e, t, r, s) {
    var o;
    if (this.subscribe = !1, this.provided = !1, this.value = void 0, this.t = (n, a) => {
      this.unsubscribe && (this.unsubscribe !== a && (this.provided = !1, this.unsubscribe()), this.subscribe || this.unsubscribe()), this.value = n, this.host.requestUpdate(), this.provided && !this.subscribe || (this.provided = !0, this.callback && this.callback(n, a)), this.unsubscribe = a;
    }, this.host = e, t.context !== void 0) {
      const n = t;
      this.context = n.context, this.callback = n.callback, this.subscribe = (o = n.subscribe) !== null && o !== void 0 && o;
    } else
      this.context = t, this.callback = r, this.subscribe = s != null && s;
    this.host.addController(this);
  }
  hostConnected() {
    this.dispatchRequest();
  }
  hostDisconnected() {
    this.unsubscribe && (this.unsubscribe(), this.unsubscribe = void 0);
  }
  dispatchRequest() {
    this.host.dispatchEvent(new eu(this.context, this.t, this.subscribe));
  }
};
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
let Am = class {
  constructor(e) {
    this.subscriptions = /* @__PURE__ */ new Map(), this.updateObservers = () => {
      for (const [t, { disposer: r }] of this.subscriptions)
        t(this.o, r);
    }, e !== void 0 && (this.value = e);
  }
  get value() {
    return this.o;
  }
  set value(e) {
    this.setValue(e);
  }
  setValue(e, t = !1) {
    const r = t || !Object.is(e, this.o);
    this.o = e, r && this.updateObservers();
  }
  addCallback(e, t, r) {
    if (!r)
      return void e(this.value);
    this.subscriptions.has(e) || this.subscriptions.set(e, { disposer: () => {
      this.subscriptions.delete(e);
    }, consumerHost: t });
    const { disposer: s } = this.subscriptions.get(e);
    e(this.value, s);
  }
  clearCallbacks() {
    this.subscriptions.clear();
  }
};
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
let Em = class extends Event {
  constructor(e) {
    super("context-provider", { bubbles: !0, composed: !0 }), this.context = e;
  }
}, Sm = class extends Am {
  constructor(e, t, r) {
    super(t.context !== void 0 ? t.initialValue : r), this.onContextRequest = (s) => {
      const o = s.composedPath()[0];
      s.context === this.context && o !== this.host && (s.stopPropagation(), this.addCallback(s.callback, o, s.subscribe));
    }, this.onProviderRequest = (s) => {
      const o = s.composedPath()[0];
      if (s.context !== this.context || o === this.host)
        return;
      const n = /* @__PURE__ */ new Set();
      for (const [a, { consumerHost: l }] of this.subscriptions)
        n.has(a) || (n.add(a), l.dispatchEvent(new eu(this.context, a, !0)));
      s.stopPropagation();
    }, this.host = e, t.context !== void 0 ? this.context = t.context : this.context = t, this.attachListeners(), this.host.addController(this);
  }
  attachListeners() {
    this.host.addEventListener("context-request", this.onContextRequest), this.host.addEventListener("context-provider", this.onProviderRequest);
  }
  hostConnected() {
    this.host.dispatchEvent(new Em(this.context));
  }
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const ma = ({ finisher: i, descriptor: e }) => (t, r) => {
  var s;
  if (r === void 0) {
    const o = (s = t.originalKey) !== null && s !== void 0 ? s : t.key, n = e != null ? { kind: "method", placement: "prototype", key: o, descriptor: e(t.key) } : { ...t, key: o };
    return i != null && (n.finisher = function(a) {
      i(a, o);
    }), n;
  }
  {
    const o = t.constructor;
    e !== void 0 && Object.defineProperty(t, r, e(r)), i == null || i(o, r);
  }
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function tu({ context: i }) {
  return ma({ finisher: (e, t) => {
    const r = /* @__PURE__ */ new WeakMap();
    e.addInitializer((a) => {
      r.set(a, new Sm(a, { context: i }));
    });
    const s = Object.getOwnPropertyDescriptor(e.prototype, t), o = s == null ? void 0 : s.set, n = { ...s, set: function(a) {
      var l;
      (l = r.get(this)) === null || l === void 0 || l.setValue(a), o && o.call(this, a);
    } };
    Object.defineProperty(e.prototype, t, n);
  } });
}
/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function to({ context: i, subscribe: e }) {
  return ma({ finisher: (t, r) => {
    t.addInitializer((s) => {
      new km(s, { context: i, callback: (o) => {
        s[r] = o;
      }, subscribe: e });
    });
  } });
}
const ro = "constants";
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Qt = (i) => (e) => typeof e == "function" ? ((t, r) => (customElements.define(t, r), r))(i, e) : ((t, r) => {
  const { kind: s, elements: o } = r;
  return { kind: s, elements: o, finisher(n) {
    customElements.define(t, n);
  } };
})(i, e);
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Tm = (i, e) => e.kind === "method" && e.descriptor && !("value" in e.descriptor) ? { ...e, finisher(t) {
  t.createProperty(e.key, i);
} } : { kind: "field", key: Symbol(), placement: "own", descriptor: {}, originalKey: e.key, initializer() {
  typeof e.initializer == "function" && (this[e.key] = e.initializer.call(this));
}, finisher(t) {
  t.createProperty(e.key, i);
} }, Im = (i, e, t) => {
  e.constructor.createProperty(t, i);
};
function G(i) {
  return (e, t) => t !== void 0 ? Im(i, e, t) : Tm(i, e);
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function z(i) {
  return G({ ...i, state: !0 });
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function Dm(i, e) {
  return ma({ descriptor: (t) => {
    const r = { get() {
      var s, o;
      return (o = (s = this.renderRoot) === null || s === void 0 ? void 0 : s.querySelector(i)) !== null && o !== void 0 ? o : null;
    }, enumerable: !0, configurable: !0 };
    if (e) {
      const s = typeof t == "symbol" ? Symbol() : "__" + t;
      r.get = function() {
        var o, n;
        return this[s] === void 0 && (this[s] = (n = (o = this.renderRoot) === null || o === void 0 ? void 0 : o.querySelector(i)) !== null && n !== void 0 ? n : null), this[s];
      };
    }
    return r;
  } });
}
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var No;
((No = window.HTMLSlotElement) === null || No === void 0 ? void 0 : No.prototype.assignedElements) != null;
const Om = `.col-bg-body-lighter{background-color:var(--col-bg-body-lighter)}.col-bg-body{background-color:var(--col-bg-body)}.col-bg-body-darker{background-color:var(--col-bg-body-darker)}.col-bg-1-lighter{background-color:var(--col-bg-1-lighter)}.col-bg-1{background-color:var(--col-bg-1)}.col-bg-1-darker{background-color:var(--col-bg-1-darker)}.col-bg-1-input{background-color:var(--col-bg-1-input)}.col-primary-bg-1{background-color:var(--col-primary-bg-1)}.col-accent-bg-1{background-color:var(--col-accent-bg-1)}.col-success-bg-1{background-color:var(--col-success-bg-1)}.col-warning-bg-1{background-color:var(--col-warning-bg-1)}.col-error-bg-1{background-color:var(--col-error-bg-1)}.col-bg-2-lighter{background-color:var(--col-bg-2-lighter)}.col-bg-2{background-color:var(--col-bg-2)}.col-bg-2-darker{background-color:var(--col-bg-2-darker)}.col-bg-2-button{background-color:var(--col-bg-2-button)}.col-bg-2-input{background-color:var(--col-bg-2-input)}.col-primary-bg-2{background-color:var(--col-primary-bg-2)}.col-accent-bg-2{background-color:var(--col-accent-bg-2)}.col-success-bg-2{background-color:var(--col-success-bg-2)}.col-warning-bg-2{background-color:var(--col-warning-bg-2)}.col-error-bg-2{background-color:var(--col-error-bg-2)}.col-bg-3-lighter{background-color:var(--col-bg-3-lighter)}.col-bg-3{background-color:var(--col-bg-3)}.col-bg-3-darker{background-color:var(--col-bg-3-darker)}.col-bg-3-button{background-color:var(--col-bg-3-button)}.col-bg-3-input{background-color:var(--col-bg-3-input)}.col-primary-bg-3{background-color:var(--col-primary-bg-3)}.col-accent-bg-3{background-color:var(--col-accent-bg-3)}.col-success-bg-3{background-color:var(--col-success-bg-3)}.col-warning-bg-3{background-color:var(--col-warning-bg-3)}.col-error-bg-3{background-color:var(--col-error-bg-3)}.col-bg-ack-lighter{background-color:var(--col-bg-ack-lighter)}.col-bg-ack{background-color:var(--col-bg-ack)}.col-bg-ack-darker{background-color:var(--col-bg-ack-darker)}.col-primary-bg-ack{background-color:var(--col-primary-bg-ack)}.col-accent-bg-ack{background-color:var(--col-accent-bg-ack)}.col-bg-att-lighter{background-color:var(--col-bg-att-lighter)}.col-bg-att{background-color:var(--col-bg-att)}.col-bg-att-darker{background-color:var(--col-bg-att-darker)}.col-primary-bg-att{background-color:var(--col-primary-bg-att)}.col-accent-bg-att{background-color:var(--col-accent-bg-att)}.col-bg-alert-lighter{background-color:var(--col-bg-alert-lighter)}.col-bg-alert{background-color:var(--col-bg-alert)}.col-bg-alert-darker{background-color:var(--col-bg-alert-darker)}.col-primary-bg-alert{background-color:var(--col-primary-bg-alert)}.col-accent-bg-alert{background-color:var(--col-accent-bg-alert)}.col-bg-btn-lighter{background-color:var(--col-bg-btn-lighter)}.col-bg-btn{background-color:var(--col-bg-btn)}.col-bg-btn-darker{background-color:var(--col-bg-btn-darker)}.col-primary-bg-btn{background-color:var(--col-primary-bg-btn)}.col-accent-bg-btn{background-color:var(--col-accent-bg-btn)}.pattern-diagonal-stripes-sm{background:repeating-linear-gradient(45deg,transparent,transparent 10px,currentColor 10px,currentColor 20px)}.pattern-dots-lg{background-image:radial-gradient(currentColor 1.5px,transparent 1.5px);background-size:15px 15px}.pattern-dots-md{background-image:radial-gradient(currentColor 1px,transparent 1px);background-size:8px 8px}.pattern-dots-medium-dense{background-image:radial-gradient(currentColor .5px,transparent .5px);background-size:3px 3px}.pattern-dots-sm{background-image:radial-gradient(currentColor .5px,transparent .5px);background-size:5px 5px}.pattern-cross-dots-md,.imagelist-background{background-image:radial-gradient(currentColor .7px,transparent 1px),radial-gradient(currentColor .7px,transparent 1px);background-size:6.5px 6.5px;background-position:0 0,3.5px 3.5px}.imagelist-background{background-color:#fff9;background-blend-mode:overlay}*{box-sizing:border-box}.loading{display:flex;justify-content:center;align-content:center;height:5px;background-color:#000;width:100%}.loading-progress{height:5px;width:100%;border-radius:3px;background:linear-gradient(90deg,red 0%,yellow 15%,lime 30%,cyan 50%,blue 65%,magenta 80%,red 100%);background-size:200%;animation:move-gradient 2s ease-in infinite}.loading-message{font-family:var(--monospace-font);text-align:center;width:100%;color:var(--col-accent-bg-1);padding:1em}@keyframes move-gradient{0%{background-position:0 0}to{background-position:-200% 0%}}p,div{padding:0;margin:0;border:0px;-webkit-user-select:text;user-select:text}select{-webkit-user-select:none;user-select:none}.fa,.fas{font-family:"Font Awesome 6 Free";font-weight:900;font-style:normal}.fa-trash:before{content:""}.fa-view-grid:before{content:""}.fa-reload:before{content:""}.fa-view-list:before{content:""}.fa-camera:before{content:""}.fa-view-image:before{content:""}.fa-check:before{content:""}.fa-bug:before{content:""}.fa-lightbulb:before{content:""}.fa-query:before{content:""}.fa-footsteps{transform:rotate(270deg)}.fa-footsteps:before{content:""}i{font-family:"Font Awesome 6 Free";font-style:normal;font-variant:normal;text-rendering:auto;-webkit-font-smoothing:antialiased;font-weight:900;font-size:.9em}:host *{-webkit-user-select:none;user-select:none}.query-selector-overlay{position:fixed;min-width:100%;min-height:100%;top:0;left:0;right:0;bottom:0;background-color:#00000080;z-index:2;cursor:pointer}.query-selector{position:relative;background-color:var(--col-bg-1);margin:2em;min-height:200px;width:calc(100% - 4em);z-index:3;padding:1em;-webkit-user-select:none;user-select:none;overflow-y:auto}.kiosk-query-selector-title-bar{position:sticky;top:0;text-align:right;z-index:2}.kiosk-query-selector-title-bar i{line-height:var(--font-size-h3);font-size:var(--font-size-h3)}.kiosk-query-selector-title-bar i:hover{color:var(--col-accent-bg-1)}.kiosk-query-selector-headline{position:sticky;background-color:var(--col-bg-1);top:0;display:flex;align-items:center;border-bottom:1px solid var(--col-bg-1-darker);padding-bottom:1em;margin-bottom:1em}.kiosk-query-selector-headline h3{margin-left:.5em}.kiosk-query-selector-headline i{font-size:var(--font-size-h2)}#kiosk-query-list{display:grid;width:100%;grid-template-columns:repeat(auto-fill,minmax(350px,1fr));grid-column-gap:1em;grid-row-gap:.3em}.kiosk-query{display:flex;align-items:center;padding-bottom:.2em;margin-bottom:.2em;color:var(--col-primary-bg-1)}.kiosk-query:hover{color:var(--col-accent-bg-1)}.kiosk-query:active{background-color:var(--col-bg-1-darker)}.kiosk-query i{font-size:var(--font-size-h3)}.kiosk-query .kiosk-query-text{margin-left:1em;display:flex;flex-direction:column}.kiosk-query .kiosk-query-text div{color:inherit;font-size:var(--font-size-standard, 1rem)}.kiosk-query .kiosk-query-text div:first-child{font-size:var(--font-size-h4);font-weight:700}
`, Fo = "MSG_NETWORK_ERROR";
class $m {
  constructor(e, t, r = "") {
    this.messageId = e, this.headline = t, this.body = r;
  }
}
function Ro(i, e, t, r = "") {
  let s = new $m(
    e,
    t,
    r
  );
  i.dispatchEvent(new CustomEvent(
    "send-message",
    { bubbles: !0, composed: !0, detail: s }
  ));
}
class Jt extends Error {
}
class Pm extends Jt {
  constructor(e) {
    super(`Invalid DateTime: ${e.toMessage()}`);
  }
}
class Mm extends Jt {
  constructor(e) {
    super(`Invalid Interval: ${e.toMessage()}`);
  }
}
class zm extends Jt {
  constructor(e) {
    super(`Invalid Duration: ${e.toMessage()}`);
  }
}
class ii extends Jt {
}
class ru extends Jt {
  constructor(e) {
    super(`Invalid unit ${e}`);
  }
}
class xe extends Jt {
}
class ot extends Jt {
  constructor() {
    super("Zone is an abstract class");
  }
}
const g = "numeric", Ve = "short", ge = "long", $s = {
  year: g,
  month: g,
  day: g
}, iu = {
  year: g,
  month: Ve,
  day: g
}, Nm = {
  year: g,
  month: Ve,
  day: g,
  weekday: Ve
}, su = {
  year: g,
  month: ge,
  day: g
}, ou = {
  year: g,
  month: ge,
  day: g,
  weekday: ge
}, nu = {
  hour: g,
  minute: g
}, au = {
  hour: g,
  minute: g,
  second: g
}, lu = {
  hour: g,
  minute: g,
  second: g,
  timeZoneName: Ve
}, cu = {
  hour: g,
  minute: g,
  second: g,
  timeZoneName: ge
}, du = {
  hour: g,
  minute: g,
  hourCycle: "h23"
}, uu = {
  hour: g,
  minute: g,
  second: g,
  hourCycle: "h23"
}, hu = {
  hour: g,
  minute: g,
  second: g,
  hourCycle: "h23",
  timeZoneName: Ve
}, fu = {
  hour: g,
  minute: g,
  second: g,
  hourCycle: "h23",
  timeZoneName: ge
}, pu = {
  year: g,
  month: g,
  day: g,
  hour: g,
  minute: g
}, mu = {
  year: g,
  month: g,
  day: g,
  hour: g,
  minute: g,
  second: g
}, gu = {
  year: g,
  month: Ve,
  day: g,
  hour: g,
  minute: g
}, _u = {
  year: g,
  month: Ve,
  day: g,
  hour: g,
  minute: g,
  second: g
}, Fm = {
  year: g,
  month: Ve,
  day: g,
  weekday: Ve,
  hour: g,
  minute: g
}, bu = {
  year: g,
  month: ge,
  day: g,
  hour: g,
  minute: g,
  timeZoneName: Ve
}, yu = {
  year: g,
  month: ge,
  day: g,
  hour: g,
  minute: g,
  second: g,
  timeZoneName: Ve
}, vu = {
  year: g,
  month: ge,
  day: g,
  weekday: ge,
  hour: g,
  minute: g,
  timeZoneName: ge
}, wu = {
  year: g,
  month: ge,
  day: g,
  weekday: ge,
  hour: g,
  minute: g,
  second: g,
  timeZoneName: ge
};
class zi {
  /**
   * The type of zone
   * @abstract
   * @type {string}
   */
  get type() {
    throw new ot();
  }
  /**
   * The name of this zone.
   * @abstract
   * @type {string}
   */
  get name() {
    throw new ot();
  }
  get ianaName() {
    return this.name;
  }
  /**
   * Returns whether the offset is known to be fixed for the whole year.
   * @abstract
   * @type {boolean}
   */
  get isUniversal() {
    throw new ot();
  }
  /**
   * Returns the offset's common name (such as EST) at the specified timestamp
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the name
   * @param {Object} opts - Options to affect the format
   * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
   * @param {string} opts.locale - What locale to return the offset name in.
   * @return {string}
   */
  offsetName(e, t) {
    throw new ot();
  }
  /**
   * Returns the offset's value as a string
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the offset
   * @param {string} format - What style of offset to return.
   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
   * @return {string}
   */
  formatOffset(e, t) {
    throw new ot();
  }
  /**
   * Return the offset in minutes for this zone at the specified timestamp.
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to compute the offset
   * @return {number}
   */
  offset(e) {
    throw new ot();
  }
  /**
   * Return whether this Zone is equal to another zone
   * @abstract
   * @param {Zone} otherZone - the zone to compare
   * @return {boolean}
   */
  equals(e) {
    throw new ot();
  }
  /**
   * Return whether this Zone is valid.
   * @abstract
   * @type {boolean}
   */
  get isValid() {
    throw new ot();
  }
}
let Lo = null;
class io extends zi {
  /**
   * Get a singleton instance of the local zone
   * @return {SystemZone}
   */
  static get instance() {
    return Lo === null && (Lo = new io()), Lo;
  }
  /** @override **/
  get type() {
    return "system";
  }
  /** @override **/
  get name() {
    return new Intl.DateTimeFormat().resolvedOptions().timeZone;
  }
  /** @override **/
  get isUniversal() {
    return !1;
  }
  /** @override **/
  offsetName(e, { format: t, locale: r }) {
    return Cu(e, t, r);
  }
  /** @override **/
  formatOffset(e, t) {
    return di(this.offset(e), t);
  }
  /** @override **/
  offset(e) {
    return -new Date(e).getTimezoneOffset();
  }
  /** @override **/
  equals(e) {
    return e.type === "system";
  }
  /** @override **/
  get isValid() {
    return !0;
  }
}
let ws = {};
function Rm(i) {
  return ws[i] || (ws[i] = new Intl.DateTimeFormat("en-US", {
    hour12: !1,
    timeZone: i,
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
    era: "short"
  })), ws[i];
}
const Lm = {
  year: 0,
  month: 1,
  day: 2,
  era: 3,
  hour: 4,
  minute: 5,
  second: 6
};
function Vm(i, e) {
  const t = i.format(e).replace(/\u200E/g, ""), r = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(t), [, s, o, n, a, l, c, d] = r;
  return [n, s, o, a, l, c, d];
}
function Hm(i, e) {
  const t = i.formatToParts(e), r = [];
  for (let s = 0; s < t.length; s++) {
    const { type: o, value: n } = t[s], a = Lm[o];
    o === "era" ? r[a] = n : E(a) || (r[a] = parseInt(n, 10));
  }
  return r;
}
let es = {};
class Je extends zi {
  /**
   * @param {string} name - Zone name
   * @return {IANAZone}
   */
  static create(e) {
    return es[e] || (es[e] = new Je(e)), es[e];
  }
  /**
   * Reset local caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCache() {
    es = {}, ws = {};
  }
  /**
   * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.
   * @param {string} s - The string to check validity on
   * @example IANAZone.isValidSpecifier("America/New_York") //=> true
   * @example IANAZone.isValidSpecifier("Sport~~blorp") //=> false
   * @deprecated This method returns false for some valid IANA names. Use isValidZone instead.
   * @return {boolean}
   */
  static isValidSpecifier(e) {
    return this.isValidZone(e);
  }
  /**
   * Returns whether the provided string identifies a real zone
   * @param {string} zone - The string to check
   * @example IANAZone.isValidZone("America/New_York") //=> true
   * @example IANAZone.isValidZone("Fantasia/Castle") //=> false
   * @example IANAZone.isValidZone("Sport~~blorp") //=> false
   * @return {boolean}
   */
  static isValidZone(e) {
    if (!e)
      return !1;
    try {
      return new Intl.DateTimeFormat("en-US", { timeZone: e }).format(), !0;
    } catch {
      return !1;
    }
  }
  constructor(e) {
    super(), this.zoneName = e, this.valid = Je.isValidZone(e);
  }
  /** @override **/
  get type() {
    return "iana";
  }
  /** @override **/
  get name() {
    return this.zoneName;
  }
  /** @override **/
  get isUniversal() {
    return !1;
  }
  /** @override **/
  offsetName(e, { format: t, locale: r }) {
    return Cu(e, t, r, this.name);
  }
  /** @override **/
  formatOffset(e, t) {
    return di(this.offset(e), t);
  }
  /** @override **/
  offset(e) {
    const t = new Date(e);
    if (isNaN(t))
      return NaN;
    const r = Rm(this.name);
    let [s, o, n, a, l, c, d] = r.formatToParts ? Hm(r, t) : Vm(r, t);
    a === "BC" && (s = -Math.abs(s) + 1);
    const h = oo({
      year: s,
      month: o,
      day: n,
      hour: l === 24 ? 0 : l,
      minute: c,
      second: d,
      millisecond: 0
    });
    let f = +t;
    const m = f % 1e3;
    return f -= m >= 0 ? m : 1e3 + m, (h - f) / (60 * 1e3);
  }
  /** @override **/
  equals(e) {
    return e.type === "iana" && e.name === this.name;
  }
  /** @override **/
  get isValid() {
    return this.valid;
  }
}
let Tl = {};
function Bm(i, e = {}) {
  const t = JSON.stringify([i, e]);
  let r = Tl[t];
  return r || (r = new Intl.ListFormat(i, e), Tl[t] = r), r;
}
let Sn = {};
function Tn(i, e = {}) {
  const t = JSON.stringify([i, e]);
  let r = Sn[t];
  return r || (r = new Intl.DateTimeFormat(i, e), Sn[t] = r), r;
}
let In = {};
function Um(i, e = {}) {
  const t = JSON.stringify([i, e]);
  let r = In[t];
  return r || (r = new Intl.NumberFormat(i, e), In[t] = r), r;
}
let Dn = {};
function qm(i, e = {}) {
  const { base: t, ...r } = e, s = JSON.stringify([i, r]);
  let o = Dn[s];
  return o || (o = new Intl.RelativeTimeFormat(i, e), Dn[s] = o), o;
}
let si = null;
function Wm() {
  return si || (si = new Intl.DateTimeFormat().resolvedOptions().locale, si);
}
function jm(i) {
  const e = i.indexOf("-x-");
  e !== -1 && (i = i.substring(0, e));
  const t = i.indexOf("-u-");
  if (t === -1)
    return [i];
  {
    let r, s;
    try {
      r = Tn(i).resolvedOptions(), s = i;
    } catch {
      const l = i.substring(0, t);
      r = Tn(l).resolvedOptions(), s = l;
    }
    const { numberingSystem: o, calendar: n } = r;
    return [s, o, n];
  }
}
function Gm(i, e, t) {
  return (t || e) && (i.includes("-u-") || (i += "-u"), t && (i += `-ca-${t}`), e && (i += `-nu-${e}`)), i;
}
function Ym(i) {
  const e = [];
  for (let t = 1; t <= 12; t++) {
    const r = x.utc(2009, t, 1);
    e.push(i(r));
  }
  return e;
}
function Zm(i) {
  const e = [];
  for (let t = 1; t <= 7; t++) {
    const r = x.utc(2016, 11, 13 + t);
    e.push(i(r));
  }
  return e;
}
function ts(i, e, t, r) {
  const s = i.listingMode();
  return s === "error" ? null : s === "en" ? t(e) : r(e);
}
function Km(i) {
  return i.numberingSystem && i.numberingSystem !== "latn" ? !1 : i.numberingSystem === "latn" || !i.locale || i.locale.startsWith("en") || new Intl.DateTimeFormat(i.intl).resolvedOptions().numberingSystem === "latn";
}
class Qm {
  constructor(e, t, r) {
    this.padTo = r.padTo || 0, this.floor = r.floor || !1;
    const { padTo: s, floor: o, ...n } = r;
    if (!t || Object.keys(n).length > 0) {
      const a = { useGrouping: !1, ...r };
      r.padTo > 0 && (a.minimumIntegerDigits = r.padTo), this.inf = Um(e, a);
    }
  }
  format(e) {
    if (this.inf) {
      const t = this.floor ? Math.floor(e) : e;
      return this.inf.format(t);
    } else {
      const t = this.floor ? Math.floor(e) : _a(e, 3);
      return Q(t, this.padTo);
    }
  }
}
class Jm {
  constructor(e, t, r) {
    this.opts = r, this.originalZone = void 0;
    let s;
    if (this.opts.timeZone)
      this.dt = e;
    else if (e.zone.type === "fixed") {
      const n = -1 * (e.offset / 60), a = n >= 0 ? `Etc/GMT+${n}` : `Etc/GMT${n}`;
      e.offset !== 0 && Je.create(a).valid ? (s = a, this.dt = e) : (s = "UTC", this.dt = e.offset === 0 ? e : e.setZone("UTC").plus({ minutes: e.offset }), this.originalZone = e.zone);
    } else
      e.zone.type === "system" ? this.dt = e : e.zone.type === "iana" ? (this.dt = e, s = e.zone.name) : (s = "UTC", this.dt = e.setZone("UTC").plus({ minutes: e.offset }), this.originalZone = e.zone);
    const o = { ...this.opts };
    o.timeZone = o.timeZone || s, this.dtf = Tn(t, o);
  }
  format() {
    return this.originalZone ? this.formatToParts().map(({ value: e }) => e).join("") : this.dtf.format(this.dt.toJSDate());
  }
  formatToParts() {
    const e = this.dtf.formatToParts(this.dt.toJSDate());
    return this.originalZone ? e.map((t) => {
      if (t.type === "timeZoneName") {
        const r = this.originalZone.offsetName(this.dt.ts, {
          locale: this.dt.locale,
          format: this.opts.timeZoneName
        });
        return {
          ...t,
          value: r
        };
      } else
        return t;
    }) : e;
  }
  resolvedOptions() {
    return this.dtf.resolvedOptions();
  }
}
class Xm {
  constructor(e, t, r) {
    this.opts = { style: "long", ...r }, !t && xu() && (this.rtf = qm(e, r));
  }
  format(e, t) {
    return this.rtf ? this.rtf.format(e, t) : gg(t, e, this.opts.numeric, this.opts.style !== "long");
  }
  formatToParts(e, t) {
    return this.rtf ? this.rtf.formatToParts(e, t) : [];
  }
}
class L {
  static fromOpts(e) {
    return L.create(e.locale, e.numberingSystem, e.outputCalendar, e.defaultToEN);
  }
  static create(e, t, r, s = !1) {
    const o = e || Z.defaultLocale, n = o || (s ? "en-US" : Wm()), a = t || Z.defaultNumberingSystem, l = r || Z.defaultOutputCalendar;
    return new L(n, a, l, o);
  }
  static resetCache() {
    si = null, Sn = {}, In = {}, Dn = {};
  }
  static fromObject({ locale: e, numberingSystem: t, outputCalendar: r } = {}) {
    return L.create(e, t, r);
  }
  constructor(e, t, r, s) {
    const [o, n, a] = jm(e);
    this.locale = o, this.numberingSystem = t || n || null, this.outputCalendar = r || a || null, this.intl = Gm(this.locale, this.numberingSystem, this.outputCalendar), this.weekdaysCache = { format: {}, standalone: {} }, this.monthsCache = { format: {}, standalone: {} }, this.meridiemCache = null, this.eraCache = {}, this.specifiedLocale = s, this.fastNumbersCached = null;
  }
  get fastNumbers() {
    return this.fastNumbersCached == null && (this.fastNumbersCached = Km(this)), this.fastNumbersCached;
  }
  listingMode() {
    const e = this.isEnglish(), t = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
    return e && t ? "en" : "intl";
  }
  clone(e) {
    return !e || Object.getOwnPropertyNames(e).length === 0 ? this : L.create(
      e.locale || this.specifiedLocale,
      e.numberingSystem || this.numberingSystem,
      e.outputCalendar || this.outputCalendar,
      e.defaultToEN || !1
    );
  }
  redefaultToEN(e = {}) {
    return this.clone({ ...e, defaultToEN: !0 });
  }
  redefaultToSystem(e = {}) {
    return this.clone({ ...e, defaultToEN: !1 });
  }
  months(e, t = !1) {
    return ts(this, e, Eu, () => {
      const r = t ? { month: e, day: "numeric" } : { month: e }, s = t ? "format" : "standalone";
      return this.monthsCache[s][e] || (this.monthsCache[s][e] = Ym((o) => this.extract(o, r, "month"))), this.monthsCache[s][e];
    });
  }
  weekdays(e, t = !1) {
    return ts(this, e, Iu, () => {
      const r = t ? { weekday: e, year: "numeric", month: "long", day: "numeric" } : { weekday: e }, s = t ? "format" : "standalone";
      return this.weekdaysCache[s][e] || (this.weekdaysCache[s][e] = Zm(
        (o) => this.extract(o, r, "weekday")
      )), this.weekdaysCache[s][e];
    });
  }
  meridiems() {
    return ts(
      this,
      void 0,
      () => Du,
      () => {
        if (!this.meridiemCache) {
          const e = { hour: "numeric", hourCycle: "h12" };
          this.meridiemCache = [x.utc(2016, 11, 13, 9), x.utc(2016, 11, 13, 19)].map(
            (t) => this.extract(t, e, "dayperiod")
          );
        }
        return this.meridiemCache;
      }
    );
  }
  eras(e) {
    return ts(this, e, Ou, () => {
      const t = { era: e };
      return this.eraCache[e] || (this.eraCache[e] = [x.utc(-40, 1, 1), x.utc(2017, 1, 1)].map(
        (r) => this.extract(r, t, "era")
      )), this.eraCache[e];
    });
  }
  extract(e, t, r) {
    const s = this.dtFormatter(e, t), o = s.formatToParts(), n = o.find((a) => a.type.toLowerCase() === r);
    return n ? n.value : null;
  }
  numberFormatter(e = {}) {
    return new Qm(this.intl, e.forceSimple || this.fastNumbers, e);
  }
  dtFormatter(e, t = {}) {
    return new Jm(e, this.intl, t);
  }
  relFormatter(e = {}) {
    return new Xm(this.intl, this.isEnglish(), e);
  }
  listFormatter(e = {}) {
    return Bm(this.intl, e);
  }
  isEnglish() {
    return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
  }
  equals(e) {
    return this.locale === e.locale && this.numberingSystem === e.numberingSystem && this.outputCalendar === e.outputCalendar;
  }
}
let Vo = null;
class oe extends zi {
  /**
   * Get a singleton instance of UTC
   * @return {FixedOffsetZone}
   */
  static get utcInstance() {
    return Vo === null && (Vo = new oe(0)), Vo;
  }
  /**
   * Get an instance with a specified offset
   * @param {number} offset - The offset in minutes
   * @return {FixedOffsetZone}
   */
  static instance(e) {
    return e === 0 ? oe.utcInstance : new oe(e);
  }
  /**
   * Get an instance of FixedOffsetZone from a UTC offset string, like "UTC+6"
   * @param {string} s - The offset string to parse
   * @example FixedOffsetZone.parseSpecifier("UTC+6")
   * @example FixedOffsetZone.parseSpecifier("UTC+06")
   * @example FixedOffsetZone.parseSpecifier("UTC-6:00")
   * @return {FixedOffsetZone}
   */
  static parseSpecifier(e) {
    if (e) {
      const t = e.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
      if (t)
        return new oe(no(t[1], t[2]));
    }
    return null;
  }
  constructor(e) {
    super(), this.fixed = e;
  }
  /** @override **/
  get type() {
    return "fixed";
  }
  /** @override **/
  get name() {
    return this.fixed === 0 ? "UTC" : `UTC${di(this.fixed, "narrow")}`;
  }
  get ianaName() {
    return this.fixed === 0 ? "Etc/UTC" : `Etc/GMT${di(-this.fixed, "narrow")}`;
  }
  /** @override **/
  offsetName() {
    return this.name;
  }
  /** @override **/
  formatOffset(e, t) {
    return di(this.fixed, t);
  }
  /** @override **/
  get isUniversal() {
    return !0;
  }
  /** @override **/
  offset() {
    return this.fixed;
  }
  /** @override **/
  equals(e) {
    return e.type === "fixed" && e.fixed === this.fixed;
  }
  /** @override **/
  get isValid() {
    return !0;
  }
}
class eg extends zi {
  constructor(e) {
    super(), this.zoneName = e;
  }
  /** @override **/
  get type() {
    return "invalid";
  }
  /** @override **/
  get name() {
    return this.zoneName;
  }
  /** @override **/
  get isUniversal() {
    return !1;
  }
  /** @override **/
  offsetName() {
    return null;
  }
  /** @override **/
  formatOffset() {
    return "";
  }
  /** @override **/
  offset() {
    return NaN;
  }
  /** @override **/
  equals() {
    return !1;
  }
  /** @override **/
  get isValid() {
    return !1;
  }
}
function ft(i, e) {
  if (E(i) || i === null)
    return e;
  if (i instanceof zi)
    return i;
  if (tg(i)) {
    const t = i.toLowerCase();
    return t === "default" ? e : t === "local" || t === "system" ? io.instance : t === "utc" || t === "gmt" ? oe.utcInstance : oe.parseSpecifier(t) || Je.create(i);
  } else
    return qt(i) ? oe.instance(i) : typeof i == "object" && "offset" in i && typeof i.offset == "function" ? i : new eg(i);
}
let Il = () => Date.now(), Dl = "system", Ol = null, $l = null, Pl = null, Ml = 60, zl;
class Z {
  /**
   * Get the callback for returning the current timestamp.
   * @type {function}
   */
  static get now() {
    return Il;
  }
  /**
   * Set the callback for returning the current timestamp.
   * The function should return a number, which will be interpreted as an Epoch millisecond count
   * @type {function}
   * @example Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future
   * @example Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time
   */
  static set now(e) {
    Il = e;
  }
  /**
   * Set the default time zone to create DateTimes in. Does not affect existing instances.
   * Use the value "system" to reset this value to the system's time zone.
   * @type {string}
   */
  static set defaultZone(e) {
    Dl = e;
  }
  /**
   * Get the default time zone object currently used to create DateTimes. Does not affect existing instances.
   * The default value is the system's time zone (the one set on the machine that runs this code).
   * @type {Zone}
   */
  static get defaultZone() {
    return ft(Dl, io.instance);
  }
  /**
   * Get the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultLocale() {
    return Ol;
  }
  /**
   * Set the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultLocale(e) {
    Ol = e;
  }
  /**
   * Get the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultNumberingSystem() {
    return $l;
  }
  /**
   * Set the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultNumberingSystem(e) {
    $l = e;
  }
  /**
   * Get the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultOutputCalendar() {
    return Pl;
  }
  /**
   * Set the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultOutputCalendar(e) {
    Pl = e;
  }
  /**
   * Get the cutoff year after which a string encoding a year as two digits is interpreted to occur in the current century.
   * @type {number}
   */
  static get twoDigitCutoffYear() {
    return Ml;
  }
  /**
   * Set the cutoff year after which a string encoding a year as two digits is interpreted to occur in the current century.
   * @type {number}
   * @example Settings.twoDigitCutoffYear = 0 // cut-off year is 0, so all 'yy' are interpreted as current century
   * @example Settings.twoDigitCutoffYear = 50 // '49' -> 1949; '50' -> 2050
   * @example Settings.twoDigitCutoffYear = 1950 // interpreted as 50
   * @example Settings.twoDigitCutoffYear = 2050 // ALSO interpreted as 50
   */
  static set twoDigitCutoffYear(e) {
    Ml = e % 100;
  }
  /**
   * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static get throwOnInvalid() {
    return zl;
  }
  /**
   * Set whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static set throwOnInvalid(e) {
    zl = e;
  }
  /**
   * Reset Luxon's global caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCaches() {
    L.resetCache(), Je.resetCache();
  }
}
function E(i) {
  return typeof i > "u";
}
function qt(i) {
  return typeof i == "number";
}
function so(i) {
  return typeof i == "number" && i % 1 === 0;
}
function tg(i) {
  return typeof i == "string";
}
function rg(i) {
  return Object.prototype.toString.call(i) === "[object Date]";
}
function xu() {
  try {
    return typeof Intl < "u" && !!Intl.RelativeTimeFormat;
  } catch {
    return !1;
  }
}
function ig(i) {
  return Array.isArray(i) ? i : [i];
}
function Nl(i, e, t) {
  if (i.length !== 0)
    return i.reduce((r, s) => {
      const o = [e(s), s];
      return r && t(r[0], o[0]) === r[0] ? r : o;
    }, null)[1];
}
function sg(i, e) {
  return e.reduce((t, r) => (t[r] = i[r], t), {});
}
function Er(i, e) {
  return Object.prototype.hasOwnProperty.call(i, e);
}
function Ze(i, e, t) {
  return so(i) && i >= e && i <= t;
}
function og(i, e) {
  return i - e * Math.floor(i / e);
}
function Q(i, e = 2) {
  const t = i < 0;
  let r;
  return t ? r = "-" + ("" + -i).padStart(e, "0") : r = ("" + i).padStart(e, "0"), r;
}
function dt(i) {
  if (!(E(i) || i === null || i === ""))
    return parseInt(i, 10);
}
function Ot(i) {
  if (!(E(i) || i === null || i === ""))
    return parseFloat(i);
}
function ga(i) {
  if (!(E(i) || i === null || i === "")) {
    const e = parseFloat("0." + i) * 1e3;
    return Math.floor(e);
  }
}
function _a(i, e, t = !1) {
  const r = 10 ** e;
  return (t ? Math.trunc : Math.round)(i * r) / r;
}
function Ni(i) {
  return i % 4 === 0 && (i % 100 !== 0 || i % 400 === 0);
}
function ci(i) {
  return Ni(i) ? 366 : 365;
}
function Ps(i, e) {
  const t = og(e - 1, 12) + 1, r = i + (e - t) / 12;
  return t === 2 ? Ni(r) ? 29 : 28 : [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][t - 1];
}
function oo(i) {
  let e = Date.UTC(
    i.year,
    i.month - 1,
    i.day,
    i.hour,
    i.minute,
    i.second,
    i.millisecond
  );
  return i.year < 100 && i.year >= 0 && (e = new Date(e), e.setUTCFullYear(i.year, i.month - 1, i.day)), +e;
}
function Ms(i) {
  const e = (i + Math.floor(i / 4) - Math.floor(i / 100) + Math.floor(i / 400)) % 7, t = i - 1, r = (t + Math.floor(t / 4) - Math.floor(t / 100) + Math.floor(t / 400)) % 7;
  return e === 4 || r === 3 ? 53 : 52;
}
function On(i) {
  return i > 99 ? i : i > Z.twoDigitCutoffYear ? 1900 + i : 2e3 + i;
}
function Cu(i, e, t, r = null) {
  const s = new Date(i), o = {
    hourCycle: "h23",
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit"
  };
  r && (o.timeZone = r);
  const n = { timeZoneName: e, ...o }, a = new Intl.DateTimeFormat(t, n).formatToParts(s).find((l) => l.type.toLowerCase() === "timezonename");
  return a ? a.value : null;
}
function no(i, e) {
  let t = parseInt(i, 10);
  Number.isNaN(t) && (t = 0);
  const r = parseInt(e, 10) || 0, s = t < 0 || Object.is(t, -0) ? -r : r;
  return t * 60 + s;
}
function ku(i) {
  const e = Number(i);
  if (typeof i == "boolean" || i === "" || Number.isNaN(e))
    throw new xe(`Invalid unit value ${i}`);
  return e;
}
function zs(i, e) {
  const t = {};
  for (const r in i)
    if (Er(i, r)) {
      const s = i[r];
      if (s == null)
        continue;
      t[e(r)] = ku(s);
    }
  return t;
}
function di(i, e) {
  const t = Math.trunc(Math.abs(i / 60)), r = Math.trunc(Math.abs(i % 60)), s = i >= 0 ? "+" : "-";
  switch (e) {
    case "short":
      return `${s}${Q(t, 2)}:${Q(r, 2)}`;
    case "narrow":
      return `${s}${t}${r > 0 ? `:${r}` : ""}`;
    case "techie":
      return `${s}${Q(t, 2)}${Q(r, 2)}`;
    default:
      throw new RangeError(`Value format ${e} is out of range for property format`);
  }
}
function ao(i) {
  return sg(i, ["hour", "minute", "second", "millisecond"]);
}
const ng = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
], Au = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
], ag = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
function Eu(i) {
  switch (i) {
    case "narrow":
      return [...ag];
    case "short":
      return [...Au];
    case "long":
      return [...ng];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
    case "2-digit":
      return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
    default:
      return null;
  }
}
const Su = [
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday",
  "Sunday"
], Tu = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"], lg = ["M", "T", "W", "T", "F", "S", "S"];
function Iu(i) {
  switch (i) {
    case "narrow":
      return [...lg];
    case "short":
      return [...Tu];
    case "long":
      return [...Su];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7"];
    default:
      return null;
  }
}
const Du = ["AM", "PM"], cg = ["Before Christ", "Anno Domini"], dg = ["BC", "AD"], ug = ["B", "A"];
function Ou(i) {
  switch (i) {
    case "narrow":
      return [...ug];
    case "short":
      return [...dg];
    case "long":
      return [...cg];
    default:
      return null;
  }
}
function hg(i) {
  return Du[i.hour < 12 ? 0 : 1];
}
function fg(i, e) {
  return Iu(e)[i.weekday - 1];
}
function pg(i, e) {
  return Eu(e)[i.month - 1];
}
function mg(i, e) {
  return Ou(e)[i.year < 0 ? 0 : 1];
}
function gg(i, e, t = "always", r = !1) {
  const s = {
    years: ["year", "yr."],
    quarters: ["quarter", "qtr."],
    months: ["month", "mo."],
    weeks: ["week", "wk."],
    days: ["day", "day", "days"],
    hours: ["hour", "hr."],
    minutes: ["minute", "min."],
    seconds: ["second", "sec."]
  }, o = ["hours", "minutes", "seconds"].indexOf(i) === -1;
  if (t === "auto" && o) {
    const u = i === "days";
    switch (e) {
      case 1:
        return u ? "tomorrow" : `next ${s[i][0]}`;
      case -1:
        return u ? "yesterday" : `last ${s[i][0]}`;
      case 0:
        return u ? "today" : `this ${s[i][0]}`;
    }
  }
  const n = Object.is(e, -0) || e < 0, a = Math.abs(e), l = a === 1, c = s[i], d = r ? l ? c[1] : c[2] || c[1] : l ? s[i][0] : i;
  return n ? `${a} ${d} ago` : `in ${a} ${d}`;
}
function Fl(i, e) {
  let t = "";
  for (const r of i)
    r.literal ? t += r.val : t += e(r.val);
  return t;
}
const _g = {
  D: $s,
  DD: iu,
  DDD: su,
  DDDD: ou,
  t: nu,
  tt: au,
  ttt: lu,
  tttt: cu,
  T: du,
  TT: uu,
  TTT: hu,
  TTTT: fu,
  f: pu,
  ff: gu,
  fff: bu,
  ffff: vu,
  F: mu,
  FF: _u,
  FFF: yu,
  FFFF: wu
};
class re {
  static create(e, t = {}) {
    return new re(e, t);
  }
  static parseFormat(e) {
    let t = null, r = "", s = !1;
    const o = [];
    for (let n = 0; n < e.length; n++) {
      const a = e.charAt(n);
      a === "'" ? (r.length > 0 && o.push({ literal: s || /^\s+$/.test(r), val: r }), t = null, r = "", s = !s) : s || a === t ? r += a : (r.length > 0 && o.push({ literal: /^\s+$/.test(r), val: r }), r = a, t = a);
    }
    return r.length > 0 && o.push({ literal: s || /^\s+$/.test(r), val: r }), o;
  }
  static macroTokenToFormatOpts(e) {
    return _g[e];
  }
  constructor(e, t) {
    this.opts = t, this.loc = e, this.systemLoc = null;
  }
  formatWithSystemDefault(e, t) {
    return this.systemLoc === null && (this.systemLoc = this.loc.redefaultToSystem()), this.systemLoc.dtFormatter(e, { ...this.opts, ...t }).format();
  }
  dtFormatter(e, t = {}) {
    return this.loc.dtFormatter(e, { ...this.opts, ...t });
  }
  formatDateTime(e, t) {
    return this.dtFormatter(e, t).format();
  }
  formatDateTimeParts(e, t) {
    return this.dtFormatter(e, t).formatToParts();
  }
  formatInterval(e, t) {
    return this.dtFormatter(e.start, t).dtf.formatRange(e.start.toJSDate(), e.end.toJSDate());
  }
  resolvedOptions(e, t) {
    return this.dtFormatter(e, t).resolvedOptions();
  }
  num(e, t = 0) {
    if (this.opts.forceSimple)
      return Q(e, t);
    const r = { ...this.opts };
    return t > 0 && (r.padTo = t), this.loc.numberFormatter(r).format(e);
  }
  formatDateTimeFromString(e, t) {
    const r = this.loc.listingMode() === "en", s = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", o = (f, m) => this.loc.extract(e, f, m), n = (f) => e.isOffsetFixed && e.offset === 0 && f.allowZ ? "Z" : e.isValid ? e.zone.formatOffset(e.ts, f.format) : "", a = () => r ? hg(e) : o({ hour: "numeric", hourCycle: "h12" }, "dayperiod"), l = (f, m) => r ? pg(e, f) : o(m ? { month: f } : { month: f, day: "numeric" }, "month"), c = (f, m) => r ? fg(e, f) : o(
      m ? { weekday: f } : { weekday: f, month: "long", day: "numeric" },
      "weekday"
    ), d = (f) => {
      const m = re.macroTokenToFormatOpts(f);
      return m ? this.formatWithSystemDefault(e, m) : f;
    }, u = (f) => r ? mg(e, f) : o({ era: f }, "era"), h = (f) => {
      switch (f) {
        case "S":
          return this.num(e.millisecond);
        case "u":
        case "SSS":
          return this.num(e.millisecond, 3);
        case "s":
          return this.num(e.second);
        case "ss":
          return this.num(e.second, 2);
        case "uu":
          return this.num(Math.floor(e.millisecond / 10), 2);
        case "uuu":
          return this.num(Math.floor(e.millisecond / 100));
        case "m":
          return this.num(e.minute);
        case "mm":
          return this.num(e.minute, 2);
        case "h":
          return this.num(e.hour % 12 === 0 ? 12 : e.hour % 12);
        case "hh":
          return this.num(e.hour % 12 === 0 ? 12 : e.hour % 12, 2);
        case "H":
          return this.num(e.hour);
        case "HH":
          return this.num(e.hour, 2);
        case "Z":
          return n({ format: "narrow", allowZ: this.opts.allowZ });
        case "ZZ":
          return n({ format: "short", allowZ: this.opts.allowZ });
        case "ZZZ":
          return n({ format: "techie", allowZ: this.opts.allowZ });
        case "ZZZZ":
          return e.zone.offsetName(e.ts, { format: "short", locale: this.loc.locale });
        case "ZZZZZ":
          return e.zone.offsetName(e.ts, { format: "long", locale: this.loc.locale });
        case "z":
          return e.zoneName;
        case "a":
          return a();
        case "d":
          return s ? o({ day: "numeric" }, "day") : this.num(e.day);
        case "dd":
          return s ? o({ day: "2-digit" }, "day") : this.num(e.day, 2);
        case "c":
          return this.num(e.weekday);
        case "ccc":
          return c("short", !0);
        case "cccc":
          return c("long", !0);
        case "ccccc":
          return c("narrow", !0);
        case "E":
          return this.num(e.weekday);
        case "EEE":
          return c("short", !1);
        case "EEEE":
          return c("long", !1);
        case "EEEEE":
          return c("narrow", !1);
        case "L":
          return s ? o({ month: "numeric", day: "numeric" }, "month") : this.num(e.month);
        case "LL":
          return s ? o({ month: "2-digit", day: "numeric" }, "month") : this.num(e.month, 2);
        case "LLL":
          return l("short", !0);
        case "LLLL":
          return l("long", !0);
        case "LLLLL":
          return l("narrow", !0);
        case "M":
          return s ? o({ month: "numeric" }, "month") : this.num(e.month);
        case "MM":
          return s ? o({ month: "2-digit" }, "month") : this.num(e.month, 2);
        case "MMM":
          return l("short", !1);
        case "MMMM":
          return l("long", !1);
        case "MMMMM":
          return l("narrow", !1);
        case "y":
          return s ? o({ year: "numeric" }, "year") : this.num(e.year);
        case "yy":
          return s ? o({ year: "2-digit" }, "year") : this.num(e.year.toString().slice(-2), 2);
        case "yyyy":
          return s ? o({ year: "numeric" }, "year") : this.num(e.year, 4);
        case "yyyyyy":
          return s ? o({ year: "numeric" }, "year") : this.num(e.year, 6);
        case "G":
          return u("short");
        case "GG":
          return u("long");
        case "GGGGG":
          return u("narrow");
        case "kk":
          return this.num(e.weekYear.toString().slice(-2), 2);
        case "kkkk":
          return this.num(e.weekYear, 4);
        case "W":
          return this.num(e.weekNumber);
        case "WW":
          return this.num(e.weekNumber, 2);
        case "o":
          return this.num(e.ordinal);
        case "ooo":
          return this.num(e.ordinal, 3);
        case "q":
          return this.num(e.quarter);
        case "qq":
          return this.num(e.quarter, 2);
        case "X":
          return this.num(Math.floor(e.ts / 1e3));
        case "x":
          return this.num(e.ts);
        default:
          return d(f);
      }
    };
    return Fl(re.parseFormat(t), h);
  }
  formatDurationFromString(e, t) {
    const r = (l) => {
      switch (l[0]) {
        case "S":
          return "millisecond";
        case "s":
          return "second";
        case "m":
          return "minute";
        case "h":
          return "hour";
        case "d":
          return "day";
        case "w":
          return "week";
        case "M":
          return "month";
        case "y":
          return "year";
        default:
          return null;
      }
    }, s = (l) => (c) => {
      const d = r(c);
      return d ? this.num(l.get(d), c.length) : c;
    }, o = re.parseFormat(t), n = o.reduce(
      (l, { literal: c, val: d }) => c ? l : l.concat(d),
      []
    ), a = e.shiftTo(...n.map(r).filter((l) => l));
    return Fl(o, s(a));
  }
}
class Ne {
  constructor(e, t) {
    this.reason = e, this.explanation = t;
  }
  toMessage() {
    return this.explanation ? `${this.reason}: ${this.explanation}` : this.reason;
  }
}
const $u = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;
function Pr(...i) {
  const e = i.reduce((t, r) => t + r.source, "");
  return RegExp(`^${e}$`);
}
function Mr(...i) {
  return (e) => i.reduce(
    ([t, r, s], o) => {
      const [n, a, l] = o(e, s);
      return [{ ...t, ...n }, a || r, l];
    },
    [{}, null, 1]
  ).slice(0, 2);
}
function zr(i, ...e) {
  if (i == null)
    return [null, null];
  for (const [t, r] of e) {
    const s = t.exec(i);
    if (s)
      return r(s);
  }
  return [null, null];
}
function Pu(...i) {
  return (e, t) => {
    const r = {};
    let s;
    for (s = 0; s < i.length; s++)
      r[i[s]] = dt(e[t + s]);
    return [r, null, t + s];
  };
}
const Mu = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/, bg = `(?:${Mu.source}?(?:\\[(${$u.source})\\])?)?`, ba = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/, zu = RegExp(`${ba.source}${bg}`), ya = RegExp(`(?:T${zu.source})?`), yg = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/, vg = /(\d{4})-?W(\d\d)(?:-?(\d))?/, wg = /(\d{4})-?(\d{3})/, xg = Pu("weekYear", "weekNumber", "weekDay"), Cg = Pu("year", "ordinal"), kg = /(\d{4})-(\d\d)-(\d\d)/, Nu = RegExp(
  `${ba.source} ?(?:${Mu.source}|(${$u.source}))?`
), Ag = RegExp(`(?: ${Nu.source})?`);
function br(i, e, t) {
  const r = i[e];
  return E(r) ? t : dt(r);
}
function Eg(i, e) {
  return [{
    year: br(i, e),
    month: br(i, e + 1, 1),
    day: br(i, e + 2, 1)
  }, null, e + 3];
}
function Nr(i, e) {
  return [{
    hours: br(i, e, 0),
    minutes: br(i, e + 1, 0),
    seconds: br(i, e + 2, 0),
    milliseconds: ga(i[e + 3])
  }, null, e + 4];
}
function Fi(i, e) {
  const t = !i[e] && !i[e + 1], r = no(i[e + 1], i[e + 2]), s = t ? null : oe.instance(r);
  return [{}, s, e + 3];
}
function Ri(i, e) {
  const t = i[e] ? Je.create(i[e]) : null;
  return [{}, t, e + 1];
}
const Sg = RegExp(`^T?${ba.source}$`), Tg = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
function Ig(i) {
  const [e, t, r, s, o, n, a, l, c] = i, d = e[0] === "-", u = l && l[0] === "-", h = (f, m = !1) => f !== void 0 && (m || f && d) ? -f : f;
  return [
    {
      years: h(Ot(t)),
      months: h(Ot(r)),
      weeks: h(Ot(s)),
      days: h(Ot(o)),
      hours: h(Ot(n)),
      minutes: h(Ot(a)),
      seconds: h(Ot(l), l === "-0"),
      milliseconds: h(ga(c), u)
    }
  ];
}
const Dg = {
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};
function va(i, e, t, r, s, o, n) {
  const a = {
    year: e.length === 2 ? On(dt(e)) : dt(e),
    month: Au.indexOf(t) + 1,
    day: dt(r),
    hour: dt(s),
    minute: dt(o)
  };
  return n && (a.second = dt(n)), i && (a.weekday = i.length > 3 ? Su.indexOf(i) + 1 : Tu.indexOf(i) + 1), a;
}
const Og = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
function $g(i) {
  const [
    ,
    e,
    t,
    r,
    s,
    o,
    n,
    a,
    l,
    c,
    d,
    u
  ] = i, h = va(e, s, r, t, o, n, a);
  let f;
  return l ? f = Dg[l] : c ? f = 0 : f = no(d, u), [h, new oe(f)];
}
function Pg(i) {
  return i.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
}
const Mg = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/, zg = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/, Ng = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
function Rl(i) {
  const [, e, t, r, s, o, n, a] = i;
  return [va(e, s, r, t, o, n, a), oe.utcInstance];
}
function Fg(i) {
  const [, e, t, r, s, o, n, a] = i;
  return [va(e, a, t, r, s, o, n), oe.utcInstance];
}
const Rg = Pr(yg, ya), Lg = Pr(vg, ya), Vg = Pr(wg, ya), Hg = Pr(zu), Fu = Mr(
  Eg,
  Nr,
  Fi,
  Ri
), Bg = Mr(
  xg,
  Nr,
  Fi,
  Ri
), Ug = Mr(
  Cg,
  Nr,
  Fi,
  Ri
), qg = Mr(
  Nr,
  Fi,
  Ri
);
function Wg(i) {
  return zr(
    i,
    [Rg, Fu],
    [Lg, Bg],
    [Vg, Ug],
    [Hg, qg]
  );
}
function jg(i) {
  return zr(Pg(i), [Og, $g]);
}
function Gg(i) {
  return zr(
    i,
    [Mg, Rl],
    [zg, Rl],
    [Ng, Fg]
  );
}
function Yg(i) {
  return zr(i, [Tg, Ig]);
}
const Zg = Mr(Nr);
function Kg(i) {
  return zr(i, [Sg, Zg]);
}
const Qg = Pr(kg, Ag), Jg = Pr(Nu), Xg = Mr(
  Nr,
  Fi,
  Ri
);
function e_(i) {
  return zr(
    i,
    [Qg, Fu],
    [Jg, Xg]
  );
}
const Ll = "Invalid Duration", Ru = {
  weeks: {
    days: 7,
    hours: 7 * 24,
    minutes: 7 * 24 * 60,
    seconds: 7 * 24 * 60 * 60,
    milliseconds: 7 * 24 * 60 * 60 * 1e3
  },
  days: {
    hours: 24,
    minutes: 24 * 60,
    seconds: 24 * 60 * 60,
    milliseconds: 24 * 60 * 60 * 1e3
  },
  hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1e3 },
  minutes: { seconds: 60, milliseconds: 60 * 1e3 },
  seconds: { milliseconds: 1e3 }
}, t_ = {
  years: {
    quarters: 4,
    months: 12,
    weeks: 52,
    days: 365,
    hours: 365 * 24,
    minutes: 365 * 24 * 60,
    seconds: 365 * 24 * 60 * 60,
    milliseconds: 365 * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: 13,
    days: 91,
    hours: 91 * 24,
    minutes: 91 * 24 * 60,
    seconds: 91 * 24 * 60 * 60,
    milliseconds: 91 * 24 * 60 * 60 * 1e3
  },
  months: {
    weeks: 4,
    days: 30,
    hours: 30 * 24,
    minutes: 30 * 24 * 60,
    seconds: 30 * 24 * 60 * 60,
    milliseconds: 30 * 24 * 60 * 60 * 1e3
  },
  ...Ru
}, ve = 146097 / 400, nr = 146097 / 4800, r_ = {
  years: {
    quarters: 4,
    months: 12,
    weeks: ve / 7,
    days: ve,
    hours: ve * 24,
    minutes: ve * 24 * 60,
    seconds: ve * 24 * 60 * 60,
    milliseconds: ve * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: ve / 28,
    days: ve / 4,
    hours: ve * 24 / 4,
    minutes: ve * 24 * 60 / 4,
    seconds: ve * 24 * 60 * 60 / 4,
    milliseconds: ve * 24 * 60 * 60 * 1e3 / 4
  },
  months: {
    weeks: nr / 7,
    days: nr,
    hours: nr * 24,
    minutes: nr * 24 * 60,
    seconds: nr * 24 * 60 * 60,
    milliseconds: nr * 24 * 60 * 60 * 1e3
  },
  ...Ru
}, Ht = [
  "years",
  "quarters",
  "months",
  "weeks",
  "days",
  "hours",
  "minutes",
  "seconds",
  "milliseconds"
], i_ = Ht.slice(0).reverse();
function nt(i, e, t = !1) {
  const r = {
    values: t ? e.values : { ...i.values, ...e.values || {} },
    loc: i.loc.clone(e.loc),
    conversionAccuracy: e.conversionAccuracy || i.conversionAccuracy,
    matrix: e.matrix || i.matrix
  };
  return new T(r);
}
function Lu(i, e) {
  let t = e.milliseconds ?? 0;
  for (const r of i_.slice(1))
    e[r] && (t += e[r] * i[r].milliseconds);
  return t;
}
function Vl(i, e) {
  const t = Lu(i, e) < 0 ? -1 : 1;
  Ht.reduceRight((r, s) => {
    if (E(e[s]))
      return r;
    if (r) {
      const o = e[r] * t, n = i[s][r], a = Math.floor(o / n);
      e[s] += a * t, e[r] -= a * n * t;
    }
    return s;
  }, null), Ht.reduce((r, s) => {
    if (E(e[s]))
      return r;
    if (r) {
      const o = e[r] % 1;
      e[r] -= o, e[s] += o * i[r][s];
    }
    return s;
  }, null);
}
function s_(i) {
  const e = {};
  for (const [t, r] of Object.entries(i))
    r !== 0 && (e[t] = r);
  return e;
}
class T {
  /**
   * @private
   */
  constructor(e) {
    const t = e.conversionAccuracy === "longterm" || !1;
    let r = t ? r_ : t_;
    e.matrix && (r = e.matrix), this.values = e.values, this.loc = e.loc || L.create(), this.conversionAccuracy = t ? "longterm" : "casual", this.invalid = e.invalid || null, this.matrix = r, this.isLuxonDuration = !0;
  }
  /**
   * Create Duration from a number of milliseconds.
   * @param {number} count of milliseconds
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  static fromMillis(e, t) {
    return T.fromObject({ milliseconds: e }, t);
  }
  /**
   * Create a Duration from a JavaScript object with keys like 'years' and 'hours'.
   * If this object is empty then a zero milliseconds duration is returned.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.years
   * @param {number} obj.quarters
   * @param {number} obj.months
   * @param {number} obj.weeks
   * @param {number} obj.days
   * @param {number} obj.hours
   * @param {number} obj.minutes
   * @param {number} obj.seconds
   * @param {number} obj.milliseconds
   * @param {Object} [opts=[]] - options for creating this Duration
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the custom conversion system to use
   * @return {Duration}
   */
  static fromObject(e, t = {}) {
    if (e == null || typeof e != "object")
      throw new xe(
        `Duration.fromObject: argument expected to be an object, got ${e === null ? "null" : typeof e}`
      );
    return new T({
      values: zs(e, T.normalizeUnit),
      loc: L.fromObject(t),
      conversionAccuracy: t.conversionAccuracy,
      matrix: t.matrix
    });
  }
  /**
   * Create a Duration from DurationLike.
   *
   * @param {Object | number | Duration} durationLike
   * One of:
   * - object with keys like 'years' and 'hours'.
   * - number representing milliseconds
   * - Duration instance
   * @return {Duration}
   */
  static fromDurationLike(e) {
    if (qt(e))
      return T.fromMillis(e);
    if (T.isDuration(e))
      return e;
    if (typeof e == "object")
      return T.fromObject(e);
    throw new xe(
      `Unknown duration argument ${e} of type ${typeof e}`
    );
  }
  /**
   * Create a Duration from an ISO 8601 duration string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the preset conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }
   * @example Duration.fromISO('PT23H').toObject() //=> { hours: 23 }
   * @example Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }
   * @return {Duration}
   */
  static fromISO(e, t) {
    const [r] = Yg(e);
    return r ? T.fromObject(r, t) : T.invalid("unparsable", `the input "${e}" can't be parsed as ISO 8601`);
  }
  /**
   * Create a Duration from an ISO 8601 time string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @example Duration.fromISOTime('11:22:33.444').toObject() //=> { hours: 11, minutes: 22, seconds: 33, milliseconds: 444 }
   * @example Duration.fromISOTime('11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @return {Duration}
   */
  static fromISOTime(e, t) {
    const [r] = Kg(e);
    return r ? T.fromObject(r, t) : T.invalid("unparsable", `the input "${e}" can't be parsed as ISO 8601`);
  }
  /**
   * Create an invalid Duration.
   * @param {string} reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Duration}
   */
  static invalid(e, t = null) {
    if (!e)
      throw new xe("need to specify a reason the Duration is invalid");
    const r = e instanceof Ne ? e : new Ne(e, t);
    if (Z.throwOnInvalid)
      throw new zm(r);
    return new T({ invalid: r });
  }
  /**
   * @private
   */
  static normalizeUnit(e) {
    const t = {
      year: "years",
      years: "years",
      quarter: "quarters",
      quarters: "quarters",
      month: "months",
      months: "months",
      week: "weeks",
      weeks: "weeks",
      day: "days",
      days: "days",
      hour: "hours",
      hours: "hours",
      minute: "minutes",
      minutes: "minutes",
      second: "seconds",
      seconds: "seconds",
      millisecond: "milliseconds",
      milliseconds: "milliseconds"
    }[e && e.toLowerCase()];
    if (!t)
      throw new ru(e);
    return t;
  }
  /**
   * Check if an object is a Duration. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDuration(e) {
    return e && e.isLuxonDuration || !1;
  }
  /**
   * Get  the locale of a Duration, such 'en-GB'
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  /**
   * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  /**
   * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:
   * * `S` for milliseconds
   * * `s` for seconds
   * * `m` for minutes
   * * `h` for hours
   * * `d` for days
   * * `w` for weeks
   * * `M` for months
   * * `y` for years
   * Notes:
   * * Add padding by repeating the token, e.g. "yy" pads the years to two digits, "hhhh" pads the hours out to four digits
   * * Tokens can be escaped by wrapping with single quotes.
   * * The duration will be converted to the set of units in the format string using {@link Duration#shiftTo} and the Durations's conversion accuracy setting.
   * @param {string} fmt - the format string
   * @param {Object} opts - options
   * @param {boolean} [opts.floor=true] - floor numerical values
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("y d s") //=> "1 6 2"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("yy dd sss") //=> "01 06 002"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("M S") //=> "12 518402000"
   * @return {string}
   */
  toFormat(e, t = {}) {
    const r = {
      ...t,
      floor: t.round !== !1 && t.floor !== !1
    };
    return this.isValid ? re.create(this.loc, r).formatDurationFromString(this, e) : Ll;
  }
  /**
   * Returns a string representation of a Duration with all units included.
   * To modify its behavior use the `listStyle` and any Intl.NumberFormat option, though `unitDisplay` is especially relevant.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat
   * @param opts - On option object to override the formatting. Accepts the same keys as the options parameter of the native `Int.NumberFormat` constructor, as well as `listStyle`.
   * @example
   * ```js
   * var dur = Duration.fromObject({ days: 1, hours: 5, minutes: 6 })
   * dur.toHuman() //=> '1 day, 5 hours, 6 minutes'
   * dur.toHuman({ listStyle: "long" }) //=> '1 day, 5 hours, and 6 minutes'
   * dur.toHuman({ unitDisplay: "short" }) //=> '1 day, 5 hr, 6 min'
   * ```
   */
  toHuman(e = {}) {
    if (!this.isValid)
      return Ll;
    const t = Ht.map((r) => {
      const s = this.values[r];
      return E(s) ? null : this.loc.numberFormatter({ style: "unit", unitDisplay: "long", ...e, unit: r.slice(0, -1) }).format(s);
    }).filter((r) => r);
    return this.loc.listFormatter({ type: "conjunction", style: e.listStyle || "narrow", ...e }).format(t);
  }
  /**
   * Returns a JavaScript object with this Duration's values.
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }
   * @return {Object}
   */
  toObject() {
    return this.isValid ? { ...this.values } : {};
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Duration.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'
   * @example Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'
   * @example Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'
   * @example Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'
   * @example Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'
   * @return {string}
   */
  toISO() {
    if (!this.isValid)
      return null;
    let e = "P";
    return this.years !== 0 && (e += this.years + "Y"), (this.months !== 0 || this.quarters !== 0) && (e += this.months + this.quarters * 3 + "M"), this.weeks !== 0 && (e += this.weeks + "W"), this.days !== 0 && (e += this.days + "D"), (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0) && (e += "T"), this.hours !== 0 && (e += this.hours + "H"), this.minutes !== 0 && (e += this.minutes + "M"), (this.seconds !== 0 || this.milliseconds !== 0) && (e += _a(this.seconds + this.milliseconds / 1e3, 3) + "S"), e === "P" && (e += "T0S"), e;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Duration, formatted as a time of day.
   * Note that this will return null if the duration is invalid, negative, or equal to or greater than 24 hours.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example Duration.fromObject({ hours: 11 }).toISOTime() //=> '11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressMilliseconds: true }) //=> '11:00:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressSeconds: true }) //=> '11:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ includePrefix: true }) //=> 'T11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ format: 'basic' }) //=> '110000.000'
   * @return {string}
   */
  toISOTime(e = {}) {
    if (!this.isValid)
      return null;
    const t = this.toMillis();
    return t < 0 || t >= 864e5 ? null : (e = {
      suppressMilliseconds: !1,
      suppressSeconds: !1,
      includePrefix: !1,
      format: "extended",
      ...e,
      includeOffset: !1
    }, x.fromMillis(t, { zone: "UTC" }).toISOTime(e));
  }
  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }
  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.
   * @return {string}
   */
  toString() {
    return this.toISO();
  }
  /**
   * Returns an milliseconds value of this Duration.
   * @return {number}
   */
  toMillis() {
    return this.isValid ? Lu(this.matrix, this.values) : NaN;
  }
  /**
   * Returns an milliseconds value of this Duration. Alias of {@link toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }
  /**
   * Make this Duration longer by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  plus(e) {
    if (!this.isValid)
      return this;
    const t = T.fromDurationLike(e), r = {};
    for (const s of Ht)
      (Er(t.values, s) || Er(this.values, s)) && (r[s] = t.get(s) + this.get(s));
    return nt(this, { values: r }, !0);
  }
  /**
   * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  minus(e) {
    if (!this.isValid)
      return this;
    const t = T.fromDurationLike(e);
    return this.plus(t.negate());
  }
  /**
   * Scale this Duration by the specified amount. Return a newly-constructed Duration.
   * @param {function} fn - The function to apply to each unit. Arity is 1 or 2: the value of the unit and, optionally, the unit name. Must return a number.
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits(x => x * 2) //=> { hours: 2, minutes: 60 }
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits((x, u) => u === "hours" ? x * 2 : x) //=> { hours: 2, minutes: 30 }
   * @return {Duration}
   */
  mapUnits(e) {
    if (!this.isValid)
      return this;
    const t = {};
    for (const r of Object.keys(this.values))
      t[r] = ku(e(this.values[r], r));
    return nt(this, { values: t }, !0);
  }
  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example Duration.fromObject({years: 2, days: 3}).get('years') //=> 2
   * @example Duration.fromObject({years: 2, days: 3}).get('months') //=> 0
   * @example Duration.fromObject({years: 2, days: 3}).get('days') //=> 3
   * @return {number}
   */
  get(e) {
    return this[T.normalizeUnit(e)];
  }
  /**
   * "Set" the values of specified units. Return a newly-constructed Duration.
   * @param {Object} values - a mapping of units to numbers
   * @example dur.set({ years: 2017 })
   * @example dur.set({ hours: 8, minutes: 30 })
   * @return {Duration}
   */
  set(e) {
    if (!this.isValid)
      return this;
    const t = { ...this.values, ...zs(e, T.normalizeUnit) };
    return nt(this, { values: t });
  }
  /**
   * "Set" the locale and/or numberingSystem.  Returns a newly-constructed Duration.
   * @example dur.reconfigure({ locale: 'en-GB' })
   * @return {Duration}
   */
  reconfigure({ locale: e, numberingSystem: t, conversionAccuracy: r, matrix: s } = {}) {
    const n = { loc: this.loc.clone({ locale: e, numberingSystem: t }), matrix: s, conversionAccuracy: r };
    return nt(this, n);
  }
  /**
   * Return the length of the duration in the specified unit.
   * @param {string} unit - a unit such as 'minutes' or 'days'
   * @example Duration.fromObject({years: 1}).as('days') //=> 365
   * @example Duration.fromObject({years: 1}).as('months') //=> 12
   * @example Duration.fromObject({hours: 60}).as('days') //=> 2.5
   * @return {number}
   */
  as(e) {
    return this.isValid ? this.shiftTo(e).get(e) : NaN;
  }
  /**
   * Reduce this Duration to its canonical representation in its current units.
   * Assuming the overall value of the Duration is positive, this means:
   * - excessive values for lower-order units are converted to higher-order units (if possible, see first and second example)
   * - negative lower-order units are converted to higher order units (there must be such a higher order unit, otherwise
   *   the overall value would be negative, see second example)
   * - fractional values for higher-order units are converted to lower-order units (if possible, see fourth example)
   *
   * If the overall value is negative, the result of this method is equivalent to `this.negate().normalize().negate()`.
   * @example Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }
   * @example Duration.fromObject({ days: 5000 }).normalize().toObject() //=> { days: 5000 }
   * @example Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }
   * @example Duration.fromObject({ years: 2.5, days: 0, hours: 0 }).normalize().toObject() //=> { years: 2, days: 182, hours: 12 }
   * @return {Duration}
   */
  normalize() {
    if (!this.isValid)
      return this;
    const e = this.toObject();
    return Vl(this.matrix, e), nt(this, { values: e }, !0);
  }
  /**
   * Rescale units to its largest representation
   * @example Duration.fromObject({ milliseconds: 90000 }).rescale().toObject() //=> { minutes: 1, seconds: 30 }
   * @return {Duration}
   */
  rescale() {
    if (!this.isValid)
      return this;
    const e = s_(this.normalize().shiftToAll().toObject());
    return nt(this, { values: e }, !0);
  }
  /**
   * Convert this Duration into its representation in a different set of units.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }
   * @return {Duration}
   */
  shiftTo(...e) {
    if (!this.isValid)
      return this;
    if (e.length === 0)
      return this;
    e = e.map((n) => T.normalizeUnit(n));
    const t = {}, r = {}, s = this.toObject();
    let o;
    for (const n of Ht)
      if (e.indexOf(n) >= 0) {
        o = n;
        let a = 0;
        for (const c in r)
          a += this.matrix[c][n] * r[c], r[c] = 0;
        qt(s[n]) && (a += s[n]);
        const l = Math.trunc(a);
        t[n] = l, r[n] = (a * 1e3 - l * 1e3) / 1e3;
      } else
        qt(s[n]) && (r[n] = s[n]);
    for (const n in r)
      r[n] !== 0 && (t[o] += n === o ? r[n] : r[n] / this.matrix[o][n]);
    return Vl(this.matrix, t), nt(this, { values: t }, !0);
  }
  /**
   * Shift this Duration to all available units.
   * Same as shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds")
   * @return {Duration}
   */
  shiftToAll() {
    return this.isValid ? this.shiftTo(
      "years",
      "months",
      "weeks",
      "days",
      "hours",
      "minutes",
      "seconds",
      "milliseconds"
    ) : this;
  }
  /**
   * Return the negative of this Duration.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }
   * @return {Duration}
   */
  negate() {
    if (!this.isValid)
      return this;
    const e = {};
    for (const t of Object.keys(this.values))
      e[t] = this.values[t] === 0 ? 0 : -this.values[t];
    return nt(this, { values: e }, !0);
  }
  /**
   * Get the years.
   * @type {number}
   */
  get years() {
    return this.isValid ? this.values.years || 0 : NaN;
  }
  /**
   * Get the quarters.
   * @type {number}
   */
  get quarters() {
    return this.isValid ? this.values.quarters || 0 : NaN;
  }
  /**
   * Get the months.
   * @type {number}
   */
  get months() {
    return this.isValid ? this.values.months || 0 : NaN;
  }
  /**
   * Get the weeks
   * @type {number}
   */
  get weeks() {
    return this.isValid ? this.values.weeks || 0 : NaN;
  }
  /**
   * Get the days.
   * @type {number}
   */
  get days() {
    return this.isValid ? this.values.days || 0 : NaN;
  }
  /**
   * Get the hours.
   * @type {number}
   */
  get hours() {
    return this.isValid ? this.values.hours || 0 : NaN;
  }
  /**
   * Get the minutes.
   * @type {number}
   */
  get minutes() {
    return this.isValid ? this.values.minutes || 0 : NaN;
  }
  /**
   * Get the seconds.
   * @return {number}
   */
  get seconds() {
    return this.isValid ? this.values.seconds || 0 : NaN;
  }
  /**
   * Get the milliseconds.
   * @return {number}
   */
  get milliseconds() {
    return this.isValid ? this.values.milliseconds || 0 : NaN;
  }
  /**
   * Returns whether the Duration is invalid. Invalid durations are returned by diff operations
   * on invalid DateTimes or Intervals.
   * @return {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }
  /**
   * Returns an error code if this Duration became invalid, or null if the Duration is valid
   * @return {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this Duration became invalid, or null if the Duration is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Equality check
   * Two Durations are equal iff they have the same units and the same values for each unit.
   * @param {Duration} other
   * @return {boolean}
   */
  equals(e) {
    if (!this.isValid || !e.isValid || !this.loc.equals(e.loc))
      return !1;
    function t(r, s) {
      return r === void 0 || r === 0 ? s === void 0 || s === 0 : r === s;
    }
    for (const r of Ht)
      if (!t(this.values[r], e.values[r]))
        return !1;
    return !0;
  }
}
const ar = "Invalid Interval";
function o_(i, e) {
  return !i || !i.isValid ? q.invalid("missing or invalid start") : !e || !e.isValid ? q.invalid("missing or invalid end") : e < i ? q.invalid(
    "end before start",
    `The end of an interval must be after its start, but you had start=${i.toISO()} and end=${e.toISO()}`
  ) : null;
}
class q {
  /**
   * @private
   */
  constructor(e) {
    this.s = e.start, this.e = e.end, this.invalid = e.invalid || null, this.isLuxonInterval = !0;
  }
  /**
   * Create an invalid Interval.
   * @param {string} reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Interval}
   */
  static invalid(e, t = null) {
    if (!e)
      throw new xe("need to specify a reason the Interval is invalid");
    const r = e instanceof Ne ? e : new Ne(e, t);
    if (Z.throwOnInvalid)
      throw new Mm(r);
    return new q({ invalid: r });
  }
  /**
   * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.
   * @param {DateTime|Date|Object} start
   * @param {DateTime|Date|Object} end
   * @return {Interval}
   */
  static fromDateTimes(e, t) {
    const r = Gr(e), s = Gr(t), o = o_(r, s);
    return o ?? new q({
      start: r,
      end: s
    });
  }
  /**
   * Create an Interval from a start DateTime and a Duration to extend to.
   * @param {DateTime|Date|Object} start
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static after(e, t) {
    const r = T.fromDurationLike(t), s = Gr(e);
    return q.fromDateTimes(s, s.plus(r));
  }
  /**
   * Create an Interval from an end DateTime and a Duration to extend backwards to.
   * @param {DateTime|Date|Object} end
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static before(e, t) {
    const r = T.fromDurationLike(t), s = Gr(e);
    return q.fromDateTimes(s.minus(r), s);
  }
  /**
   * Create an Interval from an ISO 8601 string.
   * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.
   * @param {string} text - the ISO string to parse
   * @param {Object} [opts] - options to pass {@link DateTime#fromISO} and optionally {@link Duration#fromISO}
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {Interval}
   */
  static fromISO(e, t) {
    const [r, s] = (e || "").split("/", 2);
    if (r && s) {
      let o, n;
      try {
        o = x.fromISO(r, t), n = o.isValid;
      } catch {
        n = !1;
      }
      let a, l;
      try {
        a = x.fromISO(s, t), l = a.isValid;
      } catch {
        l = !1;
      }
      if (n && l)
        return q.fromDateTimes(o, a);
      if (n) {
        const c = T.fromISO(s, t);
        if (c.isValid)
          return q.after(o, c);
      } else if (l) {
        const c = T.fromISO(r, t);
        if (c.isValid)
          return q.before(a, c);
      }
    }
    return q.invalid("unparsable", `the input "${e}" can't be parsed as ISO 8601`);
  }
  /**
   * Check if an object is an Interval. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isInterval(e) {
    return e && e.isLuxonInterval || !1;
  }
  /**
   * Returns the start of the Interval
   * @type {DateTime}
   */
  get start() {
    return this.isValid ? this.s : null;
  }
  /**
   * Returns the end of the Interval
   * @type {DateTime}
   */
  get end() {
    return this.isValid ? this.e : null;
  }
  /**
   * Returns whether this Interval's end is at least its start, meaning that the Interval isn't 'backwards'.
   * @type {boolean}
   */
  get isValid() {
    return this.invalidReason === null;
  }
  /**
   * Returns an error code if this Interval is invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this Interval became invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Returns the length of the Interval in the specified unit.
   * @param {string} unit - the unit (such as 'hours' or 'days') to return the length in.
   * @return {number}
   */
  length(e = "milliseconds") {
    return this.isValid ? this.toDuration(e).get(e) : NaN;
  }
  /**
   * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.
   * Unlike {@link Interval#length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'
   * asks 'what dates are included in this interval?', not 'how many days long is this interval?'
   * @param {string} [unit='milliseconds'] - the unit of time to count.
   * @return {number}
   */
  count(e = "milliseconds") {
    if (!this.isValid)
      return NaN;
    const t = this.start.startOf(e), r = this.end.startOf(e);
    return Math.floor(r.diff(t, e).get(e)) + (r.valueOf() !== this.end.valueOf());
  }
  /**
   * Returns whether this Interval's start and end are both in the same unit of time
   * @param {string} unit - the unit of time to check sameness on
   * @return {boolean}
   */
  hasSame(e) {
    return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, e) : !1;
  }
  /**
   * Return whether this Interval has the same start and end DateTimes.
   * @return {boolean}
   */
  isEmpty() {
    return this.s.valueOf() === this.e.valueOf();
  }
  /**
   * Return whether this Interval's start is after the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isAfter(e) {
    return this.isValid ? this.s > e : !1;
  }
  /**
   * Return whether this Interval's end is before the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isBefore(e) {
    return this.isValid ? this.e <= e : !1;
  }
  /**
   * Return whether this Interval contains the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  contains(e) {
    return this.isValid ? this.s <= e && this.e > e : !1;
  }
  /**
   * "Sets" the start and/or end dates. Returns a newly-constructed Interval.
   * @param {Object} values - the values to set
   * @param {DateTime} values.start - the starting DateTime
   * @param {DateTime} values.end - the ending DateTime
   * @return {Interval}
   */
  set({ start: e, end: t } = {}) {
    return this.isValid ? q.fromDateTimes(e || this.s, t || this.e) : this;
  }
  /**
   * Split this Interval at each of the specified DateTimes
   * @param {...DateTime} dateTimes - the unit of time to count.
   * @return {Array}
   */
  splitAt(...e) {
    if (!this.isValid)
      return [];
    const t = e.map(Gr).filter((n) => this.contains(n)).sort(), r = [];
    let { s } = this, o = 0;
    for (; s < this.e; ) {
      const n = t[o] || this.e, a = +n > +this.e ? this.e : n;
      r.push(q.fromDateTimes(s, a)), s = a, o += 1;
    }
    return r;
  }
  /**
   * Split this Interval into smaller Intervals, each of the specified length.
   * Left over time is grouped into a smaller interval
   * @param {Duration|Object|number} duration - The length of each resulting interval.
   * @return {Array}
   */
  splitBy(e) {
    const t = T.fromDurationLike(e);
    if (!this.isValid || !t.isValid || t.as("milliseconds") === 0)
      return [];
    let { s: r } = this, s = 1, o;
    const n = [];
    for (; r < this.e; ) {
      const a = this.start.plus(t.mapUnits((l) => l * s));
      o = +a > +this.e ? this.e : a, n.push(q.fromDateTimes(r, o)), r = o, s += 1;
    }
    return n;
  }
  /**
   * Split this Interval into the specified number of smaller intervals.
   * @param {number} numberOfParts - The number of Intervals to divide the Interval into.
   * @return {Array}
   */
  divideEqually(e) {
    return this.isValid ? this.splitBy(this.length() / e).slice(0, e) : [];
  }
  /**
   * Return whether this Interval overlaps with the specified Interval
   * @param {Interval} other
   * @return {boolean}
   */
  overlaps(e) {
    return this.e > e.s && this.s < e.e;
  }
  /**
   * Return whether this Interval's end is adjacent to the specified Interval's start.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsStart(e) {
    return this.isValid ? +this.e == +e.s : !1;
  }
  /**
   * Return whether this Interval's start is adjacent to the specified Interval's end.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsEnd(e) {
    return this.isValid ? +e.e == +this.s : !1;
  }
  /**
   * Return whether this Interval engulfs the start and end of the specified Interval.
   * @param {Interval} other
   * @return {boolean}
   */
  engulfs(e) {
    return this.isValid ? this.s <= e.s && this.e >= e.e : !1;
  }
  /**
   * Return whether this Interval has the same start and end as the specified Interval.
   * @param {Interval} other
   * @return {boolean}
   */
  equals(e) {
    return !this.isValid || !e.isValid ? !1 : this.s.equals(e.s) && this.e.equals(e.e);
  }
  /**
   * Return an Interval representing the intersection of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.
   * Returns null if the intersection is empty, meaning, the intervals don't intersect.
   * @param {Interval} other
   * @return {Interval}
   */
  intersection(e) {
    if (!this.isValid)
      return this;
    const t = this.s > e.s ? this.s : e.s, r = this.e < e.e ? this.e : e.e;
    return t >= r ? null : q.fromDateTimes(t, r);
  }
  /**
   * Return an Interval representing the union of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.
   * @param {Interval} other
   * @return {Interval}
   */
  union(e) {
    if (!this.isValid)
      return this;
    const t = this.s < e.s ? this.s : e.s, r = this.e > e.e ? this.e : e.e;
    return q.fromDateTimes(t, r);
  }
  /**
   * Merge an array of Intervals into a equivalent minimal set of Intervals.
   * Combines overlapping and adjacent Intervals.
   * @param {Array} intervals
   * @return {Array}
   */
  static merge(e) {
    const [t, r] = e.sort((s, o) => s.s - o.s).reduce(
      ([s, o], n) => o ? o.overlaps(n) || o.abutsStart(n) ? [s, o.union(n)] : [s.concat([o]), n] : [s, n],
      [[], null]
    );
    return r && t.push(r), t;
  }
  /**
   * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.
   * @param {Array} intervals
   * @return {Array}
   */
  static xor(e) {
    let t = null, r = 0;
    const s = [], o = e.map((l) => [
      { time: l.s, type: "s" },
      { time: l.e, type: "e" }
    ]), n = Array.prototype.concat(...o), a = n.sort((l, c) => l.time - c.time);
    for (const l of a)
      r += l.type === "s" ? 1 : -1, r === 1 ? t = l.time : (t && +t != +l.time && s.push(q.fromDateTimes(t, l.time)), t = null);
    return q.merge(s);
  }
  /**
   * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.
   * @param {...Interval} intervals
   * @return {Array}
   */
  difference(...e) {
    return q.xor([this].concat(e)).map((t) => this.intersection(t)).filter((t) => t && !t.isEmpty());
  }
  /**
   * Returns a string representation of this Interval appropriate for debugging.
   * @return {string}
   */
  toString() {
    return this.isValid ? `[${this.s.toISO()} – ${this.e.toISO()})` : ar;
  }
  /**
   * Returns a localized string representing this Interval. Accepts the same options as the
   * Intl.DateTimeFormat constructor and any presets defined by Luxon, such as
   * {@link DateTime.DATE_FULL} or {@link DateTime.TIME_SIMPLE}. The exact behavior of this method
   * is browser-specific, but in general it will return an appropriate representation of the
   * Interval in the assigned locale. Defaults to the system's locale if no locale has been
   * specified.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {Object} [formatOpts=DateTime.DATE_SHORT] - Either a DateTime preset or
   * Intl.DateTimeFormat constructor options.
   * @param {Object} opts - Options to override the configuration of the start DateTime.
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(); //=> 11/7/2022 – 11/8/2022
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL); //=> November 7 – 8, 2022
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL, { locale: 'fr-FR' }); //=> 7–8 novembre 2022
   * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString(DateTime.TIME_SIMPLE); //=> 6:00 – 8:00 PM
   * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> Mon, Nov 07, 6:00 – 8:00 p
   * @return {string}
   */
  toLocaleString(e = $s, t = {}) {
    return this.isValid ? re.create(this.s.loc.clone(t), e).formatInterval(this) : ar;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Interval.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISO(e) {
    return this.isValid ? `${this.s.toISO(e)}/${this.e.toISO(e)}` : ar;
  }
  /**
   * Returns an ISO 8601-compliant string representation of date of this Interval.
   * The time components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {string}
   */
  toISODate() {
    return this.isValid ? `${this.s.toISODate()}/${this.e.toISODate()}` : ar;
  }
  /**
   * Returns an ISO 8601-compliant string representation of time of this Interval.
   * The date components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISOTime(e) {
    return this.isValid ? `${this.s.toISOTime(e)}/${this.e.toISOTime(e)}` : ar;
  }
  /**
   * Returns a string representation of this Interval formatted according to the specified format
   * string. **You may not want this.** See {@link Interval#toLocaleString} for a more flexible
   * formatting tool.
   * @param {string} dateFormat - The format string. This string formats the start and end time.
   * See {@link DateTime#toFormat} for details.
   * @param {Object} opts - Options.
   * @param {string} [opts.separator =  ' – '] - A separator to place between the start and end
   * representations.
   * @return {string}
   */
  toFormat(e, { separator: t = " – " } = {}) {
    return this.isValid ? `${this.s.toFormat(e)}${t}${this.e.toFormat(e)}` : ar;
  }
  /**
   * Return a Duration representing the time spanned by this interval.
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }
   * @return {Duration}
   */
  toDuration(e, t) {
    return this.isValid ? this.e.diff(this.s, e, t) : T.invalid(this.invalidReason);
  }
  /**
   * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes
   * @param {function} mapFn
   * @return {Interval}
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))
   */
  mapEndpoints(e) {
    return q.fromDateTimes(e(this.s), e(this.e));
  }
}
class rs {
  /**
   * Return whether the specified zone contains a DST.
   * @param {string|Zone} [zone='local'] - Zone to check. Defaults to the environment's local zone.
   * @return {boolean}
   */
  static hasDST(e = Z.defaultZone) {
    const t = x.now().setZone(e).set({ month: 12 });
    return !e.isUniversal && t.offset !== t.set({ month: 6 }).offset;
  }
  /**
   * Return whether the specified zone is a valid IANA specifier.
   * @param {string} zone - Zone to check
   * @return {boolean}
   */
  static isValidIANAZone(e) {
    return Je.isValidZone(e);
  }
  /**
   * Converts the input into a {@link Zone} instance.
   *
   * * If `input` is already a Zone instance, it is returned unchanged.
   * * If `input` is a string containing a valid time zone name, a Zone instance
   *   with that name is returned.
   * * If `input` is a string that doesn't refer to a known time zone, a Zone
   *   instance with {@link Zone#isValid} == false is returned.
   * * If `input is a number, a Zone instance with the specified fixed offset
   *   in minutes is returned.
   * * If `input` is `null` or `undefined`, the default zone is returned.
   * @param {string|Zone|number} [input] - the value to be converted
   * @return {Zone}
   */
  static normalizeZone(e) {
    return ft(e, Z.defaultZone);
  }
  /**
   * Return an array of standalone month names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @example Info.months()[0] //=> 'January'
   * @example Info.months('short')[0] //=> 'Jan'
   * @example Info.months('numeric')[0] //=> '1'
   * @example Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'
   * @example Info.months('numeric', { locale: 'ar' })[0] //=> '١'
   * @example Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabiʻ I'
   * @return {Array}
   */
  static months(e = "long", { locale: t = null, numberingSystem: r = null, locObj: s = null, outputCalendar: o = "gregory" } = {}) {
    return (s || L.create(t, r, o)).months(e);
  }
  /**
   * Return an array of format month names.
   * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that
   * changes the string.
   * See {@link Info#months}
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @return {Array}
   */
  static monthsFormat(e = "long", { locale: t = null, numberingSystem: r = null, locObj: s = null, outputCalendar: o = "gregory" } = {}) {
    return (s || L.create(t, r, o)).months(e, !0);
  }
  /**
   * Return an array of standalone week names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the weekday representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @example Info.weekdays()[0] //=> 'Monday'
   * @example Info.weekdays('short')[0] //=> 'Mon'
   * @example Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'
   * @example Info.weekdays('short', { locale: 'ar' })[0] //=> 'الاثنين'
   * @return {Array}
   */
  static weekdays(e = "long", { locale: t = null, numberingSystem: r = null, locObj: s = null } = {}) {
    return (s || L.create(t, r, null)).weekdays(e);
  }
  /**
   * Return an array of format week names.
   * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that
   * changes the string.
   * See {@link Info#weekdays}
   * @param {string} [length='long'] - the length of the month representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale=null] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @return {Array}
   */
  static weekdaysFormat(e = "long", { locale: t = null, numberingSystem: r = null, locObj: s = null } = {}) {
    return (s || L.create(t, r, null)).weekdays(e, !0);
  }
  /**
   * Return an array of meridiems.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.meridiems() //=> [ 'AM', 'PM' ]
   * @example Info.meridiems({ locale: 'my' }) //=> [ 'နံနက်', 'ညနေ' ]
   * @return {Array}
   */
  static meridiems({ locale: e = null } = {}) {
    return L.create(e).meridiems();
  }
  /**
   * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.
   * @param {string} [length='short'] - the length of the era representation, such as "short" or "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.eras() //=> [ 'BC', 'AD' ]
   * @example Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]
   * @example Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jésus-Christ', 'après Jésus-Christ' ]
   * @return {Array}
   */
  static eras(e = "short", { locale: t = null } = {}) {
    return L.create(t, null, "gregory").eras(e);
  }
  /**
   * Return the set of available features in this environment.
   * Some features of Luxon are not available in all environments. For example, on older browsers, relative time formatting support is not available. Use this function to figure out if that's the case.
   * Keys:
   * * `relative`: whether this environment supports relative time formatting
   * @example Info.features() //=> { relative: false }
   * @return {Object}
   */
  static features() {
    return { relative: xu() };
  }
}
function Hl(i, e) {
  const t = (s) => s.toUTC(0, { keepLocalTime: !0 }).startOf("day").valueOf(), r = t(e) - t(i);
  return Math.floor(T.fromMillis(r).as("days"));
}
function n_(i, e, t) {
  const r = [
    ["years", (l, c) => c.year - l.year],
    ["quarters", (l, c) => c.quarter - l.quarter + (c.year - l.year) * 4],
    ["months", (l, c) => c.month - l.month + (c.year - l.year) * 12],
    [
      "weeks",
      (l, c) => {
        const d = Hl(l, c);
        return (d - d % 7) / 7;
      }
    ],
    ["days", Hl]
  ], s = {}, o = i;
  let n, a;
  for (const [l, c] of r)
    t.indexOf(l) >= 0 && (n = l, s[l] = c(i, e), a = o.plus(s), a > e ? (s[l]--, i = o.plus(s), i > e && (a = i, s[l]--, i = o.plus(s))) : i = a);
  return [i, s, a, n];
}
function a_(i, e, t, r) {
  let [s, o, n, a] = n_(i, e, t);
  const l = e - s, c = t.filter(
    (u) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(u) >= 0
  );
  c.length === 0 && (n < e && (n = s.plus({ [a]: 1 })), n !== s && (o[a] = (o[a] || 0) + l / (n - s)));
  const d = T.fromObject(o, r);
  return c.length > 0 ? T.fromMillis(l, r).shiftTo(...c).plus(d) : d;
}
const wa = {
  arab: "[٠-٩]",
  arabext: "[۰-۹]",
  bali: "[᭐-᭙]",
  beng: "[০-৯]",
  deva: "[०-९]",
  fullwide: "[０-９]",
  gujr: "[૦-૯]",
  hanidec: "[〇|一|二|三|四|五|六|七|八|九]",
  khmr: "[០-៩]",
  knda: "[೦-೯]",
  laoo: "[໐-໙]",
  limb: "[᥆-᥏]",
  mlym: "[൦-൯]",
  mong: "[᠐-᠙]",
  mymr: "[၀-၉]",
  orya: "[୦-୯]",
  tamldec: "[௦-௯]",
  telu: "[౦-౯]",
  thai: "[๐-๙]",
  tibt: "[༠-༩]",
  latn: "\\d"
}, Bl = {
  arab: [1632, 1641],
  arabext: [1776, 1785],
  bali: [6992, 7001],
  beng: [2534, 2543],
  deva: [2406, 2415],
  fullwide: [65296, 65303],
  gujr: [2790, 2799],
  khmr: [6112, 6121],
  knda: [3302, 3311],
  laoo: [3792, 3801],
  limb: [6470, 6479],
  mlym: [3430, 3439],
  mong: [6160, 6169],
  mymr: [4160, 4169],
  orya: [2918, 2927],
  tamldec: [3046, 3055],
  telu: [3174, 3183],
  thai: [3664, 3673],
  tibt: [3872, 3881]
}, l_ = wa.hanidec.replace(/[\[|\]]/g, "").split("");
function c_(i) {
  let e = parseInt(i, 10);
  if (isNaN(e)) {
    e = "";
    for (let t = 0; t < i.length; t++) {
      const r = i.charCodeAt(t);
      if (i[t].search(wa.hanidec) !== -1)
        e += l_.indexOf(i[t]);
      else
        for (const s in Bl) {
          const [o, n] = Bl[s];
          r >= o && r <= n && (e += r - o);
        }
    }
    return parseInt(e, 10);
  } else
    return e;
}
function $e({ numberingSystem: i }, e = "") {
  return new RegExp(`${wa[i || "latn"]}${e}`);
}
const d_ = "missing Intl.DateTimeFormat.formatToParts support";
function $(i, e = (t) => t) {
  return { regex: i, deser: ([t]) => e(c_(t)) };
}
const u_ = String.fromCharCode(160), Vu = `[ ${u_}]`, Hu = new RegExp(Vu, "g");
function h_(i) {
  return i.replace(/\./g, "\\.?").replace(Hu, Vu);
}
function Ul(i) {
  return i.replace(/\./g, "").replace(Hu, " ").toLowerCase();
}
function Pe(i, e) {
  return i === null ? null : {
    regex: RegExp(i.map(h_).join("|")),
    deser: ([t]) => i.findIndex((r) => Ul(t) === Ul(r)) + e
  };
}
function ql(i, e) {
  return { regex: i, deser: ([, t, r]) => no(t, r), groups: e };
}
function is(i) {
  return { regex: i, deser: ([e]) => e };
}
function f_(i) {
  return i.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
}
function p_(i, e) {
  const t = $e(e), r = $e(e, "{2}"), s = $e(e, "{3}"), o = $e(e, "{4}"), n = $e(e, "{6}"), a = $e(e, "{1,2}"), l = $e(e, "{1,3}"), c = $e(e, "{1,6}"), d = $e(e, "{1,9}"), u = $e(e, "{2,4}"), h = $e(e, "{4,6}"), f = (k) => ({ regex: RegExp(f_(k.val)), deser: ([M]) => M, literal: !0 }), v = ((k) => {
    if (i.literal)
      return f(k);
    switch (k.val) {
      case "G":
        return Pe(e.eras("short"), 0);
      case "GG":
        return Pe(e.eras("long"), 0);
      case "y":
        return $(c);
      case "yy":
        return $(u, On);
      case "yyyy":
        return $(o);
      case "yyyyy":
        return $(h);
      case "yyyyyy":
        return $(n);
      case "M":
        return $(a);
      case "MM":
        return $(r);
      case "MMM":
        return Pe(e.months("short", !0), 1);
      case "MMMM":
        return Pe(e.months("long", !0), 1);
      case "L":
        return $(a);
      case "LL":
        return $(r);
      case "LLL":
        return Pe(e.months("short", !1), 1);
      case "LLLL":
        return Pe(e.months("long", !1), 1);
      case "d":
        return $(a);
      case "dd":
        return $(r);
      case "o":
        return $(l);
      case "ooo":
        return $(s);
      case "HH":
        return $(r);
      case "H":
        return $(a);
      case "hh":
        return $(r);
      case "h":
        return $(a);
      case "mm":
        return $(r);
      case "m":
        return $(a);
      case "q":
        return $(a);
      case "qq":
        return $(r);
      case "s":
        return $(a);
      case "ss":
        return $(r);
      case "S":
        return $(l);
      case "SSS":
        return $(s);
      case "u":
        return is(d);
      case "uu":
        return is(a);
      case "uuu":
        return $(t);
      case "a":
        return Pe(e.meridiems(), 0);
      case "kkkk":
        return $(o);
      case "kk":
        return $(u, On);
      case "W":
        return $(a);
      case "WW":
        return $(r);
      case "E":
      case "c":
        return $(t);
      case "EEE":
        return Pe(e.weekdays("short", !1), 1);
      case "EEEE":
        return Pe(e.weekdays("long", !1), 1);
      case "ccc":
        return Pe(e.weekdays("short", !0), 1);
      case "cccc":
        return Pe(e.weekdays("long", !0), 1);
      case "Z":
      case "ZZ":
        return ql(new RegExp(`([+-]${a.source})(?::(${r.source}))?`), 2);
      case "ZZZ":
        return ql(new RegExp(`([+-]${a.source})(${r.source})?`), 2);
      case "z":
        return is(/[a-z_+-/]{1,256}?/i);
      case " ":
        return is(/[^\S\n\r]/);
      default:
        return f(k);
    }
  })(i) || {
    invalidReason: d_
  };
  return v.token = i, v;
}
const m_ = {
  year: {
    "2-digit": "yy",
    numeric: "yyyyy"
  },
  month: {
    numeric: "M",
    "2-digit": "MM",
    short: "MMM",
    long: "MMMM"
  },
  day: {
    numeric: "d",
    "2-digit": "dd"
  },
  weekday: {
    short: "EEE",
    long: "EEEE"
  },
  dayperiod: "a",
  dayPeriod: "a",
  hour12: {
    numeric: "h",
    "2-digit": "hh"
  },
  hour24: {
    numeric: "H",
    "2-digit": "HH"
  },
  minute: {
    numeric: "m",
    "2-digit": "mm"
  },
  second: {
    numeric: "s",
    "2-digit": "ss"
  },
  timeZoneName: {
    long: "ZZZZZ",
    short: "ZZZ"
  }
};
function g_(i, e, t) {
  const { type: r, value: s } = i;
  if (r === "literal") {
    const l = /^\s+$/.test(s);
    return {
      literal: !l,
      val: l ? " " : s
    };
  }
  const o = e[r];
  let n = r;
  r === "hour" && (e.hour12 != null ? n = e.hour12 ? "hour12" : "hour24" : e.hourCycle != null ? e.hourCycle === "h11" || e.hourCycle === "h12" ? n = "hour12" : n = "hour24" : n = t.hour12 ? "hour12" : "hour24");
  let a = m_[n];
  if (typeof a == "object" && (a = a[o]), a)
    return {
      literal: !1,
      val: a
    };
}
function __(i) {
  return [`^${i.map((t) => t.regex).reduce((t, r) => `${t}(${r.source})`, "")}$`, i];
}
function b_(i, e, t) {
  const r = i.match(e);
  if (r) {
    const s = {};
    let o = 1;
    for (const n in t)
      if (Er(t, n)) {
        const a = t[n], l = a.groups ? a.groups + 1 : 1;
        !a.literal && a.token && (s[a.token.val[0]] = a.deser(r.slice(o, o + l))), o += l;
      }
    return [r, s];
  } else
    return [r, {}];
}
function y_(i) {
  const e = (o) => {
    switch (o) {
      case "S":
        return "millisecond";
      case "s":
        return "second";
      case "m":
        return "minute";
      case "h":
      case "H":
        return "hour";
      case "d":
        return "day";
      case "o":
        return "ordinal";
      case "L":
      case "M":
        return "month";
      case "y":
        return "year";
      case "E":
      case "c":
        return "weekday";
      case "W":
        return "weekNumber";
      case "k":
        return "weekYear";
      case "q":
        return "quarter";
      default:
        return null;
    }
  };
  let t = null, r;
  return E(i.z) || (t = Je.create(i.z)), E(i.Z) || (t || (t = new oe(i.Z)), r = i.Z), E(i.q) || (i.M = (i.q - 1) * 3 + 1), E(i.h) || (i.h < 12 && i.a === 1 ? i.h += 12 : i.h === 12 && i.a === 0 && (i.h = 0)), i.G === 0 && i.y && (i.y = -i.y), E(i.u) || (i.S = ga(i.u)), [Object.keys(i).reduce((o, n) => {
    const a = e(n);
    return a && (o[a] = i[n]), o;
  }, {}), t, r];
}
let Ho = null;
function v_() {
  return Ho || (Ho = x.fromMillis(1555555555555)), Ho;
}
function w_(i, e) {
  if (i.literal)
    return i;
  const t = re.macroTokenToFormatOpts(i.val), r = qu(t, e);
  return r == null || r.includes(void 0) ? i : r;
}
function Bu(i, e) {
  return Array.prototype.concat(...i.map((t) => w_(t, e)));
}
function Uu(i, e, t) {
  const r = Bu(re.parseFormat(t), i), s = r.map((n) => p_(n, i)), o = s.find((n) => n.invalidReason);
  if (o)
    return { input: e, tokens: r, invalidReason: o.invalidReason };
  {
    const [n, a] = __(s), l = RegExp(n, "i"), [c, d] = b_(e, l, a), [u, h, f] = d ? y_(d) : [null, null, void 0];
    if (Er(d, "a") && Er(d, "H"))
      throw new ii(
        "Can't include meridiem when specifying 24-hour format"
      );
    return { input: e, tokens: r, regex: l, rawMatches: c, matches: d, result: u, zone: h, specificOffset: f };
  }
}
function x_(i, e, t) {
  const { result: r, zone: s, specificOffset: o, invalidReason: n } = Uu(i, e, t);
  return [r, s, o, n];
}
function qu(i, e) {
  if (!i)
    return null;
  const r = re.create(e, i).dtFormatter(v_()), s = r.formatToParts(), o = r.resolvedOptions();
  return s.map((n) => g_(n, i, o));
}
const Wu = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334], ju = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
function ke(i, e) {
  return new Ne(
    "unit out of range",
    `you specified ${e} (of type ${typeof e}) as a ${i}, which is invalid`
  );
}
function Gu(i, e, t) {
  const r = new Date(Date.UTC(i, e - 1, t));
  i < 100 && i >= 0 && r.setUTCFullYear(r.getUTCFullYear() - 1900);
  const s = r.getUTCDay();
  return s === 0 ? 7 : s;
}
function Yu(i, e, t) {
  return t + (Ni(i) ? ju : Wu)[e - 1];
}
function Zu(i, e) {
  const t = Ni(i) ? ju : Wu, r = t.findIndex((o) => o < e), s = e - t[r];
  return { month: r + 1, day: s };
}
function $n(i) {
  const { year: e, month: t, day: r } = i, s = Yu(e, t, r), o = Gu(e, t, r);
  let n = Math.floor((s - o + 10) / 7), a;
  return n < 1 ? (a = e - 1, n = Ms(a)) : n > Ms(e) ? (a = e + 1, n = 1) : a = e, { weekYear: a, weekNumber: n, weekday: o, ...ao(i) };
}
function Wl(i) {
  const { weekYear: e, weekNumber: t, weekday: r } = i, s = Gu(e, 1, 4), o = ci(e);
  let n = t * 7 + r - s - 3, a;
  n < 1 ? (a = e - 1, n += ci(a)) : n > o ? (a = e + 1, n -= ci(e)) : a = e;
  const { month: l, day: c } = Zu(a, n);
  return { year: a, month: l, day: c, ...ao(i) };
}
function Bo(i) {
  const { year: e, month: t, day: r } = i, s = Yu(e, t, r);
  return { year: e, ordinal: s, ...ao(i) };
}
function jl(i) {
  const { year: e, ordinal: t } = i, { month: r, day: s } = Zu(e, t);
  return { year: e, month: r, day: s, ...ao(i) };
}
function C_(i) {
  const e = so(i.weekYear), t = Ze(i.weekNumber, 1, Ms(i.weekYear)), r = Ze(i.weekday, 1, 7);
  return e ? t ? r ? !1 : ke("weekday", i.weekday) : ke("week", i.week) : ke("weekYear", i.weekYear);
}
function k_(i) {
  const e = so(i.year), t = Ze(i.ordinal, 1, ci(i.year));
  return e ? t ? !1 : ke("ordinal", i.ordinal) : ke("year", i.year);
}
function Ku(i) {
  const e = so(i.year), t = Ze(i.month, 1, 12), r = Ze(i.day, 1, Ps(i.year, i.month));
  return e ? t ? r ? !1 : ke("day", i.day) : ke("month", i.month) : ke("year", i.year);
}
function Qu(i) {
  const { hour: e, minute: t, second: r, millisecond: s } = i, o = Ze(e, 0, 23) || e === 24 && t === 0 && r === 0 && s === 0, n = Ze(t, 0, 59), a = Ze(r, 0, 59), l = Ze(s, 0, 999);
  return o ? n ? a ? l ? !1 : ke("millisecond", s) : ke("second", r) : ke("minute", t) : ke("hour", e);
}
const Uo = "Invalid DateTime", Gl = 864e13;
function ss(i) {
  return new Ne("unsupported zone", `the zone "${i.name}" is not supported`);
}
function qo(i) {
  return i.weekData === null && (i.weekData = $n(i.c)), i.weekData;
}
function $t(i, e) {
  const t = {
    ts: i.ts,
    zone: i.zone,
    c: i.c,
    o: i.o,
    loc: i.loc,
    invalid: i.invalid
  };
  return new x({ ...t, ...e, old: t });
}
function Ju(i, e, t) {
  let r = i - e * 60 * 1e3;
  const s = t.offset(r);
  if (e === s)
    return [r, e];
  r -= (s - e) * 60 * 1e3;
  const o = t.offset(r);
  return s === o ? [r, s] : [i - Math.min(s, o) * 60 * 1e3, Math.max(s, o)];
}
function os(i, e) {
  i += e * 60 * 1e3;
  const t = new Date(i);
  return {
    year: t.getUTCFullYear(),
    month: t.getUTCMonth() + 1,
    day: t.getUTCDate(),
    hour: t.getUTCHours(),
    minute: t.getUTCMinutes(),
    second: t.getUTCSeconds(),
    millisecond: t.getUTCMilliseconds()
  };
}
function xs(i, e, t) {
  return Ju(oo(i), e, t);
}
function Yl(i, e) {
  const t = i.o, r = i.c.year + Math.trunc(e.years), s = i.c.month + Math.trunc(e.months) + Math.trunc(e.quarters) * 3, o = {
    ...i.c,
    year: r,
    month: s,
    day: Math.min(i.c.day, Ps(r, s)) + Math.trunc(e.days) + Math.trunc(e.weeks) * 7
  }, n = T.fromObject({
    years: e.years - Math.trunc(e.years),
    quarters: e.quarters - Math.trunc(e.quarters),
    months: e.months - Math.trunc(e.months),
    weeks: e.weeks - Math.trunc(e.weeks),
    days: e.days - Math.trunc(e.days),
    hours: e.hours,
    minutes: e.minutes,
    seconds: e.seconds,
    milliseconds: e.milliseconds
  }).as("milliseconds"), a = oo(o);
  let [l, c] = Ju(a, t, i.zone);
  return n !== 0 && (l += n, c = i.zone.offset(l)), { ts: l, o: c };
}
function jr(i, e, t, r, s, o) {
  const { setZone: n, zone: a } = t;
  if (i && Object.keys(i).length !== 0 || e) {
    const l = e || a, c = x.fromObject(i, {
      ...t,
      zone: l,
      specificOffset: o
    });
    return n ? c : c.setZone(a);
  } else
    return x.invalid(
      new Ne("unparsable", `the input "${s}" can't be parsed as ${r}`)
    );
}
function ns(i, e, t = !0) {
  return i.isValid ? re.create(L.create("en-US"), {
    allowZ: t,
    forceSimple: !0
  }).formatDateTimeFromString(i, e) : null;
}
function Wo(i, e) {
  const t = i.c.year > 9999 || i.c.year < 0;
  let r = "";
  return t && i.c.year >= 0 && (r += "+"), r += Q(i.c.year, t ? 6 : 4), e ? (r += "-", r += Q(i.c.month), r += "-", r += Q(i.c.day)) : (r += Q(i.c.month), r += Q(i.c.day)), r;
}
function Zl(i, e, t, r, s, o) {
  let n = Q(i.c.hour);
  return e ? (n += ":", n += Q(i.c.minute), (i.c.millisecond !== 0 || i.c.second !== 0 || !t) && (n += ":")) : n += Q(i.c.minute), (i.c.millisecond !== 0 || i.c.second !== 0 || !t) && (n += Q(i.c.second), (i.c.millisecond !== 0 || !r) && (n += ".", n += Q(i.c.millisecond, 3))), s && (i.isOffsetFixed && i.offset === 0 && !o ? n += "Z" : i.o < 0 ? (n += "-", n += Q(Math.trunc(-i.o / 60)), n += ":", n += Q(Math.trunc(-i.o % 60))) : (n += "+", n += Q(Math.trunc(i.o / 60)), n += ":", n += Q(Math.trunc(i.o % 60)))), o && (n += "[" + i.zone.ianaName + "]"), n;
}
const Xu = {
  month: 1,
  day: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
}, A_ = {
  weekNumber: 1,
  weekday: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
}, E_ = {
  ordinal: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
}, eh = ["year", "month", "day", "hour", "minute", "second", "millisecond"], S_ = [
  "weekYear",
  "weekNumber",
  "weekday",
  "hour",
  "minute",
  "second",
  "millisecond"
], T_ = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
function Kl(i) {
  const e = {
    year: "year",
    years: "year",
    month: "month",
    months: "month",
    day: "day",
    days: "day",
    hour: "hour",
    hours: "hour",
    minute: "minute",
    minutes: "minute",
    quarter: "quarter",
    quarters: "quarter",
    second: "second",
    seconds: "second",
    millisecond: "millisecond",
    milliseconds: "millisecond",
    weekday: "weekday",
    weekdays: "weekday",
    weeknumber: "weekNumber",
    weeksnumber: "weekNumber",
    weeknumbers: "weekNumber",
    weekyear: "weekYear",
    weekyears: "weekYear",
    ordinal: "ordinal"
  }[i.toLowerCase()];
  if (!e)
    throw new ru(i);
  return e;
}
function Ql(i, e) {
  const t = ft(e.zone, Z.defaultZone), r = L.fromObject(e), s = Z.now();
  let o, n;
  if (E(i.year))
    o = s;
  else {
    for (const c of eh)
      E(i[c]) && (i[c] = Xu[c]);
    const a = Ku(i) || Qu(i);
    if (a)
      return x.invalid(a);
    const l = t.offset(s);
    [o, n] = xs(i, l, t);
  }
  return new x({ ts: o, zone: t, loc: r, o: n });
}
function Jl(i, e, t) {
  const r = E(t.round) ? !0 : t.round, s = (n, a) => (n = _a(n, r || t.calendary ? 0 : 2, !0), e.loc.clone(t).relFormatter(t).format(n, a)), o = (n) => t.calendary ? e.hasSame(i, n) ? 0 : e.startOf(n).diff(i.startOf(n), n).get(n) : e.diff(i, n).get(n);
  if (t.unit)
    return s(o(t.unit), t.unit);
  for (const n of t.units) {
    const a = o(n);
    if (Math.abs(a) >= 1)
      return s(a, n);
  }
  return s(i > e ? -0 : 0, t.units[t.units.length - 1]);
}
function Xl(i) {
  let e = {}, t;
  return i.length > 0 && typeof i[i.length - 1] == "object" ? (e = i[i.length - 1], t = Array.from(i).slice(0, i.length - 1)) : t = Array.from(i), [e, t];
}
class x {
  /**
   * @access private
   */
  constructor(e) {
    const t = e.zone || Z.defaultZone;
    let r = e.invalid || (Number.isNaN(e.ts) ? new Ne("invalid input") : null) || (t.isValid ? null : ss(t));
    this.ts = E(e.ts) ? Z.now() : e.ts;
    let s = null, o = null;
    if (!r)
      if (e.old && e.old.ts === this.ts && e.old.zone.equals(t))
        [s, o] = [e.old.c, e.old.o];
      else {
        const a = t.offset(this.ts);
        s = os(this.ts, a), r = Number.isNaN(s.year) ? new Ne("invalid input") : null, s = r ? null : s, o = r ? null : a;
      }
    this._zone = t, this.loc = e.loc || L.create(), this.invalid = r, this.weekData = null, this.c = s, this.o = o, this.isLuxonDateTime = !0;
  }
  // CONSTRUCT
  /**
   * Create a DateTime for the current instant, in the system's time zone.
   *
   * Use Settings to override these default values if needed.
   * @example DateTime.now().toISO() //~> now in the ISO format
   * @return {DateTime}
   */
  static now() {
    return new x({});
  }
  /**
   * Create a local DateTime
   * @param {number} [year] - The calendar year. If omitted (as in, call `local()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month, 1-indexed
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @example DateTime.local()                                  //~> now
   * @example DateTime.local({ zone: "America/New_York" })      //~> now, in US east coast time
   * @example DateTime.local(2017)                              //~> 2017-01-01T00:00:00
   * @example DateTime.local(2017, 3)                           //~> 2017-03-01T00:00:00
   * @example DateTime.local(2017, 3, 12, { locale: "fr" })     //~> 2017-03-12T00:00:00, with a French locale
   * @example DateTime.local(2017, 3, 12, 5)                    //~> 2017-03-12T05:00:00
   * @example DateTime.local(2017, 3, 12, 5, { zone: "utc" })   //~> 2017-03-12T05:00:00, in UTC
   * @example DateTime.local(2017, 3, 12, 5, 45)                //~> 2017-03-12T05:45:00
   * @example DateTime.local(2017, 3, 12, 5, 45, 10)            //~> 2017-03-12T05:45:10
   * @example DateTime.local(2017, 3, 12, 5, 45, 10, 765)       //~> 2017-03-12T05:45:10.765
   * @return {DateTime}
   */
  static local() {
    const [e, t] = Xl(arguments), [r, s, o, n, a, l, c] = t;
    return Ql({ year: r, month: s, day: o, hour: n, minute: a, second: l, millisecond: c }, e);
  }
  /**
   * Create a DateTime in UTC
   * @param {number} [year] - The calendar year. If omitted (as in, call `utc()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @param {Object} options - configuration options for the DateTime
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} [options.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [options.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @example DateTime.utc()                                              //~> now
   * @example DateTime.utc(2017)                                          //~> 2017-01-01T00:00:00Z
   * @example DateTime.utc(2017, 3)                                       //~> 2017-03-01T00:00:00Z
   * @example DateTime.utc(2017, 3, 12)                                   //~> 2017-03-12T00:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5)                                //~> 2017-03-12T05:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45)                            //~> 2017-03-12T05:45:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, { locale: "fr" })          //~> 2017-03-12T05:45:00Z with a French locale
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10)                        //~> 2017-03-12T05:45:10Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10, 765, { locale: "fr" }) //~> 2017-03-12T05:45:10.765Z with a French locale
   * @return {DateTime}
   */
  static utc() {
    const [e, t] = Xl(arguments), [r, s, o, n, a, l, c] = t;
    return e.zone = oe.utcInstance, Ql({ year: r, month: s, day: o, hour: n, minute: a, second: l, millisecond: c }, e);
  }
  /**
   * Create a DateTime from a JavaScript Date object. Uses the default zone.
   * @param {Date} date - a JavaScript Date object
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @return {DateTime}
   */
  static fromJSDate(e, t = {}) {
    const r = rg(e) ? e.valueOf() : NaN;
    if (Number.isNaN(r))
      return x.invalid("invalid input");
    const s = ft(t.zone, Z.defaultZone);
    return s.isValid ? new x({
      ts: r,
      zone: s,
      loc: L.fromObject(t)
    }) : x.invalid(ss(s));
  }
  /**
   * Create a DateTime from a number of milliseconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} milliseconds - a number of milliseconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromMillis(e, t = {}) {
    if (qt(e))
      return e < -Gl || e > Gl ? x.invalid("Timestamp out of range") : new x({
        ts: e,
        zone: ft(t.zone, Z.defaultZone),
        loc: L.fromObject(t)
      });
    throw new xe(
      `fromMillis requires a numerical input, but received a ${typeof e} with value ${e}`
    );
  }
  /**
   * Create a DateTime from a number of seconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} seconds - a number of seconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromSeconds(e, t = {}) {
    if (qt(e))
      return new x({
        ts: e * 1e3,
        zone: ft(t.zone, Z.defaultZone),
        loc: L.fromObject(t)
      });
    throw new xe("fromSeconds requires a numerical input");
  }
  /**
   * Create a DateTime from a JavaScript object with keys like 'year' and 'hour' with reasonable defaults.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.year - a year, such as 1987
   * @param {number} obj.month - a month, 1-12
   * @param {number} obj.day - a day of the month, 1-31, depending on the month
   * @param {number} obj.ordinal - day of the year, 1-365 or 366
   * @param {number} obj.weekYear - an ISO week year
   * @param {number} obj.weekNumber - an ISO week number, between 1 and 52 or 53, depending on the year
   * @param {number} obj.weekday - an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday
   * @param {number} obj.hour - hour of the day, 0-23
   * @param {number} obj.minute - minute of the hour, 0-59
   * @param {number} obj.second - second of the minute, 0-59
   * @param {number} obj.millisecond - millisecond of the second, 0-999
   * @param {Object} opts - options for creating this DateTime
   * @param {string|Zone} [opts.zone='local'] - interpret the numbers in the context of a particular zone. Can take any value taken as the first argument to setZone()
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'
   * @example DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'utc' }),
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'local' })
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'America/New_York' })
   * @example DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'
   * @return {DateTime}
   */
  static fromObject(e, t = {}) {
    e = e || {};
    const r = ft(t.zone, Z.defaultZone);
    if (!r.isValid)
      return x.invalid(ss(r));
    const s = Z.now(), o = E(t.specificOffset) ? r.offset(s) : t.specificOffset, n = zs(e, Kl), a = !E(n.ordinal), l = !E(n.year), c = !E(n.month) || !E(n.day), d = l || c, u = n.weekYear || n.weekNumber, h = L.fromObject(t);
    if ((d || a) && u)
      throw new ii(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    if (c && a)
      throw new ii("Can't mix ordinal dates with month/day");
    const f = u || n.weekday && !d;
    let m, v, k = os(s, o);
    f ? (m = S_, v = A_, k = $n(k)) : a ? (m = T_, v = E_, k = Bo(k)) : (m = eh, v = Xu);
    let M = !1;
    for (const De of m) {
      const Io = n[De];
      E(Io) ? M ? n[De] = v[De] : n[De] = k[De] : M = !0;
    }
    const F = f ? C_(n) : a ? k_(n) : Ku(n), se = F || Qu(n);
    if (se)
      return x.invalid(se);
    const he = f ? Wl(n) : a ? jl(n) : n, [j, Ie] = xs(he, o, r), je = new x({
      ts: j,
      zone: r,
      o: Ie,
      loc: h
    });
    return n.weekday && d && e.weekday !== je.weekday ? x.invalid(
      "mismatched weekday",
      `you can't specify both a weekday of ${n.weekday} and a date of ${je.toISO()}`
    ) : je;
  }
  /**
   * Create a DateTime from an ISO 8601 string
   * @param {string} text - the ISO string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the time to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} [opts.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [opts.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromISO('2016-05-25T09:08:34.123')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})
   * @example DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})
   * @example DateTime.fromISO('2016-W05-4')
   * @return {DateTime}
   */
  static fromISO(e, t = {}) {
    const [r, s] = Wg(e);
    return jr(r, s, t, "ISO 8601", e);
  }
  /**
   * Create a DateTime from an RFC 2822 string
   * @param {string} text - the RFC 2822 string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since the offset is always specified in the string itself, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')
   * @example DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23 Z')
   * @return {DateTime}
   */
  static fromRFC2822(e, t = {}) {
    const [r, s] = jg(e);
    return jr(r, s, t, "RFC 2822", e);
  }
  /**
   * Create a DateTime from an HTTP header date
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @param {string} text - the HTTP header date
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since HTTP dates are always in UTC, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with the fixed-offset zone specified in the string. For HTTP dates, this is always UTC, so this option is equivalent to setting the `zone` option to 'utc', but this option is included for consistency with similar methods.
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sun Nov  6 08:49:37 1994')
   * @return {DateTime}
   */
  static fromHTTP(e, t = {}) {
    const [r, s] = Gg(e);
    return jr(r, s, t, "HTTP", t);
  }
  /**
   * Create a DateTime from an input string and format string.
   * Defaults to en-US if no locale has been specified, regardless of the system's locale. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/parsing?id=table-of-tokens).
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see the link below for the formats)
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromFormat(e, t, r = {}) {
    if (E(e) || E(t))
      throw new xe("fromFormat requires an input string and a format");
    const { locale: s = null, numberingSystem: o = null } = r, n = L.fromOpts({
      locale: s,
      numberingSystem: o,
      defaultToEN: !0
    }), [a, l, c, d] = x_(n, e, t);
    return d ? x.invalid(d) : jr(a, l, r, `format ${t}`, e, c);
  }
  /**
   * @deprecated use fromFormat instead
   */
  static fromString(e, t, r = {}) {
    return x.fromFormat(e, t, r);
  }
  /**
   * Create a DateTime from a SQL date, time, or datetime
   * Defaults to en-US if no locale has been specified, regardless of the system's locale
   * @param {string} text - the string to parse
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @example DateTime.fromSQL('2017-05-15')
   * @example DateTime.fromSQL('2017-05-15 09:12:34')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })
   * @example DateTime.fromSQL('09:12:34.342')
   * @return {DateTime}
   */
  static fromSQL(e, t = {}) {
    const [r, s] = e_(e);
    return jr(r, s, t, "SQL", e);
  }
  /**
   * Create an invalid DateTime.
   * @param {string} reason - simple string of why this DateTime is invalid. Should not contain parameters or anything else data-dependent.
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {DateTime}
   */
  static invalid(e, t = null) {
    if (!e)
      throw new xe("need to specify a reason the DateTime is invalid");
    const r = e instanceof Ne ? e : new Ne(e, t);
    if (Z.throwOnInvalid)
      throw new Pm(r);
    return new x({ invalid: r });
  }
  /**
   * Check if an object is an instance of DateTime. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDateTime(e) {
    return e && e.isLuxonDateTime || !1;
  }
  /**
   * Produce the format string for a set of options
   * @param formatOpts
   * @param localeOpts
   * @returns {string}
   */
  static parseFormatForOpts(e, t = {}) {
    const r = qu(e, L.fromObject(t));
    return r ? r.map((s) => s ? s.val : null).join("") : null;
  }
  /**
   * Produce the the fully expanded format token for the locale
   * Does NOT quote characters, so quoted tokens will not round trip correctly
   * @param fmt
   * @param localeOpts
   * @returns {string}
   */
  static expandFormat(e, t = {}) {
    return Bu(re.parseFormat(e), L.fromObject(t)).map((s) => s.val).join("");
  }
  // INFO
  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example DateTime.local(2017, 7, 4).get('month'); //=> 7
   * @example DateTime.local(2017, 7, 4).get('day'); //=> 4
   * @return {number}
   */
  get(e) {
    return this[e];
  }
  /**
   * Returns whether the DateTime is valid. Invalid DateTimes occur when:
   * * The DateTime was created from invalid calendar information, such as the 13th month or February 30
   * * The DateTime was created by an operation on another invalid date
   * @type {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }
  /**
   * Returns an error code if this DateTime is invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime
   *
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  /**
   * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  /**
   * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime
   *
   * @type {string}
   */
  get outputCalendar() {
    return this.isValid ? this.loc.outputCalendar : null;
  }
  /**
   * Get the time zone associated with this DateTime.
   * @type {Zone}
   */
  get zone() {
    return this._zone;
  }
  /**
   * Get the name of the time zone.
   * @type {string}
   */
  get zoneName() {
    return this.isValid ? this.zone.name : null;
  }
  /**
   * Get the year
   * @example DateTime.local(2017, 5, 25).year //=> 2017
   * @type {number}
   */
  get year() {
    return this.isValid ? this.c.year : NaN;
  }
  /**
   * Get the quarter
   * @example DateTime.local(2017, 5, 25).quarter //=> 2
   * @type {number}
   */
  get quarter() {
    return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
  }
  /**
   * Get the month (1-12).
   * @example DateTime.local(2017, 5, 25).month //=> 5
   * @type {number}
   */
  get month() {
    return this.isValid ? this.c.month : NaN;
  }
  /**
   * Get the day of the month (1-30ish).
   * @example DateTime.local(2017, 5, 25).day //=> 25
   * @type {number}
   */
  get day() {
    return this.isValid ? this.c.day : NaN;
  }
  /**
   * Get the hour of the day (0-23).
   * @example DateTime.local(2017, 5, 25, 9).hour //=> 9
   * @type {number}
   */
  get hour() {
    return this.isValid ? this.c.hour : NaN;
  }
  /**
   * Get the minute of the hour (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30).minute //=> 30
   * @type {number}
   */
  get minute() {
    return this.isValid ? this.c.minute : NaN;
  }
  /**
   * Get the second of the minute (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52
   * @type {number}
   */
  get second() {
    return this.isValid ? this.c.second : NaN;
  }
  /**
   * Get the millisecond of the second (0-999).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654
   * @type {number}
   */
  get millisecond() {
    return this.isValid ? this.c.millisecond : NaN;
  }
  /**
   * Get the week year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 12, 31).weekYear //=> 2015
   * @type {number}
   */
  get weekYear() {
    return this.isValid ? qo(this).weekYear : NaN;
  }
  /**
   * Get the week number of the week year (1-52ish).
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2017, 5, 25).weekNumber //=> 21
   * @type {number}
   */
  get weekNumber() {
    return this.isValid ? qo(this).weekNumber : NaN;
  }
  /**
   * Get the day of the week.
   * 1 is Monday and 7 is Sunday
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 11, 31).weekday //=> 4
   * @type {number}
   */
  get weekday() {
    return this.isValid ? qo(this).weekday : NaN;
  }
  /**
   * Get the ordinal (meaning the day of the year)
   * @example DateTime.local(2017, 5, 25).ordinal //=> 145
   * @type {number|DateTime}
   */
  get ordinal() {
    return this.isValid ? Bo(this.c).ordinal : NaN;
  }
  /**
   * Get the human readable short month name, such as 'Oct'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthShort //=> Oct
   * @type {string}
   */
  get monthShort() {
    return this.isValid ? rs.months("short", { locObj: this.loc })[this.month - 1] : null;
  }
  /**
   * Get the human readable long month name, such as 'October'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthLong //=> October
   * @type {string}
   */
  get monthLong() {
    return this.isValid ? rs.months("long", { locObj: this.loc })[this.month - 1] : null;
  }
  /**
   * Get the human readable short weekday, such as 'Mon'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayShort //=> Mon
   * @type {string}
   */
  get weekdayShort() {
    return this.isValid ? rs.weekdays("short", { locObj: this.loc })[this.weekday - 1] : null;
  }
  /**
   * Get the human readable long weekday, such as 'Monday'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayLong //=> Monday
   * @type {string}
   */
  get weekdayLong() {
    return this.isValid ? rs.weekdays("long", { locObj: this.loc })[this.weekday - 1] : null;
  }
  /**
   * Get the UTC offset of this DateTime in minutes
   * @example DateTime.now().offset //=> -240
   * @example DateTime.utc().offset //=> 0
   * @type {number}
   */
  get offset() {
    return this.isValid ? +this.o : NaN;
  }
  /**
   * Get the short human name for the zone's current offset, for example "EST" or "EDT".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameShort() {
    return this.isValid ? this.zone.offsetName(this.ts, {
      format: "short",
      locale: this.locale
    }) : null;
  }
  /**
   * Get the long human name for the zone's current offset, for example "Eastern Standard Time" or "Eastern Daylight Time".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameLong() {
    return this.isValid ? this.zone.offsetName(this.ts, {
      format: "long",
      locale: this.locale
    }) : null;
  }
  /**
   * Get whether this zone's offset ever changes, as in a DST.
   * @type {boolean}
   */
  get isOffsetFixed() {
    return this.isValid ? this.zone.isUniversal : null;
  }
  /**
   * Get whether the DateTime is in a DST.
   * @type {boolean}
   */
  get isInDST() {
    return this.isOffsetFixed ? !1 : this.offset > this.set({ month: 1, day: 1 }).offset || this.offset > this.set({ month: 5 }).offset;
  }
  /**
   * Get those DateTimes which have the same local time as this DateTime, but a different offset from UTC
   * in this DateTime's zone. During DST changes local time can be ambiguous, for example
   * `2023-10-29T02:30:00` in `Europe/Berlin` can have offset `+01:00` or `+02:00`.
   * This method will return both possible DateTimes if this DateTime's local time is ambiguous.
   * @returns {DateTime[]}
   */
  getPossibleOffsets() {
    if (!this.isValid || this.isOffsetFixed)
      return [this];
    const e = 864e5, t = 6e4, r = oo(this.c), s = this.zone.offset(r - e), o = this.zone.offset(r + e), n = this.zone.offset(r - s * t), a = this.zone.offset(r - o * t);
    if (n === a)
      return [this];
    const l = r - n * t, c = r - a * t, d = os(l, n), u = os(c, a);
    return d.hour === u.hour && d.minute === u.minute && d.second === u.second && d.millisecond === u.millisecond ? [$t(this, { ts: l }), $t(this, { ts: c })] : [this];
  }
  /**
   * Returns true if this DateTime is in a leap year, false otherwise
   * @example DateTime.local(2016).isInLeapYear //=> true
   * @example DateTime.local(2013).isInLeapYear //=> false
   * @type {boolean}
   */
  get isInLeapYear() {
    return Ni(this.year);
  }
  /**
   * Returns the number of days in this DateTime's month
   * @example DateTime.local(2016, 2).daysInMonth //=> 29
   * @example DateTime.local(2016, 3).daysInMonth //=> 31
   * @type {number}
   */
  get daysInMonth() {
    return Ps(this.year, this.month);
  }
  /**
   * Returns the number of days in this DateTime's year
   * @example DateTime.local(2016).daysInYear //=> 366
   * @example DateTime.local(2013).daysInYear //=> 365
   * @type {number}
   */
  get daysInYear() {
    return this.isValid ? ci(this.year) : NaN;
  }
  /**
   * Returns the number of weeks in this DateTime's year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2004).weeksInWeekYear //=> 53
   * @example DateTime.local(2013).weeksInWeekYear //=> 52
   * @type {number}
   */
  get weeksInWeekYear() {
    return this.isValid ? Ms(this.weekYear) : NaN;
  }
  /**
   * Returns the resolved Intl options for this DateTime.
   * This is useful in understanding the behavior of formatting methods
   * @param {Object} opts - the same options as toLocaleString
   * @return {Object}
   */
  resolvedLocaleOptions(e = {}) {
    const { locale: t, numberingSystem: r, calendar: s } = re.create(
      this.loc.clone(e),
      e
    ).resolvedOptions(this);
    return { locale: t, numberingSystem: r, outputCalendar: s };
  }
  // TRANSFORM
  /**
   * "Set" the DateTime's zone to UTC. Returns a newly-constructed DateTime.
   *
   * Equivalent to {@link DateTime#setZone}('utc')
   * @param {number} [offset=0] - optionally, an offset from UTC in minutes
   * @param {Object} [opts={}] - options to pass to `setZone()`
   * @return {DateTime}
   */
  toUTC(e = 0, t = {}) {
    return this.setZone(oe.instance(e), t);
  }
  /**
   * "Set" the DateTime's zone to the host's local zone. Returns a newly-constructed DateTime.
   *
   * Equivalent to `setZone('local')`
   * @return {DateTime}
   */
  toLocal() {
    return this.setZone(Z.defaultZone);
  }
  /**
   * "Set" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.
   *
   * By default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will report different local times and consider DSTs when making computations, as with {@link DateTime#plus}. You may wish to use {@link DateTime#toLocal} and {@link DateTime#toUTC} which provide simple convenience wrappers for commonly used zones.
   * @param {string|Zone} [zone='local'] - a zone identifier. As a string, that can be any IANA zone supported by the host environment, or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'. You may also supply an instance of a {@link DateTime#Zone} class.
   * @param {Object} opts - options
   * @param {boolean} [opts.keepLocalTime=false] - If true, adjust the underlying time so that the local time stays the same, but in the target zone. You should rarely need this.
   * @return {DateTime}
   */
  setZone(e, { keepLocalTime: t = !1, keepCalendarTime: r = !1 } = {}) {
    if (e = ft(e, Z.defaultZone), e.equals(this.zone))
      return this;
    if (e.isValid) {
      let s = this.ts;
      if (t || r) {
        const o = e.offset(this.ts), n = this.toObject();
        [s] = xs(n, o, e);
      }
      return $t(this, { ts: s, zone: e });
    } else
      return x.invalid(ss(e));
  }
  /**
   * "Set" the locale, numberingSystem, or outputCalendar. Returns a newly-constructed DateTime.
   * @param {Object} properties - the properties to set
   * @example DateTime.local(2017, 5, 25).reconfigure({ locale: 'en-GB' })
   * @return {DateTime}
   */
  reconfigure({ locale: e, numberingSystem: t, outputCalendar: r } = {}) {
    const s = this.loc.clone({ locale: e, numberingSystem: t, outputCalendar: r });
    return $t(this, { loc: s });
  }
  /**
   * "Set" the locale. Returns a newly-constructed DateTime.
   * Just a convenient alias for reconfigure({ locale })
   * @example DateTime.local(2017, 5, 25).setLocale('en-GB')
   * @return {DateTime}
   */
  setLocale(e) {
    return this.reconfigure({ locale: e });
  }
  /**
   * "Set" the values of specified units. Returns a newly-constructed DateTime.
   * You can only set units with this method; for "setting" metadata, see {@link DateTime#reconfigure} and {@link DateTime#setZone}.
   * @param {Object} values - a mapping of units to numbers
   * @example dt.set({ year: 2017 })
   * @example dt.set({ hour: 8, minute: 30 })
   * @example dt.set({ weekday: 5 })
   * @example dt.set({ year: 2005, ordinal: 234 })
   * @return {DateTime}
   */
  set(e) {
    if (!this.isValid)
      return this;
    const t = zs(e, Kl), r = !E(t.weekYear) || !E(t.weekNumber) || !E(t.weekday), s = !E(t.ordinal), o = !E(t.year), n = !E(t.month) || !E(t.day), a = o || n, l = t.weekYear || t.weekNumber;
    if ((a || s) && l)
      throw new ii(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    if (n && s)
      throw new ii("Can't mix ordinal dates with month/day");
    let c;
    r ? c = Wl({ ...$n(this.c), ...t }) : E(t.ordinal) ? (c = { ...this.toObject(), ...t }, E(t.day) && (c.day = Math.min(Ps(c.year, c.month), c.day))) : c = jl({ ...Bo(this.c), ...t });
    const [d, u] = xs(c, this.o, this.zone);
    return $t(this, { ts: d, o: u });
  }
  /**
   * Add a period of time to this DateTime and return the resulting DateTime
   *
   * Adding hours, minutes, seconds, or milliseconds increases the timestamp by the right number of milliseconds. Adding days, months, or years shifts the calendar, accounting for DSTs and leap years along the way. Thus, `dt.plus({ hours: 24 })` may result in a different time than `dt.plus({ days: 1 })` if there's a DST shift in between.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @example DateTime.now().plus(123) //~> in 123 milliseconds
   * @example DateTime.now().plus({ minutes: 15 }) //~> in 15 minutes
   * @example DateTime.now().plus({ days: 1 }) //~> this time tomorrow
   * @example DateTime.now().plus({ days: -1 }) //~> this time yesterday
   * @example DateTime.now().plus({ hours: 3, minutes: 13 }) //~> in 3 hr, 13 min
   * @example DateTime.now().plus(Duration.fromObject({ hours: 3, minutes: 13 })) //~> in 3 hr, 13 min
   * @return {DateTime}
   */
  plus(e) {
    if (!this.isValid)
      return this;
    const t = T.fromDurationLike(e);
    return $t(this, Yl(this, t));
  }
  /**
   * Subtract a period of time to this DateTime and return the resulting DateTime
   * See {@link DateTime#plus}
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   @return {DateTime}
   */
  minus(e) {
    if (!this.isValid)
      return this;
    const t = T.fromDurationLike(e).negate();
    return $t(this, Yl(this, t));
  }
  /**
   * "Set" this DateTime to the beginning of a unit of time.
   * @param {string} unit - The unit to go to the beginning of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @example DateTime.local(2014, 3, 3).startOf('month').toISODate(); //=> '2014-03-01'
   * @example DateTime.local(2014, 3, 3).startOf('year').toISODate(); //=> '2014-01-01'
   * @example DateTime.local(2014, 3, 3).startOf('week').toISODate(); //=> '2014-03-03', weeks always start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('day').toISOTime(); //=> '00:00.000-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('hour').toISOTime(); //=> '05:00:00.000-05:00'
   * @return {DateTime}
   */
  startOf(e) {
    if (!this.isValid)
      return this;
    const t = {}, r = T.normalizeUnit(e);
    switch (r) {
      case "years":
        t.month = 1;
      case "quarters":
      case "months":
        t.day = 1;
      case "weeks":
      case "days":
        t.hour = 0;
      case "hours":
        t.minute = 0;
      case "minutes":
        t.second = 0;
      case "seconds":
        t.millisecond = 0;
        break;
    }
    if (r === "weeks" && (t.weekday = 1), r === "quarters") {
      const s = Math.ceil(this.month / 3);
      t.month = (s - 1) * 3 + 1;
    }
    return this.set(t);
  }
  /**
   * "Set" this DateTime to the end (meaning the last millisecond) of a unit of time
   * @param {string} unit - The unit to go to the end of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @example DateTime.local(2014, 3, 3).endOf('month').toISO(); //=> '2014-03-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('year').toISO(); //=> '2014-12-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('week').toISO(); // => '2014-03-09T23:59:59.999-05:00', weeks start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('day').toISO(); //=> '2014-03-03T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('hour').toISO(); //=> '2014-03-03T05:59:59.999-05:00'
   * @return {DateTime}
   */
  endOf(e) {
    return this.isValid ? this.plus({ [e]: 1 }).startOf(e).minus(1) : this;
  }
  // OUTPUT
  /**
   * Returns a string representation of this DateTime formatted according to the specified format string.
   * **You may not want this.** See {@link DateTime#toLocaleString} for a more flexible formatting tool. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/formatting?id=table-of-tokens).
   * Defaults to en-US if no locale has been specified, regardless of the system's locale.
   * @param {string} fmt - the format string
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toFormat('yyyy LLL dd') //=> '2017 Apr 22'
   * @example DateTime.now().setLocale('fr').toFormat('yyyy LLL dd') //=> '2017 avr. 22'
   * @example DateTime.now().toFormat('yyyy LLL dd', { locale: "fr" }) //=> '2017 avr. 22'
   * @example DateTime.now().toFormat("HH 'hours and' mm 'minutes'") //=> '20 hours and 55 minutes'
   * @return {string}
   */
  toFormat(e, t = {}) {
    return this.isValid ? re.create(this.loc.redefaultToEN(t)).formatDateTimeFromString(this, e) : Uo;
  }
  /**
   * Returns a localized string representing this date. Accepts the same options as the Intl.DateTimeFormat constructor and any presets defined by Luxon, such as `DateTime.DATE_FULL` or `DateTime.TIME_SIMPLE`.
   * The exact behavior of this method is browser-specific, but in general it will return an appropriate representation
   * of the DateTime in the assigned locale.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param formatOpts {Object} - Intl.DateTimeFormat constructor options and configuration options
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toLocaleString(); //=> 4/20/2017
   * @example DateTime.now().setLocale('en-gb').toLocaleString(); //=> '20/04/2017'
   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL); //=> 'April 20, 2017'
   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL, { locale: 'fr' }); //=> '28 août 2022'
   * @example DateTime.now().toLocaleString(DateTime.TIME_SIMPLE); //=> '11:32 AM'
   * @example DateTime.now().toLocaleString(DateTime.DATETIME_SHORT); //=> '4/20/2017, 11:32 AM'
   * @example DateTime.now().toLocaleString({ weekday: 'long', month: 'long', day: '2-digit' }); //=> 'Thursday, April 20'
   * @example DateTime.now().toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> 'Thu, Apr 20, 11:27 AM'
   * @example DateTime.now().toLocaleString({ hour: '2-digit', minute: '2-digit', hourCycle: 'h23' }); //=> '11:32'
   * @return {string}
   */
  toLocaleString(e = $s, t = {}) {
    return this.isValid ? re.create(this.loc.clone(t), e).formatDateTime(this) : Uo;
  }
  /**
   * Returns an array of format "parts", meaning individual tokens along with metadata. This is allows callers to post-process individual sections of the formatted output.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts
   * @param opts {Object} - Intl.DateTimeFormat constructor options, same as `toLocaleString`.
   * @example DateTime.now().toLocaleParts(); //=> [
   *                                   //=>   { type: 'day', value: '25' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'month', value: '05' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'year', value: '1982' }
   *                                   //=> ]
   */
  toLocaleParts(e = {}) {
    return this.isValid ? re.create(this.loc.clone(e), e).formatDateTimeParts(this) : [];
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.extendedZone=false] - add the time zone format extension
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc(1983, 5, 25).toISO() //=> '1982-05-25T00:00:00.000Z'
   * @example DateTime.now().toISO() //=> '2017-04-22T20:47:05.335-04:00'
   * @example DateTime.now().toISO({ includeOffset: false }) //=> '2017-04-22T20:47:05.335'
   * @example DateTime.now().toISO({ format: 'basic' }) //=> '20170422T204705.335-0400'
   * @return {string}
   */
  toISO({
    format: e = "extended",
    suppressSeconds: t = !1,
    suppressMilliseconds: r = !1,
    includeOffset: s = !0,
    extendedZone: o = !1
  } = {}) {
    if (!this.isValid)
      return null;
    const n = e === "extended";
    let a = Wo(this, n);
    return a += "T", a += Zl(this, n, t, r, s, o), a;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's date component
   * @param {Object} opts - options
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc(1982, 5, 25).toISODate() //=> '1982-05-25'
   * @example DateTime.utc(1982, 5, 25).toISODate({ format: 'basic' }) //=> '19820525'
   * @return {string}
   */
  toISODate({ format: e = "extended" } = {}) {
    return this.isValid ? Wo(this, e === "extended") : null;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's week date
   * @example DateTime.utc(1982, 5, 25).toISOWeekDate() //=> '1982-W21-2'
   * @return {string}
   */
  toISOWeekDate() {
    return ns(this, "kkkk-'W'WW-c");
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's time component
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.extendedZone=true] - add the time zone format extension
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime() //=> '07:34:19.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34, seconds: 0, milliseconds: 0 }).toISOTime({ suppressSeconds: true }) //=> '07:34Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ format: 'basic' }) //=> '073419.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ includePrefix: true }) //=> 'T07:34:19.361Z'
   * @return {string}
   */
  toISOTime({
    suppressMilliseconds: e = !1,
    suppressSeconds: t = !1,
    includeOffset: r = !0,
    includePrefix: s = !1,
    extendedZone: o = !1,
    format: n = "extended"
  } = {}) {
    return this.isValid ? (s ? "T" : "") + Zl(
      this,
      n === "extended",
      t,
      e,
      r,
      o
    ) : null;
  }
  /**
   * Returns an RFC 2822-compatible string representation of this DateTime
   * @example DateTime.utc(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 +0000'
   * @example DateTime.local(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 -0400'
   * @return {string}
   */
  toRFC2822() {
    return ns(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", !1);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in HTTP headers. The output is always expressed in GMT.
   * Specifically, the string conforms to RFC 1123.
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @example DateTime.utc(2014, 7, 13).toHTTP() //=> 'Sun, 13 Jul 2014 00:00:00 GMT'
   * @example DateTime.utc(2014, 7, 13, 19).toHTTP() //=> 'Sun, 13 Jul 2014 19:00:00 GMT'
   * @return {string}
   */
  toHTTP() {
    return ns(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Date
   * @example DateTime.utc(2014, 7, 13).toSQLDate() //=> '2014-07-13'
   * @return {string}
   */
  toSQLDate() {
    return this.isValid ? Wo(this, !0) : null;
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Time
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc().toSQL() //=> '05:15:16.345'
   * @example DateTime.now().toSQL() //=> '05:15:16.345 -04:00'
   * @example DateTime.now().toSQL({ includeOffset: false }) //=> '05:15:16.345'
   * @example DateTime.now().toSQL({ includeZone: false }) //=> '05:15:16.345 America/New_York'
   * @return {string}
   */
  toSQLTime({ includeOffset: e = !0, includeZone: t = !1, includeOffsetSpace: r = !0 } = {}) {
    let s = "HH:mm:ss.SSS";
    return (t || e) && (r && (s += " "), t ? s += "z" : e && (s += "ZZ")), ns(this, s, !0);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 Z'
   * @example DateTime.local(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 -04:00'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeOffset: false }) //=> '2014-07-13 00:00:00.000'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeZone: true }) //=> '2014-07-13 00:00:00.000 America/New_York'
   * @return {string}
   */
  toSQL(e = {}) {
    return this.isValid ? `${this.toSQLDate()} ${this.toSQLTime(e)}` : null;
  }
  /**
   * Returns a string representation of this DateTime appropriate for debugging
   * @return {string}
   */
  toString() {
    return this.isValid ? this.toISO() : Uo;
  }
  /**
   * Returns the epoch milliseconds of this DateTime. Alias of {@link DateTime#toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }
  /**
   * Returns the epoch milliseconds of this DateTime.
   * @return {number}
   */
  toMillis() {
    return this.isValid ? this.ts : NaN;
  }
  /**
   * Returns the epoch seconds of this DateTime.
   * @return {number}
   */
  toSeconds() {
    return this.isValid ? this.ts / 1e3 : NaN;
  }
  /**
   * Returns the epoch seconds (as a whole number) of this DateTime.
   * @return {number}
   */
  toUnixInteger() {
    return this.isValid ? Math.floor(this.ts / 1e3) : NaN;
  }
  /**
   * Returns an ISO 8601 representation of this DateTime appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }
  /**
   * Returns a BSON serializable equivalent to this DateTime.
   * @return {Date}
   */
  toBSON() {
    return this.toJSDate();
  }
  /**
   * Returns a JavaScript object with this DateTime's year, month, day, and so on.
   * @param opts - options for generating the object
   * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output
   * @example DateTime.now().toObject() //=> { year: 2017, month: 4, day: 22, hour: 20, minute: 49, second: 42, millisecond: 268 }
   * @return {Object}
   */
  toObject(e = {}) {
    if (!this.isValid)
      return {};
    const t = { ...this.c };
    return e.includeConfig && (t.outputCalendar = this.outputCalendar, t.numberingSystem = this.loc.numberingSystem, t.locale = this.loc.locale), t;
  }
  /**
   * Returns a JavaScript Date equivalent to this DateTime.
   * @return {Date}
   */
  toJSDate() {
    return new Date(this.isValid ? this.ts : NaN);
  }
  // COMPARE
  /**
   * Return the difference between two DateTimes as a Duration.
   * @param {DateTime} otherDateTime - the DateTime to compare this one to
   * @param {string|string[]} [unit=['milliseconds']] - the unit or array of units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example
   * var i1 = DateTime.fromISO('1982-05-25T09:45'),
   *     i2 = DateTime.fromISO('1983-10-14T10:30');
   * i2.diff(i1).toObject() //=> { milliseconds: 43807500000 }
   * i2.diff(i1, 'hours').toObject() //=> { hours: 12168.75 }
   * i2.diff(i1, ['months', 'days']).toObject() //=> { months: 16, days: 19.03125 }
   * i2.diff(i1, ['months', 'days', 'hours']).toObject() //=> { months: 16, days: 19, hours: 0.75 }
   * @return {Duration}
   */
  diff(e, t = "milliseconds", r = {}) {
    if (!this.isValid || !e.isValid)
      return T.invalid("created by diffing an invalid DateTime");
    const s = { locale: this.locale, numberingSystem: this.numberingSystem, ...r }, o = ig(t).map(T.normalizeUnit), n = e.valueOf() > this.valueOf(), a = n ? this : e, l = n ? e : this, c = a_(a, l, o, s);
    return n ? c.negate() : c;
  }
  /**
   * Return the difference between this DateTime and right now.
   * See {@link DateTime#diff}
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units units (such as 'hours' or 'days') to include in the duration
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  diffNow(e = "milliseconds", t = {}) {
    return this.diff(x.now(), e, t);
  }
  /**
   * Return an Interval spanning between this DateTime and another DateTime
   * @param {DateTime} otherDateTime - the other end point of the Interval
   * @return {Interval}
   */
  until(e) {
    return this.isValid ? q.fromDateTimes(this, e) : this;
  }
  /**
   * Return whether this DateTime is in the same unit of time as another DateTime.
   * Higher-order units must also be identical for this function to return `true`.
   * Note that time zones are **ignored** in this comparison, which compares the **local** calendar time. Use {@link DateTime#setZone} to convert one of the dates if needed.
   * @param {DateTime} otherDateTime - the other DateTime
   * @param {string} unit - the unit of time to check sameness on
   * @example DateTime.now().hasSame(otherDT, 'day'); //~> true if otherDT is in the same current calendar day
   * @return {boolean}
   */
  hasSame(e, t) {
    if (!this.isValid)
      return !1;
    const r = e.valueOf(), s = this.setZone(e.zone, { keepLocalTime: !0 });
    return s.startOf(t) <= r && r <= s.endOf(t);
  }
  /**
   * Equality check
   * Two DateTimes are equal if and only if they represent the same millisecond, have the same zone and location, and are both valid.
   * To compare just the millisecond values, use `+dt1 === +dt2`.
   * @param {DateTime} other - the other DateTime
   * @return {boolean}
   */
  equals(e) {
    return this.isValid && e.isValid && this.valueOf() === e.valueOf() && this.zone.equals(e.zone) && this.loc.equals(e.loc);
  }
  /**
   * Returns a string representation of a this time relative to now, such as "in two days". Can only internationalize if your
   * platform supports Intl.RelativeTimeFormat. Rounds down by default.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} [options.style="long"] - the style of units, must be "long", "short", or "narrow"
   * @param {string|string[]} options.unit - use a specific unit or array of units; if omitted, or an array, the method will pick the best unit. Use an array or one of "years", "quarters", "months", "weeks", "days", "hours", "minutes", or "seconds"
   * @param {boolean} [options.round=true] - whether to round the numbers in the output.
   * @param {number} [options.padding=0] - padding in milliseconds. This allows you to round up the result if it fits inside the threshold. Don't use in combination with {round: false} because the decimal output will include the padding.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelative() //=> "in 1 day"
   * @example DateTime.now().setLocale("es").toRelative({ days: 1 }) //=> "dentro de 1 día"
   * @example DateTime.now().plus({ days: 1 }).toRelative({ locale: "fr" }) //=> "dans 23 heures"
   * @example DateTime.now().minus({ days: 2 }).toRelative() //=> "2 days ago"
   * @example DateTime.now().minus({ days: 2 }).toRelative({ unit: "hours" }) //=> "48 hours ago"
   * @example DateTime.now().minus({ hours: 36 }).toRelative({ round: false }) //=> "1.5 days ago"
   */
  toRelative(e = {}) {
    if (!this.isValid)
      return null;
    const t = e.base || x.fromObject({}, { zone: this.zone }), r = e.padding ? this < t ? -e.padding : e.padding : 0;
    let s = ["years", "months", "days", "hours", "minutes", "seconds"], o = e.unit;
    return Array.isArray(e.unit) && (s = e.unit, o = void 0), Jl(t, this.plus(r), {
      ...e,
      numeric: "always",
      units: s,
      unit: o
    });
  }
  /**
   * Returns a string representation of this date relative to today, such as "yesterday" or "next month".
   * Only internationalizes on platforms that supports Intl.RelativeTimeFormat.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of "years", "quarters", "months", "weeks", or "days"
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar() //=> "tomorrow"
   * @example DateTime.now().setLocale("es").plus({ days: 1 }).toRelative() //=> ""mañana"
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar({ locale: "fr" }) //=> "demain"
   * @example DateTime.now().minus({ days: 2 }).toRelativeCalendar() //=> "2 days ago"
   */
  toRelativeCalendar(e = {}) {
    return this.isValid ? Jl(e.base || x.fromObject({}, { zone: this.zone }), this, {
      ...e,
      numeric: "auto",
      units: ["years", "months", "days"],
      calendary: !0
    }) : null;
  }
  /**
   * Return the min of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the minimum
   * @return {DateTime} the min DateTime, or undefined if called with no argument
   */
  static min(...e) {
    if (!e.every(x.isDateTime))
      throw new xe("min requires all arguments be DateTimes");
    return Nl(e, (t) => t.valueOf(), Math.min);
  }
  /**
   * Return the max of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the maximum
   * @return {DateTime} the max DateTime, or undefined if called with no argument
   */
  static max(...e) {
    if (!e.every(x.isDateTime))
      throw new xe("max requires all arguments be DateTimes");
    return Nl(e, (t) => t.valueOf(), Math.max);
  }
  // MISC
  /**
   * Explain how a string would be parsed by fromFormat()
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see description)
   * @param {Object} options - options taken by fromFormat()
   * @return {Object}
   */
  static fromFormatExplain(e, t, r = {}) {
    const { locale: s = null, numberingSystem: o = null } = r, n = L.fromOpts({
      locale: s,
      numberingSystem: o,
      defaultToEN: !0
    });
    return Uu(n, e, t);
  }
  /**
   * @deprecated use fromFormatExplain instead
   */
  static fromStringExplain(e, t, r = {}) {
    return x.fromFormatExplain(e, t, r);
  }
  // FORMAT PRESETS
  /**
   * {@link DateTime#toLocaleString} format like 10/14/1983
   * @type {Object}
   */
  static get DATE_SHORT() {
    return $s;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED() {
    return iu;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Fri, Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED_WITH_WEEKDAY() {
    return Nm;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983'
   * @type {Object}
   */
  static get DATE_FULL() {
    return su;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Tuesday, October 14, 1983'
   * @type {Object}
   */
  static get DATE_HUGE() {
    return ou;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_SIMPLE() {
    return nu;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SECONDS() {
    return au;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SHORT_OFFSET() {
    return lu;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_LONG_OFFSET() {
    return cu;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_SIMPLE() {
    return du;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SECONDS() {
    return uu;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 EDT', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SHORT_OFFSET() {
    return hu;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_LONG_OFFSET() {
    return fu;
  }
  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT() {
    return pu;
  }
  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT_WITH_SECONDS() {
    return mu;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED() {
    return gu;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_SECONDS() {
    return _u;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Fri, 14 Oct 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_WEEKDAY() {
    return Fm;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL() {
    return bu;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL_WITH_SECONDS() {
    return yu;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE() {
    return vu;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE_WITH_SECONDS() {
    return wu;
  }
}
function Gr(i) {
  if (x.isDateTime(i))
    return i;
  if (i && i.valueOf && qt(i.valueOf()))
    return x.fromJSDate(i);
  if (i && typeof i == "object")
    return x.fromObject(i);
  throw new xe(
    `Unknown datetime argument: ${i}, of type ${typeof i}`
  );
}
function Sr(i, e, t = "", r = null) {
  if (t && (t += ": "), e.response) {
    if (e.response.status == 403 || e.response.status == 401) {
      Ro(
        i,
        Fo,
        `${t}You are not logged in properly or your session has timed out`,
        '<a href="/logout">Please log in again.</a>'
      );
      return;
    }
    r ? r(e) : Ro(
      i,
      Fo,
      `${t}Kiosk server responded with an error.`,
      `(${e.msg}). 
                The server might be down or perhaps you are not logged in properly.`
    );
  } else {
    Ro(
      i,
      Fo,
      `${t}Kiosk server responded with a network error.`,
      `(${e}). 
            The server might be down or perhaps you are not logged in properly.`
    );
    return;
  }
}
function I_(i, e = 2166136261, t = 16777619) {
  let r = e;
  for (let s = 0; s < i.length; s++)
    r ^= i.charCodeAt(s), r = Math.imul(r, t);
  return r >>> 0;
}
function ec(i, e) {
  return !i && e ? 1 : i && !e ? -1 : !i && !e ? 0 : String(i).localeCompare(String(e));
}
function tc(i, e) {
  if (!i && e)
    return 1;
  if (i && !e)
    return -1;
  if (!i && !e)
    return 0;
  const t = x.fromISO(i), r = x.fromISO(e);
  return t < r ? -1 : t > r ? 1 : 0;
}
function D_(i) {
  const e = i.split("\r"), t = {};
  let r, s;
  for (const o of e)
    if ([r, s] = o.split("="), r && s)
      t[r] = s;
    else
      return;
  return t;
}
function rc(i, e = !0) {
  const t = ["I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX", "X", "XI", "XII"], r = `${i.day}.${t[i.month - 1]}.${i.year}`;
  return e ? r + " " + i.toLocaleString(x.TIME_SIMPLE) : r;
}
var O_ = Object.defineProperty, $_ = Object.getOwnPropertyDescriptor, P_ = (i, e, t, r) => {
  for (var s = r > 1 ? void 0 : r ? $_(e, t) : e, o = i.length - 1, n; o >= 0; o--)
    (n = i[o]) && (s = (r ? n(e, t, s) : n(s)) || s);
  return r && s && O_(e, t, s), s;
};
class Xt extends _t {
  constructor() {
    super(), this.kiosk_base_url = "/", this.showProgress = !1, this.apiContext = void 0;
  }
  updated(e) {
    e.has("apiContext") && (this.showProgress = !1);
  }
  render() {
    let e;
    return this.apiContext && this.apiContext.status === Qd ? e = this.apiRender() : this.apiContext && this.apiContext.status === En ? e = this.renderApiError() : e = this.renderNoContextYet(), p`
            <link rel="stylesheet" href="${this.kiosk_base_url}static/styles.css" />
            ${e}
        `;
  }
  renderNoContextYet() {
    return p` <link rel="stylesheet" href="${this.kiosk_base_url}static/styles.css" /> `;
  }
  renderApiError() {
  }
  renderProgress(e = !1) {
    if (e || this.showProgress)
      return p` <div class="loading">
                <div class="loading-progress"></div>
            </div>`;
  }
}
Xt.properties = {
  /**
   * The Api Context
   */
  apiContext: { type: Object }
};
P_([
  z()
], Xt.prototype, "showProgress", 2);
const M_ = `.col-bg-body-lighter{background-color:var(--col-bg-body-lighter)}.col-bg-body{background-color:var(--col-bg-body)}.col-bg-body-darker{background-color:var(--col-bg-body-darker)}.col-bg-1-lighter{background-color:var(--col-bg-1-lighter)}.col-bg-1{background-color:var(--col-bg-1)}.col-bg-1-darker{background-color:var(--col-bg-1-darker)}.col-bg-1-input{background-color:var(--col-bg-1-input)}.col-primary-bg-1{background-color:var(--col-primary-bg-1)}.col-accent-bg-1{background-color:var(--col-accent-bg-1)}.col-success-bg-1{background-color:var(--col-success-bg-1)}.col-warning-bg-1{background-color:var(--col-warning-bg-1)}.col-error-bg-1{background-color:var(--col-error-bg-1)}.col-bg-2-lighter{background-color:var(--col-bg-2-lighter)}.col-bg-2{background-color:var(--col-bg-2)}.col-bg-2-darker{background-color:var(--col-bg-2-darker)}.col-bg-2-button{background-color:var(--col-bg-2-button)}.col-bg-2-input{background-color:var(--col-bg-2-input)}.col-primary-bg-2{background-color:var(--col-primary-bg-2)}.col-accent-bg-2{background-color:var(--col-accent-bg-2)}.col-success-bg-2{background-color:var(--col-success-bg-2)}.col-warning-bg-2{background-color:var(--col-warning-bg-2)}.col-error-bg-2{background-color:var(--col-error-bg-2)}.col-bg-3-lighter{background-color:var(--col-bg-3-lighter)}.col-bg-3{background-color:var(--col-bg-3)}.col-bg-3-darker{background-color:var(--col-bg-3-darker)}.col-bg-3-button{background-color:var(--col-bg-3-button)}.col-bg-3-input{background-color:var(--col-bg-3-input)}.col-primary-bg-3{background-color:var(--col-primary-bg-3)}.col-accent-bg-3{background-color:var(--col-accent-bg-3)}.col-success-bg-3{background-color:var(--col-success-bg-3)}.col-warning-bg-3{background-color:var(--col-warning-bg-3)}.col-error-bg-3{background-color:var(--col-error-bg-3)}.col-bg-ack-lighter{background-color:var(--col-bg-ack-lighter)}.col-bg-ack{background-color:var(--col-bg-ack)}.col-bg-ack-darker{background-color:var(--col-bg-ack-darker)}.col-primary-bg-ack{background-color:var(--col-primary-bg-ack)}.col-accent-bg-ack{background-color:var(--col-accent-bg-ack)}.col-bg-att-lighter{background-color:var(--col-bg-att-lighter)}.col-bg-att{background-color:var(--col-bg-att)}.col-bg-att-darker{background-color:var(--col-bg-att-darker)}.col-primary-bg-att{background-color:var(--col-primary-bg-att)}.col-accent-bg-att{background-color:var(--col-accent-bg-att)}.col-bg-alert-lighter{background-color:var(--col-bg-alert-lighter)}.col-bg-alert{background-color:var(--col-bg-alert)}.col-bg-alert-darker{background-color:var(--col-bg-alert-darker)}.col-primary-bg-alert{background-color:var(--col-primary-bg-alert)}.col-accent-bg-alert{background-color:var(--col-accent-bg-alert)}.col-bg-btn-lighter{background-color:var(--col-bg-btn-lighter)}.col-bg-btn{background-color:var(--col-bg-btn)}.col-bg-btn-darker{background-color:var(--col-bg-btn-darker)}.col-primary-bg-btn{background-color:var(--col-primary-bg-btn)}.col-accent-bg-btn{background-color:var(--col-accent-bg-btn)}.pattern-diagonal-stripes-sm{background:repeating-linear-gradient(45deg,transparent,transparent 10px,currentColor 10px,currentColor 20px)}.pattern-dots-lg{background-image:radial-gradient(currentColor 1.5px,transparent 1.5px);background-size:15px 15px}.pattern-dots-md{background-image:radial-gradient(currentColor 1px,transparent 1px);background-size:8px 8px}.pattern-dots-medium-dense{background-image:radial-gradient(currentColor .5px,transparent .5px);background-size:3px 3px}.pattern-dots-sm{background-image:radial-gradient(currentColor .5px,transparent .5px);background-size:5px 5px}.pattern-cross-dots-md,.imagelist-background{background-image:radial-gradient(currentColor .7px,transparent 1px),radial-gradient(currentColor .7px,transparent 1px);background-size:6.5px 6.5px;background-position:0 0,3.5px 3.5px}.imagelist-background{background-color:#fff9;background-blend-mode:overlay}*{box-sizing:border-box}.loading{display:flex;justify-content:center;align-content:center;height:5px;background-color:#000;width:100%}.loading-progress{height:5px;width:100%;border-radius:3px;background:linear-gradient(90deg,red 0%,yellow 15%,lime 30%,cyan 50%,blue 65%,magenta 80%,red 100%);background-size:200%;animation:move-gradient 2s ease-in infinite}.loading-message{font-family:var(--monospace-font);text-align:center;width:100%;color:var(--col-accent-bg-1);padding:1em}@keyframes move-gradient{0%{background-position:0 0}to{background-position:-200% 0%}}p,div{padding:0;margin:0;border:0px;-webkit-user-select:text;user-select:text}select{-webkit-user-select:none;user-select:none}.fa,.fas{font-family:"Font Awesome 6 Free";font-weight:900;font-style:normal}.fa-trash:before{content:""}.fa-view-grid:before{content:""}.fa-reload:before{content:""}.fa-view-list:before{content:""}.fa-camera:before{content:""}.fa-view-image:before{content:""}.fa-check:before{content:""}.fa-bug:before{content:""}.fa-lightbulb:before{content:""}.fa-query:before{content:""}.fa-footsteps{transform:rotate(270deg)}.fa-footsteps:before{content:""}i{font-family:"Font Awesome 6 Free";font-style:normal;font-variant:normal;text-rendering:auto;-webkit-font-smoothing:antialiased;font-weight:900;font-size:.9em}:host{--lumo-font-size-s: $font-size-standard;--_lumo-grid-secondary-border-color: $col-bg-1-lighter;--_lumo-grid-border-width: 5px;--lumo-font-family: $standard-text;--lumo-size-m: $font-size-standard}:host *{-webkit-user-select:none;user-select:none}.kiosk-query-ui{background-color:var(--col-bg-2);--ui-col-bg-1: $col-bg-2;--ui-button-width: 42px;--ui-button-height: 42px;--ui-button-font-size: 20px;padding:.5em}vaadin-grid::part(cell){padding-left:.5em;padding-top:3px;padding-bottom:3px}vaadin-grid::part(header-cell){min-height:auto;padding-top:.5em;padding-bottom:.5em;border-bottom-color:var(--col-bg-1-darker);border-bottom-width:2px}.identifier{text-decoration:underline;text-decoration-style:dotted;cursor:pointer}.kiosk-query-results{position:relative}.no-records{position:absolute;display:grid;place-items:center;height:100%;width:100%;background-color:var(--col-bg-body);top:0}.no-records div{padding-right:1em;font-size:var(--font-size-standard, 1rem);display:flex;flex-direction:row;line-height:var(--font-size-h3)}.no-records i{font-style:normal;font-size:var(--font-size-h3);vertical-align:middle;font-family:"Font Awesome 6 Free";padding-right:1em}
`;
/**
 * @license
 * Copyright (c) 2021 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function O(i) {
  const e = customElements.get(i.is);
  if (!e)
    customElements.define(i.is, i);
  else {
    const t = e.version;
    t && i.version && i.version;
  }
}
/**
 * @license
 * Copyright (c) 2017 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class z_ extends HTMLElement {
  static get is() {
    return "vaadin-lumo-styles";
  }
  static get version() {
    return "24.2.2";
  }
}
O(z_);
/**
 * @license
 * Copyright (c) 2017 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const N_ = (i) => class extends i {
  static get properties() {
    return {
      /**
       * Helper property with theme attribute value facilitating propagation
       * in shadow DOM.
       *
       * Enables the component implementation to propagate the `theme`
       * attribute value to the sub-components in Shadow DOM by binding
       * the sub-component's "theme" attribute to the `theme` property of
       * the host.
       *
       * **NOTE:** Extending the mixin only provides the property for binding,
       * and does not make the propagation alone.
       *
       * See [Styling Components: Sub-components](https://vaadin.com/docs/latest/styling/styling-components/#sub-components).
       * page for more information.
       *
       * @protected
       */
      _theme: {
        type: String,
        readOnly: !0
      }
    };
  }
  static get observedAttributes() {
    return [...super.observedAttributes, "theme"];
  }
  /** @protected */
  attributeChangedCallback(t, r, s) {
    super.attributeChangedCallback(t, r, s), t === "theme" && this._set_theme(s);
  }
};
/**
 * @license
 * Copyright (c) 2017 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const th = [];
function rh(i) {
  return i && Object.prototype.hasOwnProperty.call(i, "__themes");
}
function F_(i) {
  return rh(customElements.get(i));
}
function R_(i = []) {
  return [i].flat(1 / 0).filter((e) => e instanceof fa);
}
function C(i, e, t = {}) {
  i && F_(i), e = R_(e), window.Vaadin && window.Vaadin.styleModules ? window.Vaadin.styleModules.registerStyles(i, e, t) : th.push({
    themeFor: i,
    styles: e,
    include: t.include,
    moduleId: t.moduleId
  });
}
function Pn() {
  return window.Vaadin && window.Vaadin.styleModules ? window.Vaadin.styleModules.getAllThemes() : th;
}
function L_(i, e) {
  return (i || "").split(" ").some((t) => new RegExp(`^${t.split("*").join(".*")}$`, "u").test(e));
}
function V_(i = "") {
  let e = 0;
  return i.startsWith("lumo-") || i.startsWith("material-") ? e = 1 : i.startsWith("vaadin-") && (e = 2), e;
}
function ih(i) {
  const e = [];
  return i.include && [].concat(i.include).forEach((t) => {
    const r = Pn().find((s) => s.moduleId === t);
    r && e.push(...ih(r), ...r.styles);
  }, i.styles), e;
}
function H_(i, e) {
  const t = document.createElement("style");
  t.innerHTML = i.map((r) => r.cssText).join(`
`), e.content.appendChild(t);
}
function B_(i) {
  const e = `${i}-default-theme`, t = Pn().filter((r) => r.moduleId !== e && L_(r.themeFor, i)).map((r) => ({
    ...r,
    // Prepend styles from included themes
    styles: [...ih(r), ...r.styles],
    // Map moduleId to includePriority
    includePriority: V_(r.moduleId)
  })).sort((r, s) => s.includePriority - r.includePriority);
  return t.length > 0 ? t : Pn().filter((r) => r.moduleId === e);
}
const X = (i) => class extends N_(i) {
  /**
   * Covers PolymerElement based component styling
   * @protected
   */
  static finalize() {
    if (super.finalize(), this.elementStyles)
      return;
    const t = this.prototype._template;
    !t || rh(this) || H_(this.getStylesForThis(), t);
  }
  /**
   * Covers LitElement based component styling
   *
   * @protected
   */
  static finalizeStyles(t) {
    const r = this.getStylesForThis();
    return t ? [...super.finalizeStyles(t), ...r] : r;
  }
  /**
   * Get styles for the component type
   *
   * @private
   */
  static getStylesForThis() {
    const t = Object.getPrototypeOf(this.prototype), r = (t ? t.constructor.__themes : []) || [];
    this.__themes = [...r, ...B_(this.is)];
    const s = this.__themes.flatMap((o) => o.styles);
    return s.filter((o, n) => n === s.lastIndexOf(o));
  }
};
/**
 * @license
 * Copyright (c) 2017 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const U_ = (i, ...e) => {
  const t = document.createElement("style");
  t.id = i, t.textContent = e.map((r) => r.toString()).join(`
`).replace(":host", "html"), document.head.insertAdjacentElement("afterbegin", t);
}, Fr = (i, ...e) => {
  U_(`lumo-${i}`, e);
};
/**
 * @license
 * Copyright (c) 2017 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const q_ = y`
  :host {
    /* Base (background) */
    --lumo-base-color: #fff;

    /* Tint */
    --lumo-tint-5pct: hsla(0, 0%, 100%, 0.3);
    --lumo-tint-10pct: hsla(0, 0%, 100%, 0.37);
    --lumo-tint-20pct: hsla(0, 0%, 100%, 0.44);
    --lumo-tint-30pct: hsla(0, 0%, 100%, 0.5);
    --lumo-tint-40pct: hsla(0, 0%, 100%, 0.57);
    --lumo-tint-50pct: hsla(0, 0%, 100%, 0.64);
    --lumo-tint-60pct: hsla(0, 0%, 100%, 0.7);
    --lumo-tint-70pct: hsla(0, 0%, 100%, 0.77);
    --lumo-tint-80pct: hsla(0, 0%, 100%, 0.84);
    --lumo-tint-90pct: hsla(0, 0%, 100%, 0.9);
    --lumo-tint: #fff;

    /* Shade */
    --lumo-shade-5pct: hsla(214, 61%, 25%, 0.05);
    --lumo-shade-10pct: hsla(214, 57%, 24%, 0.1);
    --lumo-shade-20pct: hsla(214, 53%, 23%, 0.16);
    --lumo-shade-30pct: hsla(214, 50%, 22%, 0.26);
    --lumo-shade-40pct: hsla(214, 47%, 21%, 0.38);
    --lumo-shade-50pct: hsla(214, 45%, 20%, 0.52);
    --lumo-shade-60pct: hsla(214, 43%, 19%, 0.6);
    --lumo-shade-70pct: hsla(214, 42%, 18%, 0.69);
    --lumo-shade-80pct: hsla(214, 41%, 17%, 0.83);
    --lumo-shade-90pct: hsla(214, 40%, 16%, 0.94);
    --lumo-shade: hsl(214, 35%, 15%);

    /* Contrast */
    --lumo-contrast-5pct: var(--lumo-shade-5pct);
    --lumo-contrast-10pct: var(--lumo-shade-10pct);
    --lumo-contrast-20pct: var(--lumo-shade-20pct);
    --lumo-contrast-30pct: var(--lumo-shade-30pct);
    --lumo-contrast-40pct: var(--lumo-shade-40pct);
    --lumo-contrast-50pct: var(--lumo-shade-50pct);
    --lumo-contrast-60pct: var(--lumo-shade-60pct);
    --lumo-contrast-70pct: var(--lumo-shade-70pct);
    --lumo-contrast-80pct: var(--lumo-shade-80pct);
    --lumo-contrast-90pct: var(--lumo-shade-90pct);
    --lumo-contrast: var(--lumo-shade);

    /* Text */
    --lumo-header-text-color: var(--lumo-contrast);
    --lumo-body-text-color: var(--lumo-contrast-90pct);
    --lumo-secondary-text-color: var(--lumo-contrast-70pct);
    --lumo-tertiary-text-color: var(--lumo-contrast-50pct);
    --lumo-disabled-text-color: var(--lumo-contrast-30pct);

    /* Primary */
    --lumo-primary-color: hsl(214, 100%, 48%);
    --lumo-primary-color-50pct: hsla(214, 100%, 49%, 0.76);
    --lumo-primary-color-10pct: hsla(214, 100%, 60%, 0.13);
    --lumo-primary-text-color: hsl(214, 100%, 43%);
    --lumo-primary-contrast-color: #fff;

    /* Error */
    --lumo-error-color: hsl(3, 85%, 48%);
    --lumo-error-color-50pct: hsla(3, 85%, 49%, 0.5);
    --lumo-error-color-10pct: hsla(3, 85%, 49%, 0.1);
    --lumo-error-text-color: hsl(3, 89%, 42%);
    --lumo-error-contrast-color: #fff;

    /* Success */
    --lumo-success-color: hsl(145, 72%, 30%);
    --lumo-success-color-50pct: hsla(145, 72%, 31%, 0.5);
    --lumo-success-color-10pct: hsla(145, 72%, 31%, 0.1);
    --lumo-success-text-color: hsl(145, 85%, 25%);
    --lumo-success-contrast-color: #fff;

    /* Warning */
    --lumo-warning-color: hsl(48, 100%, 50%);
    --lumo-warning-color-10pct: hsla(48, 100%, 50%, 0.25);
    --lumo-warning-text-color: hsl(32, 100%, 30%);
    --lumo-warning-contrast-color: var(--lumo-shade-90pct);
  }

  /* forced-colors mode adjustments */
  @media (forced-colors: active) {
    html {
      --lumo-disabled-text-color: GrayText;
    }
  }
`;
Fr("color-props", q_);
const W_ = y`
  [theme~='dark'] {
    /* Base (background) */
    --lumo-base-color: hsl(214, 35%, 21%);

    /* Tint */
    --lumo-tint-5pct: hsla(214, 65%, 85%, 0.06);
    --lumo-tint-10pct: hsla(214, 60%, 80%, 0.14);
    --lumo-tint-20pct: hsla(214, 64%, 82%, 0.23);
    --lumo-tint-30pct: hsla(214, 69%, 84%, 0.32);
    --lumo-tint-40pct: hsla(214, 73%, 86%, 0.41);
    --lumo-tint-50pct: hsla(214, 78%, 88%, 0.5);
    --lumo-tint-60pct: hsla(214, 82%, 90%, 0.58);
    --lumo-tint-70pct: hsla(214, 87%, 92%, 0.69);
    --lumo-tint-80pct: hsla(214, 91%, 94%, 0.8);
    --lumo-tint-90pct: hsla(214, 96%, 96%, 0.9);
    --lumo-tint: hsl(214, 100%, 98%);

    /* Shade */
    --lumo-shade-5pct: hsla(214, 0%, 0%, 0.07);
    --lumo-shade-10pct: hsla(214, 4%, 2%, 0.15);
    --lumo-shade-20pct: hsla(214, 8%, 4%, 0.23);
    --lumo-shade-30pct: hsla(214, 12%, 6%, 0.32);
    --lumo-shade-40pct: hsla(214, 16%, 8%, 0.41);
    --lumo-shade-50pct: hsla(214, 20%, 10%, 0.5);
    --lumo-shade-60pct: hsla(214, 24%, 12%, 0.6);
    --lumo-shade-70pct: hsla(214, 28%, 13%, 0.7);
    --lumo-shade-80pct: hsla(214, 32%, 13%, 0.8);
    --lumo-shade-90pct: hsla(214, 33%, 13%, 0.9);
    --lumo-shade: hsl(214, 33%, 13%);

    /* Contrast */
    --lumo-contrast-5pct: var(--lumo-tint-5pct);
    --lumo-contrast-10pct: var(--lumo-tint-10pct);
    --lumo-contrast-20pct: var(--lumo-tint-20pct);
    --lumo-contrast-30pct: var(--lumo-tint-30pct);
    --lumo-contrast-40pct: var(--lumo-tint-40pct);
    --lumo-contrast-50pct: var(--lumo-tint-50pct);
    --lumo-contrast-60pct: var(--lumo-tint-60pct);
    --lumo-contrast-70pct: var(--lumo-tint-70pct);
    --lumo-contrast-80pct: var(--lumo-tint-80pct);
    --lumo-contrast-90pct: var(--lumo-tint-90pct);
    --lumo-contrast: var(--lumo-tint);

    /* Text */
    --lumo-header-text-color: var(--lumo-contrast);
    --lumo-body-text-color: var(--lumo-contrast-90pct);
    --lumo-secondary-text-color: var(--lumo-contrast-70pct);
    --lumo-tertiary-text-color: var(--lumo-contrast-50pct);
    --lumo-disabled-text-color: var(--lumo-contrast-30pct);

    /* Primary */
    --lumo-primary-color: hsl(214, 90%, 48%);
    --lumo-primary-color-50pct: hsla(214, 90%, 70%, 0.69);
    --lumo-primary-color-10pct: hsla(214, 90%, 55%, 0.13);
    --lumo-primary-text-color: hsl(214, 90%, 77%);
    --lumo-primary-contrast-color: #fff;

    /* Error */
    --lumo-error-color: hsl(3, 79%, 49%);
    --lumo-error-color-50pct: hsla(3, 75%, 62%, 0.5);
    --lumo-error-color-10pct: hsla(3, 75%, 62%, 0.14);
    --lumo-error-text-color: hsl(3, 100%, 80%);

    /* Success */
    --lumo-success-color: hsl(145, 72%, 30%);
    --lumo-success-color-50pct: hsla(145, 92%, 51%, 0.5);
    --lumo-success-color-10pct: hsla(145, 92%, 51%, 0.1);
    --lumo-success-text-color: hsl(145, 85%, 46%);

    /* Warning */
    --lumo-warning-color: hsl(43, 100%, 48%);
    --lumo-warning-color-10pct: hsla(40, 100%, 50%, 0.2);
    --lumo-warning-text-color: hsl(45, 100%, 60%);
    --lumo-warning-contrast-color: var(--lumo-shade-90pct);
  }

  html {
    color: var(--lumo-body-text-color);
    background-color: var(--lumo-base-color);
    color-scheme: light;
  }

  [theme~='dark'] {
    color: var(--lumo-body-text-color);
    background-color: var(--lumo-base-color);
    color-scheme: dark;
  }

  h1,
  h2,
  h3,
  h4,
  h5,
  h6 {
    color: var(--lumo-header-text-color);
  }

  a:where(:any-link) {
    color: var(--lumo-primary-text-color);
  }

  a:not(:any-link) {
    color: var(--lumo-disabled-text-color);
  }

  blockquote {
    color: var(--lumo-secondary-text-color);
  }

  code,
  pre {
    background-color: var(--lumo-contrast-10pct);
    border-radius: var(--lumo-border-radius-m);
  }
`;
C("", W_, { moduleId: "lumo-color" });
/**
 * @license
 * Copyright (c) 2017 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const j_ = y`
  @font-face {
    font-family: 'lumo-icons';
    src: url(data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAABEgAAsAAAAAIjQAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABCAAAADsAAABUIIslek9TLzIAAAFEAAAAQwAAAFZAIUuKY21hcAAAAYgAAAD4AAADrsCU8d5nbHlmAAACgAAAC2cAABeAWri7U2hlYWQAAA3oAAAAMAAAADZa/6SsaGhlYQAADhgAAAAdAAAAJAbpA35obXR4AAAOOAAAABAAAACspBAAAGxvY2EAAA5IAAAAWAAAAFh57oA4bWF4cAAADqAAAAAfAAAAIAFKAXBuYW1lAAAOwAAAATEAAAIuUUJZCHBvc3QAAA/0AAABKwAAAelm8SzVeJxjYGRgYOBiMGCwY2BycfMJYeDLSSzJY5BiYGGAAJA8MpsxJzM9kYEDxgPKsYBpDiBmg4gCACY7BUgAeJxjYGS+yDiBgZWBgamKaQ8DA0MPhGZ8wGDIyAQUZWBlZsAKAtJcUxgcXjG+0mIO+p/FEMUcxDANKMwIkgMABn8MLQB4nO3SWW6DMABF0UtwCEnIPM/zhLK8LqhfXRybSP14XUYtHV9hGYQwQBNIo3cUIPkhQeM7rib1ekqnXg981XuC1qvy84lzojleh3puxL0hPjGjRU473teloEefAUNGjJkwZcacBUtWrNmwZceeA0dOnLlw5cadB09elPGhGf+j0NTI/65KfXerT6JhqKnpRKtgOpuqaTrtKjPUlqHmhto21I7pL6i6hlqY3q7qGWrfUAeGOjTUkaGODXViqFNDnRnq3FAXhro01JWhrg11Y6hbQ90Z6t5QD4Z6NNSToZ4N9WKoV0O9GerdUB+G+jTUl6GWRvkL24BkEXictVh9bFvVFb/nxvbz+7Rf/N6zHcd2bCfP+Wic1Z9N0jpNHCD9SNqqoVBgbQoMjY+pjA4hNnWa2pV1rHSIif0DGkyT2k10Kmu1Cag6huj4ZpqYBHSqJsTEJgZCG3TaVBFv595nO3ZIv4RIrPPuvefe884599zzO/cRF8G/tgn6CFFImNgkR0ggX8wlspbhSSWSdrC5ozd30s2dw5afzvgtyz9/zG9t1hV4RtF1pXolowvtzc2z6L2aYUQM45jKH9WDTvd1LRDoDASYWhfTzTyvboXz6uZX4ARX5wrF39y+HM2+CJ8d0pkyqBIqoze3D12ez4DrFoYzxI8dWwMrDlZ2DMqQAR9AROsJU+2smlTPaTTco52BVxXa2a2+I8vvqd2dVHm1LoPeTn/AZPRYGthDYOeZjBjKoFsVGulR3lGU95SeCK44oHU7MhWUGUKZDT3oSUcG2GWuh+EDDfUYA/jhIhl0TOsJNYSEu7mQmi3UzfXwZKA4BsVsHLXQYGgJW95qEtpJ1VcW9HiTriZBlFEqxsDjA09yCNUoQxxwd7KWSTt2y3GTKifkqHRCoWZc3m11Wa/dKdFgXD4kSYfkeJBKd8KMz7J8dZn/cGRCcLGDnA2Ge3bKzcvlnTDNthFWLH7Xt80ua5FMjA4WKelWv5Xo16vHuYzpRbJhhdVlftuRK0VlR27D9lu5TF0DPBi60OrHNO0AfP/uRWvhn/U3LXICE+nh+3IHPUJ8JE6GyBjZQLbjGchlrSgYngF8zyrIF4NJD3atUcgWsWunGN/UHX5B5/yg7uF87Nqp4Gf52F3gH73DjEZNRoqCKAr9giQJp5rGJABpiVE2htNhW9R8nw0jqYjCYcY4LIjwYNScf4WN06IZnZCEqsI4cFaQbo4Z1TsZBx40YhXkHOecaYE5oY37IIQ+iJJ+UsDYSun5MuRSBRZRUUhlY2DqOGajOR6zrSU/5My6l2DnusH1GQgnw5BZP7iuYM/ahcfQ7Z8y51ddfutvuwNqWQ0cBYr8fj0U0vsHpwerVaB2sWhXT2NExi2r1KUE2tUuVMnkepVQrxTmpQrZTG4iu8he8iPyM3KcPE/+RP5KPoE2CEAKclCBzXATxkYOtUY/o961PWRqsj0chRrHFBbtrjP9/P0ven5pcbRdpL94vfsy33e5+izuwz3nFLFPVNayPZx/jdG1fOChflFRvYzsW6L18efgLrSWIgvcqnGJYi4skO4xREURjbDuxKke5v0T3Mrzkt2fi31uyZlLLrqIpEuXXsMlgw442Jb0GAxjS1DM20kBoCzHLXm/jEm0IltdcvU0fEW24jgiwwRjVd9u4NJHcIyoHJcwvyVqgqj5hqBJ1ZWSJryh9p56UWhX1XbhRbW2ZopuZWsQd5y8mEQ8M+C6xjRYxZbDKWf5AgY+Qq/l6wSPk16zDFjowYuu+wjx13mfkxbyDDxadYT/LijZyI0THB+6yfLaWsRcO82zo9mWTNtpO18qlorZoIVMwSN40tky5DOQ1MCIAe24mvlsuwIIxPb10+uXDQ4uWz/9m3rj+ql7p6bufZARuPVq5tXtsn6KwfP8Jy0TeWOyNhUJN6mhX5rkUTtUppQWEMNTqEdaCGKFYKJaQrCE4JtDLYOlNEKmO5kBTPGY2A0N2sY3+dVlo1N9ycBsIGtOjQ2p/tlZvzo0ur4v6cOh8NTospB7U/X40KahoU3bGIH97dnwmtHlYffVG3R1YOwKM2vNhrPhCT5zk64sG53oS4b31aYjqe/B7+kQiXBN+b6h21hNUPMq29B8CU4elINdygMPKF1B+WBTG7Z9ZshpN/xwEuuDQZR+nuoo4CDaAiiwXmLpmukMQyPf/JMclqgL1ixZQ/nnP2VbdUODFGt2fgBvL123rlLYu/6A9ckb7F3K0/CyBMEu6aQoPscroCcacVehvyQyCZAsizsWWBkoLC+WAiWnOksLKaeuQDzGuqSk42aiYTiJ4zf9afl17SrqaTO1f+XlZAfIuYcq7/IqYMaMrksOJ6vHkOCPDq943xcCnHqVD9pHFRpMqSPXrIua1WNs+tOz1U+ciTCDpPk+c4QYJIHnYhxP/kVPAq+ahFpVhPcHp8qyarhiF+HsBU9Hrl+UZa876fbKipL0KqB6OdUveErgtOI97fZ63ae9SvWU6k2w1JfwqnUbHsYcFCJFrC/W12zIMMirWYEHxMPs6LGYSdkSZ5TsNP9PCpwnWC3HKZ1lydNjWHC2Mn3l6vL0dHn1ldP3LTSrX+vKrBqv7KmMr8p0SR6P1NqF63or6XRlIyO90f7+kf7+myOhvt4tq7f09oUiTc2/dycGgqFQcCDRLYmi1NL7fk0CknVMxEg/cdfs/TnpJMNkgqwj17B8beVazSrVbU4lG67IZYOCnWrYy3yBR9cyWcChywos3LJBEdhhFoAdYjiw0rLGm0xU5OzoGm5/ZfmHjVZpNNg6SznzGKDdwv2cCtVn6Eaxo12cfxLprpVtTcZ6hVx6dow7Yq7e8LXO8PY9Jgjoze9yCtU5FNbegcKkQMdCbt9au/te4Ebe0jkc0ukUL32eYnTpNs20h0KpUOhZPYwVcfhZnfdqeCvDfXiuCbAoYWcXERPc/mDQD3/hdF+wK4i/xv3kYfprIpAuMkk2kW3kdtS0kBIKpZwp8KxmsCyfM1MFzAss9LBkDxRyThiaqTLwKYKJVTwmWTudMyz+yks09346MDh4m72yOxCKrt1XMlQ1qPVlTEVVQ1ofdK/sCWjtZu9qGwZ8YZ9PPWlo1IV3eW3+U0aXblP39zrt+JPf6UhEQ1rUjNBULN+utyuaDNW34kpAVuSOeMTyWbSNWnooFu+QFNWQ4d/Ox4IPWx41fP/fB/Rjeoz08ezPA9TysMtmnOXfGN7Ui3xIYLDALrlDLOP09qtJuY2OeL0+QZXdRnR1nxRVBF/SOyKKPpcrn9mWzH4rH9IidE+PTNU2182+hOgSItrE1slByS24vaLvJpxOqe4Pduf3HJkZ+jLqUz9rRzB7p8gKcgWZwV1L8JtUS5Z2JxZSOCuBoMTQihMzLbCPA0KqGMAljRQjONklW/wjnXKy8vxT/Elvm3/KiMUMOoV0/vnDYlhec0SMKtt3/kKMyOt33tj2bqxQLsTjSGLl+EAsNhCnTyRGktW55EgCn/A4PlnWn+Mg8bgZrWqHxTbPwMuyy1u5YeZF2SUM7JRhddwRgiRuxpmgJmxn9ZW7XpcF3ViX/ar6ptRpGJ0S9Adg4qhb9sI3vbL7qNJV/y4i07t5TZBiho1imFoMz3gED+CtjYUxvP4SOxov4bFoNPg5aR1e+G4UgDPoedJTpogyCJ7oYvRqoVS0MQAy+CoNEdTDUjok5ZHZL/WtjV7rFj3PKQE3iKp7ou+rIxN3b9LB1dGjeT4cvKo3FrnWpYpuaFd/h3dtV8UeKN1Y9hpR3dt4p0H/zKuPQq0kZQUIIpuDfoiETsnIk+gCWMJZUXHtE8V9LkUc2TE8vOMbO4ax/MACabzyaGXc7u3FBr11ThBdB8SIeMAlCntG2KThHSPsaj2Dc9KNyY2a0KZ7ODaTHoRiFkeYz+shZBpCS4X6471KKKnuHd84edfk5F37d1XO5bbkcltu2ZLNbvnPXiUVAnVvprJrP+NObryjxrllS65md6Tm6wzFHRR4dY3QUUjb7MgxaIixU8hspi98fl/Xc+IB4iU66eCVL9YfAfahiSUt4TONS8x0D8W7u8vd3fGWx6OXlM/U1IoU/s61PGhpyXRFa3eReq2qG56lvmYtXavCC1iN7lbiBpWxXHU+cSlztVLVz0tVN600fVsLxaVDknhYioeoXP3t4lqV1r79MAw0GCI1FTL1YIGzPL1MMlJ9ZsN9P7lvA2yr9ZFUzwzPrVgxN/x/SS+chwB4nGNgZGBgAOLPrYdY4vltvjJwM78AijDUqG5oRND/XzNPZboF5HIwMIFEAU/lC+J4nGNgZGBgDvqfBSRfMAAB81QGRgZUoA0AVvYDbwAAAHicY2BgYGB+MTQwAM8EJo8AAAAAAE4AmgDoAQoBLAFOAXABmgHEAe4CGgKcAugEmgS8BNYE8gUOBSoFegXQBf4GRAZmBrYHGAeQCBgIUghqCP4JRgm+CdoKBAo+CoQKugr0C1QLmgvAeJxjYGRgYNBmTGEQZQABJiDmAkIGhv9gPgMAGJQBvAB4nG2RPU7DMBiG3/QP0UoIBGJh8QILavozdmRo9w7d09RpUzlx5LgVvQMn4BAcgoEzcAgOwVvzSZVQbcnf48fvFysJgGt8IcJxROiG9TgauODuj5ukG+EW+UG4jR4ehTv0Q+EunjER7uEWmk+IWpc0d3gVbuAKb8JN+nfhFvlDuI17fAp36L+Fu1jgR7iHp+jF7Arbz1Nb1nO93pnEncSJFtrVuS3VKB6e5EyX2iVer9TyoOr9eux9pjJnCzW1pdfGWFU5u9WpjzfeV5PBIBMfp7aAwQ4FLPrIkbKWqDHn+67pDRK4s4lzbsEux5qHvcIIMb/nueSMyTKkE3jWFdNLHLjW2PPmMa1Hxn3GjGW/wjT0HtOG09JU4WxLk9LH2ISuiv9twJn9y8fh9uIXI+BknAAAAHicbY7ZboMwEEW5CVBCSLrv+76kfJRjTwHFsdGAG+Xvy5JUfehIHp0rnxmNN/D6ir3/a4YBhvARIMQOIowQY4wEE0yxiz3s4wCHOMIxTnCKM5zjApe4wjVucIs73OMBj3jCM17wije84wMzfHqJ0EVmUkmmJo77oOmrHvfIRZbXsTCZplTZldlgb3TYGVHProwFs11t1A57tcON2rErR3PBqcwF1/6ctI6k0GSU4JHMSS6WghdJQ99sTbfuN7QLJ9vQ37dNrgyktnIxlDYLJNuqitpRbYWKFNuyDT6pog6oOYKHtKakeakqKjHXpPwlGRcsC+OqxLIiJpXqoqqDMreG2l5bv9Ri3TRX+c23DZna9WFFgmXuO6Ps1Jm/w6ErW8N3FbHn/QC444j0AA==)
      format('woff');
    font-weight: normal;
    font-style: normal;
  }

  html {
    --lumo-icons-align-center: '\\ea01';
    --lumo-icons-align-left: '\\ea02';
    --lumo-icons-align-right: '\\ea03';
    --lumo-icons-angle-down: '\\ea04';
    --lumo-icons-angle-left: '\\ea05';
    --lumo-icons-angle-right: '\\ea06';
    --lumo-icons-angle-up: '\\ea07';
    --lumo-icons-arrow-down: '\\ea08';
    --lumo-icons-arrow-left: '\\ea09';
    --lumo-icons-arrow-right: '\\ea0a';
    --lumo-icons-arrow-up: '\\ea0b';
    --lumo-icons-bar-chart: '\\ea0c';
    --lumo-icons-bell: '\\ea0d';
    --lumo-icons-calendar: '\\ea0e';
    --lumo-icons-checkmark: '\\ea0f';
    --lumo-icons-chevron-down: '\\ea10';
    --lumo-icons-chevron-left: '\\ea11';
    --lumo-icons-chevron-right: '\\ea12';
    --lumo-icons-chevron-up: '\\ea13';
    --lumo-icons-clock: '\\ea14';
    --lumo-icons-cog: '\\ea15';
    --lumo-icons-cross: '\\ea16';
    --lumo-icons-download: '\\ea17';
    --lumo-icons-dropdown: '\\ea18';
    --lumo-icons-edit: '\\ea19';
    --lumo-icons-error: '\\ea1a';
    --lumo-icons-eye: '\\ea1b';
    --lumo-icons-eye-disabled: '\\ea1c';
    --lumo-icons-menu: '\\ea1d';
    --lumo-icons-minus: '\\ea1e';
    --lumo-icons-ordered-list: '\\ea1f';
    --lumo-icons-phone: '\\ea20';
    --lumo-icons-photo: '\\ea21';
    --lumo-icons-play: '\\ea22';
    --lumo-icons-plus: '\\ea23';
    --lumo-icons-redo: '\\ea24';
    --lumo-icons-reload: '\\ea25';
    --lumo-icons-search: '\\ea26';
    --lumo-icons-undo: '\\ea27';
    --lumo-icons-unordered-list: '\\ea28';
    --lumo-icons-upload: '\\ea29';
    --lumo-icons-user: '\\ea2a';
  }
`;
Fr("font-icons", j_);
/**
 * @license
 * Copyright (c) 2017 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const G_ = y`
  :host {
    --lumo-size-xs: 1.625rem;
    --lumo-size-s: 1.875rem;
    --lumo-size-m: 2.25rem;
    --lumo-size-l: 2.75rem;
    --lumo-size-xl: 3.5rem;

    /* Icons */
    --lumo-icon-size-s: 1.25em;
    --lumo-icon-size-m: 1.5em;
    --lumo-icon-size-l: 2.25em;
    /* For backwards compatibility */
    --lumo-icon-size: var(--lumo-icon-size-m);
  }
`;
Fr("sizing-props", G_);
/**
 * @license
 * Copyright (c) 2017 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Y_ = y`
  :host {
    /* Square */
    --lumo-space-xs: 0.25rem;
    --lumo-space-s: 0.5rem;
    --lumo-space-m: 1rem;
    --lumo-space-l: 1.5rem;
    --lumo-space-xl: 2.5rem;

    /* Wide */
    --lumo-space-wide-xs: calc(var(--lumo-space-xs) / 2) var(--lumo-space-xs);
    --lumo-space-wide-s: calc(var(--lumo-space-s) / 2) var(--lumo-space-s);
    --lumo-space-wide-m: calc(var(--lumo-space-m) / 2) var(--lumo-space-m);
    --lumo-space-wide-l: calc(var(--lumo-space-l) / 2) var(--lumo-space-l);
    --lumo-space-wide-xl: calc(var(--lumo-space-xl) / 2) var(--lumo-space-xl);

    /* Tall */
    --lumo-space-tall-xs: var(--lumo-space-xs) calc(var(--lumo-space-xs) / 2);
    --lumo-space-tall-s: var(--lumo-space-s) calc(var(--lumo-space-s) / 2);
    --lumo-space-tall-m: var(--lumo-space-m) calc(var(--lumo-space-m) / 2);
    --lumo-space-tall-l: var(--lumo-space-l) calc(var(--lumo-space-l) / 2);
    --lumo-space-tall-xl: var(--lumo-space-xl) calc(var(--lumo-space-xl) / 2);
  }
`;
Fr("spacing-props", Y_);
/**
 * @license
 * Copyright (c) 2017 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Z_ = y`
  :host {
    /* Border radius */
    --lumo-border-radius-s: 0.25em; /* Checkbox, badge, date-picker year indicator, etc */
    --lumo-border-radius-m: var(--lumo-border-radius, 0.25em); /* Button, text field, menu overlay, etc */
    --lumo-border-radius-l: 0.5em; /* Dialog, notification, etc */

    /* Shadow */
    --lumo-box-shadow-xs: 0 1px 4px -1px var(--lumo-shade-50pct);
    --lumo-box-shadow-s: 0 2px 4px -1px var(--lumo-shade-20pct), 0 3px 12px -1px var(--lumo-shade-30pct);
    --lumo-box-shadow-m: 0 2px 6px -1px var(--lumo-shade-20pct), 0 8px 24px -4px var(--lumo-shade-40pct);
    --lumo-box-shadow-l: 0 3px 18px -2px var(--lumo-shade-20pct), 0 12px 48px -6px var(--lumo-shade-40pct);
    --lumo-box-shadow-xl: 0 4px 24px -3px var(--lumo-shade-20pct), 0 18px 64px -8px var(--lumo-shade-40pct);

    /* Clickable element cursor */
    --lumo-clickable-cursor: default;
  }
`;
y`
  html {
    --vaadin-checkbox-size: calc(var(--lumo-size-m) / 2);
    --vaadin-radio-button-size: calc(var(--lumo-size-m) / 2);
    --vaadin-input-field-border-radius: var(--lumo-border-radius-m);
  }
`;
Fr("style-props", Z_);
/**
 * @license
 * Copyright (c) 2017 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const K_ = y`
  :host {
    /* prettier-ignore */
    --lumo-font-family: -apple-system, BlinkMacSystemFont, 'Roboto', 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';

    /* Font sizes */
    --lumo-font-size-xxs: 0.75rem;
    --lumo-font-size-xs: 0.8125rem;
    --lumo-font-size-s: 0.875rem;
    --lumo-font-size-m: 1rem;
    --lumo-font-size-l: 1.125rem;
    --lumo-font-size-xl: 1.375rem;
    --lumo-font-size-xxl: 1.75rem;
    --lumo-font-size-xxxl: 2.5rem;

    /* Line heights */
    --lumo-line-height-xs: 1.25;
    --lumo-line-height-s: 1.375;
    --lumo-line-height-m: 1.625;
  }
`, Q_ = y`
  body,
  :host {
    font-family: var(--lumo-font-family);
    font-size: var(--lumo-font-size-m);
    line-height: var(--lumo-line-height-m);
    -webkit-text-size-adjust: 100%;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }

  small,
  [theme~='font-size-s'] {
    font-size: var(--lumo-font-size-s);
    line-height: var(--lumo-line-height-s);
  }

  [theme~='font-size-xs'] {
    font-size: var(--lumo-font-size-xs);
    line-height: var(--lumo-line-height-xs);
  }

  :where(h1, h2, h3, h4, h5, h6) {
    font-weight: 600;
    line-height: var(--lumo-line-height-xs);
    margin-block: 0;
  }

  :where(h1) {
    font-size: var(--lumo-font-size-xxxl);
  }

  :where(h2) {
    font-size: var(--lumo-font-size-xxl);
  }

  :where(h3) {
    font-size: var(--lumo-font-size-xl);
  }

  :where(h4) {
    font-size: var(--lumo-font-size-l);
  }

  :where(h5) {
    font-size: var(--lumo-font-size-m);
  }

  :where(h6) {
    font-size: var(--lumo-font-size-xs);
    text-transform: uppercase;
    letter-spacing: 0.03em;
  }

  p,
  blockquote {
    margin-top: 0.5em;
    margin-bottom: 0.75em;
  }

  a {
    text-decoration: none;
  }

  a:where(:any-link):hover {
    text-decoration: underline;
  }

  hr {
    display: block;
    align-self: stretch;
    height: 1px;
    border: 0;
    padding: 0;
    margin: var(--lumo-space-s) calc(var(--lumo-border-radius-m) / 2);
    background-color: var(--lumo-contrast-10pct);
  }

  blockquote {
    border-left: 2px solid var(--lumo-contrast-30pct);
  }

  b,
  strong {
    font-weight: 600;
  }

  /* RTL specific styles */
  blockquote[dir='rtl'] {
    border-left: none;
    border-right: 2px solid var(--lumo-contrast-30pct);
  }
`;
C("", Q_, { moduleId: "lumo-typography" });
Fr("typography-props", K_);
C(
  "vaadin-checkbox",
  y`
    :host {
      color: var(--lumo-body-text-color);
      font-size: var(--lumo-font-size-m);
      font-family: var(--lumo-font-family);
      line-height: var(--lumo-line-height-s);
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      -webkit-tap-highlight-color: transparent;
      -webkit-user-select: none;
      -moz-user-select: none;
      user-select: none;
      cursor: default;
      outline: none;
      --_checkbox-size: var(--vaadin-checkbox-size, calc(var(--lumo-size-m) / 2));
    }

    :host([has-label]) ::slotted(label) {
      padding-block: var(--lumo-space-xs);
      padding-inline: var(--lumo-space-xs) var(--lumo-space-s);
    }

    [part='checkbox'] {
      width: var(--_checkbox-size);
      height: var(--_checkbox-size);
      margin: var(--lumo-space-xs);
      position: relative;
      border-radius: var(--lumo-border-radius-s);
      background-color: var(--lumo-contrast-20pct);
      transition: transform 0.2s cubic-bezier(0.12, 0.32, 0.54, 2), background-color 0.15s;
      cursor: var(--lumo-clickable-cursor);
      /* Default field border color */
      --_input-border-color: var(--vaadin-input-field-border-color, var(--lumo-contrast-50pct));
    }

    :host([indeterminate]),
    :host([checked]) {
      --vaadin-input-field-border-color: transparent;
    }

    :host([indeterminate]) [part='checkbox'],
    :host([checked]) [part='checkbox'] {
      background-color: var(--lumo-primary-color);
    }

    /* Checkmark */
    [part='checkbox']::after {
      pointer-events: none;
      font-family: 'lumo-icons';
      content: var(--lumo-icons-checkmark);
      color: var(--lumo-primary-contrast-color);
      font-size: calc(var(--_checkbox-size) + 2px);
      line-height: 1;
      position: absolute;
      top: -1px;
      left: -1px;
      contain: content;
      opacity: 0;
    }

    :host([checked]) [part='checkbox']::after {
      opacity: 1;
    }

    /* Indeterminate checkmark */
    :host([indeterminate]) [part='checkbox']::after {
      content: '';
      opacity: 1;
      top: 45%;
      height: 10%;
      left: 22%;
      right: 22%;
      width: auto;
      border: 0;
      background-color: var(--lumo-primary-contrast-color);
    }

    /* Focus ring */
    :host([focus-ring]) [part='checkbox'] {
      box-shadow: 0 0 0 1px var(--lumo-base-color), 0 0 0 3px var(--lumo-primary-color-50pct),
        inset 0 0 0 var(--_input-border-width, 0) var(--_input-border-color);
    }

    /* Disabled */
    :host([disabled]) {
      pointer-events: none;
      color: var(--lumo-disabled-text-color);
      --vaadin-input-field-border-color: var(--lumo-contrast-20pct);
    }

    :host([disabled]) ::slotted(label) {
      color: inherit;
    }

    :host([disabled]) [part='checkbox'] {
      background-color: var(--lumo-contrast-10pct);
    }

    :host([disabled]) [part='checkbox']::after {
      color: var(--lumo-contrast-30pct);
    }

    :host([indeterminate][disabled]) [part='checkbox']::after {
      background-color: var(--lumo-contrast-30pct);
    }

    /* RTL specific styles */
    :host([dir='rtl'][has-label]) ::slotted(label) {
      padding: var(--lumo-space-xs) var(--lumo-space-xs) var(--lumo-space-xs) var(--lumo-space-s);
    }

    /* Used for activation "halo" */
    [part='checkbox']::before {
      pointer-events: none;
      color: transparent;
      width: 100%;
      height: 100%;
      line-height: var(--_checkbox-size);
      border-radius: inherit;
      background-color: inherit;
      transform: scale(1.4);
      opacity: 0;
      transition: transform 0.1s, opacity 0.8s;
    }

    /* Hover */
    :host(:not([checked]):not([indeterminate]):not([disabled]):hover) [part='checkbox'] {
      background-color: var(--lumo-contrast-30pct);
    }

    /* Disable hover for touch devices */
    @media (pointer: coarse) {
      :host(:not([checked]):not([indeterminate]):not([disabled]):hover) [part='checkbox'] {
        background-color: var(--lumo-contrast-20pct);
      }
    }

    /* Active */
    :host([active]) [part='checkbox'] {
      transform: scale(0.9);
      transition-duration: 0.05s;
    }

    :host([active][checked]) [part='checkbox'] {
      transform: scale(1.1);
    }

    :host([active]:not([checked])) [part='checkbox']::before {
      transition-duration: 0.01s, 0.01s;
      transform: scale(0);
      opacity: 0.4;
    }
  `,
  { moduleId: "lumo-checkbox" }
);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
window.JSCompiler_renameProperty = function(i, e) {
  return i;
};
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
let J_ = /(url\()([^)]*)(\))/g, X_ = /(^\/[^\/])|(^#)|(^[\w-\d]*:)/, as, fe;
function ui(i, e) {
  if (i && X_.test(i) || i === "//")
    return i;
  if (as === void 0) {
    as = !1;
    try {
      const t = new URL("b", "http://a");
      t.pathname = "c%20d", as = t.href === "http://a/c%20d";
    } catch {
    }
  }
  if (e || (e = document.baseURI || window.location.href), as)
    try {
      return new URL(i, e).href;
    } catch {
      return i;
    }
  return fe || (fe = document.implementation.createHTMLDocument("temp"), fe.base = fe.createElement("base"), fe.head.appendChild(fe.base), fe.anchor = fe.createElement("a"), fe.body.appendChild(fe.anchor)), fe.base.href = e, fe.anchor.href = i, fe.anchor.href || i;
}
function xa(i, e) {
  return i.replace(J_, function(t, r, s, o) {
    return r + "'" + ui(s.replace(/["']/g, ""), e) + "'" + o;
  });
}
function Ca(i) {
  return i.substring(0, i.lastIndexOf("/") + 1);
}
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const sh = !window.ShadyDOM || !window.ShadyDOM.inUse;
!window.ShadyCSS || window.ShadyCSS.nativeCss;
const eb = sh && "adoptedStyleSheets" in Document.prototype && "replaceSync" in CSSStyleSheet.prototype && // Since spec may change, feature detect exact API we need
(() => {
  try {
    const i = new CSSStyleSheet();
    i.replaceSync("");
    const e = document.createElement("div");
    return e.attachShadow({ mode: "open" }), e.shadowRoot.adoptedStyleSheets = [i], e.shadowRoot.adoptedStyleSheets[0] === i;
  } catch {
    return !1;
  }
})();
let tb = window.Polymer && window.Polymer.rootPath || Ca(document.baseURI || window.location.href), Ns = window.Polymer && window.Polymer.sanitizeDOMValue || void 0;
window.Polymer && window.Polymer.setPassiveTouchGestures;
let Fs = window.Polymer && window.Polymer.strictTemplatePolicy || !1, rb = window.Polymer && window.Polymer.allowTemplateFromDomModule || !1, oh = window.Polymer && window.Polymer.legacyOptimizations || !1, nh = window.Polymer && window.Polymer.legacyWarnings || !1, ib = window.Polymer && window.Polymer.syncInitialRender || !1, Mn = window.Polymer && window.Polymer.legacyUndefined || !1, sb = window.Polymer && window.Polymer.orderedComputed || !1, ic = window.Polymer && window.Polymer.removeNestedTemplates || !1, ob = window.Polymer && window.Polymer.fastDomIf || !1, sc = window.Polymer && window.Polymer.suppressTemplateNotifications || !1;
window.Polymer && window.Polymer.legacyNoObservedAttributes;
let nb = window.Polymer && window.Polymer.useAdoptedStyleSheetsWithBuiltCSS || !1;
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
let ab = 0;
const Y = function(i) {
  let e = (
    /** @type {!MixinFunction} */
    i.__mixinApplications
  );
  e || (e = /* @__PURE__ */ new WeakMap(), i.__mixinApplications = e);
  let t = ab++;
  function r(s) {
    let o = (
      /** @type {!MixinFunction} */
      s.__mixinSet
    );
    if (o && o[t])
      return s;
    let n = e, a = n.get(s);
    if (!a) {
      a = /** @type {!Function} */
      i(s), n.set(s, a);
      let l = Object.create(
        /** @type {!MixinFunction} */
        a.__mixinSet || o || null
      );
      l[t] = !0, a.__mixinSet = l;
    }
    return a;
  }
  return r;
};
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
let ka = {}, ah = {};
function oc(i, e) {
  ka[i] = ah[i.toLowerCase()] = e;
}
function nc(i) {
  return ka[i] || ah[i.toLowerCase()];
}
function lb(i) {
  i.querySelector("style");
}
class Ci extends HTMLElement {
  /** @override */
  static get observedAttributes() {
    return ["id"];
  }
  /**
   * Retrieves the element specified by the css `selector` in the module
   * registered by `id`. For example, this.import('foo', 'img');
   * @param {string} id The id of the dom-module in which to search.
   * @param {string=} selector The css selector by which to find the element.
   * @return {Element} Returns the element which matches `selector` in the
   * module registered at the specified `id`.
   *
   * @export
   * @nocollapse Referred to indirectly in style-gather.js
   */
  static import(e, t) {
    if (e) {
      let r = nc(e);
      return r && t ? r.querySelector(t) : r;
    }
    return null;
  }
  /* eslint-disable no-unused-vars */
  /**
   * @param {string} name Name of attribute.
   * @param {?string} old Old value of attribute.
   * @param {?string} value Current value of attribute.
   * @param {?string} namespace Attribute namespace.
   * @return {void}
   * @override
   */
  attributeChangedCallback(e, t, r, s) {
    t !== r && this.register();
  }
  /* eslint-enable no-unused-args */
  /**
   * The absolute URL of the original location of this `dom-module`.
   *
   * This value will differ from this element's `ownerDocument` in the
   * following ways:
   * - Takes into account any `assetpath` attribute added during bundling
   *   to indicate the original location relative to the bundled location
   * - Uses the HTMLImports polyfill's `importForElement` API to ensure
   *   the path is relative to the import document's location since
   *   `ownerDocument` is not currently polyfilled
   */
  get assetpath() {
    if (!this.__assetpath) {
      const e = window.HTMLImports && HTMLImports.importForElement ? HTMLImports.importForElement(this) || document : this.ownerDocument, t = ui(
        this.getAttribute("assetpath") || "",
        e.baseURI
      );
      this.__assetpath = Ca(t);
    }
    return this.__assetpath;
  }
  /**
   * Registers the dom-module at a given id. This method should only be called
   * when a dom-module is imperatively created. For
   * example, `document.createElement('dom-module').register('foo')`.
   * @param {string=} id The id at which to register the dom-module.
   * @return {void}
   */
  register(e) {
    if (e = e || this.id, e) {
      if (Fs && nc(e) !== void 0)
        throw oc(e, null), new Error(`strictTemplatePolicy: dom-module ${e} re-registered`);
      this.id = e, oc(e, this), lb(this);
    }
  }
}
Ci.prototype.modules = ka;
customElements.define("dom-module", Ci);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const cb = "link[rel=import][type~=css]", db = "include", ac = "shady-unscoped";
function lh(i) {
  return (
    /** @type {?DomModule} */
    Ci.import(i)
  );
}
function lc(i) {
  let e = i.body ? i.body : i;
  const t = xa(
    e.textContent,
    i.baseURI
  ), r = document.createElement("style");
  return r.textContent = t, r;
}
function ub(i) {
  const e = i.trim().split(/\s+/), t = [];
  for (let r = 0; r < e.length; r++)
    t.push(...hb(e[r]));
  return t;
}
function hb(i) {
  const e = lh(i);
  if (!e)
    return [];
  if (e._styles === void 0) {
    const t = [];
    t.push(...dh(e));
    const r = (
      /** @type {?HTMLTemplateElement} */
      e.querySelector("template")
    );
    r && t.push(...ch(
      r,
      /** @type {templateWithAssetPath} */
      e.assetpath
    )), e._styles = t;
  }
  return e._styles;
}
function ch(i, e) {
  if (!i._styles) {
    const t = [], r = i.content.querySelectorAll("style");
    for (let s = 0; s < r.length; s++) {
      let o = r[s], n = o.getAttribute(db);
      n && t.push(...ub(n).filter(function(a, l, c) {
        return c.indexOf(a) === l;
      })), e && (o.textContent = xa(
        o.textContent,
        /** @type {string} */
        e
      )), t.push(o);
    }
    i._styles = t;
  }
  return i._styles;
}
function fb(i) {
  let e = lh(i);
  return e ? dh(e) : [];
}
function dh(i) {
  const e = [], t = i.querySelectorAll(cb);
  for (let r = 0; r < t.length; r++) {
    let s = t[r];
    if (s.import) {
      const o = s.import, n = s.hasAttribute(ac);
      if (n && !o._unscopedStyle) {
        const a = lc(o);
        a.setAttribute(ac, ""), o._unscopedStyle = a;
      } else
        o._style || (o._style = lc(o));
      e.push(n ? o._unscopedStyle : o._style);
    }
  }
  return e;
}
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const B = window.ShadyDOM && window.ShadyDOM.noPatch && window.ShadyDOM.wrap ? window.ShadyDOM.wrap : window.ShadyDOM ? (i) => ShadyDOM.patch(i) : (i) => i;
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
function zn(i) {
  return i.indexOf(".") >= 0;
}
function er(i) {
  let e = i.indexOf(".");
  return e === -1 ? i : i.slice(0, e);
}
function uh(i, e) {
  return i.indexOf(e + ".") === 0;
}
function ki(i, e) {
  return e.indexOf(i + ".") === 0;
}
function Ai(i, e, t) {
  return e + t.slice(i.length);
}
function pb(i, e) {
  return i === e || uh(i, e) || ki(i, e);
}
function oi(i) {
  if (Array.isArray(i)) {
    let e = [];
    for (let t = 0; t < i.length; t++) {
      let r = i[t].toString().split(".");
      for (let s = 0; s < r.length; s++)
        e.push(r[s]);
    }
    return e.join(".");
  } else
    return i;
}
function hh(i) {
  return Array.isArray(i) ? oi(i).split(".") : i.toString().split(".");
}
function ae(i, e, t) {
  let r = i, s = hh(e);
  for (let o = 0; o < s.length; o++) {
    if (!r)
      return;
    let n = s[o];
    r = r[n];
  }
  return t && (t.path = s.join(".")), r;
}
function cc(i, e, t) {
  let r = i, s = hh(e), o = s[s.length - 1];
  if (s.length > 1) {
    for (let n = 0; n < s.length - 1; n++) {
      let a = s[n];
      if (r = r[a], !r)
        return;
    }
    r[o] = t;
  } else
    r[e] = t;
  return s.join(".");
}
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const Rs = {}, mb = /-[a-z]/g, gb = /([A-Z])/g;
function fh(i) {
  return Rs[i] || (Rs[i] = i.indexOf("-") < 0 ? i : i.replace(
    mb,
    (e) => e[1].toUpperCase()
  ));
}
function lo(i) {
  return Rs[i] || (Rs[i] = i.replace(gb, "-$1").toLowerCase());
}
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
let _b = 0, ph = 0, yr = [], bb = 0, Nn = !1, mh = document.createTextNode("");
new window.MutationObserver(yb).observe(mh, { characterData: !0 });
function yb() {
  Nn = !1;
  const i = yr.length;
  for (let e = 0; e < i; e++) {
    let t = yr[e];
    if (t)
      try {
        t();
      } catch (r) {
        setTimeout(() => {
          throw r;
        });
      }
  }
  yr.splice(0, i), ph += i;
}
const vb = {
  /**
   * Returns a sub-module with the async interface providing the provided
   * delay.
   *
   * @memberof timeOut
   * @param {number=} delay Time to wait before calling callbacks in ms
   * @return {!AsyncInterface} An async timeout interface
   */
  after(i) {
    return {
      run(e) {
        return window.setTimeout(e, i);
      },
      cancel(e) {
        window.clearTimeout(e);
      }
    };
  },
  /**
   * Enqueues a function called in the next task.
   *
   * @memberof timeOut
   * @param {!Function} fn Callback to run
   * @param {number=} delay Delay in milliseconds
   * @return {number} Handle used for canceling task
   */
  run(i, e) {
    return window.setTimeout(i, e);
  },
  /**
   * Cancels a previously enqueued `timeOut` callback.
   *
   * @memberof timeOut
   * @param {number} handle Handle returned from `run` of callback to cancel
   * @return {void}
   */
  cancel(i) {
    window.clearTimeout(i);
  }
}, Aa = {
  /**
   * Enqueues a function called at microtask timing.
   *
   * @memberof microTask
   * @param {!Function=} callback Callback to run
   * @return {number} Handle used for canceling task
   */
  run(i) {
    return Nn || (Nn = !0, mh.textContent = bb++), yr.push(i), _b++;
  },
  /**
   * Cancels a previously enqueued `microTask` callback.
   *
   * @memberof microTask
   * @param {number} handle Handle returned from `run` of callback to cancel
   * @return {void}
   */
  cancel(i) {
    const e = i - ph;
    if (e >= 0) {
      if (!yr[e])
        throw new Error("invalid async handle: " + i);
      yr[e] = null;
    }
  }
};
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const wb = Aa, gh = Y(
  /**
   * @template T
   * @param {function(new:T)} superClass Class to apply mixin to.
   * @return {function(new:T)} superClass with mixin applied.
   */
  (i) => {
    class e extends i {
      /**
       * Creates property accessors for the given property names.
       * @param {!Object} props Object whose keys are names of accessors.
       * @return {void}
       * @protected
       * @nocollapse
       */
      static createProperties(r) {
        const s = this.prototype;
        for (let o in r)
          o in s || s._createPropertyAccessor(o);
      }
      /**
       * Returns an attribute name that corresponds to the given property.
       * The attribute name is the lowercased property name. Override to
       * customize this mapping.
       * @param {string} property Property to convert
       * @return {string} Attribute name corresponding to the given property.
       *
       * @protected
       * @nocollapse
       */
      static attributeNameForProperty(r) {
        return r.toLowerCase();
      }
      /**
       * Override point to provide a type to which to deserialize a value to
       * a given property.
       * @param {string} name Name of property
       *
       * @protected
       * @nocollapse
       */
      static typeForProperty(r) {
      }
      //eslint-disable-line no-unused-vars
      /**
       * Creates a setter/getter pair for the named property with its own
       * local storage.  The getter returns the value in the local storage,
       * and the setter calls `_setProperty`, which updates the local storage
       * for the property and enqueues a `_propertiesChanged` callback.
       *
       * This method may be called on a prototype or an instance.  Calling
       * this method may overwrite a property value that already exists on
       * the prototype/instance by creating the accessor.
       *
       * @param {string} property Name of the property
       * @param {boolean=} readOnly When true, no setter is created; the
       *   protected `_setProperty` function must be used to set the property
       * @return {void}
       * @protected
       * @override
       */
      _createPropertyAccessor(r, s) {
        this._addPropertyToAttributeMap(r), this.hasOwnProperty(JSCompiler_renameProperty("__dataHasAccessor", this)) || (this.__dataHasAccessor = Object.assign({}, this.__dataHasAccessor)), this.__dataHasAccessor[r] || (this.__dataHasAccessor[r] = !0, this._definePropertyAccessor(r, s));
      }
      /**
       * Adds the given `property` to a map matching attribute names
       * to property names, using `attributeNameForProperty`. This map is
       * used when deserializing attribute values to properties.
       *
       * @param {string} property Name of the property
       * @override
       */
      _addPropertyToAttributeMap(r) {
        this.hasOwnProperty(JSCompiler_renameProperty("__dataAttributes", this)) || (this.__dataAttributes = Object.assign({}, this.__dataAttributes));
        let s = this.__dataAttributes[r];
        return s || (s = this.constructor.attributeNameForProperty(r), this.__dataAttributes[s] = r), s;
      }
      /**
       * Defines a property accessor for the given property.
       * @param {string} property Name of the property
       * @param {boolean=} readOnly When true, no setter is created
       * @return {void}
       * @override
       */
      _definePropertyAccessor(r, s) {
        Object.defineProperty(this, r, {
          /* eslint-disable valid-jsdoc */
          /** @this {PropertiesChanged} */
          get() {
            return this.__data[r];
          },
          /** @this {PropertiesChanged} */
          set: s ? function() {
          } : function(o) {
            this._setPendingProperty(r, o, !0) && this._invalidateProperties();
          }
          /* eslint-enable */
        });
      }
      constructor() {
        super(), this.__dataEnabled = !1, this.__dataReady = !1, this.__dataInvalid = !1, this.__data = {}, this.__dataPending = null, this.__dataOld = null, this.__dataInstanceProps = null, this.__dataCounter = 0, this.__serializing = !1, this._initializeProperties();
      }
      /**
       * Lifecycle callback called when properties are enabled via
       * `_enableProperties`.
       *
       * Users may override this function to implement behavior that is
       * dependent on the element having its property data initialized, e.g.
       * from defaults (initialized from `constructor`, `_initializeProperties`),
       * `attributeChangedCallback`, or values propagated from host e.g. via
       * bindings.  `super.ready()` must be called to ensure the data system
       * becomes enabled.
       *
       * @return {void}
       * @public
       * @override
       */
      ready() {
        this.__dataReady = !0, this._flushProperties();
      }
      /**
       * Initializes the local storage for property accessors.
       *
       * Provided as an override point for performing any setup work prior
       * to initializing the property accessor system.
       *
       * @return {void}
       * @protected
       * @override
       */
      _initializeProperties() {
        for (let r in this.__dataHasAccessor)
          this.hasOwnProperty(r) && (this.__dataInstanceProps = this.__dataInstanceProps || {}, this.__dataInstanceProps[r] = this[r], delete this[r]);
      }
      /**
       * Called at ready time with bag of instance properties that overwrote
       * accessors when the element upgraded.
       *
       * The default implementation sets these properties back into the
       * setter at ready time.  This method is provided as an override
       * point for customizing or providing more efficient initialization.
       *
       * @param {Object} props Bag of property values that were overwritten
       *   when creating property accessors.
       * @return {void}
       * @protected
       * @override
       */
      _initializeInstanceProperties(r) {
        Object.assign(this, r);
      }
      /**
       * Updates the local storage for a property (via `_setPendingProperty`)
       * and enqueues a `_proeprtiesChanged` callback.
       *
       * @param {string} property Name of the property
       * @param {*} value Value to set
       * @return {void}
       * @protected
       * @override
       */
      _setProperty(r, s) {
        this._setPendingProperty(r, s) && this._invalidateProperties();
      }
      /**
       * Returns the value for the given property.
       * @param {string} property Name of property
       * @return {*} Value for the given property
       * @protected
       * @override
       */
      _getProperty(r) {
        return this.__data[r];
      }
      /* eslint-disable no-unused-vars */
      /**
       * Updates the local storage for a property, records the previous value,
       * and adds it to the set of "pending changes" that will be passed to the
       * `_propertiesChanged` callback.  This method does not enqueue the
       * `_propertiesChanged` callback.
       *
       * @param {string} property Name of the property
       * @param {*} value Value to set
       * @param {boolean=} ext Not used here; affordance for closure
       * @return {boolean} Returns true if the property changed
       * @protected
       * @override
       */
      _setPendingProperty(r, s, o) {
        let n = this.__data[r], a = this._shouldPropertyChange(r, s, n);
        return a && (this.__dataPending || (this.__dataPending = {}, this.__dataOld = {}), this.__dataOld && !(r in this.__dataOld) && (this.__dataOld[r] = n), this.__data[r] = s, this.__dataPending[r] = s), a;
      }
      /* eslint-enable */
      /**
       * @param {string} property Name of the property
       * @return {boolean} Returns true if the property is pending.
       */
      _isPropertyPending(r) {
        return !!(this.__dataPending && this.__dataPending.hasOwnProperty(r));
      }
      /**
       * Marks the properties as invalid, and enqueues an async
       * `_propertiesChanged` callback.
       *
       * @return {void}
       * @protected
       * @override
       */
      _invalidateProperties() {
        !this.__dataInvalid && this.__dataReady && (this.__dataInvalid = !0, wb.run(() => {
          this.__dataInvalid && (this.__dataInvalid = !1, this._flushProperties());
        }));
      }
      /**
       * Call to enable property accessor processing. Before this method is
       * called accessor values will be set but side effects are
       * queued. When called, any pending side effects occur immediately.
       * For elements, generally `connectedCallback` is a normal spot to do so.
       * It is safe to call this method multiple times as it only turns on
       * property accessors once.
       *
       * @return {void}
       * @protected
       * @override
       */
      _enableProperties() {
        this.__dataEnabled || (this.__dataEnabled = !0, this.__dataInstanceProps && (this._initializeInstanceProperties(this.__dataInstanceProps), this.__dataInstanceProps = null), this.ready());
      }
      /**
       * Calls the `_propertiesChanged` callback with the current set of
       * pending changes (and old values recorded when pending changes were
       * set), and resets the pending set of changes. Generally, this method
       * should not be called in user code.
       *
       * @return {void}
       * @protected
       * @override
       */
      _flushProperties() {
        this.__dataCounter++;
        const r = this.__data, s = this.__dataPending, o = this.__dataOld;
        this._shouldPropertiesChange(r, s, o) && (this.__dataPending = null, this.__dataOld = null, this._propertiesChanged(r, s, o)), this.__dataCounter--;
      }
      /**
       * Called in `_flushProperties` to determine if `_propertiesChanged`
       * should be called. The default implementation returns true if
       * properties are pending. Override to customize when
       * `_propertiesChanged` is called.
       * @param {!Object} currentProps Bag of all current accessor values
       * @param {?Object} changedProps Bag of properties changed since the last
       *   call to `_propertiesChanged`
       * @param {?Object} oldProps Bag of previous values for each property
       *   in `changedProps`
       * @return {boolean} true if changedProps is truthy
       * @override
       */
      _shouldPropertiesChange(r, s, o) {
        return !!s;
      }
      /**
       * Callback called when any properties with accessors created via
       * `_createPropertyAccessor` have been set.
       *
       * @param {!Object} currentProps Bag of all current accessor values
       * @param {?Object} changedProps Bag of properties changed since the last
       *   call to `_propertiesChanged`
       * @param {?Object} oldProps Bag of previous values for each property
       *   in `changedProps`
       * @return {void}
       * @protected
       * @override
       */
      _propertiesChanged(r, s, o) {
      }
      /**
       * Method called to determine whether a property value should be
       * considered as a change and cause the `_propertiesChanged` callback
       * to be enqueued.
       *
       * The default implementation returns `true` if a strict equality
       * check fails. The method always returns false for `NaN`.
       *
       * Override this method to e.g. provide stricter checking for
       * Objects/Arrays when using immutable patterns.
       *
       * @param {string} property Property name
       * @param {*} value New property value
       * @param {*} old Previous property value
       * @return {boolean} Whether the property should be considered a change
       *   and enqueue a `_proeprtiesChanged` callback
       * @protected
       * @override
       */
      _shouldPropertyChange(r, s, o) {
        return (
          // Strict equality check
          o !== s && // This ensures (old==NaN, value==NaN) always returns false
          (o === o || s === s)
        );
      }
      /**
       * Implements native Custom Elements `attributeChangedCallback` to
       * set an attribute value to a property via `_attributeToProperty`.
       *
       * @param {string} name Name of attribute that changed
       * @param {?string} old Old attribute value
       * @param {?string} value New attribute value
       * @param {?string} namespace Attribute namespace.
       * @return {void}
       * @suppress {missingProperties} Super may or may not implement the callback
       * @override
       */
      attributeChangedCallback(r, s, o, n) {
        s !== o && this._attributeToProperty(r, o), super.attributeChangedCallback && super.attributeChangedCallback(r, s, o, n);
      }
      /**
       * Deserializes an attribute to its associated property.
       *
       * This method calls the `_deserializeValue` method to convert the string to
       * a typed value.
       *
       * @param {string} attribute Name of attribute to deserialize.
       * @param {?string} value of the attribute.
       * @param {*=} type type to deserialize to, defaults to the value
       * returned from `typeForProperty`
       * @return {void}
       * @override
       */
      _attributeToProperty(r, s, o) {
        if (!this.__serializing) {
          const n = this.__dataAttributes, a = n && n[r] || r;
          this[a] = this._deserializeValue(s, o || this.constructor.typeForProperty(a));
        }
      }
      /**
       * Serializes a property to its associated attribute.
       *
       * @suppress {invalidCasts} Closure can't figure out `this` is an element.
       *
       * @param {string} property Property name to reflect.
       * @param {string=} attribute Attribute name to reflect to.
       * @param {*=} value Property value to refect.
       * @return {void}
       * @override
       */
      _propertyToAttribute(r, s, o) {
        this.__serializing = !0, o = arguments.length < 3 ? this[r] : o, this._valueToNodeAttribute(
          /** @type {!HTMLElement} */
          this,
          o,
          s || this.constructor.attributeNameForProperty(r)
        ), this.__serializing = !1;
      }
      /**
       * Sets a typed value to an HTML attribute on a node.
       *
       * This method calls the `_serializeValue` method to convert the typed
       * value to a string.  If the `_serializeValue` method returns `undefined`,
       * the attribute will be removed (this is the default for boolean
       * type `false`).
       *
       * @param {Element} node Element to set attribute to.
       * @param {*} value Value to serialize.
       * @param {string} attribute Attribute name to serialize to.
       * @return {void}
       * @override
       */
      _valueToNodeAttribute(r, s, o) {
        const n = this._serializeValue(s);
        (o === "class" || o === "name" || o === "slot") && (r = /** @type {?Element} */
        B(r)), n === void 0 ? r.removeAttribute(o) : r.setAttribute(
          o,
          // Closure's type for `setAttribute`'s second parameter incorrectly
          // excludes `TrustedScript`.
          n === "" && window.trustedTypes ? (
            /** @type {?} */
            window.trustedTypes.emptyScript
          ) : n
        );
      }
      /**
       * Converts a typed JavaScript value to a string.
       *
       * This method is called when setting JS property values to
       * HTML attributes.  Users may override this method to provide
       * serialization for custom types.
       *
       * @param {*} value Property value to serialize.
       * @return {string | undefined} String serialized from the provided
       * property  value.
       * @override
       */
      _serializeValue(r) {
        switch (typeof r) {
          case "boolean":
            return r ? "" : void 0;
          default:
            return r != null ? r.toString() : void 0;
        }
      }
      /**
       * Converts a string to a typed JavaScript value.
       *
       * This method is called when reading HTML attribute values to
       * JS properties.  Users may override this method to provide
       * deserialization for custom `type`s. Types for `Boolean`, `String`,
       * and `Number` convert attributes to the expected types.
       *
       * @param {?string} value Value to deserialize.
       * @param {*=} type Type to deserialize the string to.
       * @return {*} Typed value deserialized from the provided string.
       * @override
       */
      _deserializeValue(r, s) {
        switch (s) {
          case Boolean:
            return r !== null;
          case Number:
            return Number(r);
          default:
            return r;
        }
      }
    }
    return e;
  }
);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const _h = {};
let ls = HTMLElement.prototype;
for (; ls; ) {
  let i = Object.getOwnPropertyNames(ls);
  for (let e = 0; e < i.length; e++)
    _h[i[e]] = !0;
  ls = Object.getPrototypeOf(ls);
}
const xb = (() => window.trustedTypes ? (i) => trustedTypes.isHTML(i) || trustedTypes.isScript(i) || trustedTypes.isScriptURL(i) : () => !1)();
function Cb(i, e) {
  if (!_h[e]) {
    let t = i[e];
    t !== void 0 && (i.__data ? i._setPendingProperty(e, t) : (i.__dataProto ? i.hasOwnProperty(JSCompiler_renameProperty("__dataProto", i)) || (i.__dataProto = Object.create(i.__dataProto)) : i.__dataProto = {}, i.__dataProto[e] = t));
  }
}
const kb = Y((i) => {
  const e = gh(i);
  class t extends e {
    /**
     * Generates property accessors for all attributes in the standard
     * static `observedAttributes` array.
     *
     * Attribute names are mapped to property names using the `dash-case` to
     * `camelCase` convention
     *
     * @return {void}
     * @nocollapse
     */
    static createPropertiesForAttributes() {
      let s = (
        /** @type {?} */
        this.observedAttributes
      );
      for (let o = 0; o < s.length; o++)
        this.prototype._createPropertyAccessor(fh(s[o]));
    }
    /**
     * Returns an attribute name that corresponds to the given property.
     * By default, converts camel to dash case, e.g. `fooBar` to `foo-bar`.
     * @param {string} property Property to convert
     * @return {string} Attribute name corresponding to the given property.
     *
     * @protected
     * @nocollapse
     */
    static attributeNameForProperty(s) {
      return lo(s);
    }
    /**
     * Overrides PropertiesChanged implementation to initialize values for
     * accessors created for values that already existed on the element
     * prototype.
     *
     * @return {void}
     * @protected
     * @override
     */
    _initializeProperties() {
      this.__dataProto && (this._initializeProtoProperties(this.__dataProto), this.__dataProto = null), super._initializeProperties();
    }
    /**
     * Called at instance time with bag of properties that were overwritten
     * by accessors on the prototype when accessors were created.
     *
     * The default implementation sets these properties back into the
     * setter at instance time.  This method is provided as an override
     * point for customizing or providing more efficient initialization.
     *
     * @param {Object} props Bag of property values that were overwritten
     *   when creating property accessors.
     * @return {void}
     * @protected
     * @override
     */
    _initializeProtoProperties(s) {
      for (let o in s)
        this._setProperty(o, s[o]);
    }
    /**
     * Ensures the element has the given attribute. If it does not,
     * assigns the given value to the attribute.
     *
     * @suppress {invalidCasts} Closure can't figure out `this` is infact an
     *     element
     *
     * @param {string} attribute Name of attribute to ensure is set.
     * @param {string} value of the attribute.
     * @return {void}
     * @override
     */
    _ensureAttribute(s, o) {
      const n = (
        /** @type {!HTMLElement} */
        this
      );
      n.hasAttribute(s) || this._valueToNodeAttribute(n, o, s);
    }
    /**
     * Overrides PropertiesChanged implemention to serialize objects as JSON.
     *
     * @param {*} value Property value to serialize.
     * @return {string | undefined} String serialized from the provided property
     *     value.
     * @override
     */
    _serializeValue(s) {
      switch (typeof s) {
        case "object":
          if (s instanceof Date)
            return s.toString();
          if (s) {
            if (xb(s))
              return (
                /** @type {?} */
                s
              );
            try {
              return JSON.stringify(s);
            } catch {
              return "";
            }
          }
        default:
          return super._serializeValue(s);
      }
    }
    /**
     * Converts a string to a typed JavaScript value.
     *
     * This method is called by Polymer when reading HTML attribute values to
     * JS properties.  Users may override this method on Polymer element
     * prototypes to provide deserialization for custom `type`s.  Note,
     * the `type` argument is the value of the `type` field provided in the
     * `properties` configuration object for a given property, and is
     * by convention the constructor for the type to deserialize.
     *
     *
     * @param {?string} value Attribute value to deserialize.
     * @param {*=} type Type to deserialize the string to.
     * @return {*} Typed value deserialized from the provided string.
     * @override
     */
    _deserializeValue(s, o) {
      let n;
      switch (o) {
        case Object:
          try {
            n = JSON.parse(
              /** @type {string} */
              s
            );
          } catch {
            n = s;
          }
          break;
        case Array:
          try {
            n = JSON.parse(
              /** @type {string} */
              s
            );
          } catch {
            n = null;
          }
          break;
        case Date:
          n = isNaN(s) ? String(s) : Number(s), n = new Date(n);
          break;
        default:
          n = super._deserializeValue(s, o);
          break;
      }
      return n;
    }
    /* eslint-enable no-fallthrough */
    /**
     * Overrides PropertiesChanged implementation to save existing prototype
     * property value so that it can be reset.
     * @param {string} property Name of the property
     * @param {boolean=} readOnly When true, no setter is created
     *
     * When calling on a prototype, any overwritten values are saved in
     * `__dataProto`, and it is up to the subclasser to decide how/when
     * to set those properties back into the accessor.  When calling on an
     * instance, the overwritten value is set via `_setPendingProperty`,
     * and the user should call `_invalidateProperties` or `_flushProperties`
     * for the values to take effect.
     * @protected
     * @return {void}
     * @override
     */
    _definePropertyAccessor(s, o) {
      Cb(this, s), super._definePropertyAccessor(s, o);
    }
    /**
     * Returns true if this library created an accessor for the given property.
     *
     * @param {string} property Property name
     * @return {boolean} True if an accessor was created
     * @override
     */
    _hasAccessor(s) {
      return this.__dataHasAccessor && this.__dataHasAccessor[s];
    }
    /**
     * Returns true if the specified property has a pending change.
     *
     * @param {string} prop Property name
     * @return {boolean} True if property has a pending change
     * @protected
     * @override
     */
    _isPropertyPending(s) {
      return !!(this.__dataPending && s in this.__dataPending);
    }
  }
  return t;
});
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const Ab = {
  "dom-if": !0,
  "dom-repeat": !0
};
let dc = !1, uc = !1;
function Eb() {
  if (!dc) {
    dc = !0;
    const i = document.createElement("textarea");
    i.placeholder = "a", uc = i.placeholder === i.textContent;
  }
  return uc;
}
function Sb(i) {
  Eb() && i.localName === "textarea" && i.placeholder && i.placeholder === i.textContent && (i.textContent = null);
}
const Tb = (() => {
  const i = window.trustedTypes && window.trustedTypes.createPolicy(
    "polymer-template-event-attribute-policy",
    {
      createScript: (e) => e
    }
  );
  return (e, t, r) => {
    const s = t.getAttribute(r);
    if (i && r.startsWith("on-")) {
      e.setAttribute(
        r,
        i.createScript(s, r)
      );
      return;
    }
    e.setAttribute(r, s);
  };
})();
function Ib(i) {
  let e = i.getAttribute("is");
  if (e && Ab[e]) {
    let t = i;
    for (t.removeAttribute("is"), i = t.ownerDocument.createElement(e), t.parentNode.replaceChild(i, t), i.appendChild(t); t.attributes.length; ) {
      const { name: r } = t.attributes[0];
      Tb(i, t, r), t.removeAttribute(r);
    }
  }
  return i;
}
function bh(i, e) {
  let t = e.parentInfo && bh(i, e.parentInfo);
  if (t) {
    for (let r = t.firstChild, s = 0; r; r = r.nextSibling)
      if (e.parentIndex === s++)
        return r;
  } else
    return i;
}
function Db(i, e, t, r) {
  r.id && (e[r.id] = t);
}
function Ob(i, e, t) {
  if (t.events && t.events.length)
    for (let r = 0, s = t.events, o; r < s.length && (o = s[r]); r++)
      i._addMethodEventListenerToNode(e, o.name, o.value, i);
}
function $b(i, e, t, r) {
  t.templateInfo && (e._templateInfo = t.templateInfo, e._parentTemplateInfo = r);
}
function Pb(i, e, t) {
  return i = i._methodHost || i, function(s) {
    i[t] && i[t](s, s.detail);
  };
}
const Mb = Y(
  /**
   * @template T
   * @param {function(new:T)} superClass Class to apply mixin to.
   * @return {function(new:T)} superClass with mixin applied.
   */
  (i) => {
    class e extends i {
      /**
       * Scans a template to produce template metadata.
       *
       * Template-specific metadata are stored in the object returned, and node-
       * specific metadata are stored in objects in its flattened `nodeInfoList`
       * array.  Only nodes in the template that were parsed as nodes of
       * interest contain an object in `nodeInfoList`.  Each `nodeInfo` object
       * contains an `index` (`childNodes` index in parent) and optionally
       * `parent`, which points to node info of its parent (including its index).
       *
       * The template metadata object returned from this method has the following
       * structure (many fields optional):
       *
       * ```js
       *   {
       *     // Flattened list of node metadata (for nodes that generated metadata)
       *     nodeInfoList: [
       *       {
       *         // `id` attribute for any nodes with id's for generating `$` map
       *         id: {string},
       *         // `on-event="handler"` metadata
       *         events: [
       *           {
       *             name: {string},   // event name
       *             value: {string},  // handler method name
       *           }, ...
       *         ],
       *         // Notes when the template contained a `<slot>` for shady DOM
       *         // optimization purposes
       *         hasInsertionPoint: {boolean},
       *         // For nested `<template>`` nodes, nested template metadata
       *         templateInfo: {object}, // nested template metadata
       *         // Metadata to allow efficient retrieval of instanced node
       *         // corresponding to this metadata
       *         parentInfo: {number},   // reference to parent nodeInfo>
       *         parentIndex: {number},  // index in parent's `childNodes` collection
       *         infoIndex: {number},    // index of this `nodeInfo` in `templateInfo.nodeInfoList`
       *       },
       *       ...
       *     ],
       *     // When true, the template had the `strip-whitespace` attribute
       *     // or was nested in a template with that setting
       *     stripWhitespace: {boolean},
       *     // For nested templates, nested template content is moved into
       *     // a document fragment stored here; this is an optimization to
       *     // avoid the cost of nested template cloning
       *     content: {DocumentFragment}
       *   }
       * ```
       *
       * This method kicks off a recursive treewalk as follows:
       *
       * ```
       *    _parseTemplate <---------------------+
       *      _parseTemplateContent              |
       *        _parseTemplateNode  <------------|--+
       *          _parseTemplateNestedTemplate --+  |
       *          _parseTemplateChildNodes ---------+
       *          _parseTemplateNodeAttributes
       *            _parseTemplateNodeAttribute
       *
       * ```
       *
       * These methods may be overridden to add custom metadata about templates
       * to either `templateInfo` or `nodeInfo`.
       *
       * Note that this method may be destructive to the template, in that
       * e.g. event annotations may be removed after being noted in the
       * template metadata.
       *
       * @param {!HTMLTemplateElement} template Template to parse
       * @param {TemplateInfo=} outerTemplateInfo Template metadata from the outer
       *   template, for parsing nested templates
       * @return {!TemplateInfo} Parsed template metadata
       * @nocollapse
       */
      static _parseTemplate(r, s) {
        if (!r._templateInfo) {
          let o = r._templateInfo = {};
          o.nodeInfoList = [], o.nestedTemplate = !!s, o.stripWhiteSpace = s && s.stripWhiteSpace || r.hasAttribute && r.hasAttribute("strip-whitespace"), this._parseTemplateContent(
            r,
            o,
            /** @type {?} */
            { parent: null }
          );
        }
        return r._templateInfo;
      }
      /**
       * See docs for _parseTemplateNode.
       *
       * @param {!HTMLTemplateElement} template .
       * @param {!TemplateInfo} templateInfo .
       * @param {!NodeInfo} nodeInfo .
       * @return {boolean} .
       * @nocollapse
       */
      static _parseTemplateContent(r, s, o) {
        return this._parseTemplateNode(r.content, s, o);
      }
      /**
       * Parses template node and adds template and node metadata based on
       * the current node, and its `childNodes` and `attributes`.
       *
       * This method may be overridden to add custom node or template specific
       * metadata based on this node.
       *
       * @param {Node} node Node to parse
       * @param {!TemplateInfo} templateInfo Template metadata for current template
       * @param {!NodeInfo} nodeInfo Node metadata for current template.
       * @return {boolean} `true` if the visited node added node-specific
       *   metadata to `nodeInfo`
       * @nocollapse
       */
      static _parseTemplateNode(r, s, o) {
        let n = !1, a = (
          /** @type {!HTMLTemplateElement} */
          r
        );
        return a.localName == "template" && !a.hasAttribute("preserve-content") ? n = this._parseTemplateNestedTemplate(a, s, o) || n : a.localName === "slot" && (s.hasInsertionPoint = !0), Sb(a), a.firstChild && this._parseTemplateChildNodes(a, s, o), a.hasAttributes && a.hasAttributes() && (n = this._parseTemplateNodeAttributes(a, s, o) || n), n || o.noted;
      }
      /**
       * Parses template child nodes for the given root node.
       *
       * This method also wraps whitelisted legacy template extensions
       * (`is="dom-if"` and `is="dom-repeat"`) with their equivalent element
       * wrappers, collapses text nodes, and strips whitespace from the template
       * if the `templateInfo.stripWhitespace` setting was provided.
       *
       * @param {Node} root Root node whose `childNodes` will be parsed
       * @param {!TemplateInfo} templateInfo Template metadata for current template
       * @param {!NodeInfo} nodeInfo Node metadata for current template.
       * @return {void}
       */
      static _parseTemplateChildNodes(r, s, o) {
        if (!(r.localName === "script" || r.localName === "style"))
          for (let n = r.firstChild, a = 0, l; n; n = l) {
            if (n.localName == "template" && (n = Ib(n)), l = n.nextSibling, n.nodeType === Node.TEXT_NODE) {
              let d = l;
              for (; d && d.nodeType === Node.TEXT_NODE; )
                n.textContent += d.textContent, l = d.nextSibling, r.removeChild(d), d = l;
              if (s.stripWhiteSpace && !n.textContent.trim()) {
                r.removeChild(n);
                continue;
              }
            }
            let c = (
              /** @type {!NodeInfo} */
              { parentIndex: a, parentInfo: o }
            );
            this._parseTemplateNode(n, s, c) && (c.infoIndex = s.nodeInfoList.push(c) - 1), n.parentNode && a++;
          }
      }
      /**
       * Parses template content for the given nested `<template>`.
       *
       * Nested template info is stored as `templateInfo` in the current node's
       * `nodeInfo`. `template.content` is removed and stored in `templateInfo`.
       * It will then be the responsibility of the host to set it back to the
       * template and for users stamping nested templates to use the
       * `_contentForTemplate` method to retrieve the content for this template
       * (an optimization to avoid the cost of cloning nested template content).
       *
       * @param {HTMLTemplateElement} node Node to parse (a <template>)
       * @param {TemplateInfo} outerTemplateInfo Template metadata for current template
       *   that includes the template `node`
       * @param {!NodeInfo} nodeInfo Node metadata for current template.
       * @return {boolean} `true` if the visited node added node-specific
       *   metadata to `nodeInfo`
       * @nocollapse
       */
      static _parseTemplateNestedTemplate(r, s, o) {
        let n = (
          /** @type {!HTMLTemplateElement} */
          r
        ), a = this._parseTemplate(n, s);
        return (a.content = n.content.ownerDocument.createDocumentFragment()).appendChild(n.content), o.templateInfo = a, !0;
      }
      /**
       * Parses template node attributes and adds node metadata to `nodeInfo`
       * for nodes of interest.
       *
       * @param {Element} node Node to parse
       * @param {!TemplateInfo} templateInfo Template metadata for current
       *     template
       * @param {!NodeInfo} nodeInfo Node metadata for current template.
       * @return {boolean} `true` if the visited node added node-specific
       *   metadata to `nodeInfo`
       * @nocollapse
       */
      static _parseTemplateNodeAttributes(r, s, o) {
        let n = !1, a = Array.from(r.attributes);
        for (let l = a.length - 1, c; c = a[l]; l--)
          n = this._parseTemplateNodeAttribute(r, s, o, c.name, c.value) || n;
        return n;
      }
      /**
       * Parses a single template node attribute and adds node metadata to
       * `nodeInfo` for attributes of interest.
       *
       * This implementation adds metadata for `on-event="handler"` attributes
       * and `id` attributes.
       *
       * @param {Element} node Node to parse
       * @param {!TemplateInfo} templateInfo Template metadata for current template
       * @param {!NodeInfo} nodeInfo Node metadata for current template.
       * @param {string} name Attribute name
       * @param {string} value Attribute value
       * @return {boolean} `true` if the visited node added node-specific
       *   metadata to `nodeInfo`
       * @nocollapse
       */
      static _parseTemplateNodeAttribute(r, s, o, n, a) {
        return n.slice(0, 3) === "on-" ? (r.removeAttribute(n), o.events = o.events || [], o.events.push({
          name: n.slice(3),
          value: a
        }), !0) : n === "id" ? (o.id = a, !0) : !1;
      }
      /**
       * Returns the `content` document fragment for a given template.
       *
       * For nested templates, Polymer performs an optimization to cache nested
       * template content to avoid the cost of cloning deeply nested templates.
       * This method retrieves the cached content for a given template.
       *
       * @param {HTMLTemplateElement} template Template to retrieve `content` for
       * @return {DocumentFragment} Content fragment
       * @nocollapse
       */
      static _contentForTemplate(r) {
        let s = (
          /** @type {HTMLTemplateElementWithInfo} */
          r._templateInfo
        );
        return s && s.content || r.content;
      }
      /**
       * Clones the provided template content and returns a document fragment
       * containing the cloned dom.
       *
       * The template is parsed (once and memoized) using this library's
       * template parsing features, and provides the following value-added
       * features:
       * * Adds declarative event listeners for `on-event="handler"` attributes
       * * Generates an "id map" for all nodes with id's under `$` on returned
       *   document fragment
       * * Passes template info including `content` back to templates as
       *   `_templateInfo` (a performance optimization to avoid deep template
       *   cloning)
       *
       * Note that the memoized template parsing process is destructive to the
       * template: attributes for bindings and declarative event listeners are
       * removed after being noted in notes, and any nested `<template>.content`
       * is removed and stored in notes as well.
       *
       * @param {!HTMLTemplateElement} template Template to stamp
       * @param {TemplateInfo=} templateInfo Optional template info associated
       *   with the template to be stamped; if omitted the template will be
       *   automatically parsed.
       * @return {!StampedTemplate} Cloned template content
       * @override
       */
      _stampTemplate(r, s) {
        r && !r.content && window.HTMLTemplateElement && HTMLTemplateElement.decorate && HTMLTemplateElement.decorate(r), s = s || this.constructor._parseTemplate(r);
        let o = s.nodeInfoList, n = s.content || r.content, a = (
          /** @type {DocumentFragment} */
          document.importNode(n, !0)
        );
        a.__noInsertionPoint = !s.hasInsertionPoint;
        let l = a.nodeList = new Array(o.length);
        a.$ = {};
        for (let c = 0, d = o.length, u; c < d && (u = o[c]); c++) {
          let h = l[c] = bh(a, u);
          Db(this, a.$, h, u), $b(this, h, u, s), Ob(this, h, u);
        }
        return a = /** @type {!StampedTemplate} */
        a, a;
      }
      /**
       * Adds an event listener by method name for the event provided.
       *
       * This method generates a handler function that looks up the method
       * name at handling time.
       *
       * @param {!EventTarget} node Node to add listener on
       * @param {string} eventName Name of event
       * @param {string} methodName Name of method
       * @param {*=} context Context the method will be called on (defaults
       *   to `node`)
       * @return {Function} Generated handler function
       * @override
       */
      _addMethodEventListenerToNode(r, s, o, n) {
        n = n || r;
        let a = Pb(n, s, o);
        return this._addEventListenerToNode(r, s, a), a;
      }
      /**
       * Override point for adding custom or simulated event handling.
       *
       * @param {!EventTarget} node Node to add event listener to
       * @param {string} eventName Name of event
       * @param {function(!Event):void} handler Listener function to add
       * @return {void}
       * @override
       */
      _addEventListenerToNode(r, s, o) {
        r.addEventListener(s, o);
      }
      /**
       * Override point for adding custom or simulated event handling.
       *
       * @param {!EventTarget} node Node to remove event listener from
       * @param {string} eventName Name of event
       * @param {function(!Event):void} handler Listener function to remove
       * @return {void}
       * @override
       */
      _removeEventListenerFromNode(r, s, o) {
        r.removeEventListener(s, o);
      }
    }
    return e;
  }
);
/**
 * @fileoverview
 * @suppress {checkPrototypalTypes}
 * @license Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt The complete set of authors may be found
 * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may
 * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by
 * Google as part of the polymer project is also subject to an additional IP
 * rights grant found at http://polymer.github.io/PATENTS.txt
 */
let Ei = 0;
const Si = [], D = {
  COMPUTE: "__computeEffects",
  REFLECT: "__reflectEffects",
  NOTIFY: "__notifyEffects",
  PROPAGATE: "__propagateEffects",
  OBSERVE: "__observeEffects",
  READ_ONLY: "__readOnly"
}, yh = "__computeInfo", zb = /[A-Z]/;
function jo(i, e, t) {
  let r = i[e];
  if (!r)
    r = i[e] = {};
  else if (!i.hasOwnProperty(e) && (r = i[e] = Object.create(i[e]), t))
    for (let s in r) {
      let o = r[s], n = r[s] = Array(o.length);
      for (let a = 0; a < o.length; a++)
        n[a] = o[a];
    }
  return r;
}
function ni(i, e, t, r, s, o) {
  if (e) {
    let n = !1;
    const a = Ei++;
    for (let l in t) {
      let c = s ? er(l) : l, d = e[c];
      if (d)
        for (let u = 0, h = d.length, f; u < h && (f = d[u]); u++)
          (!f.info || f.info.lastRun !== a) && (!s || Ea(l, f.trigger)) && (f.info && (f.info.lastRun = a), f.fn(i, l, t, r, f.info, s, o), n = !0);
    }
    return n;
  }
  return !1;
}
function Nb(i, e, t, r, s, o, n, a) {
  let l = !1, c = n ? er(r) : r, d = e[c];
  if (d)
    for (let u = 0, h = d.length, f; u < h && (f = d[u]); u++)
      (!f.info || f.info.lastRun !== t) && (!n || Ea(r, f.trigger)) && (f.info && (f.info.lastRun = t), f.fn(i, r, s, o, f.info, n, a), l = !0);
  return l;
}
function Ea(i, e) {
  if (e) {
    let t = (
      /** @type {string} */
      e.name
    );
    return t == i || !!(e.structured && uh(t, i)) || !!(e.wildcard && ki(t, i));
  } else
    return !0;
}
function hc(i, e, t, r, s) {
  let o = typeof s.method == "string" ? i[s.method] : s.method, n = s.property;
  o ? o.call(i, i.__data[n], r[n]) : s.dynamicFn;
}
function Fb(i, e, t, r, s) {
  let o = i[D.NOTIFY], n, a = Ei++;
  for (let c in e)
    e[c] && (o && Nb(i, o, a, c, t, r, s) || s && Rb(i, c, t)) && (n = !0);
  let l;
  n && (l = i.__dataHost) && l._invalidateProperties && l._invalidateProperties();
}
function Rb(i, e, t) {
  let r = er(e);
  if (r !== e) {
    let s = lo(r) + "-changed";
    return vh(i, s, t[e], e), !0;
  }
  return !1;
}
function vh(i, e, t, r) {
  let s = {
    value: t,
    queueProperty: !0
  };
  r && (s.path = r), B(
    /** @type {!HTMLElement} */
    i
  ).dispatchEvent(new CustomEvent(e, { detail: s }));
}
function Lb(i, e, t, r, s, o) {
  let a = (o ? er(e) : e) != e ? e : null, l = a ? ae(i, a) : i.__data[e];
  a && l === void 0 && (l = t[e]), vh(i, s.eventName, l, a);
}
function Vb(i, e, t, r, s) {
  let o, n = (
    /** @type {Object} */
    i.detail
  ), a = n && n.path;
  a ? (r = Ai(t, r, a), o = n && n.value) : o = i.currentTarget[t], o = s ? !o : o, (!e[D.READ_ONLY] || !e[D.READ_ONLY][r]) && e._setPendingPropertyOrPath(r, o, !0, !!a) && (!n || !n.queueProperty) && e._invalidateProperties();
}
function Hb(i, e, t, r, s) {
  let o = i.__data[e];
  Ns && (o = Ns(
    o,
    s.attrName,
    "attribute",
    /** @type {Node} */
    i
  )), i._propertyToAttribute(e, s.attrName, o);
}
function Bb(i, e, t, r) {
  let s = i[D.COMPUTE];
  if (s)
    if (sb) {
      Ei++;
      const o = qb(i), n = [];
      for (let l in e)
        fc(l, s, n, o, r);
      let a;
      for (; a = n.shift(); )
        wh(i, "", e, t, a) && fc(a.methodInfo, s, n, o, r);
      Object.assign(
        /** @type {!Object} */
        t,
        i.__dataOld
      ), Object.assign(
        /** @type {!Object} */
        e,
        i.__dataPending
      ), i.__dataPending = null;
    } else {
      let o = e;
      for (; ni(i, s, o, t, r); )
        Object.assign(
          /** @type {!Object} */
          t,
          i.__dataOld
        ), Object.assign(
          /** @type {!Object} */
          e,
          i.__dataPending
        ), o = i.__dataPending, i.__dataPending = null;
    }
}
const Ub = (i, e, t) => {
  let r = 0, s = e.length - 1, o = -1;
  for (; r <= s; ) {
    const n = r + s >> 1, a = t.get(e[n].methodInfo) - t.get(i.methodInfo);
    if (a < 0)
      r = n + 1;
    else if (a > 0)
      s = n - 1;
    else {
      o = n;
      break;
    }
  }
  o < 0 && (o = s + 1), e.splice(o, 0, i);
}, fc = (i, e, t, r, s) => {
  const o = s ? er(i) : i, n = e[o];
  if (n)
    for (let a = 0; a < n.length; a++) {
      const l = n[a];
      l.info.lastRun !== Ei && (!s || Ea(i, l.trigger)) && (l.info.lastRun = Ei, Ub(l.info, t, r));
    }
};
function qb(i) {
  let e = i.constructor.__orderedComputedDeps;
  if (!e) {
    e = /* @__PURE__ */ new Map();
    const t = i[D.COMPUTE];
    let { counts: r, ready: s, total: o } = Wb(i), n;
    for (; n = s.shift(); ) {
      e.set(n, e.size);
      const a = t[n];
      a && a.forEach((l) => {
        const c = l.info.methodInfo;
        --o, --r[c] === 0 && s.push(c);
      });
    }
    if (o !== 0) {
      const a = (
        /** @type {HTMLElement} */
        i
      );
    }
    i.constructor.__orderedComputedDeps = e;
  }
  return e;
}
function Wb(i) {
  const e = i[yh], t = {}, r = i[D.COMPUTE], s = [];
  let o = 0;
  for (let n in e) {
    const a = e[n];
    o += t[n] = a.args.filter((l) => !l.literal).length + (a.dynamicFn ? 1 : 0);
  }
  for (let n in r)
    e[n] || s.push(n);
  return { counts: t, ready: s, total: o };
}
function wh(i, e, t, r, s) {
  let o = Fn(i, e, t, r, s);
  if (o === Si)
    return !1;
  let n = s.methodInfo;
  return i.__dataHasAccessor && i.__dataHasAccessor[n] ? i._setPendingProperty(n, o, !0) : (i[n] = o, !1);
}
function jb(i, e, t) {
  let r = i.__dataLinkedPaths;
  if (r) {
    let s;
    for (let o in r) {
      let n = r[o];
      ki(o, e) ? (s = Ai(o, n, e), i._setPendingPropertyOrPath(s, t, !0, !0)) : ki(n, e) && (s = Ai(n, o, e), i._setPendingPropertyOrPath(s, t, !0, !0));
    }
  }
}
function Go(i, e, t, r, s, o, n) {
  t.bindings = t.bindings || [];
  let a = { kind: r, target: s, parts: o, literal: n, isCompound: o.length !== 1 };
  if (t.bindings.push(a), Qb(a)) {
    let { event: c, negate: d } = a.parts[0];
    a.listenerEvent = c || lo(s) + "-changed", a.listenerNegate = d;
  }
  let l = e.nodeInfoList.length;
  for (let c = 0; c < a.parts.length; c++) {
    let d = a.parts[c];
    d.compoundIndex = c, Gb(i, e, a, d, l);
  }
}
function Gb(i, e, t, r, s) {
  if (!r.literal && !(t.kind === "attribute" && t.target[0] === "-")) {
    let o = r.dependencies, n = { index: s, binding: t, part: r, evaluator: i };
    for (let a = 0; a < o.length; a++) {
      let l = o[a];
      typeof l == "string" && (l = Ch(l), l.wildcard = !0), i._addTemplatePropertyEffect(e, l.rootProperty, {
        fn: Yb,
        info: n,
        trigger: l
      });
    }
  }
}
function Yb(i, e, t, r, s, o, n) {
  let a = n[s.index], l = s.binding, c = s.part;
  if (o && c.source && e.length > c.source.length && l.kind == "property" && !l.isCompound && a.__isPropertyEffectsClient && a.__dataHasAccessor && a.__dataHasAccessor[l.target]) {
    let d = t[e];
    e = Ai(c.source, l.target, e), a._setPendingPropertyOrPath(e, d, !1, !0) && i._enqueueClient(a);
  } else {
    let d = s.evaluator._evaluateBinding(i, c, e, t, r, o);
    d !== Si && Zb(i, a, l, c, d);
  }
}
function Zb(i, e, t, r, s) {
  if (s = Kb(e, s, t, r), Ns && (s = Ns(s, t.target, t.kind, e)), t.kind == "attribute")
    i._valueToNodeAttribute(
      /** @type {Element} */
      e,
      s,
      t.target
    );
  else {
    let o = t.target;
    e.__isPropertyEffectsClient && e.__dataHasAccessor && e.__dataHasAccessor[o] ? (!e[D.READ_ONLY] || !e[D.READ_ONLY][o]) && e._setPendingProperty(o, s) && i._enqueueClient(e) : i._setUnmanagedPropertyToNode(e, o, s);
  }
}
function Kb(i, e, t, r) {
  if (t.isCompound) {
    let s = i.__dataCompoundStorage[t.target];
    s[r.compoundIndex] = e, e = s.join("");
  }
  return t.kind !== "attribute" && (t.target === "textContent" || t.target === "value" && (i.localName === "input" || i.localName === "textarea")) && (e = e ?? ""), e;
}
function Qb(i) {
  return !!i.target && i.kind != "attribute" && i.kind != "text" && !i.isCompound && i.parts[0].mode === "{";
}
function Jb(i, e) {
  let { nodeList: t, nodeInfoList: r } = e;
  if (r.length)
    for (let s = 0; s < r.length; s++) {
      let o = r[s], n = t[s], a = o.bindings;
      if (a)
        for (let l = 0; l < a.length; l++) {
          let c = a[l];
          Xb(n, c), ey(n, i, c);
        }
      n.__dataHost = i;
    }
}
function Xb(i, e) {
  if (e.isCompound) {
    let t = i.__dataCompoundStorage || (i.__dataCompoundStorage = {}), r = e.parts, s = new Array(r.length);
    for (let n = 0; n < r.length; n++)
      s[n] = r[n].literal;
    let o = e.target;
    t[o] = s, e.literal && e.kind == "property" && (o === "className" && (i = B(i)), i[o] = e.literal);
  }
}
function ey(i, e, t) {
  if (t.listenerEvent) {
    let r = t.parts[0];
    i.addEventListener(t.listenerEvent, function(s) {
      Vb(s, e, t.target, r.source, r.negate);
    });
  }
}
function pc(i, e, t, r, s, o) {
  o = e.static || o && (typeof o != "object" || o[e.methodName]);
  let n = {
    methodName: e.methodName,
    args: e.args,
    methodInfo: s,
    dynamicFn: o
  };
  for (let a = 0, l; a < e.args.length && (l = e.args[a]); a++)
    l.literal || i._addPropertyEffect(l.rootProperty, t, {
      fn: r,
      info: n,
      trigger: l
    });
  return o && i._addPropertyEffect(e.methodName, t, {
    fn: r,
    info: n
  }), n;
}
function Fn(i, e, t, r, s) {
  let o = i._methodHost || i, n = o[s.methodName];
  if (n) {
    let a = i._marshalArgs(s.args, e, t);
    return a === Si ? Si : n.apply(o, a);
  } else
    s.dynamicFn;
}
const ty = [], xh = "(?:[a-zA-Z_$][\\w.:$\\-*]*)", ry = "(?:[-+]?[0-9]*\\.?[0-9]+(?:[eE][-+]?[0-9]+)?)", iy = "(?:'(?:[^'\\\\]|\\\\.)*')", sy = '(?:"(?:[^"\\\\]|\\\\.)*")', oy = "(?:" + iy + "|" + sy + ")", mc = "(?:(" + xh + "|" + ry + "|" + oy + ")\\s*)", ny = "(?:" + mc + "(?:,\\s*" + mc + ")*)", ay = "(?:\\(\\s*(?:" + ny + "?)\\)\\s*)", ly = "(" + xh + "\\s*" + ay + "?)", cy = "(\\[\\[|{{)\\s*", dy = "(?:]]|}})", uy = "(?:(!)\\s*)?", hy = cy + uy + ly + dy, gc = new RegExp(hy, "g");
function _c(i) {
  let e = "";
  for (let t = 0; t < i.length; t++) {
    let r = i[t].literal;
    e += r || "";
  }
  return e;
}
function Yo(i) {
  let e = i.match(/([^\s]+?)\(([\s\S]*)\)/);
  if (e) {
    let r = { methodName: e[1], static: !0, args: ty };
    if (e[2].trim()) {
      let s = e[2].replace(/\\,/g, "&comma;").split(",");
      return fy(s, r);
    } else
      return r;
  }
  return null;
}
function fy(i, e) {
  return e.args = i.map(function(t) {
    let r = Ch(t);
    return r.literal || (e.static = !1), r;
  }, this), e;
}
function Ch(i) {
  let e = i.trim().replace(/&comma;/g, ",").replace(/\\(.)/g, "$1"), t = {
    name: e,
    value: "",
    literal: !1
  }, r = e[0];
  switch (r === "-" && (r = e[1]), r >= "0" && r <= "9" && (r = "#"), r) {
    case "'":
    case '"':
      t.value = e.slice(1, -1), t.literal = !0;
      break;
    case "#":
      t.value = Number(e), t.literal = !0;
      break;
  }
  return t.literal || (t.rootProperty = er(e), t.structured = zn(e), t.structured && (t.wildcard = e.slice(-2) == ".*", t.wildcard && (t.name = e.slice(0, -2)))), t;
}
function bc(i, e, t) {
  let r = ae(i, t);
  return r === void 0 && (r = e[t]), r;
}
function kh(i, e, t, r) {
  const s = { indexSplices: r };
  Mn && !i._overrideLegacyUndefined && (e.splices = s), i.notifyPath(t + ".splices", s), i.notifyPath(t + ".length", e.length), Mn && !i._overrideLegacyUndefined && (s.indexSplices = []);
}
function Yr(i, e, t, r, s, o) {
  kh(i, e, t, [{
    index: r,
    addedCount: s,
    removed: o,
    object: e,
    type: "splice"
  }]);
}
function py(i) {
  return i[0].toUpperCase() + i.substring(1);
}
const Sa = Y((i) => {
  const e = Mb(kb(i));
  class t extends e {
    constructor() {
      super(), this.__isPropertyEffectsClient = !0, this.__dataClientsReady, this.__dataPendingClients, this.__dataToNotify, this.__dataLinkedPaths, this.__dataHasPaths, this.__dataCompoundStorage, this.__dataHost, this.__dataTemp, this.__dataClientsInitialized, this.__data, this.__dataPending, this.__dataOld, this.__computeEffects, this.__computeInfo, this.__reflectEffects, this.__notifyEffects, this.__propagateEffects, this.__observeEffects, this.__readOnly, this.__templateInfo, this._overrideLegacyUndefined;
    }
    get PROPERTY_EFFECT_TYPES() {
      return D;
    }
    /**
     * @override
     * @return {void}
     */
    _initializeProperties() {
      super._initializeProperties(), this._registerHost(), this.__dataClientsReady = !1, this.__dataPendingClients = null, this.__dataToNotify = null, this.__dataLinkedPaths = null, this.__dataHasPaths = !1, this.__dataCompoundStorage = this.__dataCompoundStorage || null, this.__dataHost = this.__dataHost || null, this.__dataTemp = {}, this.__dataClientsInitialized = !1;
    }
    _registerHost() {
      if (Zr.length) {
        let s = Zr[Zr.length - 1];
        s._enqueueClient(this), this.__dataHost = s;
      }
    }
    /**
     * Overrides `PropertyAccessors` implementation to provide a
     * more efficient implementation of initializing properties from
     * the prototype on the instance.
     *
     * @override
     * @param {Object} props Properties to initialize on the prototype
     * @return {void}
     */
    _initializeProtoProperties(s) {
      this.__data = Object.create(s), this.__dataPending = Object.create(s), this.__dataOld = {};
    }
    /**
     * Overrides `PropertyAccessors` implementation to avoid setting
     * `_setProperty`'s `shouldNotify: true`.
     *
     * @override
     * @param {Object} props Properties to initialize on the instance
     * @return {void}
     */
    _initializeInstanceProperties(s) {
      let o = this[D.READ_ONLY];
      for (let n in s)
        (!o || !o[n]) && (this.__dataPending = this.__dataPending || {}, this.__dataOld = this.__dataOld || {}, this.__data[n] = this.__dataPending[n] = s[n]);
    }
    // Prototype setup ----------------------------------------
    /**
     * Equivalent to static `addPropertyEffect` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @override
     * @param {string} property Property that should trigger the effect
     * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
     * @param {Object=} effect Effect metadata object
     * @return {void}
     * @protected
     */
    _addPropertyEffect(s, o, n) {
      this._createPropertyAccessor(s, o == D.READ_ONLY);
      let a = jo(this, o, !0)[s];
      a || (a = this[o][s] = []), a.push(n);
    }
    /**
     * Removes the given property effect.
     *
     * @override
     * @param {string} property Property the effect was associated with
     * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
     * @param {Object=} effect Effect metadata object to remove
     * @return {void}
     */
    _removePropertyEffect(s, o, n) {
      let a = jo(this, o, !0)[s], l = a.indexOf(n);
      l >= 0 && a.splice(l, 1);
    }
    /**
     * Returns whether the current prototype/instance has a property effect
     * of a certain type.
     *
     * @override
     * @param {string} property Property name
     * @param {string=} type Effect type, from this.PROPERTY_EFFECT_TYPES
     * @return {boolean} True if the prototype/instance has an effect of this
     *     type
     * @protected
     */
    _hasPropertyEffect(s, o) {
      let n = this[o];
      return !!(n && n[s]);
    }
    /**
     * Returns whether the current prototype/instance has a "read only"
     * accessor for the given property.
     *
     * @override
     * @param {string} property Property name
     * @return {boolean} True if the prototype/instance has an effect of this
     *     type
     * @protected
     */
    _hasReadOnlyEffect(s) {
      return this._hasPropertyEffect(s, D.READ_ONLY);
    }
    /**
     * Returns whether the current prototype/instance has a "notify"
     * property effect for the given property.
     *
     * @override
     * @param {string} property Property name
     * @return {boolean} True if the prototype/instance has an effect of this
     *     type
     * @protected
     */
    _hasNotifyEffect(s) {
      return this._hasPropertyEffect(s, D.NOTIFY);
    }
    /**
     * Returns whether the current prototype/instance has a "reflect to
     * attribute" property effect for the given property.
     *
     * @override
     * @param {string} property Property name
     * @return {boolean} True if the prototype/instance has an effect of this
     *     type
     * @protected
     */
    _hasReflectEffect(s) {
      return this._hasPropertyEffect(s, D.REFLECT);
    }
    /**
     * Returns whether the current prototype/instance has a "computed"
     * property effect for the given property.
     *
     * @override
     * @param {string} property Property name
     * @return {boolean} True if the prototype/instance has an effect of this
     *     type
     * @protected
     */
    _hasComputedEffect(s) {
      return this._hasPropertyEffect(s, D.COMPUTE);
    }
    // Runtime ----------------------------------------
    /**
     * Sets a pending property or path.  If the root property of the path in
     * question had no accessor, the path is set, otherwise it is enqueued
     * via `_setPendingProperty`.
     *
     * This function isolates relatively expensive functionality necessary
     * for the public API (`set`, `setProperties`, `notifyPath`, and property
     * change listeners via {{...}} bindings), such that it is only done
     * when paths enter the system, and not at every propagation step.  It
     * also sets a `__dataHasPaths` flag on the instance which is used to
     * fast-path slower path-matching code in the property effects host paths.
     *
     * `path` can be a path string or array of path parts as accepted by the
     * public API.
     *
     * @override
     * @param {string | !Array<number|string>} path Path to set
     * @param {*} value Value to set
     * @param {boolean=} shouldNotify Set to true if this change should
     *  cause a property notification event dispatch
     * @param {boolean=} isPathNotification If the path being set is a path
     *   notification of an already changed value, as opposed to a request
     *   to set and notify the change.  In the latter `false` case, a dirty
     *   check is performed and then the value is set to the path before
     *   enqueuing the pending property change.
     * @return {boolean} Returns true if the property/path was enqueued in
     *   the pending changes bag.
     * @protected
     */
    _setPendingPropertyOrPath(s, o, n, a) {
      if (a || er(Array.isArray(s) ? s[0] : s) !== s) {
        if (!a) {
          let l = ae(this, s);
          if (s = /** @type {string} */
          cc(this, s, o), !s || !super._shouldPropertyChange(s, o, l))
            return !1;
        }
        if (this.__dataHasPaths = !0, this._setPendingProperty(
          /**@type{string}*/
          s,
          o,
          n
        ))
          return jb(
            this,
            /**@type{string}*/
            s,
            o
          ), !0;
      } else {
        if (this.__dataHasAccessor && this.__dataHasAccessor[s])
          return this._setPendingProperty(
            /**@type{string}*/
            s,
            o,
            n
          );
        this[s] = o;
      }
      return !1;
    }
    /**
     * Applies a value to a non-Polymer element/node's property.
     *
     * The implementation makes a best-effort at binding interop:
     * Some native element properties have side-effects when
     * re-setting the same value (e.g. setting `<input>.value` resets the
     * cursor position), so we do a dirty-check before setting the value.
     * However, for better interop with non-Polymer custom elements that
     * accept objects, we explicitly re-set object changes coming from the
     * Polymer world (which may include deep object changes without the
     * top reference changing), erring on the side of providing more
     * information.
     *
     * Users may override this method to provide alternate approaches.
     *
     * @override
     * @param {!Node} node The node to set a property on
     * @param {string} prop The property to set
     * @param {*} value The value to set
     * @return {void}
     * @protected
     */
    _setUnmanagedPropertyToNode(s, o, n) {
      (n !== s[o] || typeof n == "object") && (o === "className" && (s = /** @type {!Node} */
      B(s)), s[o] = n);
    }
    /**
     * Overrides the `PropertiesChanged` implementation to introduce special
     * dirty check logic depending on the property & value being set:
     *
     * 1. Any value set to a path (e.g. 'obj.prop': 42 or 'obj.prop': {...})
     *    Stored in `__dataTemp`, dirty checked against `__dataTemp`
     * 2. Object set to simple property (e.g. 'prop': {...})
     *    Stored in `__dataTemp` and `__data`, dirty checked against
     *    `__dataTemp` by default implementation of `_shouldPropertyChange`
     * 3. Primitive value set to simple property (e.g. 'prop': 42)
     *    Stored in `__data`, dirty checked against `__data`
     *
     * The dirty-check is important to prevent cycles due to two-way
     * notification, but paths and objects are only dirty checked against any
     * previous value set during this turn via a "temporary cache" that is
     * cleared when the last `_propertiesChanged` exits. This is so:
     * a. any cached array paths (e.g. 'array.3.prop') may be invalidated
     *    due to array mutations like shift/unshift/splice; this is fine
     *    since path changes are dirty-checked at user entry points like `set`
     * b. dirty-checking for objects only lasts one turn to allow the user
     *    to mutate the object in-place and re-set it with the same identity
     *    and have all sub-properties re-propagated in a subsequent turn.
     *
     * The temp cache is not necessarily sufficient to prevent invalid array
     * paths, since a splice can happen during the same turn (with pathological
     * user code); we could introduce a "fixup" for temporarily cached array
     * paths if needed: https://github.com/Polymer/polymer/issues/4227
     *
     * @override
     * @param {string} property Name of the property
     * @param {*} value Value to set
     * @param {boolean=} shouldNotify True if property should fire notification
     *   event (applies only for `notify: true` properties)
     * @return {boolean} Returns true if the property changed
     */
    _setPendingProperty(s, o, n) {
      let a = this.__dataHasPaths && zn(s), l = a ? this.__dataTemp : this.__data;
      return this._shouldPropertyChange(s, o, l[s]) ? (this.__dataPending || (this.__dataPending = {}, this.__dataOld = {}), s in this.__dataOld || (this.__dataOld[s] = this.__data[s]), a ? this.__dataTemp[s] = o : this.__data[s] = o, this.__dataPending[s] = o, (a || this[D.NOTIFY] && this[D.NOTIFY][s]) && (this.__dataToNotify = this.__dataToNotify || {}, this.__dataToNotify[s] = n), !0) : !1;
    }
    /**
     * Overrides base implementation to ensure all accessors set `shouldNotify`
     * to true, for per-property notification tracking.
     *
     * @override
     * @param {string} property Name of the property
     * @param {*} value Value to set
     * @return {void}
     */
    _setProperty(s, o) {
      this._setPendingProperty(s, o, !0) && this._invalidateProperties();
    }
    /**
     * Overrides `PropertyAccessor`'s default async queuing of
     * `_propertiesChanged`: if `__dataReady` is false (has not yet been
     * manually flushed), the function no-ops; otherwise flushes
     * `_propertiesChanged` synchronously.
     *
     * @override
     * @return {void}
     */
    _invalidateProperties() {
      this.__dataReady && this._flushProperties();
    }
    /**
     * Enqueues the given client on a list of pending clients, whose
     * pending property changes can later be flushed via a call to
     * `_flushClients`.
     *
     * @override
     * @param {Object} client PropertyEffects client to enqueue
     * @return {void}
     * @protected
     */
    _enqueueClient(s) {
      this.__dataPendingClients = this.__dataPendingClients || [], s !== this && this.__dataPendingClients.push(s);
    }
    /**
     * Flushes any clients previously enqueued via `_enqueueClient`, causing
     * their `_flushProperties` method to run.
     *
     * @override
     * @return {void}
     * @protected
     */
    _flushClients() {
      this.__dataClientsReady ? this.__enableOrFlushClients() : (this.__dataClientsReady = !0, this._readyClients(), this.__dataReady = !0);
    }
    // NOTE: We ensure clients either enable or flush as appropriate. This
    // handles two corner cases:
    // (1) clients flush properly when connected/enabled before the host
    // enables; e.g.
    //   (a) Templatize stamps with no properties and does not flush and
    //   (b) the instance is inserted into dom and
    //   (c) then the instance flushes.
    // (2) clients enable properly when not connected/enabled when the host
    // flushes; e.g.
    //   (a) a template is runtime stamped and not yet connected/enabled
    //   (b) a host sets a property, causing stamped dom to flush
    //   (c) the stamped dom enables.
    __enableOrFlushClients() {
      let s = this.__dataPendingClients;
      if (s) {
        this.__dataPendingClients = null;
        for (let o = 0; o < s.length; o++) {
          let n = s[o];
          n.__dataEnabled ? n.__dataPending && n._flushProperties() : n._enableProperties();
        }
      }
    }
    /**
     * Perform any initial setup on client dom. Called before the first
     * `_flushProperties` call on client dom and before any element
     * observers are called.
     *
     * @override
     * @return {void}
     * @protected
     */
    _readyClients() {
      this.__enableOrFlushClients();
    }
    /**
     * Sets a bag of property changes to this instance, and
     * synchronously processes all effects of the properties as a batch.
     *
     * Property names must be simple properties, not paths.  Batched
     * path propagation is not supported.
     *
     * @override
     * @param {Object} props Bag of one or more key-value pairs whose key is
     *   a property and value is the new value to set for that property.
     * @param {boolean=} setReadOnly When true, any private values set in
     *   `props` will be set. By default, `setProperties` will not set
     *   `readOnly: true` root properties.
     * @return {void}
     * @public
     */
    setProperties(s, o) {
      for (let n in s)
        (o || !this[D.READ_ONLY] || !this[D.READ_ONLY][n]) && this._setPendingPropertyOrPath(n, s[n], !0);
      this._invalidateProperties();
    }
    /**
     * Overrides `PropertyAccessors` so that property accessor
     * side effects are not enabled until after client dom is fully ready.
     * Also calls `_flushClients` callback to ensure client dom is enabled
     * that was not enabled as a result of flushing properties.
     *
     * @override
     * @return {void}
     */
    ready() {
      this._flushProperties(), this.__dataClientsReady || this._flushClients(), this.__dataPending && this._flushProperties();
    }
    /**
     * Implements `PropertyAccessors`'s properties changed callback.
     *
     * Runs each class of effects for the batch of changed properties in
     * a specific order (compute, propagate, reflect, observe, notify).
     *
     * @override
     * @param {!Object} currentProps Bag of all current accessor values
     * @param {?Object} changedProps Bag of properties changed since the last
     *   call to `_propertiesChanged`
     * @param {?Object} oldProps Bag of previous values for each property
     *   in `changedProps`
     * @return {void}
     */
    _propertiesChanged(s, o, n) {
      let a = this.__dataHasPaths;
      this.__dataHasPaths = !1;
      let l;
      Bb(this, o, n, a), l = this.__dataToNotify, this.__dataToNotify = null, this._propagatePropertyChanges(o, n, a), this._flushClients(), ni(this, this[D.REFLECT], o, n, a), ni(this, this[D.OBSERVE], o, n, a), l && Fb(this, l, o, n, a), this.__dataCounter == 1 && (this.__dataTemp = {});
    }
    /**
     * Called to propagate any property changes to stamped template nodes
     * managed by this element.
     *
     * @override
     * @param {Object} changedProps Bag of changed properties
     * @param {Object} oldProps Bag of previous values for changed properties
     * @param {boolean} hasPaths True with `props` contains one or more paths
     * @return {void}
     * @protected
     */
    _propagatePropertyChanges(s, o, n) {
      this[D.PROPAGATE] && ni(this, this[D.PROPAGATE], s, o, n), this.__templateInfo && this._runEffectsForTemplate(this.__templateInfo, s, o, n);
    }
    _runEffectsForTemplate(s, o, n, a) {
      const l = (c, d) => {
        ni(
          this,
          s.propertyEffects,
          c,
          n,
          d,
          s.nodeList
        );
        for (let u = s.firstChild; u; u = u.nextSibling)
          this._runEffectsForTemplate(u, c, n, d);
      };
      s.runEffects ? s.runEffects(l, o, a) : l(o, a);
    }
    /**
     * Aliases one data path as another, such that path notifications from one
     * are routed to the other.
     *
     * @override
     * @param {string | !Array<string|number>} to Target path to link.
     * @param {string | !Array<string|number>} from Source path to link.
     * @return {void}
     * @public
     */
    linkPaths(s, o) {
      s = oi(s), o = oi(o), this.__dataLinkedPaths = this.__dataLinkedPaths || {}, this.__dataLinkedPaths[s] = o;
    }
    /**
     * Removes a data path alias previously established with `_linkPaths`.
     *
     * Note, the path to unlink should be the target (`to`) used when
     * linking the paths.
     *
     * @override
     * @param {string | !Array<string|number>} path Target path to unlink.
     * @return {void}
     * @public
     */
    unlinkPaths(s) {
      s = oi(s), this.__dataLinkedPaths && delete this.__dataLinkedPaths[s];
    }
    /**
     * Notify that an array has changed.
     *
     * Example:
     *
     *     this.items = [ {name: 'Jim'}, {name: 'Todd'}, {name: 'Bill'} ];
     *     ...
     *     this.items.splice(1, 1, {name: 'Sam'});
     *     this.items.push({name: 'Bob'});
     *     this.notifySplices('items', [
     *       { index: 1, removed: [{name: 'Todd'}], addedCount: 1,
     *         object: this.items, type: 'splice' },
     *       { index: 3, removed: [], addedCount: 1,
     *         object: this.items, type: 'splice'}
     *     ]);
     *
     * @param {string} path Path that should be notified.
     * @param {Array} splices Array of splice records indicating ordered
     *   changes that occurred to the array. Each record should have the
     *   following fields:
     *    * index: index at which the change occurred
     *    * removed: array of items that were removed from this index
     *    * addedCount: number of new items added at this index
     *    * object: a reference to the array in question
     *    * type: the string literal 'splice'
     *
     *   Note that splice records _must_ be normalized such that they are
     *   reported in index order (raw results from `Object.observe` are not
     *   ordered and must be normalized/merged before notifying).
     *
     * @override
     * @return {void}
     * @public
     */
    notifySplices(s, o) {
      let n = { path: "" }, a = (
        /** @type {Array} */
        ae(this, s, n)
      );
      kh(this, a, n.path, o);
    }
    /**
     * Convenience method for reading a value from a path.
     *
     * Note, if any part in the path is undefined, this method returns
     * `undefined` (this method does not throw when dereferencing undefined
     * paths).
     *
     * @override
     * @param {(string|!Array<(string|number)>)} path Path to the value
     *   to read.  The path may be specified as a string (e.g. `foo.bar.baz`)
     *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that
     *   bracketed expressions are not supported; string-based path parts
     *   *must* be separated by dots.  Note that when dereferencing array
     *   indices, the index may be used as a dotted part directly
     *   (e.g. `users.12.name` or `['users', 12, 'name']`).
     * @param {Object=} root Root object from which the path is evaluated.
     * @return {*} Value at the path, or `undefined` if any part of the path
     *   is undefined.
     * @public
     */
    get(s, o) {
      return ae(o || this, s);
    }
    /**
     * Convenience method for setting a value to a path and notifying any
     * elements bound to the same path.
     *
     * Note, if any part in the path except for the last is undefined,
     * this method does nothing (this method does not throw when
     * dereferencing undefined paths).
     *
     * @override
     * @param {(string|!Array<(string|number)>)} path Path to the value
     *   to write.  The path may be specified as a string (e.g. `'foo.bar.baz'`)
     *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that
     *   bracketed expressions are not supported; string-based path parts
     *   *must* be separated by dots.  Note that when dereferencing array
     *   indices, the index may be used as a dotted part directly
     *   (e.g. `'users.12.name'` or `['users', 12, 'name']`).
     * @param {*} value Value to set at the specified path.
     * @param {Object=} root Root object from which the path is evaluated.
     *   When specified, no notification will occur.
     * @return {void}
     * @public
     */
    set(s, o, n) {
      n ? cc(n, s, o) : (!this[D.READ_ONLY] || !this[D.READ_ONLY][
        /** @type {string} */
        s
      ]) && this._setPendingPropertyOrPath(s, o, !0) && this._invalidateProperties();
    }
    /**
     * Adds items onto the end of the array at the path specified.
     *
     * The arguments after `path` and return value match that of
     * `Array.prototype.push`.
     *
     * This method notifies other paths to the same array that a
     * splice occurred to the array.
     *
     * @override
     * @param {string | !Array<string|number>} path Path to array.
     * @param {...*} items Items to push onto array
     * @return {number} New length of the array.
     * @public
     */
    push(s, ...o) {
      let n = { path: "" }, a = (
        /** @type {Array}*/
        ae(this, s, n)
      ), l = a.length, c = a.push(...o);
      return o.length && Yr(this, a, n.path, l, o.length, []), c;
    }
    /**
     * Removes an item from the end of array at the path specified.
     *
     * The arguments after `path` and return value match that of
     * `Array.prototype.pop`.
     *
     * This method notifies other paths to the same array that a
     * splice occurred to the array.
     *
     * @override
     * @param {string | !Array<string|number>} path Path to array.
     * @return {*} Item that was removed.
     * @public
     */
    pop(s) {
      let o = { path: "" }, n = (
        /** @type {Array} */
        ae(this, s, o)
      ), a = !!n.length, l = n.pop();
      return a && Yr(this, n, o.path, n.length, 0, [l]), l;
    }
    /**
     * Starting from the start index specified, removes 0 or more items
     * from the array and inserts 0 or more new items in their place.
     *
     * The arguments after `path` and return value match that of
     * `Array.prototype.splice`.
     *
     * This method notifies other paths to the same array that a
     * splice occurred to the array.
     *
     * @override
     * @param {string | !Array<string|number>} path Path to array.
     * @param {number} start Index from which to start removing/inserting.
     * @param {number=} deleteCount Number of items to remove.
     * @param {...*} items Items to insert into array.
     * @return {!Array} Array of removed items.
     * @public
     */
    splice(s, o, n, ...a) {
      let l = { path: "" }, c = (
        /** @type {Array} */
        ae(this, s, l)
      );
      o < 0 ? o = c.length - Math.floor(-o) : o && (o = Math.floor(o));
      let d;
      return arguments.length === 2 ? d = c.splice(o) : d = c.splice(o, n, ...a), (a.length || d.length) && Yr(this, c, l.path, o, a.length, d), d;
    }
    /**
     * Removes an item from the beginning of array at the path specified.
     *
     * The arguments after `path` and return value match that of
     * `Array.prototype.pop`.
     *
     * This method notifies other paths to the same array that a
     * splice occurred to the array.
     *
     * @override
     * @param {string | !Array<string|number>} path Path to array.
     * @return {*} Item that was removed.
     * @public
     */
    shift(s) {
      let o = { path: "" }, n = (
        /** @type {Array} */
        ae(this, s, o)
      ), a = !!n.length, l = n.shift();
      return a && Yr(this, n, o.path, 0, 0, [l]), l;
    }
    /**
     * Adds items onto the beginning of the array at the path specified.
     *
     * The arguments after `path` and return value match that of
     * `Array.prototype.push`.
     *
     * This method notifies other paths to the same array that a
     * splice occurred to the array.
     *
     * @override
     * @param {string | !Array<string|number>} path Path to array.
     * @param {...*} items Items to insert info array
     * @return {number} New length of the array.
     * @public
     */
    unshift(s, ...o) {
      let n = { path: "" }, a = (
        /** @type {Array} */
        ae(this, s, n)
      ), l = a.unshift(...o);
      return o.length && Yr(this, a, n.path, 0, o.length, []), l;
    }
    /**
     * Notify that a path has changed.
     *
     * Example:
     *
     *     this.item.user.name = 'Bob';
     *     this.notifyPath('item.user.name');
     *
     * @override
     * @param {string} path Path that should be notified.
     * @param {*=} value Value at the path (optional).
     * @return {void}
     * @public
     */
    notifyPath(s, o) {
      let n;
      if (arguments.length == 1) {
        let a = { path: "" };
        o = ae(this, s, a), n = a.path;
      } else
        Array.isArray(s) ? n = oi(s) : n = /** @type{string} */
        s;
      this._setPendingPropertyOrPath(n, o, !0, !0) && this._invalidateProperties();
    }
    /**
     * Equivalent to static `createReadOnlyProperty` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @override
     * @param {string} property Property name
     * @param {boolean=} protectedSetter Creates a custom protected setter
     *   when `true`.
     * @return {void}
     * @protected
     */
    _createReadOnlyProperty(s, o) {
      this._addPropertyEffect(s, D.READ_ONLY), o && (this["_set" + py(s)] = /** @this {PropertyEffects} */
      function(n) {
        this._setProperty(s, n);
      });
    }
    /**
     * Equivalent to static `createPropertyObserver` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @override
     * @param {string} property Property name
     * @param {string|function(*,*)} method Function or name of observer method
     *     to call
     * @param {boolean=} dynamicFn Whether the method name should be included as
     *   a dependency to the effect.
     * @return {void}
     * @protected
     */
    _createPropertyObserver(s, o, n) {
      let a = { property: s, method: o, dynamicFn: !!n };
      this._addPropertyEffect(s, D.OBSERVE, {
        fn: hc,
        info: a,
        trigger: { name: s }
      }), n && this._addPropertyEffect(
        /** @type {string} */
        o,
        D.OBSERVE,
        {
          fn: hc,
          info: a,
          trigger: { name: o }
        }
      );
    }
    /**
     * Equivalent to static `createMethodObserver` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @override
     * @param {string} expression Method expression
     * @param {boolean|Object=} dynamicFn Boolean or object map indicating
     *   whether method names should be included as a dependency to the effect.
     * @return {void}
     * @protected
     */
    _createMethodObserver(s, o) {
      let n = Yo(s);
      if (!n)
        throw new Error("Malformed observer expression '" + s + "'");
      pc(this, n, D.OBSERVE, Fn, null, o);
    }
    /**
     * Equivalent to static `createNotifyingProperty` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @override
     * @param {string} property Property name
     * @return {void}
     * @protected
     */
    _createNotifyingProperty(s) {
      this._addPropertyEffect(s, D.NOTIFY, {
        fn: Lb,
        info: {
          eventName: lo(s) + "-changed",
          property: s
        }
      });
    }
    /**
     * Equivalent to static `createReflectedProperty` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @override
     * @param {string} property Property name
     * @return {void}
     * @protected
     * @suppress {missingProperties} go/missingfnprops
     */
    _createReflectedProperty(s) {
      let o = this.constructor.attributeNameForProperty(s);
      o[0] === "-" || this._addPropertyEffect(s, D.REFLECT, {
        fn: Hb,
        info: {
          attrName: o
        }
      });
    }
    /**
     * Equivalent to static `createComputedProperty` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @override
     * @param {string} property Name of computed property to set
     * @param {string} expression Method expression
     * @param {boolean|Object=} dynamicFn Boolean or object map indicating
     *   whether method names should be included as a dependency to the effect.
     * @return {void}
     * @protected
     */
    _createComputedProperty(s, o, n) {
      let a = Yo(o);
      if (!a)
        throw new Error("Malformed computed expression '" + o + "'");
      const l = pc(this, a, D.COMPUTE, wh, s, n);
      jo(this, yh)[s] = l;
    }
    /**
     * Gather the argument values for a method specified in the provided array
     * of argument metadata.
     *
     * The `path` and `value` arguments are used to fill in wildcard descriptor
     * when the method is being called as a result of a path notification.
     *
     * @param {!Array<!MethodArg>} args Array of argument metadata
     * @param {string} path Property/path name that triggered the method effect
     * @param {Object} props Bag of current property changes
     * @return {!Array<*>} Array of argument values
     * @private
     */
    _marshalArgs(s, o, n) {
      const a = this.__data, l = [];
      for (let c = 0, d = s.length; c < d; c++) {
        let { name: u, structured: h, wildcard: f, value: m, literal: v } = s[c];
        if (!v)
          if (f) {
            const k = ki(u, o), M = bc(a, n, k ? o : u);
            m = {
              path: k ? o : u,
              value: M,
              base: k ? ae(a, u) : M
            };
          } else
            m = h ? bc(a, n, u) : a[u];
        if (Mn && !this._overrideLegacyUndefined && m === void 0 && s.length > 1)
          return Si;
        l[c] = m;
      }
      return l;
    }
    // -- static class methods ------------
    /**
     * Ensures an accessor exists for the specified property, and adds
     * to a list of "property effects" that will run when the accessor for
     * the specified property is set.  Effects are grouped by "type", which
     * roughly corresponds to a phase in effect processing.  The effect
     * metadata should be in the following form:
     *
     *     {
     *       fn: effectFunction, // Reference to function to call to perform effect
     *       info: { ... }       // Effect metadata passed to function
     *       trigger: {          // Optional triggering metadata; if not provided
     *         name: string      // the property is treated as a wildcard
     *         structured: boolean
     *         wildcard: boolean
     *       }
     *     }
     *
     * Effects are called from `_propertiesChanged` in the following order by
     * type:
     *
     * 1. COMPUTE
     * 2. PROPAGATE
     * 3. REFLECT
     * 4. OBSERVE
     * 5. NOTIFY
     *
     * Effect functions are called with the following signature:
     *
     *     effectFunction(inst, path, props, oldProps, info, hasPaths)
     *
     * @param {string} property Property that should trigger the effect
     * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
     * @param {Object=} effect Effect metadata object
     * @return {void}
     * @protected
     * @nocollapse
     */
    static addPropertyEffect(s, o, n) {
      this.prototype._addPropertyEffect(s, o, n);
    }
    /**
     * Creates a single-property observer for the given property.
     *
     * @param {string} property Property name
     * @param {string|function(*,*)} method Function or name of observer method to call
     * @param {boolean=} dynamicFn Whether the method name should be included as
     *   a dependency to the effect.
     * @return {void}
     * @protected
     * @nocollapse
     */
    static createPropertyObserver(s, o, n) {
      this.prototype._createPropertyObserver(s, o, n);
    }
    /**
     * Creates a multi-property "method observer" based on the provided
     * expression, which should be a string in the form of a normal JavaScript
     * function signature: `'methodName(arg1, [..., argn])'`.  Each argument
     * should correspond to a property or path in the context of this
     * prototype (or instance), or may be a literal string or number.
     *
     * @param {string} expression Method expression
     * @param {boolean|Object=} dynamicFn Boolean or object map indicating
     * @return {void}
     *   whether method names should be included as a dependency to the effect.
     * @protected
     * @nocollapse
     */
    static createMethodObserver(s, o) {
      this.prototype._createMethodObserver(s, o);
    }
    /**
     * Causes the setter for the given property to dispatch `<property>-changed`
     * events to notify of changes to the property.
     *
     * @param {string} property Property name
     * @return {void}
     * @protected
     * @nocollapse
     */
    static createNotifyingProperty(s) {
      this.prototype._createNotifyingProperty(s);
    }
    /**
     * Creates a read-only accessor for the given property.
     *
     * To set the property, use the protected `_setProperty` API.
     * To create a custom protected setter (e.g. `_setMyProp()` for
     * property `myProp`), pass `true` for `protectedSetter`.
     *
     * Note, if the property will have other property effects, this method
     * should be called first, before adding other effects.
     *
     * @param {string} property Property name
     * @param {boolean=} protectedSetter Creates a custom protected setter
     *   when `true`.
     * @return {void}
     * @protected
     * @nocollapse
     */
    static createReadOnlyProperty(s, o) {
      this.prototype._createReadOnlyProperty(s, o);
    }
    /**
     * Causes the setter for the given property to reflect the property value
     * to a (dash-cased) attribute of the same name.
     *
     * @param {string} property Property name
     * @return {void}
     * @protected
     * @nocollapse
     */
    static createReflectedProperty(s) {
      this.prototype._createReflectedProperty(s);
    }
    /**
     * Creates a computed property whose value is set to the result of the
     * method described by the given `expression` each time one or more
     * arguments to the method changes.  The expression should be a string
     * in the form of a normal JavaScript function signature:
     * `'methodName(arg1, [..., argn])'`
     *
     * @param {string} property Name of computed property to set
     * @param {string} expression Method expression
     * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether
     *   method names should be included as a dependency to the effect.
     * @return {void}
     * @protected
     * @nocollapse
     */
    static createComputedProperty(s, o, n) {
      this.prototype._createComputedProperty(s, o, n);
    }
    /**
     * Parses the provided template to ensure binding effects are created
     * for them, and then ensures property accessors are created for any
     * dependent properties in the template.  Binding effects for bound
     * templates are stored in a linked list on the instance so that
     * templates can be efficiently stamped and unstamped.
     *
     * @param {!HTMLTemplateElement} template Template containing binding
     *   bindings
     * @return {!TemplateInfo} Template metadata object
     * @protected
     * @nocollapse
     */
    static bindTemplate(s) {
      return this.prototype._bindTemplate(s);
    }
    // -- binding ----------------------------------------------
    /*
     * Overview of binding flow:
     *
     * During finalization (`instanceBinding==false`, `wasPreBound==false`):
     *  `_bindTemplate(t, false)` called directly during finalization - parses
     *  the template (for the first time), and then assigns that _prototypical_
     *  template info to `__preboundTemplateInfo` _on the prototype_; note in
     *  this case `wasPreBound` is false; this is the first time we're binding
     *  it, thus we create accessors.
     *
     * During first stamping (`instanceBinding==true`, `wasPreBound==true`):
     *   `_stampTemplate` calls `_bindTemplate(t, true)`: the `templateInfo`
     *   returned matches the prebound one, and so this is `wasPreBound == true`
     *   state; thus we _skip_ creating accessors, but _do_ create an instance
     *   of the template info to serve as the start of our linked list (needs to
     *   be an instance, not the prototypical one, so that we can add `nodeList`
     *   to it to contain the `nodeInfo`-ordered list of instance nodes for
     *   bindings, and so we can chain runtime-stamped template infos off of
     *   it). At this point, the call to `_stampTemplate` calls
     *   `applyTemplateInfo` for each nested `<template>` found during parsing
     *   to hand prototypical `_templateInfo` to them; we also pass the _parent_
     *   `templateInfo` to the `<template>` so that we have the instance-time
     *   parent to link the `templateInfo` under in the case it was
     *   runtime-stamped.
     *
     * During subsequent runtime stamping (`instanceBinding==true`,
     *   `wasPreBound==false`): `_stampTemplate` calls `_bindTemplate(t, true)`
     *   - here `templateInfo` is guaranteed to _not_ match the prebound one,
     *   because it was either a different template altogether, or even if it
     *   was the same template, the step above created a instance of the info;
     *   in this case `wasPreBound == false`, so we _do_ create accessors, _and_
     *   link a instance into the linked list.
     */
    /**
     * Equivalent to static `bindTemplate` API but can be called on an instance
     * to add effects at runtime.  See that method for full API docs.
     *
     * This method may be called on the prototype (for prototypical template
     * binding, to avoid creating accessors every instance) once per prototype,
     * and will be called with `runtimeBinding: true` by `_stampTemplate` to
     * create and link an instance of the template metadata associated with a
     * particular stamping.
     *
     * @override
     * @param {!HTMLTemplateElement} template Template containing binding
     * bindings
     * @param {boolean=} instanceBinding When false (default), performs
     * "prototypical" binding of the template and overwrites any previously
     * bound template for the class. When true (as passed from
     * `_stampTemplate`), the template info is instanced and linked into the
     * list of bound templates.
     * @return {!TemplateInfo} Template metadata object; for `runtimeBinding`,
     * this is an instance of the prototypical template info
     * @protected
     * @suppress {missingProperties} go/missingfnprops
     */
    _bindTemplate(s, o) {
      let n = this.constructor._parseTemplate(s), a = this.__preBoundTemplateInfo == n;
      if (!a)
        for (let l in n.propertyEffects)
          this._createPropertyAccessor(l);
      if (o)
        if (n = /** @type {!TemplateInfo} */
        Object.create(n), n.wasPreBound = a, !this.__templateInfo)
          this.__templateInfo = n;
        else {
          const l = s._parentTemplateInfo || this.__templateInfo, c = l.lastChild;
          n.parent = l, l.lastChild = n, n.previousSibling = c, c ? c.nextSibling = n : l.firstChild = n;
        }
      else
        this.__preBoundTemplateInfo = n;
      return n;
    }
    /**
     * Adds a property effect to the given template metadata, which is run
     * at the "propagate" stage of `_propertiesChanged` when the template
     * has been bound to the element via `_bindTemplate`.
     *
     * The `effect` object should match the format in `_addPropertyEffect`.
     *
     * @param {Object} templateInfo Template metadata to add effect to
     * @param {string} prop Property that should trigger the effect
     * @param {Object=} effect Effect metadata object
     * @return {void}
     * @protected
     * @nocollapse
     */
    static _addTemplatePropertyEffect(s, o, n) {
      let a = s.hostProps = s.hostProps || {};
      a[o] = !0;
      let l = s.propertyEffects = s.propertyEffects || {};
      (l[o] = l[o] || []).push(n);
    }
    /**
     * Stamps the provided template and performs instance-time setup for
     * Polymer template features, including data bindings, declarative event
     * listeners, and the `this.$` map of `id`'s to nodes.  A document fragment
     * is returned containing the stamped DOM, ready for insertion into the
     * DOM.
     *
     * This method may be called more than once; however note that due to
     * `shadycss` polyfill limitations, only styles from templates prepared
     * using `ShadyCSS.prepareTemplate` will be correctly polyfilled (scoped
     * to the shadow root and support CSS custom properties), and note that
     * `ShadyCSS.prepareTemplate` may only be called once per element. As such,
     * any styles required by in runtime-stamped templates must be included
     * in the main element template.
     *
     * @param {!HTMLTemplateElement} template Template to stamp
     * @param {TemplateInfo=} templateInfo Optional bound template info associated
     *   with the template to be stamped; if omitted the template will be
     *   automatically bound.
     * @return {!StampedTemplate} Cloned template content
     * @override
     * @protected
     */
    _stampTemplate(s, o) {
      o = o || /** @type {!TemplateInfo} */
      this._bindTemplate(s, !0), Zr.push(this);
      let n = super._stampTemplate(s, o);
      if (Zr.pop(), o.nodeList = n.nodeList, !o.wasPreBound) {
        let a = o.childNodes = [];
        for (let l = n.firstChild; l; l = l.nextSibling)
          a.push(l);
      }
      return n.templateInfo = o, Jb(this, o), this.__dataClientsReady && (this._runEffectsForTemplate(o, this.__data, null, !1), this._flushClients()), n;
    }
    /**
     * Removes and unbinds the nodes previously contained in the provided
     * DocumentFragment returned from `_stampTemplate`.
     *
     * @override
     * @param {!StampedTemplate} dom DocumentFragment previously returned
     *   from `_stampTemplate` associated with the nodes to be removed
     * @return {void}
     * @protected
     */
    _removeBoundDom(s) {
      const o = s.templateInfo, { previousSibling: n, nextSibling: a, parent: l } = o;
      n ? n.nextSibling = a : l && (l.firstChild = a), a ? a.previousSibling = n : l && (l.lastChild = n), o.nextSibling = o.previousSibling = null;
      let c = o.childNodes;
      for (let d = 0; d < c.length; d++) {
        let u = c[d];
        B(B(u).parentNode).removeChild(u);
      }
    }
    /**
     * Overrides default `TemplateStamp` implementation to add support for
     * parsing bindings from `TextNode`'s' `textContent`.  A `bindings`
     * array is added to `nodeInfo` and populated with binding metadata
     * with information capturing the binding target, and a `parts` array
     * with one or more metadata objects capturing the source(s) of the
     * binding.
     *
     * @param {Node} node Node to parse
     * @param {TemplateInfo} templateInfo Template metadata for current template
     * @param {NodeInfo} nodeInfo Node metadata for current template node
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     * @protected
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     * @nocollapse
     */
    static _parseTemplateNode(s, o, n) {
      let a = e._parseTemplateNode.call(
        this,
        s,
        o,
        n
      );
      if (s.nodeType === Node.TEXT_NODE) {
        let l = this._parseBindings(s.textContent, o);
        l && (s.textContent = _c(l) || " ", Go(this, o, n, "text", "textContent", l), a = !0);
      }
      return a;
    }
    /**
     * Overrides default `TemplateStamp` implementation to add support for
     * parsing bindings from attributes.  A `bindings`
     * array is added to `nodeInfo` and populated with binding metadata
     * with information capturing the binding target, and a `parts` array
     * with one or more metadata objects capturing the source(s) of the
     * binding.
     *
     * @param {Element} node Node to parse
     * @param {TemplateInfo} templateInfo Template metadata for current template
     * @param {NodeInfo} nodeInfo Node metadata for current template node
     * @param {string} name Attribute name
     * @param {string} value Attribute value
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     * @protected
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     * @nocollapse
     */
    static _parseTemplateNodeAttribute(s, o, n, a, l) {
      let c = this._parseBindings(l, o);
      if (c) {
        let d = a, u = "property";
        zb.test(a) ? u = "attribute" : a[a.length - 1] == "$" && (a = a.slice(0, -1), u = "attribute");
        let h = _c(c);
        return h && u == "attribute" && (a == "class" && s.hasAttribute("class") && (h += " " + s.getAttribute(a)), s.setAttribute(a, h)), u == "attribute" && d == "disable-upgrade$" && s.setAttribute(a, ""), s.localName === "input" && d === "value" && s.setAttribute(d, ""), s.removeAttribute(d), u === "property" && (a = fh(a)), Go(this, o, n, u, a, c, h), !0;
      } else
        return e._parseTemplateNodeAttribute.call(
          this,
          s,
          o,
          n,
          a,
          l
        );
    }
    /**
     * Overrides default `TemplateStamp` implementation to add support for
     * binding the properties that a nested template depends on to the template
     * as `_host_<property>`.
     *
     * @param {Node} node Node to parse
     * @param {TemplateInfo} templateInfo Template metadata for current template
     * @param {NodeInfo} nodeInfo Node metadata for current template node
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     * @protected
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     * @nocollapse
     */
    static _parseTemplateNestedTemplate(s, o, n) {
      let a = e._parseTemplateNestedTemplate.call(
        this,
        s,
        o,
        n
      );
      const l = s.parentNode, c = n.templateInfo, d = l.localName === "dom-if", u = l.localName === "dom-repeat";
      ic && (d || u) && (l.removeChild(s), n = n.parentInfo, n.templateInfo = c, n.noted = !0, a = !1);
      let h = c.hostProps;
      if (ob && d)
        h && (o.hostProps = Object.assign(o.hostProps || {}, h), ic || (n.parentInfo.noted = !0));
      else {
        let f = "{";
        for (let m in h) {
          let v = [{ mode: f, source: m, dependencies: [m], hostProp: !0 }];
          Go(this, o, n, "property", "_host_" + m, v);
        }
      }
      return a;
    }
    /**
     * Called to parse text in a template (either attribute values or
     * textContent) into binding metadata.
     *
     * Any overrides of this method should return an array of binding part
     * metadata  representing one or more bindings found in the provided text
     * and any "literal" text in between.  Any non-literal parts will be passed
     * to `_evaluateBinding` when any dependencies change.  The only required
     * fields of each "part" in the returned array are as follows:
     *
     * - `dependencies` - Array containing trigger metadata for each property
     *   that should trigger the binding to update
     * - `literal` - String containing text if the part represents a literal;
     *   in this case no `dependencies` are needed
     *
     * Additional metadata for use by `_evaluateBinding` may be provided in
     * each part object as needed.
     *
     * The default implementation handles the following types of bindings
     * (one or more may be intermixed with literal strings):
     * - Property binding: `[[prop]]`
     * - Path binding: `[[object.prop]]`
     * - Negated property or path bindings: `[[!prop]]` or `[[!object.prop]]`
     * - Two-way property or path bindings (supports negation):
     *   `{{prop}}`, `{{object.prop}}`, `{{!prop}}` or `{{!object.prop}}`
     * - Inline computed method (supports negation):
     *   `[[compute(a, 'literal', b)]]`, `[[!compute(a, 'literal', b)]]`
     *
     * The default implementation uses a regular expression for best
     * performance. However, the regular expression uses a white-list of
     * allowed characters in a data-binding, which causes problems for
     * data-bindings that do use characters not in this white-list.
     *
     * Instead of updating the white-list with all allowed characters,
     * there is a StrictBindingParser (see lib/mixins/strict-binding-parser)
     * that uses a state machine instead. This state machine is able to handle
     * all characters. However, it is slightly less performant, therefore we
     * extracted it into a separate optional mixin.
     *
     * @param {string} text Text to parse from attribute or textContent
     * @param {Object} templateInfo Current template metadata
     * @return {Array<!BindingPart>} Array of binding part metadata
     * @protected
     * @nocollapse
     */
    static _parseBindings(s, o) {
      let n = [], a = 0, l;
      for (; (l = gc.exec(s)) !== null; ) {
        l.index > a && n.push({ literal: s.slice(a, l.index) });
        let c = l[1][0], d = !!l[2], u = l[3].trim(), h = !1, f = "", m = -1;
        c == "{" && (m = u.indexOf("::")) > 0 && (f = u.substring(m + 2), u = u.substring(0, m), h = !0);
        let v = Yo(u), k = [];
        if (v) {
          let { args: M, methodName: F } = v;
          for (let he = 0; he < M.length; he++) {
            let j = M[he];
            j.literal || k.push(j);
          }
          let se = o.dynamicFns;
          (se && se[F] || v.static) && (k.push(F), v.dynamicFn = !0);
        } else
          k.push(u);
        n.push({
          source: u,
          mode: c,
          negate: d,
          customEvent: h,
          signature: v,
          dependencies: k,
          event: f
        }), a = gc.lastIndex;
      }
      if (a && a < s.length) {
        let c = s.substring(a);
        c && n.push({
          literal: c
        });
      }
      return n.length ? n : null;
    }
    /**
     * Called to evaluate a previously parsed binding part based on a set of
     * one or more changed dependencies.
     *
     * @param {!Polymer_PropertyEffects} inst Element that should be used as
     *     scope for binding dependencies
     * @param {BindingPart} part Binding part metadata
     * @param {string} path Property/path that triggered this effect
     * @param {Object} props Bag of current property changes
     * @param {Object} oldProps Bag of previous values for changed properties
     * @param {boolean} hasPaths True with `props` contains one or more paths
     * @return {*} Value the binding part evaluated to
     * @protected
     * @nocollapse
     */
    static _evaluateBinding(s, o, n, a, l, c) {
      let d;
      return o.signature ? d = Fn(s, n, a, l, o.signature) : n != o.source ? d = ae(s, o.source) : c && zn(n) ? d = ae(s, n) : d = s.__data[n], o.negate && (d = !d), d;
    }
  }
  return t;
}), Zr = [];
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
function my(i) {
  const e = {};
  for (let t in i) {
    const r = i[t];
    e[t] = typeof r == "function" ? { type: r } : r;
  }
  return e;
}
const gy = Y((i) => {
  const e = gh(i);
  function t(o) {
    const n = Object.getPrototypeOf(o);
    return n.prototype instanceof s ? (
      /** @type {!PropertiesMixinConstructor} */
      n
    ) : null;
  }
  function r(o) {
    if (!o.hasOwnProperty(JSCompiler_renameProperty("__ownProperties", o))) {
      let n = null;
      if (o.hasOwnProperty(JSCompiler_renameProperty("properties", o))) {
        const a = o.properties;
        a && (n = my(a));
      }
      o.__ownProperties = n;
    }
    return o.__ownProperties;
  }
  class s extends e {
    /**
     * Implements standard custom elements getter to observes the attributes
     * listed in `properties`.
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     * @nocollapse
     */
    static get observedAttributes() {
      if (!this.hasOwnProperty(JSCompiler_renameProperty("__observedAttributes", this))) {
        this.prototype;
        const n = this._properties;
        this.__observedAttributes = n ? Object.keys(n).map((a) => this.prototype._addPropertyToAttributeMap(a)) : [];
      }
      return this.__observedAttributes;
    }
    /**
     * Finalizes an element definition, including ensuring any super classes
     * are also finalized. This includes ensuring property
     * accessors exist on the element prototype. This method calls
     * `_finalizeClass` to finalize each constructor in the prototype chain.
     * @return {void}
     * @nocollapse
     */
    static finalize() {
      if (!this.hasOwnProperty(JSCompiler_renameProperty("__finalized", this))) {
        const n = t(
          /** @type {!PropertiesMixinConstructor} */
          this
        );
        n && n.finalize(), this.__finalized = !0, this._finalizeClass();
      }
    }
    /**
     * Finalize an element class. This includes ensuring property
     * accessors exist on the element prototype. This method is called by
     * `finalize` and finalizes the class constructor.
     *
     * @protected
     * @nocollapse
     */
    static _finalizeClass() {
      const n = r(
        /** @type {!PropertiesMixinConstructor} */
        this
      );
      n && this.createProperties(n);
    }
    /**
     * Returns a memoized version of all properties, including those inherited
     * from super classes. Properties not in object format are converted to
     * at least {type}.
     *
     * @return {Object} Object containing properties for this class
     * @protected
     * @nocollapse
     */
    static get _properties() {
      if (!this.hasOwnProperty(
        JSCompiler_renameProperty("__properties", this)
      )) {
        const n = t(
          /** @type {!PropertiesMixinConstructor} */
          this
        );
        this.__properties = Object.assign(
          {},
          n && n._properties,
          r(
            /** @type {PropertiesMixinConstructor} */
            this
          )
        );
      }
      return this.__properties;
    }
    /**
     * Overrides `PropertiesChanged` method to return type specified in the
     * static `properties` object for the given property.
     * @param {string} name Name of property
     * @return {*} Type to which to deserialize attribute
     *
     * @protected
     * @nocollapse
     */
    static typeForProperty(n) {
      const a = this._properties[n];
      return a && a.type;
    }
    /**
     * Overrides `PropertiesChanged` method and adds a call to
     * `finalize` which lazily configures the element's property accessors.
     * @override
     * @return {void}
     */
    _initializeProperties() {
      this.constructor.finalize(), super._initializeProperties();
    }
    /**
     * Called when the element is added to a document.
     * Calls `_enableProperties` to turn on property system from
     * `PropertiesChanged`.
     * @suppress {missingProperties} Super may or may not implement the callback
     * @return {void}
     * @override
     */
    connectedCallback() {
      super.connectedCallback && super.connectedCallback(), this._enableProperties();
    }
    /**
     * Called when the element is removed from a document
     * @suppress {missingProperties} Super may or may not implement the callback
     * @return {void}
     * @override
     */
    disconnectedCallback() {
      super.disconnectedCallback && super.disconnectedCallback();
    }
  }
  return s;
});
/**
 * @fileoverview
 * @suppress {checkPrototypalTypes}
 * @license Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt The complete set of authors may be found
 * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may
 * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by
 * Google as part of the polymer project is also subject to an additional IP
 * rights grant found at http://polymer.github.io/PATENTS.txt
 */
const _y = "3.5.1", yc = window.ShadyCSS && window.ShadyCSS.cssBuild, by = Y((i) => {
  const e = gy(Sa(i));
  function t(l) {
    if (!l.hasOwnProperty(
      JSCompiler_renameProperty("__propertyDefaults", l)
    )) {
      l.__propertyDefaults = null;
      let c = l._properties;
      for (let d in c) {
        let u = c[d];
        "value" in u && (l.__propertyDefaults = l.__propertyDefaults || {}, l.__propertyDefaults[d] = u);
      }
    }
    return l.__propertyDefaults;
  }
  function r(l) {
    return l.hasOwnProperty(
      JSCompiler_renameProperty("__ownObservers", l)
    ) || (l.__ownObservers = l.hasOwnProperty(
      JSCompiler_renameProperty("observers", l)
    ) ? (
      /** @type {PolymerElementConstructor} */
      l.observers
    ) : null), l.__ownObservers;
  }
  function s(l, c, d, u) {
    d.computed && (d.readOnly = !0), d.computed && (l._hasReadOnlyEffect(c) || l._createComputedProperty(c, d.computed, u)), d.readOnly && !l._hasReadOnlyEffect(c) ? l._createReadOnlyProperty(c, !d.computed) : d.readOnly === !1 && l._hasReadOnlyEffect(c), d.reflectToAttribute && !l._hasReflectEffect(c) ? l._createReflectedProperty(c) : d.reflectToAttribute === !1 && l._hasReflectEffect(c), d.notify && !l._hasNotifyEffect(c) ? l._createNotifyingProperty(c) : d.notify === !1 && l._hasNotifyEffect(c), d.observer && l._createPropertyObserver(c, d.observer, u[d.observer]), l._addPropertyToAttributeMap(c);
  }
  function o(l, c, d, u) {
    if (!yc) {
      const h = c.content.querySelectorAll("style"), f = ch(c), m = fb(d), v = c.content.firstElementChild;
      for (let M = 0; M < m.length; M++) {
        let F = m[M];
        F.textContent = l._processStyleText(F.textContent, u), c.content.insertBefore(F, v);
      }
      let k = 0;
      for (let M = 0; M < f.length; M++) {
        let F = f[M], se = h[k];
        se !== F ? (F = F.cloneNode(!0), se.parentNode.insertBefore(F, se)) : k++, F.textContent = l._processStyleText(F.textContent, u);
      }
    }
    if (window.ShadyCSS && window.ShadyCSS.prepareTemplate(c, d), nb && yc && eb) {
      const h = c.content.querySelectorAll("style");
      if (h) {
        let f = "";
        Array.from(h).forEach((m) => {
          f += m.textContent, m.parentNode.removeChild(m);
        }), l._styleSheet = new CSSStyleSheet(), l._styleSheet.replaceSync(f);
      }
    }
  }
  function n(l) {
    let c = null;
    if (l && (!Fs || rb) && (c = /** @type {?HTMLTemplateElement} */
    Ci.import(l, "template"), Fs && !c))
      throw new Error(`strictTemplatePolicy: expecting dom-module or null template for ${l}`);
    return c;
  }
  class a extends e {
    /**
     * Current Polymer version in Semver notation.
     * @type {string} Semver notation of the current version of Polymer.
     * @nocollapse
     */
    static get polymerElementVersion() {
      return _y;
    }
    /**
     * Override of PropertiesMixin _finalizeClass to create observers and
     * find the template.
     * @return {void}
     * @protected
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     * @nocollapse
     */
    static _finalizeClass() {
      e._finalizeClass.call(this);
      const c = r(this);
      c && this.createObservers(c, this._properties), this._prepareTemplate();
    }
    /** @nocollapse */
    static _prepareTemplate() {
      let c = (
        /** @type {PolymerElementConstructor} */
        this.template
      );
      c && (typeof c == "string" ? c = null : oh || (c = c.cloneNode(!0))), this.prototype._template = c;
    }
    /**
     * Override of PropertiesChanged createProperties to create accessors
     * and property effects for all of the properties.
     * @param {!Object} props .
     * @return {void}
     * @protected
     * @nocollapse
     */
    static createProperties(c) {
      for (let d in c)
        s(
          /** @type {?} */
          this.prototype,
          d,
          c[d],
          c
        );
    }
    /**
     * Creates observers for the given `observers` array.
     * Leverages `PropertyEffects` to create observers.
     * @param {Object} observers Array of observer descriptors for
     *   this class
     * @param {Object} dynamicFns Object containing keys for any properties
     *   that are functions and should trigger the effect when the function
     *   reference is changed
     * @return {void}
     * @protected
     * @nocollapse
     */
    static createObservers(c, d) {
      const u = this.prototype;
      for (let h = 0; h < c.length; h++)
        u._createMethodObserver(c[h], d);
    }
    /**
     * Returns the template that will be stamped into this element's shadow root.
     *
     * If a `static get is()` getter is defined, the default implementation will
     * return the first `<template>` in a `dom-module` whose `id` matches this
     * element's `is` (note that a `_template` property on the class prototype
     * takes precedence over the `dom-module` template, to maintain legacy
     * element semantics; a subclass will subsequently fall back to its super
     * class template if neither a `prototype._template` or a `dom-module` for
     * the class's `is` was found).
     *
     * Users may override this getter to return an arbitrary template
     * (in which case the `is` getter is unnecessary). The template returned
     * must be an `HTMLTemplateElement`.
     *
     * Note that when subclassing, if the super class overrode the default
     * implementation and the subclass would like to provide an alternate
     * template via a `dom-module`, it should override this getter and
     * return `DomModule.import(this.is, 'template')`.
     *
     * If a subclass would like to modify the super class template, it should
     * clone it rather than modify it in place.  If the getter does expensive
     * work such as cloning/modifying a template, it should memoize the
     * template for maximum performance:
     *
     *   let memoizedTemplate;
     *   class MySubClass extends MySuperClass {
     *     static get template() {
     *       if (!memoizedTemplate) {
     *         memoizedTemplate = super.template.cloneNode(true);
     *         let subContent = document.createElement('div');
     *         subContent.textContent = 'This came from MySubClass';
     *         memoizedTemplate.content.appendChild(subContent);
     *       }
     *       return memoizedTemplate;
     *     }
     *   }
     *
     * @return {!HTMLTemplateElement|string} Template to be stamped
     * @nocollapse
     */
    static get template() {
      if (!this.hasOwnProperty(JSCompiler_renameProperty("_template", this))) {
        let c = this.prototype.hasOwnProperty(
          JSCompiler_renameProperty("_template", this.prototype)
        ) ? this.prototype._template : void 0;
        typeof c == "function" && (c = c()), this._template = // If user has put template on prototype (e.g. in legacy via registered
        // callback or info object), prefer that first. Note that `null` is
        // used as a sentinel to indicate "no template" and can be used to
        // override a super template, whereas `undefined` is used as a
        // sentinel to mean "fall-back to default template lookup" via
        // dom-module and/or super.template.
        c !== void 0 ? c : (
          // Look in dom-module associated with this element's is
          this.hasOwnProperty(JSCompiler_renameProperty("is", this)) && n(
            /** @type {PolymerElementConstructor}*/
            this.is
          ) || // Next look for superclass template (call the super impl this
          // way so that `this` points to the superclass)
          Object.getPrototypeOf(
            /** @type {PolymerElementConstructor}*/
            this.prototype
          ).constructor.template
        );
      }
      return this._template;
    }
    /**
     * Set the template.
     *
     * @param {!HTMLTemplateElement|string} value Template to set.
     * @nocollapse
     */
    static set template(c) {
      this._template = c;
    }
    /**
     * Path matching the url from which the element was imported.
     *
     * This path is used to resolve url's in template style cssText.
     * The `importPath` property is also set on element instances and can be
     * used to create bindings relative to the import path.
     *
     * For elements defined in ES modules, users should implement
     * `static get importMeta() { return import.meta; }`, and the default
     * implementation of `importPath` will  return `import.meta.url`'s path.
     * For elements defined in HTML imports, this getter will return the path
     * to the document containing a `dom-module` element matching this
     * element's static `is` property.
     *
     * Note, this path should contain a trailing `/`.
     *
     * @return {string} The import path for this element class
     * @suppress {missingProperties}
     * @nocollapse
     */
    static get importPath() {
      if (!this.hasOwnProperty(JSCompiler_renameProperty("_importPath", this))) {
        const c = this.importMeta;
        if (c)
          this._importPath = Ca(c.url);
        else {
          const d = Ci.import(
            /** @type {PolymerElementConstructor} */
            this.is
          );
          this._importPath = d && d.assetpath || Object.getPrototypeOf(
            /** @type {PolymerElementConstructor}*/
            this.prototype
          ).constructor.importPath;
        }
      }
      return this._importPath;
    }
    constructor() {
      super(), this._template, this._importPath, this.rootPath, this.importPath, this.root, this.$;
    }
    /**
     * Overrides the default `PropertyAccessors` to ensure class
     * metaprogramming related to property accessors and effects has
     * completed (calls `finalize`).
     *
     * It also initializes any property defaults provided via `value` in
     * `properties` metadata.
     *
     * @return {void}
     * @override
     * @suppress {invalidCasts,missingProperties} go/missingfnprops
     */
    _initializeProperties() {
      this.constructor.finalize(), this.constructor._finalizeTemplate(
        /** @type {!HTMLElement} */
        this.localName
      ), super._initializeProperties(), this.rootPath = tb, this.importPath = this.constructor.importPath;
      let c = t(this.constructor);
      if (c)
        for (let d in c) {
          let u = c[d];
          if (this._canApplyPropertyDefault(d)) {
            let h = typeof u.value == "function" ? u.value.call(this) : u.value;
            this._hasAccessor(d) ? this._setPendingProperty(d, h, !0) : this[d] = h;
          }
        }
    }
    /**
     * Determines if a property dfeault can be applied. For example, this
     * prevents a default from being applied when a property that has no
     * accessor is overridden by its host before upgrade (e.g. via a binding).
     * @override
     * @param {string} property Name of the property
     * @return {boolean} Returns true if the property default can be applied.
     */
    _canApplyPropertyDefault(c) {
      return !this.hasOwnProperty(c);
    }
    /**
     * Gather style text for a style element in the template.
     *
     * @param {string} cssText Text containing styling to process
     * @param {string} baseURI Base URI to rebase CSS paths against
     * @return {string} The processed CSS text
     * @protected
     * @nocollapse
     */
    static _processStyleText(c, d) {
      return xa(c, d);
    }
    /**
    * Configures an element `proto` to function with a given `template`.
    * The element name `is` and extends `ext` must be specified for ShadyCSS
    * style scoping.
    *
    * @param {string} is Tag name (or type extension name) for this element
    * @return {void}
    * @protected
    * @nocollapse
    */
    static _finalizeTemplate(c) {
      const d = this.prototype._template;
      if (d && !d.__polymerFinalized) {
        d.__polymerFinalized = !0;
        const u = this.importPath, h = u ? ui(u) : "";
        o(this, d, c, h), this.prototype._bindTemplate(d);
      }
    }
    /**
     * Provides a default implementation of the standard Custom Elements
     * `connectedCallback`.
     *
     * The default implementation enables the property effects system and
     * flushes any pending properties, and updates shimmed CSS properties
     * when using the ShadyCSS scoping/custom properties polyfill.
     *
     * @override
     * @suppress {missingProperties, invalidCasts} Super may or may not
     *     implement the callback
     * @return {void}
     */
    connectedCallback() {
      window.ShadyCSS && this._template && window.ShadyCSS.styleElement(
        /** @type {!HTMLElement} */
        this
      ), super.connectedCallback();
    }
    /**
     * Stamps the element template.
     *
     * @return {void}
     * @override
     */
    ready() {
      this._template && (this.root = this._stampTemplate(this._template), this.$ = this.root.$), super.ready();
    }
    /**
     * Implements `PropertyEffects`'s `_readyClients` call. Attaches
     * element dom by calling `_attachDom` with the dom stamped from the
     * element's template via `_stampTemplate`. Note that this allows
     * client dom to be attached to the element prior to any observers
     * running.
     *
     * @return {void}
     * @override
     */
    _readyClients() {
      this._template && (this.root = this._attachDom(
        /** @type {StampedTemplate} */
        this.root
      )), super._readyClients();
    }
    /**
     * Attaches an element's stamped dom to itself. By default,
     * this method creates a `shadowRoot` and adds the dom to it.
     * However, this method may be overridden to allow an element
     * to put its dom in another location.
     *
     * @override
     * @throws {Error}
     * @suppress {missingReturn}
     * @param {StampedTemplate} dom to attach to the element.
     * @return {ShadowRoot} node to which the dom has been attached.
     */
    _attachDom(c) {
      const d = B(this);
      if (d.attachShadow)
        return c ? (d.shadowRoot || (d.attachShadow({ mode: "open", shadyUpgradeFragment: c }), d.shadowRoot.appendChild(c), this.constructor._styleSheet && (d.shadowRoot.adoptedStyleSheets = [this.constructor._styleSheet])), ib && window.ShadyDOM && window.ShadyDOM.flushInitial(d.shadowRoot), d.shadowRoot) : null;
      throw new Error("ShadowDOM not available. PolymerElement can create dom as children instead of in ShadowDOM by setting `this.root = this;` before `ready`.");
    }
    /**
     * When using the ShadyCSS scoping and custom property shim, causes all
     * shimmed styles in this element (and its subtree) to be updated
     * based on current custom property values.
     *
     * The optional parameter overrides inline custom property styles with an
     * object of properties where the keys are CSS properties, and the values
     * are strings.
     *
     * Example: `this.updateStyles({'--color': 'blue'})`
     *
     * These properties are retained unless a value of `null` is set.
     *
     * Note: This function does not support updating CSS mixins.
     * You can not dynamically change the value of an `@apply`.
     *
     * @override
     * @param {Object=} properties Bag of custom property key/values to
     *   apply to this element.
     * @return {void}
     * @suppress {invalidCasts}
     */
    updateStyles(c) {
      window.ShadyCSS && window.ShadyCSS.styleSubtree(
        /** @type {!HTMLElement} */
        this,
        c
      );
    }
    /**
     * Rewrites a given URL relative to a base URL. The base URL defaults to
     * the original location of the document containing the `dom-module` for
     * this element. This method will return the same URL before and after
     * bundling.
     *
     * Note that this function performs no resolution for URLs that start
     * with `/` (absolute URLs) or `#` (hash identifiers).  For general purpose
     * URL resolution, use `window.URL`.
     *
     * @override
     * @param {string} url URL to resolve.
     * @param {string=} base Optional base URL to resolve against, defaults
     * to the element's `importPath`
     * @return {string} Rewritten URL relative to base
     */
    resolveUrl(c, d) {
      return !d && this.importPath && (d = ui(this.importPath)), ui(c, d);
    }
    /**
     * Overrides `PropertyEffects` to add map of dynamic functions on
     * template info, for consumption by `PropertyEffects` template binding
     * code. This map determines which method templates should have accessors
     * created for them.
     *
     * @param {!HTMLTemplateElement} template Template
     * @param {!TemplateInfo} templateInfo Template metadata for current template
     * @param {!NodeInfo} nodeInfo Node metadata for current template.
     * @return {boolean} .
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     * @nocollapse
     */
    static _parseTemplateContent(c, d, u) {
      return d.dynamicFns = d.dynamicFns || this._properties, e._parseTemplateContent.call(
        this,
        c,
        d,
        u
      );
    }
    /**
     * Overrides `PropertyEffects` to warn on use of undeclared properties in
     * template.
     *
     * @param {Object} templateInfo Template metadata to add effect to
     * @param {string} prop Property that should trigger the effect
     * @param {Object=} effect Effect metadata object
     * @return {void}
     * @protected
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     * @nocollapse
     */
    static _addTemplatePropertyEffect(c, d, u) {
      return nh && !(d in this._properties) && // Methods used in templates with no dependencies (or only literal
      // dependencies) become accessors with template effects; ignore these
      !(u.info.part.signature && u.info.part.signature.static) && // Warnings for bindings added to nested templates are handled by
      // templatizer so ignore both the host-to-template bindings
      // (`hostProp`) and TemplateInstance-to-child bindings
      // (`nestedTemplate`)
      !u.info.part.hostProp && c.nestedTemplate, e._addTemplatePropertyEffect.call(
        this,
        c,
        d,
        u
      );
    }
  }
  return a;
});
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const vc = window.trustedTypes && trustedTypes.createPolicy("polymer-html-literal", { createHTML: (i) => i });
class Ah {
  /**
   * @param {!ITemplateArray} strings Constant parts of tagged template literal
   * @param {!Array<*>} values Variable parts of tagged template literal
   */
  constructor(e, t) {
    Sh(e, t);
    const r = t.reduce(
      (s, o, n) => s + Eh(o) + e[n + 1],
      e[0]
    );
    this.value = r.toString();
  }
  /**
   * @return {string} LiteralString string value
   * @override
   */
  toString() {
    return this.value;
  }
}
function Eh(i) {
  if (i instanceof Ah)
    return (
      /** @type {!LiteralString} */
      i.value
    );
  throw new Error(
    `non-literal value passed to Polymer's htmlLiteral function: ${i}`
  );
}
function yy(i) {
  if (i instanceof HTMLTemplateElement)
    return (
      /** @type {!HTMLTemplateElement } */
      i.innerHTML
    );
  if (i instanceof Ah)
    return Eh(i);
  throw new Error(
    `non-template value passed to Polymer's html function: ${i}`
  );
}
const U = function(e, ...t) {
  Sh(e, t);
  const r = (
    /** @type {!HTMLTemplateElement} */
    document.createElement("template")
  );
  let s = t.reduce(
    (o, n, a) => o + yy(n) + e[a + 1],
    e[0]
  );
  return vc && (s = vc.createHTML(s)), r.innerHTML = s, r;
}, Sh = (i, e) => {
  if (!Array.isArray(i) || !Array.isArray(i.raw) || e.length !== i.length - 1)
    throw new TypeError("Invalid call to the html template tag");
};
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const N = by(HTMLElement), vy = /\/\*[\*!]\s+vaadin-dev-mode:start([\s\S]*)vaadin-dev-mode:end\s+\*\*\//i, Cs = window.Vaadin && window.Vaadin.Flow && window.Vaadin.Flow.clients;
function wy() {
  function i() {
    return !0;
  }
  return Th(i);
}
function xy() {
  try {
    return Cy() ? !0 : ky() ? Cs ? !Ay() : !wy() : !1;
  } catch {
    return !1;
  }
}
function Cy() {
  return localStorage.getItem("vaadin.developmentmode.force");
}
function ky() {
  return ["localhost", "127.0.0.1"].indexOf(window.location.hostname) >= 0;
}
function Ay() {
  return !!(Cs && Object.keys(Cs).map((e) => Cs[e]).filter((e) => e.productionMode).length > 0);
}
function Th(i, e) {
  if (typeof i != "function")
    return;
  const t = vy.exec(i.toString());
  if (t)
    try {
      i = new Function(t[1]);
    } catch {
    }
  return i(e);
}
window.Vaadin = window.Vaadin || {};
const wc = function(i, e) {
  if (window.Vaadin.developmentMode)
    return Th(i, e);
};
window.Vaadin.developmentMode === void 0 && (window.Vaadin.developmentMode = xy());
function Ey() {
}
const Sy = function() {
  if (typeof wc == "function")
    return wc(Ey);
};
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
let xc = 0, Ih = 0;
const vr = [];
let Rn = !1;
function Ty() {
  Rn = !1;
  const i = vr.length;
  for (let e = 0; e < i; e++) {
    const t = vr[e];
    if (t)
      try {
        t();
      } catch (r) {
        setTimeout(() => {
          throw r;
        });
      }
  }
  vr.splice(0, i), Ih += i;
}
const _e = {
  /**
   * Returns a sub-module with the async interface providing the provided
   * delay.
   *
   * @memberof timeOut
   * @param {number=} delay Time to wait before calling callbacks in ms
   * @return {!AsyncInterface} An async timeout interface
   */
  after(i) {
    return {
      run(e) {
        return window.setTimeout(e, i);
      },
      cancel(e) {
        window.clearTimeout(e);
      }
    };
  },
  /**
   * Enqueues a function called in the next task.
   *
   * @memberof timeOut
   * @param {!Function} fn Callback to run
   * @param {number=} delay Delay in milliseconds
   * @return {number} Handle used for canceling task
   */
  run(i, e) {
    return window.setTimeout(i, e);
  },
  /**
   * Cancels a previously enqueued `timeOut` callback.
   *
   * @memberof timeOut
   * @param {number} handle Handle returned from `run` of callback to cancel
   * @return {void}
   */
  cancel(i) {
    window.clearTimeout(i);
  }
}, wt = {
  /**
   * Enqueues a function called at `requestAnimationFrame` timing.
   *
   * @memberof animationFrame
   * @param {function(number):void} fn Callback to run
   * @return {number} Handle used for canceling task
   */
  run(i) {
    return window.requestAnimationFrame(i);
  },
  /**
   * Cancels a previously enqueued `animationFrame` callback.
   *
   * @memberof animationFrame
   * @param {number} handle Handle returned from `run` of callback to cancel
   * @return {void}
   */
  cancel(i) {
    window.cancelAnimationFrame(i);
  }
}, Dh = {
  /**
   * Enqueues a function called at `requestIdleCallback` timing.
   *
   * @memberof idlePeriod
   * @param {function(!IdleDeadline):void} fn Callback to run
   * @return {number} Handle used for canceling task
   */
  run(i) {
    return window.requestIdleCallback ? window.requestIdleCallback(i) : window.setTimeout(i, 16);
  },
  /**
   * Cancels a previously enqueued `idlePeriod` callback.
   *
   * @memberof idlePeriod
   * @param {number} handle Handle returned from `run` of callback to cancel
   * @return {void}
   */
  cancel(i) {
    window.cancelIdleCallback ? window.cancelIdleCallback(i) : window.clearTimeout(i);
  }
}, xt = {
  /**
   * Enqueues a function called at microtask timing.
   *
   * @memberof microTask
   * @param {!Function=} callback Callback to run
   * @return {number} Handle used for canceling task
   */
  run(i) {
    Rn || (Rn = !0, queueMicrotask(() => Ty())), vr.push(i);
    const e = xc;
    return xc += 1, e;
  },
  /**
   * Cancels a previously enqueued `microTask` callback.
   *
   * @memberof microTask
   * @param {number} handle Handle returned from `run` of callback to cancel
   * @return {void}
   */
  cancel(i) {
    const e = i - Ih;
    if (e >= 0) {
      if (!vr[e])
        throw new Error(`invalid async handle: ${i}`);
      vr[e] = null;
    }
  }
};
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const Ti = /* @__PURE__ */ new Set();
let R = class Ln {
  /**
   * Creates a debouncer if no debouncer is passed as a parameter
   * or it cancels an active debouncer otherwise. The following
   * example shows how a debouncer can be called multiple times within a
   * microtask and "debounced" such that the provided callback function is
   * called once. Add this method to a custom element:
   *
   * ```js
   * import {microTask} from '@vaadin/component-base/src/async.js';
   * import {Debouncer} from '@vaadin/component-base/src/debounce.js';
   * // ...
   *
   * _debounceWork() {
   *   this._debounceJob = Debouncer.debounce(this._debounceJob,
   *       microTask, () => this._doWork());
   * }
   * ```
   *
   * If the `_debounceWork` method is called multiple times within the same
   * microtask, the `_doWork` function will be called only once at the next
   * microtask checkpoint.
   *
   * Note: In testing it is often convenient to avoid asynchrony. To accomplish
   * this with a debouncer, you can use `enqueueDebouncer` and
   * `flush`. For example, extend the above example by adding
   * `enqueueDebouncer(this._debounceJob)` at the end of the
   * `_debounceWork` method. Then in a test, call `flush` to ensure
   * the debouncer has completed.
   *
   * @param {Debouncer?} debouncer Debouncer object.
   * @param {!AsyncInterface} asyncModule Object with Async interface
   * @param {function()} callback Callback to run.
   * @return {!Debouncer} Returns a debouncer object.
   */
  static debounce(e, t, r) {
    return e instanceof Ln ? e._cancelAsync() : e = new Ln(), e.setConfig(t, r), e;
  }
  constructor() {
    this._asyncModule = null, this._callback = null, this._timer = null;
  }
  /**
   * Sets the scheduler; that is, a module with the Async interface,
   * a callback and optional arguments to be passed to the run function
   * from the async module.
   *
   * @param {!AsyncInterface} asyncModule Object with Async interface.
   * @param {function()} callback Callback to run.
   * @return {void}
   */
  setConfig(e, t) {
    this._asyncModule = e, this._callback = t, this._timer = this._asyncModule.run(() => {
      this._timer = null, Ti.delete(this), this._callback();
    });
  }
  /**
   * Cancels an active debouncer and returns a reference to itself.
   *
   * @return {void}
   */
  cancel() {
    this.isActive() && (this._cancelAsync(), Ti.delete(this));
  }
  /**
   * Cancels a debouncer's async callback.
   *
   * @return {void}
   */
  _cancelAsync() {
    this.isActive() && (this._asyncModule.cancel(
      /** @type {number} */
      this._timer
    ), this._timer = null);
  }
  /**
   * Flushes an active debouncer and returns a reference to itself.
   *
   * @return {void}
   */
  flush() {
    this.isActive() && (this.cancel(), this._callback());
  }
  /**
   * Returns true if the debouncer is active.
   *
   * @return {boolean} True if active.
   */
  isActive() {
    return this._timer != null;
  }
};
function Oh(i) {
  Ti.add(i);
}
function Iy() {
  const i = !!Ti.size;
  return Ti.forEach((e) => {
    try {
      e.flush();
    } catch (t) {
      setTimeout(() => {
        throw t;
      });
    }
  }), i;
}
const ai = () => {
  let i;
  do
    i = Iy();
  while (i);
};
/**
 * @license
 * Copyright (c) 2021 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Ge = [];
function Vn(i, e, t = i.getAttribute("dir")) {
  e ? i.setAttribute("dir", e) : t != null && i.removeAttribute("dir");
}
function Hn() {
  return document.documentElement.getAttribute("dir");
}
function Dy() {
  const i = Hn();
  Ge.forEach((e) => {
    Vn(e, i);
  });
}
const Oy = new MutationObserver(Dy);
Oy.observe(document.documentElement, { attributes: !0, attributeFilter: ["dir"] });
const Be = (i) => class extends i {
  static get properties() {
    return {
      /**
       * @protected
       */
      dir: {
        type: String,
        value: "",
        reflectToAttribute: !0,
        converter: {
          fromAttribute: (t) => t || "",
          toAttribute: (t) => t === "" ? null : t
        }
      }
    };
  }
  /**
   * @return {boolean}
   * @protected
   */
  get __isRTL() {
    return this.getAttribute("dir") === "rtl";
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback(), (!this.hasAttribute("dir") || this.__restoreSubscription) && (this.__subscribe(), Vn(this, Hn(), null));
  }
  /** @protected */
  attributeChangedCallback(t, r, s) {
    if (super.attributeChangedCallback(t, r, s), t !== "dir")
      return;
    const o = Hn(), n = s === o && Ge.indexOf(this) === -1, a = !s && r && Ge.indexOf(this) === -1;
    n || a ? (this.__subscribe(), Vn(this, o, s)) : s !== o && r === o && this.__unsubscribe();
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback(), this.__restoreSubscription = Ge.includes(this), this.__unsubscribe();
  }
  /** @protected */
  _valueToNodeAttribute(t, r, s) {
    s === "dir" && r === "" && !t.hasAttribute("dir") || super._valueToNodeAttribute(t, r, s);
  }
  /** @protected */
  _attributeToProperty(t, r, s) {
    t === "dir" && !r ? this.dir = "" : super._attributeToProperty(t, r, s);
  }
  /** @private */
  __subscribe() {
    Ge.includes(this) || Ge.push(this);
  }
  /** @private */
  __unsubscribe() {
    Ge.includes(this) && Ge.splice(Ge.indexOf(this), 1);
  }
};
/**
 * @license
 * Copyright (c) 2021 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
window.Vaadin || (window.Vaadin = {});
window.Vaadin.registrations || (window.Vaadin.registrations = []);
window.Vaadin.developmentModeCallback || (window.Vaadin.developmentModeCallback = {});
window.Vaadin.developmentModeCallback["vaadin-usage-statistics"] = function() {
  Sy();
};
let Zo;
const Cc = /* @__PURE__ */ new Set(), At = (i) => class extends Be(i) {
  static get version() {
    return "24.2.2";
  }
  /** @protected */
  static finalize() {
    super.finalize();
    const { is: t } = this;
    t && !Cc.has(t) && (window.Vaadin.registrations.push(this), Cc.add(t), window.Vaadin.developmentModeCallback && (Zo = R.debounce(Zo, Dh, () => {
      window.Vaadin.developmentModeCallback["vaadin-usage-statistics"]();
    }), Oh(Zo)));
  }
  constructor() {
    super(), document.doctype;
  }
};
/**
 * @license
 * Copyright (c) 2021 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function $y(i) {
  const e = [];
  for (; i; ) {
    if (i.nodeType === Node.DOCUMENT_NODE) {
      e.push(i);
      break;
    }
    if (i.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
      e.push(i), i = i.host;
      continue;
    }
    if (i.assignedSlot) {
      i = i.assignedSlot;
      continue;
    }
    i = i.parentNode;
  }
  return e;
}
function $h(i, e) {
  return e ? e.closest(i) || $h(i, e.getRootNode().host) : null;
}
function Ta(i) {
  return i ? new Set(i.split(" ")) : /* @__PURE__ */ new Set();
}
function co(i) {
  return i ? [...i].join(" ") : "";
}
function uo(i, e, t) {
  const r = Ta(i.getAttribute(e));
  r.add(t), i.setAttribute(e, co(r));
}
function Ia(i, e, t) {
  const r = Ta(i.getAttribute(e));
  if (r.delete(t), r.size === 0) {
    i.removeAttribute(e);
    return;
  }
  i.setAttribute(e, co(r));
}
function Py(i) {
  return i.nodeType === Node.TEXT_NODE && i.textContent.trim() === "";
}
/**
 * @license
 * Copyright (c) 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class My {
  constructor(e, t) {
    this.slot = e, this.callback = t, this._storedNodes = [], this._connected = !1, this._scheduled = !1, this._boundSchedule = () => {
      this._schedule();
    }, this.connect(), this._schedule();
  }
  /**
   * Activates an observer. This method is automatically called when
   * a `SlotObserver` is created. It should only be called to  re-activate
   * an observer that has been deactivated via the `disconnect` method.
   */
  connect() {
    this.slot.addEventListener("slotchange", this._boundSchedule), this._connected = !0;
  }
  /**
   * Deactivates the observer. After calling this method the observer callback
   * will not be called when changes to slotted nodes occur. The `connect` method
   * may be subsequently called to reactivate the observer.
   */
  disconnect() {
    this.slot.removeEventListener("slotchange", this._boundSchedule), this._connected = !1;
  }
  /** @private */
  _schedule() {
    this._scheduled || (this._scheduled = !0, queueMicrotask(() => {
      this.flush();
    }));
  }
  /**
   * Run the observer callback synchronously.
   */
  flush() {
    this._connected && (this._scheduled = !1, this._processNodes());
  }
  /** @private */
  _processNodes() {
    const e = this.slot.assignedNodes({ flatten: !0 });
    let t = [];
    const r = [], s = [];
    e.length && (t = e.filter((o) => !this._storedNodes.includes(o))), this._storedNodes.length && this._storedNodes.forEach((o, n) => {
      const a = e.indexOf(o);
      a === -1 ? r.push(o) : a !== n && s.push(o);
    }), (t.length || r.length || s.length) && this.callback({ addedNodes: t, movedNodes: s, removedNodes: r }), this._storedNodes = e;
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
let zy = 0;
function Da() {
  return zy++;
}
/**
 * @license
 * Copyright (c) 2021 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class Ke extends EventTarget {
  /**
   * Ensure that every instance has unique ID.
   *
   * @param {HTMLElement} host
   * @param {string} slotName
   * @return {string}
   * @protected
   */
  static generateId(e, t) {
    return `${t || "default"}-${e.localName}-${Da()}`;
  }
  constructor(e, t, r, s = {}) {
    super();
    const { initializer: o, multiple: n, observe: a, useUniqueId: l } = s;
    this.host = e, this.slotName = t, this.tagName = r, this.observe = typeof a == "boolean" ? a : !0, this.multiple = typeof n == "boolean" ? n : !1, this.slotInitializer = o, n && (this.nodes = []), l && (this.defaultId = this.constructor.generateId(e, t));
  }
  hostConnected() {
    this.initialized || (this.multiple ? this.initMultiple() : this.initSingle(), this.observe && this.observeSlot(), this.initialized = !0);
  }
  /** @protected */
  initSingle() {
    let e = this.getSlotChild();
    e ? (this.node = e, this.initAddedNode(e)) : (e = this.attachDefaultNode(), this.initNode(e));
  }
  /** @protected */
  initMultiple() {
    const e = this.getSlotChildren();
    if (e.length === 0) {
      const t = this.attachDefaultNode();
      t && (this.nodes = [t], this.initNode(t));
    } else
      this.nodes = e, e.forEach((t) => {
        this.initAddedNode(t);
      });
  }
  /**
   * Create and attach default node using the provided tag name, if any.
   * @return {Node | undefined}
   * @protected
   */
  attachDefaultNode() {
    const { host: e, slotName: t, tagName: r } = this;
    let s = this.defaultNode;
    return !s && r && (s = document.createElement(r), s instanceof Element && (t !== "" && s.setAttribute("slot", t), this.node = s, this.defaultNode = s)), s && e.appendChild(s), s;
  }
  /**
   * Return the list of nodes matching the slot managed by the controller.
   * @return {Node}
   */
  getSlotChildren() {
    const { slotName: e } = this;
    return Array.from(this.host.childNodes).filter((t) => t.nodeType === Node.ELEMENT_NODE && t.slot === e || t.nodeType === Node.TEXT_NODE && t.textContent.trim() && e === "");
  }
  /**
   * Return a reference to the node managed by the controller.
   * @return {Node}
   */
  getSlotChild() {
    return this.getSlotChildren()[0];
  }
  /**
   * Run `slotInitializer` for the node managed by the controller.
   *
   * @param {Node} node
   * @protected
   */
  initNode(e) {
    const { slotInitializer: t } = this;
    t && t(e, this.host);
  }
  /**
   * Override to initialize the newly added custom node.
   *
   * @param {Node} _node
   * @protected
   */
  initCustomNode(e) {
  }
  /**
   * Override to teardown slotted node when it's removed.
   *
   * @param {Node} _node
   * @protected
   */
  teardownNode(e) {
  }
  /**
   * Run both `initCustomNode` and `initNode` for a custom slotted node.
   *
   * @param {Node} node
   * @protected
   */
  initAddedNode(e) {
    e !== this.defaultNode && (this.initCustomNode(e), this.initNode(e));
  }
  /**
   * Setup the observer to manage slot content changes.
   * @protected
   */
  observeSlot() {
    const { slotName: e } = this, t = e === "" ? "slot:not([name])" : `slot[name=${e}]`, r = this.host.shadowRoot.querySelector(t);
    this.__slotObserver = new My(r, ({ addedNodes: s, removedNodes: o }) => {
      const n = this.multiple ? this.nodes : [this.node], a = s.filter((l) => !Py(l) && !n.includes(l));
      o.length && (this.nodes = n.filter((l) => !o.includes(l)), o.forEach((l) => {
        this.teardownNode(l);
      })), a && a.length > 0 && (this.multiple ? (this.defaultNode && this.defaultNode.remove(), this.nodes = [...n, ...a].filter((l) => l !== this.defaultNode), a.forEach((l) => {
        this.initAddedNode(l);
      })) : (this.node && this.node.remove(), this.node = a[0], this.initAddedNode(this.node)));
    });
  }
}
/**
 * @license
 * Copyright (c) 2022 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class Et extends Ke {
  constructor(e) {
    super(e, "tooltip"), this.setTarget(e);
  }
  /**
   * Override to initialize the newly added custom tooltip.
   *
   * @param {Node} tooltipNode
   * @protected
   * @override
   */
  initCustomNode(e) {
    e.target = this.target, this.ariaTarget !== void 0 && (e.ariaTarget = this.ariaTarget), this.context !== void 0 && (e.context = this.context), this.manual !== void 0 && (e.manual = this.manual), this.opened !== void 0 && (e.opened = this.opened), this.position !== void 0 && (e._position = this.position), this.shouldShow !== void 0 && (e.shouldShow = this.shouldShow), this.__notifyChange();
  }
  /**
   * Override to notify the host when the tooltip is removed.
   *
   * @param {Node} tooltipNode
   * @protected
   * @override
   */
  teardownNode() {
    this.__notifyChange();
  }
  /**
   * Set an HTML element for linking with the tooltip overlay
   * via `aria-describedby` attribute used by screen readers.
   * @param {HTMLElement} ariaTarget
   */
  setAriaTarget(e) {
    this.ariaTarget = e;
    const t = this.node;
    t && (t.ariaTarget = e);
  }
  /**
   * Set a context object to be used by generator.
   * @param {object} context
   */
  setContext(e) {
    this.context = e;
    const t = this.node;
    t && (t.context = e);
  }
  /**
   * Toggle manual state on the slotted tooltip.
   * @param {boolean} manual
   */
  setManual(e) {
    this.manual = e;
    const t = this.node;
    t && (t.manual = e);
  }
  /**
   * Toggle opened state on the slotted tooltip.
   * @param {boolean} opened
   */
  setOpened(e) {
    this.opened = e;
    const t = this.node;
    t && (t.opened = e);
  }
  /**
   * Set default position for the slotted tooltip.
   * This can be overridden by setting the position
   * using corresponding property or attribute.
   * @param {string} position
   */
  setPosition(e) {
    this.position = e;
    const t = this.node;
    t && (t._position = e);
  }
  /**
   * Set function used to detect whether to show
   * the tooltip based on a condition.
   * @param {Function} shouldShow
   */
  setShouldShow(e) {
    this.shouldShow = e;
    const t = this.node;
    t && (t.shouldShow = e);
  }
  /**
   * Set an HTML element to attach the tooltip to.
   * @param {HTMLElement} target
   */
  setTarget(e) {
    this.target = e;
    const t = this.node;
    t && (t.target = e);
  }
  /** @private */
  __notifyChange() {
    this.dispatchEvent(new CustomEvent("tooltip-changed", { detail: { node: this.node } }));
  }
}
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const Ny = !1, Fy = (i) => i, Oa = typeof document.head.style.touchAction == "string", Bn = "__polymerGestures", Ko = "__polymerGesturesHandled", Un = "__polymerGesturesTouchAction", kc = 25, Ac = 5, Ry = 2, Ly = ["mousedown", "mousemove", "mouseup", "click"], Vy = [0, 1, 4, 2], Hy = function() {
  try {
    return new MouseEvent("test", { buttons: 1 }).buttons === 1;
  } catch {
    return !1;
  }
}();
function $a(i) {
  return Ly.indexOf(i) > -1;
}
let Ph = !1;
(function() {
  try {
    const i = Object.defineProperty({}, "passive", {
      // eslint-disable-next-line getter-return
      get() {
        Ph = !0;
      }
    });
    window.addEventListener("test", null, i), window.removeEventListener("test", null, i);
  } catch {
  }
})();
function By(i) {
  if (!($a(i) || i === "touchend") && Oa && Ph && Ny)
    return { passive: !0 };
}
const Uy = navigator.userAgent.match(/iP(?:[oa]d|hone)|Android/u), qy = {
  button: !0,
  command: !0,
  fieldset: !0,
  input: !0,
  keygen: !0,
  optgroup: !0,
  option: !0,
  select: !0,
  textarea: !0
};
function Wt(i) {
  const e = i.type;
  if (!$a(e))
    return !1;
  if (e === "mousemove") {
    let r = i.buttons === void 0 ? 1 : i.buttons;
    return i instanceof window.MouseEvent && !Hy && (r = Vy[i.which] || 0), !!(r & 1);
  }
  return (i.button === void 0 ? 0 : i.button) === 0;
}
function Wy(i) {
  if (i.type === "click") {
    if (i.detail === 0)
      return !0;
    const e = bt(i);
    if (!e.nodeType || /** @type {Element} */
    e.nodeType !== Node.ELEMENT_NODE)
      return !0;
    const t = (
      /** @type {Element} */
      e.getBoundingClientRect()
    ), r = i.pageX, s = i.pageY;
    return !(r >= t.left && r <= t.right && s >= t.top && s <= t.bottom);
  }
  return !1;
}
const Ye = {
  mouse: {
    target: null,
    mouseIgnoreJob: null
  },
  touch: {
    x: 0,
    y: 0,
    id: -1,
    scrollDecided: !1
  }
};
function jy(i) {
  let e = "auto";
  const t = zh(i);
  for (let r = 0, s; r < t.length; r++)
    if (s = t[r], s[Un]) {
      e = s[Un];
      break;
    }
  return e;
}
function Mh(i, e, t) {
  i.movefn = e, i.upfn = t, document.addEventListener("mousemove", e), document.addEventListener("mouseup", t);
}
function wr(i) {
  document.removeEventListener("mousemove", i.movefn), document.removeEventListener("mouseup", i.upfn), i.movefn = null, i.upfn = null;
}
const zh = window.ShadyDOM && window.ShadyDOM.noPatch ? window.ShadyDOM.composedPath : (i) => i.composedPath && i.composedPath() || [], Pa = {}, Bt = [];
function Gy(i, e) {
  let t = document.elementFromPoint(i, e), r = t;
  for (; r && r.shadowRoot && !window.ShadyDOM; ) {
    const s = r;
    if (r = r.shadowRoot.elementFromPoint(i, e), s === r)
      break;
    r && (t = r);
  }
  return t;
}
function bt(i) {
  const e = zh(
    /** @type {?Event} */
    i
  );
  return e.length > 0 ? e[0] : i.target;
}
function Yy(i) {
  const e = i.type, r = i.currentTarget[Bn];
  if (!r)
    return;
  const s = r[e];
  if (!s)
    return;
  if (!i[Ko] && (i[Ko] = {}, e.startsWith("touch"))) {
    const n = i.changedTouches[0];
    if (e === "touchstart" && i.touches.length === 1 && (Ye.touch.id = n.identifier), Ye.touch.id !== n.identifier)
      return;
    Oa || (e === "touchstart" || e === "touchmove") && Zy(i);
  }
  const o = i[Ko];
  if (!o.skip) {
    for (let n = 0, a; n < Bt.length; n++)
      a = Bt[n], s[a.name] && !o[a.name] && a.flow && a.flow.start.indexOf(i.type) > -1 && a.reset && a.reset();
    for (let n = 0, a; n < Bt.length; n++)
      a = Bt[n], s[a.name] && !o[a.name] && (o[a.name] = !0, a[e](i));
  }
}
function Zy(i) {
  const e = i.changedTouches[0], t = i.type;
  if (t === "touchstart")
    Ye.touch.x = e.clientX, Ye.touch.y = e.clientY, Ye.touch.scrollDecided = !1;
  else if (t === "touchmove") {
    if (Ye.touch.scrollDecided)
      return;
    Ye.touch.scrollDecided = !0;
    const r = jy(i);
    let s = !1;
    const o = Math.abs(Ye.touch.x - e.clientX), n = Math.abs(Ye.touch.y - e.clientY);
    i.cancelable && (r === "none" ? s = !0 : r === "pan-x" ? s = n > o : r === "pan-y" && (s = o > n)), s ? i.preventDefault() : Ls("track");
  }
}
function pe(i, e, t) {
  return Pa[e] ? (Ky(i, e, t), !0) : !1;
}
function Ky(i, e, t) {
  const r = Pa[e], s = r.deps, o = r.name;
  let n = i[Bn];
  n || (i[Bn] = n = {});
  for (let a = 0, l, c; a < s.length; a++)
    l = s[a], !(Uy && $a(l) && l !== "click") && (c = n[l], c || (n[l] = c = { _count: 0 }), c._count === 0 && i.addEventListener(l, Yy, By(l)), c[o] = (c[o] || 0) + 1, c._count = (c._count || 0) + 1);
  i.addEventListener(e, t), r.touchAction && Nh(i, r.touchAction);
}
function Ma(i) {
  Bt.push(i), i.emits.forEach((e) => {
    Pa[e] = i;
  });
}
function Qy(i) {
  for (let e = 0, t; e < Bt.length; e++) {
    t = Bt[e];
    for (let r = 0, s; r < t.emits.length; r++)
      if (s = t.emits[r], s === i)
        return t;
  }
  return null;
}
function Nh(i, e) {
  Oa && i instanceof HTMLElement && xt.run(() => {
    i.style.touchAction = e;
  }), i[Un] = e;
}
function za(i, e, t) {
  const r = new Event(e, { bubbles: !0, cancelable: !0, composed: !0 });
  if (r.detail = t, Fy(
    /** @type {!Node} */
    i
  ).dispatchEvent(r), r.defaultPrevented) {
    const s = t.preventer || t.sourceEvent;
    s && s.preventDefault && s.preventDefault();
  }
}
function Ls(i) {
  const e = Qy(i);
  e.info && (e.info.prevent = !0);
}
Ma({
  name: "downup",
  deps: ["mousedown", "touchstart", "touchend"],
  flow: {
    start: ["mousedown", "touchstart"],
    end: ["mouseup", "touchend"]
  },
  emits: ["down", "up"],
  info: {
    movefn: null,
    upfn: null
  },
  /**
   * @this {GestureRecognizer}
   * @return {void}
   */
  reset() {
    wr(this.info);
  },
  /**
   * @this {GestureRecognizer}
   * @param {MouseEvent} e
   * @return {void}
   */
  mousedown(i) {
    if (!Wt(i))
      return;
    const e = bt(i), t = this, r = (o) => {
      Wt(o) || (Kr("up", e, o), wr(t.info));
    }, s = (o) => {
      Wt(o) && Kr("up", e, o), wr(t.info);
    };
    Mh(this.info, r, s), Kr("down", e, i);
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   * @return {void}
   */
  touchstart(i) {
    Kr("down", bt(i), i.changedTouches[0], i);
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   * @return {void}
   */
  touchend(i) {
    Kr("up", bt(i), i.changedTouches[0], i);
  }
});
function Kr(i, e, t, r) {
  e && za(e, i, {
    x: t.clientX,
    y: t.clientY,
    sourceEvent: t,
    preventer: r,
    prevent(s) {
      return Ls(s);
    }
  });
}
Ma({
  name: "track",
  touchAction: "none",
  deps: ["mousedown", "touchstart", "touchmove", "touchend"],
  flow: {
    start: ["mousedown", "touchstart"],
    end: ["mouseup", "touchend"]
  },
  emits: ["track"],
  info: {
    x: 0,
    y: 0,
    state: "start",
    started: !1,
    moves: [],
    /** @this {GestureInfo} */
    addMove(i) {
      this.moves.length > Ry && this.moves.shift(), this.moves.push(i);
    },
    movefn: null,
    upfn: null,
    prevent: !1
  },
  /**
   * @this {GestureRecognizer}
   * @return {void}
   */
  reset() {
    this.info.state = "start", this.info.started = !1, this.info.moves = [], this.info.x = 0, this.info.y = 0, this.info.prevent = !1, wr(this.info);
  },
  /**
   * @this {GestureRecognizer}
   * @param {MouseEvent} e
   * @return {void}
   */
  mousedown(i) {
    if (!Wt(i))
      return;
    const e = bt(i), t = this, r = (o) => {
      const n = o.clientX, a = o.clientY;
      Ec(t.info, n, a) && (t.info.state = t.info.started ? o.type === "mouseup" ? "end" : "track" : "start", t.info.state === "start" && Ls("tap"), t.info.addMove({ x: n, y: a }), Wt(o) || (t.info.state = "end", wr(t.info)), e && Qo(t.info, e, o), t.info.started = !0);
    }, s = (o) => {
      t.info.started && r(o), wr(t.info);
    };
    Mh(this.info, r, s), this.info.x = i.clientX, this.info.y = i.clientY;
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   * @return {void}
   */
  touchstart(i) {
    const e = i.changedTouches[0];
    this.info.x = e.clientX, this.info.y = e.clientY;
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   * @return {void}
   */
  touchmove(i) {
    const e = bt(i), t = i.changedTouches[0], r = t.clientX, s = t.clientY;
    Ec(this.info, r, s) && (this.info.state === "start" && Ls("tap"), this.info.addMove({ x: r, y: s }), Qo(this.info, e, t), this.info.state = "track", this.info.started = !0);
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   * @return {void}
   */
  touchend(i) {
    const e = bt(i), t = i.changedTouches[0];
    this.info.started && (this.info.state = "end", this.info.addMove({ x: t.clientX, y: t.clientY }), Qo(this.info, e, t));
  }
});
function Ec(i, e, t) {
  if (i.prevent)
    return !1;
  if (i.started)
    return !0;
  const r = Math.abs(i.x - e), s = Math.abs(i.y - t);
  return r >= Ac || s >= Ac;
}
function Qo(i, e, t) {
  if (!e)
    return;
  const r = i.moves[i.moves.length - 2], s = i.moves[i.moves.length - 1], o = s.x - i.x, n = s.y - i.y;
  let a, l = 0;
  r && (a = s.x - r.x, l = s.y - r.y), za(e, "track", {
    state: i.state,
    x: t.clientX,
    y: t.clientY,
    dx: o,
    dy: n,
    ddx: a,
    ddy: l,
    sourceEvent: t,
    hover() {
      return Gy(t.clientX, t.clientY);
    }
  });
}
Ma({
  name: "tap",
  deps: ["mousedown", "click", "touchstart", "touchend"],
  flow: {
    start: ["mousedown", "touchstart"],
    end: ["click", "touchend"]
  },
  emits: ["tap"],
  info: {
    x: NaN,
    y: NaN,
    prevent: !1
  },
  /**
   * @this {GestureRecognizer}
   * @return {void}
   */
  reset() {
    this.info.x = NaN, this.info.y = NaN, this.info.prevent = !1;
  },
  /**
   * @this {GestureRecognizer}
   * @param {MouseEvent} e
   * @return {void}
   */
  mousedown(i) {
    Wt(i) && (this.info.x = i.clientX, this.info.y = i.clientY);
  },
  /**
   * @this {GestureRecognizer}
   * @param {MouseEvent} e
   * @return {void}
   */
  click(i) {
    Wt(i) && Sc(this.info, i);
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   * @return {void}
   */
  touchstart(i) {
    const e = i.changedTouches[0];
    this.info.x = e.clientX, this.info.y = e.clientY;
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   * @return {void}
   */
  touchend(i) {
    Sc(this.info, i.changedTouches[0], i);
  }
});
function Sc(i, e, t) {
  const r = Math.abs(e.clientX - i.x), s = Math.abs(e.clientY - i.y), o = bt(t || e);
  !o || qy[
    /** @type {!HTMLElement} */
    o.localName
  ] && o.hasAttribute("disabled") || (isNaN(r) || isNaN(s) || r <= kc && s <= kc || Wy(e)) && (i.prevent || za(o, "tap", {
    x: e.clientX,
    y: e.clientY,
    sourceEvent: e,
    preventer: t
  }));
}
/**
 * @license
 * Copyright (c) 2021 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Li = Y(
  (i) => class extends i {
    static get properties() {
      return {
        /**
         * If true, the user cannot interact with this element.
         */
        disabled: {
          type: Boolean,
          value: !1,
          observer: "_disabledChanged",
          reflectToAttribute: !0
        }
      };
    }
    /**
     * @param {boolean} disabled
     * @protected
     */
    _disabledChanged(t) {
      this._setAriaDisabled(t);
    }
    /**
     * @param {boolean} disabled
     * @protected
     */
    _setAriaDisabled(t) {
      t ? this.setAttribute("aria-disabled", "true") : this.removeAttribute("aria-disabled");
    }
    /**
     * Overrides the default element `click` method in order to prevent
     * firing the `click` event when the element is disabled.
     * @protected
     * @override
     */
    click() {
      this.disabled || super.click();
    }
  }
);
/**
 * @license
 * Copyright (c) 2021 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Vi = Y(
  (i) => class extends i {
    /** @protected */
    ready() {
      super.ready(), this.addEventListener("keydown", (t) => {
        this._onKeyDown(t);
      }), this.addEventListener("keyup", (t) => {
        this._onKeyUp(t);
      });
    }
    /**
     * A handler for the `keydown` event. By default, it calls
     * separate methods for handling "Enter" and "Escape" keys.
     * Override the method to implement your own behavior.
     *
     * @param {KeyboardEvent} event
     * @protected
     */
    _onKeyDown(t) {
      switch (t.key) {
        case "Enter":
          this._onEnter(t);
          break;
        case "Escape":
          this._onEscape(t);
          break;
      }
    }
    /**
     * A handler for the `keyup` event. By default, it does nothing.
     * Override the method to implement your own behavior.
     *
     * @param {KeyboardEvent} _event
     * @protected
     */
    _onKeyUp(t) {
    }
    /**
     * A handler for the "Enter" key. By default, it does nothing.
     * Override the method to implement your own behavior.
     *
     * @param {KeyboardEvent} _event
     * @protected
     */
    _onEnter(t) {
    }
    /**
     * A handler for the "Escape" key. By default, it does nothing.
     * Override the method to implement your own behavior.
     *
     * @param {KeyboardEvent} _event
     * @protected
     */
    _onEscape(t) {
    }
  }
);
/**
 * @license
 * Copyright (c) 2021 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Fh = (i) => class extends Li(Vi(i)) {
  /**
   * An array of activation keys.
   *
   * See possible values here:
   * https://developer.mozilla.org/ru/docs/Web/API/KeyboardEvent/key/Key_Values
   *
   * @protected
   * @return {!Array<!string>}
   */
  get _activeKeys() {
    return [" "];
  }
  /** @protected */
  ready() {
    super.ready(), pe(this, "down", (t) => {
      this._shouldSetActive(t) && this._setActive(!0);
    }), pe(this, "up", () => {
      this._setActive(!1);
    });
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback(), this._setActive(!1);
  }
  /**
   * @param {KeyboardEvent | MouseEvent} _event
   * @protected
   */
  _shouldSetActive(t) {
    return !this.disabled;
  }
  /**
   * Sets the `active` attribute on the element if an activation key is pressed.
   *
   * @param {KeyboardEvent} event
   * @protected
   * @override
   */
  _onKeyDown(t) {
    super._onKeyDown(t), this._shouldSetActive(t) && this._activeKeys.includes(t.key) && (this._setActive(!0), document.addEventListener(
      "keyup",
      (r) => {
        this._activeKeys.includes(r.key) && this._setActive(!1);
      },
      { once: !0 }
    ));
  }
  /**
   * Toggles the `active` attribute on the element.
   *
   * @param {boolean} active
   * @protected
   */
  _setActive(t) {
    this.toggleAttribute("active", t);
  }
};
/**
 * @license
 * Copyright (c) 2021 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
let Na = !1;
window.addEventListener(
  "keydown",
  () => {
    Na = !0;
  },
  { capture: !0 }
);
window.addEventListener(
  "mousedown",
  () => {
    Na = !1;
  },
  { capture: !0 }
);
function qn() {
  let i = document.activeElement || document.body;
  for (; i.shadowRoot && i.shadowRoot.activeElement; )
    i = i.shadowRoot.activeElement;
  return i;
}
function Rh() {
  return Na;
}
function Lh(i) {
  const e = i.style;
  if (e.visibility === "hidden" || e.display === "none")
    return !0;
  const t = window.getComputedStyle(i);
  return t.visibility === "hidden" || t.display === "none";
}
function Jy(i, e) {
  const t = Math.max(i.tabIndex, 0), r = Math.max(e.tabIndex, 0);
  return t === 0 || r === 0 ? r > t : t > r;
}
function Xy(i, e) {
  const t = [];
  for (; i.length > 0 && e.length > 0; )
    Jy(i[0], e[0]) ? t.push(e.shift()) : t.push(i.shift());
  return t.concat(i, e);
}
function Wn(i) {
  const e = i.length;
  if (e < 2)
    return i;
  const t = Math.ceil(e / 2), r = Wn(i.slice(0, t)), s = Wn(i.slice(t));
  return Xy(r, s);
}
function Vs(i) {
  return i.offsetParent === null && i.clientWidth === 0 && i.clientHeight === 0 ? !0 : Lh(i);
}
function ev(i) {
  return i.matches('[tabindex="-1"]') ? !1 : i.matches("input, select, textarea, button, object") ? i.matches(":not([disabled])") : i.matches("a[href], area[href], iframe, [tabindex], [contentEditable]");
}
function Fa(i) {
  return i.getRootNode().activeElement === i;
}
function tv(i) {
  if (!ev(i))
    return -1;
  const e = i.getAttribute("tabindex") || 0;
  return Number(e);
}
function Vh(i, e) {
  if (i.nodeType !== Node.ELEMENT_NODE || Lh(i))
    return !1;
  const t = (
    /** @type {HTMLElement} */
    i
  ), r = tv(t);
  let s = r > 0;
  r >= 0 && e.push(t);
  let o = [];
  return t.localName === "slot" ? o = t.assignedNodes({ flatten: !0 }) : o = (t.shadowRoot || t).children, [...o].forEach((n) => {
    s = Vh(n, e) || s;
  }), s;
}
function rv(i) {
  const e = [];
  return Vh(i, e) ? Wn(e) : e;
}
/**
 * @license
 * Copyright (c) 2021 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Hi = Y(
  (i) => class extends i {
    /**
     * @protected
     * @return {boolean}
     */
    get _keyboardActive() {
      return Rh();
    }
    /** @protected */
    ready() {
      this.addEventListener("focusin", (t) => {
        this._shouldSetFocus(t) && this._setFocused(!0);
      }), this.addEventListener("focusout", (t) => {
        this._shouldRemoveFocus(t) && this._setFocused(!1);
      }), super.ready();
    }
    /** @protected */
    disconnectedCallback() {
      super.disconnectedCallback(), this.hasAttribute("focused") && this._setFocused(!1);
    }
    /**
     * Override to change how focused and focus-ring attributes are set.
     *
     * @param {boolean} focused
     * @protected
     */
    _setFocused(t) {
      this.toggleAttribute("focused", t), this.toggleAttribute("focus-ring", t && this._keyboardActive);
    }
    /**
     * Override to define if the field receives focus based on the event.
     *
     * @param {FocusEvent} _event
     * @return {boolean}
     * @protected
     */
    _shouldSetFocus(t) {
      return !0;
    }
    /**
     * Override to define if the field loses focus based on the event.
     *
     * @param {FocusEvent} _event
     * @return {boolean}
     * @protected
     */
    _shouldRemoveFocus(t) {
      return !0;
    }
  }
);
/**
 * @license
 * Copyright (c) 2021 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Ra = (i) => class extends Li(i) {
  static get properties() {
    return {
      /**
       * Indicates whether the element can be focused and where it participates in sequential keyboard navigation.
       *
       * @protected
       */
      tabindex: {
        type: Number,
        reflectToAttribute: !0,
        observer: "_tabindexChanged"
      },
      /**
       * Stores the last known tabindex since the element has been disabled.
       *
       * @protected
       */
      _lastTabIndex: {
        type: Number
      }
    };
  }
  /**
   * When the element gets disabled, the observer saves the last known tabindex
   * and makes the element not focusable by setting tabindex to -1.
   * As soon as the element gets enabled, the observer restores the last known tabindex
   * so that the element can be focusable again.
   *
   * @protected
   * @override
   */
  _disabledChanged(t, r) {
    super._disabledChanged(t, r), t ? (this.tabindex !== void 0 && (this._lastTabIndex = this.tabindex), this.tabindex = -1) : r && (this.tabindex = this._lastTabIndex);
  }
  /**
   * When the user has changed tabindex while the element is disabled,
   * the observer reverts tabindex to -1 and rather saves the new tabindex value to apply it later.
   * The new value will be applied as soon as the element becomes enabled.
   *
   * @protected
   */
  _tabindexChanged(t) {
    this.disabled && t !== -1 && (this._lastTabIndex = t, this.tabindex = -1);
  }
};
/**
 * @license
 * Copyright (c) 2021 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const La = Y(
  (i) => class extends Hi(Ra(i)) {
    static get properties() {
      return {
        /**
         * Specify that this control should have input focus when the page loads.
         */
        autofocus: {
          type: Boolean
        },
        /**
         * A reference to the focusable element controlled by the mixin.
         * It can be an input, textarea, button or any element with tabindex > -1.
         *
         * Any component implementing this mixin is expected to provide it
         * by using `this._setFocusElement(input)` Polymer API.
         *
         * Toggling `tabindex` attribute on the host element propagates its value to `focusElement`.
         *
         * @protected
         * @type {!HTMLElement}
         */
        focusElement: {
          type: Object,
          readOnly: !0,
          observer: "_focusElementChanged"
        },
        /**
         * Override the property from `TabIndexMixin`
         * to ensure the `tabindex` attribute of the focus element
         * will be restored to `0` after re-enabling the element.
         *
         * @protected
         * @override
         */
        _lastTabIndex: {
          value: 0
        }
      };
    }
    constructor() {
      super(), this._boundOnBlur = this._onBlur.bind(this), this._boundOnFocus = this._onFocus.bind(this);
    }
    /** @protected */
    ready() {
      super.ready(), this.autofocus && !this.disabled && requestAnimationFrame(() => {
        this.focus(), this.setAttribute("focus-ring", "");
      });
    }
    /**
     * @protected
     * @override
     */
    focus() {
      this.focusElement && !this.disabled && this.focusElement.focus();
    }
    /**
     * @protected
     * @override
     */
    blur() {
      this.focusElement && this.focusElement.blur();
    }
    /**
     * @protected
     * @override
     */
    click() {
      this.focusElement && !this.disabled && this.focusElement.click();
    }
    /** @protected */
    _focusElementChanged(t, r) {
      t ? (t.disabled = this.disabled, this._addFocusListeners(t), this.__forwardTabIndex(this.tabindex)) : r && this._removeFocusListeners(r);
    }
    /**
     * @param {HTMLElement} element
     * @protected
     */
    _addFocusListeners(t) {
      t.addEventListener("blur", this._boundOnBlur), t.addEventListener("focus", this._boundOnFocus);
    }
    /**
     * @param {HTMLElement} element
     * @protected
     */
    _removeFocusListeners(t) {
      t.removeEventListener("blur", this._boundOnBlur), t.removeEventListener("focus", this._boundOnFocus);
    }
    /**
     * Focus event does not bubble, so we dispatch it manually
     * on the host element to support adding focus listeners
     * when the focusable element is placed in light DOM.
     * @param {FocusEvent} event
     * @protected
     */
    _onFocus(t) {
      t.stopPropagation(), this.dispatchEvent(new Event("focus"));
    }
    /**
     * Blur event does not bubble, so we dispatch it manually
     * on the host element to support adding blur listeners
     * when the focusable element is placed in light DOM.
     * @param {FocusEvent} event
     * @protected
     */
    _onBlur(t) {
      t.stopPropagation(), this.dispatchEvent(new Event("blur"));
    }
    /**
     * @param {FocusEvent} event
     * @return {boolean}
     * @protected
     * @override
     */
    _shouldSetFocus(t) {
      return t.target === this.focusElement;
    }
    /**
     * @param {FocusEvent} event
     * @return {boolean}
     * @protected
     * @override
     */
    _shouldRemoveFocus(t) {
      return t.target === this.focusElement;
    }
    /**
     * @param {boolean} disabled
     * @param {boolean} oldDisabled
     * @protected
     * @override
     */
    _disabledChanged(t, r) {
      super._disabledChanged(t, r), this.focusElement && (this.focusElement.disabled = t), t && this.blur();
    }
    /**
     * Override an observer from `TabindexMixin`.
     * Do not call super to remove tabindex attribute
     * from the host after it has been forwarded.
     * @param {string} tabindex
     * @protected
     * @override
     */
    _tabindexChanged(t) {
      this.__forwardTabIndex(t);
    }
    /** @private */
    __forwardTabIndex(t) {
      t !== void 0 && this.focusElement && (this.focusElement.tabIndex = t, t !== -1 && (this.tabindex = void 0)), this.disabled && t && (t !== -1 && (this._lastTabIndex = t), this.tabindex = void 0);
    }
  }
);
/**
 * @license
 * Copyright (c) 2021 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Hh = Y(
  (i) => class extends i {
    static get properties() {
      return {
        /**
         * A target element to which attributes and properties are delegated.
         * @protected
         */
        stateTarget: {
          type: Object,
          observer: "_stateTargetChanged"
        }
      };
    }
    /**
     * An array of the host attributes to delegate to the target element.
     */
    static get delegateAttrs() {
      return [];
    }
    /**
     * An array of the host properties to delegate to the target element.
     */
    static get delegateProps() {
      return [];
    }
    /** @protected */
    ready() {
      super.ready(), this._createDelegateAttrsObserver(), this._createDelegatePropsObserver();
    }
    /** @protected */
    _stateTargetChanged(t) {
      t && (this._ensureAttrsDelegated(), this._ensurePropsDelegated());
    }
    /** @protected */
    _createDelegateAttrsObserver() {
      this._createMethodObserver(`_delegateAttrsChanged(${this.constructor.delegateAttrs.join(", ")})`);
    }
    /** @protected */
    _createDelegatePropsObserver() {
      this._createMethodObserver(`_delegatePropsChanged(${this.constructor.delegateProps.join(", ")})`);
    }
    /** @protected */
    _ensureAttrsDelegated() {
      this.constructor.delegateAttrs.forEach((t) => {
        this._delegateAttribute(t, this[t]);
      });
    }
    /** @protected */
    _ensurePropsDelegated() {
      this.constructor.delegateProps.forEach((t) => {
        this._delegateProperty(t, this[t]);
      });
    }
    /** @protected */
    _delegateAttrsChanged(...t) {
      this.constructor.delegateAttrs.forEach((r, s) => {
        this._delegateAttribute(r, t[s]);
      });
    }
    /** @protected */
    _delegatePropsChanged(...t) {
      this.constructor.delegateProps.forEach((r, s) => {
        this._delegateProperty(r, t[s]);
      });
    }
    /** @protected */
    _delegateAttribute(t, r) {
      this.stateTarget && (t === "invalid" && this._delegateAttribute("aria-invalid", r ? "true" : !1), typeof r == "boolean" ? this.stateTarget.toggleAttribute(t, r) : r ? this.stateTarget.setAttribute(t, r) : this.stateTarget.removeAttribute(t));
    }
    /** @protected */
    _delegateProperty(t, r) {
      this.stateTarget && (this.stateTarget[t] = r);
    }
  }
);
/**
 * @license
 * Copyright (c) 2021 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const ho = Y(
  (i) => class extends i {
    static get properties() {
      return {
        /**
         * A reference to the input element controlled by the mixin.
         * Any component implementing this mixin is expected to provide it
         * by using `this._setInputElement(input)` Polymer API.
         *
         * A typical case is using `InputController` that does this automatically.
         * However, the input element does not have to always be native <input>:
         * as an example, <vaadin-combo-box-light> accepts other components.
         *
         * @protected
         * @type {!HTMLElement}
         */
        inputElement: {
          type: Object,
          readOnly: !0,
          observer: "_inputElementChanged"
        },
        /**
         * String used to define input type.
         * @protected
         */
        type: {
          type: String,
          readOnly: !0
        },
        /**
         * The value of the field.
         */
        value: {
          type: String,
          value: "",
          observer: "_valueChanged",
          notify: !0,
          sync: !0
        },
        /**
         * Whether the input element has a non-empty value.
         *
         * @protected
         */
        _hasInputValue: {
          type: Boolean,
          value: !1,
          observer: "_hasInputValueChanged"
        }
      };
    }
    constructor() {
      super(), this._boundOnInput = this.__onInput.bind(this), this._boundOnChange = this._onChange.bind(this);
    }
    /**
     * Indicates whether the value is different from the default one.
     * Override if the `value` property has a type other than `string`.
     *
     * @protected
     */
    get _hasValue() {
      return this.value != null && this.value !== "";
    }
    /**
     * A property for accessing the input element's value.
     *
     * Override this getter if the property is different from the default `value` one.
     *
     * @protected
     * @return {string}
     */
    get _inputElementValueProperty() {
      return "value";
    }
    /**
     * The input element's value.
     *
     * @protected
     * @return {string}
     */
    get _inputElementValue() {
      return this.inputElement ? this.inputElement[this._inputElementValueProperty] : void 0;
    }
    /**
     * The input element's value.
     *
     * @protected
     */
    set _inputElementValue(t) {
      this.inputElement && (this.inputElement[this._inputElementValueProperty] = t);
    }
    /**
     * Clear the value of the field.
     */
    clear() {
      this._hasInputValue = !1, this.value = "", this._inputElementValue = "";
    }
    /**
     * Add event listeners to the input element instance.
     * Override this method to add custom listeners.
     * @param {!HTMLElement} input
     * @protected
     */
    _addInputListeners(t) {
      t.addEventListener("input", this._boundOnInput), t.addEventListener("change", this._boundOnChange);
    }
    /**
     * Remove event listeners from the input element instance.
     * @param {!HTMLElement} input
     * @protected
     */
    _removeInputListeners(t) {
      t.removeEventListener("input", this._boundOnInput), t.removeEventListener("change", this._boundOnChange);
    }
    /**
     * A method to forward the value property set on the field
     * programmatically back to the input element value.
     * Override this method to perform additional checks,
     * for example to skip this in certain conditions.
     * @param {string} value
     * @protected
     */
    _forwardInputValue(t) {
      this.inputElement && (this._inputElementValue = t ?? "");
    }
    /**
     * @param {HTMLElement | undefined} input
     * @param {HTMLElement | undefined} oldInput
     * @protected
     */
    _inputElementChanged(t, r) {
      t ? this._addInputListeners(t) : r && this._removeInputListeners(r);
    }
    /**
     * Observer to notify about the change of private property.
     *
     * @private
     */
    _hasInputValueChanged(t, r) {
      (t || r) && this.dispatchEvent(new CustomEvent("has-input-value-changed"));
    }
    /**
     * An input event listener used to update `_hasInputValue` property.
     * Do not override this method.
     *
     * @param {Event} event
     * @private
     */
    __onInput(t) {
      this._setHasInputValue(t), this._onInput(t);
    }
    /**
     * An input event listener used to update the field value.
     *
     * @param {Event} event
     * @protected
     */
    _onInput(t) {
      const r = t.composedPath()[0];
      this.__userInput = t.isTrusted, this.value = r.value, this.__userInput = !1;
    }
    /**
     * A change event listener.
     * Override this method with an actual implementation.
     * @param {Event} _event
     * @protected
     */
    _onChange(t) {
    }
    /**
     * Toggle the has-value attribute based on the value property.
     *
     * @param {boolean} hasValue
     * @protected
     */
    _toggleHasValue(t) {
      this.toggleAttribute("has-value", t);
    }
    /**
     * Observer called when a value property changes.
     * @param {string | undefined} newVal
     * @param {string | undefined} oldVal
     * @protected
     */
    _valueChanged(t, r) {
      this._toggleHasValue(this._hasValue), !(t === "" && r === void 0) && (this.__userInput || this._forwardInputValue(t));
    }
    /**
     * Sets the `_hasInputValue` property based on the `input` event.
     *
     * @param {InputEvent} event
     * @protected
     */
    _setHasInputValue(t) {
      const r = t.composedPath()[0];
      this._hasInputValue = r.value.length > 0;
    }
  }
);
/**
 * @license
 * Copyright (c) 2021 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const iv = Y(
  (i) => class extends Hh(Li(ho(i))) {
    static get properties() {
      return {
        /**
         * True if the element is checked.
         * @type {boolean}
         */
        checked: {
          type: Boolean,
          value: !1,
          notify: !0,
          reflectToAttribute: !0
        }
      };
    }
    static get delegateProps() {
      return [...super.delegateProps, "checked"];
    }
    /**
     * @param {Event} event
     * @protected
     * @override
     */
    _onChange(t) {
      const r = t.target;
      this._toggleChecked(r.checked), Fa(r) || r.focus();
    }
    /** @protected */
    _toggleChecked(t) {
      this.checked = t;
    }
  }
);
/**
 * @license
 * Copyright (c) 2021 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class Bi extends Ke {
  constructor(e, t) {
    super(e, "input", "input", {
      initializer: (r, s) => {
        s.value && (r.value = s.value), s.type && r.setAttribute("type", s.type), r.id = this.defaultId, typeof t == "function" && t(r);
      },
      useUniqueId: !0
    });
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const rt = Y((i) => typeof i.prototype.addController == "function" ? i : class extends i {
  constructor() {
    super(), this.__controllers = /* @__PURE__ */ new Set();
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback(), this.__controllers.forEach((t) => {
      t.hostConnected && t.hostConnected();
    });
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback(), this.__controllers.forEach((t) => {
      t.hostDisconnected && t.hostDisconnected();
    });
  }
  /**
   * Registers a controller to participate in the element update cycle.
   *
   * @param {ReactiveController} controller
   * @protected
   */
  addController(t) {
    this.__controllers.add(t), this.$ !== void 0 && this.isConnected && t.hostConnected && t.hostConnected();
  }
  /**
   * Removes a controller from the element.
   *
   * @param {ReactiveController} controller
   * @protected
   */
  removeController(t) {
    this.__controllers.delete(t);
  }
});
/**
 * @license
 * Copyright (c) 2022 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class Va extends Ke {
  constructor(e, t, r, s = {}) {
    super(e, t, r, { ...s, useUniqueId: !0 });
  }
  /**
   * Override to initialize the newly added custom node.
   *
   * @param {Node} node
   * @protected
   * @override
   */
  initCustomNode(e) {
    this.__updateNodeId(e), this.__notifyChange(e);
  }
  /**
   * Override to notify the controller host about removal of
   * the custom node, and to apply the default one if needed.
   *
   * @param {Node} _node
   * @protected
   * @override
   */
  teardownNode(e) {
    const t = this.getSlotChild();
    t && t !== this.defaultNode ? this.__notifyChange(t) : (this.restoreDefaultNode(), this.updateDefaultNode(this.node));
  }
  /**
   * Override method inherited from `SlotMixin`
   * to set ID attribute on the default node.
   *
   * @return {Node}
   * @protected
   * @override
   */
  attachDefaultNode() {
    const e = super.attachDefaultNode();
    return e && this.__updateNodeId(e), e;
  }
  /**
   * Override to restore default node when a custom one is removed.
   *
   * @protected
   */
  restoreDefaultNode() {
  }
  /**
   * Override to update default node text on property change.
   *
   * @param {Node} node
   * @protected
   */
  updateDefaultNode(e) {
    this.__notifyChange(e);
  }
  /**
   * Setup the mutation observer on the node to update ID and notify host.
   * Node doesn't get observed automatically until this method is called.
   *
   * @param {Node} node
   * @protected
   */
  observeNode(e) {
    this.__nodeObserver && this.__nodeObserver.disconnect(), this.__nodeObserver = new MutationObserver((t) => {
      t.forEach((r) => {
        const s = r.target, o = s === this.node;
        r.type === "attributes" ? o && this.__updateNodeId(s) : (o || s.parentElement === this.node) && this.__notifyChange(this.node);
      });
    }), this.__nodeObserver.observe(e, {
      attributes: !0,
      attributeFilter: ["id"],
      childList: !0,
      subtree: !0,
      characterData: !0
    });
  }
  /**
   * Returns true if a node is an HTML element with children,
   * or is a defined custom element, or has non-empty text.
   *
   * @param {Node} node
   * @return {boolean}
   * @private
   */
  __hasContent(e) {
    return e ? e.nodeType === Node.ELEMENT_NODE && (customElements.get(e.localName) || e.children.length > 0) || e.textContent && e.textContent.trim() !== "" : !1;
  }
  /**
   * Fire an event to notify the controller host about node changes.
   *
   * @param {Node} node
   * @private
   */
  __notifyChange(e) {
    this.dispatchEvent(
      new CustomEvent("slot-content-changed", {
        detail: { hasContent: this.__hasContent(e), node: e }
      })
    );
  }
  /**
   * Set default ID on the node in case it is an HTML element.
   *
   * @param {Node} node
   * @private
   */
  __updateNodeId(e) {
    const t = !this.nodes || e === this.nodes[0];
    e.nodeType === Node.ELEMENT_NODE && (!this.multiple || t) && !e.id && (e.id = this.defaultId);
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class sv extends Va {
  constructor(e) {
    super(e, "label", "label");
  }
  /**
   * Set label based on corresponding host property.
   *
   * @param {string} label
   */
  setLabel(e) {
    this.label = e, this.getSlotChild() || this.restoreDefaultNode(), this.node === this.defaultNode && this.updateDefaultNode(this.node);
  }
  /**
   * Override method inherited from `SlotChildObserveController`
   * to restore and observe the default label element.
   *
   * @protected
   * @override
   */
  restoreDefaultNode() {
    const { label: e } = this;
    if (e && e.trim() !== "") {
      const t = this.attachDefaultNode();
      this.observeNode(t);
    }
  }
  /**
   * Override method inherited from `SlotChildObserveController`
   * to update the default label element text content.
   *
   * @param {Node | undefined} node
   * @protected
   * @override
   */
  updateDefaultNode(e) {
    e && (e.textContent = this.label), super.updateDefaultNode(e);
  }
  /**
   * Override to observe the newly added custom node.
   *
   * @param {Node} node
   * @protected
   * @override
   */
  initCustomNode(e) {
    super.initCustomNode(e), this.observeNode(e);
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Bh = Y(
  (i) => class extends rt(i) {
    static get properties() {
      return {
        /**
         * The label text for the input node.
         * When no light dom defined via [slot=label], this value will be used.
         */
        label: {
          type: String,
          observer: "_labelChanged"
        }
      };
    }
    constructor() {
      super(), this._labelController = new sv(this), this._labelController.addEventListener("slot-content-changed", (t) => {
        this.toggleAttribute("has-label", t.detail.hasContent);
      });
    }
    /** @protected */
    get _labelId() {
      const t = this._labelNode;
      return t && t.id;
    }
    /** @protected */
    get _labelNode() {
      return this._labelController.node;
    }
    /** @protected */
    ready() {
      super.ready(), this.addController(this._labelController);
    }
    /** @protected */
    _labelChanged(t) {
      this._labelController.setLabel(t);
    }
  }
);
/**
 * @license
 * Copyright (c) 2021 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class Ui {
  constructor(e, t) {
    this.input = e, this.__preventDuplicateLabelClick = this.__preventDuplicateLabelClick.bind(this), t.addEventListener("slot-content-changed", (r) => {
      this.__initLabel(r.detail.node);
    }), this.__initLabel(t.node);
  }
  /**
   * @param {HTMLElement} label
   * @private
   */
  __initLabel(e) {
    e && (e.addEventListener("click", this.__preventDuplicateLabelClick), this.input && e.setAttribute("for", this.input.id));
  }
  /**
   * The native platform fires an event for both the click on the label, and also
   * the subsequent click on the native input element caused by label click.
   * This results in two click events arriving at the host, but we only want one.
   * This method prevents the duplicate click and ensures the correct isTrusted event
   * with the correct event.target arrives at the host.
   * @private
   */
  __preventDuplicateLabelClick() {
    const e = (t) => {
      t.stopImmediatePropagation(), this.input.removeEventListener("click", e);
    };
    this.input.addEventListener("click", e);
  }
}
/**
 * @license
 * Copyright (c) 2017 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const ov = (i) => class extends Bh(iv(La(Fh(i)))) {
  static get properties() {
    return {
      /**
       * True if the checkbox is in the indeterminate state which means
       * it is not possible to say whether it is checked or unchecked.
       * The state is reset once the user switches the checkbox by hand.
       *
       * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox#Indeterminate_state_checkboxes
       *
       * @type {boolean}
       */
      indeterminate: {
        type: Boolean,
        notify: !0,
        value: !1,
        reflectToAttribute: !0
      },
      /**
       * The name of the checkbox.
       *
       * @type {string}
       */
      name: {
        type: String,
        value: ""
      }
    };
  }
  /** @override */
  static get delegateProps() {
    return [...super.delegateProps, "indeterminate"];
  }
  /** @override */
  static get delegateAttrs() {
    return [...super.delegateAttrs, "name"];
  }
  constructor() {
    super(), this._setType("checkbox"), this.value = "on";
  }
  /** @protected */
  ready() {
    super.ready(), this.addController(
      new Bi(this, (t) => {
        this._setInputElement(t), this._setFocusElement(t), this.stateTarget = t, this.ariaTarget = t;
      })
    ), this.addController(new Ui(this.inputElement, this._labelController));
  }
  /**
   * Override method inherited from `ActiveMixin` to prevent setting
   * `active` attribute when clicking a link placed inside the label.
   *
   * @param {Event} event
   * @return {boolean}
   * @protected
   * @override
   */
  _shouldSetActive(t) {
    return t.target.localName === "a" ? !1 : super._shouldSetActive(t);
  }
  /**
   * Override method inherited from `CheckedMixin` to reset
   * `indeterminate` state checkbox is toggled by the user.
   *
   * @param {boolean} checked
   * @protected
   * @override
   */
  _toggleChecked(t) {
    this.indeterminate && (this.indeterminate = !1), super._toggleChecked(t);
  }
};
/**
 * @license
 * Copyright (c) 2017 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const nv = y`
  :host {
    display: inline-block;
  }

  :host([hidden]) {
    display: none !important;
  }

  :host([disabled]) {
    -webkit-tap-highlight-color: transparent;
  }

  .vaadin-checkbox-container {
    display: grid;
    grid-template-columns: auto 1fr;
    align-items: baseline;
  }

  [part='checkbox'],
  ::slotted(input),
  ::slotted(label) {
    grid-row: 1;
  }

  [part='checkbox'],
  ::slotted(input) {
    grid-column: 1;
  }

  [part='checkbox'] {
    width: var(--vaadin-checkbox-size, 1em);
    height: var(--vaadin-checkbox-size, 1em);
    --_input-border-width: var(--vaadin-input-field-border-width, 0);
    --_input-border-color: var(--vaadin-input-field-border-color, transparent);
    box-shadow: inset 0 0 0 var(--_input-border-width, 0) var(--_input-border-color);
  }

  [part='checkbox']::before {
    display: block;
    content: '\\202F';
    line-height: var(--vaadin-checkbox-size, 1em);
    contain: paint;
  }

  /* visually hidden */
  ::slotted(input) {
    opacity: 0;
    cursor: inherit;
    margin: 0;
    align-self: stretch;
    -webkit-appearance: none;
    width: initial;
    height: initial;
  }

  @media (forced-colors: active) {
    [part='checkbox'] {
      outline: 1px solid;
      outline-offset: -1px;
    }

    :host([disabled]) [part='checkbox'],
    :host([disabled]) [part='checkbox']::after {
      outline-color: GrayText;
    }

    :host(:is([checked], [indeterminate])) [part='checkbox']::after {
      outline: 1px solid;
      outline-offset: -1px;
      border-radius: inherit;
    }

    :host([focused]) [part='checkbox'],
    :host([focused]) [part='checkbox']::after {
      outline-width: 2px;
    }
  }
`;
/**
 * @license
 * Copyright (c) 2017 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
C("vaadin-checkbox", nv, { moduleId: "vaadin-checkbox-styles" });
class av extends ov(At(X(N))) {
  static get is() {
    return "vaadin-checkbox";
  }
  static get template() {
    return U`
      <div class="vaadin-checkbox-container">
        <div part="checkbox" aria-hidden="true"></div>
        <slot name="input"></slot>
        <slot name="label"></slot>
      </div>
      <slot name="tooltip"></slot>
    `;
  }
  /** @protected */
  ready() {
    super.ready(), this._tooltipController = new Et(this), this._tooltipController.setAriaTarget(this.inputElement), this.addController(this._tooltipController);
  }
}
O(av);
C(
  "vaadin-grid",
  y`
    :host {
      font-family: var(--lumo-font-family);
      font-size: var(--lumo-font-size-m);
      line-height: var(--lumo-line-height-s);
      color: var(--lumo-body-text-color);
      background-color: var(--lumo-base-color);
      box-sizing: border-box;
      -webkit-text-size-adjust: 100%;
      -webkit-tap-highlight-color: transparent;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;

      /* For internal use only */
      --_lumo-grid-border-color: var(--lumo-contrast-20pct);
      --_lumo-grid-secondary-border-color: var(--lumo-contrast-10pct);
      --_lumo-grid-border-width: 1px;
      --_lumo-grid-selected-row-color: var(--lumo-primary-color-10pct);
    }

    /* No (outer) border */

    :host(:not([theme~='no-border'])) {
      border: var(--_lumo-grid-border-width) solid var(--_lumo-grid-border-color);
    }

    :host([disabled]) {
      opacity: 0.7;
    }

    /* Cell styles */

    [part~='cell'] {
      min-height: var(--lumo-size-m);
      background-color: var(--lumo-base-color);
    }

    [part~='cell'] ::slotted(vaadin-grid-cell-content) {
      cursor: default;
      padding: var(--lumo-space-xs) var(--lumo-space-m);
    }

    /* Apply row borders by default and introduce the "no-row-borders" variant */
    :host(:not([theme~='no-row-borders'])) [part~='cell']:not([part~='details-cell']) {
      border-top: var(--_lumo-grid-border-width) solid var(--_lumo-grid-secondary-border-color);
    }

    /* Hide first body row top border */
    :host(:not([theme~='no-row-borders'])) [part~='first-row'] [part~='cell']:not([part~='details-cell']) {
      border-top: 0;
      min-height: calc(var(--lumo-size-m) - var(--_lumo-grid-border-width));
    }

    /* Focus-ring */

    [part~='row'] {
      position: relative;
    }

    [part~='row']:focus,
    [part~='focused-cell']:focus {
      outline: none;
    }

    :host([navigating]) [part~='row']:focus::before,
    :host([navigating]) [part~='focused-cell']:focus::before {
      content: '';
      position: absolute;
      inset: 0;
      pointer-events: none;
      box-shadow: inset 0 0 0 2px var(--lumo-primary-color-50pct);
    }

    :host([navigating]) [part~='row']:focus::before {
      transform: translateX(calc(-1 * var(--_grid-horizontal-scroll-position)));
      z-index: 3;
    }

    /* Drag and Drop styles */
    :host([dragover])::after {
      content: '';
      position: absolute;
      z-index: 100;
      inset: 0;
      pointer-events: none;
      box-shadow: inset 0 0 0 2px var(--lumo-primary-color-50pct);
    }

    [part~='row'][dragover] {
      z-index: 100 !important;
    }

    [part~='row'][dragover] [part~='cell'] {
      overflow: visible;
    }

    [part~='row'][dragover] [part~='cell']::after {
      content: '';
      position: absolute;
      inset: 0;
      height: calc(var(--_lumo-grid-border-width) + 2px);
      pointer-events: none;
      background: var(--lumo-primary-color-50pct);
    }

    [part~='row'][dragover] [part~='cell'][last-frozen]::after {
      right: -1px;
    }

    :host([theme~='no-row-borders']) [dragover] [part~='cell']::after {
      height: 2px;
    }

    [part~='row'][dragover='below'] [part~='cell']::after {
      top: 100%;
      bottom: auto;
      margin-top: -1px;
    }

    :host([all-rows-visible]) [part~='last-row'][dragover='below'] [part~='cell']::after {
      height: 1px;
    }

    [part~='row'][dragover='above'] [part~='cell']::after {
      top: auto;
      bottom: 100%;
      margin-bottom: -1px;
    }

    [part~='row'][details-opened][dragover='below'] [part~='cell']:not([part~='details-cell'])::after,
    [part~='row'][details-opened][dragover='above'] [part~='details-cell']::after {
      display: none;
    }

    [part~='row'][dragover][dragover='on-top'] [part~='cell']::after {
      height: 100%;
      opacity: 0.5;
    }

    [part~='row'][dragstart] [part~='cell'] {
      border: none !important;
      box-shadow: none !important;
    }

    [part~='row'][dragstart] [part~='cell'][last-column] {
      border-radius: 0 var(--lumo-border-radius-s) var(--lumo-border-radius-s) 0;
    }

    [part~='row'][dragstart] [part~='cell'][first-column] {
      border-radius: var(--lumo-border-radius-s) 0 0 var(--lumo-border-radius-s);
    }

    #scroller [part~='row'][dragstart]:not([dragstart=''])::after {
      display: block;
      position: absolute;
      left: var(--_grid-drag-start-x);
      top: var(--_grid-drag-start-y);
      z-index: 100;
      content: attr(dragstart);
      align-items: center;
      justify-content: center;
      box-sizing: border-box;
      padding: calc(var(--lumo-space-xs) * 0.8);
      color: var(--lumo-error-contrast-color);
      background-color: var(--lumo-error-color);
      border-radius: var(--lumo-border-radius-m);
      font-family: var(--lumo-font-family);
      font-size: var(--lumo-font-size-xxs);
      line-height: 1;
      font-weight: 500;
      text-transform: initial;
      letter-spacing: initial;
      min-width: calc(var(--lumo-size-s) * 0.7);
      text-align: center;
    }

    /* Headers and footers */

    [part~='header-cell'] ::slotted(vaadin-grid-cell-content),
    [part~='footer-cell'] ::slotted(vaadin-grid-cell-content),
    [part~='reorder-ghost'] {
      font-size: var(--lumo-font-size-s);
      font-weight: 500;
    }

    [part~='footer-cell'] ::slotted(vaadin-grid-cell-content) {
      font-weight: 400;
    }

    [part~='row']:only-child [part~='header-cell'] {
      min-height: var(--lumo-size-xl);
    }

    /* Header borders */

    /* Hide first header row top border */
    :host(:not([theme~='no-row-borders'])) [part~='row']:first-child [part~='header-cell'] {
      border-top: 0;
    }

    [part~='row']:last-child [part~='header-cell'] {
      border-bottom: var(--_lumo-grid-border-width) solid transparent;
    }

    :host(:not([theme~='no-row-borders'])) [part~='row']:last-child [part~='header-cell'] {
      border-bottom-color: var(--_lumo-grid-secondary-border-color);
    }

    /* Overflow uses a stronger border color */
    :host([overflow~='top']) [part~='row']:last-child [part~='header-cell'] {
      border-bottom-color: var(--_lumo-grid-border-color);
    }

    /* Footer borders */

    [part~='row']:first-child [part~='footer-cell'] {
      border-top: var(--_lumo-grid-border-width) solid transparent;
    }

    :host(:not([theme~='no-row-borders'])) [part~='row']:first-child [part~='footer-cell'] {
      border-top-color: var(--_lumo-grid-secondary-border-color);
    }

    /* Overflow uses a stronger border color */
    :host([overflow~='bottom']) [part~='row']:first-child [part~='footer-cell'] {
      border-top-color: var(--_lumo-grid-border-color);
    }

    /* Column reordering */

    :host([reordering]) [part~='cell'] {
      background: linear-gradient(var(--lumo-shade-20pct), var(--lumo-shade-20pct)) var(--lumo-base-color);
    }

    :host([reordering]) [part~='cell'][reorder-status='allowed'] {
      background: var(--lumo-base-color);
    }

    :host([reordering]) [part~='cell'][reorder-status='dragging'] {
      background: linear-gradient(var(--lumo-contrast-5pct), var(--lumo-contrast-5pct)) var(--lumo-base-color);
    }

    [part~='reorder-ghost'] {
      opacity: 0.85;
      box-shadow: var(--lumo-box-shadow-s);
      /* TODO Use the same styles as for the cell element (reorder-ghost copies styles from the cell element) */
      padding: var(--lumo-space-s) var(--lumo-space-m) !important;
    }

    /* Column resizing */

    [part='resize-handle'] {
      width: 3px;
      background-color: var(--lumo-primary-color-50pct);
      opacity: 0;
      transition: opacity 0.2s;
    }

    :host(:not([reordering])) *:not([column-resizing]) [part~='cell']:hover [part='resize-handle'],
    [part='resize-handle']:active {
      opacity: 1;
      transition-delay: 0.15s;
    }

    /* Column borders */

    :host([theme~='column-borders']) [part~='cell']:not([last-column]):not([part~='details-cell']) {
      border-right: var(--_lumo-grid-border-width) solid var(--_lumo-grid-secondary-border-color);
    }

    /* Frozen columns */

    [last-frozen] {
      border-right: var(--_lumo-grid-border-width) solid transparent;
      overflow: hidden;
    }

    :host([overflow~='start']) [part~='cell'][last-frozen]:not([part~='details-cell']) {
      border-right-color: var(--_lumo-grid-border-color);
    }

    [first-frozen-to-end] {
      border-left: var(--_lumo-grid-border-width) solid transparent;
    }

    :host([overflow~='end']) [part~='cell'][first-frozen-to-end]:not([part~='details-cell']) {
      border-left-color: var(--_lumo-grid-border-color);
    }

    /* Row stripes */

    :host([theme~='row-stripes']) [part~='even-row'] [part~='body-cell'],
    :host([theme~='row-stripes']) [part~='even-row'] [part~='details-cell'] {
      background-image: linear-gradient(var(--lumo-contrast-5pct), var(--lumo-contrast-5pct));
      background-repeat: repeat-x;
    }

    /* Selected row */

    /* Raise the selected rows above unselected rows (so that box-shadow can cover unselected rows) */
    :host(:not([reordering])) [part~='row'][selected] {
      z-index: 1;
    }

    :host(:not([reordering])) [part~='row'][selected] [part~='body-cell']:not([part~='details-cell']) {
      background-image: linear-gradient(var(--_lumo-grid-selected-row-color), var(--_lumo-grid-selected-row-color));
      background-repeat: repeat;
    }

    /* Cover the border of an unselected row */
    :host(:not([theme~='no-row-borders'])) [part~='row'][selected] [part~='cell']:not([part~='details-cell']) {
      box-shadow: 0 var(--_lumo-grid-border-width) 0 0 var(--_lumo-grid-selected-row-color);
    }

    /* Compact */

    :host([theme~='compact']) [part~='row']:only-child [part~='header-cell'] {
      min-height: var(--lumo-size-m);
    }

    :host([theme~='compact']) [part~='cell'] {
      min-height: var(--lumo-size-s);
    }

    :host([theme~='compact']) [part~='first-row'] [part~='cell']:not([part~='details-cell']) {
      min-height: calc(var(--lumo-size-s) - var(--_lumo-grid-border-width));
    }

    :host([theme~='compact']) [part~='cell'] ::slotted(vaadin-grid-cell-content) {
      padding: var(--lumo-space-xs) var(--lumo-space-s);
    }

    /* Wrap cell contents */

    :host([theme~='wrap-cell-content']) [part~='cell'] ::slotted(vaadin-grid-cell-content) {
      white-space: normal;
    }

    /* RTL specific styles */

    :host([dir='rtl']) [part~='row'][dragstart] [part~='cell'][last-column] {
      border-radius: var(--lumo-border-radius-s) 0 0 var(--lumo-border-radius-s);
    }

    :host([dir='rtl']) [part~='row'][dragstart] [part~='cell'][first-column] {
      border-radius: 0 var(--lumo-border-radius-s) var(--lumo-border-radius-s) 0;
    }

    :host([dir='rtl'][theme~='column-borders']) [part~='cell']:not([last-column]):not([part~='details-cell']) {
      border-right: none;
      border-left: var(--_lumo-grid-border-width) solid var(--_lumo-grid-secondary-border-color);
    }

    :host([dir='rtl']) [last-frozen] {
      border-right: none;
      border-left: var(--_lumo-grid-border-width) solid transparent;
    }

    :host([dir='rtl']) [first-frozen-to-end] {
      border-left: none;
      border-right: var(--_lumo-grid-border-width) solid transparent;
    }

    :host([dir='rtl'][overflow~='start']) [part~='cell'][last-frozen]:not([part~='details-cell']) {
      border-left-color: var(--_lumo-grid-border-color);
    }

    :host([dir='rtl'][overflow~='end']) [part~='cell'][first-frozen-to-end]:not([part~='details-cell']) {
      border-right-color: var(--_lumo-grid-border-color);
    }
  `,
  { moduleId: "lumo-grid" }
);
/**
 * @license
 * Copyright (c) 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function Ct(i, e) {
  return i.split(".").reduce((t, r) => t ? t[r] : void 0, e);
}
/**
 * @license
 * Copyright (c) 2021 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function Ha(i) {
  if (window.Vaadin && window.Vaadin.templateRendererCallback) {
    window.Vaadin.templateRendererCallback(i);
    return;
  }
  i.querySelector("template");
}
/**
 * @license
 * Copyright (c) 2016 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function Tr(i) {
  return i.__cells || Array.from(i.querySelectorAll('[part~="cell"]:not([part~="details-cell"])'));
}
function le(i, e) {
  [...i.children].forEach(e);
}
function Ir(i, e) {
  Tr(i).forEach(e), i.__detailsCell && e(i.__detailsCell);
}
function Uh(i, e, t) {
  let r = 1;
  i.forEach((s) => {
    r % 10 === 0 && (r += 1), s._order = t + r * e, r += 1;
  });
}
function fo(i, e, t) {
  switch (typeof t) {
    case "boolean":
      i.toggleAttribute(e, t);
      break;
    case "string":
      i.setAttribute(e, t);
      break;
    default:
      i.removeAttribute(e);
      break;
  }
}
function kt(i, e, t) {
  e || e === "" ? uo(i, "part", t) : Ia(i, "part", t);
}
function gt(i, e, t) {
  i.forEach((r) => {
    kt(r, t, e);
  });
}
function hi(i, e) {
  const t = Tr(i);
  Object.entries(e).forEach(([r, s]) => {
    fo(i, r, s);
    const o = `${r}-row`;
    kt(i, s, o), gt(t, `${o}-cell`, s);
  });
}
function Tc(i, e) {
  const t = Tr(i);
  Object.entries(e).forEach(([r, s]) => {
    const o = i.getAttribute(r);
    if (fo(i, r, s), o) {
      const n = `${r}-${o}-row`;
      kt(i, !1, n), gt(t, `${n}-cell`, !1);
    }
    if (s) {
      const n = `${r}-${s}-row`;
      kt(i, s, n), gt(t, `${n}-cell`, s);
    }
  });
}
function Ft(i, e, t, r, s) {
  fo(i, e, t), s && kt(i, !1, s), kt(i, t, r || `${e}-cell`);
}
/**
 * @license
 * Copyright (c) 2016 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const qh = (i) => class extends i {
  static get properties() {
    return {
      /**
       * When set to true, the column is user-resizable.
       * @default false
       */
      resizable: {
        type: Boolean,
        value() {
          if (this.localName === "vaadin-grid-column-group")
            return;
          const t = this.parentNode;
          return t && t.localName === "vaadin-grid-column-group" && t.resizable || !1;
        }
      },
      /**
       * When true, the column is frozen. When a column inside of a column group is frozen,
       * all of the sibling columns inside the group will get frozen also.
       * @type {boolean}
       */
      frozen: {
        type: Boolean,
        value: !1
      },
      /**
       * When true, the column is frozen to end of grid.
       *
       * When a column inside of a column group is frozen to end, all of the sibling columns
       * inside the group will get frozen to end also.
       *
       * Column can not be set as `frozen` and `frozenToEnd` at the same time.
       * @attr {boolean} frozen-to-end
       * @type {boolean}
       */
      frozenToEnd: {
        type: Boolean,
        value: !1
      },
      /**
       * When true, the cells for this column will be rendered with the `role` attribute
       * set as `rowheader`, instead of the `gridcell` role value used by default.
       *
       * When a column is set as row header, its cells will be announced by screen readers
       * while navigating to help user identify the current row as uniquely as possible.
       *
       * @attr {boolean} row-header
       * @type {boolean}
       */
      rowHeader: {
        type: Boolean,
        value: !1
      },
      /**
       * When set to true, the cells for this column are hidden.
       */
      hidden: {
        type: Boolean,
        value: !1
      },
      /**
       * Text content to display in the header cell of the column.
       */
      header: {
        type: String
      },
      /**
       * Aligns the columns cell content horizontally.
       * Supported values: "start", "center" and "end".
       * @attr {start|center|end} text-align
       * @type {GridColumnTextAlign | null | undefined}
       */
      textAlign: {
        type: String
      },
      /**
       * @type {boolean}
       * @protected
       */
      _lastFrozen: {
        type: Boolean,
        value: !1
      },
      /**
       * @type {boolean}
       * @protected
       */
      _bodyContentHidden: {
        type: Boolean,
        value: !1
      },
      /**
       * @type {boolean}
       * @protected
       */
      _firstFrozenToEnd: {
        type: Boolean,
        value: !1
      },
      /** @protected */
      _order: Number,
      /** @private */
      _reorderStatus: Boolean,
      /**
       * @type {Array<!HTMLElement>}
       * @protected
       */
      _emptyCells: Array,
      /** @private */
      _headerCell: Object,
      /** @private */
      _footerCell: Object,
      /** @protected */
      _grid: Object,
      /**
       * By default, the Polymer doesn't invoke the observer
       * during initialization if all of its dependencies are `undefined`.
       * This internal property can be used to force initial invocation of an observer
       * even the other dependencies of the observer are `undefined`.
       *
       * @private
       */
      __initialized: {
        type: Boolean,
        value: !0
      },
      /**
       * Custom function for rendering the header content.
       * Receives two arguments:
       *
       * - `root` The header cell content DOM element. Append your content to it.
       * - `column` The `<vaadin-grid-column>` element.
       *
       * @type {GridHeaderFooterRenderer | null | undefined}
       */
      headerRenderer: Function,
      /**
       * Represents the final header renderer computed on the set of observable arguments.
       * It is supposed to be used internally when rendering the header cell content.
       *
       * @protected
       * @type {GridHeaderFooterRenderer | undefined}
       */
      _headerRenderer: {
        type: Function,
        computed: "_computeHeaderRenderer(headerRenderer, header, __initialized)"
      },
      /**
       * Custom function for rendering the footer content.
       * Receives two arguments:
       *
       * - `root` The footer cell content DOM element. Append your content to it.
       * - `column` The `<vaadin-grid-column>` element.
       *
       * @type {GridHeaderFooterRenderer | null | undefined}
       */
      footerRenderer: Function,
      /**
       * Represents the final footer renderer computed on the set of observable arguments.
       * It is supposed to be used internally when rendering the footer cell content.
       *
       * @protected
       * @type {GridHeaderFooterRenderer | undefined}
       */
      _footerRenderer: {
        type: Function,
        computed: "_computeFooterRenderer(footerRenderer, __initialized)"
      },
      /**
       * An internal property that is mainly used by `vaadin-template-renderer`
       * to identify grid column elements.
       *
       * @private
       */
      __gridColumnElement: {
        type: Boolean,
        value: !0
      }
    };
  }
  static get observers() {
    return [
      "_widthChanged(width, _headerCell, _footerCell, _cells.*)",
      "_frozenChanged(frozen, _headerCell, _footerCell, _cells.*)",
      "_frozenToEndChanged(frozenToEnd, _headerCell, _footerCell, _cells.*)",
      "_flexGrowChanged(flexGrow, _headerCell, _footerCell, _cells.*)",
      "_textAlignChanged(textAlign, _cells.*, _headerCell, _footerCell)",
      "_orderChanged(_order, _headerCell, _footerCell, _cells.*)",
      "_lastFrozenChanged(_lastFrozen)",
      "_firstFrozenToEndChanged(_firstFrozenToEnd)",
      "_onRendererOrBindingChanged(_renderer, _cells, _bodyContentHidden, _cells.*, path)",
      "_onHeaderRendererOrBindingChanged(_headerRenderer, _headerCell, path, header)",
      "_onFooterRendererOrBindingChanged(_footerRenderer, _footerCell)",
      "_resizableChanged(resizable, _headerCell)",
      "_reorderStatusChanged(_reorderStatus, _headerCell, _footerCell, _cells.*)",
      "_hiddenChanged(hidden, _headerCell, _footerCell, _cells.*)",
      "_rowHeaderChanged(rowHeader, _cells.*)"
    ];
  }
  /**
   * @return {!Grid | undefined}
   * @protected
   */
  get _grid() {
    return this._gridValue || (this._gridValue = this._findHostGrid()), this._gridValue;
  }
  /**
   * @return {!Array<!HTMLElement>}
   * @protected
   */
  get _allCells() {
    return [].concat(this._cells || []).concat(this._emptyCells || []).concat(this._headerCell).concat(this._footerCell).filter((t) => t);
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback(), requestAnimationFrame(() => {
      this._grid && this._allCells.forEach((t) => {
        t._content.parentNode || this._grid.appendChild(t._content);
      });
    });
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback(), requestAnimationFrame(() => {
      this._grid || this._allCells.forEach((t) => {
        t._content.parentNode && t._content.parentNode.removeChild(t._content);
      });
    }), this._gridValue = void 0;
  }
  /** @protected */
  ready() {
    super.ready(), Ha(this);
  }
  /**
   * @return {!Grid | undefined}
   * @protected
   */
  _findHostGrid() {
    let t = this;
    for (; t && !/^vaadin.*grid(-pro)?$/u.test(t.localName); )
      t = t.assignedSlot ? t.assignedSlot.parentNode : t.parentNode;
    return t || void 0;
  }
  /** @protected */
  _renderHeaderAndFooter() {
    this._renderHeaderCellContent(this._headerRenderer, this._headerCell), this._renderFooterCellContent(this._footerRenderer, this._footerCell);
  }
  /** @private */
  _flexGrowChanged(t) {
    this.parentElement && this.parentElement._columnPropChanged && this.parentElement._columnPropChanged("flexGrow"), this._allCells.forEach((r) => {
      r.style.flexGrow = t;
    });
  }
  /** @private */
  _orderChanged(t) {
    this._allCells.forEach((r) => {
      r.style.order = t;
    });
  }
  /** @private */
  _widthChanged(t) {
    this.parentElement && this.parentElement._columnPropChanged && this.parentElement._columnPropChanged("width"), this._allCells.forEach((r) => {
      r.style.width = t;
    });
  }
  /** @private */
  _frozenChanged(t) {
    this.parentElement && this.parentElement._columnPropChanged && this.parentElement._columnPropChanged("frozen", t), this._allCells.forEach((r) => {
      Ft(r, "frozen", t);
    }), this._grid && this._grid._frozenCellsChanged && this._grid._frozenCellsChanged();
  }
  /** @private */
  _frozenToEndChanged(t) {
    this.parentElement && this.parentElement._columnPropChanged && this.parentElement._columnPropChanged("frozenToEnd", t), this._allCells.forEach((r) => {
      this._grid && r.parentElement === this._grid.$.sizer || Ft(r, "frozen-to-end", t);
    }), this._grid && this._grid._frozenCellsChanged && this._grid._frozenCellsChanged();
  }
  /** @private */
  _lastFrozenChanged(t) {
    this._allCells.forEach((r) => {
      Ft(r, "last-frozen", t);
    }), this.parentElement && this.parentElement._columnPropChanged && (this.parentElement._lastFrozen = t);
  }
  /** @private */
  _firstFrozenToEndChanged(t) {
    this._allCells.forEach((r) => {
      this._grid && r.parentElement === this._grid.$.sizer || Ft(r, "first-frozen-to-end", t);
    }), this.parentElement && this.parentElement._columnPropChanged && (this.parentElement._firstFrozenToEnd = t);
  }
  /** @private */
  _rowHeaderChanged(t, r) {
    r.value && r.value.forEach((s) => {
      s.setAttribute("role", t ? "rowheader" : "gridcell");
    });
  }
  /**
   * @param {string} path
   * @return {string}
   * @protected
   */
  _generateHeader(t) {
    return t.substr(t.lastIndexOf(".") + 1).replace(/([A-Z])/gu, "-$1").toLowerCase().replace(/-/gu, " ").replace(/^./u, (r) => r.toUpperCase());
  }
  /** @private */
  _reorderStatusChanged(t) {
    const r = this.__previousReorderStatus, s = r ? `reorder-${r}-cell` : "", o = `reorder-${t}-cell`;
    this._allCells.forEach((n) => {
      Ft(n, "reorder-status", t, o, s);
    }), this.__previousReorderStatus = t;
  }
  /** @private */
  _resizableChanged(t, r) {
    t === void 0 || r === void 0 || r && [r].concat(this._emptyCells).forEach((s) => {
      if (s) {
        const o = s.querySelector('[part~="resize-handle"]');
        if (o && s.removeChild(o), t) {
          const n = document.createElement("div");
          n.setAttribute("part", "resize-handle"), s.appendChild(n);
        }
      }
    });
  }
  /** @private */
  _textAlignChanged(t) {
    if (t === void 0 || this._grid === void 0 || ["start", "end", "center"].indexOf(t) === -1)
      return;
    let r;
    getComputedStyle(this._grid).direction === "ltr" ? t === "start" ? r = "left" : t === "end" && (r = "right") : t === "start" ? r = "right" : t === "end" && (r = "left"), this._allCells.forEach((s) => {
      s._content.style.textAlign = t, getComputedStyle(s._content).textAlign !== t && (s._content.style.textAlign = r);
    });
  }
  /** @private */
  _hiddenChanged(t) {
    this.parentElement && this.parentElement._columnPropChanged && this.parentElement._columnPropChanged("hidden", t), !!t != !!this._previousHidden && this._grid && (t === !0 && this._allCells.forEach((r) => {
      r._content.parentNode && r._content.parentNode.removeChild(r._content);
    }), this._grid._debouncerHiddenChanged = R.debounce(
      this._grid._debouncerHiddenChanged,
      wt,
      () => {
        this._grid && this._grid._renderColumnTree && this._grid._renderColumnTree(this._grid._columnTree);
      }
    ), this._grid._debounceUpdateFrozenColumn && this._grid._debounceUpdateFrozenColumn(), this._grid._resetKeyboardNavigation && this._grid._resetKeyboardNavigation()), this._previousHidden = t;
  }
  /** @protected */
  _runRenderer(t, r, s) {
    const o = [r._content, this];
    s && s.item && o.push(s), t.apply(this, o);
  }
  /**
   * Renders the content to the given cells using a renderer.
   *
   * @private
   */
  __renderCellsContent(t, r) {
    this.hidden || !this._grid || r.forEach((s) => {
      if (!s.parentElement)
        return;
      const o = this._grid.__getRowModel(s.parentElement);
      t && (s._renderer !== t && this._clearCellContent(s), s._renderer = t, (o.item || t === this._headerRenderer || t === this._footerRenderer) && this._runRenderer(t, s, o));
    });
  }
  /**
   * Clears the content of a cell.
   *
   * @protected
   */
  _clearCellContent(t) {
    t._content.innerHTML = "", delete t._content._$litPart$;
  }
  /**
   * Renders the header cell content using a renderer,
   * and then updates the visibility of the parent row depending on
   * whether all its children cells are empty or not.
   *
   * @protected
   */
  _renderHeaderCellContent(t, r) {
    !r || !t || (this.__renderCellsContent(t, [r]), this._grid && r.parentElement && this._grid.__debounceUpdateHeaderFooterRowVisibility(r.parentElement));
  }
  /** @protected */
  _onHeaderRendererOrBindingChanged(t, r, ...s) {
    this._renderHeaderCellContent(t, r);
  }
  /**
   * Renders the content of body cells using a renderer.
   *
   * @protected
   */
  _renderBodyCellsContent(t, r) {
    !r || !t || this.__renderCellsContent(t, r);
  }
  /** @protected */
  _onRendererOrBindingChanged(t, r, ...s) {
    this._renderBodyCellsContent(t, r);
  }
  /**
   * Renders the footer cell content using a renderer
   * and then updates the visibility of the parent row depending on
   * whether all its children cells are empty or not.
   *
   * @protected
   */
  _renderFooterCellContent(t, r) {
    !r || !t || (this.__renderCellsContent(t, [r]), this._grid && r.parentElement && this._grid.__debounceUpdateHeaderFooterRowVisibility(r.parentElement));
  }
  /** @protected */
  _onFooterRendererOrBindingChanged(t, r) {
    this._renderFooterCellContent(t, r);
  }
  /** @private */
  __setTextContent(t, r) {
    t.textContent !== r && (t.textContent = r);
  }
  /**
   * Renders the text header to the header cell.
   *
   * @private
   */
  __textHeaderRenderer() {
    this.__setTextContent(this._headerCell._content, this.header);
  }
  /**
   * Computes the property name based on the path and renders it to the header cell.
   * If the path is not defined, then nothing is rendered.
   *
   * @protected
   */
  _defaultHeaderRenderer() {
    this.path && this.__setTextContent(this._headerCell._content, this._generateHeader(this.path));
  }
  /**
   * Computes the item property value based on the path and renders it to the body cell.
   * If the path is not defined, then nothing is rendered.
   *
   * @protected
   */
  _defaultRenderer(t, r, { item: s }) {
    this.path && this.__setTextContent(t, Ct(this.path, s));
  }
  /**
   * By default, nothing is rendered to the footer cell.
   *
   * @protected
   */
  _defaultFooterRenderer() {
  }
  /**
   * Computes the final header renderer for the `_headerRenderer` computed property.
   * All the arguments are observable by the Polymer, it re-calls the method
   * once an argument is changed to update the property value.
   *
   * @protected
   * @return {GridHeaderFooterRenderer | undefined}
   */
  _computeHeaderRenderer(t, r) {
    return t || (r != null ? this.__textHeaderRenderer : this._defaultHeaderRenderer);
  }
  /**
   * Computes the final renderer for the `_renderer` property.
   * All the arguments are observable by the Polymer, it re-calls the method
   * once an argument is changed to update the property value.
   *
   * @protected
   * @return {GridBodyRenderer | undefined}
   */
  _computeRenderer(t) {
    return t || this._defaultRenderer;
  }
  /**
   * Computes the final footer renderer for the `_footerRenderer` property.
   * All the arguments are observable by the Polymer, it re-calls the method
   * once an argument is changed to update the property value.
   *
   * @protected
   * @return {GridHeaderFooterRenderer | undefined}
   */
  _computeFooterRenderer(t) {
    return t || this._defaultFooterRenderer;
  }
};
class qi extends qh(Be(N)) {
  static get is() {
    return "vaadin-grid-column";
  }
  static get properties() {
    return {
      /**
       * Width of the cells for this column.
       */
      width: {
        type: String,
        value: "100px"
      },
      /**
       * Flex grow ratio for the cell widths. When set to 0, cell width is fixed.
       * @attr {number} flex-grow
       * @type {number}
       */
      flexGrow: {
        type: Number,
        value: 1
      },
      /**
       * Custom function for rendering the cell content.
       * Receives three arguments:
       *
       * - `root` The cell content DOM element. Append your content to it.
       * - `column` The `<vaadin-grid-column>` element.
       * - `model` The object with the properties related with
       *   the rendered item, contains:
       *   - `model.index` The index of the item.
       *   - `model.item` The item.
       *   - `model.expanded` Sublevel toggle state.
       *   - `model.level` Level of the tree represented with a horizontal offset of the toggle button.
       *   - `model.selected` Selected state.
       *   - `model.detailsOpened` Details opened state.
       *
       * @type {GridBodyRenderer | null | undefined}
       */
      renderer: Function,
      /**
       * Represents the final renderer computed on the set of observable arguments.
       * It is supposed to be used internally when rendering the content of a body cell.
       *
       * @protected
       * @type {GridBodyRenderer | undefined}
       */
      _renderer: {
        type: Function,
        computed: "_computeRenderer(renderer, __initialized)"
      },
      /**
       * Path to an item sub-property whose value gets displayed in the column body cells.
       * The property name is also shown in the column header if an explicit header or renderer isn't defined.
       */
      path: {
        type: String
      },
      /**
       * Automatically sets the width of the column based on the column contents when this is set to `true`.
       *
       * For performance reasons the column width is calculated automatically only once when the grid items
       * are rendered for the first time and the calculation only considers the rows which are currently
       * rendered in DOM (a bit more than what is currently visible). If the grid is scrolled, or the cell
       * content changes, the column width might not match the contents anymore.
       *
       * Hidden columns are ignored in the calculation and their widths are not automatically updated when
       * you show a column that was initially hidden.
       *
       * You can manually trigger the auto sizing behavior again by calling `grid.recalculateColumnWidths()`.
       *
       * The column width may still grow larger when `flexGrow` is not 0.
       * @attr {boolean} auto-width
       * @type {boolean}
       */
      autoWidth: {
        type: Boolean,
        value: !1
      },
      /**
       * When true, wraps the cell's slot into an element with role="button", and sets
       * the tabindex attribute on the button element, instead of the cell itself.
       * This is needed to keep focus in sync with VoiceOver cursor when navigating
       * with Control + Option + arrow keys: focusing the `<td>` element does not fire
       * a focus event, but focusing an element with role="button" inside a cell fires it.
       * @protected
       */
      _focusButtonMode: {
        type: Boolean,
        value: !1
      },
      /**
       * @type {Array<!HTMLElement>}
       * @protected
       */
      _cells: Array
    };
  }
}
O(qi);
/**
 * @license
 * Copyright (c) 2016 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
C(
  "vaadin-grid",
  y`
    @keyframes vaadin-grid-appear {
      to {
        opacity: 1;
      }
    }

    :host {
      display: flex;
      flex-direction: column;
      animation: 1ms vaadin-grid-appear;
      height: 400px;
      flex: 1 1 auto;
      align-self: stretch;
      position: relative;
    }

    :host([hidden]) {
      display: none !important;
    }

    :host([disabled]) {
      pointer-events: none;
    }

    #scroller {
      display: flex;
      flex-direction: column;
      min-height: 100%;
      transform: translateY(0);
      width: auto;
      height: auto;
      position: absolute;
      inset: 0;
    }

    :host([all-rows-visible]) {
      height: auto;
      align-self: flex-start;
      flex-grow: 0;
      width: 100%;
    }

    :host([all-rows-visible]) #scroller {
      width: 100%;
      height: 100%;
      position: relative;
    }

    :host([all-rows-visible]) #items {
      min-height: 1px;
    }

    #table {
      display: flex;
      flex-direction: column;
      width: 100%;
      height: 100%;
      overflow: auto;
      position: relative;
      outline: none;
      /* Workaround for a Desktop Safari bug: new stacking context here prevents the scrollbar from getting hidden */
      z-index: 0;
    }

    #header,
    #footer {
      display: block;
      position: -webkit-sticky;
      position: sticky;
      left: 0;
      overflow: visible;
      width: 100%;
      z-index: 1;
    }

    #header {
      top: 0;
    }

    th {
      text-align: inherit;
    }

    /* Safari doesn't work with "inherit" */
    [safari] th {
      text-align: initial;
    }

    #footer {
      bottom: 0;
    }

    #items {
      flex-grow: 1;
      flex-shrink: 0;
      display: block;
      position: -webkit-sticky;
      position: sticky;
      width: 100%;
      left: 0;
      overflow: visible;
    }

    [part~='row'] {
      display: flex;
      width: 100%;
      box-sizing: border-box;
      margin: 0;
    }

    [part~='row'][loading] [part~='body-cell'] ::slotted(vaadin-grid-cell-content) {
      visibility: hidden;
    }

    [column-rendering='lazy'] [part~='body-cell']:not([frozen]):not([frozen-to-end]) {
      transform: translateX(var(--_grid-lazy-columns-start));
    }

    #items [part~='row'] {
      position: absolute;
    }

    #items [part~='row']:empty {
      height: 100%;
    }

    [part~='cell']:not([part~='details-cell']) {
      flex-shrink: 0;
      flex-grow: 1;
      box-sizing: border-box;
      display: flex;
      width: 100%;
      position: relative;
      align-items: center;
      padding: 0;
      white-space: nowrap;
    }

    [part~='cell'] > [tabindex] {
      display: flex;
      align-items: inherit;
      outline: none;
      position: absolute;
      inset: 0;
    }

    [part~='details-cell'] {
      position: absolute;
      bottom: 0;
      width: 100%;
      box-sizing: border-box;
      padding: 0;
    }

    [part~='cell'] ::slotted(vaadin-grid-cell-content) {
      display: block;
      width: 100%;
      box-sizing: border-box;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    [hidden] {
      display: none !important;
    }

    [frozen],
    [frozen-to-end] {
      z-index: 2;
      will-change: transform;
    }

    [no-scrollbars][safari] #table,
    [no-scrollbars][firefox] #table {
      overflow: hidden;
    }

    /* Reordering styles */
    :host([reordering]) [part~='cell'] ::slotted(vaadin-grid-cell-content),
    :host([reordering]) [part~='resize-handle'],
    #scroller[no-content-pointer-events] [part~='cell'] ::slotted(vaadin-grid-cell-content) {
      pointer-events: none;
    }

    [part~='reorder-ghost'] {
      visibility: hidden;
      position: fixed;
      pointer-events: none;
      opacity: 0.5;

      /* Prevent overflowing the grid in Firefox */
      top: 0;
      left: 0;
    }

    :host([reordering]) {
      -moz-user-select: none;
      -webkit-user-select: none;
      user-select: none;
    }

    /* Resizing styles */
    [part~='resize-handle'] {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
      cursor: col-resize;
      z-index: 1;
    }

    [part~='resize-handle']::before {
      position: absolute;
      content: '';
      height: 100%;
      width: 35px;
      transform: translateX(-50%);
    }

    [last-column] [part~='resize-handle']::before,
    [last-frozen] [part~='resize-handle']::before {
      width: 18px;
      transform: none;
      right: 0;
    }

    [frozen-to-end] [part~='resize-handle'] {
      left: 0;
      right: auto;
    }

    [frozen-to-end] [part~='resize-handle']::before {
      left: 0;
      right: auto;
    }

    [first-frozen-to-end] [part~='resize-handle']::before {
      width: 18px;
      transform: none;
    }

    [first-frozen-to-end] {
      margin-inline-start: auto;
    }

    /* Hide resize handle if scrolled to end */
    :host(:not([overflow~='end'])) [first-frozen-to-end] [part~='resize-handle'] {
      display: none;
    }

    #scroller[column-resizing] {
      -ms-user-select: none;
      -moz-user-select: none;
      -webkit-user-select: none;
      user-select: none;
    }

    /* Sizer styles */
    #sizer {
      display: flex;
      position: absolute;
      visibility: hidden;
    }

    #sizer [part~='details-cell'] {
      display: none !important;
    }

    #sizer [part~='cell'][hidden] {
      display: none !important;
    }

    #sizer [part~='cell'] {
      display: block;
      flex-shrink: 0;
      line-height: 0;
      height: 0 !important;
      min-height: 0 !important;
      max-height: 0 !important;
      padding: 0 !important;
      border: none !important;
    }

    #sizer [part~='cell']::before {
      content: '-';
    }

    #sizer [part~='cell'] ::slotted(vaadin-grid-cell-content) {
      display: none !important;
    }

    /* RTL specific styles */

    :host([dir='rtl']) #items,
    :host([dir='rtl']) #header,
    :host([dir='rtl']) #footer {
      left: auto;
    }

    :host([dir='rtl']) [part~='reorder-ghost'] {
      left: auto;
      right: 0;
    }

    :host([dir='rtl']) [part~='resize-handle'] {
      left: 0;
      right: auto;
    }

    :host([dir='rtl']) [part~='resize-handle']::before {
      transform: translateX(50%);
    }

    :host([dir='rtl']) [last-column] [part~='resize-handle']::before,
    :host([dir='rtl']) [last-frozen] [part~='resize-handle']::before {
      left: 0;
      right: auto;
    }

    :host([dir='rtl']) [frozen-to-end] [part~='resize-handle'] {
      right: 0;
      left: auto;
    }

    :host([dir='rtl']) [frozen-to-end] [part~='resize-handle']::before {
      right: 0;
      left: auto;
    }

    @media (forced-colors: active) {
      [part~='selected-row'] [part~='first-column-cell']::after {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        bottom: 0;
        border: 2px solid;
      }

      [part~='focused-cell']::before {
        outline: 2px solid !important;
        outline-offset: -1px;
      }
    }
  `,
  { moduleId: "vaadin-grid-styles" }
);
/**
 * @license
 * Copyright (c) 2021 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const po = (i) => i.test(navigator.userAgent), jn = (i) => i.test(navigator.platform), lv = (i) => i.test(navigator.vendor), Ic = po(/Android/u), cv = po(/Chrome/u) && lv(/Google Inc/u), Wh = po(/Firefox/u), dv = jn(/^iPad/u) || jn(/^Mac/u) && navigator.maxTouchPoints > 1, uv = jn(/^iPhone/u), Hs = uv || dv, jh = po(/^((?!chrome|android).)*safari/iu), Ii = (() => {
  try {
    return document.createEvent("TouchEvent"), !0;
  } catch {
    return !1;
  }
})();
/**
 * @license
 * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
const Dc = navigator.userAgent.match(/iP(?:hone|ad;(?: U;)? CPU) OS (\d+)/u), hv = Dc && Dc[1] >= 8, Oc = 3, fv = {
  /**
   * The ratio of hidden tiles that should remain in the scroll direction.
   * Recommended value ~0.5, so it will distribute tiles evenly in both
   * directions.
   */
  _ratio: 0.5,
  /**
   * The padding-top value for the list.
   */
  _scrollerPaddingTop: 0,
  /**
   * This value is a cached value of `scrollTop` from the last `scroll` event.
   */
  _scrollPosition: 0,
  /**
   * The sum of the heights of all the tiles in the DOM.
   */
  _physicalSize: 0,
  /**
   * The average `offsetHeight` of the tiles observed till now.
   */
  _physicalAverage: 0,
  /**
   * The number of tiles which `offsetHeight` > 0 observed until now.
   */
  _physicalAverageCount: 0,
  /**
   * The Y position of the item rendered in the `_physicalStart`
   * tile relative to the scrolling list.
   */
  _physicalTop: 0,
  /**
   * The number of items in the list.
   */
  _virtualCount: 0,
  /**
   * The estimated scroll height based on `_physicalAverage`
   */
  _estScrollHeight: 0,
  /**
   * The scroll height of the dom node
   */
  _scrollHeight: 0,
  /**
   * The height of the list. This is referred as the viewport in the context of
   * list.
   */
  _viewportHeight: 0,
  /**
   * The width of the list. This is referred as the viewport in the context of
   * list.
   */
  _viewportWidth: 0,
  /**
   * An array of DOM nodes that are currently in the tree
   * @type {?Array<!HTMLElement>}
   */
  _physicalItems: null,
  /**
   * An array of heights for each item in `_physicalItems`
   * @type {?Array<number>}
   */
  _physicalSizes: null,
  /**
   * A cached value for the first visible index.
   * See `firstVisibleIndex`
   * @type {?number}
   */
  _firstVisibleIndexVal: null,
  /**
   * A cached value for the last visible index.
   * See `lastVisibleIndex`
   * @type {?number}
   */
  _lastVisibleIndexVal: null,
  /**
   * The max number of pages to render. One page is equivalent to the height of
   * the list.
   */
  _maxPages: 2,
  /**
   * The cost of stamping a template in ms.
   */
  _templateCost: 0,
  /**
   * The bottom of the physical content.
   */
  get _physicalBottom() {
    return this._physicalTop + this._physicalSize;
  },
  /**
   * The bottom of the scroll.
   */
  get _scrollBottom() {
    return this._scrollPosition + this._viewportHeight;
  },
  /**
   * The n-th item rendered in the last physical item.
   */
  get _virtualEnd() {
    return this._virtualStart + this._physicalCount - 1;
  },
  /**
   * The height of the physical content that isn't on the screen.
   */
  get _hiddenContentSize() {
    return this._physicalSize - this._viewportHeight;
  },
  /**
   * The maximum scroll top value.
   */
  get _maxScrollTop() {
    return this._estScrollHeight - this._viewportHeight + this._scrollOffset;
  },
  /**
   * The largest n-th value for an item such that it can be rendered in
   * `_physicalStart`.
   */
  get _maxVirtualStart() {
    const i = this._virtualCount;
    return Math.max(0, i - this._physicalCount);
  },
  get _virtualStart() {
    return this._virtualStartVal || 0;
  },
  set _virtualStart(i) {
    i = this._clamp(i, 0, this._maxVirtualStart), this._virtualStartVal = i;
  },
  get _physicalStart() {
    return this._physicalStartVal || 0;
  },
  /**
   * The k-th tile that is at the top of the scrolling list.
   */
  set _physicalStart(i) {
    i %= this._physicalCount, i < 0 && (i = this._physicalCount + i), this._physicalStartVal = i;
  },
  /**
   * The k-th tile that is at the bottom of the scrolling list.
   */
  get _physicalEnd() {
    return (this._physicalStart + this._physicalCount - 1) % this._physicalCount;
  },
  get _physicalCount() {
    return this._physicalCountVal || 0;
  },
  set _physicalCount(i) {
    this._physicalCountVal = i;
  },
  /**
   * An optimal physical size such that we will have enough physical items
   * to fill up the viewport and recycle when the user scrolls.
   *
   * This default value assumes that we will at least have the equivalent
   * to a viewport of physical items above and below the user's viewport.
   */
  get _optPhysicalSize() {
    return this._viewportHeight === 0 ? 1 / 0 : this._viewportHeight * this._maxPages;
  },
  /**
   * True if the current list is visible.
   */
  get _isVisible() {
    return !!(this.offsetWidth || this.offsetHeight);
  },
  /**
   * Gets the index of the first visible item in the viewport.
   *
   * @type {number}
   */
  get firstVisibleIndex() {
    let i = this._firstVisibleIndexVal;
    if (i == null) {
      let e = this._physicalTop + this._scrollOffset;
      i = this._iterateItems((t, r) => {
        if (e += this._getPhysicalSizeIncrement(t), e > this._scrollPosition)
          return r;
      }) || 0, this._firstVisibleIndexVal = i;
    }
    return i;
  },
  /**
   * Gets the index of the last visible item in the viewport.
   *
   * @type {number}
   */
  get lastVisibleIndex() {
    let i = this._lastVisibleIndexVal;
    if (i == null) {
      let e = this._physicalTop + this._scrollOffset;
      this._iterateItems((t, r) => {
        e < this._scrollBottom && (i = r), e += this._getPhysicalSizeIncrement(t);
      }), this._lastVisibleIndexVal = i;
    }
    return i;
  },
  get _scrollOffset() {
    return this._scrollerPaddingTop + this.scrollOffset;
  },
  /**
   * Recycles the physical items when needed.
   */
  _scrollHandler() {
    const i = Math.max(0, Math.min(this._maxScrollTop, this._scrollTop));
    let e = i - this._scrollPosition;
    const t = e >= 0;
    if (this._scrollPosition = i, this._firstVisibleIndexVal = null, this._lastVisibleIndexVal = null, Math.abs(e) > this._physicalSize && this._physicalSize > 0) {
      e -= this._scrollOffset;
      const r = Math.round(e / this._physicalAverage);
      this._virtualStart += r, this._physicalStart += r, this._physicalTop = Math.min(Math.floor(this._virtualStart) * this._physicalAverage, this._scrollPosition), this._update();
    } else if (this._physicalCount > 0) {
      const r = this._getReusables(t);
      t ? (this._physicalTop = r.physicalTop, this._virtualStart += r.indexes.length, this._physicalStart += r.indexes.length) : (this._virtualStart -= r.indexes.length, this._physicalStart -= r.indexes.length), this._update(r.indexes, t ? null : r.indexes), this._debounce("_increasePoolIfNeeded", this._increasePoolIfNeeded.bind(this, 0), xt);
    }
  },
  /**
   * Returns an object that contains the indexes of the physical items
   * that might be reused and the physicalTop.
   *
   * @param {boolean} fromTop If the potential reusable items are above the scrolling region.
   */
  _getReusables(i) {
    let e, t, r;
    const s = [], o = this._hiddenContentSize * this._ratio, n = this._virtualStart, a = this._virtualEnd, l = this._physicalCount;
    let c = this._physicalTop + this._scrollOffset;
    const d = this._physicalBottom + this._scrollOffset, u = this._scrollPosition, h = this._scrollBottom;
    for (i ? (e = this._physicalStart, t = u - c) : (e = this._physicalEnd, t = d - h); r = this._getPhysicalSizeIncrement(e), t -= r, !(s.length >= l || t <= o); )
      if (i) {
        if (a + s.length + 1 >= this._virtualCount || c + r >= u - this._scrollOffset)
          break;
        s.push(e), c += r, e = (e + 1) % l;
      } else {
        if (n - s.length <= 0 || c + this._physicalSize - r <= h)
          break;
        s.push(e), c -= r, e = e === 0 ? l - 1 : e - 1;
      }
    return { indexes: s, physicalTop: c - this._scrollOffset };
  },
  /**
   * Update the list of items, starting from the `_virtualStart` item.
   * @param {!Array<number>=} itemSet
   * @param {!Array<number>=} movingUp
   */
  _update(i, e) {
    if (!(i && i.length === 0 || this._physicalCount === 0)) {
      if (this._assignModels(i), this._updateMetrics(i), e)
        for (; e.length; ) {
          const t = e.pop();
          this._physicalTop -= this._getPhysicalSizeIncrement(t);
        }
      this._positionItems(), this._updateScrollerSize();
    }
  },
  _isClientFull() {
    return this._scrollBottom !== 0 && this._physicalBottom - 1 >= this._scrollBottom && this._physicalTop <= this._scrollPosition;
  },
  /**
   * Increases the pool size.
   */
  _increasePoolIfNeeded(i) {
    const t = this._clamp(
      this._physicalCount + i,
      Oc,
      this._virtualCount - this._virtualStart
    ) - this._physicalCount;
    let r = Math.round(this._physicalCount * 0.5);
    if (!(t < 0)) {
      if (t > 0) {
        const s = window.performance.now();
        [].push.apply(this._physicalItems, this._createPool(t));
        for (let o = 0; o < t; o++)
          this._physicalSizes.push(0);
        this._physicalCount += t, this._physicalStart > this._physicalEnd && this._isIndexRendered(this._focusedVirtualIndex) && this._getPhysicalIndex(this._focusedVirtualIndex) < this._physicalEnd && (this._physicalStart += t), this._update(), this._templateCost = (window.performance.now() - s) / t, r = Math.round(this._physicalCount * 0.5);
      }
      this._virtualEnd >= this._virtualCount - 1 || r === 0 || (this._isClientFull() ? this._physicalSize < this._optPhysicalSize && this._debounce(
        "_increasePoolIfNeeded",
        this._increasePoolIfNeeded.bind(this, this._clamp(Math.round(50 / this._templateCost), 1, r)),
        Dh
      ) : this._debounce("_increasePoolIfNeeded", this._increasePoolIfNeeded.bind(this, r), xt));
    }
  },
  /**
   * Renders the a new list.
   */
  _render() {
    if (!(!this.isAttached || !this._isVisible))
      if (this._physicalCount !== 0) {
        const i = this._getReusables(!0);
        this._physicalTop = i.physicalTop, this._virtualStart += i.indexes.length, this._physicalStart += i.indexes.length, this._update(i.indexes), this._update(), this._increasePoolIfNeeded(0);
      } else
        this._virtualCount > 0 && (this.updateViewportBoundaries(), this._increasePoolIfNeeded(Oc));
  },
  /**
   * Called when the items have changed. That is, reassignments
   * to `items`, splices or updates to a single item.
   */
  _itemsChanged(i) {
    i.path === "items" && (this._virtualStart = 0, this._physicalTop = 0, this._virtualCount = this.items ? this.items.length : 0, this._physicalIndexForKey = {}, this._firstVisibleIndexVal = null, this._lastVisibleIndexVal = null, this._physicalItems || (this._physicalItems = []), this._physicalSizes || (this._physicalSizes = []), this._physicalStart = 0, this._scrollTop > this._scrollOffset && this._resetScrollPosition(0), this._debounce("_render", this._render, wt));
  },
  /**
   * Executes a provided function per every physical index in `itemSet`
   * `itemSet` default value is equivalent to the entire set of physical
   * indexes.
   *
   * @param {!function(number, number)} fn
   * @param {!Array<number>=} itemSet
   */
  _iterateItems(i, e) {
    let t, r, s, o;
    if (arguments.length === 2 && e) {
      for (o = 0; o < e.length; o++)
        if (t = e[o], r = this._computeVidx(t), (s = i.call(this, t, r)) != null)
          return s;
    } else {
      for (t = this._physicalStart, r = this._virtualStart; t < this._physicalCount; t++, r++)
        if ((s = i.call(this, t, r)) != null)
          return s;
      for (t = 0; t < this._physicalStart; t++, r++)
        if ((s = i.call(this, t, r)) != null)
          return s;
    }
  },
  /**
   * Returns the virtual index for a given physical index
   *
   * @param {number} pidx Physical index
   * @return {number}
   */
  _computeVidx(i) {
    return i >= this._physicalStart ? this._virtualStart + (i - this._physicalStart) : this._virtualStart + (this._physicalCount - this._physicalStart) + i;
  },
  /**
   * Updates the position of the physical items.
   */
  _positionItems() {
    this._adjustScrollPosition();
    let i = this._physicalTop;
    this._iterateItems((e) => {
      this.translate3d(0, `${i}px`, 0, this._physicalItems[e]), i += this._physicalSizes[e];
    });
  },
  _getPhysicalSizeIncrement(i) {
    return this._physicalSizes[i];
  },
  /**
   * Adjusts the scroll position when it was overestimated.
   */
  _adjustScrollPosition() {
    const i = this._virtualStart === 0 ? this._physicalTop : Math.min(this._scrollPosition + this._physicalTop, 0);
    if (i !== 0) {
      this._physicalTop -= i;
      const e = this._scrollPosition;
      !hv && e > 0 && this._resetScrollPosition(e - i);
    }
  },
  /**
   * Sets the position of the scroll.
   */
  _resetScrollPosition(i) {
    this.scrollTarget && i >= 0 && (this._scrollTop = i, this._scrollPosition = this._scrollTop);
  },
  /**
   * Sets the scroll height, that's the height of the content,
   *
   * @param {boolean=} forceUpdate If true, updates the height no matter what.
   */
  _updateScrollerSize(i) {
    const e = this._physicalBottom + Math.max(this._virtualCount - this._physicalCount - this._virtualStart, 0) * this._physicalAverage;
    this._estScrollHeight = e, (i || this._scrollHeight === 0 || this._scrollPosition >= e - this._physicalSize || Math.abs(e - this._scrollHeight) >= this._viewportHeight) && (this.$.items.style.height = `${e}px`, this._scrollHeight = e);
  },
  /**
   * Scroll to a specific index in the virtual list regardless
   * of the physical items in the DOM tree.
   *
   * @method scrollToIndex
   * @param {number} idx The index of the item
   */
  scrollToIndex(i) {
    if (typeof i != "number" || i < 0 || i > this.items.length - 1 || (ai(), this._physicalCount === 0))
      return;
    i = this._clamp(i, 0, this._virtualCount - 1), (!this._isIndexRendered(i) || i >= this._maxVirtualStart) && (this._virtualStart = i - 1), this._assignModels(), this._updateMetrics(), this._physicalTop = this._virtualStart * this._physicalAverage;
    let e = this._physicalStart, t = this._virtualStart, r = 0;
    const s = this._hiddenContentSize;
    for (; t < i && r <= s; )
      r += this._getPhysicalSizeIncrement(e), e = (e + 1) % this._physicalCount, t += 1;
    this._updateScrollerSize(!0), this._positionItems(), this._resetScrollPosition(this._physicalTop + this._scrollOffset + r), this._increasePoolIfNeeded(0), this._firstVisibleIndexVal = null, this._lastVisibleIndexVal = null;
  },
  /**
   * Reset the physical average and the average count.
   */
  _resetAverage() {
    this._physicalAverage = 0, this._physicalAverageCount = 0;
  },
  /**
   * A handler for the `iron-resize` event triggered by `IronResizableBehavior`
   * when the element is resized.
   */
  _resizeHandler() {
    this._debounce(
      "_render",
      () => {
        this._firstVisibleIndexVal = null, this._lastVisibleIndexVal = null, this._isVisible ? (this.updateViewportBoundaries(), this.toggleScrollListener(!0), this._resetAverage(), this._render()) : this.toggleScrollListener(!1);
      },
      wt
    );
  },
  _isIndexRendered(i) {
    return i >= this._virtualStart && i <= this._virtualEnd;
  },
  _getPhysicalIndex(i) {
    return (this._physicalStart + (i - this._virtualStart)) % this._physicalCount;
  },
  _clamp(i, e, t) {
    return Math.min(t, Math.max(e, i));
  },
  _debounce(i, e, t) {
    this._debouncers || (this._debouncers = {}), this._debouncers[i] = R.debounce(this._debouncers[i], t, e.bind(this)), Oh(this._debouncers[i]);
  }
};
/**
 * @license
 * Copyright (c) 2021 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const pv = 1e5, Jo = 1e3;
class Gh {
  constructor({ createElements: e, updateElement: t, scrollTarget: r, scrollContainer: s, elementsContainer: o, reorderElements: n }) {
    this.isAttached = !0, this._vidxOffset = 0, this.createElements = e, this.updateElement = t, this.scrollTarget = r, this.scrollContainer = s, this.elementsContainer = o || s, this.reorderElements = n, this._maxPages = 1.3, this.__placeholderHeight = 200, this.__elementHeightQueue = Array(10), this.timeouts = {
      SCROLL_REORDER: 500,
      IGNORE_WHEEL: 500,
      FIX_INVALID_ITEM_POSITIONING: 100
    }, this.__resizeObserver = new ResizeObserver(() => this._resizeHandler()), getComputedStyle(this.scrollTarget).overflow === "visible" && (this.scrollTarget.style.overflow = "auto"), getComputedStyle(this.scrollContainer).position === "static" && (this.scrollContainer.style.position = "relative"), this.__resizeObserver.observe(this.scrollTarget), this.scrollTarget.addEventListener("scroll", () => this._scrollHandler()), this._scrollLineHeight = this._getScrollLineHeight(), this.scrollTarget.addEventListener("wheel", (a) => this.__onWheel(a)), this.reorderElements && (this.scrollTarget.addEventListener("mousedown", () => {
      this.__mouseDown = !0;
    }), this.scrollTarget.addEventListener("mouseup", () => {
      this.__mouseDown = !1, this.__pendingReorder && this.__reorderElements();
    }));
  }
  get scrollOffset() {
    return 0;
  }
  get adjustedFirstVisibleIndex() {
    return this.firstVisibleIndex + this._vidxOffset;
  }
  get adjustedLastVisibleIndex() {
    return this.lastVisibleIndex + this._vidxOffset;
  }
  scrollToIndex(e) {
    if (typeof e != "number" || isNaN(e) || this.size === 0 || !this.scrollTarget.offsetHeight)
      return;
    e = this._clamp(e, 0, this.size - 1);
    const t = this.__getVisibleElements().length;
    let r = Math.floor(e / this.size * this._virtualCount);
    this._virtualCount - r < t ? (r = this._virtualCount - (this.size - e), this._vidxOffset = this.size - this._virtualCount) : r < t ? e < Jo ? (r = e, this._vidxOffset = 0) : (r = Jo, this._vidxOffset = e - r) : this._vidxOffset = e - r, this.__skipNextVirtualIndexAdjust = !0, super.scrollToIndex(r), this.adjustedFirstVisibleIndex !== e && this._scrollTop < this._maxScrollTop && !this.grid && (this._scrollTop -= this.__getIndexScrollOffset(e) || 0), this._scrollHandler();
  }
  flush() {
    this.scrollTarget.offsetHeight !== 0 && (this._resizeHandler(), ai(), this._scrollHandler(), this.__fixInvalidItemPositioningDebouncer && this.__fixInvalidItemPositioningDebouncer.flush(), this.__scrollReorderDebouncer && this.__scrollReorderDebouncer.flush(), this.__debouncerWheelAnimationFrame && this.__debouncerWheelAnimationFrame.flush());
  }
  update(e = 0, t = this.size - 1) {
    const r = [];
    this.__getVisibleElements().forEach((s) => {
      s.__virtualIndex >= e && s.__virtualIndex <= t && (this.__updateElement(s, s.__virtualIndex, !0), r.push(s));
    }), this.__afterElementsUpdated(r);
  }
  /**
   * Updates the height for a given set of items.
   *
   * @param {!Array<number>=} itemSet
   */
  _updateMetrics(e) {
    ai();
    let t = 0, r = 0;
    const s = this._physicalAverageCount, o = this._physicalAverage;
    this._iterateItems((n, a) => {
      r += this._physicalSizes[n], this._physicalSizes[n] = Math.ceil(this.__getBorderBoxHeight(this._physicalItems[n])), t += this._physicalSizes[n], this._physicalAverageCount += this._physicalSizes[n] ? 1 : 0;
    }, e), this._physicalSize = this._physicalSize + t - r, this._physicalAverageCount !== s && (this._physicalAverage = Math.round(
      (o * s + t) / this._physicalAverageCount
    ));
  }
  __getBorderBoxHeight(e) {
    const t = getComputedStyle(e), r = parseFloat(t.height) || 0;
    if (t.boxSizing === "border-box")
      return r;
    const s = parseFloat(t.paddingBottom) || 0, o = parseFloat(t.paddingTop) || 0, n = parseFloat(t.borderBottomWidth) || 0, a = parseFloat(t.borderTopWidth) || 0;
    return r + s + o + n + a;
  }
  __updateElement(e, t, r) {
    e.style.paddingTop && (e.style.paddingTop = ""), !this.__preventElementUpdates && (e.__lastUpdatedIndex !== t || r) && (this.updateElement(e, t), e.__lastUpdatedIndex = t);
  }
  /**
   * Called synchronously right after elements have been updated.
   * This is a good place to do any post-update work.
   *
   * @param {!Array<!HTMLElement>} updatedElements
   */
  __afterElementsUpdated(e) {
    e.forEach((t) => {
      const r = t.offsetHeight;
      if (r === 0)
        t.style.paddingTop = `${this.__placeholderHeight}px`, this.__placeholderClearDebouncer = R.debounce(
          this.__placeholderClearDebouncer,
          wt,
          () => this._resizeHandler()
        );
      else {
        this.__elementHeightQueue.push(r), this.__elementHeightQueue.shift();
        const s = this.__elementHeightQueue.filter((o) => o !== void 0);
        this.__placeholderHeight = Math.round(s.reduce((o, n) => o + n, 0) / s.length);
      }
    });
  }
  __getIndexScrollOffset(e) {
    const t = this.__getVisibleElements().find((r) => r.__virtualIndex === e);
    return t ? this.scrollTarget.getBoundingClientRect().top - t.getBoundingClientRect().top : void 0;
  }
  get size() {
    return this.__size;
  }
  set size(e) {
    e !== this.size && (this.__fixInvalidItemPositioningDebouncer && this.__fixInvalidItemPositioningDebouncer.cancel(), this._debouncers && this._debouncers._increasePoolIfNeeded && this._debouncers._increasePoolIfNeeded.cancel(), this.__size = e, this._physicalItems ? this._virtualCount = this.items.length : (this._itemsChanged({
      path: "items"
    }), this.__preventElementUpdates = !0, ai(), this.__preventElementUpdates = !1), this._isVisible || this._assignModels(), this.elementsContainer.children.length || requestAnimationFrame(() => this._resizeHandler()), this._resizeHandler(), ai());
  }
  /** @private */
  get _scrollTop() {
    return this.scrollTarget.scrollTop;
  }
  /** @private */
  set _scrollTop(e) {
    this.scrollTarget.scrollTop = e;
  }
  /** @private */
  get items() {
    return {
      length: Math.min(this.size, pv)
    };
  }
  /** @private */
  get offsetHeight() {
    return this.scrollTarget.offsetHeight;
  }
  /** @private */
  get $() {
    return {
      items: this.scrollContainer
    };
  }
  /** @private */
  updateViewportBoundaries() {
    const e = window.getComputedStyle(this.scrollTarget);
    this._scrollerPaddingTop = this.scrollTarget === this ? 0 : parseInt(e["padding-top"], 10), this._isRTL = e.direction === "rtl", this._viewportWidth = this.elementsContainer.offsetWidth, this._viewportHeight = this.scrollTarget.offsetHeight, this._scrollPageHeight = this._viewportHeight - this._scrollLineHeight, this.grid && this._updateGridMetrics();
  }
  /** @private */
  setAttribute() {
  }
  /** @private */
  _createPool(e) {
    const t = this.createElements(e), r = document.createDocumentFragment();
    return t.forEach((s) => {
      s.style.position = "absolute", r.appendChild(s), this.__resizeObserver.observe(s);
    }), this.elementsContainer.appendChild(r), t;
  }
  /** @private */
  _assignModels(e) {
    const t = [];
    this._iterateItems((r, s) => {
      const o = this._physicalItems[r];
      o.hidden = s >= this.size, o.hidden ? delete o.__lastUpdatedIndex : (o.__virtualIndex = s + (this._vidxOffset || 0), this.__updateElement(o, o.__virtualIndex), t.push(o));
    }, e), this.__afterElementsUpdated(t);
  }
  /** @private */
  _isClientFull() {
    return setTimeout(() => {
      this.__clientFull = !0;
    }), this.__clientFull || super._isClientFull();
  }
  /** @private */
  translate3d(e, t, r, s) {
    s.style.transform = `translateY(${t})`;
  }
  /** @private */
  toggleScrollListener() {
  }
  _scrollHandler() {
    if (this.scrollTarget.offsetHeight === 0)
      return;
    this._adjustVirtualIndexOffset(this._scrollTop - (this.__previousScrollTop || 0));
    const e = this.scrollTarget.scrollTop - this._scrollPosition;
    if (super._scrollHandler(), this._physicalCount !== 0) {
      const t = e >= 0, r = this._getReusables(!t);
      r.indexes.length && (this._physicalTop = r.physicalTop, t ? (this._virtualStart -= r.indexes.length, this._physicalStart -= r.indexes.length) : (this._virtualStart += r.indexes.length, this._physicalStart += r.indexes.length), this._resizeHandler());
    }
    e && (this.__fixInvalidItemPositioningDebouncer = R.debounce(
      this.__fixInvalidItemPositioningDebouncer,
      _e.after(this.timeouts.FIX_INVALID_ITEM_POSITIONING),
      () => this.__fixInvalidItemPositioning()
    )), this.reorderElements && (this.__scrollReorderDebouncer = R.debounce(
      this.__scrollReorderDebouncer,
      _e.after(this.timeouts.SCROLL_REORDER),
      () => this.__reorderElements()
    )), this.__previousScrollTop = this._scrollTop, this._scrollTop === 0 && this.firstVisibleIndex !== 0 && Math.abs(e) > 0 && this.scrollToIndex(0);
  }
  /**
   * Work around an iron-list issue with invalid item positioning.
   * See https://github.com/vaadin/flow-components/issues/4306
   * @private
   */
  __fixInvalidItemPositioning() {
    if (!this.scrollTarget.isConnected)
      return;
    const e = this._physicalTop > this._scrollTop, t = this._physicalBottom < this._scrollBottom, r = this.adjustedFirstVisibleIndex === 0, s = this.adjustedLastVisibleIndex === this.size - 1;
    if (e && !r || t && !s) {
      const o = t, n = this._ratio;
      this._ratio = 0, this._scrollPosition = this._scrollTop + (o ? -1 : 1), this._scrollHandler(), this._ratio = n;
    }
  }
  /** @private */
  __onWheel(e) {
    if (e.ctrlKey || this._hasScrolledAncestor(e.target, e.deltaX, e.deltaY))
      return;
    let t = e.deltaY;
    if (e.deltaMode === WheelEvent.DOM_DELTA_LINE ? t *= this._scrollLineHeight : e.deltaMode === WheelEvent.DOM_DELTA_PAGE && (t *= this._scrollPageHeight), this._deltaYAcc || (this._deltaYAcc = 0), this._wheelAnimationFrame) {
      this._deltaYAcc += t, e.preventDefault();
      return;
    }
    t += this._deltaYAcc, this._deltaYAcc = 0, this._wheelAnimationFrame = !0, this.__debouncerWheelAnimationFrame = R.debounce(
      this.__debouncerWheelAnimationFrame,
      wt,
      () => {
        this._wheelAnimationFrame = !1;
      }
    );
    const r = Math.abs(e.deltaX) + Math.abs(t);
    this._canScroll(this.scrollTarget, e.deltaX, t) ? (e.preventDefault(), this.scrollTarget.scrollTop += t, this.scrollTarget.scrollLeft += e.deltaX, this._hasResidualMomentum = !0, this._ignoreNewWheel = !0, this._debouncerIgnoreNewWheel = R.debounce(
      this._debouncerIgnoreNewWheel,
      _e.after(this.timeouts.IGNORE_WHEEL),
      () => {
        this._ignoreNewWheel = !1;
      }
    )) : this._hasResidualMomentum && r <= this._previousMomentum || this._ignoreNewWheel ? e.preventDefault() : r > this._previousMomentum && (this._hasResidualMomentum = !1), this._previousMomentum = r;
  }
  /**
   * Determines if the element has an ancestor that handles the scroll delta prior to this
   *
   * @private
   */
  _hasScrolledAncestor(e, t, r) {
    if (e === this.scrollTarget || e === this.scrollTarget.getRootNode().host)
      return !1;
    if (this._canScroll(e, t, r) && ["auto", "scroll"].indexOf(getComputedStyle(e).overflow) !== -1)
      return !0;
    if (e !== this && e.parentElement)
      return this._hasScrolledAncestor(e.parentElement, t, r);
  }
  _canScroll(e, t, r) {
    return r > 0 && e.scrollTop < e.scrollHeight - e.offsetHeight || r < 0 && e.scrollTop > 0 || t > 0 && e.scrollLeft < e.scrollWidth - e.offsetWidth || t < 0 && e.scrollLeft > 0;
  }
  /**
   * Increases the pool size.
   * @override
   */
  _increasePoolIfNeeded(e) {
    if (this._physicalCount > 2 && e) {
      const r = Math.ceil(this._optPhysicalSize / this._physicalAverage) - this._physicalCount;
      super._increasePoolIfNeeded(Math.max(e, Math.min(100, r)));
    } else
      super._increasePoolIfNeeded(e);
  }
  /**
   * @returns {Number|undefined} - The browser's default font-size in pixels
   * @private
   */
  _getScrollLineHeight() {
    const e = document.createElement("div");
    e.style.fontSize = "initial", e.style.display = "none", document.body.appendChild(e);
    const t = window.getComputedStyle(e).fontSize;
    return document.body.removeChild(e), t ? window.parseInt(t) : void 0;
  }
  __getVisibleElements() {
    return Array.from(this.elementsContainer.children).filter((e) => !e.hidden);
  }
  /** @private */
  __reorderElements() {
    if (this.__mouseDown) {
      this.__pendingReorder = !0;
      return;
    }
    this.__pendingReorder = !1;
    const e = this._virtualStart + (this._vidxOffset || 0), t = this.__getVisibleElements(), s = t.find(
      (a) => a.contains(this.elementsContainer.getRootNode().activeElement) || a.contains(this.scrollTarget.getRootNode().activeElement)
    ) || t[0];
    if (!s)
      return;
    const o = s.__virtualIndex - e, n = t.indexOf(s) - o;
    if (n > 0)
      for (let a = 0; a < n; a++)
        this.elementsContainer.appendChild(t[a]);
    else if (n < 0)
      for (let a = t.length + n; a < t.length; a++)
        this.elementsContainer.insertBefore(t[a], t[0]);
    if (jh) {
      const { transform: a } = this.scrollTarget.style;
      this.scrollTarget.style.transform = "translateZ(0)", setTimeout(() => {
        this.scrollTarget.style.transform = a;
      });
    }
  }
  /** @private */
  _adjustVirtualIndexOffset(e) {
    if (this._virtualCount >= this.size)
      this._vidxOffset = 0;
    else if (this.__skipNextVirtualIndexAdjust)
      this.__skipNextVirtualIndexAdjust = !1;
    else if (Math.abs(e) > 1e4) {
      const t = this._scrollTop / (this.scrollTarget.scrollHeight - this.scrollTarget.offsetHeight), r = t * this.size;
      this._vidxOffset = Math.round(r - t * this._virtualCount);
    } else {
      const t = this._vidxOffset, r = Jo, s = 100;
      this._scrollTop === 0 ? (this._vidxOffset = 0, t !== this._vidxOffset && super.scrollToIndex(0)) : this.firstVisibleIndex < r && this._vidxOffset > 0 && (this._vidxOffset -= Math.min(this._vidxOffset, s), super.scrollToIndex(this.firstVisibleIndex + (t - this._vidxOffset)));
      const o = this.size - this._virtualCount;
      this._scrollTop >= this._maxScrollTop && this._maxScrollTop > 0 ? (this._vidxOffset = o, t !== this._vidxOffset && super.scrollToIndex(this._virtualCount - 1)) : this.firstVisibleIndex > this._virtualCount - r && this._vidxOffset < o && (this._vidxOffset += Math.min(o - this._vidxOffset, s), super.scrollToIndex(this.firstVisibleIndex - (this._vidxOffset - t)));
    }
  }
}
Object.setPrototypeOf(Gh.prototype, fv);
class Yh {
  /**
   * @typedef {Object} VirtualizerConfig
   * @property {Function} createElements Function that returns the given number of new elements
   * @property {Function} updateElement Function that updates the element at a specific index
   * @property {HTMLElement} scrollTarget Reference to the scrolling element
   * @property {HTMLElement} scrollContainer Reference to a wrapper for the item elements (or a slot) inside the scrollTarget
   * @property {HTMLElement | undefined} elementsContainer Reference to the container in which the item elements are placed, defaults to scrollContainer
   * @property {boolean | undefined} reorderElements Determines whether the physical item elements should be kept in order in the DOM
   * @param {VirtualizerConfig} config Configuration for the virtualizer
   */
  constructor(e) {
    this.__adapter = new Gh(e);
  }
  /**
   * Gets the index of the first visible item in the viewport.
   *
   * @return {number}
   */
  get firstVisibleIndex() {
    return this.__adapter.adjustedFirstVisibleIndex;
  }
  /**
   * Gets the index of the last visible item in the viewport.
   *
   * @return {number}
   */
  get lastVisibleIndex() {
    return this.__adapter.adjustedLastVisibleIndex;
  }
  /**
   * The size of the virtualizer
   * @return {number | undefined} The size of the virtualizer
   */
  get size() {
    return this.__adapter.size;
  }
  /**
   * The size of the virtualizer
   * @param {number} size The size of the virtualizer
   */
  set size(e) {
    this.__adapter.size = e;
  }
  /**
   * Scroll to a specific index in the virtual list
   *
   * @method scrollToIndex
   * @param {number} index The index of the item
   */
  scrollToIndex(e) {
    this.__adapter.scrollToIndex(e);
  }
  /**
   * Requests the virtualizer to re-render the item elements on an index range, if currently in the DOM
   *
   * @method update
   * @param {number | undefined} startIndex The start index of the range
   * @param {number | undefined} endIndex The end index of the range
   */
  update(e = 0, t = this.size - 1) {
    this.__adapter.update(e, t);
  }
  /**
   * Flushes active asynchronous tasks so that the component and the DOM end up in a stable state
   *
   * @method update
   * @param {number | undefined} startIndex The start index of the range
   * @param {number | undefined} endIndex The end index of the range
   */
  flush() {
    this.__adapter.flush();
  }
}
/**
 * @license
 * Copyright (c) 2016 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const mv = (i) => class extends i {
  static get observers() {
    return ["_a11yUpdateGridSize(size, _columnTree, _columnTree.*)"];
  }
  /** @private */
  _a11yGetHeaderRowCount(t) {
    return t.filter((r) => r.some((s) => s.headerRenderer || s.path || s.header)).length;
  }
  /** @private */
  _a11yGetFooterRowCount(t) {
    return t.filter((r) => r.some((s) => s.headerRenderer)).length;
  }
  /** @private */
  _a11yUpdateGridSize(t, r) {
    if (t === void 0 || r === void 0)
      return;
    const s = r[r.length - 1];
    this.$.table.setAttribute(
      "aria-rowcount",
      t + this._a11yGetHeaderRowCount(r) + this._a11yGetFooterRowCount(r)
    ), this.$.table.setAttribute("aria-colcount", s && s.length || 0), this._a11yUpdateHeaderRows(), this._a11yUpdateFooterRows();
  }
  /** @protected */
  _a11yUpdateHeaderRows() {
    le(this.$.header, (t, r) => {
      t.setAttribute("aria-rowindex", r + 1);
    });
  }
  /** @protected */
  _a11yUpdateFooterRows() {
    le(this.$.footer, (t, r) => {
      t.setAttribute("aria-rowindex", this._a11yGetHeaderRowCount(this._columnTree) + this.size + r + 1);
    });
  }
  /**
   * @param {!HTMLElement} row
   * @param {number} index
   * @protected
   */
  _a11yUpdateRowRowindex(t, r) {
    t.setAttribute("aria-rowindex", r + this._a11yGetHeaderRowCount(this._columnTree) + 1);
  }
  /**
   * @param {!HTMLElement} row
   * @param {boolean} selected
   * @protected
   */
  _a11yUpdateRowSelected(t, r) {
    t.setAttribute("aria-selected", !!r), Ir(t, (s) => {
      s.setAttribute("aria-selected", !!r);
    });
  }
  /**
   * @param {!HTMLElement} row
   * @protected
   */
  _a11yUpdateRowExpanded(t) {
    this.__isRowExpandable(t) ? t.setAttribute("aria-expanded", "false") : this.__isRowCollapsible(t) ? t.setAttribute("aria-expanded", "true") : t.removeAttribute("aria-expanded");
  }
  /**
   * @param {!HTMLElement} row
   * @param {number} level
   * @protected
   */
  _a11yUpdateRowLevel(t, r) {
    r > 0 || this.__isRowCollapsible(t) || this.__isRowExpandable(t) ? t.setAttribute("aria-level", r + 1) : t.removeAttribute("aria-level");
  }
  /**
   * @param {!HTMLElement} row
   * @param {!HTMLElement} detailsCell
   * @protected
   */
  _a11ySetRowDetailsCell(t, r) {
    Ir(t, (s) => {
      s !== r && s.setAttribute("aria-controls", r.id);
    });
  }
  /**
   * @param {!HTMLElement} row
   * @param {number} colspan
   * @protected
   */
  _a11yUpdateCellColspan(t, r) {
    t.setAttribute("aria-colspan", Number(r));
  }
  /** @protected */
  _a11yUpdateSorters() {
    Array.from(this.querySelectorAll("vaadin-grid-sorter")).forEach((t) => {
      let r = t.parentNode;
      for (; r && r.localName !== "vaadin-grid-cell-content"; )
        r = r.parentNode;
      r && r.assignedSlot && r.assignedSlot.parentNode.setAttribute(
        "aria-sort",
        {
          asc: "ascending",
          desc: "descending"
        }[String(t.direction)] || "none"
      );
    });
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Zh = (i) => {
  if (!i.parentNode)
    return !1;
  const t = Array.from(
    i.parentNode.querySelectorAll(
      "[tabindex], button, input, select, textarea, object, iframe, a[href], area[href]"
    )
  ).filter((r) => {
    const s = r.getAttribute("part");
    return !(s && s.includes("body-cell"));
  }).includes(i);
  return !i.disabled && t && i.offsetParent && getComputedStyle(i).visibility !== "hidden";
}, gv = (i) => class extends i {
  static get properties() {
    return {
      /**
       * The item user has last interacted with. Turns to `null` after user deactivates
       * the item by re-interacting with the currently active item.
       * @type {GridItem}
       */
      activeItem: {
        type: Object,
        notify: !0,
        value: null
      }
    };
  }
  /** @protected */
  ready() {
    super.ready(), this.$.scroller.addEventListener("click", this._onClick.bind(this)), this.addEventListener("cell-activate", this._activateItem.bind(this)), this.addEventListener("row-activate", this._activateItem.bind(this));
  }
  /** @private */
  _activateItem(t) {
    const r = t.detail.model, s = r ? r.item : null;
    s && (this.activeItem = this._itemsEqual(this.activeItem, s) ? null : s);
  }
  /**
   * We need to listen to click instead of tap because on mobile safari, the
   * document.activeElement has not been updated (focus has not been shifted)
   * yet at the point when tap event is being executed.
   * @param {!MouseEvent} e
   * @protected
   */
  _onClick(t) {
    if (t.defaultPrevented)
      return;
    const r = t.composedPath(), s = r[r.indexOf(this.$.table) - 3];
    if (!s || s.getAttribute("part").indexOf("details-cell") > -1)
      return;
    const o = s._content, n = this.getRootNode().activeElement;
    !o.contains(n) && !this._isFocusable(t.target) && !(t.target instanceof HTMLLabelElement) && this.dispatchEvent(
      new CustomEvent("cell-activate", {
        detail: {
          model: this.__getRowModel(s.parentElement)
        }
      })
    );
  }
  /**
   * @param {!Element} target
   * @return {boolean}
   * @protected
   */
  _isFocusable(t) {
    return Zh(t);
  }
  /**
   * Fired when the `activeItem` property changes.
   *
   * @event active-item-changed
   */
  /**
   * Fired when the cell is activated with click or keyboard.
   *
   * @event cell-activate
   */
};
function gr(i, e) {
  return i.split(".").reduce((t, r) => t[r], e);
}
function $c(i, e, t) {
  if (t.length === 0)
    return !1;
  let r = !0;
  return i.forEach(({ path: s }) => {
    if (!s || s.indexOf(".") === -1)
      return;
    const o = s.replace(/\.[^.]*$/u, "");
    gr(o, t[0]) === void 0 && (r = !1);
  }), r;
}
function Bs(i) {
  return [void 0, null].indexOf(i) >= 0 ? "" : isNaN(i) ? i.toString() : i;
}
function Pc(i, e) {
  return i = Bs(i), e = Bs(e), i < e ? -1 : i > e ? 1 : 0;
}
function _v(i, e) {
  return i.sort((t, r) => e.map((s) => s.direction === "asc" ? Pc(gr(s.path, t), gr(s.path, r)) : s.direction === "desc" ? Pc(gr(s.path, r), gr(s.path, t)) : 0).reduce((s, o) => s !== 0 ? s : o, 0));
}
function bv(i, e) {
  return i.filter((t) => e.every((r) => {
    const s = Bs(gr(r.path, t)), o = Bs(r.value).toString().toLowerCase();
    return s.toString().toLowerCase().includes(o);
  }));
}
const yv = (i) => (e, t) => {
  let r = i ? [...i] : [];
  e.filters && $c(e.filters, "filtering", r) && (r = bv(r, e.filters)), Array.isArray(e.sortOrders) && e.sortOrders.length && $c(e.sortOrders, "sorting", r) && (r = _v(r, e.sortOrders));
  const s = Math.min(r.length, e.pageSize), o = e.page * s, n = o + s, a = r.slice(o, n);
  t(a, r.length);
};
/**
 * @license
 * Copyright (c) 2016 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const vv = (i) => class extends i {
  static get properties() {
    return {
      /**
       * An array containing the items which will be passed to renderer functions.
       *
       * @type {Array<!GridItem> | undefined}
       */
      items: Array
    };
  }
  static get observers() {
    return ["__dataProviderOrItemsChanged(dataProvider, items, isAttached, items.*, _filters, _sorters)"];
  }
  /** @private */
  __setArrayDataProvider(t) {
    const r = yv(this.items);
    r.__items = t, this.setProperties({
      _arrayDataProvider: r,
      size: t.length,
      dataProvider: r
    });
  }
  /** @private */
  __dataProviderOrItemsChanged(t, r, s) {
    s && (this._arrayDataProvider ? t !== this._arrayDataProvider ? this.setProperties({
      _arrayDataProvider: void 0,
      items: void 0
    }) : r ? this._arrayDataProvider.__items === r ? (this.clearCache(), this.size = this._effectiveSize) : this.__setArrayDataProvider(r) : (this.setProperties({
      _arrayDataProvider: void 0,
      dataProvider: void 0,
      size: 0
    }), this.clearCache()) : r && this.__setArrayDataProvider(r));
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const wv = (i) => class extends i {
  static get properties() {
    return {
      /**
       * Set to true to allow column reordering.
       * @attr {boolean} column-reordering-allowed
       * @type {boolean}
       */
      columnReorderingAllowed: {
        type: Boolean,
        value: !1
      },
      /** @private */
      _orderBaseScope: {
        type: Number,
        value: 1e7
      }
    };
  }
  static get observers() {
    return ["_updateOrders(_columnTree)"];
  }
  /** @protected */
  ready() {
    super.ready(), pe(this, "track", this._onTrackEvent), this._reorderGhost = this.shadowRoot.querySelector('[part="reorder-ghost"]'), this.addEventListener("touchstart", this._onTouchStart.bind(this)), this.addEventListener("touchmove", this._onTouchMove.bind(this)), this.addEventListener("touchend", this._onTouchEnd.bind(this)), this.addEventListener("contextmenu", this._onContextMenu.bind(this));
  }
  /** @private */
  _onContextMenu(t) {
    this.hasAttribute("reordering") && (t.preventDefault(), Ii || this._onTrackEnd());
  }
  /** @private */
  _onTouchStart(t) {
    this._startTouchReorderTimeout = setTimeout(() => {
      this._onTrackStart({
        detail: {
          x: t.touches[0].clientX,
          y: t.touches[0].clientY
        }
      });
    }, 100);
  }
  /** @private */
  _onTouchMove(t) {
    this._draggedColumn && t.preventDefault(), clearTimeout(this._startTouchReorderTimeout);
  }
  /** @private */
  _onTouchEnd() {
    clearTimeout(this._startTouchReorderTimeout), this._onTrackEnd();
  }
  /** @private */
  _onTrackEvent(t) {
    if (t.detail.state === "start") {
      const r = t.composedPath(), s = r[r.indexOf(this.$.header) - 2];
      if (!s || !s._content || s._content.contains(this.getRootNode().activeElement) || this.$.scroller.hasAttribute("column-resizing"))
        return;
      this._touchDevice || this._onTrackStart(t);
    } else
      t.detail.state === "track" ? this._onTrack(t) : t.detail.state === "end" && this._onTrackEnd(t);
  }
  /** @private */
  _onTrackStart(t) {
    if (!this.columnReorderingAllowed)
      return;
    const r = t.composedPath && t.composedPath();
    if (r && r.some((o) => o.hasAttribute && o.hasAttribute("draggable")))
      return;
    const s = this._cellFromPoint(t.detail.x, t.detail.y);
    if (!(!s || !s.getAttribute("part").includes("header-cell"))) {
      for (this.toggleAttribute("reordering", !0), this._draggedColumn = s._column; this._draggedColumn.parentElement.childElementCount === 1; )
        this._draggedColumn = this._draggedColumn.parentElement;
      this._setSiblingsReorderStatus(this._draggedColumn, "allowed"), this._draggedColumn._reorderStatus = "dragging", this._updateGhost(s), this._reorderGhost.style.visibility = "visible", this._updateGhostPosition(t.detail.x, this._touchDevice ? t.detail.y - 50 : t.detail.y), this._autoScroller();
    }
  }
  /** @private */
  _onTrack(t) {
    if (!this._draggedColumn)
      return;
    const r = this._cellFromPoint(t.detail.x, t.detail.y);
    if (!r)
      return;
    const s = this._getTargetColumn(r, this._draggedColumn);
    if (this._isSwapAllowed(this._draggedColumn, s) && this._isSwappableByPosition(s, t.detail.x)) {
      const o = this._columnTree.findIndex((d) => d.includes(s)), n = this._getColumnsInOrder(o), a = n.indexOf(this._draggedColumn), l = n.indexOf(s), c = a < l ? 1 : -1;
      for (let d = a; d !== l; d += c)
        this._swapColumnOrders(this._draggedColumn, n[d + c]);
    }
    this._updateGhostPosition(t.detail.x, this._touchDevice ? t.detail.y - 50 : t.detail.y), this._lastDragClientX = t.detail.x;
  }
  /** @private */
  _onTrackEnd() {
    this._draggedColumn && (this.toggleAttribute("reordering", !1), this._draggedColumn._reorderStatus = "", this._setSiblingsReorderStatus(this._draggedColumn, ""), this._draggedColumn = null, this._lastDragClientX = null, this._reorderGhost.style.visibility = "hidden", this.dispatchEvent(
      new CustomEvent("column-reorder", {
        detail: {
          columns: this._getColumnsInOrder()
        }
      })
    ));
  }
  /**
   * Returns the columns (or column groups) on the specified header level in visual order.
   * By default, the bottom level is used.
   *
   * @return {!Array<!GridColumn>}
   * @protected
   */
  _getColumnsInOrder(t = this._columnTree.length - 1) {
    return this._columnTree[t].filter((r) => !r.hidden).sort((r, s) => r._order - s._order);
  }
  /**
   * @param {number} x
   * @param {number} y
   * @return {HTMLElement | undefined}
   * @protected
   */
  _cellFromPoint(t = 0, r = 0) {
    this._draggedColumn || this.$.scroller.toggleAttribute("no-content-pointer-events", !0);
    const s = this.shadowRoot.elementFromPoint(t, r);
    if (this.$.scroller.toggleAttribute("no-content-pointer-events", !1), s && s._column)
      return s;
  }
  /**
   * @param {number} eventClientX
   * @param {number} eventClientY
   * @protected
   */
  _updateGhostPosition(t, r) {
    const s = this._reorderGhost.getBoundingClientRect(), o = t - s.width / 2, n = r - s.height / 2, a = parseInt(this._reorderGhost._left || 0), l = parseInt(this._reorderGhost._top || 0);
    this._reorderGhost._left = a - (s.left - o), this._reorderGhost._top = l - (s.top - n), this._reorderGhost.style.transform = `translate(${this._reorderGhost._left}px, ${this._reorderGhost._top}px)`;
  }
  /**
   * @param {!HTMLElement} cell
   * @return {!HTMLElement}
   * @protected
   */
  _updateGhost(t) {
    const r = this._reorderGhost;
    r.textContent = t._content.innerText;
    const s = window.getComputedStyle(t);
    return [
      "boxSizing",
      "display",
      "width",
      "height",
      "background",
      "alignItems",
      "padding",
      "border",
      "flex-direction",
      "overflow"
    ].forEach((o) => {
      r.style[o] = s[o];
    }), r;
  }
  /** @private */
  _updateOrders(t) {
    t !== void 0 && (t[0].forEach((r) => {
      r._order = 0;
    }), Uh(t[0], this._orderBaseScope, 0));
  }
  /**
   * @param {!GridColumn} column
   * @param {string} status
   * @protected
   */
  _setSiblingsReorderStatus(t, r) {
    le(t.parentNode, (s) => {
      /column/u.test(s.localName) && this._isSwapAllowed(s, t) && (s._reorderStatus = r);
    });
  }
  /** @protected */
  _autoScroller() {
    if (this._lastDragClientX) {
      const t = this._lastDragClientX - this.getBoundingClientRect().right + 50, r = this.getBoundingClientRect().left - this._lastDragClientX + 50;
      t > 0 ? this.$.table.scrollLeft += t / 10 : r > 0 && (this.$.table.scrollLeft -= r / 10);
    }
    this._draggedColumn && setTimeout(() => this._autoScroller(), 10);
  }
  /**
   * @param {GridColumn | undefined} column1
   * @param {GridColumn | undefined} column2
   * @return {boolean | undefined}
   * @protected
   */
  _isSwapAllowed(t, r) {
    if (t && r) {
      const s = t !== r, o = t.parentElement === r.parentElement, n = t.frozen && r.frozen || // Both columns are frozen
      t.frozenToEnd && r.frozenToEnd || // Both columns are frozen to end
      !t.frozen && !t.frozenToEnd && !r.frozen && !r.frozenToEnd;
      return s && o && n;
    }
  }
  /**
   * @param {!GridColumn} targetColumn
   * @param {number} clientX
   * @return {boolean}
   * @protected
   */
  _isSwappableByPosition(t, r) {
    const s = Array.from(this.$.header.querySelectorAll('tr:not([hidden]) [part~="cell"]')).find(
      (a) => t.contains(a._column)
    ), o = this.$.header.querySelector("tr:not([hidden]) [reorder-status=dragging]").getBoundingClientRect(), n = s.getBoundingClientRect();
    return n.left > o.left ? r > n.right - o.width : r < n.left + o.width;
  }
  /**
   * @param {!GridColumn} column1
   * @param {!GridColumn} column2
   * @protected
   */
  _swapColumnOrders(t, r) {
    [t._order, r._order] = [r._order, t._order], this._debounceUpdateFrozenColumn(), this._updateFirstAndLastColumn();
  }
  /**
   * @param {HTMLElement | undefined} targetCell
   * @param {GridColumn} draggedColumn
   * @return {GridColumn | undefined}
   * @protected
   */
  _getTargetColumn(t, r) {
    if (t && r) {
      let s = t._column;
      for (; s.parentElement !== r.parentElement && s !== this; )
        s = s.parentElement;
      return s.parentElement === r.parentElement ? s : t._column;
    }
  }
  /**
   * Fired when the columns in the grid are reordered.
   *
   * @event column-reorder
   * @param {Object} detail
   * @param {Object} detail.columns the columns in the new order
   */
};
/**
 * @license
 * Copyright (c) 2016 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const xv = (i) => class extends i {
  /** @protected */
  ready() {
    super.ready();
    const t = this.$.scroller;
    pe(t, "track", this._onHeaderTrack.bind(this)), t.addEventListener("touchmove", (r) => t.hasAttribute("column-resizing") && r.preventDefault()), t.addEventListener(
      "contextmenu",
      (r) => r.target.getAttribute("part") === "resize-handle" && r.preventDefault()
    ), t.addEventListener(
      "mousedown",
      (r) => r.target.getAttribute("part") === "resize-handle" && r.preventDefault()
    );
  }
  /** @private */
  _onHeaderTrack(t) {
    const r = t.target;
    if (r.getAttribute("part") === "resize-handle") {
      let o = r.parentElement._column;
      for (this.$.scroller.toggleAttribute("column-resizing", !0); o.localName === "vaadin-grid-column-group"; )
        o = o._childColumns.slice(0).sort((u, h) => u._order - h._order).filter((u) => !u.hidden).pop();
      const n = this.__isRTL, a = t.detail.x, l = Array.from(this.$.header.querySelectorAll('[part~="row"]:last-child [part~="cell"]')), c = l.find((u) => u._column === o);
      if (c.offsetWidth) {
        const u = getComputedStyle(c._content), h = 10 + parseInt(u.paddingLeft) + parseInt(u.paddingRight) + parseInt(u.borderLeftWidth) + parseInt(u.borderRightWidth) + parseInt(u.marginLeft) + parseInt(u.marginRight);
        let f;
        const m = c.offsetWidth, v = c.getBoundingClientRect();
        c.hasAttribute("frozen-to-end") ? f = m + (n ? a - v.right : v.left - a) : f = m + (n ? v.left - a : a - v.right), o.width = `${Math.max(h, f)}px`, o.flexGrow = 0;
      }
      l.sort((u, h) => u._column._order - h._column._order).forEach((u, h, f) => {
        h < f.indexOf(c) && (u._column.width = `${u.offsetWidth}px`, u._column.flexGrow = 0);
      });
      const d = this._frozenToEndCells[0];
      if (d && this.$.table.scrollWidth > this.$.table.offsetWidth) {
        const u = d.getBoundingClientRect(), h = a - (n ? u.right : u.left);
        (n && h <= 0 || !n && h >= 0) && (this.$.table.scrollLeft += h);
      }
      t.detail.state === "end" && (this.$.scroller.toggleAttribute("column-resizing", !1), this.dispatchEvent(
        new CustomEvent("column-resize", {
          detail: { resizedColumn: o }
        })
      )), this._resizeHandler();
    }
  }
  /**
   * Fired when a column in the grid is resized by the user.
   *
   * @event column-resize
   * @param {Object} detail
   * @param {Object} detail.resizedColumn the column that was resized
   */
};
/**
 * @license
 * Copyright (c) 2016 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Mc = class Kh {
  /**
   * @param {!HTMLElement} grid
   * @param {!ItemCache | undefined} parentCache
   * @param {!GridItem | undefined} parentItem
   */
  constructor(e, t, r) {
    this.grid = e, this.parentCache = t, this.parentItem = r, this.itemCaches = {}, this.items = [], this.effectiveSize = 0, this.size = 0, this.pendingRequests = {};
  }
  /**
   * @return {boolean}
   */
  isLoading() {
    return !!(Object.keys(this.pendingRequests).length || Object.keys(this.itemCaches).filter((e) => this.itemCaches[e].isLoading())[0]);
  }
  /**
   * @param {number} index
   * @return {!GridItem | undefined}
   */
  getItemForIndex(e) {
    const { cache: t, scaledIndex: r } = this.getCacheAndIndex(e);
    return t.items[r];
  }
  updateSize() {
    this.effectiveSize = !this.parentItem || this.grid._isExpanded(this.parentItem) ? this.size + Object.keys(this.itemCaches).reduce((e, t) => {
      const r = this.itemCaches[t];
      return r.updateSize(), e + r.effectiveSize;
    }, 0) : 0;
  }
  /**
   * @param {number} scaledIndex
   */
  ensureSubCacheForScaledIndex(e) {
    if (!this.itemCaches[e]) {
      const t = new Kh(this.grid, this, this.items[e]);
      this.itemCaches[e] = t, this.grid._loadPage(0, t);
    }
  }
  /**
   * @param {number} index
   * @return {{cache: !ItemCache, scaledIndex: number}}
   */
  getCacheAndIndex(e) {
    let t = e;
    for (const [r, s] of Object.entries(this.itemCaches)) {
      const o = Number(r);
      if (t <= o)
        return { cache: this, scaledIndex: t };
      if (t <= o + s.effectiveSize)
        return s.getCacheAndIndex(t - o - 1);
      t -= s.effectiveSize;
    }
    return { cache: this, scaledIndex: t };
  }
  /**
   * Gets the scaled index as flattened index on this cache level.
   * In practice, this means that the effective size of any expanded
   * subcaches preceding the index are added to the value.
   * @param {number} scaledIndex
   * @return {number} The flat index on this cache level.
   */
  getFlatIndex(e) {
    const t = Math.max(0, Math.min(this.size - 1, e));
    return Object.entries(this.itemCaches).reduce((r, [s, o]) => t > Number(s) ? r + o.effectiveSize : r, t);
  }
}, Cv = (i) => class extends i {
  static get properties() {
    return {
      /**
       * The number of root-level items in the grid.
       * @attr {number} size
       * @type {number}
       */
      size: {
        type: Number,
        notify: !0
      },
      /**
       * Number of items fetched at a time from the dataprovider.
       * @attr {number} page-size
       * @type {number}
       */
      pageSize: {
        type: Number,
        value: 50,
        observer: "_pageSizeChanged"
      },
      /**
       * Function that provides items lazily. Receives arguments `params`, `callback`
       *
       * `params.page` Requested page index
       *
       * `params.pageSize` Current page size
       *
       * `params.filters` Currently applied filters
       *
       * `params.sortOrders` Currently applied sorting orders
       *
       * `params.parentItem` When tree is used, and sublevel items
       * are requested, reference to parent item of the requested sublevel.
       * Otherwise `undefined`.
       *
       * `callback(items, size)` Callback function with arguments:
       *   - `items` Current page of items
       *   - `size` Total number of items. When tree sublevel items
       *     are requested, total number of items in the requested sublevel.
       *     Optional when tree is not used, required for tree.
       *
       * @type {GridDataProvider | null | undefined}
       */
      dataProvider: {
        type: Object,
        notify: !0,
        observer: "_dataProviderChanged"
      },
      /**
       * `true` while data is being requested from the data provider.
       */
      loading: {
        type: Boolean,
        notify: !0,
        readOnly: !0,
        reflectToAttribute: !0
      },
      /**
       * @type {!ItemCache}
       * @protected
       */
      _cache: {
        type: Object,
        value() {
          return new Mc(this);
        }
      },
      /**
       * @protected
       */
      _hasData: {
        type: Boolean,
        value: !1
      },
      /**
       * Path to an item sub-property that indicates whether the item has child items.
       * @attr {string} item-has-children-path
       */
      itemHasChildrenPath: {
        type: String,
        value: "children",
        observer: "__itemHasChildrenPathChanged"
      },
      /**
       * Path to an item sub-property that identifies the item.
       * @attr {string} item-id-path
       */
      itemIdPath: {
        type: String,
        value: null
      },
      /**
       * An array that contains the expanded items.
       * @type {!Array<!GridItem>}
       */
      expandedItems: {
        type: Object,
        notify: !0,
        value: () => []
      },
      /**
       * @private
       */
      __expandedKeys: {
        type: Object,
        computed: "__computeExpandedKeys(itemIdPath, expandedItems.*)"
      }
    };
  }
  static get observers() {
    return ["_sizeChanged(size)", "_expandedItemsChanged(expandedItems.*)"];
  }
  /** @private */
  _sizeChanged(t) {
    const r = t - this._cache.size;
    this._cache.size += r, this._cache.effectiveSize += r, this._effectiveSize = this._cache.effectiveSize;
  }
  /** @private */
  __itemHasChildrenPathChanged(t, r) {
    !r && t === "children" || this.requestContentUpdate();
  }
  /**
   * @param {number} index
   * @param {HTMLElement} el
   * @protected
   */
  _getItem(t, r) {
    if (t >= this._effectiveSize)
      return;
    r.index = t;
    const { cache: s, scaledIndex: o } = this._cache.getCacheAndIndex(t), n = s.items[o];
    n ? (this.__updateLoading(r, !1), this._updateItem(r, n), this._isExpanded(n) && s.ensureSubCacheForScaledIndex(o)) : (this.__updateLoading(r, !0), this._loadPage(this._getPageForIndex(o), s));
  }
  /**
   * @param {!HTMLElement} row
   * @param {boolean} loading
   * @private
   */
  __updateLoading(t, r) {
    const s = Tr(t);
    fo(t, "loading", r), gt(s, "loading-row-cell", r);
  }
  /**
   * Returns a value that identifies the item. Uses `itemIdPath` if available.
   * Can be customized by overriding.
   * @param {!GridItem} item
   * @return {!GridItem | !unknown}
   */
  getItemId(t) {
    return this.itemIdPath ? Ct(this.itemIdPath, t) : t;
  }
  /**
   * @param {!GridItem} item
   * @return {boolean}
   * @protected
   */
  _isExpanded(t) {
    return this.__expandedKeys.has(this.getItemId(t));
  }
  /** @private */
  _expandedItemsChanged() {
    this._cache.updateSize(), this._effectiveSize = this._cache.effectiveSize, this.__updateVisibleRows();
  }
  /** @private */
  __computeExpandedKeys(t, r) {
    const s = r.base || [], o = /* @__PURE__ */ new Set();
    return s.forEach((n) => {
      o.add(this.getItemId(n));
    }), o;
  }
  /**
   * Expands the given item tree.
   * @param {!GridItem} item
   */
  expandItem(t) {
    this._isExpanded(t) || (this.expandedItems = [...this.expandedItems, t]);
  }
  /**
   * Collapses the given item tree.
   * @param {!GridItem} item
   */
  collapseItem(t) {
    this._isExpanded(t) && (this.expandedItems = this.expandedItems.filter((r) => !this._itemsEqual(r, t)));
  }
  /**
   * @param {number} index
   * @return {number}
   * @protected
   */
  _getIndexLevel(t) {
    let { cache: r } = this._cache.getCacheAndIndex(t), s = 0;
    for (; r.parentCache; )
      r = r.parentCache, s += 1;
    return s;
  }
  /**
   * @param {number} page
   * @param {ItemCache} cache
   * @protected
   */
  _loadPage(t, r) {
    if (!r.pendingRequests[t] && this.dataProvider) {
      this._setLoading(!0), r.pendingRequests[t] = !0;
      const s = {
        page: t,
        pageSize: this.pageSize,
        sortOrders: this._mapSorters(),
        filters: this._mapFilters(),
        parentItem: r.parentItem
      };
      this.dataProvider(s, (o, n) => {
        n !== void 0 ? r.size = n : s.parentItem && (r.size = o.length), o.forEach((a, l) => {
          const c = t * this.pageSize + l;
          r.items[c] = a;
        }), this._cache.updateSize(), this._effectiveSize = this._cache.effectiveSize, this._getRenderedRows().forEach((a) => {
          const { cache: l, scaledIndex: c } = this._cache.getCacheAndIndex(a.index), d = l.items[c];
          d && this._isExpanded(d) && l.ensureSubCacheForScaledIndex(c);
        }), this._hasData = !0, delete r.pendingRequests[t], this._debouncerApplyCachedData = R.debounce(this._debouncerApplyCachedData, _e.after(0), () => {
          this._setLoading(!1), this._getRenderedRows().forEach((a) => {
            this._cache.getItemForIndex(a.index) && this._getItem(a.index, a);
          }), this.__scrollToPendingIndexes(), this.__dispatchPendingBodyCellFocus();
        }), this._cache.isLoading() || this._debouncerApplyCachedData.flush(), this._onDataProviderPageLoaded();
      });
    }
  }
  /** @protected */
  _onDataProviderPageLoaded() {
  }
  /**
   * @param {number} index
   * @return {number}
   * @private
   */
  _getPageForIndex(t) {
    return Math.floor(t / this.pageSize);
  }
  /**
   * Clears the cached pages and reloads data from dataprovider when needed.
   */
  clearCache() {
    this._cache = new Mc(this), this._cache.size = this.size || 0, this._cache.updateSize(), this._hasData = !1, this.__updateVisibleRows(), this._effectiveSize || this._loadPage(0, this._cache);
  }
  /** @private */
  _pageSizeChanged(t, r) {
    r !== void 0 && t !== r && this.clearCache();
  }
  /** @protected */
  _checkSize() {
    this.size === void 0 && this._effectiveSize;
  }
  /** @private */
  _dataProviderChanged(t, r) {
    r !== void 0 && this.clearCache(), this._ensureFirstPageLoaded(), this._debouncerCheckSize = R.debounce(
      this._debouncerCheckSize,
      _e.after(2e3),
      this._checkSize.bind(this)
    );
  }
  /** @protected */
  _ensureFirstPageLoaded() {
    this._hasData || this._loadPage(0, this._cache);
  }
  /**
   * @param {!GridItem} item1
   * @param {!GridItem} item2
   * @return {boolean}
   * @protected
   */
  _itemsEqual(t, r) {
    return this.getItemId(t) === this.getItemId(r);
  }
  /**
   * @param {!GridItem} item
   * @param {!Array<!GridItem>} array
   * @return {number}
   * @protected
   */
  _getItemIndexInArray(t, r) {
    let s = -1;
    return r.forEach((o, n) => {
      this._itemsEqual(o, t) && (s = n);
    }), s;
  }
  /**
   * Scroll to a specific row index in the virtual list. Note that the row index is
   * not always the same for any particular item. For example, sorting or filtering
   * items can affect the row index related to an item.
   *
   * The `indexes` parameter can be either a single number or multiple numbers.
   * The grid will first try to scroll to the item at the first index on the top level.
   * In case the item at the first index is expanded, the grid will then try scroll to the
   * item at the second index within the children of the expanded first item, and so on.
   * Each given index points to a child of the item at the previous index.
   *
   * Using `Infinity` as an index will point to the last item on the level.
   *
   * @param indexes {...number} Row indexes to scroll to
   */
  scrollToIndex(...t) {
    let r;
    for (; r !== (r = this.__getGlobalFlatIndex(t)); )
      this._scrollToFlatIndex(r);
    (this._cache.isLoading() || !this.clientHeight) && (this.__pendingScrollToIndexes = t);
  }
  /**
   * Recursively returns the globally flat index of the item the given indexes point to.
   * Each index in the array points to a sub-item of the previous index.
   * Using `Infinity` as an index will point to the last item on the level.
   *
   * @param {!Array<number>} indexes
   * @param {!ItemCache} cache
   * @param {number} flatIndex
   * @return {number}
   * @private
   */
  __getGlobalFlatIndex([t, ...r], s = this._cache, o = 0) {
    t === 1 / 0 && (t = s.size - 1);
    const n = s.getFlatIndex(t), a = s.itemCaches[t];
    return a && a.effectiveSize && r.length ? this.__getGlobalFlatIndex(r, a, o + n + 1) : o + n;
  }
  /** @private */
  __scrollToPendingIndexes() {
    if (this.__pendingScrollToIndexes && this.$.items.children.length) {
      const t = this.__pendingScrollToIndexes;
      delete this.__pendingScrollToIndexes, this.scrollToIndex(...t);
    }
  }
  /**
   * Fired when the `expandedItems` property changes.
   *
   * @event expanded-items-changed
   */
  /**
   * Fired when the `loading` property changes.
   *
   * @event loading-changed
   */
};
/**
 * @license
 * Copyright (c) 2016 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Qr = {
  BETWEEN: "between",
  ON_TOP: "on-top",
  ON_TOP_OR_BETWEEN: "on-top-or-between",
  ON_GRID: "on-grid"
}, at = {
  ON_TOP: "on-top",
  ABOVE: "above",
  BELOW: "below",
  EMPTY: "empty"
}, kv = !("draggable" in document.createElement("div")), Av = (i) => class extends i {
  static get properties() {
    return {
      /**
       * Defines the locations within the Grid row where an element can be dropped.
       *
       * Possible values are:
       * - `between`: The drop event can happen between Grid rows.
       * - `on-top`: The drop event can happen on top of Grid rows.
       * - `on-top-or-between`: The drop event can happen either on top of or between Grid rows.
       * - `on-grid`: The drop event will not happen on any specific row, it will show the drop target outline around the whole grid.
       * @attr {between|on-top|on-top-or-between|on-grid} drop-mode
       * @type {GridDropMode | null | undefined}
       */
      dropMode: String,
      /**
       * Marks the grid's rows to be available for dragging.
       * @attr {boolean} rows-draggable
       */
      rowsDraggable: Boolean,
      /**
       * A function that filters dragging of specific grid rows. The return value should be false
       * if dragging of the row should be disabled.
       *
       * Receives one argument:
       * - `model` The object with the properties related with
       *   the rendered item, contains:
       *   - `model.index` The index of the item.
       *   - `model.item` The item.
       *   - `model.expanded` Sublevel toggle state.
       *   - `model.level` Level of the tree represented with a horizontal offset of the toggle button.
       *   - `model.selected` Selected state.
       *
       * @type {GridDragAndDropFilter | null | undefined}
       */
      dragFilter: Function,
      /**
       * A function that filters dropping on specific grid rows. The return value should be false
       * if dropping on the row should be disabled.
       *
       * Receives one argument:
       * - `model` The object with the properties related with
       *   the rendered item, contains:
       *   - `model.index` The index of the item.
       *   - `model.item` The item.
       *   - `model.expanded` Sublevel toggle state.
       *   - `model.level` Level of the tree represented with a horizontal offset of the toggle button.
       *   - `model.selected` Selected state.
       *
       * @type {GridDragAndDropFilter | null | undefined}
       */
      dropFilter: Function,
      /** @private */
      __dndAutoScrollThreshold: {
        value: 50
      }
    };
  }
  static get observers() {
    return ["_dragDropAccessChanged(rowsDraggable, dropMode, dragFilter, dropFilter, loading)"];
  }
  /** @protected */
  ready() {
    super.ready(), this.$.table.addEventListener("dragstart", this._onDragStart.bind(this)), this.$.table.addEventListener("dragend", this._onDragEnd.bind(this)), this.$.table.addEventListener("dragover", this._onDragOver.bind(this)), this.$.table.addEventListener("dragleave", this._onDragLeave.bind(this)), this.$.table.addEventListener("drop", this._onDrop.bind(this)), this.$.table.addEventListener("dragenter", (t) => {
      this.dropMode && (t.preventDefault(), t.stopPropagation());
    });
  }
  /** @private */
  _onDragStart(t) {
    if (this.rowsDraggable) {
      let r = t.target;
      if (r.localName === "vaadin-grid-cell-content" && (r = r.assignedSlot.parentNode.parentNode), r.parentNode !== this.$.items)
        return;
      if (t.stopPropagation(), this.toggleAttribute("dragging-rows", !0), this._safari) {
        const a = r.style.transform;
        r.style.top = /translateY\((.*)\)/u.exec(a)[1], r.style.transform = "none", requestAnimationFrame(() => {
          r.style.top = "", r.style.transform = a;
        });
      }
      const s = r.getBoundingClientRect();
      kv ? t.dataTransfer.setDragImage(r) : t.dataTransfer.setDragImage(r, t.clientX - s.left, t.clientY - s.top);
      let o = [r];
      this._isSelected(r._item) && (o = this.__getViewportRows().filter((a) => this._isSelected(a._item)).filter((a) => !this.dragFilter || this.dragFilter(this.__getRowModel(a)))), t.dataTransfer.setData("text", this.__formatDefaultTransferData(o)), hi(r, { dragstart: o.length > 1 ? `${o.length}` : "" }), this.style.setProperty("--_grid-drag-start-x", `${t.clientX - s.left + 20}px`), this.style.setProperty("--_grid-drag-start-y", `${t.clientY - s.top + 10}px`), requestAnimationFrame(() => {
        hi(r, { dragstart: !1 }), this.style.setProperty("--_grid-drag-start-x", ""), this.style.setProperty("--_grid-drag-start-y", "");
      });
      const n = new CustomEvent("grid-dragstart", {
        detail: {
          draggedItems: o.map((a) => a._item),
          setDragData: (a, l) => t.dataTransfer.setData(a, l),
          setDraggedItemsCount: (a) => r.setAttribute("dragstart", a)
        }
      });
      n.originalEvent = t, this.dispatchEvent(n);
    }
  }
  /** @private */
  _onDragEnd(t) {
    this.toggleAttribute("dragging-rows", !1), t.stopPropagation();
    const r = new CustomEvent("grid-dragend");
    r.originalEvent = t, this.dispatchEvent(r);
  }
  /** @private */
  _onDragLeave(t) {
    t.stopPropagation(), this._clearDragStyles();
  }
  /** @private */
  _onDragOver(t) {
    if (this.dropMode) {
      if (this._dropLocation = void 0, this._dragOverItem = void 0, this.__dndAutoScroll(t.clientY)) {
        this._clearDragStyles();
        return;
      }
      let r = t.composedPath().find((s) => s.localName === "tr");
      if (!this._effectiveSize || this.dropMode === Qr.ON_GRID)
        this._dropLocation = at.EMPTY;
      else if (!r || r.parentNode !== this.$.items) {
        if (r)
          return;
        if (this.dropMode === Qr.BETWEEN || this.dropMode === Qr.ON_TOP_OR_BETWEEN)
          r = Array.from(this.$.items.children).filter((s) => !s.hidden).pop(), this._dropLocation = at.BELOW;
        else
          return;
      } else {
        const s = r.getBoundingClientRect();
        if (this._dropLocation = at.ON_TOP, this.dropMode === Qr.BETWEEN) {
          const o = t.clientY - s.top < s.bottom - t.clientY;
          this._dropLocation = o ? at.ABOVE : at.BELOW;
        } else
          this.dropMode === Qr.ON_TOP_OR_BETWEEN && (t.clientY - s.top < s.height / 3 ? this._dropLocation = at.ABOVE : t.clientY - s.top > s.height / 3 * 2 && (this._dropLocation = at.BELOW));
      }
      if (r && r.hasAttribute("drop-disabled")) {
        this._dropLocation = void 0;
        return;
      }
      t.stopPropagation(), t.preventDefault(), this._dropLocation === at.EMPTY ? this.toggleAttribute("dragover", !0) : r ? (this._dragOverItem = r._item, r.getAttribute("dragover") !== this._dropLocation && Tc(r, { dragover: this._dropLocation })) : this._clearDragStyles();
    }
  }
  /** @private */
  __dndAutoScroll(t) {
    if (this.__dndAutoScrolling)
      return !0;
    const r = this.$.header.getBoundingClientRect().bottom, s = this.$.footer.getBoundingClientRect().top, o = r - t + this.__dndAutoScrollThreshold, n = t - s + this.__dndAutoScrollThreshold;
    let a = 0;
    if (n > 0 ? a = n * 2 : o > 0 && (a = -o * 2), a) {
      const l = this.$.table.scrollTop;
      if (this.$.table.scrollTop += a, l !== this.$.table.scrollTop)
        return this.__dndAutoScrolling = !0, setTimeout(() => {
          this.__dndAutoScrolling = !1;
        }, 20), !0;
    }
  }
  /** @private */
  __getViewportRows() {
    const t = this.$.header.getBoundingClientRect().bottom, r = this.$.footer.getBoundingClientRect().top;
    return Array.from(this.$.items.children).filter((s) => {
      const o = s.getBoundingClientRect();
      return o.bottom > t && o.top < r;
    });
  }
  /** @protected */
  _clearDragStyles() {
    this.removeAttribute("dragover"), le(this.$.items, (t) => {
      Tc(t, { dragover: null });
    });
  }
  /** @private */
  _onDrop(t) {
    if (this.dropMode) {
      t.stopPropagation(), t.preventDefault();
      const r = t.dataTransfer.types && Array.from(t.dataTransfer.types).map((o) => ({
        type: o,
        data: t.dataTransfer.getData(o)
      }));
      this._clearDragStyles();
      const s = new CustomEvent("grid-drop", {
        bubbles: t.bubbles,
        cancelable: t.cancelable,
        detail: {
          dropTargetItem: this._dragOverItem,
          dropLocation: this._dropLocation,
          dragData: r
        }
      });
      s.originalEvent = t, this.dispatchEvent(s);
    }
  }
  /** @private */
  __formatDefaultTransferData(t) {
    return t.map((r) => Array.from(r.children).filter((s) => !s.hidden && s.getAttribute("part").indexOf("details-cell") === -1).sort((s, o) => s._column._order > o._column._order ? 1 : -1).map((s) => s._content.textContent.trim()).filter((s) => s).join("	")).join(`
`);
  }
  /** @private */
  _dragDropAccessChanged() {
    this.filterDragAndDrop();
  }
  /**
   * Runs the `dragFilter` and `dropFilter` hooks for the visible cells.
   * If the filter depends on varying conditions, you may need to
   * call this function manually in order to update the draggability when
   * the conditions change.
   */
  filterDragAndDrop() {
    le(this.$.items, (t) => {
      t.hidden || this._filterDragAndDrop(t, this.__getRowModel(t));
    });
  }
  /**
   * @param {!HTMLElement} row
   * @param {!GridItemModel} model
   * @protected
   */
  _filterDragAndDrop(t, r) {
    const s = this.loading || t.hasAttribute("loading"), o = !this.rowsDraggable || s || this.dragFilter && !this.dragFilter(r), n = !this.dropMode || s || this.dropFilter && !this.dropFilter(r);
    Ir(t, (a) => {
      o ? a._content.removeAttribute("draggable") : a._content.setAttribute("draggable", !0);
    }), hi(t, {
      "drag-disabled": !!o,
      "drop-disabled": !!n
    });
  }
  /**
   * Fired when starting to drag grid rows.
   *
   * @event grid-dragstart
   * @param {Object} originalEvent The native dragstart event
   * @param {Object} detail
   * @param {Object} detail.draggedItems the items in the visible viewport that are dragged
   * @param {Function} detail.setDraggedItemsCount Overrides the default number shown in the drag image on multi row drag.
   * Parameter is of type number.
   * @param {Function} detail.setDragData Sets dataTransfer data for the drag operation.
   * Note that "text" is the only data type supported by all the browsers the grid currently supports (including IE11).
   * The function takes two parameters:
   * - type:string The type of the data
   * - data:string The data
   */
  /**
   * Fired when the dragging of the rows ends.
   *
   * @event grid-dragend
   * @param {Object} originalEvent The native dragend event
   */
  /**
   * Fired when a drop occurs on top of the grid.
   *
   * @event grid-drop
   * @param {Object} originalEvent The native drop event
   * @param {Object} detail
   * @param {Object} detail.dropTargetItem The item of the grid row on which the drop occurred.
   * @param {string} detail.dropLocation The position at which the drop event took place relative to a row.
   * Depending on the dropMode value, the drop location can be one of the following
   * - `on-top`: when the drop occurred on top of the row
   * - `above`: when the drop occurred above the row
   * - `below`: when the drop occurred below the row
   * - `empty`: when the drop occurred over the grid, not relative to any specific row
   * @param {string} detail.dragData An array of items with the payload as a string representation as the
   * `data` property and the type of the data as `type` property.
   */
};
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
function Jr(i, e, t) {
  return {
    index: i,
    removed: e,
    addedCount: t
  };
}
const Qh = 0, Jh = 1, Gn = 2, Yn = 3;
function Ev(i, e, t, r, s, o) {
  let n = o - s + 1, a = t - e + 1, l = new Array(n);
  for (let c = 0; c < n; c++)
    l[c] = new Array(a), l[c][0] = c;
  for (let c = 0; c < a; c++)
    l[0][c] = c;
  for (let c = 1; c < n; c++)
    for (let d = 1; d < a; d++)
      if (Ba(i[e + d - 1], r[s + c - 1]))
        l[c][d] = l[c - 1][d - 1];
      else {
        let u = l[c - 1][d] + 1, h = l[c][d - 1] + 1;
        l[c][d] = u < h ? u : h;
      }
  return l;
}
function Sv(i) {
  let e = i.length - 1, t = i[0].length - 1, r = i[e][t], s = [];
  for (; e > 0 || t > 0; ) {
    if (e == 0) {
      s.push(Gn), t--;
      continue;
    }
    if (t == 0) {
      s.push(Yn), e--;
      continue;
    }
    let o = i[e - 1][t - 1], n = i[e - 1][t], a = i[e][t - 1], l;
    n < a ? l = n < o ? n : o : l = a < o ? a : o, l == o ? (o == r ? s.push(Qh) : (s.push(Jh), r = o), e--, t--) : l == n ? (s.push(Yn), e--, r = n) : (s.push(Gn), t--, r = a);
  }
  return s.reverse(), s;
}
function Tv(i, e, t, r, s, o) {
  let n = 0, a = 0, l, c = Math.min(t - e, o - s);
  if (e == 0 && s == 0 && (n = Iv(i, r, c)), t == i.length && o == r.length && (a = Dv(i, r, c - n)), e += n, s += n, t -= a, o -= a, t - e == 0 && o - s == 0)
    return [];
  if (e == t) {
    for (l = Jr(e, [], 0); s < o; )
      l.removed.push(r[s++]);
    return [l];
  } else if (s == o)
    return [Jr(e, [], t - e)];
  let d = Sv(
    Ev(
      i,
      e,
      t,
      r,
      s,
      o
    )
  );
  l = void 0;
  let u = [], h = e, f = s;
  for (let m = 0; m < d.length; m++)
    switch (d[m]) {
      case Qh:
        l && (u.push(l), l = void 0), h++, f++;
        break;
      case Jh:
        l || (l = Jr(h, [], 0)), l.addedCount++, h++, l.removed.push(r[f]), f++;
        break;
      case Gn:
        l || (l = Jr(h, [], 0)), l.addedCount++, h++;
        break;
      case Yn:
        l || (l = Jr(h, [], 0)), l.removed.push(r[f]), f++;
        break;
    }
  return l && u.push(l), u;
}
function Iv(i, e, t) {
  for (let r = 0; r < t; r++)
    if (!Ba(i[r], e[r]))
      return r;
  return t;
}
function Dv(i, e, t) {
  let r = i.length, s = e.length, o = 0;
  for (; o < t && Ba(i[--r], e[--s]); )
    o++;
  return o;
}
function Ov(i, e) {
  return Tv(
    i,
    0,
    i.length,
    e,
    0,
    e.length
  );
}
function Ba(i, e) {
  return i === e;
}
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
function lr(i) {
  return i.localName === "slot";
}
let fi = class {
  /**
   * Returns the list of flattened nodes for the given `node`.
   * This list consists of a node's children and, for any children
   * that are `<slot>` elements, the expanded flattened list of `assignedNodes`.
   * For example, if the observed node has children `<a></a><slot></slot><b></b>`
   * and the `<slot>` has one `<div>` assigned to it, then the flattened
   * nodes list is `<a></a><div></div><b></b>`. If the `<slot>` has other
   * `<slot>` elements assigned to it, these are flattened as well.
   *
   * @param {!HTMLElement|!HTMLSlotElement} node The node for which to
   *      return the list of flattened nodes.
   * @return {!Array<!Node>} The list of flattened nodes for the given `node`.
   * @nocollapse See https://github.com/google/closure-compiler/issues/2763
   */
  // eslint-disable-next-line
  static getFlattenedNodes(i) {
    const e = B(i);
    return lr(i) ? (i = /** @type {!HTMLSlotElement} */
    i, e.assignedNodes({ flatten: !0 })) : Array.from(e.childNodes).map((t) => lr(t) ? (t = /** @type {!HTMLSlotElement} */
    t, B(t).assignedNodes({ flatten: !0 })) : [t]).reduce((t, r) => t.concat(r), []);
  }
  /**
   * @param {!HTMLElement} target Node on which to listen for changes.
   * @param {?function(this: Element, { target: !HTMLElement, addedNodes: !Array<!Element>, removedNodes: !Array<!Element> }):void} callback Function called when there are additions
   * or removals from the target's list of flattened nodes.
   */
  // eslint-disable-next-line
  constructor(i, e) {
    this._shadyChildrenObserver = null, this._nativeChildrenObserver = null, this._connected = !1, this._target = i, this.callback = e, this._effectiveNodes = [], this._observer = null, this._scheduled = !1, this._boundSchedule = () => {
      this._schedule();
    }, this.connect(), this._schedule();
  }
  /**
   * Activates an observer. This method is automatically called when
   * a `FlattenedNodesObserver` is created. It should only be called to
   * re-activate an observer that has been deactivated via the `disconnect` method.
   *
   * @return {void}
   */
  connect() {
    lr(this._target) ? this._listenSlots([this._target]) : B(this._target).children && (this._listenSlots(
      /** @type {!NodeList<!Node>} */
      B(this._target).children
    ), window.ShadyDOM ? this._shadyChildrenObserver = window.ShadyDOM.observeChildren(this._target, (i) => {
      this._processMutations(i);
    }) : (this._nativeChildrenObserver = new MutationObserver((i) => {
      this._processMutations(i);
    }), this._nativeChildrenObserver.observe(this._target, { childList: !0 }))), this._connected = !0;
  }
  /**
   * Deactivates the flattened nodes observer. After calling this method
   * the observer callback will not be called when changes to flattened nodes
   * occur. The `connect` method may be subsequently called to reactivate
   * the observer.
   *
   * @return {void}
   * @override
   */
  disconnect() {
    lr(this._target) ? this._unlistenSlots([this._target]) : B(this._target).children && (this._unlistenSlots(
      /** @type {!NodeList<!Node>} */
      B(this._target).children
    ), window.ShadyDOM && this._shadyChildrenObserver ? (window.ShadyDOM.unobserveChildren(this._shadyChildrenObserver), this._shadyChildrenObserver = null) : this._nativeChildrenObserver && (this._nativeChildrenObserver.disconnect(), this._nativeChildrenObserver = null)), this._connected = !1;
  }
  /**
   * @return {void}
   * @private
   */
  _schedule() {
    this._scheduled || (this._scheduled = !0, Aa.run(() => this.flush()));
  }
  /**
   * @param {Array<MutationRecord>} mutations Mutations signaled by the mutation observer
   * @return {void}
   * @private
   */
  _processMutations(i) {
    this._processSlotMutations(i), this.flush();
  }
  /**
   * @param {Array<MutationRecord>} mutations Mutations signaled by the mutation observer
   * @return {void}
   * @private
   */
  _processSlotMutations(i) {
    if (i)
      for (let e = 0; e < i.length; e++) {
        let t = i[e];
        t.addedNodes && this._listenSlots(t.addedNodes), t.removedNodes && this._unlistenSlots(t.removedNodes);
      }
  }
  /**
   * Flushes the observer causing any pending changes to be immediately
   * delivered the observer callback. By default these changes are delivered
   * asynchronously at the next microtask checkpoint.
   *
   * @return {boolean} Returns true if any pending changes caused the observer
   * callback to run.
   */
  flush() {
    if (!this._connected)
      return !1;
    window.ShadyDOM && ShadyDOM.flush(), this._nativeChildrenObserver ? this._processSlotMutations(this._nativeChildrenObserver.takeRecords()) : this._shadyChildrenObserver && this._processSlotMutations(this._shadyChildrenObserver.takeRecords()), this._scheduled = !1;
    let i = {
      target: this._target,
      addedNodes: [],
      removedNodes: []
    }, e = this.constructor.getFlattenedNodes(this._target), t = Ov(
      e,
      this._effectiveNodes
    );
    for (let s = 0, o; s < t.length && (o = t[s]); s++)
      for (let n = 0, a; n < o.removed.length && (a = o.removed[n]); n++)
        i.removedNodes.push(a);
    for (let s = 0, o; s < t.length && (o = t[s]); s++)
      for (let n = o.index; n < o.index + o.addedCount; n++)
        i.addedNodes.push(e[n]);
    this._effectiveNodes = e;
    let r = !1;
    return (i.addedNodes.length || i.removedNodes.length) && (r = !0, this.callback.call(this._target, i)), r;
  }
  /**
   * @param {!Array<!Node>|!NodeList<!Node>} nodeList Nodes that could change
   * @return {void}
   * @private
   */
  _listenSlots(i) {
    for (let e = 0; e < i.length; e++) {
      let t = i[e];
      lr(t) && t.addEventListener("slotchange", this._boundSchedule);
    }
  }
  /**
   * @param {!Array<!Node>|!NodeList<!Node>} nodeList Nodes that could change
   * @return {void}
   * @private
   */
  _unlistenSlots(i) {
    for (let e = 0; e < i.length; e++) {
      let t = i[e];
      lr(t) && t.removeEventListener("slotchange", this._boundSchedule);
    }
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function Xh(i, e) {
  if (!i || !e || i.length !== e.length)
    return !1;
  for (let t = 0, r = i.length; t < r; t++)
    if (i[t] instanceof Array && e[t] instanceof Array) {
      if (!Xh(i[t], e[t]))
        return !1;
    } else if (i[t] !== e[t])
      return !1;
  return !0;
}
const $v = (i) => class extends i {
  static get properties() {
    return {
      /**
       * @protected
       */
      _columnTree: Object
    };
  }
  /** @protected */
  ready() {
    super.ready(), this._addNodeObserver();
  }
  /** @private */
  _hasColumnGroups(t) {
    return t.some((r) => r.localName === "vaadin-grid-column-group");
  }
  /**
   * @param {!GridColumnGroup} el
   * @return {!Array<!GridColumn>}
   * @protected
   */
  _getChildColumns(t) {
    return fi.getFlattenedNodes(t).filter(this._isColumnElement);
  }
  /** @private */
  _flattenColumnGroups(t) {
    return t.map((r) => r.localName === "vaadin-grid-column-group" ? this._getChildColumns(r) : [r]).reduce((r, s) => r.concat(s), []);
  }
  /** @private */
  _getColumnTree() {
    const t = fi.getFlattenedNodes(this).filter(this._isColumnElement), r = [t];
    let s = t;
    for (; this._hasColumnGroups(s); )
      s = this._flattenColumnGroups(s), r.push(s);
    return r;
  }
  /** @protected */
  _debounceUpdateColumnTree() {
    this.__updateColumnTreeDebouncer = R.debounce(
      this.__updateColumnTreeDebouncer,
      xt,
      () => this._updateColumnTree()
    );
  }
  /** @protected */
  _updateColumnTree() {
    const t = this._getColumnTree();
    Xh(t, this._columnTree) || (this._columnTree = t);
  }
  /** @private */
  _addNodeObserver() {
    this._observer = new fi(this, (t) => {
      const r = (s) => s.filter(this._isColumnElement).length > 0;
      if (r(t.addedNodes) || r(t.removedNodes)) {
        const s = t.removedNodes.flatMap((n) => n._allCells), o = (n) => s.filter((a) => a && a._content.contains(n)).length;
        this.__removeSorters(this._sorters.filter(o)), this.__removeFilters(this._filters.filter(o)), this._debounceUpdateColumnTree();
      }
      this._debouncerCheckImports = R.debounce(
        this._debouncerCheckImports,
        _e.after(2e3),
        this._checkImports.bind(this)
      ), this._ensureFirstPageLoaded();
    });
  }
  /** @protected */
  _checkImports() {
    [
      "vaadin-grid-column-group",
      "vaadin-grid-filter",
      "vaadin-grid-filter-column",
      "vaadin-grid-tree-toggle",
      "vaadin-grid-selection-column",
      "vaadin-grid-sort-column",
      "vaadin-grid-sorter"
    ].forEach((t) => {
      const r = this.querySelector(t);
      r && r instanceof N;
    });
  }
  /** @protected */
  _updateFirstAndLastColumn() {
    Array.from(this.shadowRoot.querySelectorAll("tr")).forEach((t) => this._updateFirstAndLastColumnForRow(t));
  }
  /**
   * @param {!HTMLElement} row
   * @protected
   */
  _updateFirstAndLastColumnForRow(t) {
    Array.from(t.querySelectorAll('[part~="cell"]:not([part~="details-cell"])')).sort((r, s) => r._column._order - s._column._order).forEach((r, s, o) => {
      Ft(r, "first-column", s === 0), Ft(r, "last-column", s === o.length - 1);
    });
  }
  /**
   * @param {!Node} node
   * @return {boolean}
   * @protected
   */
  _isColumnElement(t) {
    return t.nodeType === Node.ELEMENT_NODE && /\bcolumn\b/u.test(t.localName);
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Pv = (i) => class extends i {
  /**
   * Returns an object with context information about the event target:
   * - `item`: the data object corresponding to the targeted row (not specified when targeting header or footer)
   * - `column`: the column element corresponding to the targeted cell (not specified when targeting row details)
   * - `section`: whether the event targeted the body, header, footer or details of the grid
   *
   * These additional properties are included when `item` is specified:
   * - `index`: the index of the item
   * - `selected`: the selected state of the item
   * - `detailsOpened`: whether the row details are open for the item
   * - `expanded`: the expanded state of the tree toggle
   * - `level`: the tree hierarchy level
   *
   * The returned object is populated only when a grid cell, header, footer or row details is found in `event.composedPath()`.
   * This means mostly mouse and keyboard events. If such a grid part is not found in the path, an empty object is returned.
   * This may be the case eg. if the event is fired on the `<vaadin-grid>` element and not any deeper in the DOM, or if
   * the event targets the empty part of the grid body.
   *
   * @param {!Event} event
   * @return {GridEventContext}
   */
  getEventContext(t) {
    const r = {}, s = t.__composedPath || t.composedPath(), o = s[s.indexOf(this.$.table) - 3];
    return o && (r.section = ["body", "header", "footer", "details"].find(
      (n) => o.getAttribute("part").indexOf(n) > -1
    ), o._column && (r.column = o._column), (r.section === "body" || r.section === "details") && Object.assign(r, this.__getRowModel(o.parentElement))), r;
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Mv = (i) => class extends i {
  static get properties() {
    return {
      /** @private */
      _filters: {
        type: Array,
        value: () => []
      }
    };
  }
  /** @protected */
  ready() {
    super.ready(), this.addEventListener("filter-changed", this._filterChanged.bind(this));
  }
  /** @private */
  _filterChanged(t) {
    t.stopPropagation(), this.__addFilter(t.target), this.__applyFilters();
  }
  /** @private */
  __removeFilters(t) {
    t.length !== 0 && (this._filters = this._filters.filter((r) => t.indexOf(r) < 0), this.__applyFilters());
  }
  /** @private */
  __addFilter(t) {
    this._filters.indexOf(t) === -1 && this._filters.push(t);
  }
  /** @private */
  __applyFilters() {
    this.dataProvider && this.isAttached && this.clearCache();
  }
  /**
   * @return {!Array<!GridFilterDefinition>}
   * @protected
   */
  _mapFilters() {
    return this._filters.map((t) => ({
      path: t.path,
      value: t.value
    }));
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const zv = (i) => class extends i {
  static get properties() {
    return {
      /** @private */
      _headerFocusable: {
        type: Object,
        observer: "_focusableChanged"
      },
      /**
       * @type {!HTMLElement | undefined}
       * @protected
       */
      _itemsFocusable: {
        type: Object,
        observer: "_focusableChanged"
      },
      /** @private */
      _footerFocusable: {
        type: Object,
        observer: "_focusableChanged"
      },
      /** @private */
      _navigatingIsHidden: Boolean,
      /**
       * @type {number}
       * @protected
       */
      _focusedItemIndex: {
        type: Number,
        value: 0
      },
      /** @private */
      _focusedColumnOrder: Number,
      /** @private */
      _focusedCell: {
        type: Object,
        observer: "_focusedCellChanged"
      },
      /**
       * Indicates whether the grid is currently in interaction mode.
       * In interaction mode the user is currently interacting with a control,
       * such as an input or a select, within a cell.
       * In interaction mode keyboard navigation between cells is disabled.
       * Interaction mode also prevents the focus target cell of that section of
       * the grid from receiving focus, allowing the user to switch focus to
       * controls in adjacent cells, rather than focussing the outer cell
       * itself.
       * @type {boolean}
       * @private
       */
      interacting: {
        type: Boolean,
        value: !1,
        reflectToAttribute: !0,
        readOnly: !0,
        observer: "_interactingChanged"
      }
    };
  }
  /** @private */
  get __rowFocusMode() {
    return this.__isRow(this._itemsFocusable) || this.__isRow(this._headerFocusable) || this.__isRow(this._footerFocusable);
  }
  set __rowFocusMode(t) {
    ["_itemsFocusable", "_footerFocusable", "_headerFocusable"].forEach((r) => {
      const s = this[r];
      if (t) {
        const o = s && s.parentElement;
        this.__isCell(s) ? this[r] = o : this.__isCell(o) && (this[r] = o.parentElement);
      } else if (!t && this.__isRow(s)) {
        const o = s.firstElementChild;
        this[r] = o._focusButton || o;
      }
    });
  }
  /** @protected */
  ready() {
    super.ready(), !(this._ios || this._android) && (this.addEventListener("keydown", this._onKeyDown), this.addEventListener("keyup", this._onKeyUp), this.addEventListener("focusin", this._onFocusIn), this.addEventListener("focusout", this._onFocusOut), this.$.table.addEventListener("focusin", this._onContentFocusIn.bind(this)), this.addEventListener("mousedown", () => {
      this.toggleAttribute("navigating", !1), this._isMousedown = !0, this._focusedColumnOrder = void 0;
    }), this.addEventListener("mouseup", () => {
      this._isMousedown = !1;
    }));
  }
  /** @private */
  _focusableChanged(t, r) {
    r && r.setAttribute("tabindex", "-1"), t && this._updateGridSectionFocusTarget(t);
  }
  /** @private */
  _focusedCellChanged(t, r) {
    r && Ia(r, "part", "focused-cell"), t && uo(t, "part", "focused-cell");
  }
  /** @private */
  _interactingChanged() {
    this._updateGridSectionFocusTarget(this._headerFocusable), this._updateGridSectionFocusTarget(this._itemsFocusable), this._updateGridSectionFocusTarget(this._footerFocusable);
  }
  /**
   * Since the focused cell/row state is stored as an element reference, the reference may get
   * out of sync when the virtual indexes for elements update due to effective size change.
   * This function updates the reference to the correct element after a possible index change.
   * @private
   */
  __updateItemsFocusable() {
    if (!this._itemsFocusable)
      return;
    const t = this.shadowRoot.activeElement === this._itemsFocusable;
    this._getRenderedRows().forEach((r) => {
      if (r.index === this._focusedItemIndex)
        if (this.__rowFocusMode)
          this._itemsFocusable = r;
        else {
          let s = this._itemsFocusable.parentElement, o = this._itemsFocusable;
          if (s) {
            this.__isCell(s) && (o = s, s = s.parentElement);
            const n = [...s.children].indexOf(o);
            this._itemsFocusable = this.__getFocusable(r, r.children[n]);
          }
        }
    }), t && this._itemsFocusable.focus();
  }
  /**
   * @param {!KeyboardEvent} e
   * @protected
   */
  _onKeyDown(t) {
    const r = t.key;
    let s;
    switch (r) {
      case "ArrowUp":
      case "ArrowDown":
      case "ArrowLeft":
      case "ArrowRight":
      case "PageUp":
      case "PageDown":
      case "Home":
      case "End":
        s = "Navigation";
        break;
      case "Enter":
      case "Escape":
      case "F2":
        s = "Interaction";
        break;
      case "Tab":
        s = "Tab";
        break;
      case " ":
        s = "Space";
        break;
    }
    this._detectInteracting(t), this.interacting && s !== "Interaction" && (s = void 0), s && this[`_on${s}KeyDown`](t, r);
  }
  /** @private */
  _ensureScrolledToIndex(t) {
    [...this.$.items.children].find((s) => s.index === t) ? this.__scrollIntoViewport(t) : this.scrollToIndex(t);
  }
  /** @private */
  __isRowExpandable(t) {
    if (this.itemHasChildrenPath) {
      const r = t._item;
      return r && Ct(this.itemHasChildrenPath, r) && !this._isExpanded(r);
    }
  }
  /** @private */
  __isRowCollapsible(t) {
    return this._isExpanded(t._item);
  }
  /** @private */
  __isDetailsCell(t) {
    return t.matches('[part~="details-cell"]');
  }
  /** @private */
  __isCell(t) {
    return t instanceof HTMLTableCellElement;
  }
  /** @private */
  __isRow(t) {
    return t instanceof HTMLTableRowElement;
  }
  /** @private */
  __getIndexOfChildElement(t) {
    return Array.prototype.indexOf.call(t.parentNode.children, t);
  }
  /** @private */
  _onNavigationKeyDown(t, r) {
    t.preventDefault();
    const s = this._lastVisibleIndex - this._firstVisibleIndex - 1, o = this.__isRTL;
    let n = 0, a = 0;
    switch (r) {
      case "ArrowRight":
        n = o ? -1 : 1;
        break;
      case "ArrowLeft":
        n = o ? 1 : -1;
        break;
      case "Home":
        this.__rowFocusMode || t.ctrlKey ? a = -1 / 0 : n = -1 / 0;
        break;
      case "End":
        this.__rowFocusMode || t.ctrlKey ? a = 1 / 0 : n = 1 / 0;
        break;
      case "ArrowDown":
        a = 1;
        break;
      case "ArrowUp":
        a = -1;
        break;
      case "PageDown":
        a = s;
        break;
      case "PageUp":
        a = -s;
        break;
    }
    const l = t.composedPath().find((h) => this.__isRow(h)), c = t.composedPath().find((h) => this.__isCell(h));
    if (this.__rowFocusMode && !l || !this.__rowFocusMode && !c)
      return;
    const d = o ? "ArrowLeft" : "ArrowRight", u = o ? "ArrowRight" : "ArrowLeft";
    if (r === d) {
      if (this.__rowFocusMode) {
        if (this.__isRowExpandable(l)) {
          this.expandItem(l._item);
          return;
        }
        this.__rowFocusMode = !1, this._onCellNavigation(l.firstElementChild, 0, 0);
        return;
      }
    } else if (r === u)
      if (this.__rowFocusMode) {
        if (this.__isRowCollapsible(l)) {
          this.collapseItem(l._item);
          return;
        }
      } else {
        const h = [...l.children].sort((f, m) => f._order - m._order);
        if (c === h[0] || this.__isDetailsCell(c)) {
          this.__rowFocusMode = !0, this._onRowNavigation(l, 0);
          return;
        }
      }
    this.__rowFocusMode ? this._onRowNavigation(l, a) : this._onCellNavigation(c, n, a);
  }
  /**
   * Focuses the target row after navigating by the given dy offset.
   * If the row is not in the viewport, it is first scrolled to.
   * @private
   */
  _onRowNavigation(t, r) {
    const { dstRow: s } = this.__navigateRows(r, t);
    s && s.focus();
  }
  /** @private */
  __getIndexInGroup(t, r) {
    return t.parentNode === this.$.items ? r !== void 0 ? r : t.index : this.__getIndexOfChildElement(t);
  }
  /**
   * Returns the target row after navigating by the given dy offset.
   * Also returns information whether the details cell should be the target on the target row.
   * If the row is not in the viewport, it is first scrolled to.
   * @private
   */
  __navigateRows(t, r, s) {
    const o = this.__getIndexInGroup(r, this._focusedItemIndex), n = r.parentNode, a = (n === this.$.items ? this._effectiveSize : n.children.length) - 1;
    let l = Math.max(0, Math.min(o + t, a));
    if (n !== this.$.items) {
      if (l > o)
        for (; l < a && n.children[l].hidden; )
          l += 1;
      else if (l < o)
        for (; l > 0 && n.children[l].hidden; )
          l -= 1;
      return this.toggleAttribute("navigating", !0), { dstRow: n.children[l] };
    }
    let c = !1;
    if (s) {
      const d = this.__isDetailsCell(s);
      if (n === this.$.items) {
        const u = r._item, h = this._cache.getItemForIndex(l);
        d ? c = t === 0 : c = t === 1 && this._isDetailsOpened(u) || t === -1 && l !== o && this._isDetailsOpened(h), c !== d && (t === 1 && c || t === -1 && !c) && (l = o);
      }
    }
    return this._ensureScrolledToIndex(l), this._focusedItemIndex = l, this.toggleAttribute("navigating", !0), {
      dstRow: [...n.children].find((d) => !d.hidden && d.index === l),
      dstIsRowDetails: c
    };
  }
  /**
   * Focuses the target cell after navigating by the given dx and dy offset.
   * If the cell is not in the viewport, it is first scrolled to.
   * @private
   */
  _onCellNavigation(t, r, s) {
    const o = t.parentNode, { dstRow: n, dstIsRowDetails: a } = this.__navigateRows(s, o, t);
    if (!n)
      return;
    let l = this.__getIndexOfChildElement(t);
    this.$.items.contains(t) && (l = [...this.$.sizer.children].findIndex((h) => h._column === t._column));
    const c = this.__isDetailsCell(t), d = o.parentNode, u = this.__getIndexInGroup(o, this._focusedItemIndex);
    if (this._focusedColumnOrder === void 0 && (c ? this._focusedColumnOrder = 0 : this._focusedColumnOrder = this._getColumns(d, u).filter((h) => !h.hidden)[l]._order), a)
      [...n.children].find((f) => this.__isDetailsCell(f)).focus();
    else {
      const h = this.__getIndexInGroup(n, this._focusedItemIndex), f = this._getColumns(d, h).filter((j) => !j.hidden), m = f.map((j) => j._order).sort((j, Ie) => j - Ie), v = m.length - 1, k = m.indexOf(
        m.slice(0).sort((j, Ie) => Math.abs(j - this._focusedColumnOrder) - Math.abs(Ie - this._focusedColumnOrder))[0]
      ), M = s === 0 && c ? k : Math.max(0, Math.min(k + r, v));
      M !== k && (this._focusedColumnOrder = void 0);
      const se = f.reduce((j, Ie, je) => (j[Ie._order] = je, j), {})[m[M]];
      let he;
      if (this.$.items.contains(t)) {
        const j = this.$.sizer.children[se];
        this._lazyColumns && (this.__isColumnInViewport(j._column) || j.scrollIntoView(), this.__updateColumnsBodyContentHidden(), this.__updateHorizontalScrollPosition()), he = [...n.children].find((Ie) => Ie._column === j._column), this._scrollHorizontallyToCell(he);
      } else
        he = n.children[se], this._scrollHorizontallyToCell(he);
      he.focus();
    }
  }
  /** @private */
  _onInteractionKeyDown(t, r) {
    const s = t.composedPath()[0], o = s.localName === "input" && !/^(button|checkbox|color|file|image|radio|range|reset|submit)$/iu.test(s.type);
    let n;
    switch (r) {
      case "Enter":
        n = this.interacting ? !o : !0;
        break;
      case "Escape":
        n = !1;
        break;
      case "F2":
        n = !this.interacting;
        break;
    }
    const { cell: a } = this._getGridEventLocation(t);
    if (this.interacting !== n && a !== null)
      if (n) {
        const l = a._content.querySelector("[focus-target]") || // If a child element hasn't been explicitly marked as a focus target,
        // fall back to any focusable element inside the cell.
        [...a._content.querySelectorAll("*")].find((c) => this._isFocusable(c));
        l && (t.preventDefault(), l.focus(), this._setInteracting(!0), this.toggleAttribute("navigating", !1));
      } else
        t.preventDefault(), this._focusedColumnOrder = void 0, a.focus(), this._setInteracting(!1), this.toggleAttribute("navigating", !0);
    r === "Escape" && this._hideTooltip(!0);
  }
  /** @private */
  _predictFocusStepTarget(t, r) {
    const s = [
      this.$.table,
      this._headerFocusable,
      this._itemsFocusable,
      this._footerFocusable,
      this.$.focusexit
    ];
    let o = s.indexOf(t);
    for (o += r; o >= 0 && o <= s.length - 1; ) {
      let a = s[o];
      if (a && !this.__rowFocusMode && (a = s[o].parentNode), !a || a.hidden)
        o += r;
      else
        break;
    }
    let n = s[o];
    if (n && n._column && !this.__isColumnInViewport(n._column)) {
      const a = this._getColumnsInOrder().find((l) => this.__isColumnInViewport(l));
      if (a)
        if (n === this._headerFocusable)
          n = a._headerCell;
        else if (n === this._itemsFocusable) {
          const l = n._column._cells.indexOf(n);
          n = a._cells[l];
        } else
          n === this._footerFocusable && (n = a._footerCell);
    }
    return n;
  }
  /** @private */
  _onTabKeyDown(t) {
    const r = this._predictFocusStepTarget(t.composedPath()[0], t.shiftKey ? -1 : 1);
    if (r) {
      if (t.stopPropagation(), r === this.$.table)
        this.$.table.focus();
      else if (r === this.$.focusexit)
        this.$.focusexit.focus();
      else if (r === this._itemsFocusable) {
        let s = r;
        const o = this.__isRow(r) ? r : r.parentNode;
        if (this._ensureScrolledToIndex(this._focusedItemIndex), o.index !== this._focusedItemIndex && this.__isCell(r)) {
          const n = Array.from(o.children).indexOf(this._itemsFocusable), a = Array.from(this.$.items.children).find(
            (l) => !l.hidden && l.index === this._focusedItemIndex
          );
          a && (s = a.children[n]);
        }
        t.preventDefault(), s.focus();
      } else
        t.preventDefault(), r.focus();
      this.toggleAttribute("navigating", !0);
    }
  }
  /** @private */
  _onSpaceKeyDown(t) {
    t.preventDefault();
    const r = t.composedPath()[0], s = this.__isRow(r);
    (s || !r._content || !r._content.firstElementChild) && this.dispatchEvent(
      new CustomEvent(s ? "row-activate" : "cell-activate", {
        detail: {
          model: this.__getRowModel(s ? r : r.parentElement)
        }
      })
    );
  }
  /** @private */
  _onKeyUp(t) {
    if (!/^( |SpaceBar)$/u.test(t.key) || this.interacting)
      return;
    t.preventDefault();
    const r = t.composedPath()[0];
    if (r._content && r._content.firstElementChild) {
      const s = this.hasAttribute("navigating");
      r._content.firstElementChild.dispatchEvent(
        new MouseEvent("click", {
          shiftKey: t.shiftKey,
          bubbles: !0,
          composed: !0,
          cancelable: !0
        })
      ), this.toggleAttribute("navigating", s);
    }
  }
  /**
   * @param {!FocusEvent} e
   * @protected
   */
  _onFocusIn(t) {
    this._isMousedown || this.toggleAttribute("navigating", !0);
    const r = t.composedPath()[0];
    r === this.$.table || r === this.$.focusexit ? (this._predictFocusStepTarget(r, r === this.$.table ? 1 : -1).focus(), this._setInteracting(!1)) : this._detectInteracting(t);
  }
  /**
   * @param {!FocusEvent} e
   * @protected
   */
  _onFocusOut(t) {
    this.toggleAttribute("navigating", !1), this._detectInteracting(t), this._hideTooltip(), this._focusedCell = null;
  }
  /** @private */
  _onContentFocusIn(t) {
    const { section: r, cell: s, row: o } = this._getGridEventLocation(t);
    if (!(!s && !this.__rowFocusMode)) {
      if (this._detectInteracting(t), r && (s || o))
        if (this._activeRowGroup = r, this.$.header === r ? this._headerFocusable = this.__getFocusable(o, s) : this.$.items === r ? this._itemsFocusable = this.__getFocusable(o, s) : this.$.footer === r && (this._footerFocusable = this.__getFocusable(o, s)), s) {
          const n = this.getEventContext(t);
          this.__pendingBodyCellFocus = this.loading && n.section === "body", this.__pendingBodyCellFocus || s.dispatchEvent(new CustomEvent("cell-focus", { bubbles: !0, composed: !0, detail: { context: n } })), this._focusedCell = s._focusButton || s, Rh() && t.target === s && this._showTooltip(t);
        } else
          this._focusedCell = null;
      this._detectFocusedItemIndex(t);
    }
  }
  /**
   * @private
   */
  __dispatchPendingBodyCellFocus() {
    this.__pendingBodyCellFocus && this.shadowRoot.activeElement === this._itemsFocusable && this._itemsFocusable.dispatchEvent(new Event("focusin", { bubbles: !0, composed: !0 }));
  }
  /**
   * Get the focusable element depending on the current focus mode.
   * It can be a row, a cell, or a focusable div inside a cell.
   *
   * @param {HTMLElement} row
   * @param {HTMLElement} cell
   * @return {HTMLElement}
   * @private
   */
  __getFocusable(t, r) {
    return this.__rowFocusMode ? t : r._focusButton || r;
  }
  /**
   * Enables interaction mode if a cells descendant receives focus or keyboard
   * input. Disables it if the event is not related to cell content.
   * @param {!KeyboardEvent|!FocusEvent} e
   * @private
   */
  _detectInteracting(t) {
    const r = t.composedPath().some((s) => s.localName === "vaadin-grid-cell-content");
    this._setInteracting(r), this.__updateHorizontalScrollPosition();
  }
  /** @private */
  _detectFocusedItemIndex(t) {
    const { section: r, row: s } = this._getGridEventLocation(t);
    r === this.$.items && (this._focusedItemIndex = s.index);
  }
  /**
   * Enables or disables the focus target of the containing section of the
   * grid from receiving focus, based on whether the user is interacting with
   * that section of the grid.
   * @param {HTMLElement} focusTarget
   * @private
   */
  _updateGridSectionFocusTarget(t) {
    if (!t)
      return;
    const r = this._getGridSectionFromFocusTarget(t), s = this.interacting && r === this._activeRowGroup;
    t.tabIndex = s ? -1 : 0;
  }
  /**
   * @param {!HTMLTableRowElement} row
   * @param {number} index
   * @protected
   */
  _preventScrollerRotatingCellFocus(t, r) {
    t.index === this._focusedItemIndex && this.hasAttribute("navigating") && this._activeRowGroup === this.$.items && (this._navigatingIsHidden = !0, this.toggleAttribute("navigating", !1)), r === this._focusedItemIndex && this._navigatingIsHidden && (this._navigatingIsHidden = !1, this.toggleAttribute("navigating", !0));
  }
  /**
   * @param {HTMLTableSectionElement=} rowGroup
   * @param {number=} rowIndex
   * @return {!Array<!GridColumn>}
   * @protected
   */
  _getColumns(t, r) {
    let s = this._columnTree.length - 1;
    return t === this.$.header ? s = r : t === this.$.footer && (s = this._columnTree.length - 1 - r), this._columnTree[s];
  }
  /** @private */
  __isValidFocusable(t) {
    return this.$.table.contains(t) && t.offsetHeight;
  }
  /** @protected */
  _resetKeyboardNavigation() {
    if (["header", "footer"].forEach((t) => {
      if (!this.__isValidFocusable(this[`_${t}Focusable`])) {
        const r = [...this.$[t].children].find((o) => o.offsetHeight), s = r ? [...r.children].find((o) => !o.hidden) : null;
        r && s && (this[`_${t}Focusable`] = this.__getFocusable(r, s));
      }
    }), !this.__isValidFocusable(this._itemsFocusable) && this.$.items.firstElementChild) {
      const t = this.__getFirstVisibleItem(), r = t ? [...t.children].find((s) => !s.hidden) : null;
      r && t && (delete this._focusedColumnOrder, this._itemsFocusable = this.__getFocusable(t, r));
    } else
      this.__updateItemsFocusable();
  }
  /**
   * @param {!HTMLElement} dstCell
   * @protected
   */
  _scrollHorizontallyToCell(t) {
    if (t.hasAttribute("frozen") || t.hasAttribute("frozen-to-end") || this.__isDetailsCell(t))
      return;
    const r = t.getBoundingClientRect(), s = t.parentNode, o = Array.from(s.children).indexOf(t), n = this.$.table.getBoundingClientRect();
    let a = n.left, l = n.right;
    for (let c = o - 1; c >= 0; c--) {
      const d = s.children[c];
      if (!(d.hasAttribute("hidden") || this.__isDetailsCell(d)) && (d.hasAttribute("frozen") || d.hasAttribute("frozen-to-end"))) {
        a = d.getBoundingClientRect().right;
        break;
      }
    }
    for (let c = o + 1; c < s.children.length; c++) {
      const d = s.children[c];
      if (!(d.hasAttribute("hidden") || this.__isDetailsCell(d)) && (d.hasAttribute("frozen") || d.hasAttribute("frozen-to-end"))) {
        l = d.getBoundingClientRect().left;
        break;
      }
    }
    r.left < a && (this.$.table.scrollLeft += Math.round(r.left - a)), r.right > l && (this.$.table.scrollLeft += Math.round(r.right - l));
  }
  /**
   * @typedef {Object} GridEventLocation
   * @property {HTMLTableSectionElement | null} section - The table section element that the event occurred in (header, body, or footer), or null if the event did not occur in a section
   * @property {HTMLTableRowElement | null} row - The row element that the event occurred in, or null if the event did not occur in a row
   * @property {HTMLTableCellElement | null} cell - The cell element that the event occurred in, or null if the event did not occur in a cell
   * @private
   */
  /**
   * Takes an event and returns a location object describing in which part of the grid the event occurred.
   * The event may either target table section, a row, a cell or contents of a cell.
   * @param {Event} e
   * @returns {GridEventLocation}
   * @private
   */
  _getGridEventLocation(t) {
    const r = t.composedPath(), s = r.indexOf(this.$.table), o = s >= 1 ? r[s - 1] : null, n = s >= 2 ? r[s - 2] : null, a = s >= 3 ? r[s - 3] : null;
    return {
      section: o,
      row: n,
      cell: a
    };
  }
  /**
   * Helper method that maps a focus target cell to the containing grid section
   * @param {HTMLElement} focusTarget
   * @returns {HTMLTableSectionElement | null}
   * @private
   */
  _getGridSectionFromFocusTarget(t) {
    return t === this._headerFocusable ? this.$.header : t === this._itemsFocusable ? this.$.items : t === this._footerFocusable ? this.$.footer : null;
  }
  /**
   * Fired when a cell is focused with click or keyboard navigation.
   *
   * Use context property of @see {@link GridCellFocusEvent} to get detail information about the event.
   *
   * @event cell-focus
   */
};
/**
 * @license
 * Copyright (c) 2016 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Nv = (i) => class extends i {
  static get properties() {
    return {
      /**
       * An array containing references to items with open row details.
       * @type {!Array<!GridItem>}
       */
      detailsOpenedItems: {
        type: Array,
        value: () => []
      },
      /**
       * Custom function for rendering the content of the row details.
       * Receives three arguments:
       *
       * - `root` The row details content DOM element. Append your content to it.
       * - `grid` The `<vaadin-grid>` element.
       * - `model` The object with the properties related with
       *   the rendered item, contains:
       *   - `model.index` The index of the item.
       *   - `model.item` The item.
       *   - `model.level` The number of the item's tree sublevel, starts from 0.
       *   - `model.expanded` True if the item's tree sublevel is expanded.
       *   - `model.selected` True if the item is selected.
       *
       * @type {GridRowDetailsRenderer | null | undefined}
       */
      rowDetailsRenderer: Function,
      /**
       * @type {!Array<!HTMLElement> | undefined}
       * @protected
       */
      _detailsCells: {
        type: Array
      }
    };
  }
  static get observers() {
    return [
      "_detailsOpenedItemsChanged(detailsOpenedItems.*, rowDetailsRenderer)",
      "_rowDetailsRendererChanged(rowDetailsRenderer)"
    ];
  }
  /** @protected */
  ready() {
    super.ready(), this._detailsCellResizeObserver = new ResizeObserver((t) => {
      t.forEach(({ target: r }) => {
        this._updateDetailsCellHeight(r.parentElement);
      }), this.__virtualizer.__adapter._resizeHandler();
    });
  }
  /** @private */
  _rowDetailsRendererChanged(t) {
    t && this._columnTree && le(this.$.items, (r) => {
      if (!r.querySelector("[part~=details-cell]")) {
        this._updateRow(r, this._columnTree[this._columnTree.length - 1]);
        const s = this._isDetailsOpened(r._item);
        this._toggleDetailsCell(r, s);
      }
    });
  }
  /** @private */
  _detailsOpenedItemsChanged(t, r) {
    t.path === "detailsOpenedItems.length" || !t.value || le(this.$.items, (s) => {
      if (s.hasAttribute("details-opened")) {
        this._updateItem(s, s._item);
        return;
      }
      r && this._isDetailsOpened(s._item) && this._updateItem(s, s._item);
    });
  }
  /**
   * @param {!HTMLElement} cell
   * @protected
   */
  _configureDetailsCell(t) {
    t.setAttribute("part", "cell details-cell"), t.toggleAttribute("frozen", !0), this._detailsCellResizeObserver.observe(t);
  }
  /**
   * @param {!HTMLElement} row
   * @param {!GridItem} item
   * @protected
   */
  _toggleDetailsCell(t, r) {
    const s = t.querySelector('[part~="details-cell"]');
    s && (s.hidden = !r, !s.hidden && this.rowDetailsRenderer && (s._renderer = this.rowDetailsRenderer));
  }
  /** @protected */
  _updateDetailsCellHeight(t) {
    const r = t.querySelector('[part~="details-cell"]');
    r && (r.hidden ? t.style.removeProperty("padding-bottom") : t.style.setProperty("padding-bottom", `${r.offsetHeight}px`));
  }
  /** @protected */
  _updateDetailsCellHeights() {
    le(this.$.items, (t) => {
      this._updateDetailsCellHeight(t);
    });
  }
  /**
   * @param {!GridItem} item
   * @return {boolean}
   * @protected
   */
  _isDetailsOpened(t) {
    return this.detailsOpenedItems && this._getItemIndexInArray(t, this.detailsOpenedItems) !== -1;
  }
  /**
   * Open the details row of a given item.
   * @param {!GridItem} item
   */
  openItemDetails(t) {
    this._isDetailsOpened(t) || (this.detailsOpenedItems = [...this.detailsOpenedItems, t]);
  }
  /**
   * Close the details row of a given item.
   * @param {!GridItem} item
   */
  closeItemDetails(t) {
    this._isDetailsOpened(t) && (this.detailsOpenedItems = this.detailsOpenedItems.filter((r) => !this._itemsEqual(r, t)));
  }
};
/**
 * @license
 * Copyright (c) 2022 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const mo = document.createElement("div");
mo.style.position = "fixed";
mo.style.clip = "rect(0px, 0px, 0px, 0px)";
mo.setAttribute("aria-live", "polite");
document.body.appendChild(mo);
/**
 * @license
 * Copyright (c) 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Xo = /* @__PURE__ */ new Map();
function Ua(i) {
  return Xo.has(i) || Xo.set(i, /* @__PURE__ */ new WeakMap()), Xo.get(i);
}
function ef(i, e) {
  i && i.removeAttribute(e);
}
function tf(i, e) {
  if (!i || !e)
    return;
  const t = Ua(e);
  if (t.has(i))
    return;
  const r = Ta(i.getAttribute(e));
  t.set(i, new Set(r));
}
function Fv(i, e) {
  if (!i || !e)
    return;
  const t = Ua(e), r = t.get(i);
  !r || r.size === 0 ? i.removeAttribute(e) : uo(i, e, co(r)), t.delete(i);
}
function en(i, e, t = { newId: null, oldId: null, fromUser: !1 }) {
  if (!i || !e)
    return;
  const { newId: r, oldId: s, fromUser: o } = t, n = Ua(e), a = n.get(i);
  if (!o && a) {
    s && a.delete(s), r && a.add(r);
    return;
  }
  o && (a ? r || n.delete(i) : tf(i, e), ef(i, e)), Ia(i, e, s);
  const l = r || co(a);
  l && uo(i, e, l);
}
function Rv(i, e) {
  tf(i, e), ef(i, e);
}
/**
 * @license
 * Copyright (c) 2021 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class Lv {
  constructor(e) {
    this.host = e, this.__required = !1;
  }
  /**
   * Sets a target element to which ARIA attributes are added.
   *
   * @param {HTMLElement} target
   */
  setTarget(e) {
    this.__target = e, this.__setAriaRequiredAttribute(this.__required), this.__setLabelIdToAriaAttribute(this.__labelId, this.__labelId), this.__labelIdFromUser != null && this.__setLabelIdToAriaAttribute(this.__labelIdFromUser, this.__labelIdFromUser, !0), this.__setErrorIdToAriaAttribute(this.__errorId), this.__setHelperIdToAriaAttribute(this.__helperId), this.setAriaLabel(this.__label);
  }
  /**
   * Toggles the `aria-required` attribute on the target element
   * if the target is the host component (e.g. a field group).
   * Otherwise, it does nothing.
   *
   * @param {boolean} required
   */
  setRequired(e) {
    this.__setAriaRequiredAttribute(e), this.__required = e;
  }
  /**
   * Defines the `aria-label` attribute of the target element.
   *
   * To remove the attribute, pass `null` as `label`.
   *
   * @param {string | null | undefined} label
   */
  setAriaLabel(e) {
    this.__setAriaLabelToAttribute(e), this.__label = e;
  }
  /**
   * Links the target element with a slotted label element
   * via the target's attribute `aria-labelledby`.
   *
   * To unlink the previous slotted label element, pass `null` as `labelId`.
   *
   * @param {string | null} labelId
   */
  setLabelId(e, t = !1) {
    const r = t ? this.__labelIdFromUser : this.__labelId;
    this.__setLabelIdToAriaAttribute(e, r, t), t ? this.__labelIdFromUser = e : this.__labelId = e;
  }
  /**
   * Links the target element with a slotted error element via the target's attribute:
   * - `aria-labelledby` if the target is the host component (e.g a field group).
   * - `aria-describedby` otherwise.
   *
   * To unlink the previous slotted error element, pass `null` as `errorId`.
   *
   * @param {string | null} errorId
   */
  setErrorId(e) {
    this.__setErrorIdToAriaAttribute(e, this.__errorId), this.__errorId = e;
  }
  /**
   * Links the target element with a slotted helper element via the target's attribute:
   * - `aria-labelledby` if the target is the host component (e.g a field group).
   * - `aria-describedby` otherwise.
   *
   * To unlink the previous slotted helper element, pass `null` as `helperId`.
   *
   * @param {string | null} helperId
   */
  setHelperId(e) {
    this.__setHelperIdToAriaAttribute(e, this.__helperId), this.__helperId = e;
  }
  /**
   * @param {string | null | undefined} label
   * @private
   * */
  __setAriaLabelToAttribute(e) {
    this.__target && (e ? (Rv(this.__target, "aria-labelledby"), this.__target.setAttribute("aria-label", e)) : this.__label && (Fv(this.__target, "aria-labelledby"), this.__target.removeAttribute("aria-label")));
  }
  /**
   * @param {string | null | undefined} labelId
   * @param {string | null | undefined} oldLabelId
   * @param {boolean | null | undefined} fromUser
   * @private
   */
  __setLabelIdToAriaAttribute(e, t, r) {
    en(this.__target, "aria-labelledby", { newId: e, oldId: t, fromUser: r });
  }
  /**
   * @param {string | null | undefined} errorId
   * @param {string | null | undefined} oldErrorId
   * @private
   */
  __setErrorIdToAriaAttribute(e, t) {
    en(this.__target, "aria-describedby", { newId: e, oldId: t, fromUser: !1 });
  }
  /**
   * @param {string | null | undefined} helperId
   * @param {string | null | undefined} oldHelperId
   * @private
   */
  __setHelperIdToAriaAttribute(e, t) {
    en(this.__target, "aria-describedby", { newId: e, oldId: t, fromUser: !1 });
  }
  /**
   * @param {boolean} required
   * @private
   */
  __setAriaRequiredAttribute(e) {
    this.__target && (["input", "textarea"].includes(this.__target.localName) || (e ? this.__target.setAttribute("aria-required", "true") : this.__target.removeAttribute("aria-required")));
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const tn = [];
class Vv {
  /**
   * @param {HTMLElement} host
   */
  constructor(e) {
    this.host = e, this.__trapNode = null, this.__onKeyDown = this.__onKeyDown.bind(this);
  }
  /**
   * An array of tab-ordered focusable elements inside the trap node.
   *
   * @return {HTMLElement[]}
   * @private
   */
  get __focusableElements() {
    return rv(this.__trapNode);
  }
  /**
   * The index of the element inside the trap node that currently has focus.
   *
   * @return {HTMLElement | undefined}
   * @private
   */
  get __focusedElementIndex() {
    const e = this.__focusableElements;
    return e.indexOf(e.filter(Fa).pop());
  }
  hostConnected() {
    document.addEventListener("keydown", this.__onKeyDown);
  }
  hostDisconnected() {
    document.removeEventListener("keydown", this.__onKeyDown);
  }
  /**
   * Activates a focus trap for a DOM node that will prevent focus from escaping the node.
   * The trap can be deactivated with the `.releaseFocus()` method.
   *
   * If focus is initially outside the trap, the method will move focus inside,
   * on the first focusable element of the trap in the tab order.
   * The first focusable element can be the trap node itself if it is focusable
   * and comes first in the tab order.
   *
   * If there are no focusable elements, the method will throw an exception
   * and the trap will not be set.
   *
   * @param {HTMLElement} trapNode
   */
  trapFocus(e) {
    if (this.__trapNode = e, this.__focusableElements.length === 0)
      throw this.__trapNode = null, new Error("The trap node should have at least one focusable descendant or be focusable itself.");
    tn.push(this), this.__focusedElementIndex === -1 && this.__focusableElements[0].focus();
  }
  /**
   * Deactivates the focus trap set with the `.trapFocus()` method
   * so that it becomes possible to tab outside the trap node.
   */
  releaseFocus() {
    this.__trapNode = null, tn.pop();
  }
  /**
   * A `keydown` event handler that manages tabbing navigation when the trap is enabled.
   *
   * - Moves focus to the next focusable element of the trap on `Tab` press.
   * When no next element to focus, the method moves focus to the first focusable element.
   * - Moves focus to the prev focusable element of the trap on `Shift+Tab` press.
   * When no prev element to focus, the method moves focus to the last focusable element.
   *
   * @param {KeyboardEvent} event
   * @private
   */
  __onKeyDown(e) {
    if (this.__trapNode && this === Array.from(tn).pop() && e.key === "Tab") {
      e.preventDefault();
      const t = e.shiftKey;
      this.__focusNextElement(t);
    }
  }
  /**
   * - Moves focus to the next focusable element if `backward === false`.
   * When no next element to focus, the method moves focus to the first focusable element.
   * - Moves focus to the prev focusable element if `backward === true`.
   * When no prev element to focus the method moves focus to the last focusable element.
   *
   * If no focusable elements, the method returns immediately.
   *
   * @param {boolean} backward
   * @private
   */
  __focusNextElement(e = !1) {
    const t = this.__focusableElements, r = e ? -1 : 1, s = this.__focusedElementIndex, o = (t.length + s + r) % t.length, n = t[o];
    n.focus(), n.localName === "input" && n.select();
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class Hv {
  /**
   * Saves the given node as a target for restoring focus to
   * when `restoreFocus()` is called. If no node is provided,
   * the currently focused node in the DOM is saved as a target.
   *
   * @param {Node | null | undefined} focusNode
   */
  saveFocus(e) {
    this.focusNode = e || qn();
  }
  /**
   * Restores focus to the target node that was saved previously with `saveFocus()`.
   */
  restoreFocus() {
    const e = this.focusNode;
    e && (qn() === document.body ? setTimeout(() => e.focus()) : e.focus(), this.focusNode = null);
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function zc(i, e) {
  const { scrollLeft: t } = i;
  return e !== "rtl" ? t : i.scrollWidth - i.clientWidth + t;
}
/**
 * @license
 * Copyright (c) 2021 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const cs = new ResizeObserver((i) => {
  setTimeout(() => {
    i.forEach((e) => {
      e.target.resizables ? e.target.resizables.forEach((t) => {
        t._onResize(e.contentRect);
      }) : e.target._onResize(e.contentRect);
    });
  });
}), Bv = Y(
  (i) => class extends i {
    /**
     * When true, the parent element resize will be also observed.
     * Override this getter and return `true` to enable this.
     *
     * @protected
     */
    get _observeParent() {
      return !1;
    }
    /** @protected */
    connectedCallback() {
      if (super.connectedCallback(), cs.observe(this), this._observeParent) {
        const t = this.parentNode instanceof ShadowRoot ? this.parentNode.host : this.parentNode;
        t.resizables || (t.resizables = /* @__PURE__ */ new Set(), cs.observe(t)), t.resizables.add(this), this.__parent = t;
      }
    }
    /** @protected */
    disconnectedCallback() {
      super.disconnectedCallback(), cs.unobserve(this);
      const t = this.__parent;
      if (this._observeParent && t) {
        const r = t.resizables;
        r && (r.delete(this), r.size === 0 && cs.unobserve(t)), this.__parent = null;
      }
    }
    /**
     * A handler invoked on host resize. By default, it does nothing.
     * Override the method to implement your own behavior.
     *
     * @protected
     */
    _onResize(t) {
    }
  }
);
/**
 * @license
 * Copyright (c) 2016 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Nc = {
  SCROLLING: 500,
  UPDATE_CONTENT_VISIBILITY: 100
}, Uv = (i) => class extends Bv(i) {
  static get properties() {
    return {
      /**
       * Allows you to choose between modes for rendering columns in the grid:
       *
       * "eager" (default): All columns are rendered upfront, regardless of their visibility within the viewport.
       * This mode should generally be preferred, as it avoids the limitations imposed by the "lazy" mode.
       * Use this mode unless the grid has a large number of columns and performance outweighs the limitations
       * in priority.
       *
       * "lazy": Optimizes the rendering of cells when there are multiple columns in the grid by virtualizing
       * horizontal scrolling. In this mode, body cells are rendered only when their corresponding columns are
       * inside the visible viewport.
       *
       * Using "lazy" rendering should be used only if you're dealing with a large number of columns and performance
       * is your highest priority. For most use cases, the default "eager" mode is recommended due to the
       * limitations imposed by the "lazy" mode.
       *
       * When using the "lazy" mode, keep the following limitations in mind:
       *
       * - Row Height: When only a number of columns are visible at once, the height of a row can only be that of
       * the highest cell currently visible on that row. Make sure each cell on a single row has the same height
       * as all other cells on that row. If row cells have different heights, users may experience jumpiness when
       * scrolling the grid horizontally as lazily rendered cells with different heights are scrolled into view.
       *
       * - Auto-width Columns: For the columns that are initially outside the visible viewport but still use auto-width,
       * only the header content is taken into account when calculating the column width because the body cells
       * of the columns outside the viewport are not initially rendered.
       *
       * - Screen Reader Compatibility: Screen readers may not be able to associate the focused cells with the correct
       * headers when only a subset of the body cells on a row is rendered.
       *
       * - Keyboard Navigation: Tabbing through focusable elements inside the grid body may not work as expected because
       * some of the columns that would include focusable elements in the body cells may be outside the visible viewport
       * and thus not rendered.
       *
       * @attr {eager|lazy} column-rendering
       * @type {!ColumnRendering}
       */
      columnRendering: {
        type: String,
        value: "eager"
      },
      /**
       * Cached array of frozen cells
       * @private
       */
      _frozenCells: {
        type: Array,
        value: () => []
      },
      /**
       * Cached array of cells frozen to end
       * @private
       */
      _frozenToEndCells: {
        type: Array,
        value: () => []
      },
      /** @private */
      _rowWithFocusedElement: Element
    };
  }
  static get observers() {
    return ["__columnRenderingChanged(_columnTree, columnRendering)"];
  }
  /** @private */
  get _scrollLeft() {
    return this.$.table.scrollLeft;
  }
  /** @private */
  get _scrollTop() {
    return this.$.table.scrollTop;
  }
  /**
   * Override (from iron-scroll-target-behavior) to avoid document scroll
   * @private
   */
  set _scrollTop(t) {
    this.$.table.scrollTop = t;
  }
  /** @protected */
  get _lazyColumns() {
    return this.columnRendering === "lazy";
  }
  /** @protected */
  ready() {
    super.ready(), this.scrollTarget = this.$.table, this.$.items.addEventListener("focusin", (t) => {
      const r = t.composedPath().indexOf(this.$.items);
      this._rowWithFocusedElement = t.composedPath()[r - 1];
    }), this.$.items.addEventListener("focusout", () => {
      this._rowWithFocusedElement = void 0;
    }), this.$.table.addEventListener("scroll", () => this._afterScroll());
  }
  /**
   * @protected
   * @override
   */
  _onResize() {
    if (this._updateOverflow(), this.__updateHorizontalScrollPosition(), this._firefox) {
      const t = !Vs(this);
      t && this.__previousVisible === !1 && (this._scrollTop = this.__memorizedScrollTop || 0), this.__previousVisible = t;
    }
  }
  /**
   * Scroll to a flat index in the grid. The method doesn't take into account
   * the hierarchy of the items.
   *
   * @param {number} index Row index to scroll to
   * @protected
   */
  _scrollToFlatIndex(t) {
    t = Math.min(this._effectiveSize - 1, Math.max(0, t)), this.__virtualizer.scrollToIndex(t), this.__scrollIntoViewport(t);
  }
  /**
   * Makes sure the row with the given index (if found in the DOM) is fully
   * inside the visible viewport, taking header/footer into account.
   * @private
   */
  __scrollIntoViewport(t) {
    const r = [...this.$.items.children].find((s) => s.index === t);
    if (r) {
      const s = r.getBoundingClientRect(), o = this.$.footer.getBoundingClientRect().top, n = this.$.header.getBoundingClientRect().bottom;
      s.bottom > o ? this.$.table.scrollTop += s.bottom - o : s.top < n && (this.$.table.scrollTop -= n - s.top);
    }
  }
  /** @private */
  _scheduleScrolling() {
    this._scrollingFrame || (this._scrollingFrame = requestAnimationFrame(() => this.$.scroller.toggleAttribute("scrolling", !0))), this._debounceScrolling = R.debounce(this._debounceScrolling, _e.after(Nc.SCROLLING), () => {
      cancelAnimationFrame(this._scrollingFrame), delete this._scrollingFrame, this.$.scroller.toggleAttribute("scrolling", !1);
    });
  }
  /** @private */
  _afterScroll() {
    this.__updateHorizontalScrollPosition(), this.hasAttribute("reordering") || this._scheduleScrolling(), this.hasAttribute("navigating") || this._hideTooltip(!0), this._updateOverflow(), this._debounceColumnContentVisibility = R.debounce(
      this._debounceColumnContentVisibility,
      _e.after(Nc.UPDATE_CONTENT_VISIBILITY),
      () => {
        this._lazyColumns && this.__cachedScrollLeft !== this._scrollLeft && (this.__cachedScrollLeft = this._scrollLeft, this.__updateColumnsBodyContentHidden());
      }
    ), this._firefox && !Vs(this) && this.__previousVisible !== !1 && (this.__memorizedScrollTop = this._scrollTop);
  }
  /** @private */
  __updateColumnsBodyContentHidden() {
    if (!this._columnTree)
      return;
    const t = this._getColumnsInOrder();
    if (!t[0] || !t[0]._sizerCell)
      return;
    let r = !1;
    if (t.forEach((s) => {
      const o = this._lazyColumns && !this.__isColumnInViewport(s);
      s._bodyContentHidden !== o && (r = !0, s._cells.forEach((n) => {
        if (n !== s._sizerCell) {
          if (o)
            n.remove();
          else if (n.__parentRow) {
            const a = [...n.__parentRow.children].find(
              (l) => t.indexOf(l._column) > t.indexOf(s)
            );
            n.__parentRow.insertBefore(n, a);
          }
        }
      })), s._bodyContentHidden = o;
    }), r && this._frozenCellsChanged(), this._lazyColumns) {
      const s = [...t].reverse().find((a) => a.frozen), o = this.__getColumnEnd(s), n = t.find((a) => !a.frozen && !a._bodyContentHidden);
      this.__lazyColumnsStart = this.__getColumnStart(n) - o, this.$.items.style.setProperty("--_grid-lazy-columns-start", `${this.__lazyColumnsStart}px`), this._resetKeyboardNavigation();
    }
  }
  /** @private */
  __getColumnEnd(t) {
    return t ? t._sizerCell.offsetLeft + (this.__isRTL ? 0 : t._sizerCell.offsetWidth) : this.__isRTL ? this.$.table.clientWidth : 0;
  }
  /** @private */
  __getColumnStart(t) {
    return t ? t._sizerCell.offsetLeft + (this.__isRTL ? t._sizerCell.offsetWidth : 0) : this.__isRTL ? this.$.table.clientWidth : 0;
  }
  /**
   * Returns true if the given column is horizontally inside the viewport.
   * @private
   */
  __isColumnInViewport(t) {
    return t.frozen || t.frozenToEnd ? !0 : t._sizerCell.offsetLeft + t._sizerCell.offsetWidth >= this._scrollLeft && t._sizerCell.offsetLeft <= this._scrollLeft + this.clientWidth;
  }
  /** @private */
  __columnRenderingChanged(t, r) {
    r === "eager" ? this.$.scroller.removeAttribute("column-rendering") : this.$.scroller.setAttribute("column-rendering", r), this.__updateColumnsBodyContentHidden();
  }
  /** @private */
  _updateOverflow() {
    this._debounceOverflow = R.debounce(this._debounceOverflow, wt, () => {
      this.__doUpdateOverflow();
    });
  }
  /** @private */
  __doUpdateOverflow() {
    let t = "";
    const r = this.$.table;
    r.scrollTop < r.scrollHeight - r.clientHeight && (t += " bottom"), r.scrollTop > 0 && (t += " top");
    const s = zc(r, this.getAttribute("dir"));
    s > 0 && (t += " start"), s < r.scrollWidth - r.clientWidth && (t += " end"), this.__isRTL && (t = t.replace(/start|end/giu, (n) => n === "start" ? "end" : "start")), r.scrollLeft < r.scrollWidth - r.clientWidth && (t += " right"), r.scrollLeft > 0 && (t += " left");
    const o = t.trim();
    o.length > 0 && this.getAttribute("overflow") !== o ? this.setAttribute("overflow", o) : o.length === 0 && this.hasAttribute("overflow") && this.removeAttribute("overflow");
  }
  /** @protected */
  _frozenCellsChanged() {
    this._debouncerCacheElements = R.debounce(this._debouncerCacheElements, xt, () => {
      Array.from(this.shadowRoot.querySelectorAll('[part~="cell"]')).forEach((t) => {
        t.style.transform = "";
      }), this._frozenCells = Array.prototype.slice.call(this.$.table.querySelectorAll("[frozen]")), this._frozenToEndCells = Array.prototype.slice.call(this.$.table.querySelectorAll("[frozen-to-end]")), this.__updateHorizontalScrollPosition();
    }), this._debounceUpdateFrozenColumn();
  }
  /** @protected */
  _debounceUpdateFrozenColumn() {
    this.__debounceUpdateFrozenColumn = R.debounce(
      this.__debounceUpdateFrozenColumn,
      xt,
      () => this._updateFrozenColumn()
    );
  }
  /** @private */
  _updateFrozenColumn() {
    if (!this._columnTree)
      return;
    const t = this._columnTree[this._columnTree.length - 1].slice(0);
    t.sort((o, n) => o._order - n._order);
    let r, s;
    for (let o = 0; o < t.length; o++) {
      const n = t[o];
      n._lastFrozen = !1, n._firstFrozenToEnd = !1, s === void 0 && n.frozenToEnd && !n.hidden && (s = o), n.frozen && !n.hidden && (r = o);
    }
    r !== void 0 && (t[r]._lastFrozen = !0), s !== void 0 && (t[s]._firstFrozenToEnd = !0), this.__updateColumnsBodyContentHidden();
  }
  /** @private */
  __updateHorizontalScrollPosition() {
    if (!this._columnTree)
      return;
    const t = this.$.table.scrollWidth, r = this.$.table.clientWidth, s = Math.max(0, this.$.table.scrollLeft), o = zc(this.$.table, this.getAttribute("dir")), n = `translate(${-s}px, 0)`;
    this.$.header.style.transform = n, this.$.footer.style.transform = n, this.$.items.style.transform = n;
    const a = this.__isRTL ? o + r - t : s, l = `translate(${a}px, 0)`;
    this._frozenCells.forEach((h) => {
      h.style.transform = l;
    });
    const c = this.__isRTL ? o : s + r - t, d = `translate(${c}px, 0)`;
    let u = d;
    if (this._lazyColumns) {
      const h = this._getColumnsInOrder(), f = [...h].reverse().find((F) => !F.frozenToEnd && !F._bodyContentHidden), m = this.__getColumnEnd(f), v = h.find((F) => F.frozenToEnd), k = this.__getColumnStart(v);
      u = `translate(${c + (k - m) + this.__lazyColumnsStart}px, 0)`;
    }
    this._frozenToEndCells.forEach((h) => {
      this.$.items.contains(h) ? h.style.transform = u : h.style.transform = d;
    }), this.hasAttribute("navigating") && this.__rowFocusMode && this.$.table.style.setProperty("--_grid-horizontal-scroll-position", `${-a}px`);
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const qv = (i) => class extends i {
  static get properties() {
    return {
      /**
       * An array that contains the selected items.
       * @type {!Array<!GridItem>}
       */
      selectedItems: {
        type: Object,
        notify: !0,
        value: () => []
      },
      /**
       * Set of selected item ids
       * @private
       */
      __selectedKeys: {
        type: Object,
        computed: "__computeSelectedKeys(itemIdPath, selectedItems.*)"
      }
    };
  }
  static get observers() {
    return ["__selectedItemsChanged(itemIdPath, selectedItems.*)"];
  }
  /**
   * @param {!GridItem} item
   * @return {boolean}
   * @protected
   */
  _isSelected(t) {
    return this.__selectedKeys.has(this.getItemId(t));
  }
  /**
   * Selects the given item.
   *
   * @method selectItem
   * @param {!GridItem} item The item object
   */
  selectItem(t) {
    this._isSelected(t) || (this.selectedItems = [...this.selectedItems, t]);
  }
  /**
   * Deselects the given item if it is already selected.
   *
   * @method deselect
   * @param {!GridItem} item The item object
   */
  deselectItem(t) {
    this._isSelected(t) && (this.selectedItems = this.selectedItems.filter((r) => !this._itemsEqual(r, t)));
  }
  /**
   * Toggles the selected state of the given item.
   *
   * @method toggle
   * @param {!GridItem} item The item object
   * @protected
   */
  _toggleItem(t) {
    this._isSelected(t) ? this.deselectItem(t) : this.selectItem(t);
  }
  /** @private */
  __selectedItemsChanged() {
    this.requestContentUpdate();
  }
  /** @private */
  __computeSelectedKeys(t, r) {
    const s = r.base || [], o = /* @__PURE__ */ new Set();
    return s.forEach((n) => {
      o.add(this.getItemId(n));
    }), o;
  }
  /**
   * Fired when the `selectedItems` property changes.
   *
   * @event selected-items-changed
   */
};
/**
 * @license
 * Copyright (c) 2016 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
let Fc = "prepend";
const Wv = (i) => class extends i {
  static get properties() {
    return {
      /**
       * When `true`, all `<vaadin-grid-sorter>` are applied for sorting.
       * @attr {boolean} multi-sort
       * @type {boolean}
       */
      multiSort: {
        type: Boolean,
        value: !1
      },
      /**
       * Controls how columns are added to the sort order when using multi-sort.
       * The sort order is visually indicated by numbers in grid sorters placed in column headers.
       *
       * By default, whenever an unsorted column is sorted, or the sort-direction of a column is
       * changed, that column gets sort priority 1, thus affecting the priority for all the other
       * sorted columns. This is identical to using `multi-sort-priority="prepend"`.
       *
       * Using this property allows to change this behavior so that sorting an unsorted column
       * would add it to the "end" of the sort, and changing column's sort direction would retain
       * it's previous priority. To set this, use `multi-sort-priority="append"`.
       *
       * @attr {string} multi-sort-priority
       */
      multiSortPriority: {
        type: String,
        value: () => Fc
      },
      /**
       * When `true`, Shift-clicking an unsorted column's sorter adds it to the multi-sort.
       * Shift + Space does the same action via keyboard. This property has precedence over the
       * `multiSort` property. If `multiSortOnShiftClick` is true, the multiSort property is effectively ignored.
       *
       * @attr {boolean} multi-sort-on-shift-click
       * @type {boolean}
       */
      multiSortOnShiftClick: {
        type: Boolean,
        value: !1
      },
      /**
       * @type {!Array<!GridSorterDefinition>}
       * @protected
       */
      _sorters: {
        type: Array,
        value: () => []
      },
      /** @private */
      _previousSorters: {
        type: Array,
        value: () => []
      }
    };
  }
  /**
   * Sets the default multi-sort priority to use for all grid instances.
   * This method should be called before creating any grid instances.
   * Changing this setting does not affect the default for existing grids.
   *
   * @param {string} priority
   */
  static setDefaultMultiSortPriority(t) {
    Fc = ["append", "prepend"].includes(t) ? t : "prepend";
  }
  /** @protected */
  ready() {
    super.ready(), this.addEventListener("sorter-changed", this._onSorterChanged);
  }
  /** @private */
  _onSorterChanged(t) {
    const r = t.target;
    t.stopPropagation(), r._grid = this, this.__updateSorter(r, t.detail.shiftClick, t.detail.fromSorterClick), this.__applySorters();
  }
  /** @private */
  __removeSorters(t) {
    t.length !== 0 && (this._sorters = this._sorters.filter((r) => t.indexOf(r) < 0), this.multiSort && this.__updateSortOrders(), this.__applySorters());
  }
  /** @private */
  __updateSortOrders() {
    this._sorters.forEach((t, r) => {
      t._order = this._sorters.length > 1 ? r : null;
    });
  }
  /** @private */
  __appendSorter(t) {
    t.direction ? this._sorters.includes(t) || this._sorters.push(t) : this._removeArrayItem(this._sorters, t), this.__updateSortOrders();
  }
  /** @private */
  __prependSorter(t) {
    this._removeArrayItem(this._sorters, t), t.direction && this._sorters.unshift(t), this.__updateSortOrders();
  }
  /** @private */
  __updateSorter(t, r, s) {
    if (!(!t.direction && this._sorters.indexOf(t) === -1)) {
      if (t._order = null, this.multiSort && (!this.multiSortOnShiftClick || !s) || this.multiSortOnShiftClick && r)
        this.multiSortPriority === "append" ? this.__appendSorter(t) : this.__prependSorter(t);
      else if (t.direction || this.multiSortOnShiftClick) {
        const o = this._sorters.filter((n) => n !== t);
        this._sorters = t.direction ? [t] : [], o.forEach((n) => {
          n._order = null, n.direction = null;
        });
      }
    }
  }
  /** @private */
  __applySorters() {
    this.dataProvider && // No need to clear cache if sorters didn't change and grid is attached
    this.isAttached && JSON.stringify(this._previousSorters) !== JSON.stringify(this._mapSorters()) && this.clearCache(), this._a11yUpdateSorters(), this._previousSorters = this._mapSorters();
  }
  /**
   * @return {!Array<!GridSorterDefinition>}
   * @protected
   */
  _mapSorters() {
    return this._sorters.map((t) => ({
      path: t.path,
      direction: t.direction
    }));
  }
  /** @private */
  _removeArrayItem(t, r) {
    const s = t.indexOf(r);
    s > -1 && t.splice(s, 1);
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const jv = (i) => class extends i {
  static get properties() {
    return {
      /**
       * A function that allows generating CSS class names for grid cells
       * based on their row and column. The return value should be the generated
       * class name as a string, or multiple class names separated by whitespace
       * characters.
       *
       * Receives two arguments:
       * - `column` The `<vaadin-grid-column>` element (`undefined` for details-cell).
       * - `model` The object with the properties related with
       *   the rendered item, contains:
       *   - `model.index` The index of the item.
       *   - `model.item` The item.
       *   - `model.expanded` Sublevel toggle state.
       *   - `model.level` Level of the tree represented with a horizontal offset of the toggle button.
       *   - `model.selected` Selected state.
       *
       * @type {GridCellClassNameGenerator | null | undefined}
       * @deprecated Use `cellPartNameGenerator` instead.
       */
      cellClassNameGenerator: Function,
      /**
       * A function that allows generating CSS `part` names for grid cells in Shadow DOM based
       * on their row and column, for styling from outside using the `::part()` selector.
       *
       * The return value should be the generated part name as a string, or multiple part names
       * separated by whitespace characters.
       *
       * Receives two arguments:
       * - `column` The `<vaadin-grid-column>` element (`undefined` for details-cell).
       * - `model` The object with the properties related with
       *   the rendered item, contains:
       *   - `model.index` The index of the item.
       *   - `model.item` The item.
       *   - `model.expanded` Sublevel toggle state.
       *   - `model.level` Level of the tree represented with a horizontal offset of the toggle button.
       *   - `model.selected` Selected state.
       *
       * @type {GridCellPartNameGenerator | null | undefined}
       */
      cellPartNameGenerator: Function
    };
  }
  static get observers() {
    return [
      "__cellClassNameGeneratorChanged(cellClassNameGenerator)",
      "__cellPartNameGeneratorChanged(cellPartNameGenerator)"
    ];
  }
  /** @private */
  __cellClassNameGeneratorChanged() {
    this.generateCellClassNames();
  }
  /** @private */
  __cellPartNameGeneratorChanged() {
    this.generateCellPartNames();
  }
  /**
   * Runs the `cellClassNameGenerator` for the visible cells.
   * If the generator depends on varying conditions, you need to
   * call this function manually in order to update the styles when
   * the conditions change.
   *
   * @deprecated Use `cellPartNameGenerator` and `generateCellPartNames()` instead.
   */
  generateCellClassNames() {
    le(this.$.items, (t) => {
      !t.hidden && !t.hasAttribute("loading") && this._generateCellClassNames(t, this.__getRowModel(t));
    });
  }
  /**
   * Runs the `cellPartNameGenerator` for the visible cells.
   * If the generator depends on varying conditions, you need to
   * call this function manually in order to update the styles when
   * the conditions change.
   */
  generateCellPartNames() {
    le(this.$.items, (t) => {
      !t.hidden && !t.hasAttribute("loading") && this._generateCellPartNames(t, this.__getRowModel(t));
    });
  }
  /** @private */
  _generateCellClassNames(t, r) {
    Ir(t, (s) => {
      if (s.__generatedClasses && s.__generatedClasses.forEach((o) => s.classList.remove(o)), this.cellClassNameGenerator) {
        const o = this.cellClassNameGenerator(s._column, r);
        s.__generatedClasses = o && o.split(" ").filter((n) => n.length > 0), s.__generatedClasses && s.__generatedClasses.forEach((n) => s.classList.add(n));
      }
    });
  }
  /** @private */
  _generateCellPartNames(t, r) {
    Ir(t, (s) => {
      if (s.__generatedParts && s.__generatedParts.forEach((o) => {
        kt(s, null, o);
      }), this.cellPartNameGenerator) {
        const o = this.cellPartNameGenerator(s._column, r);
        s.__generatedParts = o && o.split(" ").filter((n) => n.length > 0), s.__generatedParts && s.__generatedParts.forEach((n) => {
          kt(s, !0, n);
        });
      }
    });
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Gv = (i) => class extends Cv(
  vv(
    $v(
      gv(
        Uv(
          qv(
            Wv(
              Nv(
                zv(
                  mv(
                    Mv(
                      wv(
                        xv(
                          Pv(Av(jv(Ra(i))))
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  )
) {
  static get observers() {
    return [
      "_columnTreeChanged(_columnTree, _columnTree.*)",
      "_effectiveSizeChanged(_effectiveSize, __virtualizer, _hasData, _columnTree)"
    ];
  }
  static get properties() {
    return {
      /** @private */
      _safari: {
        type: Boolean,
        value: jh
      },
      /** @private */
      _ios: {
        type: Boolean,
        value: Hs
      },
      /** @private */
      _firefox: {
        type: Boolean,
        value: Wh
      },
      /** @private */
      _android: {
        type: Boolean,
        value: Ic
      },
      /** @private */
      _touchDevice: {
        type: Boolean,
        value: Ii
      },
      /**
       * If true, the grid's height is defined by its rows.
       *
       * Effectively, this disables the grid's virtual scrolling so that all the rows are rendered in the DOM at once.
       * If the grid has a large number of items, using the feature is discouraged to avoid performance issues.
       * @attr {boolean} all-rows-visible
       * @type {boolean}
       */
      allRowsVisible: {
        type: Boolean,
        value: !1,
        reflectToAttribute: !0
      },
      /** @private */
      __pendingRecalculateColumnWidths: {
        type: Boolean,
        value: !0
      },
      /** @private */
      isAttached: {
        value: !1
      },
      /**
       * An internal property that is mainly used by `vaadin-template-renderer`
       * to identify grid elements.
       *
       * @private
       */
      __gridElement: {
        type: Boolean,
        value: !0
      }
    };
  }
  constructor() {
    super(), this.addEventListener("animationend", this._onAnimationEnd);
  }
  /** @private */
  get _firstVisibleIndex() {
    const e = this.__getFirstVisibleItem();
    return e ? e.index : void 0;
  }
  /** @private */
  get _lastVisibleIndex() {
    const e = this.__getLastVisibleItem();
    return e ? e.index : void 0;
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback(), this.isAttached = !0, this.recalculateColumnWidths();
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback(), this.isAttached = !1, this._hideTooltip(!0);
  }
  /** @private */
  __getFirstVisibleItem() {
    return this._getRenderedRows().find((e) => this._isInViewport(e));
  }
  /** @private */
  __getLastVisibleItem() {
    return this._getRenderedRows().reverse().find((e) => this._isInViewport(e));
  }
  /** @private */
  _isInViewport(e) {
    const t = this.$.table.getBoundingClientRect(), r = e.getBoundingClientRect(), s = this.$.header.getBoundingClientRect().height, o = this.$.footer.getBoundingClientRect().height;
    return r.bottom > t.top + s && r.top < t.bottom - o;
  }
  /** @private */
  _getRenderedRows() {
    return Array.from(this.$.items.children).filter((e) => !e.hidden).sort((e, t) => e.index - t.index);
  }
  /** @protected */
  _getRowContainingNode(e) {
    const t = $h("vaadin-grid-cell-content", e);
    return t ? t.assignedSlot.parentElement.parentElement : void 0;
  }
  /** @protected */
  _isItemAssignedToRow(e, t) {
    const r = this.__getRowModel(t);
    return this.getItemId(e) === this.getItemId(r.item);
  }
  /** @protected */
  ready() {
    super.ready(), this.__virtualizer = new Yh({
      createElements: this._createScrollerRows.bind(this),
      updateElement: this._updateScrollerItem.bind(this),
      scrollContainer: this.$.items,
      scrollTarget: this.$.table,
      reorderElements: !0
    }), new ResizeObserver(
      () => setTimeout(() => {
        this.__updateFooterPositioning(), this.__updateColumnsBodyContentHidden(), this.__tryToRecalculateColumnWidthsIfPending();
      })
    ).observe(this.$.table), Ha(this), this._tooltipController = new Et(this), this.addController(this._tooltipController), this._tooltipController.setManual(!0);
  }
  /** @private */
  __getBodyCellCoordinates(e) {
    if (this.$.items.contains(e) && e.localName === "td")
      return {
        item: e.parentElement._item,
        column: e._column
      };
  }
  /** @private */
  __focusBodyCell({ item: e, column: t }) {
    const r = this._getRenderedRows().find((o) => o._item === e), s = r && [...r.children].find((o) => o._column === t);
    s && s.focus();
  }
  /** @protected */
  _focusFirstVisibleRow() {
    const e = this.__getFirstVisibleItem();
    this.__rowFocusMode = !0, e.focus();
  }
  /** @private */
  _effectiveSizeChanged(e, t, r, s) {
    if (t && r && s) {
      const o = this.shadowRoot.activeElement, n = this.__getBodyCellCoordinates(o), a = t.size || 0;
      t.size = e, t.update(a - 1, a - 1), e < a && t.update(e - 1, e - 1), n && o.parentElement.hidden && this.__focusBodyCell(n), this._resetKeyboardNavigation();
    }
  }
  /** @private */
  __hasRowsWithClientHeight() {
    return !!Array.from(this.$.items.children).filter((e) => e.clientHeight).length;
  }
  /** @private */
  __getIntrinsicWidth(e) {
    return this.__intrinsicWidthCache.has(e) || this.__calculateAndCacheIntrinsicWidths([e]), this.__intrinsicWidthCache.get(e);
  }
  /** @private */
  __getDistributedWidth(e, t) {
    if (e == null || e === this)
      return 0;
    const r = Math.max(
      this.__getIntrinsicWidth(e),
      this.__getDistributedWidth((e.assignedSlot || e).parentElement, e)
    );
    if (!t)
      return r;
    const s = e, o = r, n = s._visibleChildColumns.map((d) => this.__getIntrinsicWidth(d)).reduce((d, u) => d + u, 0), a = Math.max(0, o - n), c = this.__getIntrinsicWidth(t) / n * a;
    return this.__getIntrinsicWidth(t) + c;
  }
  /**
   * @param {!Array<!GridColumn>} cols the columns to auto size based on their content width
   * @private
   */
  _recalculateColumnWidths(e) {
    this.__virtualizer.flush(), [...this.$.header.children, ...this.$.footer.children].forEach((s) => {
      s.__debounceUpdateHeaderFooterRowVisibility && s.__debounceUpdateHeaderFooterRowVisibility.flush();
    }), this._debouncerHiddenChanged && this._debouncerHiddenChanged.flush(), this.__intrinsicWidthCache = /* @__PURE__ */ new Map();
    const t = this._firstVisibleIndex, r = this._lastVisibleIndex;
    this.__viewportRowsCache = this._getRenderedRows().filter((s) => s.index >= t && s.index <= r), this.__calculateAndCacheIntrinsicWidths(e), e.forEach((s) => {
      s.width = `${this.__getDistributedWidth(s)}px`;
    });
  }
  /**
   * Toggles the cell content for the given column to use or not use auto width.
   *
   * While content for all the column cells uses auto width (instead of the default 100%),
   * their offsetWidth can be used to calculate the collective intrinsic width of the column.
   *
   * @private
   */
  __setVisibleCellContentAutoWidth(e, t) {
    e._allCells.filter((r) => this.$.items.contains(r) ? this.__viewportRowsCache.includes(r.parentElement) : !0).forEach((r) => {
      r.__measuringAutoWidth = t, r._content.style.width = t ? "auto" : "", r._content.style.position = t ? "absolute" : "";
    });
  }
  /**
   * Returns the maximum intrinsic width of the cell content in the given column.
   * Only cells which are marked for measuring auto width are considered.
   *
   * @private
   */
  __getAutoWidthCellsMaxWidth(e) {
    return e._allCells.reduce((t, r) => r.__measuringAutoWidth ? Math.max(t, r._content.offsetWidth + 1) : t, 0);
  }
  /**
   * Calculates and caches the intrinsic width of each given column.
   *
   * @private
   */
  __calculateAndCacheIntrinsicWidths(e) {
    e.forEach((t) => this.__setVisibleCellContentAutoWidth(t, !0)), e.forEach((t) => {
      const r = this.__getAutoWidthCellsMaxWidth(t);
      this.__intrinsicWidthCache.set(t, r);
    }), e.forEach((t) => this.__setVisibleCellContentAutoWidth(t, !1));
  }
  /**
   * Updates the `width` of all columns which have `autoWidth` set to `true`.
   */
  recalculateColumnWidths() {
    if (!this._columnTree)
      return;
    if (Vs(this) || this._cache.isLoading()) {
      this.__pendingRecalculateColumnWidths = !0;
      return;
    }
    const e = this._getColumns().filter((t) => !t.hidden && t.autoWidth);
    this._recalculateColumnWidths(e);
  }
  /** @private */
  __tryToRecalculateColumnWidthsIfPending() {
    this.__pendingRecalculateColumnWidths && !Vs(this) && !this._cache.isLoading() && this.__hasRowsWithClientHeight() && (this.__pendingRecalculateColumnWidths = !1, this.recalculateColumnWidths());
  }
  /**
   * @protected
   * @override
   */
  _onDataProviderPageLoaded() {
    super._onDataProviderPageLoaded(), this.__tryToRecalculateColumnWidthsIfPending();
  }
  /** @private */
  _createScrollerRows(e) {
    const t = [];
    for (let r = 0; r < e; r++) {
      const s = document.createElement("tr");
      s.setAttribute("part", "row"), s.setAttribute("role", "row"), s.setAttribute("tabindex", "-1"), this._columnTree && this._updateRow(s, this._columnTree[this._columnTree.length - 1], "body", !1, !0), t.push(s);
    }
    return this._columnTree && this._columnTree[this._columnTree.length - 1].forEach(
      (r) => r.isConnected && r.notifyPath && r.notifyPath("_cells.*", r._cells)
    ), this.__afterCreateScrollerRowsDebouncer = R.debounce(
      this.__afterCreateScrollerRowsDebouncer,
      wt,
      () => {
        this._afterScroll(), this.__tryToRecalculateColumnWidthsIfPending();
      }
    ), t;
  }
  /** @private */
  _createCell(e, t) {
    const s = `vaadin-grid-cell-content-${this._contentIndex = this._contentIndex + 1 || 0}`, o = document.createElement("vaadin-grid-cell-content");
    o.setAttribute("slot", s);
    const n = document.createElement(e);
    n.id = s.replace("-content-", "-"), n.setAttribute("role", e === "td" ? "gridcell" : "columnheader"), !Ic && !Hs && (n.addEventListener("mouseenter", (l) => {
      this.$.scroller.hasAttribute("scrolling") || this._showTooltip(l);
    }), n.addEventListener("mouseleave", () => {
      this._hideTooltip();
    }), n.addEventListener("mousedown", () => {
      this._hideTooltip(!0);
    }));
    const a = document.createElement("slot");
    if (a.setAttribute("name", s), t && t._focusButtonMode) {
      const l = document.createElement("div");
      l.setAttribute("role", "button"), l.setAttribute("tabindex", "-1"), n.appendChild(l), n._focusButton = l, n.focus = function() {
        n._focusButton.focus();
      }, l.appendChild(a);
    } else
      n.setAttribute("tabindex", "-1"), n.appendChild(a);
    return n._content = o, o.addEventListener("mousedown", () => {
      if (cv) {
        const l = (c) => {
          const d = o.contains(this.getRootNode().activeElement), u = c.composedPath().includes(o);
          !d && u && n.focus(), document.removeEventListener("mouseup", l, !0);
        };
        document.addEventListener("mouseup", l, !0);
      } else
        setTimeout(() => {
          o.contains(this.getRootNode().activeElement) || n.focus();
        });
    }), n;
  }
  /**
   * @param {!HTMLTableRowElement} row
   * @param {!Array<!GridColumn>} columns
   * @param {?string} section
   * @param {boolean} isColumnRow
   * @param {boolean} noNotify
   * @protected
   */
  _updateRow(e, t, r = "body", s = !1, o = !1) {
    const n = document.createDocumentFragment();
    Ir(e, (a) => {
      a._vacant = !0;
    }), e.innerHTML = "", r === "body" && (e.__cells = [], e.__detailsCell = null), t.filter((a) => !a.hidden).forEach((a, l, c) => {
      let d;
      if (r === "body") {
        if (a._cells || (a._cells = []), d = a._cells.find((u) => u._vacant), d || (d = this._createCell("td", a), a._cells.push(d)), d.setAttribute("part", "cell body-cell"), d.__parentRow = e, e.__cells.push(d), a._bodyContentHidden || e.appendChild(d), e === this.$.sizer && (a._sizerCell = d), l === c.length - 1 && this.rowDetailsRenderer) {
          this._detailsCells || (this._detailsCells = []);
          const u = this._detailsCells.find((h) => h._vacant) || this._createCell("td");
          this._detailsCells.indexOf(u) === -1 && this._detailsCells.push(u), u._content.parentElement || n.appendChild(u._content), this._configureDetailsCell(u), e.appendChild(u), e.__detailsCell = u, this._a11ySetRowDetailsCell(e, u), u._vacant = !1;
        }
        a.notifyPath && !o && a.notifyPath("_cells.*", a._cells);
      } else {
        const u = r === "header" ? "th" : "td";
        s || a.localName === "vaadin-grid-column-group" ? (d = a[`_${r}Cell`] || this._createCell(u), d._column = a, e.appendChild(d), a[`_${r}Cell`] = d) : (a._emptyCells || (a._emptyCells = []), d = a._emptyCells.find((h) => h._vacant) || this._createCell(u), d._column = a, e.appendChild(d), a._emptyCells.indexOf(d) === -1 && a._emptyCells.push(d)), d.setAttribute("part", `cell ${r}-cell`);
      }
      d._content.parentElement || n.appendChild(d._content), d._vacant = !1, d._column = a;
    }), r !== "body" && this.__debounceUpdateHeaderFooterRowVisibility(e), this.appendChild(n), this._frozenCellsChanged(), this._updateFirstAndLastColumnForRow(e);
  }
  /**
   * @param {HTMLTableRowElement} row
   * @protected
   */
  __debounceUpdateHeaderFooterRowVisibility(e) {
    e.__debounceUpdateHeaderFooterRowVisibility = R.debounce(
      e.__debounceUpdateHeaderFooterRowVisibility,
      xt,
      () => this.__updateHeaderFooterRowVisibility(e)
    );
  }
  /**
   * @param {HTMLTableRowElement} row
   * @protected
   */
  __updateHeaderFooterRowVisibility(e) {
    if (!e)
      return;
    const t = Array.from(e.children).filter((r) => {
      const s = r._column;
      if (s._emptyCells && s._emptyCells.indexOf(r) > -1)
        return !1;
      if (e.parentElement === this.$.header) {
        if (s.headerRenderer)
          return !0;
        if (s.header === null)
          return !1;
        if (s.path || s.header !== void 0)
          return !0;
      } else if (s.footerRenderer)
        return !0;
      return !1;
    });
    e.hidden !== !t.length && (e.hidden = !t.length), this._resetKeyboardNavigation();
  }
  /** @private */
  _updateScrollerItem(e, t) {
    this._preventScrollerRotatingCellFocus(e, t), this._columnTree && (this._updateRowOrderParts(e, t), this._a11yUpdateRowRowindex(e, t), this._getItem(t, e));
  }
  /** @private */
  _columnTreeChanged(e) {
    this._renderColumnTree(e), this.recalculateColumnWidths(), this.__updateColumnsBodyContentHidden();
  }
  /** @private */
  _updateRowOrderParts(e, t = e.index) {
    hi(e, {
      first: t === 0,
      last: t === this._effectiveSize - 1,
      odd: t % 2 !== 0,
      even: t % 2 === 0
    });
  }
  /** @private */
  _updateRowStateParts(e, { expanded: t, selected: r, detailsOpened: s }) {
    hi(e, {
      expanded: t,
      selected: r,
      "details-opened": s
    });
  }
  /**
   * @param {!Array<!GridColumn>} columnTree
   * @protected
   */
  _renderColumnTree(e) {
    for (le(this.$.items, (t) => {
      this._updateRow(t, e[e.length - 1], "body", !1, !0);
      const r = this.__getRowModel(t);
      this._updateRowOrderParts(t), this._updateRowStateParts(t, r), this._filterDragAndDrop(t, r);
    }); this.$.header.children.length < e.length; ) {
      const t = document.createElement("tr");
      t.setAttribute("part", "row"), t.setAttribute("role", "row"), t.setAttribute("tabindex", "-1"), this.$.header.appendChild(t);
      const r = document.createElement("tr");
      r.setAttribute("part", "row"), r.setAttribute("role", "row"), r.setAttribute("tabindex", "-1"), this.$.footer.appendChild(r);
    }
    for (; this.$.header.children.length > e.length; )
      this.$.header.removeChild(this.$.header.firstElementChild), this.$.footer.removeChild(this.$.footer.firstElementChild);
    le(this.$.header, (t, r, s) => {
      this._updateRow(t, e[r], "header", r === e.length - 1);
      const o = Tr(t);
      gt(o, "first-header-row-cell", r === 0), gt(o, "last-header-row-cell", r === s.length - 1);
    }), le(this.$.footer, (t, r, s) => {
      this._updateRow(t, e[e.length - 1 - r], "footer", r === 0);
      const o = Tr(t);
      gt(o, "first-footer-row-cell", r === 0), gt(o, "last-footer-row-cell", r === s.length - 1);
    }), this._updateRow(this.$.sizer, e[e.length - 1]), this._resizeHandler(), this._frozenCellsChanged(), this._updateFirstAndLastColumn(), this._resetKeyboardNavigation(), this._a11yUpdateHeaderRows(), this._a11yUpdateFooterRows(), this.__updateFooterPositioning(), this.generateCellClassNames(), this.generateCellPartNames();
  }
  /** @private */
  __updateFooterPositioning() {
    this._firefox && parseFloat(navigator.userAgent.match(/Firefox\/(\d{2,3}.\d)/u)[1]) < 99 && (this.$.items.style.paddingBottom = 0, this.allRowsVisible || (this.$.items.style.paddingBottom = `${this.$.footer.offsetHeight}px`));
  }
  /**
   * @param {!HTMLElement} row
   * @param {GridItem} item
   * @protected
   */
  _updateItem(e, t) {
    e._item = t;
    const r = this.__getRowModel(e);
    this._toggleDetailsCell(e, r.detailsOpened), this._a11yUpdateRowLevel(e, r.level), this._a11yUpdateRowSelected(e, r.selected), this._updateRowStateParts(e, r), this._generateCellClassNames(e, r), this._generateCellPartNames(e, r), this._filterDragAndDrop(e, r), le(e, (s) => {
      if (s._renderer) {
        const o = s._column || this;
        s._renderer.call(o, s._content, o, r);
      }
    }), this._updateDetailsCellHeight(e), this._a11yUpdateRowExpanded(e, r.expanded);
  }
  /** @private */
  _resizeHandler() {
    this._updateDetailsCellHeights(), this.__updateFooterPositioning(), this.__updateHorizontalScrollPosition();
  }
  /** @private */
  _onAnimationEnd(e) {
    e.animationName.indexOf("vaadin-grid-appear") === 0 && (e.stopPropagation(), this.__tryToRecalculateColumnWidthsIfPending(), requestAnimationFrame(() => {
      this.__scrollToPendingIndexes();
    }));
  }
  /**
   * @param {!HTMLTableRowElement} row
   * @return {!GridItemModel}
   * @protected
   */
  __getRowModel(e) {
    return {
      index: e.index,
      item: e._item,
      level: this._getIndexLevel(e.index),
      expanded: this._isExpanded(e._item),
      selected: this._isSelected(e._item),
      detailsOpened: !!this.rowDetailsRenderer && this._isDetailsOpened(e._item)
    };
  }
  /**
   * @param {Event} event
   * @protected
   */
  _showTooltip(e) {
    const t = this._tooltipController.node;
    t && t.isConnected && (this._tooltipController.setTarget(e.target), this._tooltipController.setContext(this.getEventContext(e)), t._stateController.open({
      focus: e.type === "focusin",
      hover: e.type === "mouseenter"
    }));
  }
  /** @protected */
  _hideTooltip(e) {
    const t = this._tooltipController.node;
    t && t._stateController.close(e);
  }
  /**
   * Requests an update for the content of cells.
   *
   * While performing the update, the following renderers are invoked:
   * - `Grid.rowDetailsRenderer`
   * - `GridColumn.renderer`
   * - `GridColumn.headerRenderer`
   * - `GridColumn.footerRenderer`
   *
   * It is not guaranteed that the update happens immediately (synchronously) after it is requested.
   */
  requestContentUpdate() {
    this._columnTree && (this._columnTree.forEach((e) => {
      e.forEach((t) => {
        t._renderHeaderAndFooter && t._renderHeaderAndFooter();
      });
    }), this.__updateVisibleRows());
  }
  /** @protected */
  __updateVisibleRows(e, t) {
    this.__virtualizer && this.__virtualizer.update(e, t);
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class Yv extends Gv(At(X(rt(N)))) {
  static get template() {
    return U`
      <div
        id="scroller"
        safari$="[[_safari]]"
        ios$="[[_ios]]"
        loading$="[[loading]]"
        column-reordering-allowed$="[[columnReorderingAllowed]]"
      >
        <table id="table" role="treegrid" aria-multiselectable="true" tabindex="0">
          <caption id="sizer" part="row"></caption>
          <thead id="header" role="rowgroup"></thead>
          <tbody id="items" role="rowgroup"></tbody>
          <tfoot id="footer" role="rowgroup"></tfoot>
        </table>

        <div part="reorder-ghost"></div>
      </div>

      <slot name="tooltip"></slot>

      <div id="focusexit" tabindex="0"></div>
    `;
  }
  static get is() {
    return "vaadin-grid";
  }
}
O(Yv);
/**
 * @license
 * Copyright (c) 2016 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class Zv extends qh(N) {
  static get is() {
    return "vaadin-grid-column-group";
  }
  static get properties() {
    return {
      /** @private */
      _childColumns: {
        value() {
          return this._getChildColumns(this);
        }
      },
      /**
       * Flex grow ratio for the column group as the sum of the ratios of its child columns.
       * @attr {number} flex-grow
       */
      flexGrow: {
        type: Number,
        readOnly: !0
      },
      /**
       * Width of the column group as the sum of the widths of its child columns.
       */
      width: {
        type: String,
        readOnly: !0
      },
      /** @private */
      _visibleChildColumns: Array,
      /** @private */
      _colSpan: Number,
      /** @private */
      _rootColumns: Array
    };
  }
  static get observers() {
    return [
      "_groupFrozenChanged(frozen, _rootColumns)",
      "_groupFrozenToEndChanged(frozenToEnd, _rootColumns)",
      "_groupHiddenChanged(hidden)",
      "_colSpanChanged(_colSpan, _headerCell, _footerCell)",
      "_groupOrderChanged(_order, _rootColumns)",
      "_groupReorderStatusChanged(_reorderStatus, _rootColumns)",
      "_groupResizableChanged(resizable, _rootColumns)"
    ];
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback(), this._addNodeObserver(), this._updateFlexAndWidth();
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback(), this._observer && this._observer.disconnect();
  }
  /**
   * @param {string} path
   * @param {unknown=} value
   * @protected
   */
  _columnPropChanged(e, t) {
    e === "hidden" && (this._preventHiddenSynchronization = !0, this._updateVisibleChildColumns(this._childColumns), this._preventHiddenSynchronization = !1), /flexGrow|width|hidden|_childColumns/u.test(e) && this._updateFlexAndWidth(), e === "frozen" && !this.frozen && (this.frozen = t), e === "lastFrozen" && !this._lastFrozen && (this._lastFrozen = t), e === "frozenToEnd" && !this.frozenToEnd && (this.frozenToEnd = t), e === "firstFrozenToEnd" && !this._firstFrozenToEnd && (this._firstFrozenToEnd = t);
  }
  /** @private */
  _groupOrderChanged(e, t) {
    if (t) {
      const r = t.slice(0);
      if (!e) {
        r.forEach((a) => {
          a._order = 0;
        });
        return;
      }
      const s = /(0+)$/u.exec(e).pop().length, o = ~~(Math.log(t.length) / Math.LN10) + 1, n = 10 ** (s - o);
      r[0] && r[0]._order && r.sort((a, l) => a._order - l._order), Uh(r, n, e);
    }
  }
  /** @private */
  _groupReorderStatusChanged(e, t) {
    e === void 0 || t === void 0 || t.forEach((r) => {
      r._reorderStatus = e;
    });
  }
  /** @private */
  _groupResizableChanged(e, t) {
    e === void 0 || t === void 0 || t.forEach((r) => {
      r.resizable = e;
    });
  }
  /** @private */
  _updateVisibleChildColumns(e) {
    this._visibleChildColumns = Array.prototype.filter.call(e, (t) => !t.hidden), this._colSpan = this._visibleChildColumns.length, this._updateAutoHidden();
  }
  /** @protected */
  _updateFlexAndWidth() {
    if (this._visibleChildColumns) {
      if (this._visibleChildColumns.length > 0) {
        const e = this._visibleChildColumns.reduce((t, r) => (t += ` + ${(r.width || "0px").replace("calc", "")}`, t), "").substring(3);
        this._setWidth(`calc(${e})`);
      } else
        this._setWidth("0px");
      this._setFlexGrow(Array.prototype.reduce.call(this._visibleChildColumns, (e, t) => e + t.flexGrow, 0));
    }
  }
  /**
   * This method is called before the group's frozen value is being propagated to the child columns.
   * In case some of the child columns are frozen, while others are not, the non-frozen ones
   * will get automatically frozen as well. As this may sometimes be unintended, this method
   * shows a warning in the console in such cases.
   * @private
   */
  __scheduleAutoFreezeWarning(e, t) {
    if (this._grid) {
      const r = t.replace(/([A-Z])/gu, "-$1").toLowerCase(), s = e[0][t] || e[0].hasAttribute(r);
      e.every((n) => (n[t] || n.hasAttribute(r)) === s) || (this._grid.__autoFreezeWarningDebouncer = R.debounce(
        this._grid.__autoFreezeWarningDebouncer,
        wt,
        () => {
        }
      ));
    }
  }
  /** @private */
  _groupFrozenChanged(e, t) {
    t === void 0 || e === void 0 || e !== !1 && (this.__scheduleAutoFreezeWarning(t, "frozen"), Array.from(t).forEach((r) => {
      r.frozen = e;
    }));
  }
  /** @private */
  _groupFrozenToEndChanged(e, t) {
    t === void 0 || e === void 0 || e !== !1 && (this.__scheduleAutoFreezeWarning(t, "frozenToEnd"), Array.from(t).forEach((r) => {
      r.frozenToEnd = e;
    }));
  }
  /** @private */
  _groupHiddenChanged(e) {
    (e || this.__groupHiddenInitialized) && this._synchronizeHidden(), this.__groupHiddenInitialized = !0;
  }
  /** @private */
  _updateAutoHidden() {
    const e = this._autoHidden;
    this._autoHidden = (this._visibleChildColumns || []).length === 0, (e || this._autoHidden) && (this.hidden = this._autoHidden);
  }
  /** @private */
  _synchronizeHidden() {
    this._childColumns && !this._preventHiddenSynchronization && this._childColumns.forEach((e) => {
      e.hidden = this.hidden;
    });
  }
  /** @private */
  _colSpanChanged(e, t, r) {
    t && (t.setAttribute("colspan", e), this._grid && this._grid._a11yUpdateCellColspan(t, e)), r && (r.setAttribute("colspan", e), this._grid && this._grid._a11yUpdateCellColspan(r, e));
  }
  /**
   * @param {!GridColumnGroup} el
   * @return {!Array<!GridColumn>}
   * @protected
   */
  _getChildColumns(e) {
    return fi.getFlattenedNodes(e).filter(this._isColumnElement);
  }
  /** @private */
  _addNodeObserver() {
    this._observer = new fi(this, (e) => {
      (e.addedNodes.filter(this._isColumnElement).length > 0 || e.removedNodes.filter(this._isColumnElement).length > 0) && (this._preventHiddenSynchronization = !0, this._rootColumns = this._getChildColumns(this), this._childColumns = this._rootColumns, this._updateVisibleChildColumns(this._childColumns), this._preventHiddenSynchronization = !1, this._grid && this._grid._debounceUpdateColumnTree && this._grid._debounceUpdateColumnTree());
    }), this._observer.flush();
  }
  /**
   * @param {!Node} node
   * @return {boolean}
   * @protected
   */
  _isColumnElement(e) {
    return e.nodeType === Node.ELEMENT_NODE && /\bcolumn\b/u.test(e.localName);
  }
}
O(Zv);
C(
  "vaadin-input-container",
  y`
    :host {
      background-color: var(--lumo-contrast-10pct);
      padding: 0 calc(0.375em + var(--_input-container-radius) / 4 - 1px);
      font-weight: 500;
      line-height: 1;
      position: relative;
      cursor: text;
      box-sizing: border-box;
      border-radius:
        /* See https://developer.mozilla.org/en-US/docs/Web/CSS/border-radius#syntax */
        var(--vaadin-input-field-top-start-radius, var(--_input-container-radius))
        var(--vaadin-input-field-top-end-radius, var(--_input-container-radius))
        var(--vaadin-input-field-bottom-end-radius, var(--_input-container-radius))
        var(--vaadin-input-field-bottom-start-radius, var(--_input-container-radius));
      /* Fallback */
      --_input-container-radius: var(--vaadin-input-field-border-radius, var(--lumo-border-radius-m));
      /* Default field border color */
      --_input-border-color: var(--vaadin-input-field-border-color, var(--lumo-contrast-50pct));
    }

    :host([dir='rtl']) {
      border-radius:
        /* Don't use logical props, see https://github.com/vaadin/vaadin-time-picker/issues/145 */
        var(--vaadin-input-field-top-end-radius, var(--_input-container-radius))
        var(--vaadin-input-field-top-start-radius, var(--_input-container-radius))
        var(--vaadin-input-field-bottom-start-radius, var(--_input-container-radius))
        var(--vaadin-input-field-bottom-end-radius, var(--_input-container-radius));
    }

    /* Used for hover and activation effects */
    :host::after {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: inherit;
      pointer-events: none;
      background-color: var(--lumo-contrast-50pct);
      opacity: 0;
      transition: transform 0.15s, opacity 0.2s;
      transform-origin: 100% 0;
    }

    ::slotted(:not([slot$='fix'])) {
      cursor: inherit;
      min-height: var(--lumo-text-field-size, var(--lumo-size-m));
      padding: 0 0.25em;
      --_lumo-text-field-overflow-mask-image: linear-gradient(to left, transparent, #000 1.25em);
      -webkit-mask-image: var(--_lumo-text-field-overflow-mask-image);
      mask-image: var(--_lumo-text-field-overflow-mask-image);
    }

    /* Read-only */
    :host([readonly]) {
      color: var(--lumo-secondary-text-color);
      background-color: transparent;
      cursor: default;
    }

    :host([readonly])::after {
      background-color: transparent;
      opacity: 1;
      border: 1px dashed var(--lumo-contrast-30pct);
    }

    /* Disabled */
    :host([disabled]) {
      background-color: var(--lumo-contrast-5pct);
    }

    :host([disabled]) ::slotted(*) {
      color: var(--lumo-disabled-text-color);
      -webkit-text-fill-color: var(--lumo-disabled-text-color);
    }

    /* Invalid */
    :host([invalid]) {
      background-color: var(--lumo-error-color-10pct);
    }

    :host([invalid])::after {
      background-color: var(--lumo-error-color-50pct);
    }

    /* Slotted icons */
    ::slotted(vaadin-icon) {
      color: var(--lumo-contrast-60pct);
      width: var(--lumo-icon-size-m);
      height: var(--lumo-icon-size-m);
    }

    /* Vaadin icons are based on a 16x16 grid (unlike Lumo and Material icons with 24x24), so they look too big by default */
    ::slotted(vaadin-icon[icon^='vaadin:']) {
      padding: 0.25em;
      box-sizing: border-box !important;
    }

    /* Text align */
    :host([dir='rtl']) ::slotted(:not([slot$='fix'])) {
      --_lumo-text-field-overflow-mask-image: linear-gradient(to right, transparent, #000 1.25em);
    }

    @-moz-document url-prefix() {
      :host([dir='rtl']) ::slotted(:not([slot$='fix'])) {
        mask-image: var(--_lumo-text-field-overflow-mask-image);
      }
    }

    :host([theme~='align-left']) ::slotted(:not([slot$='fix'])) {
      text-align: start;
      --_lumo-text-field-overflow-mask-image: none;
    }

    :host([theme~='align-center']) ::slotted(:not([slot$='fix'])) {
      text-align: center;
      --_lumo-text-field-overflow-mask-image: none;
    }

    :host([theme~='align-right']) ::slotted(:not([slot$='fix'])) {
      text-align: end;
      --_lumo-text-field-overflow-mask-image: none;
    }

    @-moz-document url-prefix() {
      /* Firefox is smart enough to align overflowing text to right */
      :host([theme~='align-right']) ::slotted(:not([slot$='fix'])) {
        --_lumo-text-field-overflow-mask-image: linear-gradient(to right, transparent 0.25em, #000 1.5em);
      }
    }

    @-moz-document url-prefix() {
      /* Firefox is smart enough to align overflowing text to right */
      :host([theme~='align-left']) ::slotted(:not([slot$='fix'])) {
        --_lumo-text-field-overflow-mask-image: linear-gradient(to left, transparent 0.25em, #000 1.5em);
      }
    }

    /* RTL specific styles */
    :host([dir='rtl'])::after {
      transform-origin: 0% 0;
    }

    :host([theme~='align-left'][dir='rtl']) ::slotted(:not([slot$='fix'])) {
      --_lumo-text-field-overflow-mask-image: none;
    }

    :host([theme~='align-center'][dir='rtl']) ::slotted(:not([slot$='fix'])) {
      --_lumo-text-field-overflow-mask-image: none;
    }

    :host([theme~='align-right'][dir='rtl']) ::slotted(:not([slot$='fix'])) {
      --_lumo-text-field-overflow-mask-image: none;
    }

    @-moz-document url-prefix() {
      /* Firefox is smart enough to align overflowing text to right */
      :host([theme~='align-right'][dir='rtl']) ::slotted(:not([slot$='fix'])) {
        --_lumo-text-field-overflow-mask-image: linear-gradient(to right, transparent 0.25em, #000 1.5em);
      }
    }

    @-moz-document url-prefix() {
      /* Firefox is smart enough to align overflowing text to right */
      :host([theme~='align-left'][dir='rtl']) ::slotted(:not([slot$='fix'])) {
        --_lumo-text-field-overflow-mask-image: linear-gradient(to left, transparent 0.25em, #000 1.5em);
      }
    }
  `,
  { moduleId: "lumo-input-container" }
);
/**
 * @license
 * Copyright (c) 2021 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class Kv extends X(Be(N)) {
  static get is() {
    return "vaadin-input-container";
  }
  static get template() {
    return U`
      <style>
        :host {
          display: flex;
          align-items: center;
          flex: 0 1 auto;
          border-radius:
            /* See https://developer.mozilla.org/en-US/docs/Web/CSS/border-radius */
            var(--vaadin-input-field-top-start-radius, var(--__border-radius))
            var(--vaadin-input-field-top-end-radius, var(--__border-radius))
            var(--vaadin-input-field-bottom-end-radius, var(--__border-radius))
            var(--vaadin-input-field-bottom-start-radius, var(--__border-radius));
          --_border-radius: var(--vaadin-input-field-border-radius, 0px);
          --_input-border-width: var(--vaadin-input-field-border-width, 0);
          --_input-border-color: var(--vaadin-input-field-border-color, transparent);
          box-shadow: inset 0 0 0 var(--_input-border-width, 0) var(--_input-border-color);
        }

        :host([dir='rtl']) {
          border-radius:
            /* Don't use logical props, see https://github.com/vaadin/vaadin-time-picker/issues/145 */
            var(--vaadin-input-field-top-end-radius, var(--_border-radius))
            var(--vaadin-input-field-top-start-radius, var(--_border-radius))
            var(--vaadin-input-field-bottom-start-radius, var(--_border-radius))
            var(--vaadin-input-field-bottom-end-radius, var(--_border-radius));
        }

        :host([hidden]) {
          display: none !important;
        }

        /* Reset the native input styles */
        ::slotted(input) {
          -webkit-appearance: none;
          -moz-appearance: none;
          flex: auto;
          white-space: nowrap;
          overflow: hidden;
          width: 100%;
          height: 100%;
          outline: none;
          margin: 0;
          padding: 0;
          border: 0;
          border-radius: 0;
          min-width: 0;
          font: inherit;
          line-height: normal;
          color: inherit;
          background-color: transparent;
          /* Disable default invalid style in Firefox */
          box-shadow: none;
        }

        ::slotted(*) {
          flex: none;
        }

        ::slotted(:is(input, textarea))::placeholder {
          /* Use ::slotted(input:placeholder-shown) in themes to style the placeholder. */
          /* because ::slotted(...)::placeholder does not work in Safari. */
          font: inherit;
          color: inherit;
          /* Override default opacity in Firefox */
          opacity: 1;
        }
      </style>
      <slot name="prefix"></slot>
      <slot></slot>
      <slot name="suffix"></slot>
    `;
  }
  static get properties() {
    return {
      /**
       * If true, the user cannot interact with this element.
       */
      disabled: {
        type: Boolean,
        reflectToAttribute: !0
      },
      /**
       * Set to true to make this element read-only.
       */
      readonly: {
        type: Boolean,
        reflectToAttribute: !0
      },
      /**
       * Set to true when the element is invalid.
       */
      invalid: {
        type: Boolean,
        reflectToAttribute: !0
      }
    };
  }
  /** @protected */
  ready() {
    super.ready(), this.addEventListener("pointerdown", (e) => {
      e.target === this && e.preventDefault();
    }), this.addEventListener("click", (e) => {
      e.target === this && this.shadowRoot.querySelector("slot:not([name])").assignedNodes({ flatten: !0 }).forEach((t) => t.focus && t.focus());
    });
  }
}
O(Kv);
/**
 * @license
 * Copyright (c) 2017 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const rf = y`
  [part$='button'] {
    flex: none;
    width: 1em;
    height: 1em;
    line-height: 1;
    font-size: var(--lumo-icon-size-m);
    text-align: center;
    color: var(--lumo-contrast-60pct);
    transition: 0.2s color;
    cursor: var(--lumo-clickable-cursor);
  }

  [part$='button']:hover {
    color: var(--lumo-contrast-90pct);
  }

  :host([disabled]) [part$='button'],
  :host([readonly]) [part$='button'] {
    color: var(--lumo-contrast-20pct);
    cursor: default;
  }

  [part$='button']::before {
    font-family: 'lumo-icons';
    display: block;
  }
`;
C("", rf, { moduleId: "lumo-field-button" });
/**
 * @license
 * Copyright (c) 2017 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const qa = y`
  :host([has-helper]) [part='helper-text']::before {
    content: '';
    display: block;
    height: 0.4em;
  }

  [part='helper-text'] {
    display: block;
    color: var(--lumo-secondary-text-color);
    font-size: var(--lumo-font-size-xs);
    line-height: var(--lumo-line-height-xs);
    margin-left: calc(var(--lumo-border-radius-m) / 4);
    transition: color 0.2s;
  }

  :host(:hover:not([readonly])) [part='helper-text'] {
    color: var(--lumo-body-text-color);
  }

  :host([disabled]) [part='helper-text'] {
    color: var(--lumo-disabled-text-color);
    -webkit-text-fill-color: var(--lumo-disabled-text-color);
  }

  :host([has-helper][theme~='helper-above-field']) [part='helper-text']::before {
    display: none;
  }

  :host([has-helper][theme~='helper-above-field']) [part='helper-text']::after {
    content: '';
    display: block;
    height: 0.4em;
  }

  :host([has-helper][theme~='helper-above-field']) [part='label'] {
    order: 0;
    padding-bottom: 0.4em;
  }

  :host([has-helper][theme~='helper-above-field']) [part='helper-text'] {
    order: 1;
  }

  :host([has-helper][theme~='helper-above-field']) [part='label'] + * {
    order: 2;
  }

  :host([has-helper][theme~='helper-above-field']) [part='error-message'] {
    order: 3;
  }
`;
/**
 * @license
 * Copyright (c) 2017 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const go = y`
  [part='label'] {
    align-self: flex-start;
    color: var(--lumo-secondary-text-color);
    font-weight: 500;
    font-size: var(--lumo-font-size-s);
    margin-left: calc(var(--lumo-border-radius-m) / 4);
    transition: color 0.2s;
    line-height: 1;
    padding-right: 1em;
    padding-bottom: 0.5em;
    /* As a workaround for diacritics being cut off, add a top padding and a 
    negative margin to compensate */
    padding-top: 0.25em;
    margin-top: -0.25em;
    overflow: hidden;
    white-space: nowrap;
    text-overflow: ellipsis;
    position: relative;
    max-width: 100%;
    box-sizing: border-box;
  }

  :host([has-label])::before {
    margin-top: calc(var(--lumo-font-size-s) * 1.5);
  }

  :host([has-label][theme~='small'])::before {
    margin-top: calc(var(--lumo-font-size-xs) * 1.5);
  }

  :host([has-label]) {
    padding-top: var(--lumo-space-m);
  }

  :host([has-label]) ::slotted([slot='tooltip']) {
    --vaadin-tooltip-offset-bottom: calc((var(--lumo-space-m) - var(--lumo-space-xs)) * -1);
  }

  :host([required]) [part='required-indicator']::after {
    content: var(--lumo-required-field-indicator, '\\2022');
    transition: opacity 0.2s;
    color: var(--lumo-required-field-indicator-color, var(--lumo-primary-text-color));
    position: absolute;
    right: 0;
    width: 1em;
    text-align: center;
  }

  :host([invalid]) [part='required-indicator']::after {
    color: var(--lumo-required-field-indicator-color, var(--lumo-error-text-color));
  }

  [part='error-message'] {
    margin-left: calc(var(--lumo-border-radius-m) / 4);
    font-size: var(--lumo-font-size-xs);
    line-height: var(--lumo-line-height-xs);
    color: var(--lumo-error-text-color);
    will-change: max-height;
    transition: 0.4s max-height;
    max-height: 5em;
  }

  :host([has-error-message]) [part='error-message']::before,
  :host([has-error-message]) [part='error-message']::after {
    content: '';
    display: block;
    height: 0.4em;
  }

  :host(:not([invalid])) [part='error-message'] {
    max-height: 0;
    overflow: hidden;
  }

  /* RTL specific styles */

  :host([dir='rtl']) [part='label'] {
    margin-left: 0;
    margin-right: calc(var(--lumo-border-radius-m) / 4);
  }

  :host([dir='rtl']) [part='label'] {
    padding-left: 1em;
    padding-right: 0;
  }

  :host([dir='rtl']) [part='required-indicator']::after {
    right: auto;
    left: 0;
  }

  :host([dir='rtl']) [part='error-message'] {
    margin-left: 0;
    margin-right: calc(var(--lumo-border-radius-m) / 4);
  }
`;
C("", go, { moduleId: "lumo-required-field" });
/**
 * @license
 * Copyright (c) 2017 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Qv = y`
  :host {
    --lumo-text-field-size: var(--lumo-size-m);
    color: var(--lumo-body-text-color);
    font-size: var(--lumo-font-size-m);
    font-family: var(--lumo-font-family);
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    -webkit-tap-highlight-color: transparent;
    padding: var(--lumo-space-xs) 0;
  }

  :host::before {
    height: var(--lumo-text-field-size);
    box-sizing: border-box;
    display: inline-flex;
    align-items: center;
  }

  :host([focused]:not([readonly])) [part='label'] {
    color: var(--lumo-primary-text-color);
  }

  :host([focused]) [part='input-field'] ::slotted(:is(input, textarea)) {
    -webkit-mask-image: none;
    mask-image: none;
  }

  ::slotted(:is(input, textarea):placeholder-shown) {
    color: var(--lumo-secondary-text-color);
  }

  /* Hover */
  :host(:hover:not([readonly]):not([focused])) [part='label'] {
    color: var(--lumo-body-text-color);
  }

  :host(:hover:not([readonly]):not([focused])) [part='input-field']::after {
    opacity: 0.1;
  }

  /* Touch device adjustment */
  @media (pointer: coarse) {
    :host(:hover:not([readonly]):not([focused])) [part='label'] {
      color: var(--lumo-secondary-text-color);
    }

    :host(:hover:not([readonly]):not([focused])) [part='input-field']::after {
      opacity: 0;
    }

    :host(:active:not([readonly]):not([focused])) [part='input-field']::after {
      opacity: 0.2;
    }
  }

  /* Trigger when not focusing using the keyboard */
  :host([focused]:not([focus-ring]):not([readonly])) [part='input-field']::after {
    transform: scaleX(0);
    transition-duration: 0.15s, 1s;
  }

  /* Focus-ring */
  :host([focus-ring]) [part='input-field'] {
    box-shadow: 0 0 0 2px var(--lumo-primary-color-50pct);
  }

  /* Read-only and disabled */
  :host(:is([readonly], [disabled])) ::slotted(:is(input, textarea):placeholder-shown) {
    opacity: 0;
  }

  /* Read-only style */
  :host([readonly]) {
    --vaadin-input-field-border-color: transparent;
  }

  /* Disabled style */
  :host([disabled]) {
    pointer-events: none;
    --vaadin-input-field-border-color: var(--lumo-contrast-20pct);
  }

  :host([disabled]) [part='label'],
  :host([disabled]) [part='input-field'] ::slotted(*) {
    color: var(--lumo-disabled-text-color);
    -webkit-text-fill-color: var(--lumo-disabled-text-color);
  }

  /* Invalid style */
  :host([invalid]) {
    --vaadin-input-field-border-color: var(--lumo-error-color);
  }

  :host([invalid][focus-ring]) [part='input-field'] {
    box-shadow: 0 0 0 2px var(--lumo-error-color-50pct);
  }

  :host([input-prevented]) [part='input-field'] {
    animation: shake 0.15s infinite;
  }

  @keyframes shake {
    25% {
      transform: translateX(4px);
    }
    75% {
      transform: translateX(-4px);
    }
  }

  /* Small theme */
  :host([theme~='small']) {
    font-size: var(--lumo-font-size-s);
    --lumo-text-field-size: var(--lumo-size-s);
  }

  :host([theme~='small']) [part='label'] {
    font-size: var(--lumo-font-size-xs);
  }

  :host([theme~='small']) [part='error-message'] {
    font-size: var(--lumo-font-size-xxs);
  }

  /* Slotted content */
  [part='input-field'] ::slotted(:not(vaadin-icon):not(input):not(textarea)) {
    color: var(--lumo-secondary-text-color);
    font-weight: 400;
  }

  [part='clear-button']::before {
    content: var(--lumo-icons-cross);
  }
`, Wi = [go, rf, qa, Qv];
C("", Wi, {
  moduleId: "lumo-input-field-shared-styles"
});
/**
 * @license
 * Copyright (c) 2017 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
C("vaadin-text-field", Wi, {
  moduleId: "lumo-text-field-styles"
});
/**
 * @license
 * Copyright (c) 2021 - 2023 Vaadin Ltd..
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Jv = y`
  [part='clear-button'] {
    display: none;
    cursor: default;
  }

  [part='clear-button']::before {
    content: '\\2715';
  }

  :host([clear-button-visible][has-value]:not([disabled]):not([readonly])) [part='clear-button'] {
    display: block;
  }
`;
/**
 * @license
 * Copyright (c) 2021 - 2023 Vaadin Ltd..
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Xv = y`
  :host {
    display: inline-flex;
    outline: none;
  }

  :host::before {
    content: '\\2003';
    width: 0;
    display: inline-block;
    /* Size and position this element on the same vertical position as the input-field element
          to make vertical align for the host element work as expected */
  }

  :host([hidden]) {
    display: none !important;
  }

  :host(:not([has-label])) [part='label'] {
    display: none;
  }

  @media (forced-colors: active) {
    :host(:not([readonly])) [part='input-field'] {
      outline: 1px solid;
      outline-offset: -1px;
    }
    :host([focused]) [part='input-field'] {
      outline-width: 2px;
    }
    :host([disabled]) [part='input-field'] {
      outline-color: GrayText;
    }
  }
`;
/**
 * @license
 * Copyright (c) 2021 - 2023 Vaadin Ltd..
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const e0 = y`
  [class$='container'] {
    display: flex;
    flex-direction: column;
    min-width: 100%;
    max-width: 100%;
    width: var(--vaadin-field-default-width, 12em);
  }
`;
/**
 * @license
 * Copyright (c) 2021 - 2023 Vaadin Ltd..
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const ji = [Xv, e0, Jv];
/**
 * @license
 * Copyright (c) 2021 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const rn = /* @__PURE__ */ new WeakMap();
function t0(i) {
  return rn.has(i) || rn.set(i, /* @__PURE__ */ new Set()), rn.get(i);
}
function r0(i, e) {
  const t = document.createElement("style");
  t.textContent = i, e === document ? document.head.appendChild(t) : e.insertBefore(t, e.firstChild);
}
const i0 = Y(
  (i) => class extends i {
    /**
     * List of styles to insert into root.
     * @protected
     */
    get slotStyles() {
      return {};
    }
    /** @protected */
    connectedCallback() {
      super.connectedCallback(), this.__applySlotStyles();
    }
    /** @private */
    __applySlotStyles() {
      const t = this.getRootNode(), r = t0(t);
      this.slotStyles.forEach((s) => {
        r.has(s) || (r0(s, t), r.add(s));
      });
    }
  }
);
/**
 * @license
 * Copyright (c) 2021 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const s0 = (i) => class extends ho(Vi(i)) {
  static get properties() {
    return {
      /**
       * Set to true to display the clear icon which clears the input.
       *
       * It is up to the component to choose where to place the clear icon:
       * in the Shadow DOM or in the light DOM. In any way, a reference to
       * the clear icon element should be provided via the `clearElement` getter.
       *
       * @attr {boolean} clear-button-visible
       */
      clearButtonVisible: {
        type: Boolean,
        reflectToAttribute: !0,
        value: !1
      }
    };
  }
  /**
   * Any element extending this mixin is required to implement this getter.
   * It returns the reference to the clear button element.
   *
   * @protected
   * @return {Element | null | undefined}
   */
  get clearElement() {
    return null;
  }
  /** @protected */
  ready() {
    super.ready(), this.clearElement && (this.clearElement.addEventListener("mousedown", (t) => this._onClearButtonMouseDown(t)), this.clearElement.addEventListener("click", (t) => this._onClearButtonClick(t)));
  }
  /**
   * @param {Event} event
   * @protected
   */
  _onClearButtonClick(t) {
    t.preventDefault(), this._onClearAction();
  }
  /**
   * @param {MouseEvent} event
   * @protected
   */
  _onClearButtonMouseDown(t) {
    t.preventDefault(), Ii || this.inputElement.focus();
  }
  /**
   * Override an event listener inherited from `KeydownMixin` to clear on Esc.
   * Components that extend this mixin can prevent this behavior by overriding
   * this method without calling `super._onEscape` to provide custom logic.
   *
   * @param {KeyboardEvent} event
   * @protected
   * @override
   */
  _onEscape(t) {
    super._onEscape(t), this.clearButtonVisible && this.value && (t.stopPropagation(), this._onClearAction());
  }
  /**
   * Clears the value and dispatches `input` and `change` events
   * on the input element. This method should be called
   * when the clear action originates from the user.
   *
   * @protected
   */
  _onClearAction() {
    this.clear(), this.inputElement.dispatchEvent(new Event("input", { bubbles: !0, composed: !0 })), this.inputElement.dispatchEvent(new Event("change", { bubbles: !0 }));
  }
};
/**
 * @license
 * Copyright (c) 2021 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class o0 extends Va {
  constructor(e) {
    super(e, "error-message", "div");
  }
  /**
   * Set the error message element text content.
   *
   * @param {string} errorMessage
   */
  setErrorMessage(e) {
    this.errorMessage = e, this.updateDefaultNode(this.node);
  }
  /**
   * Set invalid state for detecting whether to show error message.
   *
   * @param {boolean} invalid
   */
  setInvalid(e) {
    this.invalid = e, this.updateDefaultNode(this.node);
  }
  /**
   * Override method inherited from `SlotController` to not run
   * initializer on the custom slotted node unnecessarily.
   *
   * @param {Node} node
   * @protected
   * @override
   */
  initAddedNode(e) {
    e !== this.defaultNode && this.initCustomNode(e);
  }
  /**
   * Override to initialize the newly added default error message.
   *
   * @param {Node} errorNode
   * @protected
   * @override
   */
  initNode(e) {
    this.updateDefaultNode(e);
  }
  /**
   * Override to initialize the newly added custom error message.
   *
   * @param {Node} errorNode
   * @protected
   * @override
   */
  initCustomNode(e) {
    e.textContent && !this.errorMessage && (this.errorMessage = e.textContent.trim()), super.initCustomNode(e);
  }
  /**
   * Override method inherited from `SlotChildObserveController`
   * to restore the default error message element.
   *
   * @protected
   * @override
   */
  restoreDefaultNode() {
    this.attachDefaultNode();
  }
  /**
   * Override method inherited from `SlotChildObserveController`
   * to update the error message text and hidden state.
   *
   * Note: unlike with other controllers, this method is
   * called for both default and custom error message.
   *
   * @param {Node | undefined} node
   * @protected
   * @override
   */
  updateDefaultNode(e) {
    const { errorMessage: t, invalid: r } = this, s = !!(r && t && t.trim() !== "");
    e && (e.textContent = s ? t : "", e.hidden = !s, s ? e.setAttribute("role", "alert") : e.removeAttribute("role")), super.updateDefaultNode(e);
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class n0 extends Va {
  constructor(e) {
    super(e, "helper", null);
  }
  /**
   * Set helper text based on corresponding host property.
   *
   * @param {string} helperText
   */
  setHelperText(e) {
    this.helperText = e, this.getSlotChild() || this.restoreDefaultNode(), this.node === this.defaultNode && this.updateDefaultNode(this.node);
  }
  /**
   * Override method inherited from `SlotChildObserveController`
   * to create the default helper element lazily as needed.
   *
   * @param {Node | undefined} node
   * @protected
   * @override
   */
  restoreDefaultNode() {
    const { helperText: e } = this;
    if (e && e.trim() !== "") {
      this.tagName = "div";
      const t = this.attachDefaultNode();
      this.observeNode(t);
    }
  }
  /**
   * Override method inherited from `SlotChildObserveController`
   * to update the default helper element text content.
   *
   * @param {Node | undefined} node
   * @protected
   * @override
   */
  updateDefaultNode(e) {
    e && (e.textContent = this.helperText), super.updateDefaultNode(e);
  }
  /**
   * Override to observe the newly added custom node.
   *
   * @param {Node} node
   * @protected
   * @override
   */
  initCustomNode(e) {
    super.initCustomNode(e), this.observeNode(e);
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Wa = Y(
  (i) => class extends i {
    static get properties() {
      return {
        /**
         * Set to true when the field is invalid.
         */
        invalid: {
          type: Boolean,
          reflectToAttribute: !0,
          notify: !0,
          value: !1
        },
        /**
         * Specifies that the user must fill in a value.
         */
        required: {
          type: Boolean,
          reflectToAttribute: !0
        }
      };
    }
    /**
     * Validates the field and sets the `invalid` property based on the result.
     *
     * The method fires a `validated` event with the result of the validation.
     *
     * @return {boolean} True if the value is valid.
     */
    validate() {
      const t = this.checkValidity();
      return this._setInvalid(!t), this.dispatchEvent(new CustomEvent("validated", { detail: { valid: t } })), t;
    }
    /**
     * Returns true if the field value satisfies all constraints (if any).
     *
     * @return {boolean}
     */
    checkValidity() {
      return !this.required || !!this.value;
    }
    /**
     * @param {boolean} invalid
     * @protected
     */
    _setInvalid(t) {
      this._shouldSetInvalid(t) && (this.invalid = t);
    }
    /**
     * Override this method to define whether the given `invalid` state should be set.
     *
     * @param {boolean} _invalid
     * @return {boolean}
     * @protected
     */
    _shouldSetInvalid(t) {
      return !0;
    }
    /**
     * Fired whenever the field is validated.
     *
     * @event validated
     * @param {Object} detail
     * @param {boolean} detail.valid the result of the validation.
     */
  }
);
/**
 * @license
 * Copyright (c) 2021 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const sf = (i) => class extends Wa(Bh(rt(i))) {
  static get properties() {
    return {
      /**
       * A target element to which ARIA attributes are set.
       * @protected
       */
      ariaTarget: {
        type: Object,
        observer: "_ariaTargetChanged"
      },
      /**
       * Error to show when the field is invalid.
       *
       * @attr {string} error-message
       */
      errorMessage: {
        type: String,
        observer: "_errorMessageChanged"
      },
      /**
       * String used for the helper text.
       * @attr {string} helper-text
       */
      helperText: {
        type: String,
        observer: "_helperTextChanged"
      },
      /**
       * String used to label the component to screen reader users.
       * @attr {string} accessible-name
       */
      accessibleName: {
        type: String,
        observer: "_accessibleNameChanged"
      },
      /**
       * Id of the element used as label of the component to screen reader users.
       * @attr {string} accessible-name-ref
       */
      accessibleNameRef: {
        type: String,
        observer: "_accessibleNameRefChanged"
      }
    };
  }
  static get observers() {
    return ["_invalidChanged(invalid)", "_requiredChanged(required)"];
  }
  constructor() {
    super(), this._fieldAriaController = new Lv(this), this._helperController = new n0(this), this._errorController = new o0(this), this._errorController.addEventListener("slot-content-changed", (t) => {
      this.toggleAttribute("has-error-message", t.detail.hasContent);
    }), this._labelController.addEventListener("slot-content-changed", (t) => {
      const { hasContent: r, node: s } = t.detail;
      this.__labelChanged(r, s);
    }), this._helperController.addEventListener("slot-content-changed", (t) => {
      const { hasContent: r, node: s } = t.detail;
      this.toggleAttribute("has-helper", r), this.__helperChanged(r, s);
    });
  }
  /**
   * @protected
   * @return {HTMLElement}
   */
  get _errorNode() {
    return this._errorController.node;
  }
  /**
   * @protected
   * @return {HTMLElement}
   */
  get _helperNode() {
    return this._helperController.node;
  }
  /** @protected */
  ready() {
    super.ready(), this.addController(this._fieldAriaController), this.addController(this._helperController), this.addController(this._errorController);
  }
  /** @private */
  __helperChanged(t, r) {
    t ? this._fieldAriaController.setHelperId(r.id) : this._fieldAriaController.setHelperId(null);
  }
  /** @protected */
  _accessibleNameChanged(t) {
    this._fieldAriaController.setAriaLabel(t);
  }
  /** @protected */
  _accessibleNameRefChanged(t) {
    this._fieldAriaController.setLabelId(t, !0);
  }
  /** @private */
  __labelChanged(t, r) {
    t ? this._fieldAriaController.setLabelId(r.id) : this._fieldAriaController.setLabelId(null);
  }
  /**
   * @param {string | null | undefined} errorMessage
   * @protected
   */
  _errorMessageChanged(t) {
    this._errorController.setErrorMessage(t);
  }
  /**
   * @param {string} helperText
   * @protected
   */
  _helperTextChanged(t) {
    this._helperController.setHelperText(t);
  }
  /**
   * @param {HTMLElement | null | undefined} target
   * @protected
   */
  _ariaTargetChanged(t) {
    t && this._fieldAriaController.setTarget(t);
  }
  /**
   * @param {boolean} required
   * @protected
   */
  _requiredChanged(t) {
    this._fieldAriaController.setRequired(t);
  }
  /**
   * @param {boolean} invalid
   * @protected
   */
  _invalidChanged(t) {
    this._errorController.setInvalid(t), setTimeout(() => {
      if (t) {
        const r = this._errorNode;
        this._fieldAriaController.setErrorId(r && r.id);
      } else
        this._fieldAriaController.setErrorId(null);
    });
  }
};
/**
 * @license
 * Copyright (c) 2021 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const ja = Y(
  (i) => class extends Hh(Wa(ho(i))) {
    /**
     * An array of attributes which participate in the input validation.
     * Changing these attributes will cause the input to re-validate.
     *
     * IMPORTANT: The attributes should be properly delegated to the input element
     * from the host using `delegateAttrs` getter (see `DelegateStateMixin`).
     * The `required` attribute is already delegated.
     */
    static get constraints() {
      return ["required"];
    }
    static get delegateAttrs() {
      return [...super.delegateAttrs, "required"];
    }
    /** @protected */
    ready() {
      super.ready(), this._createConstraintsObserver();
    }
    /**
     * Returns true if the current input value satisfies all constraints (if any).
     * @return {boolean}
     */
    checkValidity() {
      return this.inputElement && this._hasValidConstraints(this.constructor.constraints.map((t) => this[t])) ? this.inputElement.checkValidity() : !this.invalid;
    }
    /**
     * Returns true if some of the provided set of constraints are valid.
     * @param {Array} constraints
     * @return {boolean}
     * @protected
     */
    _hasValidConstraints(t) {
      return t.some((r) => this.__isValidConstraint(r));
    }
    /**
     * Override this method to customize setting up constraints observer.
     * @protected
     */
    _createConstraintsObserver() {
      this._createMethodObserver(`_constraintsChanged(stateTarget, ${this.constructor.constraints.join(", ")})`);
    }
    /**
     * Override this method to implement custom validation constraints.
     * @param {HTMLElement | undefined} stateTarget
     * @param {unknown[]} constraints
     * @protected
     */
    _constraintsChanged(t, ...r) {
      if (!t)
        return;
      const s = this._hasValidConstraints(r), o = this.__previousHasConstraints && !s;
      (this._hasValue || this.invalid) && s ? this.validate() : o && this._setInvalid(!1), this.__previousHasConstraints = s;
    }
    /**
     * Override an event listener inherited from `InputMixin`
     * to capture native `change` event and make sure that
     * a new one is dispatched after validation runs.
     * @param {Event} event
     * @protected
     * @override
     */
    _onChange(t) {
      t.stopPropagation(), this.validate(), this.dispatchEvent(
        new CustomEvent("change", {
          detail: {
            sourceEvent: t
          },
          bubbles: t.bubbles,
          cancelable: t.cancelable
        })
      );
    }
    /** @private */
    __isValidConstraint(t) {
      return !!t || t === 0;
    }
  }
);
/**
 * @license
 * Copyright (c) 2021 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const _o = (i) => class extends i0(
  La(ja(sf(s0(Vi(i)))))
) {
  static get properties() {
    return {
      /**
       * A pattern matched against individual characters the user inputs.
       *
       * When set, the field will prevent:
       * - `keydown` events if the entered key doesn't match `/^allowedCharPattern$/`
       * - `paste` events if the pasted text doesn't match `/^allowedCharPattern*$/`
       * - `drop` events if the dropped text doesn't match `/^allowedCharPattern*$/`
       *
       * For example, to allow entering only numbers and minus signs, use:
       * `allowedCharPattern = "[\\d-]"`
       * @attr {string} allowed-char-pattern
       */
      allowedCharPattern: {
        type: String,
        observer: "_allowedCharPatternChanged"
      },
      /**
       * If true, the input text gets fully selected when the field is focused using click or touch / tap.
       */
      autoselect: {
        type: Boolean,
        value: !1
      },
      /**
       * The name of this field.
       */
      name: {
        type: String,
        reflectToAttribute: !0
      },
      /**
       * A hint to the user of what can be entered in the field.
       */
      placeholder: {
        type: String,
        reflectToAttribute: !0
      },
      /**
       * When present, it specifies that the field is read-only.
       */
      readonly: {
        type: Boolean,
        value: !1,
        reflectToAttribute: !0
      },
      /**
       * The text usually displayed in a tooltip popup when the mouse is over the field.
       */
      title: {
        type: String,
        reflectToAttribute: !0
      }
    };
  }
  static get delegateAttrs() {
    return [...super.delegateAttrs, "name", "type", "placeholder", "readonly", "invalid", "title"];
  }
  constructor() {
    super(), this._boundOnPaste = this._onPaste.bind(this), this._boundOnDrop = this._onDrop.bind(this), this._boundOnBeforeInput = this._onBeforeInput.bind(this);
  }
  /** @protected */
  get slotStyles() {
    return [
      `
          :is(input[slot='input'], textarea[slot='textarea'])::placeholder {
            font: inherit;
            color: inherit;
          }
        `
    ];
  }
  /**
   * Override an event listener from `DelegateFocusMixin`.
   * @param {FocusEvent} event
   * @protected
   * @override
   */
  _onFocus(t) {
    super._onFocus(t), this.autoselect && this.inputElement && this.inputElement.select();
  }
  /**
   * Override an event listener inherited from `InputMixin`
   * to capture native `change` event and make sure that
   * a new one is dispatched after validation runs.
   * @param {Event} event
   * @protected
   * @override
   */
  _onChange(t) {
    t.stopPropagation(), this.validate(), this.dispatchEvent(
      new CustomEvent("change", {
        detail: {
          sourceEvent: t
        },
        bubbles: t.bubbles,
        cancelable: t.cancelable
      })
    );
  }
  /**
   * Override a method from `InputMixin`.
   * @param {!HTMLElement} input
   * @protected
   * @override
   */
  _addInputListeners(t) {
    super._addInputListeners(t), t.addEventListener("paste", this._boundOnPaste), t.addEventListener("drop", this._boundOnDrop), t.addEventListener("beforeinput", this._boundOnBeforeInput);
  }
  /**
   * Override a method from `InputMixin`.
   * @param {!HTMLElement} input
   * @protected
   * @override
   */
  _removeInputListeners(t) {
    super._removeInputListeners(t), t.removeEventListener("paste", this._boundOnPaste), t.removeEventListener("drop", this._boundOnDrop), t.removeEventListener("beforeinput", this._boundOnBeforeInput);
  }
  /**
   * Override an event listener from `KeyboardMixin`.
   * @param {!KeyboardEvent} event
   * @protected
   * @override
   */
  _onKeyDown(t) {
    super._onKeyDown(t), this.allowedCharPattern && !this.__shouldAcceptKey(t) && (t.preventDefault(), this._markInputPrevented());
  }
  /** @protected */
  _markInputPrevented() {
    this.setAttribute("input-prevented", ""), this._preventInputDebouncer = R.debounce(this._preventInputDebouncer, _e.after(200), () => {
      this.removeAttribute("input-prevented");
    });
  }
  /** @private */
  __shouldAcceptKey(t) {
    return t.metaKey || t.ctrlKey || !t.key || // Allow typing anything if event.key is not supported
    t.key.length !== 1 || // Allow "Backspace", "ArrowLeft" etc.
    this.__allowedCharRegExp.test(t.key);
  }
  /** @private */
  _onPaste(t) {
    if (this.allowedCharPattern) {
      const r = t.clipboardData.getData("text");
      this.__allowedTextRegExp.test(r) || (t.preventDefault(), this._markInputPrevented());
    }
  }
  /** @private */
  _onDrop(t) {
    if (this.allowedCharPattern) {
      const r = t.dataTransfer.getData("text");
      this.__allowedTextRegExp.test(r) || (t.preventDefault(), this._markInputPrevented());
    }
  }
  /** @private */
  _onBeforeInput(t) {
    this.allowedCharPattern && t.data && !this.__allowedTextRegExp.test(t.data) && (t.preventDefault(), this._markInputPrevented());
  }
  /** @private */
  _allowedCharPatternChanged(t) {
    if (t)
      try {
        this.__allowedCharRegExp = new RegExp(`^${t}$`, "u"), this.__allowedTextRegExp = new RegExp(`^${t}*$`, "u");
      } catch {
      }
  }
  /**
   * Fired when the user commits a value change.
   *
   * @event change
   */
  /**
   * Fired when the value is changed by the user: on every typing keystroke,
   * and the value is cleared using the clear button.
   *
   * @event input
   */
};
/**
 * @license
 * Copyright (c) 2021 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const a0 = (i) => class extends _o(i) {
  static get properties() {
    return {
      /**
       * Whether the value of the control can be automatically completed by the browser.
       * List of available options at:
       * https://developer.mozilla.org/en/docs/Web/HTML/Element/input#attr-autocomplete
       */
      autocomplete: {
        type: String
      },
      /**
       * This is a property supported by Safari that is used to control whether
       * autocorrection should be enabled when the user is entering/editing the text.
       * Possible values are:
       * on: Enable autocorrection.
       * off: Disable autocorrection.
       */
      autocorrect: {
        type: String
      },
      /**
       * This is a property supported by Safari and Chrome that is used to control whether
       * autocapitalization should be enabled when the user is entering/editing the text.
       * Possible values are:
       * characters: Characters capitalization.
       * words: Words capitalization.
       * sentences: Sentences capitalization.
       * none: No capitalization.
       */
      autocapitalize: {
        type: String,
        reflectToAttribute: !0
      }
    };
  }
  static get delegateAttrs() {
    return [...super.delegateAttrs, "autocapitalize", "autocomplete", "autocorrect"];
  }
  // Workaround for https://github.com/Polymer/polymer/issues/5259
  get __data() {
    return this.__dataValue || {};
  }
  set __data(t) {
    this.__dataValue = t;
  }
  /**
   * @param {HTMLElement} input
   * @protected
   * @override
   */
  _inputElementChanged(t) {
    super._inputElementChanged(t), t && (t.value && t.value !== this.value && (t.value = ""), this.value && (t.value = this.value));
  }
  /**
   * Override an event listener from `FocusMixin`.
   * @param {boolean} focused
   * @protected
   * @override
   */
  _setFocused(t) {
    super._setFocused(t), !t && document.hasFocus() && this.validate();
  }
  /**
   * Override an event listener from `InputMixin`
   * to mark as valid after user started typing.
   * @param {Event} event
   * @protected
   * @override
   */
  _onInput(t) {
    super._onInput(t), this.invalid && this.validate();
  }
  /**
   * Override an observer from `InputMixin` to validate the field
   * when a new value is set programmatically.
   *
   * @param {string | undefined} newValue
   * @param {string | undefined} oldValue
   * @protected
   * @override
   */
  _valueChanged(t, r) {
    super._valueChanged(t, r), r !== void 0 && this.invalid && this.validate();
  }
};
/**
 * @license
 * Copyright (c) 2021 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const l0 = (i) => class extends a0(i) {
  static get properties() {
    return {
      /**
       * Maximum number of characters (in Unicode code points) that the user can enter.
       */
      maxlength: {
        type: Number
      },
      /**
       * Minimum number of characters (in Unicode code points) that the user can enter.
       */
      minlength: {
        type: Number
      },
      /**
       * A regular expression that the value is checked against.
       * The pattern must match the entire value, not just some subset.
       */
      pattern: {
        type: String
      }
    };
  }
  static get delegateAttrs() {
    return [...super.delegateAttrs, "maxlength", "minlength", "pattern"];
  }
  static get constraints() {
    return [...super.constraints, "maxlength", "minlength", "pattern"];
  }
  constructor() {
    super(), this._setType("text");
  }
  /** @protected */
  get clearElement() {
    return this.$.clearButton;
  }
  /** @protected */
  ready() {
    super.ready(), this.addController(
      new Bi(this, (t) => {
        this._setInputElement(t), this._setFocusElement(t), this.stateTarget = t, this.ariaTarget = t;
      })
    ), this.addController(new Ui(this.inputElement, this._labelController));
  }
};
/**
 * @license
 * Copyright (c) 2017 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
C("vaadin-text-field", ji, { moduleId: "vaadin-text-field-styles" });
class c0 extends l0(X(At(N))) {
  static get is() {
    return "vaadin-text-field";
  }
  static get template() {
    return U`
      <style>
        [part='input-field'] {
          flex-grow: 0;
        }
      </style>

      <div class="vaadin-field-container">
        <div part="label">
          <slot name="label"></slot>
          <span part="required-indicator" aria-hidden="true" on-click="focus"></span>
        </div>

        <vaadin-input-container
          part="input-field"
          readonly="[[readonly]]"
          disabled="[[disabled]]"
          invalid="[[invalid]]"
          theme$="[[_theme]]"
        >
          <slot name="prefix" slot="prefix"></slot>
          <slot name="input"></slot>
          <slot name="suffix" slot="suffix"></slot>
          <div id="clearButton" part="clear-button" slot="suffix" aria-hidden="true"></div>
        </vaadin-input-container>

        <div part="helper-text">
          <slot name="helper"></slot>
        </div>

        <div part="error-message">
          <slot name="error-message"></slot>
        </div>
      </div>
      <slot name="tooltip"></slot>
    `;
  }
  static get properties() {
    return {
      /**
       * Maximum number of characters (in Unicode code points) that the user can enter.
       */
      maxlength: {
        type: Number
      },
      /**
       * Minimum number of characters (in Unicode code points) that the user can enter.
       */
      minlength: {
        type: Number
      }
    };
  }
  /** @protected */
  ready() {
    super.ready(), this._tooltipController = new Et(this), this._tooltipController.setPosition("top"), this._tooltipController.setAriaTarget(this.inputElement), this.addController(this._tooltipController);
  }
}
O(c0);
/**
 * @license
 * Copyright (c) 2016 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class d0 extends rt(N) {
  static get template() {
    return U`
      <style>
        :host {
          display: inline-flex;
          max-width: 100%;
        }

        ::slotted(*) {
          width: 100%;
          box-sizing: border-box;
        }
      </style>
      <slot></slot>
    `;
  }
  static get is() {
    return "vaadin-grid-filter";
  }
  static get properties() {
    return {
      /**
       * JS Path of the property in the item used for filtering the data.
       */
      path: String,
      /**
       * Current filter value.
       */
      value: {
        type: String,
        notify: !0
      },
      /** @private */
      _textField: {
        type: Object
      }
    };
  }
  static get observers() {
    return ["_filterChanged(path, value, _textField)"];
  }
  /** @protected */
  ready() {
    super.ready(), this._filterController = new Ke(this, "", "vaadin-text-field", {
      initializer: (e) => {
        e.addEventListener("value-changed", (t) => {
          this.value = t.detail.value;
        }), this._textField = e;
      }
    }), this.addController(this._filterController);
  }
  /** @private */
  _filterChanged(e, t, r) {
    e === void 0 || t === void 0 || !r || this._previousValue === void 0 && t === "" || (r.value = t, this._previousValue = t, this._debouncerFilterChanged = R.debounce(this._debouncerFilterChanged, _e.after(200), () => {
      this.dispatchEvent(new CustomEvent("filter-changed", { bubbles: !0 }));
    }));
  }
  focus() {
    this._textField && this._textField.focus();
  }
}
O(d0);
/**
 * @license
 * Copyright (c) 2016 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class u0 extends qi {
  static get is() {
    return "vaadin-grid-filter-column";
  }
  static get properties() {
    return {
      /**
       * JS Path of the property in the item used for filtering the data.
       */
      path: String,
      /**
       * Text to display as the label of the column filter text-field.
       */
      header: String
    };
  }
  static get observers() {
    return ["_onHeaderRendererOrBindingChanged(_headerRenderer, _headerCell, path, header, _filterValue)"];
  }
  constructor() {
    super(), this.__boundOnFilterValueChanged = this.__onFilterValueChanged.bind(this);
  }
  /**
   * Renders the grid filter with the custom text field to the header cell.
   *
   * @override
   */
  _defaultHeaderRenderer(e, t) {
    let r = e.firstElementChild, s = r ? r.firstElementChild : void 0;
    r || (r = document.createElement("vaadin-grid-filter"), s = document.createElement("vaadin-text-field"), s.setAttribute("theme", "small"), s.setAttribute("style", "max-width: 100%;"), s.setAttribute("focus-target", ""), s.addEventListener("value-changed", this.__boundOnFilterValueChanged), r.appendChild(s), e.appendChild(r)), r.path = this.path, r.value = this._filterValue, s.__rendererValue = this._filterValue, s.value = this._filterValue, s.label = this.__getHeader(this.header, this.path);
  }
  /**
   * The filter column doesn't allow to use a custom header renderer
   * to override the header cell content.
   * It always renders the grid filter to the header cell.
   *
   * @override
   */
  _computeHeaderRenderer() {
    return this._defaultHeaderRenderer;
  }
  /**
   * Updates the internal filter value once the filter text field is changed.
   * The listener handles only user-fired events.
   *
   * @private
   */
  __onFilterValueChanged(e) {
    e.detail.value !== e.target.__rendererValue && (this._filterValue = e.detail.value);
  }
  /** @private */
  __getHeader(e, t) {
    if (e)
      return e;
    if (t)
      return this._generateHeader(t);
  }
}
O(u0);
/**
 * @license
 * Copyright (c) 2016 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const h0 = (i) => class extends i {
  static get properties() {
    return {
      /**
       * Width of the cells for this column.
       */
      width: {
        type: String,
        value: "58px"
      },
      /**
       * Flex grow ratio for the cell widths. When set to 0, cell width is fixed.
       * @attr {number} flex-grow
       * @type {number}
       */
      flexGrow: {
        type: Number,
        value: 0
      },
      /**
       * When true, all the items are selected.
       * @attr {boolean} select-all
       * @type {boolean}
       */
      selectAll: {
        type: Boolean,
        value: !1,
        notify: !0
      },
      /**
       * When true, the active gets automatically selected.
       * @attr {boolean} auto-select
       * @type {boolean}
       */
      autoSelect: {
        type: Boolean,
        value: !1
      },
      /**
       * When true, rows can be selected by dragging over the selection column.
       * @attr {boolean} drag-select
       * @type {boolean}
       */
      dragSelect: {
        type: Boolean,
        value: !1
      },
      /** @protected */
      _indeterminate: Boolean,
      /** @protected */
      _selectAllHidden: Boolean
    };
  }
  static get observers() {
    return [
      "_onHeaderRendererOrBindingChanged(_headerRenderer, _headerCell, path, header, selectAll, _indeterminate, _selectAllHidden)"
    ];
  }
  /**
   * Renders the Select All checkbox to the header cell.
   *
   * @override
   */
  _defaultHeaderRenderer(t, r) {
    let s = t.firstElementChild;
    s || (s = document.createElement("vaadin-checkbox"), s.setAttribute("aria-label", "Select All"), s.classList.add("vaadin-grid-select-all-checkbox"), t.appendChild(s), s.addEventListener("checked-changed", this.__onSelectAllCheckedChanged.bind(this)));
    const o = this.__isChecked(this.selectAll, this._indeterminate);
    s.__rendererChecked = o, s.checked = o, s.hidden = this._selectAllHidden, s.indeterminate = this._indeterminate;
  }
  /**
   * Renders the Select Row checkbox to the body cell.
   *
   * @override
   */
  _defaultRenderer(t, r, { item: s, selected: o }) {
    let n = t.firstElementChild;
    n || (n = document.createElement("vaadin-checkbox"), n.setAttribute("aria-label", "Select Row"), t.appendChild(n), n.addEventListener("checked-changed", this.__onSelectRowCheckedChanged.bind(this)), pe(t, "track", this.__onCellTrack.bind(this)), t.addEventListener("mousedown", this.__onCellMouseDown.bind(this)), t.addEventListener("click", this.__onCellClick.bind(this))), n.__item = s, n.__rendererChecked = o, n.checked = o;
  }
  /**
   * Updates the select all state when the Select All checkbox is switched.
   * The listener handles only user-fired events.
   *
   * @private
   */
  __onSelectAllCheckedChanged(t) {
    t.target.checked !== t.target.__rendererChecked && (this._indeterminate || t.target.checked ? this._selectAll() : this._deselectAll());
  }
  /**
   * Selects or deselects the row when the Select Row checkbox is switched.
   * The listener handles only user-fired events.
   *
   * @private
   */
  __onSelectRowCheckedChanged(t) {
    t.target.checked !== t.target.__rendererChecked && (t.target.checked ? this._selectItem(t.target.__item) : this._deselectItem(t.target.__item));
  }
  /** @private */
  __onCellTrack(t) {
    if (this.dragSelect)
      if (this.__dragCurrentY = t.detail.y, this.__dragDy = t.detail.dy, t.detail.state === "start") {
        const s = this._grid._getRenderedRows().find((o) => o.contains(t.currentTarget.assignedSlot));
        this.__dragSelect = !this._grid._isSelected(s._item), this.__dragStartIndex = s.index, this.__dragStartItem = s._item, this.__dragAutoScroller();
      } else
        t.detail.state === "end" && (this.__dragStartItem && (this.__dragSelect ? this._selectItem(this.__dragStartItem) : this._deselectItem(this.__dragStartItem)), setTimeout(() => {
          this.__dragStartIndex = void 0;
        }));
  }
  /** @private */
  __onCellMouseDown(t) {
    this.dragSelect && t.preventDefault();
  }
  /** @private */
  __onCellClick(t) {
    this.__dragStartIndex !== void 0 && t.preventDefault();
  }
  /** @private */
  __dragAutoScroller() {
    if (this.__dragStartIndex === void 0)
      return;
    const t = this._grid._getRenderedRows(), r = t.find((l) => {
      const c = l.getBoundingClientRect();
      return this.__dragCurrentY >= c.top && this.__dragCurrentY <= c.bottom;
    });
    let s = r ? r.index : void 0;
    const o = this.__getScrollableArea();
    this.__dragCurrentY < o.top ? s = this._grid._firstVisibleIndex : this.__dragCurrentY > o.bottom && (s = this._grid._lastVisibleIndex), s !== void 0 && t.forEach((l) => {
      (s > this.__dragStartIndex && l.index >= this.__dragStartIndex && l.index <= s || s < this.__dragStartIndex && l.index <= this.__dragStartIndex && l.index >= s) && (this.__dragSelect ? this._selectItem(l._item) : this._deselectItem(l._item), this.__dragStartItem = void 0);
    });
    const n = o.height * 0.15, a = 10;
    if (this.__dragDy < 0 && this.__dragCurrentY < o.top + n) {
      const l = o.top + n - this.__dragCurrentY, c = Math.min(1, l / n);
      this._grid.$.table.scrollTop -= c * a;
    }
    if (this.__dragDy > 0 && this.__dragCurrentY > o.bottom - n) {
      const l = this.__dragCurrentY - (o.bottom - n), c = Math.min(1, l / n);
      this._grid.$.table.scrollTop += c * a;
    }
    setTimeout(() => this.__dragAutoScroller(), 10);
  }
  /**
   * Gets the scrollable area of the grid as a bounding client rect. The
   * scrollable area is the bounding rect of the grid minus the header and
   * footer.
   *
   * @private
   */
  __getScrollableArea() {
    const t = this._grid.$.table.getBoundingClientRect(), r = this._grid.$.header.getBoundingClientRect(), s = this._grid.$.footer.getBoundingClientRect();
    return {
      top: t.top + r.height,
      bottom: t.bottom - s.height,
      left: t.left,
      right: t.right,
      height: t.height - r.height - s.height,
      width: t.width
    };
  }
  /**
   * Override to handle the user selecting all items.
   * @protected
   */
  _selectAll() {
  }
  /**
   * Override to handle the user deselecting all items.
   * @protected
   */
  _deselectAll() {
  }
  /**
   * Override to handle the user selecting an item.
   * @param {Object} item the item to select
   * @protected
   */
  _selectItem(t) {
  }
  /**
   * Override to handle the user deselecting an item.
   * @param {Object} item the item to deselect
   * @protected
   */
  _deselectItem(t) {
  }
  /**
   * IOS needs indeterminate + checked at the same time
   * @private
   */
  __isChecked(t, r) {
    return r || t;
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class f0 extends h0(qi) {
  static get is() {
    return "vaadin-grid-selection-column";
  }
  static get properties() {
    return {
      /**
       * The previous state of activeItem. When activeItem turns to `null`,
       * previousActiveItem will have an Object with just unselected activeItem
       * @private
       */
      __previousActiveItem: Object
    };
  }
  static get observers() {
    return ["__onSelectAllChanged(selectAll)"];
  }
  constructor() {
    super(), this.__boundOnActiveItemChanged = this.__onActiveItemChanged.bind(this), this.__boundOnDataProviderChanged = this.__onDataProviderChanged.bind(this), this.__boundOnSelectedItemsChanged = this.__onSelectedItemsChanged.bind(this);
  }
  /** @protected */
  disconnectedCallback() {
    this._grid.removeEventListener("active-item-changed", this.__boundOnActiveItemChanged), this._grid.removeEventListener("data-provider-changed", this.__boundOnDataProviderChanged), this._grid.removeEventListener("filter-changed", this.__boundOnSelectedItemsChanged), this._grid.removeEventListener("selected-items-changed", this.__boundOnSelectedItemsChanged), super.disconnectedCallback();
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback(), this._grid && (this._grid.addEventListener("active-item-changed", this.__boundOnActiveItemChanged), this._grid.addEventListener("data-provider-changed", this.__boundOnDataProviderChanged), this._grid.addEventListener("filter-changed", this.__boundOnSelectedItemsChanged), this._grid.addEventListener("selected-items-changed", this.__boundOnSelectedItemsChanged));
  }
  /** @private */
  __onSelectAllChanged(e) {
    if (!(e === void 0 || !this._grid)) {
      if (!this.__selectAllInitialized) {
        this.__selectAllInitialized = !0;
        return;
      }
      this._selectAllChangeLock || (e && this.__hasArrayDataProvider() ? this.__withFilteredItemsArray((t) => {
        this._grid.selectedItems = t;
      }) : this._grid.selectedItems = []);
    }
  }
  /**
   * Return true if array `a` contains all the items in `b`
   * We need this when sorting or to preserve selection after filtering.
   * @private
   */
  __arrayContains(e, t) {
    return Array.isArray(e) && Array.isArray(t) && t.every((r) => e.includes(r));
  }
  /**
   * Override a method from `GridSelectionColumnBaseMixin` to handle the user
   * selecting all items.
   *
   * @protected
   * @override
   */
  _selectAll() {
    this.selectAll = !0;
  }
  /**
   * Override a method from `GridSelectionColumnBaseMixin` to handle the user
   * deselecting all items.
   *
   * @protected
   * @override
   */
  _deselectAll() {
    this.selectAll = !1;
  }
  /**
   * Override a method from `GridSelectionColumnBaseMixin` to handle the user
   * selecting an item.
   *
   * @param {Object} item the item to select
   * @protected
   * @override
   */
  _selectItem(e) {
    this._grid.selectItem(e);
  }
  /**
   * Override a method from `GridSelectionColumnBaseMixin` to handle the user
   * deselecting an item.
   *
   * @param {Object} item the item to deselect
   * @protected
   * @override
   */
  _deselectItem(e) {
    this._grid.deselectItem(e);
  }
  /** @private */
  __onActiveItemChanged(e) {
    const t = e.detail.value;
    if (this.autoSelect) {
      const r = t || this.__previousActiveItem;
      r && this._grid._toggleItem(r);
    }
    this.__previousActiveItem = t;
  }
  /** @private */
  __hasArrayDataProvider() {
    return Array.isArray(this._grid.items) && !!this._grid.dataProvider;
  }
  /** @private */
  __onSelectedItemsChanged() {
    this._selectAllChangeLock = !0, this.__hasArrayDataProvider() && this.__withFilteredItemsArray((e) => {
      this._grid.selectedItems.length ? this.__arrayContains(this._grid.selectedItems, e) ? (this.selectAll = !0, this._indeterminate = !1) : (this.selectAll = !1, this._indeterminate = !0) : (this.selectAll = !1, this._indeterminate = !1);
    }), this._selectAllChangeLock = !1;
  }
  /** @private */
  __onDataProviderChanged() {
    this._selectAllHidden = !Array.isArray(this._grid.items);
  }
  /**
   * Assuming the grid uses an items array data provider, fetches all the filtered items
   * from the data provider and invokes the callback with the resulting array.
   *
   * @private
   */
  __withFilteredItemsArray(e) {
    const t = {
      page: 0,
      pageSize: 1 / 0,
      sortOrders: [],
      filters: this._grid._mapFilters()
    };
    this._grid.dataProvider(t, (r) => e(r));
  }
}
O(f0);
C(
  "vaadin-grid-sorter",
  y`
    :host {
      justify-content: flex-start;
      align-items: baseline;
      -webkit-user-select: none;
      -moz-user-select: none;
      user-select: none;
      cursor: var(--lumo-clickable-cursor);
    }

    [part='content'] {
      display: inline-block;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    [part='indicators'] {
      margin-left: var(--lumo-space-s);
    }

    [part='indicators']::before {
      transform: scale(0.8);
    }

    :host(:not([direction]):not(:hover)) [part='indicators'] {
      color: var(--lumo-tertiary-text-color);
    }

    :host([direction]) {
      color: var(--lumo-primary-text-color);
    }

    [part='order'] {
      font-size: var(--lumo-font-size-xxs);
      line-height: 1;
    }

    /* RTL specific styles */

    :host([dir='rtl']) [part='indicators'] {
      margin-right: var(--lumo-space-s);
      margin-left: 0;
    }
  `,
  { moduleId: "lumo-grid-sorter" }
);
/**
 * @license
 * Copyright (c) 2016 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const of = document.createElement("template");
of.innerHTML = `
  <style>
    @font-face {
      font-family: 'vaadin-grid-sorter-icons';
      src: url(data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAAAQwAA0AAAAABuwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAAEFAAAABkAAAAcfep+mUdERUYAAAP4AAAAHAAAAB4AJwAOT1MvMgAAAZgAAAA/AAAAYA8TBPpjbWFwAAAB7AAAAFUAAAFeF1fZ4mdhc3AAAAPwAAAACAAAAAgAAAAQZ2x5ZgAAAlgAAABcAAAAnMvguMloZWFkAAABMAAAAC8AAAA2C5Ap72hoZWEAAAFgAAAAHQAAACQGbQPHaG10eAAAAdgAAAAUAAAAHAoAAABsb2NhAAACRAAAABIAAAASAIwAYG1heHAAAAGAAAAAFgAAACAACwAKbmFtZQAAArQAAAECAAACZxWCgKhwb3N0AAADuAAAADUAAABZCrApUXicY2BkYGAA4rDECVrx/DZfGbhZGEDgyqNPOxH0/wNMq5kPALkcDEwgUQBWRA0dAHicY2BkYGA+8P8AAwMLAwgwrWZgZEAFbABY4QM8AAAAeJxjYGRgYOAAQiYGEICQSAAAAi8AFgAAeJxjYGY6yziBgZWBgWkm0xkGBoZ+CM34msGYkZMBFTAKoAkwODAwvmRiPvD/AIMDMxCD1CDJKjAwAgBktQsXAHicY2GAAMZQCM0EwqshbAALxAEKeJxjYGBgZoBgGQZGBhCIAPIYwXwWBhsgzcXAwcAEhIwMCi+Z/v/9/x+sSuElA4T9/4k4K1gHFwMMMILMY2QDYmaoABOQYGJABUA7WBiGNwAAJd4NIQAAAAAAAAAACAAIABAAGAAmAEAATgAAeJyNjLENgDAMBP9tIURJwQCMQccSZgk2i5fIYBDAidJjycXr7x5EPwE2wY8si7jmyBNXGo/bNBerxJNrpxhbO3/fEFpx8ZICpV+ghxJ74fAMe+h7Ox14AbrsHB14nK2QQWrDMBRER4mTkhQK3ZRQKOgCNk7oGQqhhEIX2WSlWEI1BAlkJ5CDdNsj5Ey9Rncdi38ES+jzNJo/HwTgATcoDEthhY3wBHc4CE+pfwsX5F/hGe7Vo/AcK/UhvMSz+mGXKhZU6pww8ISz3oWn1BvhgnwTnuEJf8Jz1OpFeIlX9YULDLdFi4ASHolkSR0iuYdjLak1vAequBhj21D61Nqyi6l3qWybGPjySbPHGScGJl6dP58MYcQRI0bts7mjebBqrFENH7t3qWtj0OuqHnXcW7b0HOTZFnKryRGW2hFX1m0O2vEM3opNMfTau+CS6Z3Vx6veNnEXY6jwDxhsc2gAAHicY2BiwA84GBgYmRiYGJkZmBlZGFkZ2djScyoLMgzZS/MyDQwMwLSrpYEBlIbxjQDrzgsuAAAAAAEAAf//AA94nGNgZGBg4AFiMSBmYmAEQnYgZgHzGAAD6wA2eJxjYGBgZACCKyoz1cD0o087YTQATOcIewAAAA==) format('woff');
      font-weight: normal;
      font-style: normal;
    }
  </style>
`;
document.head.appendChild(of.content);
class p0 extends X(Be(N)) {
  static get template() {
    return U`
      <style>
        :host {
          display: inline-flex;
          cursor: pointer;
          max-width: 100%;
        }

        [part='content'] {
          flex: 1 1 auto;
        }

        [part='indicators'] {
          position: relative;
          align-self: center;
          flex: none;
        }

        [part='order'] {
          display: inline;
          vertical-align: super;
        }

        [part='indicators']::before {
          font-family: 'vaadin-grid-sorter-icons';
          display: inline-block;
        }

        :host(:not([direction])) [part='indicators']::before {
          content: '\\e901';
        }

        :host([direction='asc']) [part='indicators']::before {
          content: '\\e900';
        }

        :host([direction='desc']) [part='indicators']::before {
          content: '\\e902';
        }
      </style>

      <div part="content">
        <slot></slot>
      </div>
      <div part="indicators">
        <span part="order">[[_getDisplayOrder(_order)]]</span>
      </div>
    `;
  }
  static get is() {
    return "vaadin-grid-sorter";
  }
  static get properties() {
    return {
      /**
       * JS Path of the property in the item used for sorting the data.
       */
      path: String,
      /**
       * How to sort the data.
       * Possible values are `asc` to use an ascending algorithm, `desc` to sort the data in
       * descending direction, or `null` for not sorting the data.
       * @type {GridSorterDirection | undefined}
       */
      direction: {
        type: String,
        reflectToAttribute: !0,
        notify: !0,
        value: null
      },
      /**
       * @type {number | null}
       * @protected
       */
      _order: {
        type: Number,
        value: null
      },
      /** @private */
      _isConnected: {
        type: Boolean,
        observer: "__isConnectedChanged"
      }
    };
  }
  static get observers() {
    return ["_pathOrDirectionChanged(path, direction)"];
  }
  /** @protected */
  ready() {
    super.ready(), this.addEventListener("click", this._onClick.bind(this));
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback(), this._isConnected = !0;
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback(), this._isConnected = !1, !this.parentNode && this._grid && this._grid.__removeSorters([this]);
  }
  /** @private */
  _pathOrDirectionChanged() {
    this.__dispatchSorterChangedEvenIfPossible();
  }
  /** @private */
  __isConnectedChanged(e, t) {
    t !== !1 && this.__dispatchSorterChangedEvenIfPossible();
  }
  /** @private */
  __dispatchSorterChangedEvenIfPossible() {
    this.path === void 0 || this.direction === void 0 || !this._isConnected || (this.dispatchEvent(
      new CustomEvent("sorter-changed", {
        detail: { shiftClick: !!this._shiftClick, fromSorterClick: !!this._fromSorterClick },
        bubbles: !0,
        composed: !0
      })
    ), this._fromSorterClick = !1, this._shiftClick = !1);
  }
  /** @private */
  _getDisplayOrder(e) {
    return e === null ? "" : e + 1;
  }
  /** @private */
  _onClick(e) {
    if (e.defaultPrevented)
      return;
    const t = this.getRootNode().activeElement;
    this !== t && this.contains(t) || (e.preventDefault(), this._shiftClick = e.shiftKey, this._fromSorterClick = !0, this.direction === "asc" ? this.direction = "desc" : this.direction === "desc" ? this.direction = null : this.direction = "asc");
  }
}
O(p0);
/**
 * @license
 * Copyright (c) 2016 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class m0 extends qi {
  static get is() {
    return "vaadin-grid-sort-column";
  }
  static get properties() {
    return {
      /**
       * JS Path of the property in the item used for sorting the data.
       */
      path: String,
      /**
       * How to sort the data.
       * Possible values are `asc` to use an ascending algorithm, `desc` to sort the data in
       * descending direction, or `null` for not sorting the data.
       * @type {GridSorterDirection | undefined}
       */
      direction: {
        type: String,
        notify: !0
      }
    };
  }
  static get observers() {
    return ["_onHeaderRendererOrBindingChanged(_headerRenderer, _headerCell, path, header, direction)"];
  }
  constructor() {
    super(), this.__boundOnDirectionChanged = this.__onDirectionChanged.bind(this);
  }
  /**
   * Renders the grid sorter to the header cell.
   *
   * @override
   */
  _defaultHeaderRenderer(e, t) {
    let r = e.firstElementChild;
    r || (r = document.createElement("vaadin-grid-sorter"), r.addEventListener("direction-changed", this.__boundOnDirectionChanged), e.appendChild(r)), r.path = this.path, r.__rendererDirection = this.direction, r.direction = this.direction, r.textContent = this.__getHeader(this.header, this.path);
  }
  /**
   * The sort column doesn't allow to use a custom header renderer
   * to override the header cell content.
   * It always renders the grid sorter to the header cell.
   *
   * @override
   */
  _computeHeaderRenderer() {
    return this._defaultHeaderRenderer;
  }
  /**
   * Updates the sorting direction once the grid sorter's direction is changed.
   * The listener handles only user-fired events.
   *
   * @private
   */
  __onDirectionChanged(e) {
    e.detail.value !== e.target.__rendererDirection && (this.direction = e.detail.value);
  }
  /** @private */
  __getHeader(e, t) {
    if (e)
      return e;
    if (t)
      return this._generateHeader(t);
  }
}
O(m0);
C(
  "vaadin-grid-tree-toggle",
  y`
    :host {
      --vaadin-grid-tree-toggle-level-offset: 2em;
      align-items: center;
      vertical-align: middle;
      transform: translateX(calc(var(--lumo-space-s) * -1));
      -webkit-tap-highlight-color: transparent;
    }

    :host(:not([leaf])) {
      cursor: default;
    }

    [part='toggle'] {
      display: inline-block;
      font-size: 1.5em;
      line-height: 1;
      width: 1em;
      height: 1em;
      text-align: center;
      color: var(--lumo-contrast-50pct);
      cursor: var(--lumo-clickable-cursor);
      /* Increase touch target area */
      padding: calc(1em / 3);
      margin: calc(1em / -3);
    }

    :host(:not([dir='rtl'])) [part='toggle'] {
      margin-right: 0;
    }

    @media (hover: hover) {
      :host(:hover) [part='toggle'] {
        color: var(--lumo-contrast-80pct);
      }
    }

    [part='toggle']::before {
      font-family: 'lumo-icons';
      display: inline-block;
      height: 100%;
    }

    :host(:not([expanded])) [part='toggle']::before {
      content: var(--lumo-icons-angle-right);
    }

    :host([expanded]) [part='toggle']::before {
      content: var(--lumo-icons-angle-right);
      transform: rotate(90deg);
    }

    /* Experimental support for hierarchy connectors, using an unsupported selector */
    :host([theme~='connectors']) #level-spacer {
      position: relative;
      z-index: -1;
      font-size: 1em;
      height: 1.5em;
    }

    :host([theme~='connectors']) #level-spacer::before {
      display: block;
      content: '';
      margin-top: calc(var(--lumo-space-m) * -1);
      height: calc(var(--lumo-space-m) + 3em);
      background-image: linear-gradient(
        to right,
        transparent calc(var(--vaadin-grid-tree-toggle-level-offset) - 1px),
        var(--lumo-contrast-10pct) calc(var(--vaadin-grid-tree-toggle-level-offset) - 1px)
      );
      background-size: var(--vaadin-grid-tree-toggle-level-offset) var(--vaadin-grid-tree-toggle-level-offset);
      background-position: calc(var(--vaadin-grid-tree-toggle-level-offset) / 2 - 2px) 0;
    }

    /* RTL specific styles */

    :host([dir='rtl']) {
      margin-left: 0;
      margin-right: calc(var(--lumo-space-s) * -1);
    }

    :host([dir='rtl']) [part='toggle'] {
      margin-left: 0;
    }

    :host([dir='rtl'][expanded]) [part='toggle']::before {
      transform: rotate(-90deg);
    }

    :host([dir='rtl'][theme~='connectors']) #level-spacer::before {
      background-image: linear-gradient(
        to left,
        transparent calc(var(--vaadin-grid-tree-toggle-level-offset) - 1px),
        var(--lumo-contrast-10pct) calc(var(--vaadin-grid-tree-toggle-level-offset) - 1px)
      );
      background-position: calc(100% - (var(--vaadin-grid-tree-toggle-level-offset) / 2 - 2px)) 0;
    }

    :host([dir='rtl']:not([expanded])) [part='toggle']::before,
    :host([dir='rtl'][expanded]) [part='toggle']::before {
      content: var(--lumo-icons-angle-left);
    }
  `,
  { moduleId: "lumo-grid-tree-toggle" }
);
/**
 * @license
 * Copyright (c) 2016 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const nf = document.createElement("template");
nf.innerHTML = `
  <style>
    @font-face {
      font-family: "vaadin-grid-tree-icons";
      src: url(data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAAAQkAA0AAAAABrwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAAECAAAABoAAAAcgHwa6EdERUYAAAPsAAAAHAAAAB4AJwAOT1MvMgAAAZQAAAA/AAAAYA8TBIJjbWFwAAAB8AAAAFUAAAFeGJvXWmdhc3AAAAPkAAAACAAAAAgAAAAQZ2x5ZgAAAlwAAABLAAAAhIrPOhFoZWFkAAABMAAAACsAAAA2DsJI02hoZWEAAAFcAAAAHQAAACQHAgPHaG10eAAAAdQAAAAZAAAAHAxVAgBsb2NhAAACSAAAABIAAAASAIAAVG1heHAAAAF8AAAAGAAAACAACgAFbmFtZQAAAqgAAAECAAACTwflzbdwb3N0AAADrAAAADYAAABZQ7Ajh3icY2BkYGAA4twv3Vfi+W2+MnCzMIDANSOmbGSa2YEZRHEwMIEoAAoiB6sAeJxjYGRgYD7w/wADAwsDCDA7MDAyoAI2AFEEAtIAAAB4nGNgZGBg4GBgZgDRDAxMDGgAAAGbABB4nGNgZp7JOIGBlYGBaSbTGQYGhn4IzfiawZiRkwEVMAqgCTA4MDA+38d84P8BBgdmIAapQZJVYGAEAGc/C54AeJxjYYAAxlAIzQTELAwMBxgZGB0ACy0BYwAAAHicY2BgYGaAYBkGRgYQiADyGMF8FgYbIM3FwMHABISMDArP9/3/+/8/WJXC8z0Q9v8nEp5gHVwMMMAIMo+RDYiZoQJMQIKJARUA7WBhGN4AACFKDtoAAAAAAAAAAAgACAAQABgAJgA0AEIAAHichYvBEYBADAKBVHBjBT4swl9KS2k05o0XHd/yW1hAfBFwCv9sIlJu3nZaNS3PXAaXXHI8Lge7DlzF7C1RgXc7xkK6+gvcD2URmQB4nK2RQWoCMRiFX3RUqtCli65yADModOMBLLgQSqHddRFnQghIAnEUvEA3vUUP0LP0Fj1G+yb8R5iEhO9/ef/7FwFwj28o9EthiVp4hBlehcfUP4Ur8o/wBAv8CU+xVFvhOR7UB7tUdUdlVRJ6HnHWTnhM/V24In8JT5j/KzzFSi2E53hUz7jCcrcIiDDwyKSW1JEct2HdIPH1DFytbUM0PofWdNk5E5oUqb/Q6HHBiVGZpfOXkyUMEj5IyBuNmYZQjBobfsuassvnkKLe1OuBBj0VQ8cRni2xjLWsHaM0jrjx3peYA0/vrdmUYqe9iy7bzrX6eNP7Jh1SijX+AaUVbB8AAHicY2BiwA84GBgYmRiYGJkZmBlZGFkZ2djScyoLMgzZS/MyDQwMwLSruZMzlHaB0q4A76kLlwAAAAEAAf//AA94nGNgZGBg4AFiMSBmYmAEQnYgZgHzGAAD6wA2eJxjYGBgZACCKxJigiD6mhFTNowGACmcA/8AAA==) format('woff');
      font-weight: normal;
      font-style: normal;
    }
  </style>
`;
document.head.appendChild(nf.content);
class g0 extends X(Be(N)) {
  static get template() {
    return U`
      <style>
        :host {
          display: inline-flex;
          align-items: baseline;
          max-width: 100%;

          /* CSS API for :host */
          --vaadin-grid-tree-toggle-level-offset: 1em;
          --_collapsed-icon: '\\e7be\\00a0';
        }

        :host([dir='rtl']) {
          --_collapsed-icon: '\\e7bd\\00a0';
        }

        :host([hidden]) {
          display: none !important;
        }

        :host(:not([leaf])) {
          cursor: pointer;
        }

        #level-spacer,
        [part='toggle'] {
          flex: none;
        }

        #level-spacer {
          display: inline-block;
          width: calc(var(---level, '0') * var(--vaadin-grid-tree-toggle-level-offset));
        }

        [part='toggle']::before {
          font-family: 'vaadin-grid-tree-icons';
          line-height: 1em; /* make icon font metrics not affect baseline */
        }

        :host(:not([expanded])) [part='toggle']::before {
          content: var(--_collapsed-icon);
        }

        :host([expanded]) [part='toggle']::before {
          content: '\\e7bc\\00a0'; /* icon glyph + single non-breaking space */
        }

        :host([leaf]) [part='toggle'] {
          visibility: hidden;
        }

        slot {
          display: block;
          overflow: hidden;
          text-overflow: ellipsis;
        }
      </style>

      <span id="level-spacer"></span>
      <span part="toggle"></span>
      <slot></slot>
    `;
  }
  static get is() {
    return "vaadin-grid-tree-toggle";
  }
  static get properties() {
    return {
      /**
       * Current level of the tree represented with a horizontal offset
       * of the toggle button.
       * @type {number}
       */
      level: {
        type: Number,
        value: 0,
        observer: "_levelChanged"
      },
      /**
       * Hides the toggle icon and disables toggling a tree sublevel.
       * @type {boolean}
       */
      leaf: {
        type: Boolean,
        value: !1,
        reflectToAttribute: !0
      },
      /**
       * Sublevel toggle state.
       * @type {boolean}
       */
      expanded: {
        type: Boolean,
        value: !1,
        reflectToAttribute: !0,
        notify: !0
      }
    };
  }
  /** @protected */
  ready() {
    super.ready(), this.addEventListener("click", (e) => this._onClick(e));
  }
  /** @private */
  _onClick(e) {
    this.leaf || Zh(e.target) || e.target instanceof HTMLLabelElement || (e.preventDefault(), this.expanded = !this.expanded);
  }
  /** @private */
  _levelChanged(e) {
    const t = Number(e).toString();
    this.style.setProperty("---level", t);
  }
}
O(g0);
/**
 * @license
 * Copyright (c) 2016 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class _0 extends qi {
  static get is() {
    return "vaadin-grid-tree-column";
  }
  static get properties() {
    return {
      /**
       * JS Path of the property in the item used as text content for the tree toggle.
       */
      path: String
    };
  }
  static get observers() {
    return ["_onRendererOrBindingChanged(_renderer, _cells, _bodyContentHidden, _cells.*, path)"];
  }
  constructor() {
    super(), this.__boundOnExpandedChanged = this.__onExpandedChanged.bind(this);
  }
  /**
   * Renders the grid tree toggle to the body cell
   *
   * @private
   */
  __defaultRenderer(e, t, { item: r, expanded: s, level: o }) {
    let n = e.firstElementChild;
    n || (n = document.createElement("vaadin-grid-tree-toggle"), n.addEventListener("expanded-changed", this.__boundOnExpandedChanged), e.appendChild(n)), n.__item = r, n.__rendererExpanded = s, n.expanded = s, n.leaf = this.__isLeafItem(r, this._grid.itemHasChildrenPath), n.textContent = this.__getToggleContent(this.path, r), n.level = o;
  }
  /**
   * The tree column doesn't allow to use a custom renderer
   * to override the content of body cells.
   * It always renders the grid tree toggle to body cells.
   *
   * @override
   */
  _computeRenderer() {
    return this.__defaultRenderer;
  }
  /**
   * Expands or collapses the row once the tree toggle is switched.
   * The listener handles only user-fired events.
   *
   * @private
   */
  __onExpandedChanged(e) {
    e.detail.value !== e.target.__rendererExpanded && (e.detail.value ? this._grid.expandItem(e.target.__item) : this._grid.collapseItem(e.target.__item));
  }
  /** @private */
  __isLeafItem(e, t) {
    return !e || !e[t];
  }
  /** @private */
  __getToggleContent(e, t) {
    return e && Ct(e, t);
  }
}
O(_0);
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const af = { ATTRIBUTE: 1, CHILD: 2, PROPERTY: 3, BOOLEAN_ATTRIBUTE: 4, EVENT: 5, ELEMENT: 6 }, lf = (i) => (...e) => ({ _$litDirective$: i, values: e });
let b0 = class {
  constructor(e) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(e, t, r) {
    this._$Ct = e, this._$AM = t, this._$Ci = r;
  }
  _$AS(e, t) {
    return this.update(e, t);
  }
  update(e, t) {
    return this.render(...t);
  }
};
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const y0 = (i) => i.strings === void 0;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const pi = (i, e) => {
  var t, r;
  const s = i._$AN;
  if (s === void 0)
    return !1;
  for (const o of s)
    (r = (t = o)._$AO) === null || r === void 0 || r.call(t, e, !1), pi(o, e);
  return !0;
}, Us = (i) => {
  let e, t;
  do {
    if ((e = i._$AM) === void 0)
      break;
    t = e._$AN, t.delete(i), i = e;
  } while ((t == null ? void 0 : t.size) === 0);
}, cf = (i) => {
  for (let e; e = i._$AM; i = e) {
    let t = e._$AN;
    if (t === void 0)
      e._$AN = t = /* @__PURE__ */ new Set();
    else if (t.has(i))
      break;
    t.add(i), x0(e);
  }
};
function v0(i) {
  this._$AN !== void 0 ? (Us(this), this._$AM = i, cf(this)) : this._$AM = i;
}
function w0(i, e = !1, t = 0) {
  const r = this._$AH, s = this._$AN;
  if (s !== void 0 && s.size !== 0)
    if (e)
      if (Array.isArray(r))
        for (let o = t; o < r.length; o++)
          pi(r[o], !1), Us(r[o]);
      else
        r != null && (pi(r, !1), Us(r));
    else
      pi(this, i);
}
const x0 = (i) => {
  var e, t, r, s;
  i.type == af.CHILD && ((e = (r = i)._$AP) !== null && e !== void 0 || (r._$AP = w0), (t = (s = i)._$AQ) !== null && t !== void 0 || (s._$AQ = v0));
};
let C0 = class extends b0 {
  constructor() {
    super(...arguments), this._$AN = void 0;
  }
  _$AT(e, t, r) {
    super._$AT(e, t, r), cf(this), this.isConnected = e._$AU;
  }
  _$AO(e, t = !0) {
    var r, s;
    e !== this.isConnected && (this.isConnected = e, e ? (r = this.reconnected) === null || r === void 0 || r.call(this) : (s = this.disconnected) === null || s === void 0 || s.call(this)), t && (pi(this, e), Us(this));
  }
  setValue(e) {
    if (y0(this._$Ct))
      this._$Ct._$AI(e, this);
    else {
      const t = [...this._$Ct._$AH];
      t[this._$Ci] = e, this._$Ct._$AI(t, this, 0);
    }
  }
  disconnected() {
  }
  reconnected() {
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Rc = Symbol("valueNotInitialized");
class k0 extends C0 {
  constructor(e) {
    if (super(e), e.type !== af.ELEMENT)
      throw new Error(`\`${this.constructor.name}\` must be bound to an element.`);
    this.previousValue = Rc;
  }
  /** @override */
  render(e, t) {
    return b;
  }
  /** @override */
  update(e, [t, r]) {
    return this.hasChanged(r) && (this.host = e.options && e.options.host, this.element = e.element, this.renderer = t, this.previousValue === Rc ? this.addRenderer() : this.runRenderer(), this.previousValue = Array.isArray(r) ? [...r] : r), b;
  }
  /** @override */
  reconnected() {
    this.addRenderer();
  }
  /** @override */
  disconnected() {
    this.removeRenderer();
  }
  /** @abstract */
  addRenderer() {
    throw new Error("The `addRenderer` method must be implemented.");
  }
  /** @abstract */
  runRenderer() {
    throw new Error("The `runRenderer` method must be implemented.");
  }
  /** @abstract */
  removeRenderer() {
    throw new Error("The `removeRenderer` method must be implemented.");
  }
  /** @protected */
  renderRenderer(e, ...t) {
    const r = this.renderer.call(this.host, ...t);
    Kd(r, e, { host: this.host });
  }
  /** @protected */
  hasChanged(e) {
    return Array.isArray(e) ? !Array.isArray(this.previousValue) || this.previousValue.length !== e.length ? !0 : e.some((t, r) => t !== this.previousValue[r]) : this.previousValue !== e;
  }
}
/**
 * @license
 * Copyright (c) 2017 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Lc = Symbol("contentUpdateDebouncer");
/**
 * @license
 * Copyright (c) 2017 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class df extends k0 {
  /**
   * A property to that the renderer callback will be assigned.
   *
   * @abstract
   */
  get rendererProperty() {
    throw new Error("The `rendererProperty` getter must be implemented.");
  }
  /**
   * Adds the renderer callback to the grid column.
   */
  addRenderer() {
    this.element[this.rendererProperty] = (e, t) => {
      this.renderRenderer(e, t);
    };
  }
  /**
   * Runs the renderer callback on the grid column.
   */
  runRenderer() {
    const e = this.element._grid;
    e[Lc] = R.debounce(e[Lc], xt, () => {
      e.requestContentUpdate();
    });
  }
  /**
   * Removes the renderer callback from the grid column.
   */
  removeRenderer() {
    this.element[this.rendererProperty] = null;
  }
}
class A0 extends df {
  get rendererProperty() {
    return "renderer";
  }
  addRenderer() {
    this.element[this.rendererProperty] = (e, t, r) => {
      this.renderRenderer(e, r.item, r, t);
    };
  }
}
class E0 extends df {
  get rendererProperty() {
    return "headerRenderer";
  }
}
const S0 = lf(A0), T0 = lf(E0);
class Ga {
  constructor(e, t) {
    this._rootKey = "", this._id = e, this.dataContext = t;
  }
  get rootKey() {
    return this._rootKey;
  }
  set rootKey(e) {
    this._rootKey = e;
  }
  get id() {
    return this._id;
  }
}
const bo = class fr {
  constructor() {
    this.accessors = [], this.SEPARATOR = "/";
  }
  clone() {
    const e = new fr();
    return e.accessors = [...this.accessors], e.dsd = this.dsd, e.SEPARATOR = this.SEPARATOR, e;
  }
  separatePathAndKey(e) {
    const t = e.lastIndexOf(this.SEPARATOR), r = e.substring(t + 1);
    return { path: e.substring(0, t) || "", key: r };
  }
  get(e) {
    let t = fr.GET_MODE_DEFAULT;
    e = e.trimStart(), e.startsWith("*") ? (t = fr.GET_MODE_ENDS_WITH, e = e.substring(1)) : e.startsWith(":") ? t = fr.GET_MODE_REGEX : e.startsWith("/") || (e = "/" + e);
    const r = this.separatePathAndKey(e);
    for (const s of this.accessors) {
      if (t == fr.GET_MODE_DEFAULT && s.rootKey && r.path && !r.path.startsWith(s.rootKey))
        continue;
      const o = s.get(r.path, r.key, t);
      if (o)
        return o;
    }
  }
  get count() {
    return this.accessors.length;
  }
  get ids() {
    return this.accessors.map((e) => e.id);
  }
  /**
   * register a DataContextAccessor with a certain priority. By default, it will be inserted at the top of the list.
   * @param accessor a DataContextAccessor
   * @param before true (default) to put it before the position. false to put it behind.
   * @param position "" (default) or an id of an existing DataContextAccessor.
   *                 Before "" means first, after "" means last.
   */
  registerAccessor(e, t = !0, r = "") {
    if (this.deleteAccessorIfExists(e.id), r) {
      const s = this.accessors.findIndex((o) => o.id === r);
      if (s == -1)
        throw `registerAccessor: Accessor ${r} does not exist`;
      this.accessors.splice(t ? s : s + 1, 0, e);
    } else
      t ? this.accessors.splice(0, 0, e) : this.accessors.push(e);
  }
  deleteAccessorIfExists(e) {
    const t = this.accessors.findIndex((r) => r.id === e);
    t > -1 && this.accessors.splice(t, 1);
  }
  hasAccessor(e) {
    return this.accessors.findIndex((t) => t.id === e) > -1;
  }
  getAccessor(e) {
    return this.accessors.find((t) => t.id === e);
  }
};
bo.GET_MODE_DEFAULT = 0;
bo.GET_MODE_ENDS_WITH = 1;
bo.GET_MODE_REGEX = 1;
let Re = bo;
class Ya extends Ga {
  constructor(e, t, r = void 0) {
    super(e, t), this.rootKey = "/$/", this.assignEntries(r);
  }
  /**
   * assigns an array of dictionary entries of type Constant as (not to!) the dictionary. So
   * this is replacing the whole dictionary! The path value of the Constant instance follows
   * the "constants" api: there the path would be e.g. "glossary" and the key "some term". In the dictionary that
   * would be accessible as "/$/glossary/key"
   * @param dictionary an array of Constant instances.
   */
  assignEntries(e) {
    this.dictionary = e;
  }
  splitKeyAndIndex(e) {
    const t = e.lastIndexOf(":");
    return t > -1 ? [e.substring(0, t), e.substring(t + 1)] : [e, void 0];
  }
  get(e, t, r = 0) {
    e = e.substring(this.rootKey.length);
    let s;
    [t, s] = this.splitKeyAndIndex(t);
    let o;
    if (e)
      switch (r) {
        case Re.GET_MODE_DEFAULT:
          o = this.dictionary.find((n) => n.path === e && n.key === t);
          break;
        case Re.GET_MODE_ENDS_WITH:
          o = this.dictionary.find((n) => n.path.endsWith(e) && n.key === t);
          break;
        default:
          throw `dictionaryAccessor.get: unknown GET_MODE ${r}`;
      }
    else
      o = this.dictionary.find((n) => n.key === t);
    if (o) {
      if (Array.isArray(o.value))
        return this.getListValue(s, o, e, t);
      if (s) {
        const n = this.getFromFMDict(s, o);
        if (n)
          return n;
      }
      return o.value;
    } else
      return;
  }
  /**
   * returns the value for a key from an FileMaker style dictionary
   * @param index They "key" into the FM Style dictionary
   * @param entry The FM style dictionary. A string like "key=value\rkey=value\rkey=value"...
   * @returns undefined if the FM Dictionary isn't valid
   *          the index itself if there is no matching key in the dictionary
   *          the value (a string) if the index matches a key in the dictionary
   * @private
   */
  getFromFMDict(e, t) {
    const r = D_(t.value);
    if (r)
      return r.hasOwnProperty(e) ? r[e] : e;
  }
  getListValue(e, t, r, s) {
    let o;
    if (e ? o = parseInt(e) : o = 1, !isNaN(o) && !(t.value.length < o))
      return t.value[o - 1];
  }
}
class I0 {
  constructor() {
    Oe(this, "_symbol", "");
  }
  interpret(e, t = "n") {
    throw "Not implemented";
  }
  get symbol() {
    return this._symbol;
  }
}
class D0 {
  constructor() {
    Oe(this, "INTERPRETER_SYMBOL", "#");
    Oe(this, "interpreters", /* @__PURE__ */ new Map());
  }
  addInterpreter(e) {
    if (!e.symbol)
      throw "Attempt to add an interpreter that has no interpreter symbol";
    this.interpreters.set(e.symbol, e);
  }
  interpret(e, t = "n", r = "\r") {
    if (!e || typeof e != "string" || e[0] !== this.INTERPRETER_SYMBOL)
      return e;
    let s = 1;
    (e[s] === "1" || e[s] === "n") && (t = e[1], s++);
    let o = e[s], n;
    switch (o === "(" ? (n = "#(" + e.substring(s + 1), o = ":") : n = e.substring(s + 1), o) {
      case "#":
        e = "#" + n;
        break;
      case "*":
        for (const a of this.interpreters.values())
          n = a.interpret(n, t);
        e = n;
        break;
      default:
        this.interpreters.has(o) && (e = this.interpreters.get(o).interpret(n, t));
    }
    return r !== "\r" && (e = e.replace(`
`, "").replace("\r", r)), e;
  }
}
class Za {
  constructor(e) {
    Oe(this, "_variables", /* @__PURE__ */ new Map());
    Oe(this, "_text", "");
    Oe(this, "_regex", /#\(.*?\)/g);
    this._text = e, this.parse();
  }
  static quicklySubstitute(e, t, r = "n") {
    if (typeof t != "function")
      throw "quicklySubstitute expects a callable callback but didn't get one.";
    const s = new Za(e);
    let o;
    if (r === "n")
      s.variableNames.forEach((n) => {
        let a = t(n);
        a && s.set(n, a);
      }), o = s.substitute();
    else {
      if (s.variableNames.length > 0) {
        const n = t(s.variableNames[0]);
        n && s.set(s.variableNames[0], n);
      }
      o = s.substituteOne();
    }
    return {}.VITE_DEBUG_PARSING === "TRUE" ? o || `?${e}` : o;
  }
  get variableNames() {
    return [...this._variables.keys()];
  }
  parse() {
    let e;
    for (this._variables.clear(); e = this._regex.exec(this._text); )
      this._variables.set(e[0].substring(2, e[0].length - 1), { index: e.index, value: void 0 });
    return this._variables.size;
  }
  set(e, t) {
    const r = this._variables.get(e);
    r.value = t;
  }
  get(e) {
    try {
      return this._variables.get(e).value;
    } catch {
      return;
    }
  }
  substitute(e = !1) {
    let t = this._text;
    return this._variables.forEach((r, s) => {
      (r.value || !e) && (t = t.replaceAll(`#(${s})`, r.value || ""));
    }), t;
  }
  substituteOne(e = !1) {
    let t = this._text;
    if (this._variables.has(this._text))
      return this._variables[t];
    for (const r of this._variables) {
      const s = r[0], o = r[1];
      if (o.value || !e) {
        t = t.replace(`#(${s})`, o.value || "");
        break;
      }
    }
    return t;
  }
}
class O0 extends I0 {
  constructor(t) {
    super();
    Oe(this, "_symbol", ":");
    Oe(this, "_dataProvider", (t) => t);
    t && (this._dataProvider = t);
  }
  set dataProvider(t) {
    this._dataProvider = t;
  }
  interpret(t, r = "n") {
    return Za.quicklySubstitute(t, this._dataProvider, r);
  }
}
function Ka(i) {
  const e = new O0((r) => i.get(r)), t = new D0();
  return t.addInterpreter(e), t;
}
var $0 = Object.defineProperty, P0 = Object.getOwnPropertyDescriptor, M0 = Object.getPrototypeOf, z0 = Reflect.get, tr = (i, e, t, r) => {
  for (var s = r > 1 ? void 0 : r ? P0(e, t) : e, o = i.length - 1, n; o >= 0; o--)
    (n = i[o]) && (s = (r ? n(e, t, s) : n(s)) || s);
  return r && s && $0(e, t, s), s;
}, N0 = (i, e, t) => z0(M0(i), t, e);
let Ee = class extends Xt {
  constructor() {
    super(), this.overall_record_count = -1, this.dataContext = new Re(), this.data = null, this.dataProvider = async (i, e) => {
      const { page: t, pageSize: r, sortOrders: s } = i;
      if (this._inputData) {
        const o = await this.fetchQueryResults({
          page: t + 1,
          pageSize: r,
          sortOrders: s,
          searchTerm: ""
        });
        let n, a;
        [n, a] = o, (a > 0 || t == 0) && (this.overall_record_count = a, this.requestUpdate()), e(n, this.overall_record_count);
      } else
        e([], 0);
    }, this.cellRenderer = (i, e, t) => {
      const r = t.getAttribute("data-column"), s = this.data.document_information.columns[r], o = this.getFormattedCellValue(i[r], s);
      return this.isIdentifier(r) ? p`
                <div class="identifier" data-column=${r} data-identifier="${i[r]}" 
                     @click="${this.gotoIdentifier}">
                    ${o}
                </div>` : p`
                <div>
                    ${o}
                </div>`;
    }, C("vaadin-grid", y`
      :host [part~="header-cell"] ::slotted(vaadin-grid-cell-content), [part~="footer-cell"] ::slotted(vaadin-grid-cell-content), [part~="reorder-ghost"] {
        font-weight: bold
      }
    `);
  }
  get interpreter() {
    return this._interpreter;
  }
  firstUpdated(i) {
    super.firstUpdated(i);
  }
  assignConstants() {
    if (this.constants) {
      const i = new Ya("dictionary", this.dataContext, this.constants);
      i.assignEntries(this.constants), this.dataContext.registerAccessor(i), this._interpreter = Ka(this.dataContext);
    }
  }
  apiLookupProvider(i, e, t, r) {
    this.apiContext.fetchFromApi("", "lookup", {
      method: "POST",
      caller: "structuredKioskQuery.apiLookupProvider",
      body: JSON.stringify(e)
    }).then((s) => {
      "result_msg" in s && s.result_msg !== "ok" ? r([], 0) : r(s.records, s.record_count);
    }).catch((s) => {
      Sr(this, s, "structuredKioskQuery.apiLookupProvider", null), r([], 0);
    });
  }
  async fetchQueryResults(i) {
    const e = {
      query_id: this.queryDefinition.id,
      inputs: this._inputData
    }, t = new URLSearchParams();
    t.append("page_size", i.pageSize.toString()), t.append("page", i.page.toString());
    try {
      const r = await this.apiContext.fetchFromApi(
        "",
        "kioskquery",
        {
          method: "POST",
          caller: "structuredKioskQuery.fetchQueryResults",
          body: JSON.stringify(e)
        },
        "v1",
        t
      );
      return "result_msg" in r && r.result_msg !== "ok" ? [null, 0] : (this.data = r, [r.records, this.data.overall_record_count]);
    } catch (r) {
      return Sr(this, r, "structuredKioskQuery.fetchQueryResults", null), [[], 0];
    }
  }
  updated(i) {
    super.updated(i), this.assignConstants();
    const e = this.renderRoot.querySelector("#ui");
    e.lookupProvider = this.apiLookupProvider.bind(this), e.dataProvider = (t, r) => this.interpreter.interpret(t) || t, e.uiSchema = this.uiSchema;
  }
  getQueryUiSchema(i) {
    this.uiSchema = {
      header: { version: 1 },
      dsd: this.queryDefinition.ui.dsd,
      layout_settings: {
        orchestration_strategy: "stack"
      },
      meta: {
        scenario: "query-ui"
      },
      ui_elements: {
        query_fields: {
          element_type: {
            name: "layout",
            layout_settings: {
              orchestration_strategy: "stack"
            },
            ui_elements: i
          }
        },
        query_ui_controls: {
          element_type: {
            name: "layout",
            layout_settings: {
              orchestration_strategy: "stack"
            },
            ui_elements: {
              line: {
                element_type: {
                  name: "line"
                }
              },
              buttons: {
                element_type: {
                  name: "layout",
                  layout_settings: {
                    orchestration_strategy: "rightalign"
                  },
                  ui_elements: {
                    start: {
                      element_type: {
                        name: "button",
                        type: "iconButton",
                        icon: "",
                        extra_style: "padding: 2px 2px 0px 0px"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    };
  }
  willUpdate(i) {
    i.has("queryDefinition") && this.queryDefinition && this.getQueryUiSchema(this.queryDefinition.ui.ui_elements);
  }
  queryUIChanged(i) {
    var e;
    i.detail.srcElement === "start" && (this.overall_record_count = -1, this._inputData = i.detail.newData, (e = this.grid) == null || e.clearCache());
  }
  isIdentifier(i) {
    const e = this.data.document_information.columns[i];
    return "identifier" in e && e.identifier;
  }
  getColumnLabel(i) {
    const e = this.data.document_information.columns[i];
    return "label" in e ? e.label : i;
  }
  gotoIdentifier(i) {
    const e = i.currentTarget, t = e.getAttribute("data-identifier"), r = e.getAttribute("data-column"), s = this.data.document_information.columns[r], o = s.table, n = s.field, a = new CustomEvent(
      "identifierClicked",
      {
        detail: {
          dsdName: n,
          tableName: o,
          identifier: t
        },
        bubbles: !0
      }
    );
    this.dispatchEvent(a);
  }
  getFormattedCellValue(i, e) {
    switch (e.datatype) {
      case "date":
        try {
          return rc(x.fromISO(i), !1);
        } catch {
          return "";
        }
      case "datetime":
        try {
          return rc(x.fromISO(i), !0);
        } catch {
          return "";
        }
    }
    return i;
  }
  headerRenderer(i) {
    return p`<div>${this.interpreter.interpret(this.getColumnLabel(i.getAttribute("data-column")), void 0, "/")}</div>`;
  }
  renderQueryResult() {
    return p`
        <vaadin-grid id="grid" .dataProvider="${this.dataProvider}" theme="no-border">
            ${this.data ? this.data.document_information.column_order.map(
      (i) => p`
                    <vaadin-grid-column 
                                        data-column="${i}"
                                        ${T0(this.headerRenderer, [])}
                                        ${S0(this.cellRenderer, [])}></vaadin-grid-column>
                `
    ) : p`<vaadin-grid-column></vaadin-grid-column>`}
            
        </vaadin-grid>`;
  }
  apiRender() {
    return p`
            <div class="kiosk-query-ui">
                <ui-component id="ui" @dataChanged="${this.queryUIChanged}"></ui-component>
            </div>
            <div class="kiosk-query-results">
                ${this._inputData ? this.renderQueryResult() : b}
                ${!this._inputData || this.overall_record_count != 0 ? b : p`
                    <div class="no-records"><div><i></i>Sorry, your query yielded no results.</div></div>`}
            </div>
        `;
  }
};
Ee.styles = tt(M_);
Ee.properties = {
  ...N0(Ee, Ee, "properties")
};
tr([
  G()
], Ee.prototype, "queryDefinition", 2);
tr([
  z()
], Ee.prototype, "uiSchema", 2);
tr([
  z()
], Ee.prototype, "_inputData", 2);
tr([
  Dm("#grid")
], Ee.prototype, "grid", 2);
tr([
  z()
], Ee.prototype, "data", 2);
tr([
  to({ context: ro }),
  z()
], Ee.prototype, "constants", 2);
Ee = tr([
  Qt("structured-kiosk-query")
], Ee);
class mi {
  static getTypeIcon(e) {
    switch (e.toLowerCase()) {
      case "structuredkioskquery":
        return "";
      default:
        return "";
    }
  }
  static getKioskQueryTag(e) {
    switch (e.toLowerCase()) {
      case "structuredkioskquery":
        return this.tagKioskStructuredQuery;
      default:
        return null;
    }
  }
}
mi.tagKioskStructuredQuery = xm`structured-kiosk-query`;
const F0 = "query-ui";
var R0 = Object.defineProperty, L0 = Object.getOwnPropertyDescriptor, V0 = Object.getPrototypeOf, H0 = Reflect.get, Gi = (i, e, t, r) => {
  for (var s = r > 1 ? void 0 : r ? L0(e, t) : e, o = i.length - 1, n; o >= 0; o--)
    (n = i[o]) && (s = (r ? n(e, t, s) : n(s)) || s);
  return r && s && R0(e, t, s), s;
}, B0 = (i, e, t) => H0(V0(i), t, e);
let qe = class extends Xt {
  constructor() {
    super(...arguments), this.dataContext = new Re(), this.showLocalProgress = !1, this.loadingMessage = "", this.kioskQueries = [];
  }
  firstUpdated(i) {
    super.firstUpdated(i);
  }
  updated(i) {
    super.updated(i), i.has("apiContext") && this.apiContext && this.loadQueries();
  }
  assignConstants() {
    if (this.constants.length > 0 && !this.dataContext.hasAccessor("dictionary")) {
      const i = new Ya("dictionary", this.dataContext, this.constants);
      i.assignEntries(this.constants), this.dataContext.registerAccessor(i), this._interpreter = Ka(this.dataContext);
    }
  }
  loadQueries() {
    this.loadingMessage = "loading queries ...", this.showLocalProgress = !0;
    const i = new URLSearchParams();
    i.append("uic_literal", F0), this.apiContext.fetchFromApi(
      "",
      "kioskquery",
      {
        method: "GET",
        caller: "kioskqueryselector.loadQueries"
      },
      "v1",
      i
    ).then((e) => {
      "result_msg" in e && e.result_msg !== "ok" || this.showQueries(e);
    }).catch((e) => {
      Sr(this, e, "kioskqueryselector.loadQueries", null);
    });
  }
  initQueries() {
    for (const i of this.kioskQueries)
      i.name = this._interpreter.interpret(i.name, void 0, "/");
  }
  showQueries(i) {
    this.constants && this.assignConstants(), this.showLocalProgress = !1, this.kioskQueries = i, this.initQueries();
  }
  overlayClicked() {
    this.tryClose();
  }
  connectedCallback() {
    super.connectedCallback();
  }
  tryClose(i = null) {
    const e = new CustomEvent("closeSelection", i ? {
      detail: i
    } : { detail: null });
    this.dispatchEvent(e);
  }
  selectQuery(i) {
    if (!(i.currentTarget instanceof HTMLDivElement))
      return;
    const e = i.currentTarget;
    let t = this.kioskQueries.find((r) => r.id === e.id);
    this.tryClose(t);
  }
  renderQueryItem(i) {
    return p`
            <div id="${i.id}" class="kiosk-query" @click="${this.selectQuery}">
                <i class="fas">${mi.getTypeIcon(i.type)}</i>
                <div class="kiosk-query-text">
                    <div>${i.name}</div>
                    <div>${this._interpreter.interpret(i.description, void 0, "/")}</div>
                </div>
            </div>
        `;
  }
  apiRender() {
    return p`
            <div class="query-selector-overlay" @click=${this.overlayClicked}></div>
            <div class="query-selector">
                ${this.showLocalProgress || !this.constants ? this.renderProgress(!0) : p`
                          <div class="kiosk-query-selector-title-bar" @click="${this.overlayClicked}">
                              <i class="fas fa-xmark"></i>
                          </div>
                          <div class="kiosk-query-selector-headline">
                              <i class="fas fa-query"></i>
                              <h3>Choose your way to search and query</h3>
                          </div>
                      `}
                <div id="kiosk-query-list">${this.kioskQueries.map((i) => this.renderQueryItem(i))}</div>
            </div>
        `;
  }
  renderProgress(i = !1) {
    let e = super.renderProgress(i);
    return e ? p`${e}
                  <div class="loading-message">${this.loadingMessage}</div>` : p``;
  }
};
qe.styles = tt(Om);
qe.properties = {
  ...B0(qe, qe, "properties")
};
Gi([
  z()
], qe.prototype, "showLocalProgress", 2);
Gi([
  z()
], qe.prototype, "loadingMessage", 2);
Gi([
  z()
], qe.prototype, "kioskQueries", 2);
Gi([
  to({ context: ro }),
  z()
], qe.prototype, "constants", 2);
qe = Gi([
  Qt("kiosk-query-selector")
], qe);
const U0 = `:host *{-webkit-user-select:none;user-select:none}.query-selector-overlay{position:fixed;min-width:100%;min-height:100%;top:0;left:0;right:0;bottom:0;background-color:#00000080;z-index:2;cursor:pointer}.query-selector{position:relative;background-color:var(--col-bg-1);margin:2em;min-height:200px;width:calc(100% - 4em);z-index:3;padding:1em;-webkit-user-select:none;user-select:none;overflow-y:auto}.kiosk-query-selector-title-bar{position:sticky;top:0;text-align:right;z-index:2}.kiosk-query-selector-title-bar i{line-height:var(--font-size-h3);font-size:var(--font-size-h3)}.kiosk-query-selector-title-bar i:hover{color:var(--col-accent-bg-1)}.kiosk-query-selector-headline{position:sticky;background-color:var(--col-bg-1);top:0;display:flex;align-items:center;border-bottom:1px solid var(--col-bg-1-darker);padding-bottom:1em;margin-bottom:1em}.kiosk-query-selector-headline h3{margin-left:.5em}.kiosk-query-selector-headline i{font-size:var(--font-size-h2)}#kiosk-query-list{display:grid;width:100%;grid-template-columns:repeat(auto-fill,minmax(350px,1fr));grid-column-gap:1em;grid-row-gap:.3em}.kiosk-query{display:flex;align-items:center;padding-bottom:.2em;margin-bottom:.2em;color:var(--col-primary-bg-1)}.kiosk-query:hover{color:var(--col-accent-bg-1)}.kiosk-query:active{background-color:var(--col-bg-1-darker)}.kiosk-query i{font-size:var(--font-size-h3)}.kiosk-query .kiosk-query-text{margin-left:1em;display:flex;flex-direction:column}.kiosk-query .kiosk-query-text div{color:inherit;font-size:var(--font-size-standard, 1rem)}.kiosk-query .kiosk-query-text div:first-child{font-size:var(--font-size-h4);font-weight:700}.col-bg-body-lighter{background-color:var(--col-bg-body-lighter)}.col-bg-body{background-color:var(--col-bg-body)}.col-bg-body-darker{background-color:var(--col-bg-body-darker)}.col-bg-1-lighter{background-color:var(--col-bg-1-lighter)}.col-bg-1{background-color:var(--col-bg-1)}.col-bg-1-darker{background-color:var(--col-bg-1-darker)}.col-bg-1-input{background-color:var(--col-bg-1-input)}.col-primary-bg-1{background-color:var(--col-primary-bg-1)}.col-accent-bg-1{background-color:var(--col-accent-bg-1)}.col-success-bg-1{background-color:var(--col-success-bg-1)}.col-warning-bg-1{background-color:var(--col-warning-bg-1)}.col-error-bg-1{background-color:var(--col-error-bg-1)}.col-bg-2-lighter{background-color:var(--col-bg-2-lighter)}.col-bg-2{background-color:var(--col-bg-2)}.col-bg-2-darker{background-color:var(--col-bg-2-darker)}.col-bg-2-button{background-color:var(--col-bg-2-button)}.col-bg-2-input{background-color:var(--col-bg-2-input)}.col-primary-bg-2{background-color:var(--col-primary-bg-2)}.col-accent-bg-2{background-color:var(--col-accent-bg-2)}.col-success-bg-2{background-color:var(--col-success-bg-2)}.col-warning-bg-2{background-color:var(--col-warning-bg-2)}.col-error-bg-2{background-color:var(--col-error-bg-2)}.col-bg-3-lighter{background-color:var(--col-bg-3-lighter)}.col-bg-3{background-color:var(--col-bg-3)}.col-bg-3-darker{background-color:var(--col-bg-3-darker)}.col-bg-3-button{background-color:var(--col-bg-3-button)}.col-bg-3-input{background-color:var(--col-bg-3-input)}.col-primary-bg-3{background-color:var(--col-primary-bg-3)}.col-accent-bg-3{background-color:var(--col-accent-bg-3)}.col-success-bg-3{background-color:var(--col-success-bg-3)}.col-warning-bg-3{background-color:var(--col-warning-bg-3)}.col-error-bg-3{background-color:var(--col-error-bg-3)}.col-bg-ack-lighter{background-color:var(--col-bg-ack-lighter)}.col-bg-ack{background-color:var(--col-bg-ack)}.col-bg-ack-darker{background-color:var(--col-bg-ack-darker)}.col-primary-bg-ack{background-color:var(--col-primary-bg-ack)}.col-accent-bg-ack{background-color:var(--col-accent-bg-ack)}.col-bg-att-lighter{background-color:var(--col-bg-att-lighter)}.col-bg-att{background-color:var(--col-bg-att)}.col-bg-att-darker{background-color:var(--col-bg-att-darker)}.col-primary-bg-att{background-color:var(--col-primary-bg-att)}.col-accent-bg-att{background-color:var(--col-accent-bg-att)}.col-bg-alert-lighter{background-color:var(--col-bg-alert-lighter)}.col-bg-alert{background-color:var(--col-bg-alert)}.col-bg-alert-darker{background-color:var(--col-bg-alert-darker)}.col-primary-bg-alert{background-color:var(--col-primary-bg-alert)}.col-accent-bg-alert{background-color:var(--col-accent-bg-alert)}.col-bg-btn-lighter{background-color:var(--col-bg-btn-lighter)}.col-bg-btn{background-color:var(--col-bg-btn)}.col-bg-btn-darker{background-color:var(--col-bg-btn-darker)}.col-primary-bg-btn{background-color:var(--col-primary-bg-btn)}.col-accent-bg-btn{background-color:var(--col-accent-bg-btn)}.pattern-diagonal-stripes-sm{background:repeating-linear-gradient(45deg,transparent,transparent 10px,currentColor 10px,currentColor 20px)}.pattern-dots-lg{background-image:radial-gradient(currentColor 1.5px,transparent 1.5px);background-size:15px 15px}.pattern-dots-md{background-image:radial-gradient(currentColor 1px,transparent 1px);background-size:8px 8px}.pattern-dots-medium-dense{background-image:radial-gradient(currentColor .5px,transparent .5px);background-size:3px 3px}.pattern-dots-sm{background-image:radial-gradient(currentColor .5px,transparent .5px);background-size:5px 5px}.pattern-cross-dots-md,.imagelist-background{background-image:radial-gradient(currentColor .7px,transparent 1px),radial-gradient(currentColor .7px,transparent 1px);background-size:6.5px 6.5px;background-position:0 0,3.5px 3.5px}.imagelist-background{background-color:#fff9;background-blend-mode:overlay}*{box-sizing:border-box}.loading{display:flex;justify-content:center;align-content:center;height:5px;background-color:#000;width:100%}.loading-progress{height:5px;width:100%;border-radius:3px;background:linear-gradient(90deg,red 0%,yellow 15%,lime 30%,cyan 50%,blue 65%,magenta 80%,red 100%);background-size:200%;animation:move-gradient 2s ease-in infinite}.loading-message{font-family:var(--monospace-font);text-align:center;width:100%;color:var(--col-accent-bg-1);padding:1em}@keyframes move-gradient{0%{background-position:0 0}to{background-position:-200% 0%}}p,div{padding:0;margin:0;border:0px;-webkit-user-select:text;user-select:text}select{-webkit-user-select:none;user-select:none}.fa,.fas{font-family:"Font Awesome 6 Free";font-weight:900;font-style:normal}.fa-trash:before{content:""}.fa-view-grid:before{content:""}.fa-reload:before{content:""}.fa-view-list:before{content:""}.fa-camera:before{content:""}.fa-view-image:before{content:""}.fa-check:before{content:""}.fa-bug:before{content:""}.fa-lightbulb:before{content:""}.fa-query:before{content:""}.fa-footsteps{transform:rotate(270deg)}.fa-footsteps:before{content:""}i{font-family:"Font Awesome 6 Free";font-style:normal;font-variant:normal;text-rendering:auto;-webkit-font-smoothing:antialiased;font-weight:900;font-size:.9em}.select-identifier-popup-content{background-color:var(--col-bg-1);max-width:800px;padding:1em;margin:auto;position:relative;z-index:3}.identifier-list-area{max-height:calc(70vh - 200px);overflow-y:auto;display:grid;width:100%;grid-template-columns:repeat(auto-fill,minmax(350px,1fr));grid-column-gap:1em;grid-row-gap:.3em;margin-top:.5em;background-color:var(--col-bg-2);color:var(--col-primary-bg-2)}.identifier{text-decoration:underline;text-decoration-style:dotted;cursor:pointer;color:var(--col-accent-bg-2)}
`, uf = "identifierInfoContext";
var q0 = Object.defineProperty, W0 = Object.getOwnPropertyDescriptor, j0 = Object.getPrototypeOf, G0 = Reflect.get, Rr = (i, e, t, r) => {
  for (var s = r > 1 ? void 0 : r ? W0(e, t) : e, o = i.length - 1, n; o >= 0; o--)
    (n = i[o]) && (s = (r ? n(e, t, s) : n(s)) || s);
  return r && s && q0(e, t, s), s;
}, Y0 = (i, e, t) => G0(j0(i), t, e);
let Le = class extends Xt {
  constructor() {
    super(...arguments), this.dataContext = new Re(), this.firstRenderDone = !1, this.searchTerm = "", this.displayLines = [], this.kioskQueries = [], this.identifierInfo = [], this.recordTypeAliases = {};
  }
  firstUpdated(i) {
    super.firstUpdated(i);
  }
  updated(i) {
    super.updated(i), i.has("shown") && this.shown && this.renderRoot.querySelector("#input-identifier").focus();
  }
  overlayClicked() {
    this.tryClose();
  }
  connectedCallback() {
    super.connectedCallback();
  }
  tryClose(i = null) {
    const e = new CustomEvent("closeSelection", { detail: i });
    this.dispatchEvent(e);
  }
  getRecordTypeAlias(i) {
    const e = this.recordTypeAliases[i];
    return e || i;
  }
  gotoIdentifier(i) {
    const e = i.currentTarget, t = e.getAttribute("data-identifier"), r = e.getAttribute("data-table"), s = e.getAttribute("data-field");
    this.tryClose(
      {
        dsdName: s,
        tableName: r,
        identifier: t
      }
    );
  }
  async searchIdentifiers() {
    const e = this.searchTerm.toLowerCase();
    let t;
    const r = this.identifierInfo;
    if (!this.identifierInfo || this.identifierInfo.length == 0)
      return;
    function s(o) {
      t = [];
      for (const n of r) {
        if (t.length > 30)
          break;
        o(n) && t.push(n);
      }
      return t.length <= 30;
    }
    if (s((o) => o.identifier.toLowerCase().indexOf(e) > -1)) {
      this.displayLines = t;
      return;
    }
    if (s((o) => o.identifier.toLowerCase().startsWith(e))) {
      this.displayLines = t;
      return;
    }
    if (s((o) => o.identifier.toLowerCase() === e)) {
      this.displayLines = t;
      return;
    }
  }
  searchTermChanged(i) {
    const e = i.target;
    this.searchTerm = e.value, this.searchIdentifiers();
  }
  renderIdInfo(i) {
    return p`
            <div class="identifier" 
                         data-identifier="${i.identifier}" 
                         data-table="${i.record_type}" 
                         data-field="${i.field}" 
                         @click="${this.gotoIdentifier}">${i.identifier}</div>
            <div class="record-type">
                ${this.getRecordTypeAlias(i.record_type)}
            </div>`;
  }
  apiRender() {
    return p`
            <div class="query-selector-overlay" @click=${this.overlayClicked}></div>
                <div class="select-identifier-popup-content">
                    <div class="kiosk-query-selector-title-bar" @click="${this.overlayClicked}">
                        <i class="fas fa-xmark"></i>
                    </div>
                    <div class="kiosk-query-selector-headline">
                        <i class="fas fa-footsteps"></i>
                        <h3>Search and Select an Archaeological Identifier</h3>
                    </div>
                    <div class="identifier-search-area">
                        <label for="input-identifier">search for</label>
                        <input name="input-identifier" id="input-identifier" type="text" value="${this.searchTerm}" 
                               @input="${this.searchTermChanged}"/>
                    </div>
                    <div class="identifier-list-area">
                        ${this.displayLines.map((i) => this.renderIdInfo(i))}
                    </div>
                </div>
        `;
  }
  // renderProgress(force: boolean = false): TemplateResult {
  //     let htmlBar = super.renderProgress(force);
  //     return htmlBar
  //         ? html`${htmlBar}
  //               <div class="loading-message">${this.loadingMessage}</div>`
  //         : html``;
  // }
};
Le.styles = tt(U0);
Le.properties = {
  ...Y0(Le, Le, "properties")
};
Rr([
  z()
], Le.prototype, "displayLines", 2);
Rr([
  z()
], Le.prototype, "kioskQueries", 2);
Rr([
  to({ context: uf, subscribe: !0 }),
  z()
], Le.prototype, "identifierInfo", 2);
Rr([
  G()
], Le.prototype, "shown", 2);
Rr([
  G()
], Le.prototype, "recordTypeAliases", 2);
Le = Rr([
  Qt("select-identifier-popup")
], Le);
var Zn = "";
function Kn(i) {
  Zn = i;
}
function Z0(i = "") {
  if (!Zn) {
    const e = [...document.getElementsByTagName("script")], t = e.find((r) => r.hasAttribute("data-shoelace"));
    if (t)
      Kn(t.getAttribute("data-shoelace"));
    else {
      const r = e.find((o) => /shoelace(\.min)?\.js($|\?)/.test(o.src) || /shoelace-autoloader(\.min)?\.js($|\?)/.test(o.src));
      let s = "";
      r && (s = r.getAttribute("src")), Kn(s.split("/").slice(0, -1).join("/"));
    }
  }
  return Zn.replace(/\/$/, "") + (i ? `/${i.replace(/^\//, "")}` : "");
}
var hf = Object.defineProperty, K0 = Object.getOwnPropertyDescriptor, Vc = Object.getOwnPropertySymbols, Q0 = Object.prototype.hasOwnProperty, J0 = Object.prototype.propertyIsEnumerable, Hc = (i, e, t) => e in i ? hf(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[e] = t, Qa = (i, e) => {
  for (var t in e || (e = {}))
    Q0.call(e, t) && Hc(i, t, e[t]);
  if (Vc)
    for (var t of Vc(e))
      J0.call(e, t) && Hc(i, t, e[t]);
  return i;
}, A = (i, e, t, r) => {
  for (var s = r > 1 ? void 0 : r ? K0(e, t) : e, o = i.length - 1, n; o >= 0; o--)
    (n = i[o]) && (s = (r ? n(e, t, s) : n(s)) || s);
  return r && s && hf(e, t, s), s;
};
const X0 = `.col-bg-body-lighter{background-color:var(--col-bg-body-lighter)}.col-bg-body{background-color:var(--col-bg-body)}.col-bg-body-darker{background-color:var(--col-bg-body-darker)}.col-bg-1-lighter{background-color:var(--col-bg-1-lighter)}.col-bg-1{background-color:var(--col-bg-1)}.col-bg-1-darker{background-color:var(--col-bg-1-darker)}.col-bg-1-input{background-color:var(--col-bg-1-input)}.col-primary-bg-1{background-color:var(--col-primary-bg-1)}.col-accent-bg-1{background-color:var(--col-accent-bg-1)}.col-success-bg-1{background-color:var(--col-success-bg-1)}.col-warning-bg-1{background-color:var(--col-warning-bg-1)}.col-error-bg-1{background-color:var(--col-error-bg-1)}.col-bg-2-lighter{background-color:var(--col-bg-2-lighter)}.col-bg-2{background-color:var(--col-bg-2)}.col-bg-2-darker{background-color:var(--col-bg-2-darker)}.col-bg-2-button{background-color:var(--col-bg-2-button)}.col-bg-2-input{background-color:var(--col-bg-2-input)}.col-primary-bg-2{background-color:var(--col-primary-bg-2)}.col-accent-bg-2{background-color:var(--col-accent-bg-2)}.col-success-bg-2{background-color:var(--col-success-bg-2)}.col-warning-bg-2{background-color:var(--col-warning-bg-2)}.col-error-bg-2{background-color:var(--col-error-bg-2)}.col-bg-3-lighter{background-color:var(--col-bg-3-lighter)}.col-bg-3{background-color:var(--col-bg-3)}.col-bg-3-darker{background-color:var(--col-bg-3-darker)}.col-bg-3-button{background-color:var(--col-bg-3-button)}.col-bg-3-input{background-color:var(--col-bg-3-input)}.col-primary-bg-3{background-color:var(--col-primary-bg-3)}.col-accent-bg-3{background-color:var(--col-accent-bg-3)}.col-success-bg-3{background-color:var(--col-success-bg-3)}.col-warning-bg-3{background-color:var(--col-warning-bg-3)}.col-error-bg-3{background-color:var(--col-error-bg-3)}.col-bg-ack-lighter{background-color:var(--col-bg-ack-lighter)}.col-bg-ack{background-color:var(--col-bg-ack)}.col-bg-ack-darker{background-color:var(--col-bg-ack-darker)}.col-primary-bg-ack{background-color:var(--col-primary-bg-ack)}.col-accent-bg-ack{background-color:var(--col-accent-bg-ack)}.col-bg-att-lighter{background-color:var(--col-bg-att-lighter)}.col-bg-att{background-color:var(--col-bg-att)}.col-bg-att-darker{background-color:var(--col-bg-att-darker)}.col-primary-bg-att{background-color:var(--col-primary-bg-att)}.col-accent-bg-att{background-color:var(--col-accent-bg-att)}.col-bg-alert-lighter{background-color:var(--col-bg-alert-lighter)}.col-bg-alert{background-color:var(--col-bg-alert)}.col-bg-alert-darker{background-color:var(--col-bg-alert-darker)}.col-primary-bg-alert{background-color:var(--col-primary-bg-alert)}.col-accent-bg-alert{background-color:var(--col-accent-bg-alert)}.col-bg-btn-lighter{background-color:var(--col-bg-btn-lighter)}.col-bg-btn{background-color:var(--col-bg-btn)}.col-bg-btn-darker{background-color:var(--col-bg-btn-darker)}.col-primary-bg-btn{background-color:var(--col-primary-bg-btn)}.col-accent-bg-btn{background-color:var(--col-accent-bg-btn)}.pattern-diagonal-stripes-sm{background:repeating-linear-gradient(45deg,transparent,transparent 10px,currentColor 10px,currentColor 20px)}.pattern-dots-lg{background-image:radial-gradient(currentColor 1.5px,transparent 1.5px);background-size:15px 15px}.pattern-dots-md{background-image:radial-gradient(currentColor 1px,transparent 1px);background-size:8px 8px}.pattern-dots-medium-dense{background-image:radial-gradient(currentColor .5px,transparent .5px);background-size:3px 3px}.pattern-dots-sm{background-image:radial-gradient(currentColor .5px,transparent .5px);background-size:5px 5px}.pattern-cross-dots-md,.imagelist-background{background-image:radial-gradient(currentColor .7px,transparent 1px),radial-gradient(currentColor .7px,transparent 1px);background-size:6.5px 6.5px;background-position:0 0,3.5px 3.5px}.imagelist-background{background-color:#fff9;background-blend-mode:overlay}p,div{padding:0;margin:0;border:0px;-webkit-user-select:text;user-select:text}select{-webkit-user-select:none;user-select:none}.fa,.fas{font-family:"Font Awesome 6 Free";font-weight:900;font-style:normal}.fa-trash:before{content:""}.fa-view-grid:before{content:""}.fa-reload:before{content:""}.fa-view-list:before{content:""}.fa-camera:before{content:""}.fa-view-image:before{content:""}.fa-check:before{content:""}.fa-bug:before{content:""}.fa-lightbulb:before{content:""}.fa-query:before{content:""}.fa-footsteps{transform:rotate(270deg)}.fa-footsteps:before{content:""}i{font-family:"Font Awesome 6 Free";font-style:normal;font-variant:normal;text-rendering:auto;-webkit-font-smoothing:antialiased;font-weight:900;font-size:.9em}:host{display:block;width:100%}div,p{font-family:var(--standard-text-font)}.dev-tool-bar{background-color:var(--col-bg-att);display:flex;flex-direction:row;align-items:center;height:32px}.dev-tool-bar>label:first-child{display:block;width:auto;white-space:nowrap}.dev-tool-bar button{margin:0px .5rem;width:40px;height:26px;font-size:12px;font-weight:400}.dev-open-identifier{display:inline-block;padding:0 1em;margin:0 5px;background-color:var(--col-bg-att-darker)}.dev-open-identifier:hover{background-color:var(--col-bg-att-lighter)}.dev-open-identifier:active{background-color:var(--col-bg-ack)}.center-div{display:flex;flex-direction:column;align-items:center;background:var(--col-bg-body)}.wait-for-login{display:grid;place-items:center;height:100vh;background-color:var(--col-bg-body)}.wait-for-login p{font-family:var(--headline-text-font);font-size:var(--font-size-h2)}.logged-in-message{background-color:var(--col-bg-ack);color:var(--col-primary-bg-ack);display:grid;place-items:center;font-family:var(--standard-text-font)}.development{background-color:#8b0000;color:#fff;font-family:Courier New,sans-serif;font-size:18px;text-align:center}.toolbar{height:3em;background:var(--col-bg-3);display:flex;flex-direction:row;justify-content:space-between;padding:0}.toolbar-section,#toolbar-buttons,#toolbar-left{height:100%;display:flex;flex-direction:row;align-items:center;padding-left:1em}#toolbar-left{flex-grow:1;border-right:1px solid var(--col-bg-body)}#toolbar-buttons{background-color:var(--col-bg-3-darker)}.splitter{height:8px;background-color:var(--col-bg-body)}.toolbar-button{color:var(--col-primary-bg-3);height:28px;border:None}.toolbar-button i{font-size:28px;line-height:100%}.toolbar-button:hover{color:var(--col-accent-bg-3)}.toolbar-button:active{color:var(--col-bg-ack)}.toolbar-button.disabled{opacity:.3}.footstep-toolbar-button{height:22px}.footstep-toolbar-button i{font-size:22px}
`;
let ew = (i = 21) => crypto.getRandomValues(new Uint8Array(i)).reduce((e, t) => (t &= 63, t < 36 ? e += t.toString(36) : t < 62 ? e += (t - 26).toString(36).toUpperCase() : t > 62 ? e += "-" : e += "_", e), "");
const tw = `.col-bg-body-lighter{background-color:var(--col-bg-body-lighter)}.col-bg-body{background-color:var(--col-bg-body)}.col-bg-body-darker{background-color:var(--col-bg-body-darker)}.col-bg-1-lighter{background-color:var(--col-bg-1-lighter)}.col-bg-1{background-color:var(--col-bg-1)}.col-bg-1-darker{background-color:var(--col-bg-1-darker)}.col-bg-1-input{background-color:var(--col-bg-1-input)}.col-primary-bg-1{background-color:var(--col-primary-bg-1)}.col-accent-bg-1{background-color:var(--col-accent-bg-1)}.col-success-bg-1{background-color:var(--col-success-bg-1)}.col-warning-bg-1{background-color:var(--col-warning-bg-1)}.col-error-bg-1{background-color:var(--col-error-bg-1)}.col-bg-2-lighter{background-color:var(--col-bg-2-lighter)}.col-bg-2{background-color:var(--col-bg-2)}.col-bg-2-darker{background-color:var(--col-bg-2-darker)}.col-bg-2-button{background-color:var(--col-bg-2-button)}.col-bg-2-input{background-color:var(--col-bg-2-input)}.col-primary-bg-2{background-color:var(--col-primary-bg-2)}.col-accent-bg-2{background-color:var(--col-accent-bg-2)}.col-success-bg-2{background-color:var(--col-success-bg-2)}.col-warning-bg-2{background-color:var(--col-warning-bg-2)}.col-error-bg-2{background-color:var(--col-error-bg-2)}.col-bg-3-lighter{background-color:var(--col-bg-3-lighter)}.col-bg-3{background-color:var(--col-bg-3)}.col-bg-3-darker{background-color:var(--col-bg-3-darker)}.col-bg-3-button{background-color:var(--col-bg-3-button)}.col-bg-3-input{background-color:var(--col-bg-3-input)}.col-primary-bg-3{background-color:var(--col-primary-bg-3)}.col-accent-bg-3{background-color:var(--col-accent-bg-3)}.col-success-bg-3{background-color:var(--col-success-bg-3)}.col-warning-bg-3{background-color:var(--col-warning-bg-3)}.col-error-bg-3{background-color:var(--col-error-bg-3)}.col-bg-ack-lighter{background-color:var(--col-bg-ack-lighter)}.col-bg-ack{background-color:var(--col-bg-ack)}.col-bg-ack-darker{background-color:var(--col-bg-ack-darker)}.col-primary-bg-ack{background-color:var(--col-primary-bg-ack)}.col-accent-bg-ack{background-color:var(--col-accent-bg-ack)}.col-bg-att-lighter{background-color:var(--col-bg-att-lighter)}.col-bg-att{background-color:var(--col-bg-att)}.col-bg-att-darker{background-color:var(--col-bg-att-darker)}.col-primary-bg-att{background-color:var(--col-primary-bg-att)}.col-accent-bg-att{background-color:var(--col-accent-bg-att)}.col-bg-alert-lighter{background-color:var(--col-bg-alert-lighter)}.col-bg-alert{background-color:var(--col-bg-alert)}.col-bg-alert-darker{background-color:var(--col-bg-alert-darker)}.col-primary-bg-alert{background-color:var(--col-primary-bg-alert)}.col-accent-bg-alert{background-color:var(--col-accent-bg-alert)}.col-bg-btn-lighter{background-color:var(--col-bg-btn-lighter)}.col-bg-btn{background-color:var(--col-bg-btn)}.col-bg-btn-darker{background-color:var(--col-bg-btn-darker)}.col-primary-bg-btn{background-color:var(--col-primary-bg-btn)}.col-accent-bg-btn{background-color:var(--col-accent-bg-btn)}.pattern-diagonal-stripes-sm{background:repeating-linear-gradient(45deg,transparent,transparent 10px,currentColor 10px,currentColor 20px)}.pattern-dots-lg{background-image:radial-gradient(currentColor 1.5px,transparent 1.5px);background-size:15px 15px}.pattern-dots-md{background-image:radial-gradient(currentColor 1px,transparent 1px);background-size:8px 8px}.pattern-dots-medium-dense{background-image:radial-gradient(currentColor .5px,transparent .5px);background-size:3px 3px}.pattern-dots-sm{background-image:radial-gradient(currentColor .5px,transparent .5px);background-size:5px 5px}.pattern-cross-dots-md,.imagelist-background{background-image:radial-gradient(currentColor .7px,transparent 1px),radial-gradient(currentColor .7px,transparent 1px);background-size:6.5px 6.5px;background-position:0 0,3.5px 3.5px}.imagelist-background{background-color:#fff9;background-blend-mode:overlay}*{box-sizing:border-box}.loading{display:flex;justify-content:center;align-content:center;height:5px;background-color:#000;width:100%}.loading-progress{height:5px;width:100%;border-radius:3px;background:linear-gradient(90deg,red 0%,yellow 15%,lime 30%,cyan 50%,blue 65%,magenta 80%,red 100%);background-size:200%;animation:move-gradient 2s ease-in infinite}.loading-message{font-family:var(--monospace-font);text-align:center;width:100%;color:var(--col-accent-bg-1);padding:1em}@keyframes move-gradient{0%{background-position:0 0}to{background-position:-200% 0%}}p,div{padding:0;margin:0;border:0px;-webkit-user-select:text;user-select:text}select{-webkit-user-select:none;user-select:none}.fa,.fas{font-family:"Font Awesome 6 Free";font-weight:900;font-style:normal}.fa-trash:before{content:""}.fa-view-grid:before{content:""}.fa-reload:before{content:""}.fa-view-list:before{content:""}.fa-camera:before{content:""}.fa-view-image:before{content:""}.fa-check:before{content:""}.fa-bug:before{content:""}.fa-lightbulb:before{content:""}.fa-query:before{content:""}.fa-footsteps{transform:rotate(270deg)}.fa-footsteps:before{content:""}i{font-family:"Font Awesome 6 Free";font-style:normal;font-variant:normal;text-rendering:auto;-webkit-font-smoothing:antialiased;font-weight:900;font-size:.9em}:host *{-webkit-user-select:none;user-select:none}.kiosk-query-layouter{background-color:var(--col-bg-1)}sl-tab-group{--sl-color-neutral-600: var(--col-primary-bg-1);--sl-color-primary-600: var(--col-accent-bg-1);--indicator-color: var(--col-success-bg-1);--track-color: var(--col-bg-1-darker)}sl-tab-panel{padding:.5em 1em}
`;
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const ks = globalThis, Ja = ks.ShadowRoot && (ks.ShadyCSS === void 0 || ks.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, Xa = Symbol(), Bc = /* @__PURE__ */ new WeakMap();
let ff = class {
  constructor(e, t, r) {
    if (this._$cssResult$ = !0, r !== Xa)
      throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = e, this.t = t;
  }
  get styleSheet() {
    let e = this.o;
    const t = this.t;
    if (Ja && e === void 0) {
      const r = t !== void 0 && t.length === 1;
      r && (e = Bc.get(t)), e === void 0 && ((this.o = e = new CSSStyleSheet()).replaceSync(this.cssText), r && Bc.set(t, e));
    }
    return e;
  }
  toString() {
    return this.cssText;
  }
};
const rw = (i) => new ff(typeof i == "string" ? i : i + "", void 0, Xa), Lr = (i, ...e) => {
  const t = i.length === 1 ? i[0] : e.reduce((r, s, o) => r + ((n) => {
    if (n._$cssResult$ === !0)
      return n.cssText;
    if (typeof n == "number")
      return n;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + n + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(s) + i[o + 1], i[0]);
  return new ff(t, i, Xa);
}, iw = (i, e) => {
  if (Ja)
    i.adoptedStyleSheets = e.map((t) => t instanceof CSSStyleSheet ? t : t.styleSheet);
  else
    for (const t of e) {
      const r = document.createElement("style"), s = ks.litNonce;
      s !== void 0 && r.setAttribute("nonce", s), r.textContent = t.cssText, i.appendChild(r);
    }
}, Uc = Ja ? (i) => i : (i) => i instanceof CSSStyleSheet ? ((e) => {
  let t = "";
  for (const r of e.cssRules)
    t += r.cssText;
  return rw(t);
})(i) : i;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const { is: sw, defineProperty: ow, getOwnPropertyDescriptor: nw, getOwnPropertyNames: aw, getOwnPropertySymbols: lw, getPrototypeOf: cw } = Object, yt = globalThis, qc = yt.trustedTypes, dw = qc ? qc.emptyScript : "", sn = yt.reactiveElementPolyfillSupport, gi = (i, e) => i, qs = { toAttribute(i, e) {
  switch (e) {
    case Boolean:
      i = i ? dw : null;
      break;
    case Object:
    case Array:
      i = i == null ? i : JSON.stringify(i);
  }
  return i;
}, fromAttribute(i, e) {
  let t = i;
  switch (e) {
    case Boolean:
      t = i !== null;
      break;
    case Number:
      t = i === null ? null : Number(i);
      break;
    case Object:
    case Array:
      try {
        t = JSON.parse(i);
      } catch {
        t = null;
      }
  }
  return t;
} }, el = (i, e) => !sw(i, e), Wc = { attribute: !0, type: String, converter: qs, reflect: !1, hasChanged: el };
Symbol.metadata ?? (Symbol.metadata = Symbol("metadata")), yt.litPropertyMetadata ?? (yt.litPropertyMetadata = /* @__PURE__ */ new WeakMap());
let pr = class extends HTMLElement {
  static addInitializer(e) {
    this._$Ei(), (this.l ?? (this.l = [])).push(e);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(e, t = Wc) {
    if (t.state && (t.attribute = !1), this._$Ei(), this.elementProperties.set(e, t), !t.noAccessor) {
      const r = Symbol(), s = this.getPropertyDescriptor(e, r, t);
      s !== void 0 && ow(this.prototype, e, s);
    }
  }
  static getPropertyDescriptor(e, t, r) {
    const { get: s, set: o } = nw(this.prototype, e) ?? { get() {
      return this[t];
    }, set(n) {
      this[t] = n;
    } };
    return { get() {
      return s == null ? void 0 : s.call(this);
    }, set(n) {
      const a = s == null ? void 0 : s.call(this);
      o.call(this, n), this.requestUpdate(e, a, r);
    }, configurable: !0, enumerable: !0 };
  }
  static getPropertyOptions(e) {
    return this.elementProperties.get(e) ?? Wc;
  }
  static _$Ei() {
    if (this.hasOwnProperty(gi("elementProperties")))
      return;
    const e = cw(this);
    e.finalize(), e.l !== void 0 && (this.l = [...e.l]), this.elementProperties = new Map(e.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(gi("finalized")))
      return;
    if (this.finalized = !0, this._$Ei(), this.hasOwnProperty(gi("properties"))) {
      const t = this.properties, r = [...aw(t), ...lw(t)];
      for (const s of r)
        this.createProperty(s, t[s]);
    }
    const e = this[Symbol.metadata];
    if (e !== null) {
      const t = litPropertyMetadata.get(e);
      if (t !== void 0)
        for (const [r, s] of t)
          this.elementProperties.set(r, s);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [t, r] of this.elementProperties) {
      const s = this._$Eu(t, r);
      s !== void 0 && this._$Eh.set(s, t);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(e) {
    const t = [];
    if (Array.isArray(e)) {
      const r = new Set(e.flat(1 / 0).reverse());
      for (const s of r)
        t.unshift(Uc(s));
    } else
      e !== void 0 && t.push(Uc(e));
    return t;
  }
  static _$Eu(e, t) {
    const r = t.attribute;
    return r === !1 ? void 0 : typeof r == "string" ? r : typeof e == "string" ? e.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = !1, this.hasUpdated = !1, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    var e;
    this._$Eg = new Promise((t) => this.enableUpdating = t), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), (e = this.constructor.l) == null || e.forEach((t) => t(this));
  }
  addController(e) {
    var t;
    (this._$ES ?? (this._$ES = [])).push(e), this.renderRoot !== void 0 && this.isConnected && ((t = e.hostConnected) == null || t.call(e));
  }
  removeController(e) {
    var t;
    (t = this._$ES) == null || t.splice(this._$ES.indexOf(e) >>> 0, 1);
  }
  _$E_() {
    const e = /* @__PURE__ */ new Map(), t = this.constructor.elementProperties;
    for (const r of t.keys())
      this.hasOwnProperty(r) && (e.set(r, this[r]), delete this[r]);
    e.size > 0 && (this._$Ep = e);
  }
  createRenderRoot() {
    const e = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return iw(e, this.constructor.elementStyles), e;
  }
  connectedCallback() {
    var e;
    this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this.enableUpdating(!0), (e = this._$ES) == null || e.forEach((t) => {
      var r;
      return (r = t.hostConnected) == null ? void 0 : r.call(t);
    });
  }
  enableUpdating(e) {
  }
  disconnectedCallback() {
    var e;
    (e = this._$ES) == null || e.forEach((t) => {
      var r;
      return (r = t.hostDisconnected) == null ? void 0 : r.call(t);
    });
  }
  attributeChangedCallback(e, t, r) {
    this._$AK(e, r);
  }
  _$EO(e, t) {
    var o;
    const r = this.constructor.elementProperties.get(e), s = this.constructor._$Eu(e, r);
    if (s !== void 0 && r.reflect === !0) {
      const n = (((o = r.converter) == null ? void 0 : o.toAttribute) !== void 0 ? r.converter : qs).toAttribute(t, r.type);
      this._$Em = e, n == null ? this.removeAttribute(s) : this.setAttribute(s, n), this._$Em = null;
    }
  }
  _$AK(e, t) {
    var o;
    const r = this.constructor, s = r._$Eh.get(e);
    if (s !== void 0 && this._$Em !== s) {
      const n = r.getPropertyOptions(s), a = typeof n.converter == "function" ? { fromAttribute: n.converter } : ((o = n.converter) == null ? void 0 : o.fromAttribute) !== void 0 ? n.converter : qs;
      this._$Em = s, this[s] = a.fromAttribute(t, n.type), this._$Em = null;
    }
  }
  requestUpdate(e, t, r, s = !1, o) {
    if (e !== void 0) {
      if (r ?? (r = this.constructor.getPropertyOptions(e)), !(r.hasChanged ?? el)(s ? o : this[e], t))
        return;
      this.C(e, t, r);
    }
    this.isUpdatePending === !1 && (this._$Eg = this._$EP());
  }
  C(e, t, r) {
    this._$AL.has(e) || this._$AL.set(e, t), r.reflect === !0 && this._$Em !== e && (this._$Ej ?? (this._$Ej = /* @__PURE__ */ new Set())).add(e);
  }
  async _$EP() {
    this.isUpdatePending = !0;
    try {
      await this._$Eg;
    } catch (t) {
      Promise.reject(t);
    }
    const e = this.scheduleUpdate();
    return e != null && await e, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var r;
    if (!this.isUpdatePending)
      return;
    if (!this.hasUpdated) {
      if (this._$Ep) {
        for (const [o, n] of this._$Ep)
          this[o] = n;
        this._$Ep = void 0;
      }
      const s = this.constructor.elementProperties;
      if (s.size > 0)
        for (const [o, n] of s)
          n.wrapped !== !0 || this._$AL.has(o) || this[o] === void 0 || this.C(o, this[o], n);
    }
    let e = !1;
    const t = this._$AL;
    try {
      e = this.shouldUpdate(t), e ? (this.willUpdate(t), (r = this._$ES) == null || r.forEach((s) => {
        var o;
        return (o = s.hostUpdate) == null ? void 0 : o.call(s);
      }), this.update(t)) : this._$ET();
    } catch (s) {
      throw e = !1, this._$ET(), s;
    }
    e && this._$AE(t);
  }
  willUpdate(e) {
  }
  _$AE(e) {
    var t;
    (t = this._$ES) == null || t.forEach((r) => {
      var s;
      return (s = r.hostUpdated) == null ? void 0 : s.call(r);
    }), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(e)), this.updated(e);
  }
  _$ET() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = !1;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$Eg;
  }
  shouldUpdate(e) {
    return !0;
  }
  update(e) {
    this._$Ej && (this._$Ej = this._$Ej.forEach((t) => this._$EO(t, this[t]))), this._$ET();
  }
  updated(e) {
  }
  firstUpdated(e) {
  }
};
pr.elementStyles = [], pr.shadowRootOptions = { mode: "open" }, pr[gi("elementProperties")] = /* @__PURE__ */ new Map(), pr[gi("finalized")] = /* @__PURE__ */ new Map(), sn == null || sn({ ReactiveElement: pr }), (yt.reactiveElementVersions ?? (yt.reactiveElementVersions = [])).push("2.0.1");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const _i = globalThis, Ws = _i.trustedTypes, jc = Ws ? Ws.createPolicy("lit-html", { createHTML: (i) => i }) : void 0, pf = "$lit$", pt = `lit$${(Math.random() + "").slice(9)}$`, mf = "?" + pt, uw = `<${mf}>`, Zt = document, Di = () => Zt.createComment(""), Oi = (i) => i === null || typeof i != "object" && typeof i != "function", gf = Array.isArray, hw = (i) => gf(i) || typeof (i == null ? void 0 : i[Symbol.iterator]) == "function", on = `[ 	
\f\r]`, Xr = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, Gc = /-->/g, Yc = />/g, Pt = RegExp(`>|${on}(?:([^\\s"'>=/]+)(${on}*=${on}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), Zc = /'/g, Kc = /"/g, _f = /^(?:script|style|textarea|title)$/i, fw = (i) => (e, ...t) => ({ _$litType$: i, strings: e, values: t }), vt = fw(1), Kt = Symbol.for("lit-noChange"), ee = Symbol.for("lit-nothing"), Qc = /* @__PURE__ */ new WeakMap(), Ut = Zt.createTreeWalker(Zt, 129);
function bf(i, e) {
  if (!Array.isArray(i) || !i.hasOwnProperty("raw"))
    throw Error("invalid template strings array");
  return jc !== void 0 ? jc.createHTML(e) : e;
}
const pw = (i, e) => {
  const t = i.length - 1, r = [];
  let s, o = e === 2 ? "<svg>" : "", n = Xr;
  for (let a = 0; a < t; a++) {
    const l = i[a];
    let c, d, u = -1, h = 0;
    for (; h < l.length && (n.lastIndex = h, d = n.exec(l), d !== null); )
      h = n.lastIndex, n === Xr ? d[1] === "!--" ? n = Gc : d[1] !== void 0 ? n = Yc : d[2] !== void 0 ? (_f.test(d[2]) && (s = RegExp("</" + d[2], "g")), n = Pt) : d[3] !== void 0 && (n = Pt) : n === Pt ? d[0] === ">" ? (n = s ?? Xr, u = -1) : d[1] === void 0 ? u = -2 : (u = n.lastIndex - d[2].length, c = d[1], n = d[3] === void 0 ? Pt : d[3] === '"' ? Kc : Zc) : n === Kc || n === Zc ? n = Pt : n === Gc || n === Yc ? n = Xr : (n = Pt, s = void 0);
    const f = n === Pt && i[a + 1].startsWith("/>") ? " " : "";
    o += n === Xr ? l + uw : u >= 0 ? (r.push(c), l.slice(0, u) + pf + l.slice(u) + pt + f) : l + pt + (u === -2 ? a : f);
  }
  return [bf(i, o + (i[t] || "<?>") + (e === 2 ? "</svg>" : "")), r];
};
let Qn = class yf {
  constructor({ strings: e, _$litType$: t }, r) {
    let s;
    this.parts = [];
    let o = 0, n = 0;
    const a = e.length - 1, l = this.parts, [c, d] = pw(e, t);
    if (this.el = yf.createElement(c, r), Ut.currentNode = this.el.content, t === 2) {
      const u = this.el.content.firstChild;
      u.replaceWith(...u.childNodes);
    }
    for (; (s = Ut.nextNode()) !== null && l.length < a; ) {
      if (s.nodeType === 1) {
        if (s.hasAttributes())
          for (const u of s.getAttributeNames())
            if (u.endsWith(pf)) {
              const h = d[n++], f = s.getAttribute(u).split(pt), m = /([.?@])?(.*)/.exec(h);
              l.push({ type: 1, index: o, name: m[2], strings: f, ctor: m[1] === "." ? gw : m[1] === "?" ? _w : m[1] === "@" ? bw : yo }), s.removeAttribute(u);
            } else
              u.startsWith(pt) && (l.push({ type: 6, index: o }), s.removeAttribute(u));
        if (_f.test(s.tagName)) {
          const u = s.textContent.split(pt), h = u.length - 1;
          if (h > 0) {
            s.textContent = Ws ? Ws.emptyScript : "";
            for (let f = 0; f < h; f++)
              s.append(u[f], Di()), Ut.nextNode(), l.push({ type: 2, index: ++o });
            s.append(u[h], Di());
          }
        }
      } else if (s.nodeType === 8)
        if (s.data === mf)
          l.push({ type: 2, index: o });
        else {
          let u = -1;
          for (; (u = s.data.indexOf(pt, u + 1)) !== -1; )
            l.push({ type: 7, index: o }), u += pt.length - 1;
        }
      o++;
    }
  }
  static createElement(e, t) {
    const r = Zt.createElement("template");
    return r.innerHTML = e, r;
  }
};
function Dr(i, e, t = i, r) {
  var n, a;
  if (e === Kt)
    return e;
  let s = r !== void 0 ? (n = t._$Co) == null ? void 0 : n[r] : t._$Cl;
  const o = Oi(e) ? void 0 : e._$litDirective$;
  return (s == null ? void 0 : s.constructor) !== o && ((a = s == null ? void 0 : s._$AO) == null || a.call(s, !1), o === void 0 ? s = void 0 : (s = new o(i), s._$AT(i, t, r)), r !== void 0 ? (t._$Co ?? (t._$Co = []))[r] = s : t._$Cl = s), s !== void 0 && (e = Dr(i, s._$AS(i, e.values), s, r)), e;
}
let mw = class {
  constructor(e, t) {
    this._$AV = [], this._$AN = void 0, this._$AD = e, this._$AM = t;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(e) {
    const { el: { content: t }, parts: r } = this._$AD, s = ((e == null ? void 0 : e.creationScope) ?? Zt).importNode(t, !0);
    Ut.currentNode = s;
    let o = Ut.nextNode(), n = 0, a = 0, l = r[0];
    for (; l !== void 0; ) {
      if (n === l.index) {
        let c;
        l.type === 2 ? c = new tl(o, o.nextSibling, this, e) : l.type === 1 ? c = new l.ctor(o, l.name, l.strings, this, e) : l.type === 6 && (c = new yw(o, this, e)), this._$AV.push(c), l = r[++a];
      }
      n !== (l == null ? void 0 : l.index) && (o = Ut.nextNode(), n++);
    }
    return Ut.currentNode = Zt, s;
  }
  p(e) {
    let t = 0;
    for (const r of this._$AV)
      r !== void 0 && (r.strings !== void 0 ? (r._$AI(e, r, t), t += r.strings.length - 2) : r._$AI(e[t])), t++;
  }
}, tl = class vf {
  get _$AU() {
    var e;
    return ((e = this._$AM) == null ? void 0 : e._$AU) ?? this._$Cv;
  }
  constructor(e, t, r, s) {
    this.type = 2, this._$AH = ee, this._$AN = void 0, this._$AA = e, this._$AB = t, this._$AM = r, this.options = s, this._$Cv = (s == null ? void 0 : s.isConnected) ?? !0;
  }
  get parentNode() {
    let e = this._$AA.parentNode;
    const t = this._$AM;
    return t !== void 0 && (e == null ? void 0 : e.nodeType) === 11 && (e = t.parentNode), e;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(e, t = this) {
    e = Dr(this, e, t), Oi(e) ? e === ee || e == null || e === "" ? (this._$AH !== ee && this._$AR(), this._$AH = ee) : e !== this._$AH && e !== Kt && this._(e) : e._$litType$ !== void 0 ? this.g(e) : e.nodeType !== void 0 ? this.$(e) : hw(e) ? this.T(e) : this._(e);
  }
  k(e) {
    return this._$AA.parentNode.insertBefore(e, this._$AB);
  }
  $(e) {
    this._$AH !== e && (this._$AR(), this._$AH = this.k(e));
  }
  _(e) {
    this._$AH !== ee && Oi(this._$AH) ? this._$AA.nextSibling.data = e : this.$(Zt.createTextNode(e)), this._$AH = e;
  }
  g(e) {
    var o;
    const { values: t, _$litType$: r } = e, s = typeof r == "number" ? this._$AC(e) : (r.el === void 0 && (r.el = Qn.createElement(bf(r.h, r.h[0]), this.options)), r);
    if (((o = this._$AH) == null ? void 0 : o._$AD) === s)
      this._$AH.p(t);
    else {
      const n = new mw(s, this), a = n.u(this.options);
      n.p(t), this.$(a), this._$AH = n;
    }
  }
  _$AC(e) {
    let t = Qc.get(e.strings);
    return t === void 0 && Qc.set(e.strings, t = new Qn(e)), t;
  }
  T(e) {
    gf(this._$AH) || (this._$AH = [], this._$AR());
    const t = this._$AH;
    let r, s = 0;
    for (const o of e)
      s === t.length ? t.push(r = new vf(this.k(Di()), this.k(Di()), this, this.options)) : r = t[s], r._$AI(o), s++;
    s < t.length && (this._$AR(r && r._$AB.nextSibling, s), t.length = s);
  }
  _$AR(e = this._$AA.nextSibling, t) {
    var r;
    for ((r = this._$AP) == null ? void 0 : r.call(this, !1, !0, t); e && e !== this._$AB; ) {
      const s = e.nextSibling;
      e.remove(), e = s;
    }
  }
  setConnected(e) {
    var t;
    this._$AM === void 0 && (this._$Cv = e, (t = this._$AP) == null || t.call(this, e));
  }
}, yo = class {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(e, t, r, s, o) {
    this.type = 1, this._$AH = ee, this._$AN = void 0, this.element = e, this.name = t, this._$AM = s, this.options = o, r.length > 2 || r[0] !== "" || r[1] !== "" ? (this._$AH = Array(r.length - 1).fill(new String()), this.strings = r) : this._$AH = ee;
  }
  _$AI(e, t = this, r, s) {
    const o = this.strings;
    let n = !1;
    if (o === void 0)
      e = Dr(this, e, t, 0), n = !Oi(e) || e !== this._$AH && e !== Kt, n && (this._$AH = e);
    else {
      const a = e;
      let l, c;
      for (e = o[0], l = 0; l < o.length - 1; l++)
        c = Dr(this, a[r + l], t, l), c === Kt && (c = this._$AH[l]), n || (n = !Oi(c) || c !== this._$AH[l]), c === ee ? e = ee : e !== ee && (e += (c ?? "") + o[l + 1]), this._$AH[l] = c;
    }
    n && !s && this.O(e);
  }
  O(e) {
    e === ee ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, e ?? "");
  }
};
class gw extends yo {
  constructor() {
    super(...arguments), this.type = 3;
  }
  O(e) {
    this.element[this.name] = e === ee ? void 0 : e;
  }
}
let _w = class extends yo {
  constructor() {
    super(...arguments), this.type = 4;
  }
  O(e) {
    this.element.toggleAttribute(this.name, !!e && e !== ee);
  }
}, bw = class extends yo {
  constructor(e, t, r, s, o) {
    super(e, t, r, s, o), this.type = 5;
  }
  _$AI(e, t = this) {
    if ((e = Dr(this, e, t, 0) ?? ee) === Kt)
      return;
    const r = this._$AH, s = e === ee && r !== ee || e.capture !== r.capture || e.once !== r.once || e.passive !== r.passive, o = e !== ee && (r === ee || s);
    s && this.element.removeEventListener(this.name, this, r), o && this.element.addEventListener(this.name, this, e), this._$AH = e;
  }
  handleEvent(e) {
    var t;
    typeof this._$AH == "function" ? this._$AH.call(((t = this.options) == null ? void 0 : t.host) ?? this.element, e) : this._$AH.handleEvent(e);
  }
};
class yw {
  constructor(e, t, r) {
    this.element = e, this.type = 6, this._$AN = void 0, this._$AM = t, this.options = r;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(e) {
    Dr(this, e);
  }
}
const nn = _i.litHtmlPolyfillSupport;
nn == null || nn(Qn, tl), (_i.litHtmlVersions ?? (_i.litHtmlVersions = [])).push("3.0.2");
const vw = (i, e, t) => {
  const r = (t == null ? void 0 : t.renderBefore) ?? e;
  let s = r._$litPart$;
  if (s === void 0) {
    const o = (t == null ? void 0 : t.renderBefore) ?? null;
    r._$litPart$ = s = new tl(e.insertBefore(Di(), o), o, void 0, t ?? {});
  }
  return s._$AI(i), s;
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
let bi = class extends pr {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    var t;
    const e = super.createRenderRoot();
    return (t = this.renderOptions).renderBefore ?? (t.renderBefore = e.firstChild), e;
  }
  update(e) {
    const t = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(e), this._$Do = vw(t, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    var e;
    super.connectedCallback(), (e = this._$Do) == null || e.setConnected(!0);
  }
  disconnectedCallback() {
    var e;
    super.disconnectedCallback(), (e = this._$Do) == null || e.setConnected(!1);
  }
  render() {
    return Kt;
  }
};
var Bd;
bi._$litElement$ = !0, bi.finalized = !0, (Bd = globalThis.litElementHydrateSupport) == null || Bd.call(globalThis, { LitElement: bi });
const an = globalThis.litElementPolyfillSupport;
an == null || an({ LitElement: bi });
(globalThis.litElementVersions ?? (globalThis.litElementVersions = [])).push("4.0.1");
var Yi = Lr`
  :host {
    box-sizing: border-box;
  }

  :host *,
  :host *::before,
  :host *::after {
    box-sizing: inherit;
  }

  [hidden] {
    display: none !important;
  }
`, ww = Lr`
  ${Yi}

  :host {
    --padding: 0;

    display: none;
  }

  :host([active]) {
    display: block;
  }

  .tab-panel {
    display: block;
    padding: var(--padding);
  }
`;
function rr(i, e) {
  const t = Qa({
    waitUntilFirstUpdate: !1
  }, e);
  return (r, s) => {
    const { update: o } = r, n = Array.isArray(i) ? i : [i];
    r.update = function(a) {
      n.forEach((l) => {
        const c = l;
        if (a.has(c)) {
          const d = a.get(c), u = this[c];
          d !== u && (!t.waitUntilFirstUpdate || this.hasUpdated) && this[s](d, u);
        }
      }), o.call(this, a);
    };
  };
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const xw = { attribute: !0, type: String, converter: qs, reflect: !1, hasChanged: el }, Cw = (i = xw, e, t) => {
  const { kind: r, metadata: s } = t;
  let o = globalThis.litPropertyMetadata.get(s);
  if (o === void 0 && globalThis.litPropertyMetadata.set(s, o = /* @__PURE__ */ new Map()), o.set(t.name, i), r === "accessor") {
    const { name: n } = t;
    return { set(a) {
      const l = e.get.call(this);
      e.set.call(this, a), this.requestUpdate(n, l, i);
    }, init(a) {
      return a !== void 0 && this.C(n, void 0, i), a;
    } };
  }
  if (r === "setter") {
    const { name: n } = t;
    return function(a) {
      const l = this[n];
      e.call(this, a), this.requestUpdate(n, l, i);
    };
  }
  throw Error("Unsupported decorator location: " + r);
};
function H(i) {
  return (e, t) => typeof t == "object" ? Cw(i, e, t) : ((r, s, o) => {
    const n = s.hasOwnProperty(o);
    return s.constructor.createProperty(o, n ? { ...r, wrapped: !0 } : r), n ? Object.getOwnPropertyDescriptor(s, o) : void 0;
  })(i, e, t);
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function rl(i) {
  return H({ ...i, state: !0, attribute: !1 });
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Jc = (i, e, t) => (t.configurable = !0, t.enumerable = !0, Reflect.decorate && typeof e != "object" && Object.defineProperty(i, e, t), t);
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function Vr(i, e) {
  return (t, r, s) => {
    const o = (n) => {
      var a;
      return ((a = n.renderRoot) == null ? void 0 : a.querySelector(i)) ?? null;
    };
    if (e) {
      const { get: n, set: a } = typeof r == "object" ? t : s ?? (() => {
        const l = Symbol();
        return { get() {
          return this[l];
        }, set(c) {
          this[l] = c;
        } };
      })();
      return Jc(t, r, { get() {
        if (e) {
          let l = n.call(this);
          return l === void 0 && (l = o(this), a.call(this, l)), l;
        }
        return o(this);
      } });
    }
    return Jc(t, r, { get() {
      return o(this);
    } });
  };
}
var it = class extends bi {
  constructor() {
    super(), Object.entries(this.constructor.dependencies).forEach(([i, e]) => {
      this.constructor.define(i, e);
    });
  }
  emit(i, e) {
    const t = new CustomEvent(i, Qa({
      bubbles: !0,
      cancelable: !1,
      composed: !0,
      detail: {}
    }, e));
    return this.dispatchEvent(t), t;
  }
  /* eslint-enable */
  static define(i, e = this, t = {}) {
    const r = customElements.get(i);
    if (!r) {
      customElements.define(i, class extends e {
      }, t);
      return;
    }
    let s = " (unknown version)", o = s;
    "version" in e && e.version && (s = " v" + e.version), "version" in r && r.version && (o = " v" + r.version);
  }
};
it.version = "2.11.2";
it.dependencies = {};
A([
  H()
], it.prototype, "dir", 2);
A([
  H()
], it.prototype, "lang", 2);
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const kw = { ATTRIBUTE: 1, CHILD: 2, PROPERTY: 3, BOOLEAN_ATTRIBUTE: 4, EVENT: 5, ELEMENT: 6 }, Aw = (i) => (...e) => ({ _$litDirective$: i, values: e });
class Ew {
  constructor(e) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(e, t, r) {
    this._$Ct = e, this._$AM = t, this._$Ci = r;
  }
  _$AS(e, t) {
    return this.update(e, t);
  }
  update(e, t) {
    return this.render(...t);
  }
}
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const vo = Aw(class extends Ew {
  constructor(i) {
    var e;
    if (super(i), i.type !== kw.ATTRIBUTE || i.name !== "class" || ((e = i.strings) == null ? void 0 : e.length) > 2)
      throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.");
  }
  render(i) {
    return " " + Object.keys(i).filter((e) => i[e]).join(" ") + " ";
  }
  update(i, [e]) {
    var r, s;
    if (this.it === void 0) {
      this.it = /* @__PURE__ */ new Set(), i.strings !== void 0 && (this.st = new Set(i.strings.join(" ").split(/\s/).filter((o) => o !== "")));
      for (const o in e)
        e[o] && !((r = this.st) != null && r.has(o)) && this.it.add(o);
      return this.render(e);
    }
    const t = i.element.classList;
    for (const o of this.it)
      o in e || (t.remove(o), this.it.delete(o));
    for (const o in e) {
      const n = !!e[o];
      n === this.it.has(o) || (s = this.st) != null && s.has(o) || (n ? (t.add(o), this.it.add(o)) : (t.remove(o), this.it.delete(o)));
    }
    return Kt;
  }
});
var Sw = 0, Zi = class extends it {
  constructor() {
    super(...arguments), this.attrId = ++Sw, this.componentId = `sl-tab-panel-${this.attrId}`, this.name = "", this.active = !1;
  }
  connectedCallback() {
    super.connectedCallback(), this.id = this.id.length > 0 ? this.id : this.componentId, this.setAttribute("role", "tabpanel");
  }
  handleActiveChange() {
    this.setAttribute("aria-hidden", this.active ? "false" : "true");
  }
  render() {
    return vt`
      <slot
        part="base"
        class=${vo({
      "tab-panel": !0,
      "tab-panel--active": this.active
    })}
      ></slot>
    `;
  }
};
Zi.styles = ww;
A([
  H({ reflect: !0 })
], Zi.prototype, "name", 2);
A([
  H({ type: Boolean, reflect: !0 })
], Zi.prototype, "active", 2);
A([
  rr("active")
], Zi.prototype, "handleActiveChange", 1);
Zi.define("sl-tab-panel");
var Tw = Lr`
  ${Yi}

  :host {
    display: inline-block;
  }

  .tab {
    display: inline-flex;
    align-items: center;
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-small);
    font-weight: var(--sl-font-weight-semibold);
    border-radius: var(--sl-border-radius-medium);
    color: var(--sl-color-neutral-600);
    padding: var(--sl-spacing-medium) var(--sl-spacing-large);
    white-space: nowrap;
    user-select: none;
    -webkit-user-select: none;
    cursor: pointer;
    transition:
      var(--transition-speed) box-shadow,
      var(--transition-speed) color;
  }

  .tab:hover:not(.tab--disabled) {
    color: var(--sl-color-primary-600);
  }

  .tab:focus {
    outline: none;
  }

  .tab:focus-visible:not(.tab--disabled) {
    color: var(--sl-color-primary-600);
  }

  .tab:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: calc(-1 * var(--sl-focus-ring-width) - var(--sl-focus-ring-offset));
  }

  .tab.tab--active:not(.tab--disabled) {
    color: var(--sl-color-primary-600);
  }

  .tab.tab--closable {
    padding-inline-end: var(--sl-spacing-small);
  }

  .tab.tab--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .tab__close-button {
    font-size: var(--sl-font-size-small);
    margin-inline-start: var(--sl-spacing-small);
  }

  .tab__close-button::part(base) {
    padding: var(--sl-spacing-3x-small);
  }

  @media (forced-colors: active) {
    .tab.tab--active:not(.tab--disabled) {
      outline: solid 1px transparent;
      outline-offset: -3px;
    }
  }
`, Iw = Lr`
  ${Yi}

  :host {
    display: inline-block;
    color: var(--sl-color-neutral-600);
  }

  .icon-button {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    background: none;
    border: none;
    border-radius: var(--sl-border-radius-medium);
    font-size: inherit;
    color: inherit;
    padding: var(--sl-spacing-x-small);
    cursor: pointer;
    transition: var(--sl-transition-x-fast) color;
    -webkit-appearance: none;
  }

  .icon-button:hover:not(.icon-button--disabled),
  .icon-button:focus-visible:not(.icon-button--disabled) {
    color: var(--sl-color-primary-600);
  }

  .icon-button:active:not(.icon-button--disabled) {
    color: var(--sl-color-primary-700);
  }

  .icon-button:focus {
    outline: none;
  }

  .icon-button--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .icon-button:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .icon-button__icon {
    pointer-events: none;
  }
`, Dw = Lr`
  ${Yi}

  :host {
    display: inline-block;
    width: 1em;
    height: 1em;
    box-sizing: content-box !important;
  }

  svg {
    display: block;
    height: 100%;
    width: 100%;
  }
`, Ow = {
  name: "default",
  resolver: (i) => Z0(`assets/icons/${i}.svg`)
}, $w = Ow, Xc = {
  caret: `
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <polyline points="6 9 12 15 18 9"></polyline>
    </svg>
  `,
  check: `
    <svg part="checked-icon" class="checkbox__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" stroke-linecap="round">
        <g stroke="currentColor">
          <g transform="translate(3.428571, 3.428571)">
            <path d="M0,5.71428571 L3.42857143,9.14285714"></path>
            <path d="M9.14285714,0 L3.42857143,9.14285714"></path>
          </g>
        </g>
      </g>
    </svg>
  `,
  "chevron-down": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-down" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z"/>
    </svg>
  `,
  "chevron-left": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-left" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M11.354 1.646a.5.5 0 0 1 0 .708L5.707 8l5.647 5.646a.5.5 0 0 1-.708.708l-6-6a.5.5 0 0 1 0-.708l6-6a.5.5 0 0 1 .708 0z"/>
    </svg>
  `,
  "chevron-right": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-right" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z"/>
    </svg>
  `,
  copy: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-files" viewBox="0 0 16 16" part="svg">
      <path d="M13 0H6a2 2 0 0 0-2 2 2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h7a2 2 0 0 0 2-2 2 2 0 0 0 2-2V2a2 2 0 0 0-2-2zm0 13V4a2 2 0 0 0-2-2H5a1 1 0 0 1 1-1h7a1 1 0 0 1 1 1v10a1 1 0 0 1-1 1zM3 4a1 1 0 0 1 1-1h7a1 1 0 0 1 1 1v10a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V4z"></path>
    </svg>
  `,
  eye: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eye" viewBox="0 0 16 16">
      <path d="M16 8s-3-5.5-8-5.5S0 8 0 8s3 5.5 8 5.5S16 8 16 8zM1.173 8a13.133 13.133 0 0 1 1.66-2.043C4.12 4.668 5.88 3.5 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.133 13.133 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755C11.879 11.332 10.119 12.5 8 12.5c-2.12 0-3.879-1.168-5.168-2.457A13.134 13.134 0 0 1 1.172 8z"/>
      <path d="M8 5.5a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5zM4.5 8a3.5 3.5 0 1 1 7 0 3.5 3.5 0 0 1-7 0z"/>
    </svg>
  `,
  "eye-slash": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eye-slash" viewBox="0 0 16 16">
      <path d="M13.359 11.238C15.06 9.72 16 8 16 8s-3-5.5-8-5.5a7.028 7.028 0 0 0-2.79.588l.77.771A5.944 5.944 0 0 1 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.134 13.134 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755-.165.165-.337.328-.517.486l.708.709z"/>
      <path d="M11.297 9.176a3.5 3.5 0 0 0-4.474-4.474l.823.823a2.5 2.5 0 0 1 2.829 2.829l.822.822zm-2.943 1.299.822.822a3.5 3.5 0 0 1-4.474-4.474l.823.823a2.5 2.5 0 0 0 2.829 2.829z"/>
      <path d="M3.35 5.47c-.18.16-.353.322-.518.487A13.134 13.134 0 0 0 1.172 8l.195.288c.335.48.83 1.12 1.465 1.755C4.121 11.332 5.881 12.5 8 12.5c.716 0 1.39-.133 2.02-.36l.77.772A7.029 7.029 0 0 1 8 13.5C3 13.5 0 8 0 8s.939-1.721 2.641-3.238l.708.709zm10.296 8.884-12-12 .708-.708 12 12-.708.708z"/>
    </svg>
  `,
  eyedropper: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eyedropper" viewBox="0 0 16 16">
      <path d="M13.354.646a1.207 1.207 0 0 0-1.708 0L8.5 3.793l-.646-.647a.5.5 0 1 0-.708.708L8.293 5l-7.147 7.146A.5.5 0 0 0 1 12.5v1.793l-.854.853a.5.5 0 1 0 .708.707L1.707 15H3.5a.5.5 0 0 0 .354-.146L11 7.707l1.146 1.147a.5.5 0 0 0 .708-.708l-.647-.646 3.147-3.146a1.207 1.207 0 0 0 0-1.708l-2-2zM2 12.707l7-7L10.293 7l-7 7H2v-1.293z"></path>
    </svg>
  `,
  "grip-vertical": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-grip-vertical" viewBox="0 0 16 16">
      <path d="M7 2a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zM7 5a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zM7 8a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm-3 3a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm-3 3a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0z"></path>
    </svg>
  `,
  indeterminate: `
    <svg part="indeterminate-icon" class="checkbox__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" stroke-linecap="round">
        <g stroke="currentColor" stroke-width="2">
          <g transform="translate(2.285714, 6.857143)">
            <path d="M10.2857143,1.14285714 L1.14285714,1.14285714"></path>
          </g>
        </g>
      </g>
    </svg>
  `,
  "person-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-person-fill" viewBox="0 0 16 16">
      <path d="M3 14s-1 0-1-1 1-4 6-4 6 3 6 4-1 1-1 1H3zm5-6a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/>
    </svg>
  `,
  "play-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-play-fill" viewBox="0 0 16 16">
      <path d="m11.596 8.697-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"></path>
    </svg>
  `,
  "pause-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-pause-fill" viewBox="0 0 16 16">
      <path d="M5.5 3.5A1.5 1.5 0 0 1 7 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5zm5 0A1.5 1.5 0 0 1 12 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5z"></path>
    </svg>
  `,
  radio: `
    <svg part="checked-icon" class="radio__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g fill="currentColor">
          <circle cx="8" cy="8" r="3.42857143"></circle>
        </g>
      </g>
    </svg>
  `,
  "star-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-star-fill" viewBox="0 0 16 16">
      <path d="M3.612 15.443c-.386.198-.824-.149-.746-.592l.83-4.73L.173 6.765c-.329-.314-.158-.888.283-.95l4.898-.696L7.538.792c.197-.39.73-.39.927 0l2.184 4.327 4.898.696c.441.062.612.636.282.95l-3.522 3.356.83 4.73c.078.443-.36.79-.746.592L8 13.187l-4.389 2.256z"/>
    </svg>
  `,
  "x-lg": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-x-lg" viewBox="0 0 16 16">
      <path d="M2.146 2.854a.5.5 0 1 1 .708-.708L8 7.293l5.146-5.147a.5.5 0 0 1 .708.708L8.707 8l5.147 5.146a.5.5 0 0 1-.708.708L8 8.707l-5.146 5.147a.5.5 0 0 1-.708-.708L7.293 8 2.146 2.854Z"/>
    </svg>
  `,
  "x-circle-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-x-circle-fill" viewBox="0 0 16 16">
      <path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zM5.354 4.646a.5.5 0 1 0-.708.708L7.293 8l-2.647 2.646a.5.5 0 0 0 .708.708L8 8.707l2.646 2.647a.5.5 0 0 0 .708-.708L8.707 8l2.647-2.646a.5.5 0 0 0-.708-.708L8 7.293 5.354 4.646z"></path>
    </svg>
  `
}, Pw = {
  name: "system",
  resolver: (i) => i in Xc ? `data:image/svg+xml,${encodeURIComponent(Xc[i])}` : ""
}, Mw = Pw, zw = [$w, Mw], Jn = [];
function Nw(i) {
  Jn.push(i);
}
function Fw(i) {
  Jn = Jn.filter((e) => e !== i);
}
function ed(i) {
  return zw.find((e) => e.name === i);
}
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Rw = (i, e) => e === void 0 ? (i == null ? void 0 : i._$litType$) !== void 0 : (i == null ? void 0 : i._$litType$) === e;
var ei = Symbol(), ds = Symbol(), ln, cn = /* @__PURE__ */ new Map(), st = class extends it {
  constructor() {
    super(...arguments), this.initialRender = !1, this.svg = null, this.label = "", this.library = "default";
  }
  /** Given a URL, this function returns the resulting SVG element or an appropriate error symbol. */
  async resolveIcon(i, e) {
    var t;
    let r;
    if (e != null && e.spriteSheet)
      return vt`<svg part="svg">
        <use part="use" href="${i}"></use>
      </svg>`;
    try {
      if (r = await fetch(i, { mode: "cors" }), !r.ok)
        return r.status === 410 ? ei : ds;
    } catch {
      return ds;
    }
    try {
      const s = document.createElement("div");
      s.innerHTML = await r.text();
      const o = s.firstElementChild;
      if (((t = o == null ? void 0 : o.tagName) == null ? void 0 : t.toLowerCase()) !== "svg")
        return ei;
      ln || (ln = new DOMParser());
      const a = ln.parseFromString(o.outerHTML, "text/html").body.querySelector("svg");
      return a ? (a.part.add("svg"), document.adoptNode(a)) : ei;
    } catch {
      return ei;
    }
  }
  connectedCallback() {
    super.connectedCallback(), Nw(this);
  }
  firstUpdated() {
    this.initialRender = !0, this.setIcon();
  }
  disconnectedCallback() {
    super.disconnectedCallback(), Fw(this);
  }
  getIconSource() {
    const i = ed(this.library);
    return this.name && i ? {
      url: i.resolver(this.name),
      fromLibrary: !0
    } : {
      url: this.src,
      fromLibrary: !1
    };
  }
  handleLabelChange() {
    typeof this.label == "string" && this.label.length > 0 ? (this.setAttribute("role", "img"), this.setAttribute("aria-label", this.label), this.removeAttribute("aria-hidden")) : (this.removeAttribute("role"), this.removeAttribute("aria-label"), this.setAttribute("aria-hidden", "true"));
  }
  async setIcon() {
    var i;
    const { url: e, fromLibrary: t } = this.getIconSource(), r = t ? ed(this.library) : void 0;
    if (!e) {
      this.svg = null;
      return;
    }
    let s = cn.get(e);
    if (s || (s = this.resolveIcon(e, r), cn.set(e, s)), !this.initialRender)
      return;
    const o = await s;
    if (o === ds && cn.delete(e), e === this.getIconSource().url) {
      if (Rw(o)) {
        this.svg = o;
        return;
      }
      switch (o) {
        case ds:
        case ei:
          this.svg = null, this.emit("sl-error");
          break;
        default:
          this.svg = o.cloneNode(!0), (i = r == null ? void 0 : r.mutator) == null || i.call(r, this.svg), this.emit("sl-load");
      }
    }
  }
  render() {
    return this.svg;
  }
};
st.styles = Dw;
A([
  rl()
], st.prototype, "svg", 2);
A([
  H({ reflect: !0 })
], st.prototype, "name", 2);
A([
  H()
], st.prototype, "src", 2);
A([
  H()
], st.prototype, "label", 2);
A([
  H({ reflect: !0 })
], st.prototype, "library", 2);
A([
  rr("label")
], st.prototype, "handleLabelChange", 1);
A([
  rr(["name", "src", "library"])
], st.prototype, "setIcon", 1);
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const wf = Symbol.for(""), Lw = (i) => {
  if ((i == null ? void 0 : i.r) === wf)
    return i == null ? void 0 : i._$litStatic$;
}, td = (i, ...e) => ({ _$litStatic$: e.reduce((t, r, s) => t + ((o) => {
  if (o._$litStatic$ !== void 0)
    return o._$litStatic$;
  throw Error(`Value passed to 'literal' function must be a 'literal' result: ${o}. Use 'unsafeStatic' to pass non-literal values, but
            take care to ensure page security.`);
})(r) + i[s + 1], i[0]), r: wf }), rd = /* @__PURE__ */ new Map(), Vw = (i) => (e, ...t) => {
  const r = t.length;
  let s, o;
  const n = [], a = [];
  let l, c = 0, d = !1;
  for (; c < r; ) {
    for (l = e[c]; c < r && (o = t[c], (s = Lw(o)) !== void 0); )
      l += s + e[++c], d = !0;
    c !== r && a.push(o), n.push(l), c++;
  }
  if (c === r && n.push(e[r]), d) {
    const u = n.join("$$lit$$");
    (e = rd.get(u)) === void 0 && (n.raw = n, rd.set(u, e = n)), t = a;
  }
  return i(e, ...t);
}, Hw = Vw(vt);
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Ue = (i) => i ?? ee;
var ue = class extends it {
  constructor() {
    super(...arguments), this.hasFocus = !1, this.label = "", this.disabled = !1;
  }
  handleBlur() {
    this.hasFocus = !1, this.emit("sl-blur");
  }
  handleFocus() {
    this.hasFocus = !0, this.emit("sl-focus");
  }
  handleClick(i) {
    this.disabled && (i.preventDefault(), i.stopPropagation());
  }
  /** Simulates a click on the icon button. */
  click() {
    this.button.click();
  }
  /** Sets focus on the icon button. */
  focus(i) {
    this.button.focus(i);
  }
  /** Removes focus from the icon button. */
  blur() {
    this.button.blur();
  }
  render() {
    const i = !!this.href, e = i ? td`a` : td`button`;
    return Hw`
      <${e}
        part="base"
        class=${vo({
      "icon-button": !0,
      "icon-button--disabled": !i && this.disabled,
      "icon-button--focused": this.hasFocus
    })}
        ?disabled=${Ue(i ? void 0 : this.disabled)}
        type=${Ue(i ? void 0 : "button")}
        href=${Ue(i ? this.href : void 0)}
        target=${Ue(i ? this.target : void 0)}
        download=${Ue(i ? this.download : void 0)}
        rel=${Ue(i && this.target ? "noreferrer noopener" : void 0)}
        role=${Ue(i ? void 0 : "button")}
        aria-disabled=${this.disabled ? "true" : "false"}
        aria-label="${this.label}"
        tabindex=${this.disabled ? "-1" : "0"}
        @blur=${this.handleBlur}
        @focus=${this.handleFocus}
        @click=${this.handleClick}
      >
        <sl-icon
          class="icon-button__icon"
          name=${Ue(this.name)}
          library=${Ue(this.library)}
          src=${Ue(this.src)}
          aria-hidden="true"
        ></sl-icon>
      </${e}>
    `;
  }
};
ue.styles = Iw;
ue.dependencies = { "sl-icon": st };
A([
  Vr(".icon-button")
], ue.prototype, "button", 2);
A([
  rl()
], ue.prototype, "hasFocus", 2);
A([
  H()
], ue.prototype, "name", 2);
A([
  H()
], ue.prototype, "library", 2);
A([
  H()
], ue.prototype, "src", 2);
A([
  H()
], ue.prototype, "href", 2);
A([
  H()
], ue.prototype, "target", 2);
A([
  H()
], ue.prototype, "download", 2);
A([
  H()
], ue.prototype, "label", 2);
A([
  H({ type: Boolean, reflect: !0 })
], ue.prototype, "disabled", 2);
const Xn = /* @__PURE__ */ new Set(), Bw = new MutationObserver(kf), _r = /* @__PURE__ */ new Map();
let xf = document.documentElement.dir || "ltr", Cf = document.documentElement.lang || navigator.language, Rt;
Bw.observe(document.documentElement, {
  attributes: !0,
  attributeFilter: ["dir", "lang"]
});
function Uw(...i) {
  i.map((e) => {
    const t = e.$code.toLowerCase();
    _r.has(t) ? _r.set(t, Object.assign(Object.assign({}, _r.get(t)), e)) : _r.set(t, e), Rt || (Rt = e);
  }), kf();
}
function kf() {
  xf = document.documentElement.dir || "ltr", Cf = document.documentElement.lang || navigator.language, [...Xn.keys()].map((i) => {
    typeof i.requestUpdate == "function" && i.requestUpdate();
  });
}
let qw = class {
  constructor(e) {
    this.host = e, this.host.addController(this);
  }
  hostConnected() {
    Xn.add(this.host);
  }
  hostDisconnected() {
    Xn.delete(this.host);
  }
  dir() {
    return `${this.host.dir || xf}`.toLowerCase();
  }
  lang() {
    return `${this.host.lang || Cf}`.toLowerCase();
  }
  getTranslationData(e) {
    var t, r;
    const s = new Intl.Locale(e.replace(/_/g, "-")), o = s == null ? void 0 : s.language.toLowerCase(), n = (r = (t = s == null ? void 0 : s.region) === null || t === void 0 ? void 0 : t.toLowerCase()) !== null && r !== void 0 ? r : "", a = _r.get(`${o}-${n}`), l = _r.get(o);
    return { locale: s, language: o, region: n, primary: a, secondary: l };
  }
  exists(e, t) {
    var r;
    const { primary: s, secondary: o } = this.getTranslationData((r = t.lang) !== null && r !== void 0 ? r : this.lang());
    return t = Object.assign({ includeFallback: !1 }, t), !!(s && s[e] || o && o[e] || t.includeFallback && Rt && Rt[e]);
  }
  term(e, ...t) {
    const { primary: r, secondary: s } = this.getTranslationData(this.lang());
    let o;
    if (r && r[e])
      o = r[e];
    else if (s && s[e])
      o = s[e];
    else if (Rt && Rt[e])
      o = Rt[e];
    else
      return String(e);
    return typeof o == "function" ? o(...t) : o;
  }
  date(e, t) {
    return e = new Date(e), new Intl.DateTimeFormat(this.lang(), t).format(e);
  }
  number(e, t) {
    return e = Number(e), isNaN(e) ? "" : new Intl.NumberFormat(this.lang(), t).format(e);
  }
  relativeTime(e, t, r) {
    return new Intl.RelativeTimeFormat(this.lang(), r).format(e, t);
  }
};
var Af = class extends qw {
}, Ww = 0, We = class extends it {
  constructor() {
    super(...arguments), this.localize = new Af(this), this.attrId = ++Ww, this.componentId = `sl-tab-${this.attrId}`, this.panel = "", this.active = !1, this.closable = !1, this.disabled = !1;
  }
  connectedCallback() {
    super.connectedCallback(), this.setAttribute("role", "tab");
  }
  handleCloseClick(i) {
    i.stopPropagation(), this.emit("sl-close");
  }
  handleActiveChange() {
    this.setAttribute("aria-selected", this.active ? "true" : "false");
  }
  handleDisabledChange() {
    this.setAttribute("aria-disabled", this.disabled ? "true" : "false");
  }
  /** Sets focus to the tab. */
  focus(i) {
    this.tab.focus(i);
  }
  /** Removes focus from the tab. */
  blur() {
    this.tab.blur();
  }
  render() {
    return this.id = this.id.length > 0 ? this.id : this.componentId, vt`
      <div
        part="base"
        class=${vo({
      tab: !0,
      "tab--active": this.active,
      "tab--closable": this.closable,
      "tab--disabled": this.disabled
    })}
        tabindex=${this.disabled ? "-1" : "0"}
      >
        <slot></slot>
        ${this.closable ? vt`
              <sl-icon-button
                part="close-button"
                exportparts="base:close-button__base"
                name="x-lg"
                library="system"
                label=${this.localize.term("close")}
                class="tab__close-button"
                @click=${this.handleCloseClick}
                tabindex="-1"
              ></sl-icon-button>
            ` : ""}
      </div>
    `;
  }
};
We.styles = Tw;
We.dependencies = { "sl-icon-button": ue };
A([
  Vr(".tab")
], We.prototype, "tab", 2);
A([
  H({ reflect: !0 })
], We.prototype, "panel", 2);
A([
  H({ type: Boolean, reflect: !0 })
], We.prototype, "active", 2);
A([
  H({ type: Boolean })
], We.prototype, "closable", 2);
A([
  H({ type: Boolean, reflect: !0 })
], We.prototype, "disabled", 2);
A([
  rr("active")
], We.prototype, "handleActiveChange", 1);
A([
  rr("disabled")
], We.prototype, "handleDisabledChange", 1);
We.define("sl-tab");
var jw = {
  $code: "en",
  $name: "English",
  $dir: "ltr",
  carousel: "Carousel",
  clearEntry: "Clear entry",
  close: "Close",
  copied: "Copied",
  copy: "Copy",
  currentValue: "Current value",
  error: "Error",
  goToSlide: (i, e) => `Go to slide ${i} of ${e}`,
  hidePassword: "Hide password",
  loading: "Loading",
  nextSlide: "Next slide",
  numOptionsSelected: (i) => i === 0 ? "No options selected" : i === 1 ? "1 option selected" : `${i} options selected`,
  previousSlide: "Previous slide",
  progress: "Progress",
  remove: "Remove",
  resize: "Resize",
  scrollToEnd: "Scroll to end",
  scrollToStart: "Scroll to start",
  selectAColorFromTheScreen: "Select a color from the screen",
  showPassword: "Show password",
  slideNum: (i) => `Slide ${i}`,
  toggleColorFormat: "Toggle color format"
};
Uw(jw);
var Gw = Lr`
  ${Yi}

  :host {
    --indicator-color: var(--sl-color-primary-600);
    --track-color: var(--sl-color-neutral-200);
    --track-width: 2px;

    display: block;
  }

  .tab-group {
    display: flex;
    border-radius: 0;
  }

  .tab-group__tabs {
    display: flex;
    position: relative;
  }

  .tab-group__indicator {
    position: absolute;
    transition:
      var(--sl-transition-fast) translate ease,
      var(--sl-transition-fast) width ease;
  }

  .tab-group--has-scroll-controls .tab-group__nav-container {
    position: relative;
    padding: 0 var(--sl-spacing-x-large);
  }

  .tab-group__body {
    display: block;
    overflow: auto;
  }

  .tab-group__scroll-button {
    display: flex;
    align-items: center;
    justify-content: center;
    position: absolute;
    top: 0;
    bottom: 0;
    width: var(--sl-spacing-x-large);
  }

  .tab-group__scroll-button--start {
    left: 0;
  }

  .tab-group__scroll-button--end {
    right: 0;
  }

  .tab-group--rtl .tab-group__scroll-button--start {
    left: auto;
    right: 0;
  }

  .tab-group--rtl .tab-group__scroll-button--end {
    left: 0;
    right: auto;
  }

  /*
   * Top
   */

  .tab-group--top {
    flex-direction: column;
  }

  .tab-group--top .tab-group__nav-container {
    order: 1;
  }

  .tab-group--top .tab-group__nav {
    display: flex;
    overflow-x: auto;

    /* Hide scrollbar in Firefox */
    scrollbar-width: none;
  }

  /* Hide scrollbar in Chrome/Safari */
  .tab-group--top .tab-group__nav::-webkit-scrollbar {
    width: 0;
    height: 0;
  }

  .tab-group--top .tab-group__tabs {
    flex: 1 1 auto;
    position: relative;
    flex-direction: row;
    border-bottom: solid var(--track-width) var(--track-color);
  }

  .tab-group--top .tab-group__indicator {
    bottom: calc(-1 * var(--track-width));
    border-bottom: solid var(--track-width) var(--indicator-color);
  }

  .tab-group--top .tab-group__body {
    order: 2;
  }

  .tab-group--top ::slotted(sl-tab-panel) {
    --padding: var(--sl-spacing-medium) 0;
  }

  /*
   * Bottom
   */

  .tab-group--bottom {
    flex-direction: column;
  }

  .tab-group--bottom .tab-group__nav-container {
    order: 2;
  }

  .tab-group--bottom .tab-group__nav {
    display: flex;
    overflow-x: auto;

    /* Hide scrollbar in Firefox */
    scrollbar-width: none;
  }

  /* Hide scrollbar in Chrome/Safari */
  .tab-group--bottom .tab-group__nav::-webkit-scrollbar {
    width: 0;
    height: 0;
  }

  .tab-group--bottom .tab-group__tabs {
    flex: 1 1 auto;
    position: relative;
    flex-direction: row;
    border-top: solid var(--track-width) var(--track-color);
  }

  .tab-group--bottom .tab-group__indicator {
    top: calc(-1 * var(--track-width));
    border-top: solid var(--track-width) var(--indicator-color);
  }

  .tab-group--bottom .tab-group__body {
    order: 1;
  }

  .tab-group--bottom ::slotted(sl-tab-panel) {
    --padding: var(--sl-spacing-medium) 0;
  }

  /*
   * Start
   */

  .tab-group--start {
    flex-direction: row;
  }

  .tab-group--start .tab-group__nav-container {
    order: 1;
  }

  .tab-group--start .tab-group__tabs {
    flex: 0 0 auto;
    flex-direction: column;
    border-inline-end: solid var(--track-width) var(--track-color);
  }

  .tab-group--start .tab-group__indicator {
    right: calc(-1 * var(--track-width));
    border-right: solid var(--track-width) var(--indicator-color);
  }

  .tab-group--start.tab-group--rtl .tab-group__indicator {
    right: auto;
    left: calc(-1 * var(--track-width));
  }

  .tab-group--start .tab-group__body {
    flex: 1 1 auto;
    order: 2;
  }

  .tab-group--start ::slotted(sl-tab-panel) {
    --padding: 0 var(--sl-spacing-medium);
  }

  /*
   * End
   */

  .tab-group--end {
    flex-direction: row;
  }

  .tab-group--end .tab-group__nav-container {
    order: 2;
  }

  .tab-group--end .tab-group__tabs {
    flex: 0 0 auto;
    flex-direction: column;
    border-left: solid var(--track-width) var(--track-color);
  }

  .tab-group--end .tab-group__indicator {
    left: calc(-1 * var(--track-width));
    border-inline-start: solid var(--track-width) var(--indicator-color);
  }

  .tab-group--end.tab-group--rtl .tab-group__indicator {
    right: calc(-1 * var(--track-width));
    left: auto;
  }

  .tab-group--end .tab-group__body {
    flex: 1 1 auto;
    order: 1;
  }

  .tab-group--end ::slotted(sl-tab-panel) {
    --padding: 0 var(--sl-spacing-medium);
  }
`;
function Yw(i, e) {
  return {
    top: Math.round(i.getBoundingClientRect().top - e.getBoundingClientRect().top),
    left: Math.round(i.getBoundingClientRect().left - e.getBoundingClientRect().left)
  };
}
function id(i, e, t = "vertical", r = "smooth") {
  const s = Yw(i, e), o = s.top + e.scrollTop, n = s.left + e.scrollLeft, a = e.scrollLeft, l = e.scrollLeft + e.offsetWidth, c = e.scrollTop, d = e.scrollTop + e.offsetHeight;
  (t === "horizontal" || t === "both") && (n < a ? e.scrollTo({ left: n, behavior: r }) : n + i.clientWidth > l && e.scrollTo({ left: n - e.offsetWidth + i.clientWidth, behavior: r })), (t === "vertical" || t === "both") && (o < c ? e.scrollTo({ top: o, behavior: r }) : o + i.clientHeight > d && e.scrollTo({ top: o - e.offsetHeight + i.clientHeight, behavior: r }));
}
var ye = class extends it {
  constructor() {
    super(...arguments), this.localize = new Af(this), this.tabs = [], this.panels = [], this.hasScrollControls = !1, this.placement = "top", this.activation = "auto", this.noScrollControls = !1;
  }
  connectedCallback() {
    const i = Promise.all([
      customElements.whenDefined("sl-tab"),
      customElements.whenDefined("sl-tab-panel")
    ]);
    super.connectedCallback(), this.resizeObserver = new ResizeObserver(() => {
      this.repositionIndicator(), this.updateScrollControls();
    }), this.mutationObserver = new MutationObserver((e) => {
      e.some((t) => !["aria-labelledby", "aria-controls"].includes(t.attributeName)) && setTimeout(() => this.setAriaLabels()), e.some((t) => t.attributeName === "disabled") && this.syncTabsAndPanels();
    }), this.updateComplete.then(() => {
      this.syncTabsAndPanels(), this.mutationObserver.observe(this, { attributes: !0, childList: !0, subtree: !0 }), this.resizeObserver.observe(this.nav), i.then(() => {
        new IntersectionObserver((t, r) => {
          var s;
          t[0].intersectionRatio > 0 && (this.setAriaLabels(), this.setActiveTab((s = this.getActiveTab()) != null ? s : this.tabs[0], { emitEvents: !1 }), r.unobserve(t[0].target));
        }).observe(this.tabGroup);
      });
    });
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.mutationObserver.disconnect(), this.resizeObserver.unobserve(this.nav);
  }
  getAllTabs(i = { includeDisabled: !0 }) {
    return [...this.shadowRoot.querySelector('slot[name="nav"]').assignedElements()].filter((t) => i.includeDisabled ? t.tagName.toLowerCase() === "sl-tab" : t.tagName.toLowerCase() === "sl-tab" && !t.disabled);
  }
  getAllPanels() {
    return [...this.body.assignedElements()].filter((i) => i.tagName.toLowerCase() === "sl-tab-panel");
  }
  getActiveTab() {
    return this.tabs.find((i) => i.active);
  }
  handleClick(i) {
    const t = i.target.closest("sl-tab");
    (t == null ? void 0 : t.closest("sl-tab-group")) === this && t !== null && this.setActiveTab(t, { scrollBehavior: "smooth" });
  }
  handleKeyDown(i) {
    const t = i.target.closest("sl-tab");
    if ((t == null ? void 0 : t.closest("sl-tab-group")) === this && (["Enter", " "].includes(i.key) && t !== null && (this.setActiveTab(t, { scrollBehavior: "smooth" }), i.preventDefault()), ["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown", "Home", "End"].includes(i.key))) {
      const s = this.tabs.find((n) => n.matches(":focus")), o = this.localize.dir() === "rtl";
      if ((s == null ? void 0 : s.tagName.toLowerCase()) === "sl-tab") {
        let n = this.tabs.indexOf(s);
        i.key === "Home" ? n = 0 : i.key === "End" ? n = this.tabs.length - 1 : ["top", "bottom"].includes(this.placement) && i.key === (o ? "ArrowRight" : "ArrowLeft") || ["start", "end"].includes(this.placement) && i.key === "ArrowUp" ? n-- : (["top", "bottom"].includes(this.placement) && i.key === (o ? "ArrowLeft" : "ArrowRight") || ["start", "end"].includes(this.placement) && i.key === "ArrowDown") && n++, n < 0 && (n = this.tabs.length - 1), n > this.tabs.length - 1 && (n = 0), this.tabs[n].focus({ preventScroll: !0 }), this.activation === "auto" && this.setActiveTab(this.tabs[n], { scrollBehavior: "smooth" }), ["top", "bottom"].includes(this.placement) && id(this.tabs[n], this.nav, "horizontal"), i.preventDefault();
      }
    }
  }
  handleScrollToStart() {
    this.nav.scroll({
      left: this.localize.dir() === "rtl" ? this.nav.scrollLeft + this.nav.clientWidth : this.nav.scrollLeft - this.nav.clientWidth,
      behavior: "smooth"
    });
  }
  handleScrollToEnd() {
    this.nav.scroll({
      left: this.localize.dir() === "rtl" ? this.nav.scrollLeft - this.nav.clientWidth : this.nav.scrollLeft + this.nav.clientWidth,
      behavior: "smooth"
    });
  }
  setActiveTab(i, e) {
    if (e = Qa({
      emitEvents: !0,
      scrollBehavior: "auto"
    }, e), i !== this.activeTab && !i.disabled) {
      const t = this.activeTab;
      this.activeTab = i, this.tabs.forEach((r) => r.active = r === this.activeTab), this.panels.forEach((r) => {
        var s;
        return r.active = r.name === ((s = this.activeTab) == null ? void 0 : s.panel);
      }), this.syncIndicator(), ["top", "bottom"].includes(this.placement) && id(this.activeTab, this.nav, "horizontal", e.scrollBehavior), e.emitEvents && (t && this.emit("sl-tab-hide", { detail: { name: t.panel } }), this.emit("sl-tab-show", { detail: { name: this.activeTab.panel } }));
    }
  }
  setAriaLabels() {
    this.tabs.forEach((i) => {
      const e = this.panels.find((t) => t.name === i.panel);
      e && (i.setAttribute("aria-controls", e.getAttribute("id")), e.setAttribute("aria-labelledby", i.getAttribute("id")));
    });
  }
  repositionIndicator() {
    const i = this.getActiveTab();
    if (!i)
      return;
    const e = i.clientWidth, t = i.clientHeight, r = this.localize.dir() === "rtl", s = this.getAllTabs(), n = s.slice(0, s.indexOf(i)).reduce(
      (a, l) => ({
        left: a.left + l.clientWidth,
        top: a.top + l.clientHeight
      }),
      { left: 0, top: 0 }
    );
    switch (this.placement) {
      case "top":
      case "bottom":
        this.indicator.style.width = `${e}px`, this.indicator.style.height = "auto", this.indicator.style.translate = r ? `${-1 * n.left}px` : `${n.left}px`;
        break;
      case "start":
      case "end":
        this.indicator.style.width = "auto", this.indicator.style.height = `${t}px`, this.indicator.style.translate = `0 ${n.top}px`;
        break;
    }
  }
  // This stores tabs and panels so we can refer to a cache instead of calling querySelectorAll() multiple times.
  syncTabsAndPanels() {
    this.tabs = this.getAllTabs({ includeDisabled: !1 }), this.panels = this.getAllPanels(), this.syncIndicator(), this.updateComplete.then(() => this.updateScrollControls());
  }
  updateScrollControls() {
    this.noScrollControls ? this.hasScrollControls = !1 : this.hasScrollControls = ["top", "bottom"].includes(this.placement) && this.nav.scrollWidth > this.nav.clientWidth;
  }
  syncIndicator() {
    this.getActiveTab() ? (this.indicator.style.display = "block", this.repositionIndicator()) : this.indicator.style.display = "none";
  }
  /** Shows the specified tab panel. */
  show(i) {
    const e = this.tabs.find((t) => t.panel === i);
    e && this.setActiveTab(e, { scrollBehavior: "smooth" });
  }
  render() {
    const i = this.localize.dir() === "rtl";
    return vt`
      <div
        part="base"
        class=${vo({
      "tab-group": !0,
      "tab-group--top": this.placement === "top",
      "tab-group--bottom": this.placement === "bottom",
      "tab-group--start": this.placement === "start",
      "tab-group--end": this.placement === "end",
      "tab-group--rtl": this.localize.dir() === "rtl",
      "tab-group--has-scroll-controls": this.hasScrollControls
    })}
        @click=${this.handleClick}
        @keydown=${this.handleKeyDown}
      >
        <div class="tab-group__nav-container" part="nav">
          ${this.hasScrollControls ? vt`
                <sl-icon-button
                  part="scroll-button scroll-button--start"
                  exportparts="base:scroll-button__base"
                  class="tab-group__scroll-button tab-group__scroll-button--start"
                  name=${i ? "chevron-right" : "chevron-left"}
                  library="system"
                  label=${this.localize.term("scrollToStart")}
                  @click=${this.handleScrollToStart}
                ></sl-icon-button>
              ` : ""}

          <div class="tab-group__nav">
            <div part="tabs" class="tab-group__tabs" role="tablist">
              <div part="active-tab-indicator" class="tab-group__indicator"></div>
              <slot name="nav" @slotchange=${this.syncTabsAndPanels}></slot>
            </div>
          </div>

          ${this.hasScrollControls ? vt`
                <sl-icon-button
                  part="scroll-button scroll-button--end"
                  exportparts="base:scroll-button__base"
                  class="tab-group__scroll-button tab-group__scroll-button--end"
                  name=${i ? "chevron-left" : "chevron-right"}
                  library="system"
                  label=${this.localize.term("scrollToEnd")}
                  @click=${this.handleScrollToEnd}
                ></sl-icon-button>
              ` : ""}
        </div>

        <slot part="body" class="tab-group__body" @slotchange=${this.syncTabsAndPanels}></slot>
      </div>
    `;
  }
};
ye.styles = Gw;
ye.dependencies = { "sl-icon-button": ue };
A([
  Vr(".tab-group")
], ye.prototype, "tabGroup", 2);
A([
  Vr(".tab-group__body")
], ye.prototype, "body", 2);
A([
  Vr(".tab-group__nav")
], ye.prototype, "nav", 2);
A([
  Vr(".tab-group__indicator")
], ye.prototype, "indicator", 2);
A([
  rl()
], ye.prototype, "hasScrollControls", 2);
A([
  H()
], ye.prototype, "placement", 2);
A([
  H()
], ye.prototype, "activation", 2);
A([
  H({ attribute: "no-scroll-controls", type: Boolean })
], ye.prototype, "noScrollControls", 2);
A([
  rr("noScrollControls", { waitUntilFirstUpdate: !0 })
], ye.prototype, "updateScrollControls", 1);
A([
  rr("placement", { waitUntilFirstUpdate: !0 })
], ye.prototype, "syncIndicator", 1);
ye.define("sl-tab-group");
var Zw = Object.defineProperty, Kw = Object.getOwnPropertyDescriptor, Qw = Object.getPrototypeOf, Jw = Reflect.get, Ef = (i, e, t, r) => {
  for (var s = r > 1 ? void 0 : r ? Kw(e, t) : e, o = i.length - 1, n; o >= 0; o--)
    (n = i[o]) && (s = (r ? n(e, t, s) : n(s)) || s);
  return r && s && Zw(e, t, s), s;
}, Xw = (i, e, t) => Jw(Qw(i), t, e);
let jt = class extends Xt {
  constructor() {
    super(...arguments), this.assignedPages = [];
  }
  firstUpdated(i) {
    super.firstUpdated(i);
  }
  updated(i) {
    super.updated(i);
  }
  selectPage(i) {
    let e = this.shadowRoot.querySelector("sl-tab-group");
    setTimeout(() => e.show(i), 100);
  }
  tryClose(i) {
    const e = i.target;
    if ("panel" in e) {
      const t = e.panel, r = new CustomEvent("close", { detail: t });
      this.dispatchEvent(r);
    }
  }
  apiRender() {
    return this.assignedPages.length == 0 ? p`` : p`
            <div class="kiosk-query-layouter">
                <sl-tab-group @sl-close="${this.tryClose}">
                    ${this.assignedPages.map((i) => p`
                        <sl-tab slot="nav" panel="${i[0]}" closable>${i[1]}</sl-tab>
                    `)}
                    ${this.assignedPages.map((i) => p`
                        <sl-tab-panel name="${i[0]}"><slot name="${i[0]}"></slot></sl-tab-panel>
                    `)}
                </sl-tab-group>
            </div>
        `;
  }
};
jt.styles = tt(tw);
jt.properties = {
  ...Xw(jt, jt, "properties")
};
Ef([
  G()
], jt.prototype, "assignedPages", 2);
jt = Ef([
  Qt("kiosk-query-layouter")
], jt);
const ex = `.col-bg-body-lighter{background-color:var(--col-bg-body-lighter)}.col-bg-body{background-color:var(--col-bg-body)}.col-bg-body-darker{background-color:var(--col-bg-body-darker)}.col-bg-1-lighter{background-color:var(--col-bg-1-lighter)}.col-bg-1{background-color:var(--col-bg-1)}.col-bg-1-darker{background-color:var(--col-bg-1-darker)}.col-bg-1-input{background-color:var(--col-bg-1-input)}.col-primary-bg-1{background-color:var(--col-primary-bg-1)}.col-accent-bg-1{background-color:var(--col-accent-bg-1)}.col-success-bg-1{background-color:var(--col-success-bg-1)}.col-warning-bg-1{background-color:var(--col-warning-bg-1)}.col-error-bg-1{background-color:var(--col-error-bg-1)}.col-bg-2-lighter{background-color:var(--col-bg-2-lighter)}.col-bg-2{background-color:var(--col-bg-2)}.col-bg-2-darker{background-color:var(--col-bg-2-darker)}.col-bg-2-button{background-color:var(--col-bg-2-button)}.col-bg-2-input{background-color:var(--col-bg-2-input)}.col-primary-bg-2{background-color:var(--col-primary-bg-2)}.col-accent-bg-2{background-color:var(--col-accent-bg-2)}.col-success-bg-2{background-color:var(--col-success-bg-2)}.col-warning-bg-2{background-color:var(--col-warning-bg-2)}.col-error-bg-2{background-color:var(--col-error-bg-2)}.col-bg-3-lighter{background-color:var(--col-bg-3-lighter)}.col-bg-3{background-color:var(--col-bg-3)}.col-bg-3-darker{background-color:var(--col-bg-3-darker)}.col-bg-3-button{background-color:var(--col-bg-3-button)}.col-bg-3-input{background-color:var(--col-bg-3-input)}.col-primary-bg-3{background-color:var(--col-primary-bg-3)}.col-accent-bg-3{background-color:var(--col-accent-bg-3)}.col-success-bg-3{background-color:var(--col-success-bg-3)}.col-warning-bg-3{background-color:var(--col-warning-bg-3)}.col-error-bg-3{background-color:var(--col-error-bg-3)}.col-bg-ack-lighter{background-color:var(--col-bg-ack-lighter)}.col-bg-ack{background-color:var(--col-bg-ack)}.col-bg-ack-darker{background-color:var(--col-bg-ack-darker)}.col-primary-bg-ack{background-color:var(--col-primary-bg-ack)}.col-accent-bg-ack{background-color:var(--col-accent-bg-ack)}.col-bg-att-lighter{background-color:var(--col-bg-att-lighter)}.col-bg-att{background-color:var(--col-bg-att)}.col-bg-att-darker{background-color:var(--col-bg-att-darker)}.col-primary-bg-att{background-color:var(--col-primary-bg-att)}.col-accent-bg-att{background-color:var(--col-accent-bg-att)}.col-bg-alert-lighter{background-color:var(--col-bg-alert-lighter)}.col-bg-alert{background-color:var(--col-bg-alert)}.col-bg-alert-darker{background-color:var(--col-bg-alert-darker)}.col-primary-bg-alert{background-color:var(--col-primary-bg-alert)}.col-accent-bg-alert{background-color:var(--col-accent-bg-alert)}.col-bg-btn-lighter{background-color:var(--col-bg-btn-lighter)}.col-bg-btn{background-color:var(--col-bg-btn)}.col-bg-btn-darker{background-color:var(--col-bg-btn-darker)}.col-primary-bg-btn{background-color:var(--col-primary-bg-btn)}.col-accent-bg-btn{background-color:var(--col-accent-bg-btn)}.pattern-diagonal-stripes-sm{background:repeating-linear-gradient(45deg,transparent,transparent 10px,currentColor 10px,currentColor 20px)}.pattern-dots-lg{background-image:radial-gradient(currentColor 1.5px,transparent 1.5px);background-size:15px 15px}.pattern-dots-md{background-image:radial-gradient(currentColor 1px,transparent 1px);background-size:8px 8px}.pattern-dots-medium-dense{background-image:radial-gradient(currentColor .5px,transparent .5px);background-size:3px 3px}.pattern-dots-sm{background-image:radial-gradient(currentColor .5px,transparent .5px);background-size:5px 5px}.pattern-cross-dots-md,.imagelist-background{background-image:radial-gradient(currentColor .7px,transparent 1px),radial-gradient(currentColor .7px,transparent 1px);background-size:6.5px 6.5px;background-position:0 0,3.5px 3.5px}.imagelist-background{background-color:#fff9;background-blend-mode:overlay}*{box-sizing:border-box}.loading{display:flex;justify-content:center;align-content:center;height:5px;background-color:#000;width:100%}.loading-progress{height:5px;width:100%;border-radius:3px;background:linear-gradient(90deg,red 0%,yellow 15%,lime 30%,cyan 50%,blue 65%,magenta 80%,red 100%);background-size:200%;animation:move-gradient 2s ease-in infinite}.loading-message{font-family:var(--monospace-font);text-align:center;width:100%;color:var(--col-accent-bg-1);padding:1em}@keyframes move-gradient{0%{background-position:0 0}to{background-position:-200% 0%}}p,div{padding:0;margin:0;border:0px;-webkit-user-select:text;user-select:text}select{-webkit-user-select:none;user-select:none}.fa,.fas{font-family:"Font Awesome 6 Free";font-weight:900;font-style:normal}.fa-trash:before{content:""}.fa-view-grid:before{content:""}.fa-reload:before{content:""}.fa-view-list:before{content:""}.fa-camera:before{content:""}.fa-view-image:before{content:""}.fa-check:before{content:""}.fa-bug:before{content:""}.fa-lightbulb:before{content:""}.fa-query:before{content:""}.fa-footsteps{transform:rotate(270deg)}.fa-footsteps:before{content:""}i{font-family:"Font Awesome 6 Free";font-style:normal;font-variant:normal;text-rendering:auto;-webkit-font-smoothing:antialiased;font-weight:900;font-size:.9em}:host{--lumo-font-size-s: $font-size-standard;--_lumo-grid-secondary-border-color: $col-bg-1-lighter;--_lumo-grid-border-width: 5px;--lumo-font-family: $standard-text;--lumo-size-m: $font-size-standard}:host *{-webkit-user-select:none;user-select:none}.kiosk-view{background-color:var(--col-bg-2);--ui-col-bg-1: $col-bg-2;--ui-button-width: 42px;--ui-button-height: 42px;--ui-button-font-size: 20px;padding:.5em}.local-error{display:flex;flex-direction:row;align-items:center;padding:.5rem;background-color:var(--col-bg-alert);color:var(--col-primary-bg-alert);min-height:3em}.missing-record-message{display:flex;flex-direction:row;align-items:center;padding:.5rem;background-color:var(--col-bg-1-darker);color:var(--col-primary-bg-1);min-height:3em}.missing-record-message i{font-style:normal;font-size:var(--font-size-h3);vertical-align:middle;font-family:"Font Awesome 6 Free";padding-right:1em}.part-header{background-color:#000;color:#fff;padding:0 4px;transform:translate(-8px);box-shadow:#00000080 -4px 2px 5px;margin:.5em 0;width:max-content}.part-header i{margin-left:1em;font-weight:400}.accordion-part-header{background-color:var(--col-bg-1-lighter);color:#fff;padding-left:4px;width:100%;display:flex;flex-direction:row;justify-content:space-between;margin:.5em 0}.accordion-part-header i{background-color:var(--col-bg-2);color:#000;border-style:none;font-weight:700;margin-left:5px;font-size:1.5em;line-height:1.5em;vertical-align:middle}.accordion-part-header div:nth-child(2){background-color:var(--col-bg-2)}.accordion-part-header div:first-child{background-color:#000;color:#fff;padding:.3em 1em 0 6px;transform:translate(-12px);box-shadow:#00000080 -4px 2px 5px;width:max-content}.part-body{overflow-y:auto}
`;
/**
 * @license
 * Copyright (c) 2017 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const wo = y`
  :host {
    top: var(--lumo-space-m);
    right: var(--lumo-space-m);
    bottom: var(--lumo-space-m);
    left: var(--lumo-space-m);
    /* Workaround for Edge issue (only on Surface), where an overflowing vaadin-list-box inside vaadin-select-overlay makes the overlay transparent */
    /* stylelint-disable-next-line */
    outline: 0px solid transparent;
  }

  [part='overlay'] {
    background-color: var(--lumo-base-color);
    background-image: linear-gradient(var(--lumo-tint-5pct), var(--lumo-tint-5pct));
    border-radius: var(--lumo-border-radius-m);
    box-shadow: 0 0 0 1px var(--lumo-shade-5pct), var(--lumo-box-shadow-m);
    color: var(--lumo-body-text-color);
    font-family: var(--lumo-font-family);
    font-size: var(--lumo-font-size-m);
    font-weight: 400;
    line-height: var(--lumo-line-height-m);
    letter-spacing: 0;
    text-transform: none;
    -webkit-text-size-adjust: 100%;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }

  [part='content'] {
    padding: var(--lumo-space-xs);
  }

  [part='backdrop'] {
    background-color: var(--lumo-shade-20pct);
    animation: 0.2s lumo-overlay-backdrop-enter both;
    will-change: opacity;
  }

  @keyframes lumo-overlay-backdrop-enter {
    0% {
      opacity: 0;
    }
  }

  :host([closing]) [part='backdrop'] {
    animation: 0.2s lumo-overlay-backdrop-exit both;
  }

  @keyframes lumo-overlay-backdrop-exit {
    100% {
      opacity: 0;
    }
  }

  @keyframes lumo-overlay-dummy-animation {
    0% {
      opacity: 1;
    }

    100% {
      opacity: 1;
    }
  }
`;
C("", wo, { moduleId: "lumo-overlay" });
/**
 * @license
 * Copyright (c) 2017 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const xo = y`
  :host([opening]),
  :host([closing]) {
    animation: 0.14s lumo-overlay-dummy-animation;
  }

  [part='overlay'] {
    will-change: opacity, transform;
  }

  :host([opening]) [part='overlay'] {
    animation: 0.1s lumo-menu-overlay-enter ease-out both;
  }

  @keyframes lumo-menu-overlay-enter {
    0% {
      opacity: 0;
      transform: translateY(-4px);
    }
  }

  :host([closing]) [part='overlay'] {
    animation: 0.1s lumo-menu-overlay-exit both;
  }

  @keyframes lumo-menu-overlay-exit {
    100% {
      opacity: 0;
    }
  }
`;
C("", xo, { moduleId: "lumo-menu-overlay-core" });
const tx = y`
  /* Small viewport (bottom sheet) styles */
  /* Use direct media queries instead of the state attributes ([phone] and [fullscreen]) provided by the elements */
  @media (max-width: 420px), (max-height: 420px) {
    :host {
      top: 0 !important;
      right: 0 !important;
      bottom: var(--vaadin-overlay-viewport-bottom, 0) !important;
      left: 0 !important;
      align-items: stretch !important;
      justify-content: flex-end !important;
    }

    [part='overlay'] {
      max-height: 50vh;
      width: 100vw;
      border-radius: 0;
      box-shadow: var(--lumo-box-shadow-xl);
    }

    /* The content part scrolls instead of the overlay part, because of the gradient fade-out */
    [part='content'] {
      padding: 30px var(--lumo-space-m);
      max-height: inherit;
      box-sizing: border-box;
      -webkit-overflow-scrolling: touch;
      overflow: auto;
      -webkit-mask-image: linear-gradient(transparent, #000 40px, #000 calc(100% - 40px), transparent);
      mask-image: linear-gradient(transparent, #000 40px, #000 calc(100% - 40px), transparent);
    }

    [part='backdrop'] {
      display: block;
    }

    /* Animations */

    :host([opening]) [part='overlay'] {
      animation: 0.2s lumo-mobile-menu-overlay-enter cubic-bezier(0.215, 0.61, 0.355, 1) both;
    }

    :host([closing]),
    :host([closing]) [part='backdrop'] {
      animation-delay: 0.14s;
    }

    :host([closing]) [part='overlay'] {
      animation: 0.14s 0.14s lumo-mobile-menu-overlay-exit cubic-bezier(0.55, 0.055, 0.675, 0.19) both;
    }
  }

  @keyframes lumo-mobile-menu-overlay-enter {
    0% {
      transform: translateY(150%);
    }
  }

  @keyframes lumo-mobile-menu-overlay-exit {
    100% {
      transform: translateY(150%);
    }
  }
`, Sf = [wo, xo, tx];
C("", Sf, { moduleId: "lumo-menu-overlay" });
const rx = y`
  [part='overlay'] {
    /*
  Width:
      date cell widths
    + month calendar side padding
    + year scroller width
  */
    /* prettier-ignore */
    width:
    calc(
        var(--lumo-size-m) * 7
      + var(--lumo-space-xs) * 2
      + 57px
    );
    height: 100%;
    max-height: calc(var(--lumo-size-m) * 14);
    overflow: hidden;
    -webkit-tap-highlight-color: transparent;
  }

  [part='overlay'] {
    flex-direction: column;
  }

  [part='content'] {
    padding: 0;
    height: 100%;
    overflow: hidden;
    -webkit-mask-image: none;
    mask-image: none;
  }

  :host([top-aligned]) [part~='overlay'] {
    margin-top: var(--lumo-space-xs);
  }

  :host([bottom-aligned]) [part~='overlay'] {
    margin-bottom: var(--lumo-space-xs);
  }

  @media (max-width: 420px), (max-height: 420px) {
    [part='overlay'] {
      width: 100vw;
      height: 70vh;
      max-height: 70vh;
    }
  }
`;
C("vaadin-date-picker-overlay", [Sf, rx], {
  moduleId: "lumo-date-picker-overlay"
});
const ix = y`
  :host {
    /* Sizing */
    --lumo-button-size: var(--lumo-size-m);
    min-width: calc(var(--lumo-button-size) * 2);
    height: var(--lumo-button-size);
    padding: 0 calc(var(--lumo-button-size) / 3 + var(--lumo-border-radius-m) / 2);
    margin: var(--lumo-space-xs) 0;
    box-sizing: border-box;
    /* Style */
    font-family: var(--lumo-font-family);
    font-size: var(--lumo-font-size-m);
    font-weight: 500;
    color: var(--_lumo-button-color, var(--lumo-primary-text-color));
    background-color: var(--_lumo-button-background-color, var(--lumo-contrast-5pct));
    border-radius: var(--lumo-border-radius-m);
    cursor: var(--lumo-clickable-cursor);
    -webkit-tap-highlight-color: transparent;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    flex-shrink: 0;
  }

  /* Set only for the internal parts so we don't affect the host vertical alignment */
  [part='label'],
  [part='prefix'],
  [part='suffix'] {
    line-height: var(--lumo-line-height-xs);
  }

  [part='label'] {
    padding: calc(var(--lumo-button-size) / 6) 0;
  }

  :host([theme~='small']) {
    font-size: var(--lumo-font-size-s);
    --lumo-button-size: var(--lumo-size-s);
  }

  :host([theme~='large']) {
    font-size: var(--lumo-font-size-l);
    --lumo-button-size: var(--lumo-size-l);
  }

  /* For interaction states */
  :host::before,
  :host::after {
    content: '';
    /* We rely on the host always being relative */
    position: absolute;
    z-index: 1;
    inset: 0;
    background-color: currentColor;
    border-radius: inherit;
    opacity: 0;
    pointer-events: none;
  }

  /* Hover */

  @media (any-hover: hover) {
    :host(:hover)::before {
      opacity: 0.02;
    }
  }

  /* Active */

  :host::after {
    transition: opacity 1.4s, transform 0.1s;
    filter: blur(8px);
  }

  :host([active])::before {
    opacity: 0.05;
    transition-duration: 0s;
  }

  :host([active])::after {
    opacity: 0.1;
    transition-duration: 0s, 0s;
    transform: scale(0);
  }

  /* Keyboard focus */

  :host([focus-ring]) {
    box-shadow: 0 0 0 2px var(--lumo-primary-color-50pct);
  }

  :host([theme~='primary'][focus-ring]) {
    box-shadow: 0 0 0 1px var(--lumo-base-color), 0 0 0 3px var(--lumo-primary-color-50pct);
  }

  /* Types (primary, tertiary, tertiary-inline */

  :host([theme~='tertiary']),
  :host([theme~='tertiary-inline']) {
    background-color: transparent !important;
    min-width: 0;
  }

  :host([theme~='tertiary']) {
    padding: 0 calc(var(--lumo-button-size) / 6);
  }

  :host([theme~='tertiary-inline'])::before {
    display: none;
  }

  :host([theme~='tertiary-inline']) {
    margin: 0;
    height: auto;
    padding: 0;
    line-height: inherit;
    font-size: inherit;
  }

  :host([theme~='tertiary-inline']) [part='label'] {
    padding: 0;
    overflow: visible;
    line-height: inherit;
  }

  :host([theme~='primary']) {
    background-color: var(--_lumo-button-primary-background-color, var(--lumo-primary-color));
    color: var(--_lumo-button-primary-color, var(--lumo-primary-contrast-color));
    font-weight: 600;
    min-width: calc(var(--lumo-button-size) * 2.5);
  }

  :host([theme~='primary'])::before {
    background-color: black;
  }

  @media (any-hover: hover) {
    :host([theme~='primary']:hover)::before {
      opacity: 0.05;
    }
  }

  :host([theme~='primary'][active])::before {
    opacity: 0.1;
  }

  :host([theme~='primary'][active])::after {
    opacity: 0.2;
  }

  /* Colors (success, error, contrast) */

  :host([theme~='success']) {
    color: var(--lumo-success-text-color);
  }

  :host([theme~='success'][theme~='primary']) {
    background-color: var(--lumo-success-color);
    color: var(--lumo-success-contrast-color);
  }

  :host([theme~='error']) {
    color: var(--lumo-error-text-color);
  }

  :host([theme~='error'][theme~='primary']) {
    background-color: var(--lumo-error-color);
    color: var(--lumo-error-contrast-color);
  }

  :host([theme~='contrast']) {
    color: var(--lumo-contrast);
  }

  :host([theme~='contrast'][theme~='primary']) {
    background-color: var(--lumo-contrast);
    color: var(--lumo-base-color);
  }

  /* Disabled state. Keep selectors after other color variants. */

  :host([disabled]) {
    pointer-events: none;
    color: var(--lumo-disabled-text-color);
  }

  :host([theme~='primary'][disabled]) {
    background-color: var(--lumo-contrast-30pct);
    color: var(--lumo-base-color);
  }

  :host([theme~='primary'][disabled]) [part] {
    opacity: 0.7;
  }

  /* Icons */

  [part] ::slotted(vaadin-icon) {
    display: inline-block;
    width: var(--lumo-icon-size-m);
    height: var(--lumo-icon-size-m);
  }

  /* Vaadin icons are based on a 16x16 grid (unlike Lumo and Material icons with 24x24), so they look too big by default */
  [part] ::slotted(vaadin-icon[icon^='vaadin:']) {
    padding: 0.25em;
    box-sizing: border-box !important;
  }

  [part='prefix'] {
    margin-left: -0.25em;
    margin-right: 0.25em;
  }

  [part='suffix'] {
    margin-left: 0.25em;
    margin-right: -0.25em;
  }

  /* Icon-only */

  :host([theme~='icon']:not([theme~='tertiary-inline'])) {
    min-width: var(--lumo-button-size);
    padding-left: calc(var(--lumo-button-size) / 4);
    padding-right: calc(var(--lumo-button-size) / 4);
  }

  :host([theme~='icon']) [part='prefix'],
  :host([theme~='icon']) [part='suffix'] {
    margin-left: 0;
    margin-right: 0;
  }

  /* RTL specific styles */

  :host([dir='rtl']) [part='prefix'] {
    margin-left: 0.25em;
    margin-right: -0.25em;
  }

  :host([dir='rtl']) [part='suffix'] {
    margin-left: -0.25em;
    margin-right: 0.25em;
  }

  :host([dir='rtl'][theme~='icon']) [part='prefix'],
  :host([dir='rtl'][theme~='icon']) [part='suffix'] {
    margin-left: 0;
    margin-right: 0;
  }
`;
C("vaadin-button", ix, { moduleId: "lumo-button" });
/**
 * @license
 * Copyright (c) 2017 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const sx = y`
  :host {
    display: inline-block;
    position: relative;
    outline: none;
    white-space: nowrap;
    -webkit-user-select: none;
    -moz-user-select: none;
    user-select: none;
  }

  :host([hidden]) {
    display: none !important;
  }

  /* Aligns the button with form fields when placed on the same line.
  Note, to make it work, the form fields should have the same "::before" pseudo-element. */
  .vaadin-button-container::before {
    content: '\\2003';
    display: inline-block;
    width: 0;
    max-height: 100%;
  }

  .vaadin-button-container {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    text-align: center;
    width: 100%;
    height: 100%;
    min-height: inherit;
    text-shadow: inherit;
  }

  [part='prefix'],
  [part='suffix'] {
    flex: none;
  }

  [part='label'] {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  @media (forced-colors: active) {
    :host {
      outline: 1px solid;
      outline-offset: -1px;
    }

    :host([focused]) {
      outline-width: 2px;
    }

    :host([disabled]) {
      outline-color: GrayText;
    }
  }
`, ox = (i) => i`
  <div class="vaadin-button-container">
    <span part="prefix" aria-hidden="true">
      <slot name="prefix"></slot>
    </span>
    <span part="label">
      <slot></slot>
    </span>
    <span part="suffix" aria-hidden="true">
      <slot name="suffix"></slot>
    </span>
  </div>
  <slot name="tooltip"></slot>
`;
/**
 * @license
 * Copyright (c) 2017 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const nx = (i) => class extends Fh(Ra(Hi(i))) {
  static get properties() {
    return {
      /**
       * Indicates whether the element can be focused and where it participates in sequential keyboard navigation.
       *
       * @override
       * @protected
       */
      tabindex: {
        type: Number,
        value: 0,
        reflectToAttribute: !0
      }
    };
  }
  /**
   * By default, `Space` is the only possible activation key for a focusable HTML element.
   * Nonetheless, the button is an exception as it can be also activated by pressing `Enter`.
   * See the "Keyboard Support" section in https://www.w3.org/TR/wai-aria-practices/examples/button/button.html.
   *
   * @protected
   * @override
   */
  get _activeKeys() {
    return ["Enter", " "];
  }
  /** @protected */
  ready() {
    super.ready(), this.hasAttribute("role") || this.setAttribute("role", "button");
  }
  /**
   * Since the button component is designed on the base of the `[role=button]` attribute,
   * and doesn't have a native <button> inside, in order to be fully accessible from the keyboard,
   * it should manually fire the `click` event once an activation key is pressed,
   * as it follows from the WAI-ARIA specifications:
   * https://www.w3.org/TR/wai-aria-practices-1.1/#button
   *
   * According to the UI Events specifications,
   * the `click` event should be fired exactly on `keydown`:
   * https://www.w3.org/TR/uievents/#event-type-keydown
   *
   * @param {KeyboardEvent} event
   * @protected
   * @override
   */
  _onKeyDown(t) {
    super._onKeyDown(t), !(t.altKey || t.shiftKey || t.ctrlKey || t.metaKey) && this._activeKeys.includes(t.key) && (t.preventDefault(), this.click());
  }
};
/**
 * @license
 * Copyright (c) 2017 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
C("vaadin-button", sx, { moduleId: "vaadin-button-styles" });
class ax extends nx(At(X(rt(N)))) {
  static get is() {
    return "vaadin-button";
  }
  static get template() {
    return ox(U);
  }
  /** @protected */
  ready() {
    super.ready(), this._tooltipController = new Et(this), this.addController(this._tooltipController);
  }
}
O(ax);
C(
  "vaadin-date-picker-year",
  y`
    :host([current]) [part='year-number'] {
      color: var(--lumo-primary-text-color);
    }

    :host(:not([current])) [part='year-number'],
    [part='year-separator'] {
      opacity: var(--_lumo-date-picker-year-opacity, 0.7);
      transition: 0.2s opacity;
    }

    [part='year-number'],
    [part='year-separator'] {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 50%;
      transform: translateY(-50%);
    }

    [part='year-separator']::after {
      color: var(--lumo-disabled-text-color);
      content: '\\2022';
    }
  `,
  { moduleId: "lumo-date-picker-year" }
);
C(
  "vaadin-date-picker-overlay-content",
  y`
    :host {
      position: relative;
      /* Background for the year scroller, placed here as we are using a mask image on the actual years part */
      background-image: linear-gradient(var(--lumo-shade-5pct), var(--lumo-shade-5pct));
      background-size: 57px 100%;
      background-position: top right;
      background-repeat: no-repeat;
      cursor: default;
    }

    ::slotted([slot='months']) {
      /* Month calendar height:
              header height + margin-bottom
            + weekdays height + margin-bottom
            + date cell heights
            + small margin between month calendars
        */
      /* prettier-ignore */
      --vaadin-infinite-scroller-item-height:
          calc(
              var(--lumo-font-size-l) + var(--lumo-space-m)
            + var(--lumo-font-size-xs) + var(--lumo-space-s)
            + var(--lumo-size-m) * 6
            + var(--lumo-space-s)
          );
      --vaadin-infinite-scroller-buffer-offset: 10%;
      -webkit-mask-image: linear-gradient(transparent, #000 10%, #000 85%, transparent);
      mask-image: linear-gradient(transparent, #000 10%, #000 85%, transparent);
      position: relative;
      margin-right: 57px;
    }

    ::slotted([slot='years']) {
      /* TODO get rid of fixed magic number */
      --vaadin-infinite-scroller-buffer-width: 97px;
      width: 57px;
      height: auto;
      top: 0;
      bottom: 0;
      font-size: var(--lumo-font-size-s);
      box-shadow: inset 2px 0 4px 0 var(--lumo-shade-5pct);
      -webkit-mask-image: linear-gradient(transparent, #000 35%, #000 65%, transparent);
      mask-image: linear-gradient(transparent, #000 35%, #000 65%, transparent);
      cursor: var(--lumo-clickable-cursor);
    }

    ::slotted([slot='years']:hover) {
      --_lumo-date-picker-year-opacity: 1;
    }

    /* TODO unsupported selector */
    #scrollers {
      position: static;
      display: block;
    }

    /* TODO fix this in vaadin-date-picker that it adapts to the width of the year scroller */
    :host([desktop]) ::slotted([slot='months']) {
      right: auto;
    }

    /* Year scroller position indicator */
    ::slotted([slot='years'])::before {
      border: none;
      width: 1em;
      height: 1em;
      background-color: var(--lumo-base-color);
      background-image: linear-gradient(var(--lumo-tint-5pct), var(--lumo-tint-5pct));
      transform: translate(-75%, -50%) rotate(45deg);
      border-top-right-radius: var(--lumo-border-radius-s);
      box-shadow: 2px -2px 6px 0 var(--lumo-shade-5pct);
      z-index: 1;
    }

    [part='toolbar'] {
      padding: var(--lumo-space-s);
      border-bottom-left-radius: var(--lumo-border-radius-l);
      margin-right: 57px;
    }

    [part='toolbar'] ::slotted(vaadin-button) {
      margin: 0;
    }

    /* Narrow viewport mode (fullscreen) */

    :host([fullscreen]) [part='toolbar'] {
      order: -1;
      background-color: var(--lumo-base-color);
    }

    :host([fullscreen]) [part='overlay-header'] {
      order: -2;
      height: var(--lumo-size-m);
      padding: var(--lumo-space-s);
      position: absolute;
      left: 0;
      right: 0;
      justify-content: center;
    }

    :host([fullscreen]) [part='toggle-button'],
    :host([fullscreen]) [part='clear-button'],
    [part='overlay-header'] [part='label'] {
      display: none;
    }

    /* Very narrow screen (year scroller initially hidden) */

    [part='years-toggle-button'] {
      display: flex;
      align-items: center;
      height: var(--lumo-size-s);
      padding: 0 0.5em;
      border-radius: var(--lumo-border-radius-m);
      z-index: 3;
      color: var(--lumo-primary-text-color);
      font-weight: 500;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    :host([years-visible]) [part='years-toggle-button'] {
      background-color: var(--lumo-primary-color);
      color: var(--lumo-primary-contrast-color);
    }

    /* TODO magic number (same as used for media-query in vaadin-date-picker-overlay-content) */
    @media screen and (max-width: 374px) {
      :host {
        background-image: none;
      }

      [part='toolbar'],
      ::slotted([slot='months']) {
        margin-right: 0;
      }

      /* TODO make date-picker adapt to the width of the years part */
      ::slotted([slot='years']) {
        --vaadin-infinite-scroller-buffer-width: 90px;
        width: 50px;
        background-color: var(--lumo-shade-5pct);
      }

      :host([years-visible]) ::slotted([slot='months']) {
        padding-left: 50px;
      }
    }
  `,
  { moduleId: "lumo-date-picker-overlay-content" }
);
C(
  "vaadin-month-calendar",
  y`
    :host {
      -moz-user-select: none;
      -webkit-user-select: none;
      -webkit-tap-highlight-color: transparent;
      user-select: none;
      font-size: var(--lumo-font-size-m);
      color: var(--lumo-body-text-color);
      text-align: center;
      padding: 0 var(--lumo-space-xs);
    }

    /* Month header */

    [part='month-header'] {
      color: var(--lumo-header-text-color);
      font-size: var(--lumo-font-size-l);
      line-height: 1;
      font-weight: 500;
      margin-bottom: var(--lumo-space-m);
    }

    /* Week days and numbers */

    [part='weekdays'],
    [part='weekday'],
    [part='week-number'] {
      font-size: var(--lumo-font-size-xxs);
      line-height: 1;
      color: var(--lumo-secondary-text-color);
    }

    [part='weekdays'] {
      margin-bottom: var(--lumo-space-s);
    }

    [part='weekday']:empty,
    [part='week-number'] {
      width: var(--lumo-size-xs);
    }

    /* Date and week number cells */

    [part~='date'],
    [part='week-number'] {
      box-sizing: border-box;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      height: var(--lumo-size-m);
      position: relative;
    }

    [part~='date'] {
      transition: color 0.1s;
    }

    [part~='date']:not(:empty) {
      cursor: var(--lumo-clickable-cursor);
    }

    :host([week-numbers]) [part='weekday']:not(:empty),
    :host([week-numbers]) [part~='date'] {
      width: calc((100% - var(--lumo-size-xs)) / 7);
    }

    /* Today date */

    [part~='date'][part~='today'] {
      color: var(--lumo-primary-text-color);
    }

    /* Focused date */

    [part~='date']::before {
      content: '';
      position: absolute;
      z-index: -1;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      min-width: 2em;
      min-height: 2em;
      width: 80%;
      height: 80%;
      max-height: 100%;
      max-width: 100%;
      border-radius: var(--lumo-border-radius-m);
    }

    [part~='date'][part~='focused']::before {
      box-shadow: 0 0 0 1px var(--lumo-base-color), 0 0 0 3px var(--lumo-primary-color-50pct);
    }

    :host(:not([focused])) [part~='date'][part~='focused']::before {
      animation: vaadin-date-picker-month-calendar-focus-date 1.4s infinite;
    }

    @keyframes vaadin-date-picker-month-calendar-focus-date {
      50% {
        box-shadow: 0 0 0 1px var(--lumo-base-color), 0 0 0 3px transparent;
      }
    }

    [part~='date']:not(:empty):not([part~='disabled']):not([part~='selected']):hover::before {
      background-color: var(--lumo-primary-color-10pct);
    }

    [part~='date'][part~='selected'] {
      color: var(--lumo-primary-contrast-color);
    }

    [part~='date'][part~='selected']::before {
      background-color: var(--lumo-primary-color);
    }

    [part~='date'][part~='disabled'] {
      color: var(--lumo-disabled-text-color);
    }

    @media (pointer: coarse) {
      [part~='date']:hover:not([part~='selected'])::before,
      [part~='focused']:not([part~='selected'])::before {
        display: none;
      }

      [part~='date']:not(:empty):not([part~='disabled']):active::before {
        display: block;
      }

      [part~='date'][part~='selected']::before {
        box-shadow: none;
      }
    }

    /* Disabled */

    :host([disabled]) * {
      color: var(--lumo-disabled-text-color) !important;
    }
  `,
  { moduleId: "lumo-month-calendar" }
);
const Tf = document.createElement("template");
Tf.innerHTML = `
  <style>
    @keyframes vaadin-date-picker-month-calendar-focus-date {
      50% {
        box-shadow: 0 0 0 2px transparent;
      }
    }
  </style>
`;
document.head.appendChild(Tf.content);
const lx = y`
  :host {
    outline: none;
  }

  [part='toggle-button']::before {
    content: var(--lumo-icons-calendar);
  }

  [part='clear-button']::before {
    content: var(--lumo-icons-cross);
  }

  @media (max-width: 420px), (max-height: 420px) {
    [part='overlay-content'] {
      height: 70vh;
    }
  }

  :host([dir='rtl']) [part='input-field'] ::slotted(input) {
    --_lumo-text-field-overflow-mask-image: linear-gradient(to left, transparent, #000 1.25em);
  }

  :host([dir='rtl']) [part='input-field'] ::slotted(input:placeholder-shown) {
    --_lumo-text-field-overflow-mask-image: none;
  }
`;
C("vaadin-date-picker", [Wi, lx], { moduleId: "lumo-date-picker" });
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
let ea = !1, cx = [], If = [];
function dx() {
  ea = !0, requestAnimationFrame(function() {
    ea = !1, ux(cx), setTimeout(function() {
      hx(If);
    });
  });
}
function ux(i) {
  for (; i.length; )
    Df(i.shift());
}
function hx(i) {
  for (let e = 0, t = i.length; e < t; e++)
    Df(i.shift());
}
function Df(i) {
  const e = i[0], t = i[1], r = i[2];
  try {
    t.apply(e, r);
  } catch (s) {
    setTimeout(() => {
      throw s;
    });
  }
}
function Of(i, e, t) {
  ea || dx(), If.push([i, e, t]);
}
/**
 * @license
 * Copyright (c) 2017 Anton Korzunov
 * SPDX-License-Identifier: MIT
 */
let cr = /* @__PURE__ */ new WeakMap(), us = /* @__PURE__ */ new WeakMap(), hs = {}, dn = 0;
const sd = (i) => i && i.nodeType === Node.ELEMENT_NODE, un = (...i) => {
}, fx = (i, e) => sd(i) ? e.map((t) => {
  if (!sd(t))
    return un(t, "is not a valid element"), null;
  let r = t;
  for (; r && r !== i; ) {
    if (i.contains(r))
      return t;
    r = r.getRootNode().host;
  }
  return un(t, "is not contained inside", i), null;
}).filter((t) => !!t) : (un(i, "is not a valid element"), []), px = (i, e, t, r) => {
  const s = fx(e, Array.isArray(i) ? i : [i]);
  hs[t] || (hs[t] = /* @__PURE__ */ new WeakMap());
  const o = hs[t], n = [], a = /* @__PURE__ */ new Set(), l = new Set(s), c = (u) => {
    if (!u || a.has(u))
      return;
    a.add(u);
    const h = u.assignedSlot;
    h && c(h), c(u.parentNode || u.host);
  };
  s.forEach(c);
  const d = (u) => {
    if (!u || l.has(u))
      return;
    const h = u.shadowRoot;
    (h ? [...u.children, ...h.children] : [...u.children]).forEach((m) => {
      if (!["template", "script", "style"].includes(m.localName))
        if (a.has(m))
          d(m);
        else {
          const v = m.getAttribute(r), k = v !== null && v !== "false", M = (cr.get(m) || 0) + 1, F = (o.get(m) || 0) + 1;
          cr.set(m, M), o.set(m, F), n.push(m), M === 1 && k && us.set(m, !0), F === 1 && m.setAttribute(t, "true"), k || m.setAttribute(r, "true");
        }
    });
  };
  return d(e), a.clear(), dn += 1, () => {
    n.forEach((u) => {
      const h = cr.get(u) - 1, f = o.get(u) - 1;
      cr.set(u, h), o.set(u, f), h || (us.has(u) ? us.delete(u) : u.removeAttribute(r)), f || u.removeAttribute(t);
    }), dn -= 1, dn || (cr = /* @__PURE__ */ new WeakMap(), cr = /* @__PURE__ */ new WeakMap(), us = /* @__PURE__ */ new WeakMap(), hs = {});
  };
}, $f = (i, e = document.body, t = "data-aria-hidden") => {
  const r = Array.from(Array.isArray(i) ? i : [i]);
  return e && r.push(...Array.from(e.querySelectorAll("[aria-live]"))), px(r, e, t, "aria-hidden");
};
/**
 * @license
 * Copyright (c) 2021 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class mx {
  /**
   * @param {HTMLElement} host
   */
  constructor(e, t) {
    this.host = e, this.callback = typeof t == "function" ? t : () => e;
  }
  /**
   * Make the controller host modal by hiding other elements from screen readers
   * using `aria-hidden` attribute (can be replaced with `inert` in the future).
   *
   * The method name is chosen to align with the one provided by native `<dialog>`:
   * https://developer.mozilla.org/en-US/docs/Web/API/HTMLDialogElement/showModal
   */
  showModal() {
    const e = this.callback();
    this.__showOthers = $f(e);
  }
  /**
   * Remove `aria-hidden` from other elements unless there are any other
   * controller hosts on the page activated by using `showModal()` call.
   */
  close() {
    this.__showOthers && (this.__showOthers(), this.__showOthers = null);
  }
}
/**
 * @license
 * Copyright (c) 2017 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const gx = (i) => class extends rt(i) {
  static get properties() {
    return {
      /**
       * When true, opening the overlay moves focus to the first focusable child,
       * or to the overlay part with tabindex if there are no focusable children.
       * @attr {boolean} focus-trap
       */
      focusTrap: {
        type: Boolean,
        value: !1
      },
      /**
       * Set to true to enable restoring of focus when overlay is closed.
       * @attr {boolean} restore-focus-on-close
       */
      restoreFocusOnClose: {
        type: Boolean,
        value: !1
      },
      /**
       * Set to specify the element which should be focused on overlay close,
       * if `restoreFocusOnClose` is set to true.
       * @type {HTMLElement}
       */
      restoreFocusNode: {
        type: HTMLElement
      }
    };
  }
  constructor() {
    super(), this.__ariaModalController = new mx(this), this.__focusTrapController = new Vv(this), this.__focusRestorationController = new Hv();
  }
  /** @protected */
  ready() {
    super.ready(), this.addController(this.__ariaModalController), this.addController(this.__focusTrapController), this.addController(this.__focusRestorationController);
  }
  /**
   * Release focus and restore focus after the overlay is closed.
   *
   * @protected
   */
  _resetFocus() {
    this.focusTrap && (this.__ariaModalController.close(), this.__focusTrapController.releaseFocus()), this.restoreFocusOnClose && this._shouldRestoreFocus() && this.__focusRestorationController.restoreFocus();
  }
  /**
   * Save the previously focused node when the overlay starts to open.
   *
   * @protected
   */
  _saveFocus() {
    this.restoreFocusOnClose && this.__focusRestorationController.saveFocus(this.restoreFocusNode);
  }
  /**
   * Trap focus within the overlay after opening has completed.
   *
   * @protected
   */
  _trapFocus() {
    this.focusTrap && (this.__ariaModalController.showModal(), this.__focusTrapController.trapFocus(this.$.overlay));
  }
  /**
   * Returns true if focus is still inside the overlay or on the body element,
   * otherwise false.
   *
   * Focus shouldn't be restored if it's been moved elsewhere by another
   * component or as a result of a user interaction e.g. the user clicked
   * on a button outside the overlay while the overlay was open.
   *
   * @protected
   * @return {boolean}
   */
  _shouldRestoreFocus() {
    const t = qn();
    return t === document.body || this._deepContains(t);
  }
  /**
   * Returns true if the overlay contains the given node,
   * including those within shadow DOM trees.
   *
   * @param {Node} node
   * @return {boolean}
   * @protected
   */
  _deepContains(t) {
    if (this.contains(t))
      return !0;
    let r = t;
    const s = t.ownerDocument;
    for (; r && r !== s && r !== this; )
      r = r.parentNode || r.host;
    return r === this;
  }
};
/**
 * @license
 * Copyright (c) 2017 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const As = () => Array.from(document.body.children).filter((i) => i instanceof HTMLElement && i._hasOverlayStackMixin && !i.hasAttribute("closing")).sort((i, e) => i.__zIndex - e.__zIndex || 0), _x = (i) => i === As().pop(), bx = (i) => class extends i {
  constructor() {
    super(), this._hasOverlayStackMixin = !0;
  }
  /**
   * Returns true if this is the last one in the opened overlays stack.
   *
   * @return {boolean}
   * @protected
   */
  get _last() {
    return _x(this);
  }
  /**
   * Brings the overlay as visually the frontmost one.
   */
  bringToFront() {
    let t = "";
    const r = As().filter((s) => s !== this).pop();
    r && (t = r.__zIndex + 1), this.style.zIndex = t, this.__zIndex = t || parseFloat(getComputedStyle(this).zIndex);
  }
  /** @protected */
  _enterModalState() {
    document.body.style.pointerEvents !== "none" && (this._previousDocumentPointerEvents = document.body.style.pointerEvents, document.body.style.pointerEvents = "none"), As().forEach((t) => {
      t !== this && (t.$.overlay.style.pointerEvents = "none");
    });
  }
  /** @protected */
  _exitModalState() {
    this._previousDocumentPointerEvents !== void 0 && (document.body.style.pointerEvents = this._previousDocumentPointerEvents, delete this._previousDocumentPointerEvents);
    const t = As();
    let r;
    for (; (r = t.pop()) && !(r !== this && (r.$.overlay.style.removeProperty("pointer-events"), !r.modeless)); )
      ;
  }
};
/**
 * @license
 * Copyright (c) 2017 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const il = (i) => class extends gx(bx(i)) {
  static get properties() {
    return {
      /**
       * When true, the overlay is visible and attached to body.
       */
      opened: {
        type: Boolean,
        notify: !0,
        observer: "_openedChanged",
        reflectToAttribute: !0
      },
      /**
       * Owner element passed with renderer function
       * @type {HTMLElement}
       */
      owner: {
        type: Object
      },
      /**
       * Object with properties that is passed to `renderer` function
       */
      model: {
        type: Object
      },
      /**
       * Custom function for rendering the content of the overlay.
       * Receives three arguments:
       *
       * - `root` The root container DOM element. Append your content to it.
       * - `owner` The host element of the renderer function.
       * - `model` The object with the properties related with rendering.
       * @type {OverlayRenderer | null | undefined}
       */
      renderer: {
        type: Object
      },
      /**
       * When true the overlay won't disable the main content, showing
       * it doesn't change the functionality of the user interface.
       * @type {boolean}
       */
      modeless: {
        type: Boolean,
        value: !1,
        reflectToAttribute: !0,
        observer: "_modelessChanged"
      },
      /**
       * When set to true, the overlay is hidden. This also closes the overlay
       * immediately in case there is a closing animation in progress.
       * @type {boolean}
       */
      hidden: {
        type: Boolean,
        reflectToAttribute: !0,
        observer: "_hiddenChanged"
      },
      /**
       * When true the overlay has backdrop on top of content when opened.
       * @type {boolean}
       */
      withBackdrop: {
        type: Boolean,
        value: !1,
        reflectToAttribute: !0
      }
    };
  }
  static get observers() {
    return ["_rendererOrDataChanged(renderer, owner, model, opened)"];
  }
  constructor() {
    super(), this._boundMouseDownListener = this._mouseDownListener.bind(this), this._boundMouseUpListener = this._mouseUpListener.bind(this), this._boundOutsideClickListener = this._outsideClickListener.bind(this), this._boundKeydownListener = this._keydownListener.bind(this), Hs && (this._boundIosResizeListener = () => this._detectIosNavbar());
  }
  /** @protected */
  ready() {
    super.ready(), this.addEventListener("click", () => {
    }), this.$.backdrop.addEventListener("click", () => {
    });
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback(), this._boundIosResizeListener && (this._detectIosNavbar(), window.addEventListener("resize", this._boundIosResizeListener));
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback(), this._boundIosResizeListener && window.removeEventListener("resize", this._boundIosResizeListener);
  }
  /**
   * Requests an update for the content of the overlay.
   * While performing the update, it invokes the renderer passed in the `renderer` property.
   *
   * It is not guaranteed that the update happens immediately (synchronously) after it is requested.
   */
  requestContentUpdate() {
    this.renderer && this.renderer.call(this.owner, this, this.owner, this.model);
  }
  /**
   * @param {Event=} sourceEvent
   */
  close(t) {
    const r = new CustomEvent("vaadin-overlay-close", {
      bubbles: !0,
      cancelable: !0,
      detail: { sourceEvent: t }
    });
    this.dispatchEvent(r), r.defaultPrevented || (this.opened = !1);
  }
  /** @private */
  _detectIosNavbar() {
    if (!this.opened)
      return;
    const t = window.innerHeight, s = window.innerWidth > t, o = document.documentElement.clientHeight;
    s && o > t ? this.style.setProperty("--vaadin-overlay-viewport-bottom", `${o - t}px`) : this.style.setProperty("--vaadin-overlay-viewport-bottom", "0");
  }
  /** @private */
  _addGlobalListeners() {
    document.addEventListener("mousedown", this._boundMouseDownListener), document.addEventListener("mouseup", this._boundMouseUpListener), document.documentElement.addEventListener("click", this._boundOutsideClickListener, !0);
  }
  /** @private */
  _removeGlobalListeners() {
    document.removeEventListener("mousedown", this._boundMouseDownListener), document.removeEventListener("mouseup", this._boundMouseUpListener), document.documentElement.removeEventListener("click", this._boundOutsideClickListener, !0);
  }
  /** @private */
  _rendererOrDataChanged(t, r, s, o) {
    const n = this._oldOwner !== r || this._oldModel !== s;
    this._oldModel = s, this._oldOwner = r;
    const a = this._oldRenderer !== t;
    this._oldRenderer = t;
    const l = this._oldOpened !== o;
    this._oldOpened = o, a && (this.innerHTML = "", delete this._$litPart$), o && t && (a || l || n) && this.requestContentUpdate();
  }
  /** @private */
  _modelessChanged(t) {
    t ? (this._removeGlobalListeners(), this._exitModalState()) : this.opened && (this._addGlobalListeners(), this._enterModalState());
  }
  /** @private */
  _openedChanged(t, r) {
    t ? (this._saveFocus(), this._animatedOpening(), Of(this, () => {
      this._trapFocus();
      const s = new CustomEvent("vaadin-overlay-open", { bubbles: !0 });
      this.dispatchEvent(s);
    }), document.addEventListener("keydown", this._boundKeydownListener), this.modeless || this._addGlobalListeners()) : r && (this._resetFocus(), this._animatedClosing(), document.removeEventListener("keydown", this._boundKeydownListener), this.modeless || this._removeGlobalListeners());
  }
  /** @private */
  _hiddenChanged(t) {
    t && this.hasAttribute("closing") && this._flushAnimation("closing");
  }
  /**
   * @return {boolean}
   * @private
   */
  _shouldAnimate() {
    const t = getComputedStyle(this), r = t.getPropertyValue("animation-name");
    return !(t.getPropertyValue("display") === "none") && r && r !== "none";
  }
  /**
   * @param {string} type
   * @param {Function} callback
   * @private
   */
  _enqueueAnimation(t, r) {
    const s = `__${t}Handler`, o = (n) => {
      n && n.target !== this || (r(), this.removeEventListener("animationend", o), delete this[s]);
    };
    this[s] = o, this.addEventListener("animationend", o);
  }
  /**
   * @param {string} type
   * @protected
   */
  _flushAnimation(t) {
    const r = `__${t}Handler`;
    typeof this[r] == "function" && this[r]();
  }
  /** @private */
  _animatedOpening() {
    this.parentNode === document.body && this.hasAttribute("closing") && this._flushAnimation("closing"), this._attachOverlay(), this.modeless || this._enterModalState(), this.setAttribute("opening", ""), this._shouldAnimate() ? this._enqueueAnimation("opening", () => {
      this._finishOpening();
    }) : this._finishOpening();
  }
  /** @private */
  _attachOverlay() {
    this._placeholder = document.createComment("vaadin-overlay-placeholder"), this.parentNode.insertBefore(this._placeholder, this), document.body.appendChild(this), this.bringToFront();
  }
  /** @private */
  _finishOpening() {
    this.removeAttribute("opening");
  }
  /** @private */
  _finishClosing() {
    this._detachOverlay(), this.$.overlay.style.removeProperty("pointer-events"), this.removeAttribute("closing"), this.dispatchEvent(new CustomEvent("vaadin-overlay-closed"));
  }
  /** @private */
  _animatedClosing() {
    this.hasAttribute("opening") && this._flushAnimation("opening"), this._placeholder && (this._exitModalState(), this.setAttribute("closing", ""), this.dispatchEvent(new CustomEvent("vaadin-overlay-closing")), this._shouldAnimate() ? this._enqueueAnimation("closing", () => {
      this._finishClosing();
    }) : this._finishClosing());
  }
  /** @private */
  _detachOverlay() {
    this._placeholder.parentNode.insertBefore(this, this._placeholder), this._placeholder.parentNode.removeChild(this._placeholder);
  }
  /** @private */
  _mouseDownListener(t) {
    this._mouseDownInside = t.composedPath().indexOf(this.$.overlay) >= 0;
  }
  /** @private */
  _mouseUpListener(t) {
    this._mouseUpInside = t.composedPath().indexOf(this.$.overlay) >= 0;
  }
  /**
   * Whether to close the overlay on outside click or not.
   * Override this method to customize the closing logic.
   *
   * @param {Event} _event
   * @return {boolean}
   * @protected
   */
  _shouldCloseOnOutsideClick(t) {
    return this._last;
  }
  /**
   * Outside click listener used in capture phase to close the overlay before
   * propagating the event to the listener on the element that triggered it.
   * Otherwise, calling `open()` would result in closing and re-opening.
   *
   * @private
   */
  _outsideClickListener(t) {
    if (t.composedPath().includes(this.$.overlay) || this._mouseDownInside || this._mouseUpInside) {
      this._mouseDownInside = !1, this._mouseUpInside = !1;
      return;
    }
    if (!this._shouldCloseOnOutsideClick(t))
      return;
    const r = new CustomEvent("vaadin-overlay-outside-click", {
      bubbles: !0,
      cancelable: !0,
      detail: { sourceEvent: t }
    });
    this.dispatchEvent(r), this.opened && !r.defaultPrevented && this.close(t);
  }
  /**
   * Listener used to close whe overlay on Escape press, if it is the last one.
   * @private
   */
  _keydownListener(t) {
    if (this._last && !(this.modeless && !t.composedPath().includes(this.$.overlay)) && t.key === "Escape") {
      const r = new CustomEvent("vaadin-overlay-escape-press", {
        bubbles: !0,
        cancelable: !0,
        detail: { sourceEvent: t }
      });
      this.dispatchEvent(r), this.opened && !r.defaultPrevented && this.close(t);
    }
  }
};
/**
 * @license
 * Copyright (c) 2017 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const hn = {
  start: "top",
  end: "bottom"
}, fn = {
  start: "left",
  end: "right"
}, od = new ResizeObserver((i) => {
  setTimeout(() => {
    i.forEach((e) => {
      e.target.__overlay && e.target.__overlay._updatePosition();
    });
  });
}), Pf = (i) => class extends i {
  static get properties() {
    return {
      /**
       * The element next to which this overlay should be aligned.
       * The position of the overlay relative to the positionTarget can be adjusted
       * with properties `horizontalAlign`, `verticalAlign`, `noHorizontalOverlap`
       * and `noVerticalOverlap`.
       */
      positionTarget: {
        type: Object,
        value: null
      },
      /**
       * When `positionTarget` is set, this property defines whether to align the overlay's
       * left or right side to the target element by default.
       * Possible values are `start` and `end`.
       * RTL is taken into account when interpreting the value.
       * The overlay is automatically flipped to the opposite side when it doesn't fit into
       * the default side defined by this property.
       *
       * @attr {start|end} horizontal-align
       */
      horizontalAlign: {
        type: String,
        value: "start"
      },
      /**
       * When `positionTarget` is set, this property defines whether to align the overlay's
       * top or bottom side to the target element by default.
       * Possible values are `top` and `bottom`.
       * The overlay is automatically flipped to the opposite side when it doesn't fit into
       * the default side defined by this property.
       *
       * @attr {top|bottom} vertical-align
       */
      verticalAlign: {
        type: String,
        value: "top"
      },
      /**
       * When `positionTarget` is set, this property defines whether the overlay should overlap
       * the target element in the x-axis, or be positioned right next to it.
       *
       * @attr {boolean} no-horizontal-overlap
       */
      noHorizontalOverlap: {
        type: Boolean,
        value: !1
      },
      /**
       * When `positionTarget` is set, this property defines whether the overlay should overlap
       * the target element in the y-axis, or be positioned right above/below it.
       *
       * @attr {boolean} no-vertical-overlap
       */
      noVerticalOverlap: {
        type: Boolean,
        value: !1
      },
      /**
       * If the overlay content has no intrinsic height, this property can be used to set
       * the minimum vertical space (in pixels) required by the overlay. Setting a value to
       * the property effectively disables the content measurement in favor of using this
       * fixed value for determining the open direction.
       *
       * @attr {number} required-vertical-space
       */
      requiredVerticalSpace: {
        type: Number,
        value: 0
      }
    };
  }
  static get observers() {
    return [
      "__positionSettingsChanged(horizontalAlign, verticalAlign, noHorizontalOverlap, noVerticalOverlap, requiredVerticalSpace)",
      "__overlayOpenedChanged(opened, positionTarget)"
    ];
  }
  constructor() {
    super(), this.__onScroll = this.__onScroll.bind(this), this._updatePosition = this._updatePosition.bind(this);
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback(), this.opened && this.__addUpdatePositionEventListeners();
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback(), this.__removeUpdatePositionEventListeners();
  }
  /** @private */
  __addUpdatePositionEventListeners() {
    window.addEventListener("resize", this._updatePosition), this.__positionTargetAncestorRootNodes = $y(this.positionTarget), this.__positionTargetAncestorRootNodes.forEach((t) => {
      t.addEventListener("scroll", this.__onScroll, !0);
    });
  }
  /** @private */
  __removeUpdatePositionEventListeners() {
    window.removeEventListener("resize", this._updatePosition), this.__positionTargetAncestorRootNodes && (this.__positionTargetAncestorRootNodes.forEach((t) => {
      t.removeEventListener("scroll", this.__onScroll, !0);
    }), this.__positionTargetAncestorRootNodes = null);
  }
  /** @private */
  __overlayOpenedChanged(t, r) {
    if (this.__removeUpdatePositionEventListeners(), r && (r.__overlay = null, od.unobserve(r), t && (this.__addUpdatePositionEventListeners(), r.__overlay = this, od.observe(r))), t) {
      const s = getComputedStyle(this);
      this.__margins || (this.__margins = {}, ["top", "bottom", "left", "right"].forEach((o) => {
        this.__margins[o] = parseInt(s[o], 10);
      })), this.setAttribute("dir", s.direction), this._updatePosition(), requestAnimationFrame(() => this._updatePosition());
    }
  }
  __positionSettingsChanged() {
    this._updatePosition();
  }
  /** @private */
  __onScroll(t) {
    this.contains(t.target) || this._updatePosition();
  }
  _updatePosition() {
    if (!this.positionTarget || !this.opened)
      return;
    const t = this.positionTarget.getBoundingClientRect(), r = this.__shouldAlignStartVertically(t);
    this.style.justifyContent = r ? "flex-start" : "flex-end";
    const s = this.__isRTL, o = this.__shouldAlignStartHorizontally(t, s), n = !s && o || s && !o;
    this.style.alignItems = n ? "flex-start" : "flex-end";
    const a = this.getBoundingClientRect(), l = this.__calculatePositionInOneDimension(
      t,
      a,
      this.noVerticalOverlap,
      hn,
      this,
      r
    ), c = this.__calculatePositionInOneDimension(
      t,
      a,
      this.noHorizontalOverlap,
      fn,
      this,
      o
    );
    Object.assign(this.style, l, c), this.toggleAttribute("bottom-aligned", !r), this.toggleAttribute("top-aligned", r), this.toggleAttribute("end-aligned", !n), this.toggleAttribute("start-aligned", n);
  }
  __shouldAlignStartHorizontally(t, r) {
    const s = Math.max(this.__oldContentWidth || 0, this.$.overlay.offsetWidth);
    this.__oldContentWidth = this.$.overlay.offsetWidth;
    const o = Math.min(window.innerWidth, document.documentElement.clientWidth), n = !r && this.horizontalAlign === "start" || r && this.horizontalAlign === "end";
    return this.__shouldAlignStart(
      t,
      s,
      o,
      this.__margins,
      n,
      this.noHorizontalOverlap,
      fn
    );
  }
  __shouldAlignStartVertically(t) {
    const r = this.requiredVerticalSpace || Math.max(this.__oldContentHeight || 0, this.$.overlay.offsetHeight);
    this.__oldContentHeight = this.$.overlay.offsetHeight;
    const s = Math.min(window.innerHeight, document.documentElement.clientHeight), o = this.verticalAlign === "top";
    return this.__shouldAlignStart(
      t,
      r,
      s,
      this.__margins,
      o,
      this.noVerticalOverlap,
      hn
    );
  }
  // eslint-disable-next-line max-params
  __shouldAlignStart(t, r, s, o, n, a, l) {
    const c = s - t[a ? l.end : l.start] - o[l.end], d = t[a ? l.start : l.end] - o[l.start], u = n ? c : d, f = u > (n ? d : c) || u > r;
    return n === f;
  }
  /**
   * Returns an adjusted value after resizing the browser window,
   * to avoid wrong calculations when e.g. previously set `bottom`
   * CSS property value is larger than the updated viewport height.
   * See https://github.com/vaadin/web-components/issues/4604
   */
  __adjustBottomProperty(t, r, s) {
    let o;
    if (t === r.end) {
      if (r.end === hn.end) {
        const n = Math.min(window.innerHeight, document.documentElement.clientHeight);
        if (s > n && this.__oldViewportHeight) {
          const a = this.__oldViewportHeight - n;
          o = s - a;
        }
        this.__oldViewportHeight = n;
      }
      if (r.end === fn.end) {
        const n = Math.min(window.innerWidth, document.documentElement.clientWidth);
        if (s > n && this.__oldViewportWidth) {
          const a = this.__oldViewportWidth - n;
          o = s - a;
        }
        this.__oldViewportWidth = n;
      }
    }
    return o;
  }
  /**
   * Returns an object with CSS position properties to set,
   * e.g. { top: "100px" }
   */
  // eslint-disable-next-line max-params
  __calculatePositionInOneDimension(t, r, s, o, n, a) {
    const l = a ? o.start : o.end, c = a ? o.end : o.start, d = parseFloat(n.style[l] || getComputedStyle(n)[l]), u = this.__adjustBottomProperty(l, o, d), h = r[a ? o.start : o.end] - t[s === a ? o.end : o.start], f = u ? `${u}px` : `${d + h * (a ? -1 : 1)}px`;
    return {
      [l]: f,
      [c]: ""
    };
  }
};
/**
 * @license
 * Copyright (c) 2017 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const sl = y`
  :host {
    z-index: 200;
    position: fixed;

    /* Despite of what the names say, <vaadin-overlay> is just a container
          for position/sizing/alignment. The actual overlay is the overlay part. */

    /* Default position constraints: the entire viewport. Note: themes can
          override this to introduce gaps between the overlay and the viewport. */
    inset: 0;
    bottom: var(--vaadin-overlay-viewport-bottom);

    /* Use flexbox alignment for the overlay part. */
    display: flex;
    flex-direction: column; /* makes dropdowns sizing easier */
    /* Align to center by default. */
    align-items: center;
    justify-content: center;

    /* Allow centering when max-width/max-height applies. */
    margin: auto;

    /* The host is not clickable, only the overlay part is. */
    pointer-events: none;

    /* Remove tap highlight on touch devices. */
    -webkit-tap-highlight-color: transparent;

    /* CSS API for host */
    --vaadin-overlay-viewport-bottom: 0;
  }

  :host([hidden]),
  :host(:not([opened]):not([closing])) {
    display: none !important;
  }

  [part='overlay'] {
    -webkit-overflow-scrolling: touch;
    overflow: auto;
    pointer-events: auto;

    /* Prevent overflowing the host */
    max-width: 100%;
    box-sizing: border-box;

    -webkit-tap-highlight-color: initial; /* reenable tap highlight inside */
  }

  [part='backdrop'] {
    z-index: -1;
    content: '';
    background: rgba(0, 0, 0, 0.5);
    position: fixed;
    inset: 0;
    pointer-events: auto;
  }
`;
/**
 * @license
 * Copyright (c) 2016 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const yx = y`
  [part='overlay'] {
    display: flex;
    flex: auto;
  }

  [part~='content'] {
    flex: auto;
  }

  @media (forced-colors: active) {
    [part='overlay'] {
      outline: 3px solid;
    }
  }
`;
/**
 * @license
 * Copyright (c) 2016 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
C("vaadin-date-picker-overlay", [sl, yx], {
  moduleId: "vaadin-date-picker-overlay-styles"
});
class vx extends Pf(il(Be(X(N)))) {
  static get is() {
    return "vaadin-date-picker-overlay";
  }
  static get template() {
    return U`
      <div id="backdrop" part="backdrop" hidden$="[[!withBackdrop]]"></div>
      <div part="overlay" id="overlay">
        <div part="content" id="content">
          <slot></slot>
        </div>
      </div>
    `;
  }
}
O(vx);
/**
 * @license
 * Copyright (c) 2016 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function wx(i) {
  let e = i.getDay();
  e === 0 && (e = 7);
  const t = 4 - e, r = new Date(i.getTime() + t * 24 * 3600 * 1e3), s = new Date(0, 0);
  s.setFullYear(r.getFullYear());
  const o = r.getTime() - s.getTime(), n = Math.round(o / (24 * 3600 * 1e3));
  return Math.floor(n / 7 + 1);
}
function me(i, e) {
  return i instanceof Date && e instanceof Date && i.getFullYear() === e.getFullYear() && i.getMonth() === e.getMonth() && i.getDate() === e.getDate();
}
function $i(i, e, t) {
  return (!e || i >= e) && (!t || i <= t);
}
function Mf(i, e) {
  return e.filter((t) => t !== void 0).reduce((t, r) => {
    if (!r)
      return t;
    if (!t)
      return r;
    const s = Math.abs(i.getTime() - r.getTime()), o = Math.abs(t.getTime() - i.getTime());
    return s < o ? r : t;
  });
}
function zf(i) {
  return {
    day: i.getDate(),
    month: i.getMonth(),
    year: i.getFullYear()
  };
}
function Nf(i) {
  const e = /* @__PURE__ */ new Date(), t = new Date(e);
  return t.setDate(1), t.setMonth(parseInt(i) + e.getMonth()), t;
}
function xx(i, e, t = 0, r = 1) {
  if (e > 99)
    throw new Error("The provided year cannot have more than 2 digits.");
  if (e < 0)
    throw new Error("The provided year cannot be negative.");
  let s = e + Math.floor(i.getFullYear() / 100) * 100;
  return i < new Date(s - 50, t, r) ? s -= 100 : i > new Date(s + 50, t, r) && (s += 100), s;
}
function mr(i) {
  const e = /^([-+]\d{1}|\d{2,4}|[-+]\d{6})-(\d{1,2})-(\d{1,2})$/u.exec(i);
  if (!e)
    return;
  const t = new Date(0, 0);
  return t.setFullYear(parseInt(e[1], 10)), t.setMonth(parseInt(e[2], 10) - 1), t.setDate(parseInt(e[3], 10)), t;
}
/**
 * @license
 * Copyright (c) 2016 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Ff = document.createElement("template");
Ff.innerHTML = `
  <style>
    :host {
      display: block;
      overflow: hidden;
      height: 500px;
    }

    #scroller {
      position: relative;
      height: 100%;
      overflow: auto;
      outline: none;
      margin-right: -40px;
      -webkit-overflow-scrolling: touch;
      overflow-x: hidden;
    }

    #scroller.notouchscroll {
      -webkit-overflow-scrolling: auto;
    }

    #scroller::-webkit-scrollbar {
      display: none;
    }

    .buffer {
      position: absolute;
      width: var(--vaadin-infinite-scroller-buffer-width, 100%);
      box-sizing: border-box;
      padding-right: 40px;
      top: var(--vaadin-infinite-scroller-buffer-offset, 0);
      animation: fadein 0.2s;
    }

    @keyframes fadein {
      from {
        opacity: 0;
      }
      to {
        opacity: 1;
      }
    }
  </style>

  <div id="scroller">
    <div class="buffer"></div>
    <div class="buffer"></div>
    <div id="fullHeight"></div>
  </div>
`;
class Rf extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }).appendChild(Ff.content.cloneNode(!0)), this.bufferSize = 20, this._initialScroll = 5e5, this._initialIndex = 0, this._activated = !1;
  }
  /**
   * @return {boolean}
   */
  get active() {
    return this._activated;
  }
  set active(e) {
    e && !this._activated && (this._createPool(), this._activated = !0);
  }
  /**
   * @return {number}
   */
  get bufferOffset() {
    return this._buffers[0].offsetTop;
  }
  /**
   * @return {number}
   */
  get itemHeight() {
    if (!this._itemHeightVal) {
      const e = getComputedStyle(this).getPropertyValue("--vaadin-infinite-scroller-item-height"), t = "background-position";
      this.$.fullHeight.style.setProperty(t, e);
      const r = getComputedStyle(this.$.fullHeight).getPropertyValue(t);
      this.$.fullHeight.style.removeProperty(t), this._itemHeightVal = parseFloat(r);
    }
    return this._itemHeightVal;
  }
  /** @private */
  get _bufferHeight() {
    return this.itemHeight * this.bufferSize;
  }
  /**
   * @return {number}
   */
  get position() {
    return (this.$.scroller.scrollTop - this._buffers[0].translateY) / this.itemHeight + this._firstIndex;
  }
  /**
   * Current scroller position as index. Can be a fractional number.
   *
   * @type {number}
   */
  set position(e) {
    this._preventScrollEvent = !0, e > this._firstIndex && e < this._firstIndex + this.bufferSize * 2 ? this.$.scroller.scrollTop = this.itemHeight * (e - this._firstIndex) + this._buffers[0].translateY : (this._initialIndex = ~~e, this._reset(), this._scrollDisabled = !0, this.$.scroller.scrollTop += e % 1 * this.itemHeight, this._scrollDisabled = !1), this._mayHaveMomentum && (this.$.scroller.classList.add("notouchscroll"), this._mayHaveMomentum = !1, setTimeout(() => {
      this.$.scroller.classList.remove("notouchscroll");
    }, 10));
  }
  /** @protected */
  connectedCallback() {
    this._ready || (this._ready = !0, this.$ = {}, this.shadowRoot.querySelectorAll("[id]").forEach((e) => {
      this.$[e.id] = e;
    }), this.$.scroller.addEventListener("scroll", () => this._scroll()), this._buffers = [...this.shadowRoot.querySelectorAll(".buffer")], this.$.fullHeight.style.height = `${this._initialScroll * 2}px`, Wh && (this.$.scroller.tabIndex = -1));
  }
  /**
   * Force the scroller to update clones after a reset, without
   * waiting for the debouncer to resolve.
   */
  forceUpdate() {
    this._debouncerUpdateClones && (this._buffers[0].updated = this._buffers[1].updated = !1, this._updateClones(), this._debouncerUpdateClones.cancel());
  }
  /**
   * @protected
   * @override
   */
  _createElement() {
  }
  /**
   * @param {HTMLElement} _element
   * @param {number} _index
   * @protected
   * @override
   */
  _updateElement(e, t) {
  }
  /** @private */
  _finishInit() {
    this._initDone || (this._buffers.forEach((e) => {
      [...e.children].forEach((t) => {
        this._ensureStampedInstance(t._itemWrapper);
      });
    }), this._buffers[0].translateY || this._reset(), this._initDone = !0, this.dispatchEvent(new CustomEvent("init-done")));
  }
  /** @private */
  _translateBuffer(e) {
    const t = e ? 1 : 0;
    this._buffers[t].translateY = this._buffers[t ? 0 : 1].translateY + this._bufferHeight * (t ? -1 : 1), this._buffers[t].style.transform = `translate3d(0, ${this._buffers[t].translateY}px, 0)`, this._buffers[t].updated = !1, this._buffers.reverse();
  }
  /** @private */
  _scroll() {
    if (this._scrollDisabled)
      return;
    const e = this.$.scroller.scrollTop;
    (e < this._bufferHeight || e > this._initialScroll * 2 - this._bufferHeight) && (this._initialIndex = ~~this.position, this._reset());
    const t = this.itemHeight + this.bufferOffset, r = e > this._buffers[1].translateY + t, s = e < this._buffers[0].translateY + t;
    (r || s) && (this._translateBuffer(s), this._updateClones()), this._preventScrollEvent || (this.dispatchEvent(new CustomEvent("custom-scroll", { bubbles: !1, composed: !0 })), this._mayHaveMomentum = !0), this._preventScrollEvent = !1, this._debouncerScrollFinish = R.debounce(this._debouncerScrollFinish, _e.after(200), () => {
      const o = this.$.scroller.getBoundingClientRect();
      !this._isVisible(this._buffers[0], o) && !this._isVisible(this._buffers[1], o) && (this.position = this.position);
    });
  }
  /** @private */
  _reset() {
    this._scrollDisabled = !0, this.$.scroller.scrollTop = this._initialScroll, this._buffers[0].translateY = this._initialScroll - this._bufferHeight, this._buffers[1].translateY = this._initialScroll, this._buffers.forEach((e) => {
      e.style.transform = `translate3d(0, ${e.translateY}px, 0)`;
    }), this._buffers[0].updated = this._buffers[1].updated = !1, this._updateClones(!0), this._debouncerUpdateClones = R.debounce(this._debouncerUpdateClones, _e.after(200), () => {
      this._buffers[0].updated = this._buffers[1].updated = !1, this._updateClones();
    }), this._scrollDisabled = !1;
  }
  /** @private */
  _createPool() {
    const e = this.getBoundingClientRect();
    this._buffers.forEach((t) => {
      for (let r = 0; r < this.bufferSize; r++) {
        const s = document.createElement("div");
        s.style.height = `${this.itemHeight}px`, s.instance = {};
        const o = `vaadin-infinite-scroller-item-content-${Da()}`, n = document.createElement("slot");
        n.setAttribute("name", o), n._itemWrapper = s, t.appendChild(n), s.setAttribute("slot", o), this.appendChild(s), this._isVisible(s, e) && this._ensureStampedInstance(s);
      }
    }), requestAnimationFrame(() => {
      this._finishInit();
    });
  }
  /** @private */
  _ensureStampedInstance(e) {
    if (e.firstElementChild)
      return;
    const t = e.instance;
    e.instance = this._createElement(), e.appendChild(e.instance), Object.keys(t).forEach((r) => {
      e.instance[r] = t[r];
    });
  }
  /** @private */
  _updateClones(e) {
    this._firstIndex = ~~((this._buffers[0].translateY - this._initialScroll) / this.itemHeight) + this._initialIndex;
    const t = e ? this.$.scroller.getBoundingClientRect() : void 0;
    this._buffers.forEach((r, s) => {
      if (!r.updated) {
        const o = this._firstIndex + this.bufferSize * s;
        [...r.children].forEach((n, a) => {
          const l = n._itemWrapper;
          (!e || this._isVisible(l, t)) && this._updateElement(l.instance, o + a);
        }), r.updated = !0;
      }
    });
  }
  /** @private */
  _isVisible(e, t) {
    const r = e.getBoundingClientRect();
    return r.bottom > t.top && r.top < t.bottom;
  }
}
/**
 * @license
 * Copyright (c) 2016 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Lf = document.createElement("template");
Lf.innerHTML = `
  <style>
    :host {
      --vaadin-infinite-scroller-item-height: 270px;
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      height: 100%;
    }
  </style>
`;
class Cx extends Rf {
  static get is() {
    return "vaadin-date-picker-month-scroller";
  }
  constructor() {
    super(), this.bufferSize = 3, this.shadowRoot.appendChild(Lf.content.cloneNode(!0));
  }
  /**
   * @protected
   * @override
   */
  _createElement() {
    return document.createElement("vaadin-month-calendar");
  }
  /**
   * @param {HTMLElement} element
   * @param {number} index
   * @protected
   * @override
   */
  _updateElement(e, t) {
    e.month = Nf(t);
  }
}
O(Cx);
/**
 * @license
 * Copyright (c) 2016 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Vf = document.createElement("template");
Vf.innerHTML = `
  <style>
    :host {
      --vaadin-infinite-scroller-item-height: 80px;
      width: 50px;
      display: block;
      height: 100%;
      position: absolute;
      right: 0;
      transform: translateX(100%);
      -webkit-tap-highlight-color: transparent;
      -webkit-user-select: none;
      -moz-user-select: none;
      user-select: none;
      /* Center the year scroller position. */
      --vaadin-infinite-scroller-buffer-offset: 50%;
    }

    :host::before {
      content: '';
      display: block;
      background: transparent;
      width: 0;
      height: 0;
      position: absolute;
      left: 0;
      top: 50%;
      transform: translateY(-50%);
      border-width: 6px;
      border-style: solid;
      border-color: transparent;
      border-left-color: #000;
    }
  </style>
`;
class kx extends Rf {
  static get is() {
    return "vaadin-date-picker-year-scroller";
  }
  constructor() {
    super(), this.bufferSize = 12, this.shadowRoot.appendChild(Vf.content.cloneNode(!0));
  }
  /**
   * @protected
   * @override
   */
  _createElement() {
    return document.createElement("vaadin-date-picker-year");
  }
  /**
   * @param {HTMLElement} element
   * @param {number} index
   * @protected
   * @override
   */
  _updateElement(e, t) {
    e.year = this._yearAfterXYears(t);
  }
  /** @private */
  _yearAfterXYears(e) {
    const t = /* @__PURE__ */ new Date(), r = new Date(t);
    return r.setFullYear(parseInt(e) + t.getFullYear()), r.getFullYear();
  }
}
O(kx);
/**
 * @license
 * Copyright (c) 2016 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class Ax extends X(N) {
  static get is() {
    return "vaadin-date-picker-year";
  }
  static get template() {
    return U`
      <style>
        :host {
          display: block;
          height: 100%;
        }
      </style>
      <div part="year-number">[[year]]</div>
      <div part="year-separator" aria-hidden="true"></div>
    `;
  }
  static get properties() {
    return {
      year: {
        type: String
      },
      selectedDate: {
        type: Object
      }
    };
  }
  static get observers() {
    return ["__updateSelected(year, selectedDate)"];
  }
  /** @private */
  __updateSelected(e, t) {
    this.toggleAttribute("selected", t && t.getFullYear() === e), this.toggleAttribute("current", e === (/* @__PURE__ */ new Date()).getFullYear());
  }
}
O(Ax);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
function ol(i, e, t, r, s) {
  let o;
  s && (o = typeof t == "object" && t !== null, o && (r = i.__dataTemp[e]));
  let n = r !== t && (r === r || t === t);
  return o && n && (i.__dataTemp[e] = t), n;
}
const nl = Y((i) => {
  class e extends i {
    /**
     * Overrides `PropertyEffects` to provide option for skipping
     * strict equality checking for Objects and Arrays.
     *
     * This method pulls the value to dirty check against from the `__dataTemp`
     * cache (rather than the normal `__data` cache) for Objects.  Since the temp
     * cache is cleared at the end of a turn, this implementation allows
     * side-effects of deep object changes to be processed by re-setting the
     * same object (using the temp cache as an in-turn backstop to prevent
     * cycles due to 2-way notification).
     *
     * @param {string} property Property name
     * @param {*} value New property value
     * @param {*} old Previous property value
     * @return {boolean} Whether the property should be considered a change
     * @protected
     */
    _shouldPropertyChange(r, s, o) {
      return ol(this, r, s, o, !0);
    }
  }
  return e;
}), Ex = Y((i) => {
  class e extends i {
    /** @nocollapse */
    static get properties() {
      return {
        /**
         * Instance-level flag for configuring the dirty-checking strategy
         * for this element.  When true, Objects and Arrays will skip dirty
         * checking, otherwise strict equality checking will be used.
         */
        mutableData: Boolean
      };
    }
    /**
     * Overrides `PropertyEffects` to provide option for skipping
     * strict equality checking for Objects and Arrays.
     *
     * When `this.mutableData` is true on this instance, this method
     * pulls the value to dirty check against from the `__dataTemp` cache
     * (rather than the normal `__data` cache) for Objects.  Since the temp
     * cache is cleared at the end of a turn, this implementation allows
     * side-effects of deep object changes to be processed by re-setting the
     * same object (using the temp cache as an in-turn backstop to prevent
     * cycles due to 2-way notification).
     *
     * @param {string} property Property name
     * @param {*} value New property value
     * @param {*} old Previous property value
     * @return {boolean} Whether the property should be considered a change
     * @protected
     */
    _shouldPropertyChange(r, s, o) {
      return ol(this, r, s, o, this.mutableData);
    }
  }
  return e;
});
nl._mutablePropertyChange = ol;
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
let ta = null;
function ra() {
  return ta;
}
ra.prototype = Object.create(HTMLTemplateElement.prototype, {
  constructor: {
    value: ra,
    writable: !0
  }
});
const Hf = Sa(ra), Sx = nl(Hf);
function Tx(i, e) {
  ta = i, Object.setPrototypeOf(i, e.prototype), new e(), ta = null;
}
const Ix = Sa(class {
});
function Dx(i, e) {
  for (let t = 0; t < e.length; t++) {
    let r = e[t];
    if (!!i != !!r.__hideTemplateChildren__)
      if (r.nodeType === Node.TEXT_NODE)
        i ? (r.__polymerTextContent__ = r.textContent, r.textContent = "") : r.textContent = r.__polymerTextContent__;
      else if (r.localName === "slot")
        if (i)
          r.__polymerReplaced__ = document.createComment("hidden-slot"), B(B(r).parentNode).replaceChild(r.__polymerReplaced__, r);
        else {
          const s = r.__polymerReplaced__;
          s && B(B(s).parentNode).replaceChild(r, s);
        }
      else
        r.style && (i ? (r.__polymerDisplay__ = r.style.display, r.style.display = "none") : r.style.display = r.__polymerDisplay__);
    r.__hideTemplateChildren__ = i, r._showHideChildren && r._showHideChildren(i);
  }
}
class St extends Ix {
  constructor(e) {
    super(), this._configureProperties(e), this.root = this._stampTemplate(this.__dataHost);
    let t = [];
    this.children = /** @type {!NodeList} */
    t;
    for (let s = this.root.firstChild; s; s = s.nextSibling)
      t.push(s), s.__templatizeInstance = this;
    this.__templatizeOwner && this.__templatizeOwner.__hideTemplateChildren__ && this._showHideChildren(!0);
    let r = this.__templatizeOptions;
    (e && r.instanceProps || !r.instanceProps) && this._enableProperties();
  }
  /**
   * Configure the given `props` by calling `_setPendingProperty`. Also
   * sets any properties stored in `__hostProps`.
   * @private
   * @param {Object} props Object of property name-value pairs to set.
   * @return {void}
   */
  _configureProperties(e) {
    if (this.__templatizeOptions.forwardHostProp)
      for (let r in this.__hostProps)
        this._setPendingProperty(r, this.__dataHost["_host_" + r]);
    for (let r in e)
      this._setPendingProperty(r, e[r]);
  }
  /**
   * Forwards a host property to this instance.  This method should be
   * called on instances from the `options.forwardHostProp` callback
   * to propagate changes of host properties to each instance.
   *
   * Note this method enqueues the change, which are flushed as a batch.
   *
   * @param {string} prop Property or path name
   * @param {*} value Value of the property to forward
   * @return {void}
   */
  forwardHostProp(e, t) {
    this._setPendingPropertyOrPath(e, t, !1, !0) && this.__dataHost._enqueueClient(this);
  }
  /**
   * Override point for adding custom or simulated event handling.
   *
   * @override
   * @param {!Node} node Node to add event listener to
   * @param {string} eventName Name of event
   * @param {function(!Event):void} handler Listener function to add
   * @return {void}
   */
  _addEventListenerToNode(e, t, r) {
    if (this._methodHost && this.__templatizeOptions.parentModel)
      this._methodHost._addEventListenerToNode(e, t, (s) => {
        s.model = this, r(s);
      });
    else {
      let s = this.__dataHost.__dataHost;
      s && s._addEventListenerToNode(e, t, r);
    }
  }
  /**
   * Shows or hides the template instance top level child elements. For
   * text nodes, `textContent` is removed while "hidden" and replaced when
   * "shown."
   * @param {boolean} hide Set to true to hide the children;
   * set to false to show them.
   * @return {void}
   * @protected
   */
  _showHideChildren(e) {
    Dx(e, this.children);
  }
  /**
   * Overrides default property-effects implementation to intercept
   * textContent bindings while children are "hidden" and cache in
   * private storage for later retrieval.
   *
   * @override
   * @param {!Node} node The node to set a property on
   * @param {string} prop The property to set
   * @param {*} value The value to set
   * @return {void}
   * @protected
   */
  _setUnmanagedPropertyToNode(e, t, r) {
    e.__hideTemplateChildren__ && e.nodeType == Node.TEXT_NODE && t == "textContent" ? e.__polymerTextContent__ = r : super._setUnmanagedPropertyToNode(e, t, r);
  }
  /**
   * Find the parent model of this template instance.  The parent model
   * is either another templatize instance that had option `parentModel: true`,
   * or else the host element.
   *
   * @return {!Polymer_PropertyEffects} The parent model of this instance
   */
  get parentModel() {
    let e = this.__parentModel;
    if (!e) {
      let t;
      e = this;
      do
        e = e.__dataHost.__dataHost;
      while ((t = e.__templatizeOptions) && !t.parentModel);
      this.__parentModel = e;
    }
    return e;
  }
  /**
   * Stub of HTMLElement's `dispatchEvent`, so that effects that may
   * dispatch events safely no-op.
   *
   * @param {Event} event Event to dispatch
   * @return {boolean} Always true.
   * @override
   */
  dispatchEvent(e) {
    return !0;
  }
}
St.prototype.__dataHost;
St.prototype.__templatizeOptions;
St.prototype._methodHost;
St.prototype.__templatizeOwner;
St.prototype.__hostProps;
const Ox = nl(
  // This cast shouldn't be neccessary, but Closure doesn't understand that
  // TemplateInstanceBase is a constructor function.
  /** @type {function(new:TemplateInstanceBase)} */
  St
);
function nd(i) {
  let e = i.__dataHost;
  return e && e._methodHost || e;
}
function $x(i, e, t) {
  let r = t.mutableData ? Ox : St;
  ia.mixin && (r = ia.mixin(r));
  let s = class extends r {
  };
  return s.prototype.__templatizeOptions = t, s.prototype._bindTemplate(i), zx(s, i, e, t), s;
}
function Px(i, e, t, r) {
  let s = t.forwardHostProp;
  if (s && e.hasHostProps) {
    const o = i.localName == "template";
    let n = e.templatizeTemplateClass;
    if (!n) {
      if (o) {
        let l = t.mutableData ? Sx : Hf;
        class c extends l {
        }
        n = e.templatizeTemplateClass = c;
      } else {
        const l = i.constructor;
        class c extends l {
        }
        n = e.templatizeTemplateClass = c;
      }
      let a = e.hostProps;
      for (let l in a)
        n.prototype._addPropertyEffect(
          "_host_" + l,
          n.prototype.PROPERTY_EFFECT_TYPES.PROPAGATE,
          { fn: Mx(l, s) }
        ), n.prototype._createNotifyingProperty("_host_" + l);
      nh && r && Rx(e, t, r);
    }
    if (i.__dataProto && Object.assign(i.__data, i.__dataProto), o)
      Tx(i, n), i.__dataTemp = {}, i.__dataPending = null, i.__dataOld = null, i._enableProperties();
    else {
      Object.setPrototypeOf(i, n.prototype);
      const a = e.hostProps;
      for (let l in a)
        if (l = "_host_" + l, l in i) {
          const c = i[l];
          delete i[l], i.__data[l] = c;
        }
    }
  }
}
function Mx(i, e) {
  return function(r, s, o) {
    e.call(
      r.__templatizeOwner,
      s.substring(6),
      o[s]
    );
  };
}
function zx(i, e, t, r) {
  let s = t.hostProps || {};
  for (let o in r.instanceProps) {
    delete s[o];
    let n = r.notifyInstanceProp;
    n && i.prototype._addPropertyEffect(
      o,
      i.prototype.PROPERTY_EFFECT_TYPES.NOTIFY,
      { fn: Nx(o, n) }
    );
  }
  if (r.forwardHostProp && e.__dataHost)
    for (let o in s)
      t.hasHostProps || (t.hasHostProps = !0), i.prototype._addPropertyEffect(
        o,
        i.prototype.PROPERTY_EFFECT_TYPES.NOTIFY,
        { fn: Fx() }
      );
}
function Nx(i, e) {
  return function(r, s, o) {
    e.call(
      r.__templatizeOwner,
      r,
      s,
      o[s]
    );
  };
}
function Fx() {
  return function(e, t, r) {
    e.__dataHost._setPendingPropertyOrPath("_host_" + t, r[t], !0, !0);
  };
}
function ia(i, e, t) {
  if (Fs && !nd(i))
    throw new Error("strictTemplatePolicy: template owner not trusted");
  if (t = /** @type {!TemplatizeOptions} */
  t || {}, i.__templatizeOwner)
    throw new Error("A <template> can only be templatized once");
  i.__templatizeOwner = e;
  let s = (e ? e.constructor : St)._parseTemplate(i), o = s.templatizeInstanceClass;
  o || (o = $x(i, s, t), s.templatizeInstanceClass = o);
  const n = nd(i);
  Px(i, s, t, n);
  let a = class extends o {
  };
  return a.prototype._methodHost = n, a.prototype.__dataHost = /** @type {!DataTemplate} */
  i, a.prototype.__templatizeOwner = /** @type {!Object} */
  e, a.prototype.__hostProps = s.hostProps, a = /** @type {function(new:TemplateInstanceBase)} */
  a, a;
}
function Rx(i, e, t) {
  const r = t.constructor._properties, { propertyEffects: s } = i, { instanceProps: o } = e;
  for (let n in s)
    if (!r[n] && !(o && o[n])) {
      const a = s[n];
      for (let l = 0; l < a.length; l++) {
        const { part: c } = a[l].info;
        if (!(c.signature && c.signature.static))
          break;
      }
    }
}
function Lx(i, e) {
  let t;
  for (; e; )
    if (t = e.__dataHost ? e : e.__templatizeInstance)
      if (t.__dataHost != i)
        e = t.__dataHost;
      else
        return t;
    else
      e = B(e).parentNode;
  return null;
}
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
class js {
  constructor() {
    this._asyncModule = null, this._callback = null, this._timer = null;
  }
  /**
   * Sets the scheduler; that is, a module with the Async interface,
   * a callback and optional arguments to be passed to the run function
   * from the async module.
   *
   * @param {!AsyncInterface} asyncModule Object with Async interface.
   * @param {function()} callback Callback to run.
   * @return {void}
   */
  setConfig(e, t) {
    this._asyncModule = e, this._callback = t, this._timer = this._asyncModule.run(() => {
      this._timer = null, Pi.delete(this), this._callback();
    });
  }
  /**
   * Cancels an active debouncer and returns a reference to itself.
   *
   * @return {void}
   */
  cancel() {
    this.isActive() && (this._cancelAsync(), Pi.delete(this));
  }
  /**
   * Cancels a debouncer's async callback.
   *
   * @return {void}
   */
  _cancelAsync() {
    this.isActive() && (this._asyncModule.cancel(
      /** @type {number} */
      this._timer
    ), this._timer = null);
  }
  /**
   * Flushes an active debouncer and returns a reference to itself.
   *
   * @return {void}
   */
  flush() {
    this.isActive() && (this.cancel(), this._callback());
  }
  /**
   * Returns true if the debouncer is active.
   *
   * @return {boolean} True if active.
   */
  isActive() {
    return this._timer != null;
  }
  /**
   * Creates a debouncer if no debouncer is passed as a parameter
   * or it cancels an active debouncer otherwise. The following
   * example shows how a debouncer can be called multiple times within a
   * microtask and "debounced" such that the provided callback function is
   * called once. Add this method to a custom element:
   *
   * ```js
   * import {microTask} from '@polymer/polymer/lib/utils/async.js';
   * import {Debouncer} from '@polymer/polymer/lib/utils/debounce.js';
   * // ...
   *
   * _debounceWork() {
   *   this._debounceJob = Debouncer.debounce(this._debounceJob,
   *       microTask, () => this._doWork());
   * }
   * ```
   *
   * If the `_debounceWork` method is called multiple times within the same
   * microtask, the `_doWork` function will be called only once at the next
   * microtask checkpoint.
   *
   * Note: In testing it is often convenient to avoid asynchrony. To accomplish
   * this with a debouncer, you can use `enqueueDebouncer` and
   * `flush`. For example, extend the above example by adding
   * `enqueueDebouncer(this._debounceJob)` at the end of the
   * `_debounceWork` method. Then in a test, call `flush` to ensure
   * the debouncer has completed.
   *
   * @param {Debouncer?} debouncer Debouncer object.
   * @param {!AsyncInterface} asyncModule Object with Async interface
   * @param {function()} callback Callback to run.
   * @return {!Debouncer} Returns a debouncer object.
   */
  static debounce(e, t, r) {
    return e instanceof js ? e._cancelAsync() : e = new js(), e.setConfig(t, r), e;
  }
}
let Pi = /* @__PURE__ */ new Set();
const Vx = function(i) {
  Pi.add(i);
}, Hx = function() {
  const i = !!Pi.size;
  return Pi.forEach((e) => {
    try {
      e.flush();
    } catch (t) {
      setTimeout(() => {
        throw t;
      });
    }
  }), i;
};
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const Bf = function() {
  let i, e;
  do
    i = window.ShadyDOM && ShadyDOM.flush(), window.ShadyCSS && window.ShadyCSS.ScopingShim && window.ShadyCSS.ScopingShim.flush(), e = Hx();
  while (i || e);
};
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
let ad = !1;
function Bx() {
  if (oh && !sh) {
    if (!ad) {
      ad = !0;
      const i = document.createElement("style");
      i.textContent = "dom-bind,dom-if,dom-repeat{display:none;}", document.head.appendChild(i);
    }
    return !0;
  }
  return !1;
}
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const Ux = Ex(N);
class ld extends Ux {
  // Not needed to find template; can be removed once the analyzer
  // can find the tag name from customElements.define call
  static get is() {
    return "dom-repeat";
  }
  static get template() {
    return null;
  }
  static get properties() {
    return {
      /**
       * An array containing items determining how many instances of the template
       * to stamp and that that each template instance should bind to.
       */
      items: {
        type: Array
      },
      /**
       * The name of the variable to add to the binding scope for the array
       * element associated with a given template instance.
       */
      as: {
        type: String,
        value: "item"
      },
      /**
       * The name of the variable to add to the binding scope with the index
       * of the instance in the sorted and filtered list of rendered items.
       * Note, for the index in the `this.items` array, use the value of the
       * `itemsIndexAs` property.
       */
      indexAs: {
        type: String,
        value: "index"
      },
      /**
       * The name of the variable to add to the binding scope with the index
       * of the instance in the `this.items` array. Note, for the index of
       * this instance in the sorted and filtered list of rendered items,
       * use the value of the `indexAs` property.
       */
      itemsIndexAs: {
        type: String,
        value: "itemsIndex"
      },
      /**
       * A function that should determine the sort order of the items.  This
       * property should either be provided as a string, indicating a method
       * name on the element's host, or else be an actual function.  The
       * function should match the sort function passed to `Array.sort`.
       * Using a sort function has no effect on the underlying `items` array.
       */
      sort: {
        type: Function,
        observer: "__sortChanged"
      },
      /**
       * A function that can be used to filter items out of the view.  This
       * property should either be provided as a string, indicating a method
       * name on the element's host, or else be an actual function.  The
       * function should match the sort function passed to `Array.filter`.
       * Using a filter function has no effect on the underlying `items` array.
       */
      filter: {
        type: Function,
        observer: "__filterChanged"
      },
      /**
       * When using a `filter` or `sort` function, the `observe` property
       * should be set to a space-separated list of the names of item
       * sub-fields that should trigger a re-sort or re-filter when changed.
       * These should generally be fields of `item` that the sort or filter
       * function depends on.
       */
      observe: {
        type: String,
        observer: "__observeChanged"
      },
      /**
       * When using a `filter` or `sort` function, the `delay` property
       * determines a debounce time in ms after a change to observed item
       * properties that must pass before the filter or sort is re-run.
       * This is useful in rate-limiting shuffling of the view when
       * item changes may be frequent.
       */
      delay: Number,
      /**
       * Count of currently rendered items after `filter` (if any) has been applied.
       * If "chunking mode" is enabled, `renderedItemCount` is updated each time a
       * set of template instances is rendered.
       *
       */
      renderedItemCount: {
        type: Number,
        notify: !sc,
        readOnly: !0
      },
      /**
       * When greater than zero, defines an initial count of template instances
       * to render after setting the `items` array, before the next paint, and
       * puts the `dom-repeat` into "chunking mode".  The remaining items (and
       * any future items as a result of pushing onto the array) will be created
       * and rendered incrementally at each animation frame thereof until all
       * instances have been rendered.
       */
      initialCount: {
        type: Number
      },
      /**
       * When `initialCount` is used, this property defines a frame rate (in
       * fps) to target by throttling the number of instances rendered each
       * frame to not exceed the budget for the target frame rate.  The
       * framerate is effectively the number of `requestAnimationFrame`s that
       * it tries to allow to actually fire in a given second. It does this
       * by measuring the time between `rAF`s and continuously adjusting the
       * number of items created each `rAF` to maintain the target framerate.
       * Setting this to a higher number allows lower latency and higher
       * throughput for event handlers and other tasks, but results in a
       * longer time for the remaining items to complete rendering.
       */
      targetFramerate: {
        type: Number,
        value: 20
      },
      _targetFrameTime: {
        type: Number,
        computed: "__computeFrameTime(targetFramerate)"
      },
      /**
       * When the global `suppressTemplateNotifications` setting is used, setting
       * `notifyDomChange: true` will enable firing `dom-change` events on this
       * element.
       */
      notifyDomChange: {
        type: Boolean
      },
      /**
       * When chunking is enabled via `initialCount` and the `items` array is
       * set to a new array, this flag controls whether the previously rendered
       * instances are reused or not.
       *
       * When `true`, any previously rendered template instances are updated in
       * place to their new item values synchronously in one shot, and then any
       * further items (if any) are chunked out.  When `false`, the list is
       * returned back to its `initialCount` (any instances over the initial
       * count are discarded) and the remainder of the list is chunked back in.
       * Set this to `true` to avoid re-creating the list and losing scroll
       * position, although note that when changing the list to completely
       * different data the render thread will be blocked until all existing
       * instances are updated to their new data.
       */
      reuseChunkedInstances: {
        type: Boolean
      }
    };
  }
  static get observers() {
    return ["__itemsChanged(items.*)"];
  }
  constructor() {
    super(), this.__instances = [], this.__renderDebouncer = null, this.__itemsIdxToInstIdx = {}, this.__chunkCount = null, this.__renderStartTime = null, this.__itemsArrayChanged = !1, this.__shouldMeasureChunk = !1, this.__shouldContinueChunking = !1, this.__chunkingId = 0, this.__sortFn = null, this.__filterFn = null, this.__observePaths = null, this.__ctor = null, this.__isDetached = !0, this.template = null, this._templateInfo;
  }
  /**
   * @override
   * @return {void}
   */
  disconnectedCallback() {
    super.disconnectedCallback(), this.__isDetached = !0;
    for (let e = 0; e < this.__instances.length; e++)
      this.__detachInstance(e);
    this.__chunkingId && cancelAnimationFrame(this.__chunkingId);
  }
  /**
   * @override
   * @return {void}
   */
  connectedCallback() {
    if (super.connectedCallback(), Bx() || (this.style.display = "none"), this.__isDetached) {
      this.__isDetached = !1;
      let e = B(B(this).parentNode);
      for (let t = 0; t < this.__instances.length; t++)
        this.__attachInstance(t, e);
      this.__chunkingId && this.__render();
    }
  }
  __ensureTemplatized() {
    if (!this.__ctor) {
      const e = (
        /** @type {!HTMLTemplateElement} */
        /** @type {!HTMLElement} */
        this
      );
      let t = this.template = e._templateInfo ? e : (
        /** @type {!HTMLTemplateElement} */
        this.querySelector("template")
      );
      if (!t) {
        let s = new MutationObserver(() => {
          if (this.querySelector("template"))
            s.disconnect(), this.__render();
          else
            throw new Error("dom-repeat requires a <template> child");
        });
        return s.observe(this, { childList: !0 }), !1;
      }
      let r = {};
      r[this.as] = !0, r[this.indexAs] = !0, r[this.itemsIndexAs] = !0, this.__ctor = ia(t, this, {
        mutableData: this.mutableData,
        parentModel: !0,
        instanceProps: r,
        /**
         * @this {DomRepeat}
         * @param {string} prop Property to set
         * @param {*} value Value to set property to
         */
        forwardHostProp: function(s, o) {
          let n = this.__instances;
          for (let a = 0, l; a < n.length && (l = n[a]); a++)
            l.forwardHostProp(s, o);
        },
        /**
         * @this {DomRepeat}
         * @param {Object} inst Instance to notify
         * @param {string} prop Property to notify
         * @param {*} value Value to notify
         */
        notifyInstanceProp: function(s, o, n) {
          if (pb(this.as, o)) {
            let a = s[this.itemsIndexAs];
            o == this.as && (this.items[a] = n);
            let l = Ai(this.as, `${JSCompiler_renameProperty("items", this)}.${a}`, o);
            this.notifyPath(l, n);
          }
        }
      });
    }
    return !0;
  }
  __getMethodHost() {
    return this.__dataHost._methodHost || this.__dataHost;
  }
  __functionFromPropertyValue(e) {
    if (typeof e == "string") {
      let t = e, r = this.__getMethodHost();
      return function() {
        return r[t].apply(r, arguments);
      };
    }
    return e;
  }
  __sortChanged(e) {
    this.__sortFn = this.__functionFromPropertyValue(e), this.items && this.__debounceRender(this.__render);
  }
  __filterChanged(e) {
    this.__filterFn = this.__functionFromPropertyValue(e), this.items && this.__debounceRender(this.__render);
  }
  __computeFrameTime(e) {
    return Math.ceil(1e3 / e);
  }
  __observeChanged() {
    this.__observePaths = this.observe && this.observe.replace(".*", ".").split(" ");
  }
  __handleObservedPaths(e) {
    if (this.__sortFn || this.__filterFn) {
      if (!e)
        this.__debounceRender(this.__render, this.delay);
      else if (this.__observePaths) {
        let t = this.__observePaths;
        for (let r = 0; r < t.length; r++)
          e.indexOf(t[r]) === 0 && this.__debounceRender(this.__render, this.delay);
      }
    }
  }
  __itemsChanged(e) {
    this.items && Array.isArray(this.items), this.__handleItemPath(e.path, e.value) || (e.path === "items" && (this.__itemsArrayChanged = !0), this.__debounceRender(this.__render));
  }
  /**
   * @param {function(this:DomRepeat)} fn Function to debounce.
   * @param {number=} delay Delay in ms to debounce by.
   */
  __debounceRender(e, t = 0) {
    this.__renderDebouncer = js.debounce(
      this.__renderDebouncer,
      t > 0 ? vb.after(t) : Aa,
      e.bind(this)
    ), Vx(this.__renderDebouncer);
  }
  /**
   * Forces the element to render its content. Normally rendering is
   * asynchronous to a provoking change. This is done for efficiency so
   * that multiple changes trigger only a single render. The render method
   * should be called if, for example, template rendering is required to
   * validate application state.
   * @return {void}
   */
  render() {
    this.__debounceRender(this.__render), Bf();
  }
  __render() {
    if (!this.__ensureTemplatized())
      return;
    let e = this.items || [];
    const t = this.__sortAndFilterItems(e), r = this.__calculateLimit(t.length);
    this.__updateInstances(e, r, t), this.initialCount && (this.__shouldMeasureChunk || this.__shouldContinueChunking) && (cancelAnimationFrame(this.__chunkingId), this.__chunkingId = requestAnimationFrame(() => {
      this.__chunkingId = null, this.__continueChunking();
    })), this._setRenderedItemCount(this.__instances.length), (!sc || this.notifyDomChange) && this.dispatchEvent(new CustomEvent("dom-change", {
      bubbles: !0,
      composed: !0
    }));
  }
  __sortAndFilterItems(e) {
    let t = new Array(e.length);
    for (let r = 0; r < e.length; r++)
      t[r] = r;
    return this.__filterFn && (t = t.filter((r, s, o) => this.__filterFn(e[r], s, o))), this.__sortFn && t.sort((r, s) => this.__sortFn(e[r], e[s])), t;
  }
  __calculateLimit(e) {
    let t = e;
    const r = this.__instances.length;
    if (this.initialCount) {
      let s;
      !this.__chunkCount || this.__itemsArrayChanged && !this.reuseChunkedInstances ? (t = Math.min(e, this.initialCount), s = Math.max(t - r, 0), this.__chunkCount = s || 1) : (s = Math.min(
        Math.max(e - r, 0),
        this.__chunkCount
      ), t = Math.min(r + s, e)), this.__shouldMeasureChunk = s === this.__chunkCount, this.__shouldContinueChunking = t < e, this.__renderStartTime = performance.now();
    }
    return this.__itemsArrayChanged = !1, t;
  }
  __continueChunking() {
    if (this.__shouldMeasureChunk) {
      const e = performance.now() - this.__renderStartTime, t = this._targetFrameTime / e;
      this.__chunkCount = Math.round(this.__chunkCount * t) || 1;
    }
    this.__shouldContinueChunking && this.__debounceRender(this.__render);
  }
  __updateInstances(e, t, r) {
    const s = this.__itemsIdxToInstIdx = {};
    let o;
    for (o = 0; o < t; o++) {
      let n = this.__instances[o], a = r[o], l = e[a];
      s[a] = o, n ? (n._setPendingProperty(this.as, l), n._setPendingProperty(this.indexAs, o), n._setPendingProperty(this.itemsIndexAs, a), n._flushProperties()) : this.__insertInstance(l, o, a);
    }
    for (let n = this.__instances.length - 1; n >= o; n--)
      this.__detachAndRemoveInstance(n);
  }
  __detachInstance(e) {
    let t = this.__instances[e];
    const r = B(t.root);
    for (let s = 0; s < t.children.length; s++) {
      let o = t.children[s];
      r.appendChild(o);
    }
    return t;
  }
  __attachInstance(e, t) {
    let r = this.__instances[e];
    t.insertBefore(r.root, this);
  }
  __detachAndRemoveInstance(e) {
    this.__detachInstance(e), this.__instances.splice(e, 1);
  }
  __stampInstance(e, t, r) {
    let s = {};
    return s[this.as] = e, s[this.indexAs] = t, s[this.itemsIndexAs] = r, new this.__ctor(s);
  }
  __insertInstance(e, t, r) {
    const s = this.__stampInstance(e, t, r);
    let o = this.__instances[t + 1], n = o ? o.children[0] : this;
    return B(B(this).parentNode).insertBefore(s.root, n), this.__instances[t] = s, s;
  }
  // Implements extension point from Templatize mixin
  /**
   * Shows or hides the template instance top level child elements. For
   * text nodes, `textContent` is removed while "hidden" and replaced when
   * "shown."
   * @param {boolean} hidden Set to true to hide the children;
   * set to false to show them.
   * @return {void}
   * @protected
   */
  _showHideChildren(e) {
    for (let t = 0; t < this.__instances.length; t++)
      this.__instances[t]._showHideChildren(e);
  }
  // Called as a side effect of a host items.<key>.<path> path change,
  // responsible for notifying item.<path> changes to inst for key
  __handleItemPath(e, t) {
    let r = e.slice(6), s = r.indexOf("."), o = s < 0 ? r : r.substring(0, s);
    if (o == parseInt(o, 10)) {
      let n = s < 0 ? "" : r.substring(s + 1);
      this.__handleObservedPaths(n);
      let a = this.__itemsIdxToInstIdx[o], l = this.__instances[a];
      if (l) {
        let c = this.as + (n ? "." + n : "");
        l._setPendingPropertyOrPath(c, t, !1, !0), l._flushProperties();
      }
      return !0;
    }
  }
  /**
   * Returns the item associated with a given element stamped by
   * this `dom-repeat`.
   *
   * Note, to modify sub-properties of the item,
   * `modelForElement(el).set('item.<sub-prop>', value)`
   * should be used.
   *
   * @param {!HTMLElement} el Element for which to return the item.
   * @return {*} Item associated with the element.
   */
  itemForElement(e) {
    let t = this.modelForElement(e);
    return t && t[this.as];
  }
  /**
   * Returns the inst index for a given element stamped by this `dom-repeat`.
   * If `sort` is provided, the index will reflect the sorted order (rather
   * than the original array order).
   *
   * @param {!HTMLElement} el Element for which to return the index.
   * @return {?number} Row index associated with the element (note this may
   *   not correspond to the array index if a user `sort` is applied).
   */
  indexForElement(e) {
    let t = this.modelForElement(e);
    return t && t[this.indexAs];
  }
  /**
   * Returns the template "model" associated with a given element, which
   * serves as the binding scope for the template instance the element is
   * contained in. A template model
   * should be used to manipulate data associated with this template instance.
   *
   * Example:
   *
   *   let model = modelForElement(el);
   *   if (model.index < 10) {
   *     model.set('item.checked', true);
   *   }
   *
   * @param {!HTMLElement} el Element for which to return a template model.
   * @return {TemplateInstanceBase} Model representing the binding scope for
   *   the element.
   */
  modelForElement(e) {
    return Lx(this.template, e);
  }
}
customElements.define(ld.is, ld);
/**
 * @license
 * Copyright (c) 2016 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const qx = (i) => class extends Hi(i) {
  static get properties() {
    return {
      /**
       * A `Date` object defining the month to be displayed. Only year and
       * month properties are actually used.
       */
      month: {
        type: Object,
        value: /* @__PURE__ */ new Date(),
        sync: !0
      },
      /**
       * A `Date` object for the currently selected date.
       */
      selectedDate: {
        type: Object,
        notify: !0,
        sync: !0
      },
      /**
       * A `Date` object for the currently focused date.
       */
      focusedDate: {
        type: Object
      },
      /**
       * Set true to display ISO-8601 week numbers in the calendar. Notice that
       * displaying week numbers is only supported when `i18n.firstDayOfWeek`
       * is 1 (Monday).
       */
      showWeekNumbers: {
        type: Boolean,
        value: !1
      },
      i18n: {
        type: Object
      },
      /**
       * Flag stating whether taps on the component should be ignored.
       */
      ignoreTaps: {
        type: Boolean
      },
      /**
       * The earliest date that can be selected. All earlier dates will be disabled.
       */
      minDate: {
        type: Date,
        value: null,
        sync: !0
      },
      /**
       * The latest date that can be selected. All later dates will be disabled.
       */
      maxDate: {
        type: Date,
        value: null,
        sync: !0
      },
      disabled: {
        type: Boolean,
        reflectToAttribute: !0
      },
      /** @protected */
      _days: {
        type: Array
      },
      /** @protected */
      _weeks: {
        type: Array
      },
      /** @private */
      _notTapping: {
        type: Boolean
      }
    };
  }
  static get observers() {
    return ["__focusedDateChanged(focusedDate, _days)"];
  }
  get focusableDateElement() {
    return [...this.shadowRoot.querySelectorAll("[part~=date]")].find((t) => me(t.date, this.focusedDate));
  }
  /** @protected */
  ready() {
    super.ready(), pe(this.$.monthGrid, "tap", this._handleTap.bind(this));
  }
  /**
   * Returns true if all the dates in the month are out of the allowed range
   * @protected
   */
  _isDisabled(t, r, s) {
    const o = new Date(0, 0);
    o.setFullYear(t.getFullYear()), o.setMonth(t.getMonth()), o.setDate(1);
    const n = new Date(0, 0);
    return n.setFullYear(t.getFullYear()), n.setMonth(t.getMonth() + 1), n.setDate(0), r && s && r.getMonth() === s.getMonth() && r.getMonth() === t.getMonth() && s.getDate() - r.getDate() >= 0 ? !1 : !$i(o, r, s) && !$i(n, r, s);
  }
  /** @protected */
  _getTitle(t, r) {
    if (!(t === void 0 || r === void 0))
      return r.formatTitle(r.monthNames[t.getMonth()], t.getFullYear());
  }
  /** @protected */
  _onMonthGridTouchStart() {
    this._notTapping = !1, setTimeout(() => {
      this._notTapping = !0;
    }, 300);
  }
  /** @private */
  _dateAdd(t, r) {
    t.setDate(t.getDate() + r);
  }
  /** @private */
  _applyFirstDayOfWeek(t, r) {
    if (!(t === void 0 || r === void 0))
      return t.slice(r).concat(t.slice(0, r));
  }
  /** @protected */
  _getWeekDayNames(t, r) {
    if (t === void 0 || r === void 0)
      return [];
    const { weekdays: s, weekdaysShort: o, firstDayOfWeek: n } = t, a = this._applyFirstDayOfWeek(o, n);
    return this._applyFirstDayOfWeek(s, n).map((c, d) => ({
      weekDay: c,
      weekDayShort: a[d]
    }));
  }
  /** @private */
  __focusedDateChanged(t, r) {
    Array.isArray(r) && r.some((s) => me(s, t)) ? this.removeAttribute("aria-hidden") : this.setAttribute("aria-hidden", "true");
  }
  /** @protected */
  _getDate(t) {
    return t ? t.getDate() : "";
  }
  /** @protected */
  _showWeekSeparator(t, r) {
    return t && r && r.firstDayOfWeek === 1;
  }
  /** @protected */
  _isToday(t) {
    return me(/* @__PURE__ */ new Date(), t);
  }
  /** @protected */
  _getDays(t, r) {
    if (t === void 0 || r === void 0)
      return [];
    const s = new Date(0, 0);
    for (s.setFullYear(t.getFullYear()), s.setMonth(t.getMonth()), s.setDate(1); s.getDay() !== r.firstDayOfWeek; )
      this._dateAdd(s, -1);
    const o = [], n = s.getMonth(), a = t.getMonth();
    for (; s.getMonth() === a || s.getMonth() === n; )
      o.push(s.getMonth() === a ? new Date(s.getTime()) : null), this._dateAdd(s, 1);
    return o;
  }
  /** @protected */
  _getWeeks(t) {
    return t.reduce((r, s, o) => (o % 7 === 0 && r.push([]), r[r.length - 1].push(s), r), []);
  }
  /** @protected */
  _handleTap(t) {
    !this.ignoreTaps && !this._notTapping && t.target.date && !t.target.hasAttribute("disabled") && (this.selectedDate = t.target.date, this.dispatchEvent(
      new CustomEvent("date-tap", { detail: { date: t.target.date }, bubbles: !0, composed: !0 })
    ));
  }
  /** @protected */
  _preventDefault(t) {
    t.preventDefault();
  }
  /** @protected */
  __getWeekNumber(t) {
    const r = t.reduce((s, o) => !s && o ? o : s);
    return wx(r);
  }
  /** @protected */
  __getDayAriaLabel(t) {
    if (!t)
      return "";
    let r = `${this._getDate(t)} ${this.i18n.monthNames[t.getMonth()]} ${t.getFullYear()}, ${this.i18n.weekdays[t.getDay()]}`;
    return this._isToday(t) && (r += `, ${this.i18n.today}`), r;
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Wx = y`
  :host {
    display: block;
  }

  #monthGrid {
    width: 100%;
    border-collapse: collapse;
  }

  #days-container tr,
  #weekdays-container tr {
    display: flex;
  }

  [part~='date'] {
    outline: none;
  }

  [part~='disabled'] {
    pointer-events: none;
  }

  [part='week-number'][hidden],
  [part='weekday'][hidden] {
    display: none;
  }

  [part='weekday'],
  [part~='date'] {
    width: calc(100% / 7);
    padding: 0;
    font-weight: normal;
  }

  [part='weekday']:empty,
  [part='week-number'] {
    width: 12.5%;
    flex-shrink: 0;
    padding: 0;
  }

  :host([week-numbers]) [part='weekday']:not(:empty),
  :host([week-numbers]) [part~='date'] {
    width: 12.5%;
  }

  @media (forced-colors: active) {
    [part~='date'][part~='focused'] {
      outline: 1px solid;
    }

    [part~='date'][part~='selected'] {
      outline: 3px solid;
    }
  }
`;
/**
 * @license
 * Copyright (c) 2016 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
C("vaadin-month-calendar", Wx, {
  moduleId: "vaadin-month-calendar-styles"
});
class jx extends qx(X(N)) {
  static get template() {
    return U`
      <div part="month-header" id="month-header" aria-hidden="true">[[_getTitle(month, i18n)]]</div>
      <table
        id="monthGrid"
        role="grid"
        aria-labelledby="month-header"
        on-touchend="_preventDefault"
        on-touchstart="_onMonthGridTouchStart"
      >
        <thead id="weekdays-container">
          <tr role="row" part="weekdays">
            <th part="weekday" aria-hidden="true" hidden$="[[!_showWeekSeparator(showWeekNumbers, i18n)]]"></th>
            <template is="dom-repeat" items="[[_getWeekDayNames(i18n, showWeekNumbers)]]">
              <th role="columnheader" part="weekday" scope="col" abbr$="[[item.weekDay]]" aria-hidden="true">
                [[item.weekDayShort]]
              </th>
            </template>
          </tr>
        </thead>
        <tbody id="days-container">
          <template is="dom-repeat" items="[[_weeks]]" as="week">
            <tr role="row">
              <td part="week-number" aria-hidden="true" hidden$="[[!_showWeekSeparator(showWeekNumbers, i18n)]]">
                [[__getWeekNumber(week)]]
              </td>
              <template is="dom-repeat" items="[[week]]">
                <td
                  role="gridcell"
                  part$="[[__getDatePart(item, focusedDate, selectedDate, minDate, maxDate)]]"
                  date="[[item]]"
                  tabindex$="[[__getDayTabindex(item, focusedDate)]]"
                  disabled$="[[__isDayDisabled(item, minDate, maxDate)]]"
                  aria-selected$="[[__getDayAriaSelected(item, selectedDate)]]"
                  aria-disabled$="[[__getDayAriaDisabled(item, minDate, maxDate)]]"
                  aria-label$="[[__getDayAriaLabel(item)]]"
                  >[[_getDate(item)]]</td
                >
              </template>
            </tr>
          </template>
        </tbody>
      </table>
    `;
  }
  static get is() {
    return "vaadin-month-calendar";
  }
  static get properties() {
    return {
      /** @protected */
      _days: {
        type: Array,
        computed: "_getDays(month, i18n, minDate, maxDate)"
      },
      /** @protected */
      _weeks: {
        type: Array,
        computed: "_getWeeks(_days)"
      },
      disabled: {
        type: Boolean,
        reflectToAttribute: !0,
        computed: "_isDisabled(month, minDate, maxDate)"
      }
    };
  }
  static get observers() {
    return ["_showWeekNumbersChanged(showWeekNumbers, i18n)"];
  }
  /** @private */
  _showWeekNumbersChanged(e, t) {
    e && t && t.firstDayOfWeek === 1 ? this.setAttribute("week-numbers", "") : this.removeAttribute("week-numbers");
  }
  /** @private */
  __getDatePart(e, t, r, s, o) {
    const n = ["date"];
    return this.__isDayDisabled(e, s, o) && n.push("disabled"), this.__isDayFocused(e, t) && n.push("focused"), this.__isDaySelected(e, r) && n.push("selected"), this._isToday(e) && n.push("today"), n.join(" ");
  }
  /** @private */
  __isDayFocused(e, t) {
    return me(e, t);
  }
  /** @private */
  __isDaySelected(e, t) {
    return me(e, t);
  }
  /** @private */
  __getDayAriaSelected(e, t) {
    if (this.__isDaySelected(e, t))
      return "true";
  }
  /** @private */
  __isDayDisabled(e, t, r) {
    return !$i(e, t, r);
  }
  /** @private */
  __getDayAriaDisabled(e, t, r) {
    if (!(e === void 0 || t === void 0 || r === void 0) && this.__isDayDisabled(e, t, r))
      return "true";
  }
  /** @private */
  __getDayTabindex(e, t) {
    return this.__isDayFocused(e, t) ? "0" : "-1";
  }
}
O(jx);
/**
 * @license
 * Copyright (c) 2021 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class Uf {
  constructor(e, t) {
    this.query = e, this.callback = t, this._boundQueryHandler = this._queryHandler.bind(this);
  }
  hostConnected() {
    this._removeListener(), this._mediaQuery = window.matchMedia(this.query), this._addListener(), this._queryHandler(this._mediaQuery);
  }
  hostDisconnected() {
    this._removeListener();
  }
  /** @private */
  _addListener() {
    this._mediaQuery && this._mediaQuery.addListener(this._boundQueryHandler);
  }
  /** @private */
  _removeListener() {
    this._mediaQuery && this._mediaQuery.removeListener(this._boundQueryHandler), this._mediaQuery = null;
  }
  /** @private */
  _queryHandler(e) {
    typeof this.callback == "function" && this.callback(e.matches);
  }
}
/**
 * @license
 * Copyright (c) 2016 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Gx = (i) => class extends i {
  static get properties() {
    return {
      scrollDuration: {
        type: Number,
        value: 300
      },
      /**
       * The value for this element.
       */
      selectedDate: {
        type: Object,
        value: null,
        sync: !0
      },
      /**
       * Date value which is focused using keyboard.
       */
      focusedDate: {
        type: Object,
        notify: !0,
        observer: "_focusedDateChanged",
        sync: !0
      },
      _focusedMonthDate: Number,
      /**
       * Date which should be visible when there is no value selected.
       */
      initialPosition: {
        type: Object,
        observer: "_initialPositionChanged"
      },
      _originDate: {
        type: Object,
        value: /* @__PURE__ */ new Date()
      },
      _visibleMonthIndex: Number,
      _desktopMode: {
        type: Boolean,
        observer: "_desktopModeChanged"
      },
      _desktopMediaQuery: {
        type: String,
        value: "(min-width: 375px)"
      },
      _translateX: {
        observer: "_translateXChanged"
      },
      _yearScrollerWidth: {
        value: 50
      },
      i18n: {
        type: Object
      },
      showWeekNumbers: {
        type: Boolean,
        value: !1
      },
      _ignoreTaps: Boolean,
      _notTapping: Boolean,
      /**
       * The earliest date that can be selected. All earlier dates will be disabled.
       */
      minDate: {
        type: Object,
        sync: !0
      },
      /**
       * The latest date that can be selected. All later dates will be disabled.
       */
      maxDate: {
        type: Object,
        sync: !0
      },
      /**
       * Input label
       */
      label: String,
      _cancelButton: {
        type: Object
      },
      _todayButton: {
        type: Object
      },
      calendars: {
        type: Array,
        value: () => []
      },
      years: {
        type: Array,
        value: () => []
      }
    };
  }
  static get observers() {
    return [
      "__updateCalendars(calendars, i18n, minDate, maxDate, selectedDate, focusedDate, showWeekNumbers, _ignoreTaps, _theme)",
      "__updateCancelButton(_cancelButton, i18n)",
      "__updateTodayButton(_todayButton, i18n, minDate, maxDate)",
      "__updateYears(years, selectedDate, _theme)"
    ];
  }
  /**
   * Whether to scroll to a sub-month position when scrolling to a date.
   * This is active if the month scroller is not large enough to fit a
   * full month. In that case we want to scroll to a position between
   * two months in order to have the focused date in the visible area.
   * @returns {boolean} whether to use sub-month scrolling
   * @private
   */
  get __useSubMonthScrolling() {
    return this._monthScroller.clientHeight < this._monthScroller.itemHeight + this._monthScroller.bufferOffset;
  }
  get focusableDateElement() {
    return this.calendars.map((t) => t.focusableDateElement).find(Boolean);
  }
  /** @protected */
  _addListeners() {
    Nh(this.$.scrollers, "pan-y"), pe(this.$.scrollers, "track", this._track.bind(this)), pe(this.shadowRoot.querySelector('[part="clear-button"]'), "tap", this._clear.bind(this)), pe(this.shadowRoot.querySelector('[part="toggle-button"]'), "tap", this._cancel.bind(this)), pe(
      this.shadowRoot.querySelector('[part="years-toggle-button"]'),
      "tap",
      this._toggleYearScroller.bind(this)
    );
  }
  /** @protected */
  _initControllers() {
    this.addController(
      new Uf(this._desktopMediaQuery, (t) => {
        this._desktopMode = t;
      })
    ), this.addController(
      new Ke(this, "today-button", "vaadin-button", {
        observe: !1,
        initializer: (t) => {
          t.setAttribute("theme", "tertiary"), t.addEventListener("keydown", (r) => this.__onTodayButtonKeyDown(r)), pe(t, "tap", this._onTodayTap.bind(this)), this._todayButton = t;
        }
      })
    ), this.addController(
      new Ke(this, "cancel-button", "vaadin-button", {
        observe: !1,
        initializer: (t) => {
          t.setAttribute("theme", "tertiary"), t.addEventListener("keydown", (r) => this.__onCancelButtonKeyDown(r)), pe(t, "tap", this._cancel.bind(this)), this._cancelButton = t;
        }
      })
    ), this.__initMonthScroller(), this.__initYearScroller();
  }
  reset() {
    this._closeYearScroller(), this._toggleAnimateClass(!0);
  }
  /**
   * Focuses the cancel button
   */
  focusCancel() {
    this._cancelButton.focus();
  }
  /**
   * Scrolls the list to the given Date.
   */
  scrollToDate(t, r) {
    const s = this.__useSubMonthScrolling ? this._calculateWeekScrollOffset(t) : 0;
    this._scrollToPosition(this._differenceInMonths(t, this._originDate) + s, r), this._monthScroller.forceUpdate();
  }
  /** @private */
  __initMonthScroller() {
    this.addController(
      new Ke(this, "months", "vaadin-date-picker-month-scroller", {
        observe: !1,
        initializer: (t) => {
          t.addEventListener("custom-scroll", () => {
            this._onMonthScroll();
          }), t.addEventListener("touchstart", () => {
            this._onMonthScrollTouchStart();
          }), t.addEventListener("keydown", (r) => {
            this.__onMonthCalendarKeyDown(r);
          }), t.addEventListener("init-done", () => {
            const r = [...this.querySelectorAll("vaadin-month-calendar")];
            r.forEach((s) => {
              s.addEventListener("selected-date-changed", (o) => {
                this.selectedDate = o.detail.value;
              });
            }), this.calendars = r;
          }), this._monthScroller = t;
        }
      })
    );
  }
  /** @private */
  __initYearScroller() {
    this.addController(
      new Ke(this, "years", "vaadin-date-picker-year-scroller", {
        observe: !1,
        initializer: (t) => {
          t.setAttribute("aria-hidden", "true"), pe(t, "tap", (r) => {
            this._onYearTap(r);
          }), t.addEventListener("custom-scroll", () => {
            this._onYearScroll();
          }), t.addEventListener("touchstart", () => {
            this._onYearScrollTouchStart();
          }), t.addEventListener("init-done", () => {
            this.years = [...this.querySelectorAll("vaadin-date-picker-year")];
          }), this._yearScroller = t;
        }
      })
    );
  }
  /** @private */
  __updateCancelButton(t, r) {
    t && (t.textContent = r && r.cancel);
  }
  /** @private */
  __updateTodayButton(t, r, s, o) {
    t && (t.textContent = r && r.today, t.disabled = !this._isTodayAllowed(s, o));
  }
  // eslint-disable-next-line max-params
  __updateCalendars(t, r, s, o, n, a, l, c, d) {
    t && t.length && t.forEach((u) => {
      u.i18n = r, u.minDate = s, u.maxDate = o, u.focusedDate = a, u.selectedDate = n, u.showWeekNumbers = l, u.ignoreTaps = c, d ? u.setAttribute("theme", d) : u.removeAttribute("theme");
    });
  }
  /** @private */
  __updateYears(t, r, s) {
    t && t.length && t.forEach((o) => {
      o.selectedDate = r, s ? o.setAttribute("theme", s) : o.removeAttribute("theme");
    });
  }
  /**
   * Select a date and fire event indicating user interaction.
   * @protected
   */
  _selectDate(t) {
    this.selectedDate = t, this.dispatchEvent(
      new CustomEvent("date-selected", { detail: { date: t }, bubbles: !0, composed: !0 })
    );
  }
  /** @private */
  _desktopModeChanged(t) {
    this.toggleAttribute("desktop", t);
  }
  /** @private */
  _focusedDateChanged(t) {
    this.revealDate(t);
  }
  /**
   * Scrolls the month and year scrollers enough to reveal the given date.
   */
  revealDate(t, r = !0) {
    if (!t)
      return;
    const s = this._differenceInMonths(t, this._originDate);
    if (this.__useSubMonthScrolling) {
      const c = this._calculateWeekScrollOffset(t);
      this._scrollToPosition(s + c, r);
      return;
    }
    const o = this._monthScroller.position > s, a = Math.max(
      this._monthScroller.itemHeight,
      this._monthScroller.clientHeight - this._monthScroller.bufferOffset * 2
    ) / this._monthScroller.itemHeight, l = this._monthScroller.position + a - 1 < s;
    o ? this._scrollToPosition(s, r) : l && this._scrollToPosition(s - a + 1, r);
  }
  /**
   * Calculates an offset to be added to the month scroll position
   * when using sub-month scrolling, in order ensure that the week
   * that the date is in is visible even for small scroll areas.
   * As the month scroller uses a month as minimal scroll unit
   * (a value of `1` equals one month), we can not exactly identify
   * the position of a specific week. This is a best effort
   * implementation based on manual testing.
   * @param date the date for which to calculate the offset
   * @returns {number} the offset
   * @private
   */
  _calculateWeekScrollOffset(t) {
    const r = new Date(0, 0);
    r.setFullYear(t.getFullYear()), r.setMonth(t.getMonth()), r.setDate(1);
    let s = 0;
    for (; r.getDate() < t.getDate(); )
      r.setDate(r.getDate() + 1), r.getDay() === this.i18n.firstDayOfWeek && (s += 1);
    return s / 6;
  }
  /** @private */
  _initialPositionChanged(t) {
    this._monthScroller && this._yearScroller && (this._monthScroller.active = !0, this._yearScroller.active = !0), this.scrollToDate(t);
  }
  /** @private */
  _repositionYearScroller() {
    const t = this._monthScroller.position;
    this._visibleMonthIndex = Math.floor(t), this._yearScroller.position = (t + this._originDate.getMonth()) / 12;
  }
  /** @private */
  _repositionMonthScroller() {
    this._monthScroller.position = this._yearScroller.position * 12 - this._originDate.getMonth(), this._visibleMonthIndex = Math.floor(this._monthScroller.position);
  }
  /** @private */
  _onMonthScroll() {
    this._repositionYearScroller(), this._doIgnoreTaps();
  }
  /** @private */
  _onYearScroll() {
    this._repositionMonthScroller(), this._doIgnoreTaps();
  }
  /** @private */
  _onYearScrollTouchStart() {
    this._notTapping = !1, setTimeout(() => {
      this._notTapping = !0;
    }, 300), this._repositionMonthScroller();
  }
  /** @private */
  _onMonthScrollTouchStart() {
    this._repositionYearScroller();
  }
  /** @private */
  _doIgnoreTaps() {
    this._ignoreTaps = !0, this._debouncer = R.debounce(this._debouncer, _e.after(300), () => {
      this._ignoreTaps = !1;
    });
  }
  /** @protected */
  _formatDisplayed(t, r, s) {
    return t && r && typeof r.formatDate == "function" ? r.formatDate(zf(t)) : s;
  }
  /** @private */
  _onTodayTap() {
    const t = /* @__PURE__ */ new Date();
    Math.abs(this._monthScroller.position - this._differenceInMonths(t, this._originDate)) < 1e-3 ? (this._selectDate(t), this._close()) : this._scrollToCurrentMonth();
  }
  /** @private */
  _scrollToCurrentMonth() {
    this.focusedDate && (this.focusedDate = /* @__PURE__ */ new Date()), this.scrollToDate(/* @__PURE__ */ new Date(), !0);
  }
  /** @private */
  _onYearTap(t) {
    if (!this._ignoreTaps && !this._notTapping) {
      const s = (t.detail.y - (this._yearScroller.getBoundingClientRect().top + this._yearScroller.clientHeight / 2)) / this._yearScroller.itemHeight;
      this._scrollToPosition(this._monthScroller.position + s * 12, !0);
    }
  }
  /** @private */
  _scrollToPosition(t, r) {
    if (this._targetPosition !== void 0) {
      this._targetPosition = t;
      return;
    }
    if (!r) {
      this._monthScroller.position = t, this._targetPosition = void 0, this._repositionYearScroller(), this.__tryFocusDate();
      return;
    }
    this._targetPosition = t;
    let s;
    this._revealPromise = new Promise((c) => {
      s = c;
    });
    const o = (c, d, u, h) => (c /= h / 2, c < 1 ? u / 2 * c * c + d : (c -= 1, -u / 2 * (c * (c - 2) - 1) + d));
    let n = 0;
    const a = this._monthScroller.position, l = (c) => {
      n || (n = c);
      const d = c - n;
      if (d < this.scrollDuration) {
        const u = o(
          d,
          a,
          this._targetPosition - a,
          this.scrollDuration
        );
        this._monthScroller.position = u, window.requestAnimationFrame(l);
      } else
        this.dispatchEvent(
          new CustomEvent("scroll-animation-finished", {
            bubbles: !0,
            composed: !0,
            detail: {
              position: this._targetPosition,
              oldPosition: a
            }
          })
        ), this._monthScroller.position = this._targetPosition, this._targetPosition = void 0, s(), this._revealPromise = void 0;
      setTimeout(this._repositionYearScroller.bind(this), 1);
    };
    window.requestAnimationFrame(l);
  }
  /** @private */
  _limit(t, r) {
    return Math.min(r.max, Math.max(r.min, t));
  }
  /** @private */
  _handleTrack(t) {
    if (Math.abs(t.detail.dx) < 10 || Math.abs(t.detail.ddy) > 10)
      return;
    Math.abs(t.detail.ddx) > this._yearScrollerWidth / 3 && this._toggleAnimateClass(!0);
    const r = this._translateX + t.detail.ddx;
    this._translateX = this._limit(r, {
      min: 0,
      max: this._yearScrollerWidth
    });
  }
  /** @private */
  _track(t) {
    if (!this._desktopMode)
      switch (t.detail.state) {
        case "start":
          this._toggleAnimateClass(!1);
          break;
        case "track":
          this._handleTrack(t);
          break;
        case "end":
          this._toggleAnimateClass(!0), this._translateX >= this._yearScrollerWidth / 2 ? this._closeYearScroller() : this._openYearScroller();
          break;
      }
  }
  /** @private */
  _toggleAnimateClass(t) {
    t ? this.classList.add("animate") : this.classList.remove("animate");
  }
  /** @private */
  _toggleYearScroller() {
    this._isYearScrollerVisible() ? this._closeYearScroller() : this._openYearScroller();
  }
  /** @private */
  _openYearScroller() {
    this._translateX = 0, this.setAttribute("years-visible", "");
  }
  /** @private */
  _closeYearScroller() {
    this.removeAttribute("years-visible"), this._translateX = this._yearScrollerWidth;
  }
  /** @private */
  _isYearScrollerVisible() {
    return this._translateX < this._yearScrollerWidth / 2;
  }
  /** @private */
  _translateXChanged(t) {
    this._desktopMode || (this._monthScroller.style.transform = `translateX(${t - this._yearScrollerWidth}px)`, this._yearScroller.style.transform = `translateX(${t}px)`);
  }
  /** @private */
  _yearAfterXMonths(t) {
    return Nf(t).getFullYear();
  }
  /** @private */
  _differenceInMonths(t, r) {
    return (t.getFullYear() - r.getFullYear()) * 12 - r.getMonth() + t.getMonth();
  }
  /** @private */
  _clear() {
    this._selectDate("");
  }
  /** @private */
  _close() {
    this.dispatchEvent(new CustomEvent("close", { bubbles: !0, composed: !0 }));
  }
  /** @private */
  _cancel() {
    this.focusedDate = this.selectedDate, this._close();
  }
  /** @protected */
  _preventDefault(t) {
    t.preventDefault();
  }
  /** @private */
  __toggleDate(t) {
    me(t, this.selectedDate) ? (this._clear(), this.focusedDate = t) : this._selectDate(t);
  }
  /** @private */
  __onMonthCalendarKeyDown(t) {
    let r = !1;
    switch (t.key) {
      case "ArrowDown":
        this._moveFocusByDays(7), r = !0;
        break;
      case "ArrowUp":
        this._moveFocusByDays(-7), r = !0;
        break;
      case "ArrowRight":
        this._moveFocusByDays(this.__isRTL ? -1 : 1), r = !0;
        break;
      case "ArrowLeft":
        this._moveFocusByDays(this.__isRTL ? 1 : -1), r = !0;
        break;
      case "Enter":
        this._selectDate(this.focusedDate), this._close(), r = !0;
        break;
      case " ":
        this.__toggleDate(this.focusedDate), r = !0;
        break;
      case "Home":
        this._moveFocusInsideMonth(this.focusedDate, "minDate"), r = !0;
        break;
      case "End":
        this._moveFocusInsideMonth(this.focusedDate, "maxDate"), r = !0;
        break;
      case "PageDown":
        this._moveFocusByMonths(t.shiftKey ? 12 : 1), r = !0;
        break;
      case "PageUp":
        this._moveFocusByMonths(t.shiftKey ? -12 : -1), r = !0;
        break;
      case "Tab":
        this._onTabKeyDown(t, "calendar");
        break;
    }
    r && (t.preventDefault(), t.stopPropagation());
  }
  /** @private */
  _onTabKeyDown(t, r) {
    switch (t.stopPropagation(), r) {
      case "calendar":
        t.shiftKey && (t.preventDefault(), this.hasAttribute("fullscreen") ? this.focusCancel() : this.__focusInput());
        break;
      case "today":
        t.shiftKey && (t.preventDefault(), this.focusDateElement());
        break;
      case "cancel":
        t.shiftKey || (t.preventDefault(), this.hasAttribute("fullscreen") ? this.focusDateElement() : this.__focusInput());
        break;
    }
  }
  /** @private */
  __onTodayButtonKeyDown(t) {
    t.key === "Tab" && this._onTabKeyDown(t, "today");
  }
  /** @private */
  __onCancelButtonKeyDown(t) {
    t.key === "Tab" && this._onTabKeyDown(t, "cancel");
  }
  /** @private */
  __focusInput() {
    this.dispatchEvent(new CustomEvent("focus-input", { bubbles: !0, composed: !0 }));
  }
  /** @private */
  __tryFocusDate() {
    if (this.__pendingDateFocus) {
      const r = this.focusableDateElement;
      r && me(r.date, this.__pendingDateFocus) && (delete this.__pendingDateFocus, r.focus());
    }
  }
  async focusDate(t, r) {
    const s = t || this.selectedDate || this.initialPosition || /* @__PURE__ */ new Date();
    this.focusedDate = s, r || (this._focusedMonthDate = s.getDate()), await this.focusDateElement(!1);
  }
  async focusDateElement(t = !0) {
    this.__pendingDateFocus = this.focusedDate, this.calendars.length || await new Promise((r) => {
      Of(this, () => {
        Bf(), r();
      });
    }), t && this.revealDate(this.focusedDate), this._revealPromise && await this._revealPromise, this.__tryFocusDate();
  }
  /** @private */
  _focusClosestDate(t) {
    this.focusDate(Mf(t, [this.minDate, this.maxDate]));
  }
  /** @private */
  _focusAllowedDate(t, r, s) {
    this._dateAllowed(t) ? this.focusDate(t, s) : this._dateAllowed(this.focusedDate) ? r > 0 ? this.focusDate(this.maxDate) : this.focusDate(this.minDate) : this._focusClosestDate(this.focusedDate);
  }
  /** @private */
  _getDateDiff(t, r) {
    const s = new Date(0, 0);
    return s.setFullYear(this.focusedDate.getFullYear()), s.setMonth(this.focusedDate.getMonth() + t), r && s.setDate(this.focusedDate.getDate() + r), s;
  }
  /** @private */
  _moveFocusByDays(t) {
    const r = this._getDateDiff(0, t);
    this._focusAllowedDate(r, t, !1);
  }
  /** @private */
  _moveFocusByMonths(t) {
    const r = this._getDateDiff(t), s = r.getMonth();
    this._focusedMonthDate || (this._focusedMonthDate = this.focusedDate.getDate()), r.setDate(this._focusedMonthDate), r.getMonth() !== s && r.setDate(0), this._focusAllowedDate(r, t, !0);
  }
  /** @private */
  _moveFocusInsideMonth(t, r) {
    const s = new Date(0, 0);
    s.setFullYear(t.getFullYear()), r === "minDate" ? (s.setMonth(t.getMonth()), s.setDate(1)) : (s.setMonth(t.getMonth() + 1), s.setDate(0)), this._dateAllowed(s) ? this.focusDate(s) : this._dateAllowed(t) ? this.focusDate(this[r]) : this._focusClosestDate(t);
  }
  /** @private */
  _dateAllowed(t, r = this.minDate, s = this.maxDate) {
    return (!r || t >= r) && (!s || t <= s);
  }
  /** @private */
  _isTodayAllowed(t, r) {
    const s = /* @__PURE__ */ new Date(), o = new Date(0, 0);
    return o.setFullYear(s.getFullYear()), o.setMonth(s.getMonth()), o.setDate(s.getDate()), this._dateAllowed(o, t, r);
  }
  /**
   * Fired when the scroller reaches the target scrolling position.
   * @event scroll-animation-finished
   * @param {Number} detail.position new position
   * @param {Number} detail.oldPosition old position
   */
};
/**
 * @license
 * Copyright (c) 2016 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Yx = y`
  :host {
    display: flex;
    flex-direction: column;
    height: 100%;
    width: 100%;
    outline: none;
  }

  [part='overlay-header'] {
    display: flex;
    flex-shrink: 0;
    flex-wrap: nowrap;
    align-items: center;
  }

  :host(:not([fullscreen])) [part='overlay-header'] {
    display: none;
  }

  [part='label'] {
    flex-grow: 1;
  }

  [hidden] {
    display: none !important;
  }

  [part='years-toggle-button'] {
    display: flex;
  }

  #scrollers {
    display: flex;
    height: 100%;
    width: 100%;
    position: relative;
    overflow: hidden;
  }

  :host([desktop]) ::slotted([slot='months']) {
    right: 50px;
    transform: none !important;
  }

  :host([desktop]) ::slotted([slot='years']) {
    transform: none !important;
  }

  :host(.animate) ::slotted([slot='months']),
  :host(.animate) ::slotted([slot='years']) {
    transition: all 200ms;
  }

  [part='toolbar'] {
    display: flex;
    justify-content: space-between;
    z-index: 2;
    flex-shrink: 0;
  }
`;
/**
 * @license
 * Copyright (c) 2016 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
C("vaadin-date-picker-overlay-content", Yx, {
  moduleId: "vaadin-date-picker-overlay-content-styles"
});
class Zx extends Gx(
  rt(X(Be(N)))
) {
  static get template() {
    return U`
      <div part="overlay-header" on-touchend="_preventDefault" aria-hidden="true">
        <div part="label">[[_formatDisplayed(selectedDate, i18n, label)]]</div>
        <div part="clear-button" hidden$="[[!selectedDate]]"></div>
        <div part="toggle-button"></div>

        <div part="years-toggle-button" hidden$="[[_desktopMode]]" aria-hidden="true">
          [[_yearAfterXMonths(_visibleMonthIndex)]]
        </div>
      </div>

      <div id="scrollers">
        <slot name="months"></slot>
        <slot name="years"></slot>
      </div>

      <div on-touchend="_preventDefault" role="toolbar" part="toolbar">
        <slot name="today-button"></slot>
        <slot name="cancel-button"></slot>
      </div>
    `;
  }
  static get is() {
    return "vaadin-date-picker-overlay-content";
  }
  /** @protected */
  ready() {
    super.ready(), this.setAttribute("role", "dialog"), this._addListeners(), this._initControllers();
  }
}
O(Zx);
/**
 * @license
 * Copyright (c) 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const qf = (i) => class extends i {
  static get properties() {
    return {
      /**
       * A space-delimited list of CSS class names to set on the overlay element.
       * This property does not affect other CSS class names set manually via JS.
       *
       * Note, if the CSS class name was set with this property, clearing it will
       * remove it from the overlay, even if the same class name was also added
       * manually, e.g. by using `classList.add()` in the `renderer` function.
       *
       * @attr {string} overlay-class
       */
      overlayClass: {
        type: String
      },
      /**
       * An overlay element on which CSS class names are set.
       *
       * @protected
       */
      _overlayElement: {
        type: Object
      }
    };
  }
  static get observers() {
    return ["__updateOverlayClassNames(overlayClass, _overlayElement)"];
  }
  /** @private */
  __updateOverlayClassNames(t, r) {
    if (!r || t === void 0)
      return;
    const { classList: s } = r;
    if (this.__initialClasses || (this.__initialClasses = new Set(s)), Array.isArray(this.__previousClasses)) {
      const n = this.__previousClasses.filter((a) => !this.__initialClasses.has(a));
      n.length > 0 && s.remove(...n);
    }
    const o = typeof t == "string" ? t.split(" ") : [];
    o.length > 0 && s.add(...o), this.__previousClasses = o;
  }
};
/**
 * @license
 * Copyright (c) 2021 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class Wf {
  /**
   * @param {{ inputElement?: HTMLElement; opened: boolean } & HTMLElement} host
   */
  constructor(e) {
    this.host = e, e.addEventListener("opened-changed", () => {
      e.opened || this.__setVirtualKeyboardEnabled(!1);
    }), e.addEventListener("blur", () => this.__setVirtualKeyboardEnabled(!0)), e.addEventListener("touchstart", () => this.__setVirtualKeyboardEnabled(!0));
  }
  /** @private */
  __setVirtualKeyboardEnabled(e) {
    this.host.inputElement && (this.host.inputElement.inputMode = e ? "" : "none");
  }
}
/**
 * @license
 * Copyright (c) 2016 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Kx = (i) => class extends qf(
  rt(La(ja(Vi(i))))
) {
  static get properties() {
    return {
      /**
       * The current selected date.
       * @type {Date | undefined}
       * @protected
       */
      _selectedDate: {
        type: Object,
        sync: !0
      },
      /**
       * @type {Date | undefined}
       * @protected
       */
      _focusedDate: {
        type: Object,
        sync: !0
      },
      /**
       * Selected date.
       *
       * Supported date formats:
       * - ISO 8601 `"YYYY-MM-DD"` (default)
       * - 6-digit extended ISO 8601 `"+YYYYYY-MM-DD"`, `"-YYYYYY-MM-DD"`
       *
       * @type {string}
       */
      value: {
        type: String,
        notify: !0,
        value: "",
        sync: !0
      },
      /**
       * Date which should be visible when there is no value selected.
       *
       * The same date formats as for the `value` property are supported.
       * @attr {string} initial-position
       */
      initialPosition: String,
      /**
       * Set true to open the date selector overlay.
       */
      opened: {
        type: Boolean,
        reflectToAttribute: !0,
        notify: !0,
        observer: "_openedChanged",
        sync: !0
      },
      /**
       * Set true to prevent the overlay from opening automatically.
       * @attr {boolean} auto-open-disabled
       */
      autoOpenDisabled: Boolean,
      /**
       * Set true to display ISO-8601 week numbers in the calendar. Notice that
       * displaying week numbers is only supported when `i18n.firstDayOfWeek`
       * is 1 (Monday).
       * @attr {boolean} show-week-numbers
       */
      showWeekNumbers: {
        type: Boolean,
        value: !1,
        sync: !0
      },
      /**
       * @type {boolean}
       * @protected
       */
      _fullscreen: {
        type: Boolean,
        value: !1,
        sync: !0
      },
      /**
       * @type {string}
       * @protected
       */
      _fullscreenMediaQuery: {
        value: "(max-width: 420px), (max-height: 420px)"
      },
      /**
       * The object used to localize this component.
       * To change the default localization, replace the entire
       * `i18n` object with a custom one.
       *
       * To update individual properties, extend the existing i18n object like so:
       * ```
       * datePicker.i18n = { ...datePicker.i18n, {
       *   formatDate: date => { ... },
       *   parseDate: value => { ... },
       * }};
       * ```
       *
       * The object has the following JSON structure and default values:
       *
       * ```
       * {
       *   // An array with the full names of months starting
       *   // with January.
       *   monthNames: [
       *     'January', 'February', 'March', 'April', 'May',
       *     'June', 'July', 'August', 'September',
       *     'October', 'November', 'December'
       *   ],
       *
       *   // An array of weekday names starting with Sunday. Used
       *   // in screen reader announcements.
       *   weekdays: [
       *     'Sunday', 'Monday', 'Tuesday', 'Wednesday',
       *     'Thursday', 'Friday', 'Saturday'
       *   ],
       *
       *   // An array of short weekday names starting with Sunday.
       *   // Displayed in the calendar.
       *   weekdaysShort: [
       *     'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'
       *   ],
       *
       *   // An integer indicating the first day of the week
       *   // (0 = Sunday, 1 = Monday, etc.).
       *   firstDayOfWeek: 0,
       *
       *   // Translation of the Today shortcut button text.
       *   today: 'Today',
       *
       *   // Translation of the Cancel button text.
       *   cancel: 'Cancel',
       *
       *   // Used for adjusting the year value when parsing dates with short years.
       *   // The year values between 0 and 99 are evaluated and adjusted.
       *   // Example: for a referenceDate of 1970-10-30;
       *   //   dateToBeParsed: 40-10-30, result: 1940-10-30
       *   //   dateToBeParsed: 80-10-30, result: 1980-10-30
       *   //   dateToBeParsed: 10-10-30, result: 2010-10-30
       *   // Supported date format: ISO 8601 `"YYYY-MM-DD"` (default)
       *   // The default value is the current date.
       *   referenceDate: '',
       *
       *   // A function to format given `Object` as
       *   // date string. Object is in the format `{ day: ..., month: ..., year: ... }`
       *   // Note: The argument month is 0-based. This means that January = 0 and December = 11.
       *   formatDate: d => {
       *     // returns a string representation of the given
       *     // object in 'MM/DD/YYYY' -format
       *   },
       *
       *   // A function to parse the given text to an `Object` in the format `{ day: ..., month: ..., year: ... }`.
       *   // Must properly parse (at least) text formatted by `formatDate`.
       *   // Setting the property to null will disable keyboard input feature.
       *   // Note: The argument month is 0-based. This means that January = 0 and December = 11.
       *   parseDate: text => {
       *     // Parses a string in 'MM/DD/YY', 'MM/DD' or 'DD' -format to
       *     // an `Object` in the format `{ day: ..., month: ..., year: ... }`.
       *   }
       *
       *   // A function to format given `monthName` and
       *   // `fullYear` integer as calendar title string.
       *   formatTitle: (monthName, fullYear) => {
       *     return monthName + ' ' + fullYear;
       *   }
       * }
       * ```
       *
       * @type {!DatePickerI18n}
       * @default {English/US}
       */
      i18n: {
        type: Object,
        sync: !0,
        value: () => ({
          monthNames: [
            "January",
            "February",
            "March",
            "April",
            "May",
            "June",
            "July",
            "August",
            "September",
            "October",
            "November",
            "December"
          ],
          weekdays: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
          weekdaysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
          firstDayOfWeek: 0,
          today: "Today",
          cancel: "Cancel",
          referenceDate: "",
          formatDate(t) {
            const r = String(t.year).replace(/\d+/u, (s) => "0000".substr(s.length) + s);
            return [t.month + 1, t.day, r].join("/");
          },
          parseDate(t) {
            const r = t.split("/"), s = /* @__PURE__ */ new Date();
            let o, n = s.getMonth(), a = s.getFullYear();
            if (r.length === 3) {
              if (n = parseInt(r[0]) - 1, o = parseInt(r[1]), a = parseInt(r[2]), r[2].length < 3 && a >= 0) {
                const l = this.referenceDate ? mr(this.referenceDate) : /* @__PURE__ */ new Date();
                a = xx(l, a, n, o);
              }
            } else
              r.length === 2 ? (n = parseInt(r[0]) - 1, o = parseInt(r[1])) : r.length === 1 && (o = parseInt(r[0]));
            if (o !== void 0)
              return { day: o, month: n, year: a };
          },
          formatTitle: (t, r) => `${t} ${r}`
        })
      },
      /**
       * The earliest date that can be selected. All earlier dates will be disabled.
       *
       * Supported date formats:
       * - ISO 8601 `"YYYY-MM-DD"` (default)
       * - 6-digit extended ISO 8601 `"+YYYYYY-MM-DD"`, `"-YYYYYY-MM-DD"`
       *
       * @type {string | undefined}
       */
      min: {
        type: String,
        sync: !0
      },
      /**
       * The latest date that can be selected. All later dates will be disabled.
       *
       * Supported date formats:
       * - ISO 8601 `"YYYY-MM-DD"` (default)
       * - 6-digit extended ISO 8601 `"+YYYYYY-MM-DD"`, `"-YYYYYY-MM-DD"`
       *
       * @type {string | undefined}
       */
      max: {
        type: String,
        sync: !0
      },
      /**
       * The earliest date that can be selected. All earlier dates will be disabled.
       * @type {Date | undefined}
       * @protected
       */
      _minDate: {
        type: Date,
        computed: "__computeMinOrMaxDate(min)",
        sync: !0
      },
      /**
       * The latest date that can be selected. All later dates will be disabled.
       * @type {Date | undefined}
       * @protected
       */
      _maxDate: {
        type: Date,
        computed: "__computeMinOrMaxDate(max)",
        sync: !0
      },
      /** @private */
      _noInput: {
        type: Boolean,
        computed: "_isNoInput(inputElement, _fullscreen, _ios, i18n, opened, autoOpenDisabled)"
      },
      /** @private */
      _ios: {
        type: Boolean,
        value: Hs
      },
      /** @private */
      _focusOverlayOnOpen: Boolean,
      /** @private */
      _overlayContent: {
        type: Object,
        sync: !0
      },
      /**
       * In date-picker, unlike other components extending `InputMixin`,
       * the property indicates true only if the input has been entered by the user.
       * In the case of programmatic changes, the property is reset to false.
       * Read more about why this workaround is needed:
       * https://github.com/vaadin/web-components/issues/5639
       *
       * @protected
       * @override
       */
      _hasInputValue: {
        type: Boolean
      }
    };
  }
  static get observers() {
    return [
      "_selectedDateChanged(_selectedDate, i18n)",
      "_focusedDateChanged(_focusedDate, i18n)",
      "__updateOverlayContent(_overlayContent, i18n, label, _minDate, _maxDate, _focusedDate, _selectedDate, showWeekNumbers)",
      "__updateOverlayContentTheme(_overlayContent, _theme)",
      "__updateOverlayContentFullScreen(_overlayContent, _fullscreen)"
    ];
  }
  static get constraints() {
    return [...super.constraints, "min", "max"];
  }
  constructor() {
    super(), this._boundOnClick = this._onClick.bind(this), this._boundOnScroll = this._onScroll.bind(this), this._boundOverlayRenderer = this._overlayRenderer.bind(this);
  }
  /**
   * @override
   * @protected
   */
  get _inputElementValue() {
    return super._inputElementValue;
  }
  /**
   * The setter is overridden to reset the `_hasInputValue` property
   * to false when the input element's value is updated programmatically.
   * In date-picker, `_hasInputValue` is supposed to indicate true only
   * if the input has been entered by the user.
   * Read more about why this workaround is needed:
   * https://github.com/vaadin/web-components/issues/5639
   *
   * @override
   * @protected
   */
  set _inputElementValue(t) {
    super._inputElementValue = t, this._hasInputValue = !1;
  }
  /**
   * Override a getter from `InputControlMixin` to make it optional
   * and to prevent warning when a clear button is missing,
   * for example when using <vaadin-date-picker-light>.
   * @protected
   * @return {Element | null | undefined}
   */
  get clearElement() {
    return null;
  }
  /** @private */
  get _nativeInput() {
    return this.inputElement ? this.inputElement.focusElement || this.inputElement : null;
  }
  /**
   * Override an event listener from `DelegateFocusMixin`
   * @protected
   */
  _onFocus(t) {
    super._onFocus(t), this._noInput && t.target.blur();
  }
  /**
   * Override an event listener from `DelegateFocusMixin`
   * @protected
   */
  _onBlur(t) {
    super._onBlur(t), this.opened || (this._selectParsedOrFocusedDate(), document.hasFocus() && this.validate());
  }
  /** @protected */
  ready() {
    super.ready(), this.addEventListener("click", this._boundOnClick), this.addController(
      new Uf(this._fullscreenMediaQuery, (r) => {
        this._fullscreen = r;
      })
    ), this.addController(new Wf(this));
    const t = this.$.overlay;
    this._overlayElement = t, t.renderer = this._boundOverlayRenderer, this.addEventListener("mousedown", () => this.__bringToFront()), this.addEventListener("touchstart", () => this.__bringToFront());
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback(), this.opened = !1;
  }
  /**
   * Opens the dropdown.
   */
  open() {
    !this.disabled && !this.readonly && (this.opened = !0);
  }
  /**
   * Closes the dropdown.
   */
  close() {
    this.$.overlay.close();
  }
  /** @private */
  _overlayRenderer(t) {
    if (t.firstChild)
      return;
    const r = document.createElement("vaadin-date-picker-overlay-content");
    t.appendChild(r), this._overlayContent = r, r.addEventListener("close", () => {
      this._close();
    }), r.addEventListener("focus-input", this._focusAndSelect.bind(this)), r.addEventListener("date-tap", (s) => {
      this.__userConfirmedDate = !0, this._selectDate(s.detail.date), this._close();
    }), r.addEventListener("date-selected", (s) => {
      this.__userConfirmedDate = !!s.detail.date, this._selectDate(s.detail.date);
    }), r.addEventListener("focusin", () => {
      this._keyboardActive && this._setFocused(!0);
    }), r.addEventListener("focused-date-changed", (s) => {
      this._focusedDate = s.detail.value;
    });
  }
  /**
   * @param {string} dateString
   * @private
   */
  __parseDate(t) {
    if (!this.i18n.parseDate)
      return;
    let r = this.i18n.parseDate(t);
    if (r && (r = mr(`${r.year}-${r.month + 1}-${r.day}`)), r && !isNaN(r.getTime()))
      return r;
  }
  /**
   * @param {Date} dateObject
   * @private
   */
  __formatDate(t) {
    if (this.i18n.formatDate)
      return this.i18n.formatDate(zf(t));
  }
  /**
   * Returns true if the current input value satisfies all constraints (if any)
   *
   * Override the `checkValidity` method for custom validations.
   *
   * @return {boolean} True if the value is valid
   */
  checkValidity() {
    const t = this._inputElementValue, r = !t || !!this._selectedDate && t === this.__formatDate(this._selectedDate), s = !this._selectedDate || $i(this._selectedDate, this._minDate, this._maxDate);
    let o = !0;
    return this.inputElement && (this.inputElement.checkValidity ? o = this.inputElement.checkValidity() : this.inputElement.validate && (o = this.inputElement.validate())), r && s && o;
  }
  /**
   * Override method inherited from `FocusMixin`
   * to not call `_setFocused(true)` when focus
   * is restored after closing overlay on click,
   * and to avoid removing `focus-ring` attribute.
   *
   * @param {!FocusEvent} _event
   * @return {boolean}
   * @protected
   * @override
   */
  _shouldSetFocus(t) {
    return !this._shouldKeepFocusRing;
  }
  /**
   * Override method inherited from `FocusMixin`
   * to prevent removing the `focused` attribute:
   * - when moving focus to the overlay content,
   * - when closing on date click / outside click.
   *
   * @param {!FocusEvent} _event
   * @return {boolean}
   * @protected
   * @override
   */
  _shouldRemoveFocus(t) {
    return !this.opened;
  }
  /**
   * Override method inherited from `FocusMixin`
   * to store the `focus-ring` state to restore
   * it later when closing on outside click.
   *
   * @param {boolean} focused
   * @protected
   * @override
   */
  _setFocused(t) {
    super._setFocused(t), this._shouldKeepFocusRing = t && this._keyboardActive;
  }
  /** @private */
  __dispatchChange() {
    this.validate(), this.dispatchEvent(new CustomEvent("change", { bubbles: !0 }));
  }
  /**
   * Select date on user interaction and set the flag
   * to fire change event if necessary.
   *
   * @param {Date} dateToSelect
   * @protected
   */
  _selectDate(t) {
    const r = this.value;
    this._selectedDate = t, r !== this.value && this.__dispatchChange();
  }
  /** @private */
  _close() {
    this._focus(), this.close();
  }
  /** @private */
  __bringToFront() {
    requestAnimationFrame(() => {
      this.$.overlay.bringToFront();
    });
  }
  /** @private */
  // eslint-disable-next-line max-params
  _isNoInput(t, r, s, o, n, a) {
    return !t || r && (!a || n) || s && n || !o.parseDate;
  }
  /** @private */
  _formatISO(t) {
    if (!(t instanceof Date))
      return "";
    const r = (d, u = "00") => (u + d).substr((u + d).length - u.length);
    let s = "", o = "0000", n = t.getFullYear();
    n < 0 ? (n = -n, s = "-", o = "000000") : t.getFullYear() >= 1e4 && (s = "+", o = "000000");
    const a = s + r(n, o), l = r(t.getMonth() + 1), c = r(t.getDate());
    return [a, l, c].join("-");
  }
  /** @protected */
  _inputElementChanged(t) {
    super._inputElementChanged(t), t && (t.autocomplete = "off", t.setAttribute("role", "combobox"), t.setAttribute("aria-haspopup", "dialog"), t.setAttribute("aria-expanded", !!this.opened), this._applyInputValue(this._selectedDate));
  }
  /** @protected */
  _openedChanged(t) {
    this.inputElement && this.inputElement.setAttribute("aria-expanded", t);
  }
  /** @private */
  _selectedDateChanged(t, r) {
    t === void 0 || r === void 0 || (this.__keepInputValue || this._applyInputValue(t), this.value = this._formatISO(t), this._ignoreFocusedDateChange = !0, this._focusedDate = t, this._ignoreFocusedDateChange = !1);
  }
  /** @private */
  _focusedDateChanged(t, r) {
    t === void 0 || r === void 0 || !this._ignoreFocusedDateChange && !this._noInput && this._applyInputValue(t);
  }
  /**
   * Override the value observer from `InputMixin` to implement custom
   * handling of the `value` property. The date-picker doesn't forward
   * the value directly to the input like the default implementation of `InputMixin`.
   * Instead, it parses the value into a date, puts it in `_selectedDate` which
   * is then displayed in the input with respect to the specified date format.
   *
   * @param {string | undefined} value
   * @param {string | undefined} oldValue
   * @protected
   * @override
   */
  _valueChanged(t, r) {
    const s = mr(t);
    if (t && !s) {
      this.value = r;
      return;
    }
    t ? me(this._selectedDate, s) || (this._selectedDate = s, r !== void 0 && this.validate()) : this._selectedDate = null, this._toggleHasValue(this._hasValue);
  }
  /** @private */
  // eslint-disable-next-line max-params
  __updateOverlayContent(t, r, s, o, n, a, l, c) {
    t && (t.i18n = r, t.label = s, t.minDate = o, t.maxDate = n, t.focusedDate = a, t.selectedDate = l, t.showWeekNumbers = c);
  }
  /** @private */
  __updateOverlayContentTheme(t, r) {
    t && (r ? t.setAttribute("theme", r) : t.removeAttribute("theme"));
  }
  /** @private */
  __updateOverlayContentFullScreen(t, r) {
    t && t.toggleAttribute("fullscreen", r);
  }
  /** @protected */
  _onOverlayEscapePress() {
    this._focusedDate = this._selectedDate, this._close();
  }
  /** @protected */
  _onOverlayOpened() {
    const t = this._overlayContent;
    t.reset();
    const r = this._getInitialPosition();
    t.initialPosition = r;
    const s = t.focusedDate || r;
    t.scrollToDate(s), this._ignoreFocusedDateChange = !0, t.focusedDate = s, this._ignoreFocusedDateChange = !1, window.addEventListener("scroll", this._boundOnScroll, !0), this._focusOverlayOnOpen ? (t.focusDateElement(), this._focusOverlayOnOpen = !1) : this._focus();
    const o = this._nativeInput;
    this._noInput && o && (o.blur(), this._overlayContent.focusDateElement());
    const n = this._noInput ? t : [o, t];
    this.__showOthers = $f(n);
  }
  /** @private */
  _getInitialPosition() {
    const t = mr(this.initialPosition), r = this._selectedDate || this._overlayContent.initialPosition || t || /* @__PURE__ */ new Date();
    return t || $i(r, this._minDate, this._maxDate) ? r : Mf(r, [this._minDate, this._maxDate]);
  }
  /** @private */
  _selectParsedOrFocusedDate() {
    if (this._ignoreFocusedDateChange = !0, this.i18n.parseDate) {
      const t = this._inputElementValue || "", r = this.__parseDate(t);
      r ? this._selectDate(r) : (this.__keepInputValue = !0, this._selectDate(null), this._selectedDate = null, this.__keepInputValue = !1);
    } else
      this._focusedDate && this._selectDate(this._focusedDate);
    this._ignoreFocusedDateChange = !1;
  }
  /** @protected */
  _onOverlayClosed() {
    this.__showOthers && (this.__showOthers(), this.__showOthers = null), window.removeEventListener("scroll", this._boundOnScroll, !0), this.__userConfirmedDate ? this.__userConfirmedDate = !1 : this._selectParsedOrFocusedDate(), this._nativeInput && this._nativeInput.selectionStart && (this._nativeInput.selectionStart = this._nativeInput.selectionEnd), !this.value && !this._keyboardActive && this.validate();
  }
  /** @private */
  _onScroll(t) {
    (t.target === window || !this._overlayContent.contains(t.target)) && this._overlayContent._repositionYearScroller();
  }
  /** @protected */
  _focus() {
    this._noInput || this.inputElement.focus();
  }
  /** @private */
  _focusAndSelect() {
    this._focus(), this._setSelectionRange(0, this._inputElementValue.length);
  }
  /** @private */
  _applyInputValue(t) {
    this._inputElementValue = t ? this.__formatDate(t) : "";
  }
  /** @private */
  _setSelectionRange(t, r) {
    this._nativeInput && this._nativeInput.setSelectionRange && this._nativeInput.setSelectionRange(t, r);
  }
  /**
   * Override an event listener from `InputConstraintsMixin`
   * to have date-picker fully control when to fire a change event
   * and trigger validation.
   *
   * @protected
   */
  _onChange(t) {
    t.stopPropagation();
  }
  /**
   * @param {Event} event
   * @private
   */
  _onClick(t) {
    this._isClearButton(t) || this._onHostClick(t);
  }
  /**
   * @param {Event} event
   * @private
   */
  _onHostClick(t) {
    (!this.autoOpenDisabled || this._noInput) && (t.preventDefault(), this.open());
  }
  /**
   * Override an event listener from `InputControlMixin`
   * to validate and dispatch change on clear.
   * @protected
   */
  _onClearButtonClick(t) {
    t.preventDefault(), this._inputElementValue = "", this.value = "", this.__dispatchChange();
  }
  /**
   * Override an event listener from `KeyboardMixin`.
   * @param {KeyboardEvent} e
   * @protected
   * @override
   */
  _onKeyDown(t) {
    switch (super._onKeyDown(t), this._noInput && [
      9
      // Tab
    ].indexOf(t.keyCode) === -1 && t.preventDefault(), t.key) {
      case "ArrowDown":
      case "ArrowUp":
        t.preventDefault(), this.opened ? this._overlayContent.focusDateElement() : (this._focusOverlayOnOpen = !0, this.open());
        break;
      case "Tab":
        this.opened && (t.preventDefault(), t.stopPropagation(), this._setSelectionRange(0, 0), t.shiftKey ? this._overlayContent.focusCancel() : this._overlayContent.focusDateElement());
        break;
    }
  }
  /**
   * Override an event listener from `KeyboardMixin`.
   *
   * @param {!KeyboardEvent} _event
   * @protected
   * @override
   */
  _onEnter(t) {
    const r = this.value;
    this.opened ? this.close() : this._selectParsedOrFocusedDate(), r === this.value && this.validate();
  }
  /**
   * Override an event listener from `KeyboardMixin`.
   * Do not call `super` in order to override clear
   * button logic defined in `InputControlMixin`.
   *
   * @param {!KeyboardEvent} event
   * @protected
   * @override
   */
  _onEscape(t) {
    if (!this.opened) {
      if (this.clearButtonVisible && this.value) {
        t.stopPropagation(), this._onClearButtonClick(t);
        return;
      }
      this.autoOpenDisabled ? (this.inputElement.value === "" && this._selectDate(null), this._applyInputValue(this._selectedDate)) : (this._focusedDate = this._selectedDate, this._selectParsedOrFocusedDate());
    }
  }
  /** @protected */
  _isClearButton(t) {
    return t.composedPath()[0] === this.clearElement;
  }
  /**
   * Override an event listener from `InputMixin`
   * @protected
   */
  _onInput() {
    if (!this.opened && this._inputElementValue && !this.autoOpenDisabled && this.open(), this._inputElementValue) {
      const t = this.__parseDate(this._inputElementValue);
      t && (this._ignoreFocusedDateChange = !0, me(t, this._focusedDate) || (this._focusedDate = t), this._ignoreFocusedDateChange = !1);
    }
  }
  /** @private */
  __computeMinOrMaxDate(t) {
    return mr(t);
  }
  /**
   * Fired when the user commits a value change.
   *
   * @event change
   */
  /**
   * Fired when `value` property value changes.
   *
   * @event value-changed
   */
  /**
   * Fired when `opened` property value changes.
   *
   * @event opened-changed
   */
};
/**
 * @license
 * Copyright (c) 2016 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Qx = y`
  :host([opened]) {
    pointer-events: auto;
  }

  :host([dir='rtl']) [part='input-field'] {
    direction: ltr;
  }

  :host([dir='rtl']) [part='input-field'] ::slotted(input)::placeholder {
    direction: rtl;
    text-align: left;
  }
`;
/**
 * @license
 * Copyright (c) 2016 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
C("vaadin-date-picker", [ji, Qx], { moduleId: "vaadin-date-picker-styles" });
class al extends Kx(_o(X(At(N)))) {
  static get is() {
    return "vaadin-date-picker";
  }
  static get template() {
    return U`
      <div class="vaadin-date-picker-container">
        <div part="label">
          <slot name="label"></slot>
          <span part="required-indicator" aria-hidden="true" on-click="focus"></span>
        </div>

        <vaadin-input-container
          part="input-field"
          readonly="[[readonly]]"
          disabled="[[disabled]]"
          invalid="[[invalid]]"
          theme$="[[_theme]]"
        >
          <slot name="prefix" slot="prefix"></slot>
          <slot name="input"></slot>
          <div id="clearButton" part="clear-button" slot="suffix" aria-hidden="true"></div>
          <div part="toggle-button" slot="suffix" aria-hidden="true" on-click="_toggle"></div>
        </vaadin-input-container>

        <div part="helper-text">
          <slot name="helper"></slot>
        </div>

        <div part="error-message">
          <slot name="error-message"></slot>
        </div>
      </div>

      <vaadin-date-picker-overlay
        id="overlay"
        fullscreen$="[[_fullscreen]]"
        theme$="[[_theme]]"
        opened="{{opened}}"
        on-vaadin-overlay-escape-press="_onOverlayEscapePress"
        on-vaadin-overlay-open="_onOverlayOpened"
        on-vaadin-overlay-closing="_onOverlayClosed"
        restore-focus-on-close
        restore-focus-node="[[inputElement]]"
      ></vaadin-date-picker-overlay>

      <slot name="tooltip"></slot>
    `;
  }
  /**
   * Used by `InputControlMixin` as a reference to the clear button element.
   * @protected
   * @return {!HTMLElement}
   */
  get clearElement() {
    return this.$.clearButton;
  }
  /** @protected */
  ready() {
    super.ready(), this.addController(
      new Bi(this, (t) => {
        this._setInputElement(t), this._setFocusElement(t), this.stateTarget = t, this.ariaTarget = t;
      })
    ), this.addController(new Ui(this.inputElement, this._labelController)), this._tooltipController = new Et(this), this.addController(this._tooltipController), this._tooltipController.setPosition("top"), this._tooltipController.setAriaTarget(this.inputElement), this._tooltipController.setShouldShow((t) => !t.opened), this.shadowRoot.querySelector('[part="toggle-button"]').addEventListener("mousedown", (t) => t.preventDefault()), this.$.overlay.addEventListener("vaadin-overlay-close", this._onVaadinOverlayClose.bind(this));
  }
  /** @private */
  _onVaadinOverlayClose(e) {
    e.detail.sourceEvent && e.detail.sourceEvent.composedPath().includes(this) && e.preventDefault();
  }
  /** @private */
  _toggle(e) {
    e.stopPropagation(), this.$.overlay.opened ? this.close() : this.open();
  }
  // Workaround https://github.com/vaadin/web-components/issues/2855
  /** @protected */
  _openedChanged(e) {
    super._openedChanged(e), this.$.overlay.positionTarget = this.shadowRoot.querySelector('[part="input-field"]'), this.$.overlay.noVerticalOverlap = !0;
  }
}
O(al);
const ll = y`
  :host {
    display: flex;
    align-items: center;
    box-sizing: border-box;
    font-family: var(--lumo-font-family);
    font-size: var(--lumo-font-size-m);
    line-height: var(--lumo-line-height-xs);
    padding: 0.5em calc(var(--lumo-space-l) + var(--lumo-border-radius-m) / 4) 0.5em
      var(--_lumo-list-box-item-padding-left, calc(var(--lumo-border-radius-m) / 4));
    min-height: var(--lumo-size-m);
    outline: none;
    border-radius: var(--lumo-border-radius-m);
    cursor: var(--lumo-clickable-cursor);
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    -webkit-tap-highlight-color: var(--lumo-primary-color-10pct);
  }

  /* Checkmark */
  [part='checkmark']::before {
    display: var(--_lumo-item-selected-icon-display, none);
    content: var(--lumo-icons-checkmark);
    font-family: lumo-icons;
    font-size: var(--lumo-icon-size-m);
    line-height: 1;
    font-weight: normal;
    width: 1em;
    height: 1em;
    margin: calc((1 - var(--lumo-line-height-xs)) * var(--lumo-font-size-m) / 2) 0;
    color: var(--lumo-primary-text-color);
    flex: none;
    opacity: 0;
    transition: transform 0.2s cubic-bezier(0.12, 0.32, 0.54, 2), opacity 0.1s;
  }

  :host([selected]) [part='checkmark']::before {
    opacity: 1;
  }

  :host([active]:not([selected])) [part='checkmark']::before {
    transform: scale(0.8);
    opacity: 0;
    transition-duration: 0s;
  }

  [part='content'] {
    flex: auto;
  }

  /* Disabled */
  :host([disabled]) {
    color: var(--lumo-disabled-text-color);
    cursor: default;
    pointer-events: none;
  }

  /* TODO a workaround until we have "focus-follows-mouse". After that, use the hover style for focus-ring as well */
  @media (any-hover: hover) {
    :host(:hover:not([disabled])) {
      background-color: var(--lumo-primary-color-10pct);
    }

    :host([focus-ring]:not([disabled])) {
      box-shadow: inset 0 0 0 2px var(--lumo-primary-color-50pct);
    }
  }

  /* RTL specific styles */
  :host([dir='rtl']) {
    padding-left: calc(var(--lumo-space-l) + var(--lumo-border-radius-m) / 4);
    padding-right: var(--_lumo-list-box-item-padding-left, calc(var(--lumo-border-radius-m) / 4));
  }

  /* Slotted icons */
  :host ::slotted(vaadin-icon) {
    width: var(--lumo-icon-size-m);
    height: var(--lumo-icon-size-m);
  }
`;
C("vaadin-item", ll, { moduleId: "lumo-item" });
const jf = y`
  :host {
    transition: background-color 100ms;
    overflow: hidden;
    --_lumo-item-selected-icon-display: block;
  }

  @media (any-hover: hover) {
    :host([focused]:not([disabled])) {
      box-shadow: inset 0 0 0 2px var(--lumo-primary-color-50pct);
    }
  }
`;
C("vaadin-combo-box-item", [ll, jf], {
  moduleId: "lumo-combo-box-item"
});
/**
 * @license
 * Copyright (c) 2022 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Jx = y`
  [part~='loader'] {
    box-sizing: border-box;
    width: var(--lumo-icon-size-s);
    height: var(--lumo-icon-size-s);
    border: 2px solid transparent;
    border-color: var(--lumo-primary-color-10pct) var(--lumo-primary-color-10pct) var(--lumo-primary-color)
      var(--lumo-primary-color);
    border-radius: calc(0.5 * var(--lumo-icon-size-s));
    opacity: 0;
    pointer-events: none;
  }

  :host(:not([loading])) [part~='loader'] {
    display: none;
  }

  :host([loading]) [part~='loader'] {
    animation: 1s linear infinite lumo-loader-rotate, 0.3s 0.1s lumo-loader-fade-in both;
  }

  @keyframes lumo-loader-fade-in {
    0% {
      opacity: 0;
    }

    100% {
      opacity: 1;
    }
  }

  @keyframes lumo-loader-rotate {
    0% {
      transform: rotate(0deg);
    }

    100% {
      transform: rotate(360deg);
    }
  }
`, Gf = y`
  [part='content'] {
    padding: 0;
  }

  /* When items are empty, the spinner needs some room */
  :host(:not([closing])) [part~='content'] {
    min-height: calc(2 * var(--lumo-space-s) + var(--lumo-icon-size-s));
  }

  [part~='overlay'] {
    position: relative;
  }

  :host([top-aligned]) [part~='overlay'] {
    margin-top: var(--lumo-space-xs);
  }

  :host([bottom-aligned]) [part~='overlay'] {
    margin-bottom: var(--lumo-space-xs);
  }
`, Xx = y`
  [part~='loader'] {
    position: absolute;
    z-index: 1;
    left: var(--lumo-space-s);
    right: var(--lumo-space-s);
    top: var(--lumo-space-s);
    margin-left: auto;
    margin-inline-start: auto;
    margin-inline-end: 0;
  }

  :host([dir='rtl']) [part~='loader'] {
    left: auto;
    margin-left: 0;
    margin-right: auto;
    margin-inline-start: 0;
    margin-inline-end: auto;
  }
`;
C(
  "vaadin-combo-box-overlay",
  [
    wo,
    xo,
    Gf,
    Jx,
    Xx,
    y`
      :host {
        --_vaadin-combo-box-items-container-border-width: var(--lumo-space-xs);
        --_vaadin-combo-box-items-container-border-style: solid;
      }
    `
  ],
  { moduleId: "lumo-combo-box-overlay" }
);
/**
 * @license
 * Copyright (c) 2018 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
C("vaadin-time-picker-item", [ll, jf], {
  moduleId: "lumo-time-picker-item"
});
C(
  "vaadin-time-picker-overlay",
  [
    wo,
    xo,
    Gf,
    y`
      :host {
        --_vaadin-time-picker-items-container-border-width: var(--lumo-space-xs);
        --_vaadin-time-picker-items-container-border-style: solid;
      }
    `
  ],
  {
    moduleId: "lumo-time-picker-overlay"
  }
);
const eC = y`
  [part~='toggle-button']::before {
    content: var(--lumo-icons-clock);
  }

  :host([dir='rtl']) [part='input-field'] ::slotted(input:placeholder-shown) {
    --_lumo-text-field-overflow-mask-image: none;
  }

  :host([dir='rtl']) [part='input-field'] ::slotted(input) {
    --_lumo-text-field-overflow-mask-image: linear-gradient(to left, transparent, #000 1.25em);
  }
`;
C("vaadin-time-picker", [Wi, eC], { moduleId: "lumo-time-picker" });
/**
 * @license
 * Copyright (c) 2015 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Yf = (i) => class extends i {
  static get properties() {
    return {
      /**
       * The index of the item.
       */
      index: {
        type: Number
      },
      /**
       * The item to render.
       */
      item: {
        type: Object
      },
      /**
       * The text to render in the item.
       */
      label: {
        type: String
      },
      /**
       * True when item is selected.
       */
      selected: {
        type: Boolean,
        value: !1,
        reflectToAttribute: !0
      },
      /**
       * True when item is focused.
       */
      focused: {
        type: Boolean,
        value: !1,
        reflectToAttribute: !0
      },
      /**
       * Custom function for rendering the item content.
       */
      renderer: {
        type: Function
      }
    };
  }
  static get observers() {
    return ["__rendererOrItemChanged(renderer, index, item.*, selected, focused)", "__updateLabel(label, renderer)"];
  }
  static get observedAttributes() {
    return [...super.observedAttributes, "hidden"];
  }
  attributeChangedCallback(t, r, s) {
    t === "hidden" && s !== null ? this.index = void 0 : super.attributeChangedCallback(t, r, s);
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback(), this._owner = this.parentNode.owner;
    const t = this._owner.getAttribute("dir");
    t && this.setAttribute("dir", t);
  }
  /**
   * Requests an update for the content of the item.
   * While performing the update, it invokes the renderer passed in the `renderer` property.
   *
   * It is not guaranteed that the update happens immediately (synchronously) after it is requested.
   */
  requestContentUpdate() {
    if (!this.renderer)
      return;
    const t = {
      index: this.index,
      item: this.item,
      focused: this.focused,
      selected: this.selected
    };
    this.renderer(this, this._owner, t);
  }
  /** @private */
  __rendererOrItemChanged(t, r, s) {
    s === void 0 || r === void 0 || (this._oldRenderer !== t && (this.innerHTML = "", delete this._$litPart$), t && (this._oldRenderer = t, this.requestContentUpdate()));
  }
  /** @private */
  __updateLabel(t, r) {
    r || (this.textContent = t);
  }
};
/**
 * @license
 * Copyright (c) 2018 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class tC extends Yf(X(Be(N))) {
  static get is() {
    return "vaadin-time-picker-item";
  }
  static get template() {
    return U`
      <style>
        :host {
          display: block;
        }

        :host([hidden]) {
          display: none !important;
        }
      </style>
      <span part="checkmark" aria-hidden="true"></span>
      <div part="content">
        <slot></slot>
      </div>
    `;
  }
}
O(tC);
/**
 * @license
 * Copyright (c) 2015 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Zf = (i) => class extends Pf(i) {
  static get observers() {
    return ["_setOverlayWidth(positionTarget, opened)"];
  }
  constructor() {
    super(), this.requiredVerticalSpace = 200;
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    const t = this._comboBox, r = t && t.getAttribute("dir");
    r && this.setAttribute("dir", r);
  }
  /**
   * Override method inherited from `Overlay`
   * to not close on position target click.
   *
   * @param {Event} event
   * @return {boolean}
   * @protected
   */
  _shouldCloseOnOutsideClick(t) {
    const r = t.composedPath();
    return !r.includes(this.positionTarget) && !r.includes(this);
  }
  /** @private */
  _setOverlayWidth(t, r) {
    if (t && r) {
      const s = this.localName;
      this.style.setProperty(`--_${s}-default-width`, `${t.clientWidth}px`);
      const o = getComputedStyle(this._comboBox).getPropertyValue(`--${s}-width`);
      o === "" ? this.style.removeProperty(`--${s}-width`) : this.style.setProperty(`--${s}-width`, o), this._updatePosition();
    }
  }
};
/**
 * @license
 * Copyright (c) 2018 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const rC = y`
  #overlay {
    width: var(--vaadin-time-picker-overlay-width, var(--_vaadin-time-picker-overlay-default-width, auto));
  }

  [part='content'] {
    display: flex;
    flex-direction: column;
    height: 100%;
  }
`;
C("vaadin-time-picker-overlay", [sl, rC], {
  moduleId: "vaadin-time-picker-overlay-styles"
});
class iC extends Zf(il(Be(X(N)))) {
  static get is() {
    return "vaadin-time-picker-overlay";
  }
  static get template() {
    return U`
      <div id="backdrop" part="backdrop" hidden></div>
      <div part="overlay" id="overlay">
        <div part="content" id="content">
          <slot></slot>
        </div>
      </div>
    `;
  }
}
O(iC);
/**
 * @license
 * Copyright (c) 2015 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Or = class {
  toString() {
    return "";
  }
};
/**
 * @license
 * Copyright (c) 2015 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Kf = (i) => class extends i {
  static get properties() {
    return {
      /**
       * A full set of items to filter the visible options from.
       * Set to an empty array when combo-box is not opened.
       */
      items: {
        type: Array,
        observer: "__itemsChanged"
      },
      /**
       * Index of an item that has focus outline and is scrolled into view.
       * The actual focus still remains in the input field.
       */
      focusedIndex: {
        type: Number,
        observer: "__focusedIndexChanged"
      },
      /**
       * Set to true while combo-box fetches new page from the data provider.
       */
      loading: {
        type: Boolean,
        observer: "__loadingChanged"
      },
      /**
       * Whether the combo-box is currently opened or not. If set to false,
       * calling `scrollIntoView` does not have any effect.
       */
      opened: {
        type: Boolean,
        observer: "__openedChanged"
      },
      /**
       * The selected item from the `items` array.
       */
      selectedItem: {
        type: Object,
        observer: "__selectedItemChanged"
      },
      /**
       * Path for the id of the item, used to detect whether the item is selected.
       */
      itemIdPath: {
        type: String
      },
      /**
       * Reference to the owner (combo-box owner), used by the item elements.
       */
      owner: {
        type: Object
      },
      /**
       * Function used to set a label for every combo-box item.
       */
      getItemLabel: {
        type: Object
      },
      /**
       * Function used to render the content of every combo-box item.
       */
      renderer: {
        type: Object,
        observer: "__rendererChanged"
      },
      /**
       * Used to propagate the `theme` attribute from the host element.
       */
      theme: {
        type: String
      }
    };
  }
  constructor() {
    super(), this.__boundOnItemClick = this.__onItemClick.bind(this);
  }
  /** @private */
  get _viewportTotalPaddingBottom() {
    if (this._cachedViewportTotalPaddingBottom === void 0) {
      const t = window.getComputedStyle(this.$.selector);
      this._cachedViewportTotalPaddingBottom = [t.paddingBottom, t.borderBottomWidth].map((r) => parseInt(r, 10)).reduce((r, s) => r + s);
    }
    return this._cachedViewportTotalPaddingBottom;
  }
  /** @protected */
  ready() {
    super.ready(), this.setAttribute("role", "listbox"), this.id = `${this.localName}-${Da()}`, this.__hostTagName = this.constructor.is.replace("-scroller", ""), this.addEventListener("click", (t) => t.stopPropagation()), this.__patchWheelOverScrolling(), this.__virtualizer = new Yh({
      createElements: this.__createElements.bind(this),
      updateElement: this._updateElement.bind(this),
      elementsContainer: this,
      scrollTarget: this,
      scrollContainer: this.$.selector
    });
  }
  /**
   * Requests an update for the virtualizer to re-render items.
   */
  requestContentUpdate() {
    this.__virtualizer && this.__virtualizer.update();
  }
  /**
   * Scrolls an item at given index into view and adjusts `scrollTop`
   * so that the element gets fully visible on Arrow Down key press.
   * @param {number} index
   */
  scrollIntoView(t) {
    if (!(this.opened && t >= 0))
      return;
    const r = this._visibleItemsCount();
    let s = t;
    t > this.__virtualizer.lastVisibleIndex - 1 ? (this.__virtualizer.scrollToIndex(t), s = t - r + 1) : t > this.__virtualizer.firstVisibleIndex && (s = this.__virtualizer.firstVisibleIndex), this.__virtualizer.scrollToIndex(Math.max(0, s));
    const o = [...this.children].find(
      (c) => !c.hidden && c.index === this.__virtualizer.lastVisibleIndex
    );
    if (!o || t !== o.index)
      return;
    const n = o.getBoundingClientRect(), a = this.getBoundingClientRect(), l = n.bottom - a.bottom + this._viewportTotalPaddingBottom;
    l > 0 && (this.scrollTop += l);
  }
  /**
   * @param {string | object} item
   * @param {string | object} selectedItem
   * @param {string} itemIdPath
   * @protected
   */
  _isItemSelected(t, r, s) {
    return t instanceof Or ? !1 : s && t !== void 0 && r !== void 0 ? Ct(s, t) === Ct(s, r) : t === r;
  }
  /** @private */
  __itemsChanged(t) {
    this.__virtualizer && t && (this.__virtualizer.size = t.length, this.__virtualizer.flush(), this.requestContentUpdate());
  }
  /** @private */
  __loadingChanged() {
    this.requestContentUpdate();
  }
  /** @private */
  __openedChanged(t) {
    t && this.requestContentUpdate();
  }
  /** @private */
  __selectedItemChanged() {
    this.requestContentUpdate();
  }
  /** @private */
  __focusedIndexChanged(t, r) {
    t !== r && this.requestContentUpdate(), t >= 0 && !this.loading && this.scrollIntoView(t);
  }
  /** @private */
  __rendererChanged(t, r) {
    (t || r) && this.requestContentUpdate();
  }
  /** @private */
  __createElements(t) {
    return [...Array(t)].map(() => {
      const r = document.createElement(`${this.__hostTagName}-item`);
      return r.addEventListener("click", this.__boundOnItemClick), r.tabIndex = "-1", r.style.width = "100%", r;
    });
  }
  /**
   * @param {HTMLElement} el
   * @param {number} index
   * @protected
   */
  _updateElement(t, r) {
    const s = this.items[r], o = this.focusedIndex, n = this._isItemSelected(s, this.selectedItem, this.itemIdPath);
    t.setProperties({
      item: s,
      index: r,
      label: this.getItemLabel(s),
      selected: n,
      renderer: this.renderer,
      focused: !this.loading && o === r
    }), t.id = `${this.__hostTagName}-item-${r}`, t.setAttribute("role", r !== void 0 ? "option" : !1), t.setAttribute("aria-selected", n.toString()), t.setAttribute("aria-posinset", r + 1), t.setAttribute("aria-setsize", this.items.length), this.theme ? t.setAttribute("theme", this.theme) : t.removeAttribute("theme"), s instanceof Or && this.__requestItemByIndex(r);
  }
  /** @private */
  __onItemClick(t) {
    this.dispatchEvent(new CustomEvent("selection-changed", { detail: { item: t.currentTarget.item } }));
  }
  /**
   * We want to prevent the kinetic scrolling energy from being transferred from the overlay contents over to the parent.
   * Further improvement ideas: after the contents have been scrolled to the top or bottom and scrolling has stopped, it could allow
   * scrolling the parent similarly to touch scrolling.
   * @private
   */
  __patchWheelOverScrolling() {
    this.$.selector.addEventListener("wheel", (t) => {
      const r = this.scrollTop === 0, s = this.scrollHeight - this.scrollTop - this.clientHeight <= 1;
      (r && t.deltaY < 0 || s && t.deltaY > 0) && t.preventDefault();
    });
  }
  /**
   * Dispatches an `index-requested` event for the given index to notify
   * the data provider that it should start loading the page containing the requested index.
   *
   * The event is dispatched asynchronously to prevent an immediate page request and therefore
   * a possible infinite recursion in case the data provider implements page request cancelation logic
   * by invoking data provider page callbacks with an empty array.
   * The infinite recursion may occur otherwise since invoking a data provider page callback with an empty array
   * triggers a synchronous scroller update and, if the callback corresponds to the currently visible page,
   * the scroller will synchronously request the page again which may lead to looping in the end.
   * That was the case for the Flow counterpart:
   * https://github.com/vaadin/flow-components/issues/3553#issuecomment-1239344828
   * @private
   */
  __requestItemByIndex(t) {
    requestAnimationFrame(() => {
      this.dispatchEvent(
        new CustomEvent("index-requested", {
          detail: {
            index: t,
            currentScrollerPos: this._oldScrollerPosition
          }
        })
      );
    });
  }
  /** @private */
  _visibleItemsCount() {
    return this.__virtualizer.scrollToIndex(this.__virtualizer.firstVisibleIndex), this.__virtualizer.size > 0 ? this.__virtualizer.lastVisibleIndex - this.__virtualizer.firstVisibleIndex + 1 : 0;
  }
};
/**
 * @license
 * Copyright (c) 2018 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class sC extends Kf(N) {
  static get is() {
    return "vaadin-time-picker-scroller";
  }
  static get template() {
    return U`
      <style>
        :host {
          display: block;
          min-height: 1px;
          overflow: auto;

          /* Fixes item background from getting on top of scrollbars on Safari */
          transform: translate3d(0, 0, 0);

          /* Enable momentum scrolling on iOS */
          -webkit-overflow-scrolling: touch;

          /* Fixes scrollbar disappearing when 'Show scroll bars: Always' enabled in Safari */
          box-shadow: 0 0 0 white;
        }

        #selector {
          border-width: var(--_vaadin-time-picker-items-container-border-width);
          border-style: var(--_vaadin-time-picker-items-container-border-style);
          border-color: var(--_vaadin-time-picker-items-container-border-color, transparent);
          position: relative;
        }
      </style>
      <div id="selector">
        <slot></slot>
      </div>
    `;
  }
}
O(sC);
/**
 * @license
 * Copyright (c) 2015 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function cd(i) {
  return i != null;
}
function dd(i, e) {
  return i.findIndex((t) => t instanceof Or ? !1 : e(t));
}
const Qf = (i) => class extends qf(
  rt(Wa(Hi(Vi(ho(Li(i))))))
) {
  static get properties() {
    return {
      /**
       * True if the dropdown is open, false otherwise.
       * @type {boolean}
       */
      opened: {
        type: Boolean,
        notify: !0,
        value: !1,
        reflectToAttribute: !0,
        observer: "_openedChanged"
      },
      /**
       * Set true to prevent the overlay from opening automatically.
       * @attr {boolean} auto-open-disabled
       */
      autoOpenDisabled: {
        type: Boolean
      },
      /**
       * When present, it specifies that the field is read-only.
       * @type {boolean}
       */
      readonly: {
        type: Boolean,
        value: !1,
        reflectToAttribute: !0
      },
      /**
       * Custom function for rendering the content of every item.
       * Receives three arguments:
       *
       * - `root` The `<vaadin-combo-box-item>` internal container DOM element.
       * - `comboBox` The reference to the `<vaadin-combo-box>` element.
       * - `model` The object with the properties related with the rendered
       *   item, contains:
       *   - `model.index` The index of the rendered item.
       *   - `model.item` The item.
       * @type {ComboBoxRenderer | undefined}
       */
      renderer: Function,
      /**
       * A full set of items to filter the visible options from.
       * The items can be of either `String` or `Object` type.
       * @type {!Array<!ComboBoxItem | string> | undefined}
       */
      items: {
        type: Array,
        observer: "_itemsChanged"
      },
      /**
       * If `true`, the user can input a value that is not present in the items list.
       * `value` property will be set to the input value in this case.
       * Also, when `value` is set programmatically, the input value will be set
       * to reflect that value.
       * @attr {boolean} allow-custom-value
       * @type {boolean}
       */
      allowCustomValue: {
        type: Boolean,
        value: !1
      },
      /**
       * A subset of items, filtered based on the user input. Filtered items
       * can be assigned directly to omit the internal filtering functionality.
       * The items can be of either `String` or `Object` type.
       * @type {!Array<!ComboBoxItem | string> | undefined}
       */
      filteredItems: {
        type: Array,
        observer: "_filteredItemsChanged"
      },
      /**
       * Used to detect user value changes and fire `change` events.
       * @private
       */
      _lastCommittedValue: String,
      /**
       * When set to `true`, "loading" attribute is added to host and the overlay element.
       * @type {boolean}
       */
      loading: {
        type: Boolean,
        value: !1,
        reflectToAttribute: !0
      },
      /**
       * @type {number}
       * @protected
       */
      _focusedIndex: {
        type: Number,
        observer: "_focusedIndexChanged",
        value: -1
      },
      /**
       * Filtering string the user has typed into the input field.
       * @type {string}
       */
      filter: {
        type: String,
        value: "",
        notify: !0
      },
      /**
       * The selected item from the `items` array.
       * @type {ComboBoxItem | string | undefined}
       */
      selectedItem: {
        type: Object,
        notify: !0
      },
      /**
       * Path for label of the item. If `items` is an array of objects, the
       * `itemLabelPath` is used to fetch the displayed string label for each
       * item.
       *
       * The item label is also used for matching items when processing user
       * input, i.e., for filtering and selecting items.
       * @attr {string} item-label-path
       * @type {string}
       */
      itemLabelPath: {
        type: String,
        value: "label",
        observer: "_itemLabelPathChanged"
      },
      /**
       * Path for the value of the item. If `items` is an array of objects, the
       * `itemValuePath:` is used to fetch the string value for the selected
       * item.
       *
       * The item value is used in the `value` property of the combo box,
       * to provide the form value.
       * @attr {string} item-value-path
       * @type {string}
       */
      itemValuePath: {
        type: String,
        value: "value"
      },
      /**
       * Path for the id of the item. If `items` is an array of objects,
       * the `itemIdPath` is used to compare and identify the same item
       * in `selectedItem` and `filteredItems` (items given by the
       * `dataProvider` callback).
       * @attr {string} item-id-path
       */
      itemIdPath: String,
      /**
       * @type {!HTMLElement | undefined}
       * @protected
       */
      _toggleElement: {
        type: Object,
        observer: "_toggleElementChanged"
      },
      /** @private */
      _closeOnBlurIsPrevented: Boolean,
      /** @private */
      _scroller: Object,
      /** @private */
      _overlayOpened: {
        type: Boolean,
        observer: "_overlayOpenedChanged"
      }
    };
  }
  static get observers() {
    return [
      "_selectedItemChanged(selectedItem, itemValuePath, itemLabelPath)",
      "_openedOrItemsChanged(opened, filteredItems, loading)",
      "_updateScroller(_scroller, filteredItems, opened, loading, selectedItem, itemIdPath, _focusedIndex, renderer, theme)"
    ];
  }
  constructor() {
    super(), this._boundOverlaySelectedItemChanged = this._overlaySelectedItemChanged.bind(this), this._boundOnClearButtonMouseDown = this.__onClearButtonMouseDown.bind(this), this._boundOnClick = this._onClick.bind(this), this._boundOnOverlayTouchAction = this._onOverlayTouchAction.bind(this), this._boundOnTouchend = this._onTouchend.bind(this);
  }
  /**
   * Tag name prefix used by scroller and items.
   * @protected
   * @return {string}
   */
  get _tagNamePrefix() {
    return "vaadin-combo-box";
  }
  /**
   * Get a reference to the native `<input>` element.
   * Override to provide a custom input.
   * @protected
   * @return {HTMLInputElement | undefined}
   */
  get _nativeInput() {
    return this.inputElement;
  }
  /**
   * Override method inherited from `InputMixin`
   * to customize the input element.
   * @protected
   * @override
   */
  _inputElementChanged(t) {
    super._inputElementChanged(t);
    const r = this._nativeInput;
    r && (r.autocomplete = "off", r.autocapitalize = "off", r.setAttribute("role", "combobox"), r.setAttribute("aria-autocomplete", "list"), r.setAttribute("aria-expanded", !!this.opened), r.setAttribute("spellcheck", "false"), r.setAttribute("autocorrect", "off"), this._revertInputValueToValue(), this.clearElement && this.clearElement.addEventListener("mousedown", this._boundOnClearButtonMouseDown));
  }
  /** @protected */
  ready() {
    super.ready(), this._initOverlay(), this._initScroller(), this._lastCommittedValue = this.value, this.addEventListener("click", this._boundOnClick), this.addEventListener("touchend", this._boundOnTouchend);
    const t = () => {
      requestAnimationFrame(() => {
        this._overlayElement.bringToFront();
      });
    };
    this.addEventListener("mousedown", t), this.addEventListener("touchstart", t), Ha(this), this.addController(new Wf(this));
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback(), this.close();
  }
  /**
   * Requests an update for the content of items.
   * While performing the update, it invokes the renderer (passed in the `renderer` property) once an item.
   *
   * It is not guaranteed that the update happens immediately (synchronously) after it is requested.
   */
  requestContentUpdate() {
    this._scroller && (this._scroller.requestContentUpdate(), this._getItemElements().forEach((t) => {
      t.requestContentUpdate();
    }));
  }
  /**
   * Opens the dropdown list.
   */
  open() {
    !this.disabled && !this.readonly && (this.opened = !0);
  }
  /**
   * Closes the dropdown list.
   */
  close() {
    this.opened = !1;
  }
  /**
   * Override Polymer lifecycle callback to handle `filter` property change after
   * the observer for `opened` property is triggered. This is needed when opening
   * combo-box on user input to ensure the focused index is set correctly.
   *
   * @param {!Object} currentProps Current accessor values
   * @param {?Object} changedProps Properties changed since the last call
   * @param {?Object} oldProps Previous values for each changed property
   * @protected
   * @override
   */
  _propertiesChanged(t, r, s) {
    super._propertiesChanged(t, r, s), r.filter !== void 0 && this._filterChanged(r.filter);
  }
  /** @private */
  _initOverlay() {
    const t = this.$.overlay;
    t._comboBox = this, t.addEventListener("touchend", this._boundOnOverlayTouchAction), t.addEventListener("touchmove", this._boundOnOverlayTouchAction), t.addEventListener("mousedown", (r) => r.preventDefault()), t.addEventListener("opened-changed", (r) => {
      this._overlayOpened = r.detail.value;
    }), this._overlayElement = t;
  }
  /**
   * Create and initialize the scroller element.
   * Override to provide custom host reference.
   *
   * @protected
   */
  _initScroller(t) {
    const r = `${this._tagNamePrefix}-scroller`, s = this._overlayElement;
    s.renderer = (n) => {
      n.firstChild || n.appendChild(document.createElement(r));
    }, s.requestContentUpdate();
    const o = s.querySelector(r);
    o.owner = t || this, o.getItemLabel = this._getItemLabel.bind(this), o.addEventListener("selection-changed", this._boundOverlaySelectedItemChanged), this._scroller = o;
  }
  /** @private */
  // eslint-disable-next-line max-params
  _updateScroller(t, r, s, o, n, a, l, c, d) {
    t && (s && (t.style.maxHeight = getComputedStyle(this).getPropertyValue(`--${this._tagNamePrefix}-overlay-max-height`) || "65vh"), t.setProperties({
      items: s ? r : [],
      opened: s,
      loading: o,
      selectedItem: n,
      itemIdPath: a,
      focusedIndex: l,
      renderer: c,
      theme: d
    }));
  }
  /** @private */
  _openedOrItemsChanged(t, r, s) {
    this._overlayOpened = !!(t && (s || r && r.length));
  }
  /** @private */
  _overlayOpenedChanged(t, r) {
    t ? (this.dispatchEvent(new CustomEvent("vaadin-combo-box-dropdown-opened", { bubbles: !0, composed: !0 })), this._onOpened()) : r && this.filteredItems && this.filteredItems.length && (this.close(), this.dispatchEvent(new CustomEvent("vaadin-combo-box-dropdown-closed", { bubbles: !0, composed: !0 })));
  }
  /** @private */
  _focusedIndexChanged(t, r) {
    r !== void 0 && this._updateActiveDescendant(t);
  }
  /** @protected */
  _isInputFocused() {
    return this.inputElement && Fa(this.inputElement);
  }
  /** @private */
  _updateActiveDescendant(t) {
    const r = this._nativeInput;
    if (!r)
      return;
    const s = this._getItemElements().find((o) => o.index === t);
    s ? r.setAttribute("aria-activedescendant", s.id) : r.removeAttribute("aria-activedescendant");
  }
  /** @private */
  _openedChanged(t, r) {
    if (r === void 0)
      return;
    t ? (this._openedWithFocusRing = this.hasAttribute("focus-ring"), !this._isInputFocused() && !Ii && this.inputElement && this.inputElement.focus(), this._overlayElement.restoreFocusOnClose = !0) : (this._onClosed(), this._openedWithFocusRing && this._isInputFocused() && this.setAttribute("focus-ring", ""));
    const s = this._nativeInput;
    s && (s.setAttribute("aria-expanded", !!t), t ? s.setAttribute("aria-controls", this._scroller.id) : s.removeAttribute("aria-controls"));
  }
  /** @private */
  _onOverlayTouchAction() {
    this._closeOnBlurIsPrevented = !0, this.inputElement.blur(), this._closeOnBlurIsPrevented = !1;
  }
  /** @protected */
  _isClearButton(t) {
    return t.composedPath()[0] === this.clearElement;
  }
  /** @private */
  __onClearButtonMouseDown(t) {
    t.preventDefault(), this.inputElement.focus();
  }
  /**
   * @param {Event} event
   * @protected
   */
  _onClearButtonClick(t) {
    t.preventDefault(), this._onClearAction(), this.opened && this.requestContentUpdate();
  }
  /**
   * @param {Event} event
   * @private
   */
  _onToggleButtonClick(t) {
    t.preventDefault(), this.opened ? this.close() : this.open();
  }
  /**
   * @param {Event} event
   * @protected
   */
  _onHostClick(t) {
    this.autoOpenDisabled || (t.preventDefault(), this.open());
  }
  /** @private */
  _onClick(t) {
    this._isClearButton(t) ? this._onClearButtonClick(t) : t.composedPath().includes(this._toggleElement) ? this._onToggleButtonClick(t) : this._onHostClick(t);
  }
  /**
   * Override an event listener from `KeyboardMixin`.
   *
   * @param {KeyboardEvent} e
   * @protected
   * @override
   */
  _onKeyDown(t) {
    super._onKeyDown(t), t.key === "Tab" ? this._overlayElement.restoreFocusOnClose = !1 : t.key === "ArrowDown" ? (this._onArrowDown(), t.preventDefault()) : t.key === "ArrowUp" && (this._onArrowUp(), t.preventDefault());
  }
  /** @private */
  _getItemLabel(t) {
    let r = t && this.itemLabelPath ? Ct(this.itemLabelPath, t) : void 0;
    return r == null && (r = t ? t.toString() : ""), r;
  }
  /** @private */
  _getItemValue(t) {
    let r = t && this.itemValuePath ? Ct(this.itemValuePath, t) : void 0;
    return r === void 0 && (r = t ? t.toString() : ""), r;
  }
  /** @private */
  _onArrowDown() {
    if (this.opened) {
      const t = this.filteredItems;
      t && (this._focusedIndex = Math.min(t.length - 1, this._focusedIndex + 1), this._prefillFocusedItemLabel());
    } else
      this.open();
  }
  /** @private */
  _onArrowUp() {
    if (this.opened) {
      if (this._focusedIndex > -1)
        this._focusedIndex = Math.max(0, this._focusedIndex - 1);
      else {
        const t = this.filteredItems;
        t && (this._focusedIndex = t.length - 1);
      }
      this._prefillFocusedItemLabel();
    } else
      this.open();
  }
  /** @private */
  _prefillFocusedItemLabel() {
    if (this._focusedIndex > -1) {
      const t = this.filteredItems[this._focusedIndex];
      this._inputElementValue = this._getItemLabel(t), this._markAllSelectionRange();
    }
  }
  /** @private */
  _setSelectionRange(t, r) {
    this._isInputFocused() && this.inputElement.setSelectionRange && this.inputElement.setSelectionRange(t, r);
  }
  /** @private */
  _markAllSelectionRange() {
    this._inputElementValue !== void 0 && this._setSelectionRange(0, this._inputElementValue.length);
  }
  /** @private */
  _clearSelectionRange() {
    if (this._inputElementValue !== void 0) {
      const t = this._inputElementValue ? this._inputElementValue.length : 0;
      this._setSelectionRange(t, t);
    }
  }
  /** @private */
  _closeOrCommit() {
    !this.opened && !this.loading ? this._commitValue() : this.close();
  }
  /**
   * Override an event listener from `KeyboardMixin`.
   *
   * @param {KeyboardEvent} e
   * @protected
   * @override
   */
  _onEnter(t) {
    const r = this._focusedIndex < 0 && this._inputElementValue !== "" && this._getItemLabel(this.selectedItem) !== this._inputElementValue;
    if (!this.allowCustomValue && r) {
      t.preventDefault(), t.stopPropagation();
      return;
    }
    this.opened && (t.preventDefault(), t.stopPropagation()), this._closeOrCommit();
  }
  /**
   * Override an event listener from `KeyboardMixin`.
   * Do not call `super` in order to override clear
   * button logic defined in `InputControlMixin`.
   *
   * @param {!KeyboardEvent} e
   * @protected
   * @override
   */
  _onEscape(t) {
    this.autoOpenDisabled ? this.opened || this.value !== this._inputElementValue && this._inputElementValue.length > 0 ? (t.stopPropagation(), this._focusedIndex = -1, this.cancel()) : this.clearButtonVisible && !this.opened && this.value && (t.stopPropagation(), this._onClearAction()) : this.opened ? (t.stopPropagation(), this._focusedIndex > -1 ? (this._focusedIndex = -1, this._revertInputValue()) : this.cancel()) : this.clearButtonVisible && this.value && (t.stopPropagation(), this._onClearAction());
  }
  /** @private */
  _toggleElementChanged(t) {
    t && (t.addEventListener("mousedown", (r) => r.preventDefault()), t.addEventListener("click", () => {
      Ii && !this._isInputFocused() && document.activeElement.blur();
    }));
  }
  /**
   * Clears the current value.
   * @protected
   */
  _onClearAction() {
    this.selectedItem = null, this.allowCustomValue && (this.value = ""), this._detectAndDispatchChange();
  }
  /**
   * Reverts back to original value.
   */
  cancel() {
    this._revertInputValueToValue(), this._lastCommittedValue = this.value, this._closeOrCommit();
  }
  /** @private */
  _onOpened() {
    this._lastCommittedValue = this.value;
  }
  /** @private */
  _onClosed() {
    (!this.loading || this.allowCustomValue) && this._commitValue();
  }
  /** @private */
  _commitValue() {
    if (this._focusedIndex > -1) {
      const t = this.filteredItems[this._focusedIndex];
      this.selectedItem !== t && (this.selectedItem = t), this._inputElementValue = this._getItemLabel(this.selectedItem), this._focusedIndex = -1;
    } else if (this._inputElementValue === "" || this._inputElementValue === void 0)
      this.selectedItem = null, this.allowCustomValue && (this.value = "");
    else {
      const t = [this.selectedItem, ...this.filteredItems || []], r = t[this.__getItemIndexByLabel(t, this._inputElementValue)];
      if (this.allowCustomValue && // To prevent a repetitive input value being saved after pressing ESC and Tab.
      !r) {
        const s = this._inputElementValue;
        this._lastCustomValue = s;
        const o = new CustomEvent("custom-value-set", {
          detail: s,
          composed: !0,
          cancelable: !0,
          bubbles: !0
        });
        this.dispatchEvent(o), o.defaultPrevented || (this.value = s);
      } else
        !this.allowCustomValue && !this.opened && r ? this.value = this._getItemValue(r) : this._inputElementValue = this.selectedItem ? this._getItemLabel(this.selectedItem) : this.value || "";
    }
    this._detectAndDispatchChange(), this._clearSelectionRange(), this.filter = "";
  }
  /**
   * Override an event listener from `InputMixin`.
   * @param {!Event} event
   * @protected
   * @override
   */
  _onInput(t) {
    const r = this._inputElementValue, s = {};
    this.filter === r ? this._filterChanged(this.filter) : s.filter = r, !this.opened && !this._isClearButton(t) && !this.autoOpenDisabled && (s.opened = !0), this.setProperties(s);
  }
  /**
   * Override an event listener from `InputMixin`.
   * @param {!Event} event
   * @protected
   * @override
   */
  _onChange(t) {
    t.stopPropagation();
  }
  /** @private */
  _itemLabelPathChanged(t) {
  }
  /** @private */
  _filterChanged(t) {
    this._scrollIntoView(0), this._focusedIndex = -1, this.items ? this.filteredItems = this._filterItems(this.items, t) : this._filteredItemsChanged(this.filteredItems);
  }
  /** @protected */
  _revertInputValue() {
    this.filter !== "" ? this._inputElementValue = this.filter : this._revertInputValueToValue(), this._clearSelectionRange();
  }
  /** @private */
  _revertInputValueToValue() {
    this.allowCustomValue && !this.selectedItem ? this._inputElementValue = this.value : this._inputElementValue = this._getItemLabel(this.selectedItem);
  }
  /** @private */
  _selectedItemChanged(t) {
    if (t == null)
      this.filteredItems && (this.allowCustomValue || (this.value = ""), this._toggleHasValue(this._hasValue), this._inputElementValue = this.value);
    else {
      const r = this._getItemValue(t);
      if (this.value !== r && (this.value = r, this.value !== r))
        return;
      this._toggleHasValue(!0), this._inputElementValue = this._getItemLabel(t);
    }
  }
  /**
   * Override an observer from `InputMixin`.
   * @protected
   * @override
   */
  _valueChanged(t, r) {
    t === "" && r === void 0 || (cd(t) ? (this._getItemValue(this.selectedItem) !== t && this._selectItemForValue(t), !this.selectedItem && this.allowCustomValue && (this._inputElementValue = t), this._toggleHasValue(this._hasValue)) : this.selectedItem = null, this.filter = "", this._lastCommittedValue = void 0);
  }
  /** @private */
  _detectAndDispatchChange() {
    document.hasFocus() && this.validate(), this.value !== this._lastCommittedValue && (this.dispatchEvent(new CustomEvent("change", { bubbles: !0 })), this._lastCommittedValue = this.value);
  }
  /** @private */
  _itemsChanged(t, r) {
    this._ensureItemsOrDataProvider(() => {
      this.items = r;
    }), t ? this.filteredItems = t.slice(0) : r && (this.filteredItems = null);
  }
  /** @private */
  _filteredItemsChanged(t, r) {
    const s = r ? r[this._focusedIndex] : null, o = this.__getItemIndexByValue(t, this.value);
    (this.selectedItem === null || this.selectedItem === void 0) && o >= 0 && (this.selectedItem = t[o]);
    const n = this.__getItemIndexByValue(t, this._getItemValue(s));
    n > -1 ? this._focusedIndex = n : this._focusedIndex = this.__getItemIndexByLabel(this.filteredItems, this.filter);
  }
  /** @private */
  _filterItems(t, r) {
    return t && t.filter((o) => (r = r ? r.toString().toLowerCase() : "", this._getItemLabel(o).toString().toLowerCase().indexOf(r) > -1));
  }
  /** @private */
  _selectItemForValue(t) {
    const r = this.__getItemIndexByValue(this.filteredItems, t), s = this.selectedItem;
    r >= 0 ? this.selectedItem = this.filteredItems[r] : this.dataProvider && this.selectedItem === void 0 ? this.selectedItem = void 0 : this.selectedItem = null, this.selectedItem === null && s === null && this._selectedItemChanged(this.selectedItem);
  }
  /** @private */
  _getItemElements() {
    return Array.from(this._scroller.querySelectorAll(`${this._tagNamePrefix}-item`));
  }
  /** @private */
  _scrollIntoView(t) {
    this._scroller && this._scroller.scrollIntoView(t);
  }
  /**
   * Returns the first item that matches the provided value.
   *
   * @private
   */
  __getItemIndexByValue(t, r) {
    return !t || !cd(r) ? -1 : dd(t, (s) => this._getItemValue(s) === r);
  }
  /**
   * Returns the first item that matches the provided label.
   * Labels are matched against each other case insensitively.
   *
   * @private
   */
  __getItemIndexByLabel(t, r) {
    return !t || !r ? -1 : dd(t, (s) => this._getItemLabel(s).toString().toLowerCase() === r.toString().toLowerCase());
  }
  /** @private */
  _overlaySelectedItemChanged(t) {
    t.stopPropagation(), !(t.detail.item instanceof Or) && this.opened && (this._focusedIndex = this.filteredItems.indexOf(t.detail.item), this.close());
  }
  /**
   * Override method inherited from `FocusMixin`
   * to close the overlay on blur and commit the value.
   *
   * @param {boolean} focused
   * @protected
   * @override
   */
  _setFocused(t) {
    if (super._setFocused(t), !t && !this.readonly && !this._closeOnBlurIsPrevented) {
      if (!this.opened && this.allowCustomValue && this._inputElementValue === this._lastCustomValue) {
        delete this._lastCustomValue;
        return;
      }
      this._closeOrCommit();
    }
  }
  /**
   * Override method inherited from `FocusMixin` to not remove focused
   * state when focus moves to the overlay.
   *
   * @param {FocusEvent} event
   * @return {boolean}
   * @protected
   * @override
   */
  _shouldRemoveFocus(t) {
    return t.relatedTarget && t.relatedTarget.localName === `${this._tagNamePrefix}-item` ? !1 : t.relatedTarget === this._overlayElement ? (t.composedPath()[0].focus(), !1) : !0;
  }
  /** @private */
  _onTouchend(t) {
    !this.clearElement || t.composedPath()[0] !== this.clearElement || (t.preventDefault(), this._onClearAction());
  }
  /**
   * Fired when the value changes.
   *
   * @event value-changed
   * @param {Object} detail
   * @param {String} detail.value the combobox value
   */
  /**
   * Fired when selected item changes.
   *
   * @event selected-item-changed
   * @param {Object} detail
   * @param {Object|String} detail.value the selected item. Type is the same as the type of `items`.
   */
  /**
   * Fired when the user sets a custom value.
   * @event custom-value-set
   * @param {String} detail the custom value
   */
  /**
   * Fired when value changes.
   * To comply with https://developer.mozilla.org/en-US/docs/Web/Events/change
   * @event change
   */
  /**
   * Fired after the `vaadin-combo-box-overlay` opens.
   *
   * @event vaadin-combo-box-dropdown-opened
   */
  /**
   * Fired after the `vaadin-combo-box-overlay` closes.
   *
   * @event vaadin-combo-box-dropdown-closed
   */
};
/**
 * @license
 * Copyright (c) 2018 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class oC extends Qf(X(N)) {
  static get is() {
    return "vaadin-time-picker-combo-box";
  }
  static get template() {
    return U`
      <style>
        :host([opened]) {
          pointer-events: auto;
        }
      </style>

      <slot></slot>

      <vaadin-time-picker-overlay
        id="overlay"
        opened="[[_overlayOpened]]"
        loading$="[[loading]]"
        theme$="[[_theme]]"
        position-target="[[positionTarget]]"
        no-vertical-overlap
        restore-focus-node="[[inputElement]]"
      ></vaadin-time-picker-overlay>
    `;
  }
  static get properties() {
    return {
      positionTarget: {
        type: Object
      }
    };
  }
  /**
   * Tag name prefix used by scroller and items.
   * @protected
   * @return {string}
   */
  get _tagNamePrefix() {
    return "vaadin-time-picker";
  }
  /**
   * Reference to the clear button element.
   * @protected
   * @return {!HTMLElement}
   */
  get clearElement() {
    return this.querySelector('[part="clear-button"]');
  }
  /**
   * @override
   * @protected
   */
  get _inputElementValue() {
    return super._inputElementValue;
  }
  /**
   * The setter is overridden to ensure the `_hasInputValue` property
   * doesn't wrongly indicate true after the input element's value
   * is reverted or cleared programmatically.
   *
   * @override
   * @protected
   */
  set _inputElementValue(e) {
    super._inputElementValue = e, this._hasInputValue = e.length > 0;
  }
  /** @protected */
  ready() {
    super.ready(), this.allowCustomValue = !0, this._toggleElement = this.querySelector(".toggle-button"), this.setAttribute("dir", "ltr");
  }
}
O(oC);
/**
 * @license
 * Copyright (c) 2021 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Jf = (i) => class extends ja(i) {
  static get properties() {
    return {
      /**
       * A regular expression that the value is checked against.
       * The pattern must match the entire value, not just some subset.
       */
      pattern: {
        type: String
      }
    };
  }
  static get delegateAttrs() {
    return [...super.delegateAttrs, "pattern"];
  }
  static get constraints() {
    return [...super.constraints, "pattern"];
  }
};
/**
 * @license
 * Copyright (c) 2018 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const ud = "00:00:00.000", hd = "23:59:59.999";
C("vaadin-time-picker", ji, { moduleId: "vaadin-time-picker-styles" });
class Mi extends Jf(_o(X(At(N)))) {
  static get is() {
    return "vaadin-time-picker";
  }
  static get template() {
    return U`
      <style>
        /* See https://github.com/vaadin/vaadin-time-picker/issues/145 */
        :host([dir='rtl']) [part='input-field'] {
          direction: ltr;
        }

        :host([dir='rtl']) [part='input-field'] ::slotted(input)::placeholder {
          direction: rtl;
          text-align: left;
        }

        [part~='toggle-button'] {
          cursor: pointer;
        }
      </style>

      <div class="vaadin-time-picker-container">
        <div part="label">
          <slot name="label"></slot>
          <span part="required-indicator" aria-hidden="true" on-click="focus"></span>
        </div>

        <vaadin-time-picker-combo-box
          id="comboBox"
          filtered-items="[[__dropdownItems]]"
          value="{{_comboBoxValue}}"
          opened="{{opened}}"
          disabled="[[disabled]]"
          readonly="[[readonly]]"
          clear-button-visible="[[clearButtonVisible]]"
          auto-open-disabled="[[autoOpenDisabled]]"
          overlay-class="[[overlayClass]]"
          position-target="[[_inputContainer]]"
          theme$="[[_theme]]"
          on-change="__onComboBoxChange"
          on-validated="__onComboBoxValidated"
          on-has-input-value-changed="__onComboBoxHasInputValueChanged"
        >
          <vaadin-input-container
            part="input-field"
            readonly="[[readonly]]"
            disabled="[[disabled]]"
            invalid="[[invalid]]"
            theme$="[[_theme]]"
          >
            <slot name="prefix" slot="prefix"></slot>
            <slot name="input"></slot>
            <div id="clearButton" part="clear-button" slot="suffix" aria-hidden="true"></div>
            <div id="toggleButton" class="toggle-button" part="toggle-button" slot="suffix" aria-hidden="true"></div>
          </vaadin-input-container>
        </vaadin-time-picker-combo-box>

        <div part="helper-text">
          <slot name="helper"></slot>
        </div>

        <div part="error-message">
          <slot name="error-message"></slot>
        </div>
      </div>
      <slot name="tooltip"></slot>
    `;
  }
  static get properties() {
    return {
      /**
       * The time value for this element.
       *
       * Supported time formats are in ISO 8601:
       * - `hh:mm` (default)
       * - `hh:mm:ss`
       * - `hh:mm:ss.fff`
       * @type {string}
       */
      value: {
        type: String,
        notify: !0,
        value: ""
      },
      /**
       * True if the dropdown is open, false otherwise.
       */
      opened: {
        type: Boolean,
        notify: !0,
        value: !1,
        reflectToAttribute: !0
      },
      /**
       * Minimum time allowed.
       *
       * Supported time formats are in ISO 8601:
       * - `hh:mm`
       * - `hh:mm:ss`
       * - `hh:mm:ss.fff`
       * @type {string}
       */
      min: {
        type: String,
        value: ""
      },
      /**
       * Maximum time allowed.
       *
       * Supported time formats are in ISO 8601:
       * - `hh:mm`
       * - `hh:mm:ss`
       * - `hh:mm:ss.fff`
       * @type {string}
       */
      max: {
        type: String,
        value: ""
      },
      /**
       * Defines the time interval (in seconds) between the items displayed
       * in the time selection box. The default is 1 hour (i.e. `3600`).
       *
       * It also configures the precision of the value string. By default
       * the component formats values as `hh:mm` but setting a step value
       * lower than one minute or one second, format resolution changes to
       * `hh:mm:ss` and `hh:mm:ss.fff` respectively.
       *
       * Unit must be set in seconds, and for correctly configuring intervals
       * in the dropdown, it need to evenly divide a day.
       *
       * Note: it is possible to define step that is dividing an hour in inexact
       * fragments (i.e. 5760 seconds which equals 1 hour 36 minutes), but it is
       * not recommended to use it for better UX experience.
       */
      step: {
        type: Number
      },
      /**
       * Set true to prevent the overlay from opening automatically.
       * @attr {boolean} auto-open-disabled
       */
      autoOpenDisabled: Boolean,
      /**
       * A space-delimited list of CSS class names to set on the overlay element.
       *
       * @attr {string} overlay-class
       */
      overlayClass: {
        type: String
      },
      /** @private */
      __dropdownItems: {
        type: Array
      },
      /**
       * The object used to localize this component.
       * To change the default localization, replace the entire
       * _i18n_ object or just the property you want to modify.
       *
       * The object has the following JSON structure:
       *
       * ```
       * {
       *   // A function to format given `Object` as
       *   // time string. Object is in the format `{ hours: ..., minutes: ..., seconds: ..., milliseconds: ... }`
       *   formatTime: (time) => {
       *     // returns a string representation of the given
       *     // object in `hh` / 'hh:mm' / 'hh:mm:ss' / 'hh:mm:ss.fff' - formats
       *   },
       *
       *   // A function to parse the given text to an `Object` in the format
       *   // `{ hours: ..., minutes: ..., seconds: ..., milliseconds: ... }`.
       *   // Must properly parse (at least) text
       *   // formatted by `formatTime`.
       *   parseTime: text => {
       *     // Parses a string in object/string that can be formatted by`formatTime`.
       *   }
       * }
       * ```
       *
       * Both `formatTime` and `parseTime` need to be implemented
       * to ensure the component works properly.
       *
       * @type {!TimePickerI18n}
       */
      i18n: {
        type: Object,
        value: () => ({
          formatTime: (e) => {
            if (!e)
              return;
            const t = (s = 0, o = "00") => (o + s).substr((o + s).length - o.length);
            let r = `${t(e.hours)}:${t(e.minutes)}`;
            return e.seconds !== void 0 && (r += `:${t(e.seconds)}`), e.milliseconds !== void 0 && (r += `.${t(e.milliseconds, "000")}`), r;
          },
          parseTime: (e) => {
            const t = "(\\d|[0-1]\\d|2[0-3])", r = "(\\d|[0-5]\\d)", s = r, o = "(\\d{1,3})", a = new RegExp(
              `^${t}(?::${r}(?::${s}(?:\\.${o})?)?)?$`,
              "u"
            ).exec(e);
            if (a) {
              if (a[4])
                for (; a[4].length < 3; )
                  a[4] += "0";
              return { hours: a[1], minutes: a[2], seconds: a[3], milliseconds: a[4] };
            }
          }
        })
      },
      /** @private */
      _comboBoxValue: {
        type: String,
        observer: "__comboBoxValueChanged"
      },
      /** @private */
      _inputContainer: Object
    };
  }
  static get observers() {
    return ["__updateDropdownItems(i18n.*, min, max, step)"];
  }
  static get constraints() {
    return [...super.constraints, "min", "max"];
  }
  /**
   * Used by `InputControlMixin` as a reference to the clear button element.
   * @protected
   * @return {!HTMLElement}
   */
  get clearElement() {
    return this.$.clearButton;
  }
  /** @protected */
  ready() {
    super.ready(), this.addController(
      new Bi(this, (e) => {
        this._setInputElement(e), this._setFocusElement(e), this.stateTarget = e, this.ariaTarget = e;
      })
    ), this.addController(new Ui(this.inputElement, this._labelController)), this._inputContainer = this.shadowRoot.querySelector('[part~="input-field"]'), this._tooltipController = new Et(this), this._tooltipController.setShouldShow((e) => !e.opened), this._tooltipController.setPosition("top"), this._tooltipController.setAriaTarget(this.inputElement), this.addController(this._tooltipController);
  }
  /**
   * Override method inherited from `InputMixin` to forward the input to combo-box.
   * @protected
   * @override
   */
  _inputElementChanged(e) {
    super._inputElementChanged(e), e && this.$.comboBox._setInputElement(e);
  }
  /**
   * Opens the dropdown list.
   */
  open() {
    !this.disabled && !this.readonly && (this.opened = !0);
  }
  /**
   * Closes the dropdown list.
   */
  close() {
    this.opened = !1;
  }
  /**
   * Returns true if the current input value satisfies all constraints (if any).
   * You can override this method for custom validations.
   *
   * @return {boolean} True if the value is valid
   */
  checkValidity() {
    return !!(this.inputElement.checkValidity() && (!this.value || this._timeAllowed(this.i18n.parseTime(this.value))) && (!this._comboBoxValue || this.i18n.parseTime(this._comboBoxValue)));
  }
  /** @private */
  __validDayDivisor(e) {
    return !e || 24 * 3600 % e === 0 || e < 1 && e % 1 * 1e3 % 1 === 0;
  }
  /**
   * Override an event listener from `KeyboardMixin`.
   * @param {!KeyboardEvent} e
   * @protected
   */
  _onKeyDown(e) {
    if (super._onKeyDown(e), this.readonly || this.disabled || this.__dropdownItems.length)
      return;
    const t = this.__validDayDivisor(this.step) && this.step || 60;
    e.keyCode === 40 ? this.__onArrowPressWithStep(-t) : e.keyCode === 38 && this.__onArrowPressWithStep(t);
  }
  /**
   * Override an event listener from `KeyboardMixin`.
   * Do not call `super` in order to override clear
   * button logic defined in `InputControlMixin`.
   * @param {Event} event
   * @protected
   */
  _onEscape() {
  }
  /** @private */
  __onArrowPressWithStep(e) {
    const t = this.__addStep(this.__getMsec(this.__memoValue), e, !0);
    this.__memoValue = t, this.__useMemo = !0, this._comboBoxValue = this.i18n.formatTime(t), this.__useMemo = !1, this.validate(), this.__commitPendingValue();
  }
  /** @private */
  __commitPendingValue() {
    this.__committedValue !== this.value && (this.__dispatchChange(), this.__committedValue = this.value);
  }
  /** @private */
  __dispatchChange() {
    this.dispatchEvent(new CustomEvent("change", { bubbles: !0 }));
  }
  /**
   * Returning milliseconds from Object in the format `{ hours: ..., minutes: ..., seconds: ..., milliseconds: ... }`
   * @private
   */
  __getMsec(e) {
    let t = (e && e.hours || 0) * 60 * 60 * 1e3;
    return t += (e && e.minutes || 0) * 60 * 1e3, t += (e && e.seconds || 0) * 1e3, t += e && parseInt(e.milliseconds) || 0, t;
  }
  /**
   * Returning seconds from Object in the format `{ hours: ..., minutes: ..., seconds: ..., milliseconds: ... }`
   * @private
   */
  __getSec(e) {
    let t = (e && e.hours || 0) * 60 * 60;
    return t += (e && e.minutes || 0) * 60, t += e && e.seconds || 0, t += e && e.milliseconds / 1e3 || 0, t;
  }
  /**
   * Returning Object in the format `{ hours: ..., minutes: ..., seconds: ..., milliseconds: ... }`
   * from the result of adding step value in milliseconds to the milliseconds amount.
   * With `precision` parameter rounding the value to the closest step valid interval.
   * @private
   */
  __addStep(e, t, r) {
    e === 0 && t < 0 && (e = 24 * 60 * 60 * 1e3);
    const s = t * 1e3, o = e % s;
    s < 0 && o && r ? e -= o : s > 0 && o && r ? e -= o - s : e += s;
    const n = Math.floor(e / 1e3 / 60 / 60);
    e -= n * 1e3 * 60 * 60;
    const a = Math.floor(e / 1e3 / 60);
    e -= a * 1e3 * 60;
    const l = Math.floor(e / 1e3);
    return e -= l * 1e3, { hours: n < 24 ? n : 0, minutes: a, seconds: l, milliseconds: e };
  }
  /** @private */
  __updateDropdownItems(e, t, r, s) {
    const o = this.__validateTime(this.__parseISO(t || ud)), n = this.__getSec(o), a = this.__validateTime(this.__parseISO(r || hd)), l = this.__getSec(a);
    if (this.__dropdownItems = this.__generateDropdownList(n, l, s), s !== this.__oldStep) {
      this.__oldStep = s;
      const c = this.__validateTime(this.__parseISO(this.value));
      this.__updateValue(c);
    }
    this.value && (this._comboBoxValue = this.i18n.formatTime(this.i18n.parseTime(this.value)));
  }
  /** @private */
  __generateDropdownList(e, t, r) {
    if (r < 15 * 60 || !this.__validDayDivisor(r))
      return [];
    const s = [];
    r || (r = 3600);
    let o = -r + e;
    for (; o + r >= e && o + r <= t; ) {
      const n = this.__validateTime(this.__addStep(o * 1e3, r));
      o += r;
      const a = this.i18n.formatTime(n);
      s.push({ label: a, value: a });
    }
    return s;
  }
  /**
   * Override an observer from `InputMixin`.
   * @protected
   * @override
   */
  _valueChanged(e, t) {
    const r = this.__memoValue = this.__parseISO(e), s = this.__formatISO(r) || "";
    this.__skipCommittedValueUpdate || (this.__committedValue = e), e !== "" && e !== null && !r ? this.value = t === void 0 ? "" : t : e !== s ? this.value = s : this.__keepInvalidInput ? delete this.__keepInvalidInput : this.__updateInputValue(r), this._toggleHasValue(this._hasValue);
  }
  /** @private */
  __comboBoxValueChanged(e, t) {
    if (e === "" && t === void 0)
      return;
    const r = this.__useMemo ? this.__memoValue : this.i18n.parseTime(e), s = this.i18n.formatTime(r) || "";
    r ? e !== s ? this._comboBoxValue = s : (this.__skipCommittedValueUpdate = !0, this.__updateValue(r), this.__skipCommittedValueUpdate = !1) : (this.value !== "" && e !== "" && (this.__keepInvalidInput = !0), this.__skipCommittedValueUpdate = !0, this.value = "", this.__skipCommittedValueUpdate = !1);
  }
  /** @private */
  __onComboBoxChange(e) {
    e.stopPropagation(), this.__commitPendingValue();
  }
  /**
   * Synchronizes the `_hasInputValue` property with the internal combo-box's one.
   *
   * @private
   */
  __onComboBoxHasInputValueChanged() {
    this._hasInputValue = this.$.comboBox._hasInputValue;
  }
  /** @private */
  __onComboBoxValidated() {
    this.validate();
  }
  /** @private */
  __updateValue(e) {
    const t = this.__formatISO(this.__validateTime(e)) || "";
    this.value = t;
  }
  /** @private */
  __updateInputValue(e) {
    const t = this.i18n.formatTime(this.__validateTime(e)) || "";
    this._comboBoxValue = t;
  }
  /** @private */
  __validateTime(e) {
    if (e) {
      const t = this.__getStepSegment();
      e.hours = parseInt(e.hours), e.minutes = parseInt(e.minutes || 0), e.seconds = t < 3 ? void 0 : parseInt(e.seconds || 0), e.milliseconds = t < 4 ? void 0 : parseInt(e.milliseconds || 0);
    }
    return e;
  }
  /** @private */
  __getStepSegment() {
    if (this.step % 3600 === 0)
      return 1;
    if (this.step % 60 === 0 || !this.step)
      return 2;
    if (this.step % 1 === 0)
      return 3;
    if (this.step < 1)
      return 4;
  }
  /** @private */
  __formatISO(e) {
    return Mi.properties.i18n.value().formatTime(e);
  }
  /** @private */
  __parseISO(e) {
    return Mi.properties.i18n.value().parseTime(e);
  }
  /**
   * Returns true if `time` satisfies the `min` and `max` constraints (if any).
   *
   * @param {!TimePickerTime} time Value to check against constraints
   * @return {boolean} True if `time` satisfies the constraints
   * @protected
   */
  _timeAllowed(e) {
    const t = this.i18n.parseTime(this.min || ud), r = this.i18n.parseTime(this.max || hd);
    return (!this.__getMsec(t) || this.__getMsec(e) >= this.__getMsec(t)) && (!this.__getMsec(r) || this.__getMsec(e) <= this.__getMsec(r));
  }
  /**
   * Override method inherited from `InputControlMixin`.
   * @protected
   */
  _onClearButtonClick() {
  }
  /**
   * Override method inherited from `InputConstraintsMixin`.
   * @protected
   */
  _onChange() {
  }
  /**
   * Override method inherited from `InputMixin`.
   * @protected
   */
  _onInput() {
  }
  /**
   * Fired when the user commits a value change.
   *
   * @event change
   */
}
O(Mi);
/**
 * @license
 * Copyright (c) 2019 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Xf = y`
  :host {
    --lumo-text-field-size: var(--lumo-size-m);
    color: var(--lumo-body-text-color);
    font-size: var(--lumo-font-size-m);
    /* align with text-field height + vertical paddings */
    line-height: calc(var(--lumo-text-field-size) + 2 * var(--lumo-space-xs));
    font-family: var(--lumo-font-family);
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    -webkit-tap-highlight-color: transparent;
    padding: 0;
  }

  :host::before {
    margin-top: var(--lumo-space-xs);
    height: var(--lumo-text-field-size);
    box-sizing: border-box;
    display: inline-flex;
    align-items: center;
  }

  /* align with text-field label */
  :host([has-label]) [part='label'] {
    padding-bottom: calc(0.5em - var(--lumo-space-xs));
  }

  :host(:not([has-label])) [part='label'],
  :host(:not([has-label]))::before {
    display: none;
  }

  /* align with text-field error message */
  :host([has-error-message]) [part='error-message']::before {
    height: calc(0.4em - var(--lumo-space-xs));
  }

  :host([focused]:not([readonly]):not([disabled])) [part='label'] {
    color: var(--lumo-primary-text-color);
  }

  :host(:hover:not([readonly]):not([disabled]):not([focused])) [part='label'],
  :host(:hover:not([readonly]):not([disabled]):not([focused])) [part='helper-text'] {
    color: var(--lumo-body-text-color);
  }

  /* Touch device adjustment */
  @media (pointer: coarse) {
    :host(:hover:not([readonly]):not([disabled]):not([focused])) [part='label'] {
      color: var(--lumo-secondary-text-color);
    }
  }

  /* Disabled */
  :host([disabled]) [part='label'] {
    color: var(--lumo-disabled-text-color);
    -webkit-text-fill-color: var(--lumo-disabled-text-color);
  }

  /* Small theme */
  :host([theme~='small']) {
    font-size: var(--lumo-font-size-s);
    --lumo-text-field-size: var(--lumo-size-s);
  }

  :host([theme~='small'][has-label]) [part='label'] {
    font-size: var(--lumo-font-size-xs);
  }

  :host([theme~='small'][has-label]) [part='error-message'] {
    font-size: var(--lumo-font-size-xxs);
  }

  /* When custom-field is used with components without outer margin */
  :host([theme~='whitespace'][has-label]) [part='label'] {
    padding-bottom: 0.5em;
  }
`;
C("vaadin-custom-field", [go, qa, Xf], {
  moduleId: "lumo-custom-field"
});
const nC = y`
  ::slotted([slot='date-picker']) {
    margin-inline-end: 2px;
    --vaadin-input-field-top-end-radius: 0;
    --vaadin-input-field-bottom-end-radius: 0;
  }

  ::slotted([slot='time-picker']) {
    --vaadin-input-field-top-start-radius: 0;
    --vaadin-input-field-bottom-start-radius: 0;
  }
`;
C("vaadin-date-time-picker", [nC, go, qa, Xf], {
  moduleId: "lumo-date-time-picker"
});
/**
 * @license
 * Copyright (c) 2019 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
C("vaadin-date-time-picker", ji, { moduleId: "vaadin-date-time-picker" });
function ep(i, e) {
  for (; i; ) {
    if (i.properties && i.properties[e])
      return i.properties[e];
    i = Object.getPrototypeOf(i);
  }
}
const tp = ep(al, "i18n").value(), Es = ep(Mi, "i18n").value(), fd = Object.keys(tp), pd = Object.keys(Es);
class md extends Ke {
  constructor(e, t) {
    super(e, `${t}-picker`, `vaadin-${t}-picker`, {
      initializer: (r, s) => {
        const o = `__${t}Picker`;
        s[o] = r;
      }
    });
  }
}
class aC extends sf(Li(Hi(X(At(N))))) {
  static get template() {
    return U`
      <style>
        .vaadin-date-time-picker-container {
          --vaadin-field-default-width: auto;
        }

        .slots {
          display: flex;
          --vaadin-field-default-width: 12em;
        }

        .slots ::slotted([slot='date-picker']) {
          min-width: 0;
          flex: 1 1 auto;
        }

        .slots ::slotted([slot='time-picker']) {
          min-width: 0;
          flex: 1 1.65 auto;
        }
      </style>

      <div class="vaadin-date-time-picker-container">
        <div part="label" on-click="focus">
          <slot name="label"></slot>
          <span part="required-indicator" aria-hidden="true"></span>
        </div>

        <div class="slots">
          <slot name="date-picker" id="dateSlot"></slot>
          <slot name="time-picker" id="timeSlot"></slot>
        </div>

        <div part="helper-text">
          <slot name="helper"></slot>
        </div>

        <div part="error-message">
          <slot name="error-message"></slot>
        </div>
      </div>

      <slot name="tooltip"></slot>
    `;
  }
  static get is() {
    return "vaadin-date-time-picker";
  }
  static get properties() {
    return {
      /**
       * The name of the control, which is submitted with the form data.
       */
      name: {
        type: String
      },
      /**
       * The value for this element.
       *
       * Supported date time format is based on ISO 8601 (without a time zone designator):
       * - Minute precision `"YYYY-MM-DDThh:mm"` (default)
       * - Second precision `"YYYY-MM-DDThh:mm:ss"`
       * - Millisecond precision `"YYYY-MM-DDThh:mm:ss.fff"`
       * @type {string}
       */
      value: {
        type: String,
        notify: !0,
        value: "",
        observer: "__valueChanged"
      },
      /**
       * The earliest allowed value (date and time) that can be selected. All earlier values will be disabled.
       *
       * Supported date time format is based on ISO 8601 (without a time zone designator):
       * - Minute precision `"YYYY-MM-DDThh:mm"`
       * - Second precision `"YYYY-MM-DDThh:mm:ss"`
       * - Millisecond precision `"YYYY-MM-DDThh:mm:ss.fff"`
       *
       * @type {string | undefined}
       */
      min: {
        type: String,
        observer: "__minChanged"
      },
      /**
       * The latest value (date and time) that can be selected. All later values will be disabled.
       *
       * Supported date time format is based on ISO 8601 (without a time zone designator):
       * - Minute precision `"YYYY-MM-DDThh:mm"`
       * - Second precision `"YYYY-MM-DDThh:mm:ss"`
       * - Millisecond precision `"YYYY-MM-DDThh:mm:ss.fff"`
       *
       * @type {string | undefined}
       */
      max: {
        type: String,
        observer: "__maxChanged"
      },
      /**
       * The earliest value that can be selected. All earlier values will be disabled.
       * @private
       */
      __minDateTime: {
        type: Date,
        value: ""
      },
      /**
       * The latest value that can be selected. All later values will be disabled.
       * @private
       */
      __maxDateTime: {
        type: Date,
        value: ""
      },
      /**
       * A placeholder string for the date field.
       * @attr {string} date-placeholder
       */
      datePlaceholder: {
        type: String
      },
      /**
       * A placeholder string for the time field.
       * @attr {string} time-placeholder
       */
      timePlaceholder: {
        type: String
      },
      /**
       * Defines the time interval (in seconds) between the items displayed
       * in the time selection box. The default is 1 hour (i.e. `3600`).
       *
       * It also configures the precision of the time part of the value string. By default
       * the component formats time values as `hh:mm` but setting a step value
       * lower than one minute or one second, format resolution changes to
       * `hh:mm:ss` and `hh:mm:ss.fff` respectively.
       *
       * Unit must be set in seconds, and for correctly configuring intervals
       * in the dropdown, it need to evenly divide a day.
       *
       * Note: it is possible to define step that is dividing an hour in inexact
       * fragments (i.e. 5760 seconds which equals 1 hour 36 minutes), but it is
       * not recommended to use it for better UX.
       */
      step: {
        type: Number
      },
      /**
       * Date which should be visible in the date picker overlay when there is no value selected.
       *
       * The same date formats as for the `value` property are supported but without the time part.
       * @attr {string} initial-position
       */
      initialPosition: String,
      /**
       * Set true to display ISO-8601 week numbers in the calendar. Notice that
       * displaying week numbers is only supported when `i18n.firstDayOfWeek`
       * is 1 (Monday).
       * @attr {boolean} show-week-numbers
       */
      showWeekNumbers: {
        type: Boolean
      },
      /**
       * Set to true to prevent the overlays from opening automatically.
       * @attr {boolean} auto-open-disabled
       */
      autoOpenDisabled: Boolean,
      /**
       * Set to true to make this element read-only.
       * @type {boolean}
       */
      readonly: {
        type: Boolean,
        value: !1,
        reflectToAttribute: !0
      },
      /**
       * Specify that this control should have input focus when the page loads.
       * @type {boolean}
       */
      autofocus: {
        type: Boolean
      },
      /**
       * The current selected date time.
       * @private
       */
      __selectedDateTime: {
        type: Date
      },
      /**
       * The object used to localize this component.
       * To change the default localization, replace the entire
       * `i18n` object or just the properties you want to modify.
       *
       * The object is a combination of the i18n properties supported by
       * [`<vaadin-date-picker>`](#/elements/vaadin-date-picker) and
       * [`<vaadin-time-picker>`](#/elements/vaadin-time-picker).
       * @type {!DateTimePickerI18n}
       */
      i18n: {
        type: Object,
        value: () => ({ ...tp, ...Es })
      },
      /**
       * A space-delimited list of CSS class names to set on the overlay elements
       * of the internal components controlled by the `<vaadin-date-time-picker>`:
       *
       * - [`<vaadin-date-picker>`](#/elements/vaadin-date-picker#property-overlayClass)
       * - [`<vaadin-time-picker>`](#/elements/vaadin-time-picker#property-overlayClass)
       *
       * @attr {string} overlay-class
       */
      overlayClass: {
        type: String
      },
      /**
       * The current slotted date picker.
       * @private
       */
      __datePicker: {
        type: HTMLElement,
        observer: "__datePickerChanged"
      },
      /**
       * The current slotted time picker.
       * @private
       */
      __timePicker: {
        type: HTMLElement,
        observer: "__timePickerChanged"
      }
    };
  }
  static get observers() {
    return [
      "__selectedDateTimeChanged(__selectedDateTime)",
      "__datePlaceholderChanged(datePlaceholder, __datePicker)",
      "__timePlaceholderChanged(timePlaceholder, __timePicker)",
      "__stepChanged(step, __timePicker)",
      "__initialPositionChanged(initialPosition, __datePicker)",
      "__showWeekNumbersChanged(showWeekNumbers, __datePicker)",
      "__requiredChanged(required, __datePicker, __timePicker)",
      "__invalidChanged(invalid, __datePicker, __timePicker)",
      "__disabledChanged(disabled, __datePicker, __timePicker)",
      "__readonlyChanged(readonly, __datePicker, __timePicker)",
      "__i18nChanged(i18n, __datePicker, __timePicker)",
      "__autoOpenDisabledChanged(autoOpenDisabled, __datePicker, __timePicker)",
      "__themeChanged(_theme, __datePicker, __timePicker)",
      "__overlayClassChanged(overlayClass, __datePicker, __timePicker)",
      "__pickersChanged(__datePicker, __timePicker)",
      "__labelOrAccessibleNameChanged(label, accessibleName, i18n, __datePicker, __timePicker)"
    ];
  }
  constructor() {
    super(), this.__defaultDateMinMaxValue = void 0, this.__defaultTimeMinValue = "00:00:00.000", this.__defaultTimeMaxValue = "23:59:59.999", this.__changeEventHandler = this.__changeEventHandler.bind(this), this.__valueChangedEventHandler = this.__valueChangedEventHandler.bind(this);
  }
  /** @private */
  get __inputs() {
    return [this.__datePicker, this.__timePicker];
  }
  /** @private */
  get __formattedValue() {
    const [e, t] = this.__inputs.map((r) => r.value);
    return e && t ? [e, t].join("T") : "";
  }
  /** @protected */
  ready() {
    super.ready(), this._datePickerController = new md(this, "date"), this.addController(this._datePickerController), this._timePickerController = new md(this, "time"), this.addController(this._timePickerController), this.autofocus && !this.disabled && window.requestAnimationFrame(() => this.focus()), this.setAttribute("role", "group"), this._tooltipController = new Et(this), this.addController(this._tooltipController), this._tooltipController.setPosition("top"), this._tooltipController.setShouldShow((e) => e.__datePicker && !e.__datePicker.opened && e.__timePicker && !e.__timePicker.opened), this.ariaTarget = this;
  }
  focus() {
    this.__datePicker.focus();
  }
  /**
   * Override method inherited from `FocusMixin` to validate on blur.
   * @param {boolean} focused
   * @protected
   * @override
   */
  _setFocused(e) {
    super._setFocused(e), !e && document.hasFocus() && this.validate();
  }
  /**
   * Override method inherited from `FocusMixin` to not remove focused
   * state when focus moves between pickers or to the overlay.
   * @param {FocusEvent} event
   * @return {boolean}
   * @protected
   * @override
   */
  _shouldRemoveFocus(e) {
    const t = e.relatedTarget, r = this.__datePicker._overlayContent;
    return !(this.__datePicker.contains(t) || this.__timePicker.contains(t) || r && r.contains(t));
  }
  /** @private */
  __syncI18n(e, t, r = Object.keys(t.i18n)) {
    r.forEach((s) => {
      t.i18n && t.i18n.hasOwnProperty(s) && e.set(`i18n.${s}`, t.i18n[s]);
    });
  }
  /** @private */
  __changeEventHandler(e) {
    e.stopPropagation(), this.__dispatchChangeForValue === this.value && (this.validate(), this.__dispatchChange()), this.__dispatchChangeForValue = void 0;
  }
  /** @private */
  __addInputListeners(e) {
    e.addEventListener("change", this.__changeEventHandler), e.addEventListener("value-changed", this.__valueChangedEventHandler);
  }
  /** @private */
  __removeInputListeners(e) {
    e.removeEventListener("change", this.__changeEventHandler), e.removeEventListener("value-changed", this.__valueChangedEventHandler);
  }
  /** @private */
  __isDefaultPicker(e, t) {
    const r = this[`_${t}PickerController`];
    return r && e === r.defaultNode;
  }
  /** @private */
  __datePickerChanged(e, t) {
    e && (t && (this.__removeInputListeners(t), t.remove()), this.__addInputListeners(e), this.__isDefaultPicker(e, "date") ? (e.placeholder = this.datePlaceholder, e.invalid = this.invalid, e.initialPosition = this.initialPosition, e.showWeekNumbers = this.showWeekNumbers, this.__syncI18n(e, this, fd)) : (this.datePlaceholder = e.placeholder, this.initialPosition = e.initialPosition, this.showWeekNumbers = e.showWeekNumbers, this.__syncI18n(this, e, fd)), e.min = this.__formatDateISO(this.__minDateTime, this.__defaultDateMinMaxValue), e.max = this.__formatDateISO(this.__maxDateTime, this.__defaultDateMinMaxValue), e.validate = () => {
    }, e._validateInput = () => {
    });
  }
  /** @private */
  __timePickerChanged(e, t) {
    e && (t && (this.__removeInputListeners(t), t.remove()), this.__addInputListeners(e), this.__isDefaultPicker(e, "time") ? (e.placeholder = this.timePlaceholder, e.step = this.step, e.invalid = this.invalid, this.__syncI18n(e, this, pd)) : (this.timePlaceholder = e.placeholder, this.step = e.step, this.__syncI18n(this, e, pd)), this.__updateTimePickerMinMax(), e.validate = () => {
    });
  }
  /** @private */
  __updateTimePickerMinMax() {
    if (this.__timePicker && this.__datePicker) {
      const e = this.__parseDate(this.__datePicker.value), t = me(this.__minDateTime, this.__maxDateTime), r = this.__timePicker.value;
      this.__minDateTime && me(e, this.__minDateTime) || t ? this.__timePicker.min = this.__dateToIsoTimeString(this.__minDateTime) : this.__timePicker.min = this.__defaultTimeMinValue, this.__maxDateTime && me(e, this.__maxDateTime) || t ? this.__timePicker.max = this.__dateToIsoTimeString(this.__maxDateTime) : this.__timePicker.max = this.__defaultTimeMaxValue, this.__timePicker.value !== r && (this.__timePicker.value = r);
    }
  }
  /** @private */
  __i18nChanged(e, t, r) {
    t && (t.i18n = { ...t.i18n, ...e }), r && (r.i18n = { ...r.i18n, ...e });
  }
  /** @private */
  __labelOrAccessibleNameChanged(e, t, r, s, o) {
    const n = t || e || "";
    s && (s.accessibleName = `${n} ${r.dateLabel || ""}`.trim()), o && (o.accessibleName = `${n} ${r.timeLabel || ""}`.trim());
  }
  /** @private */
  __datePlaceholderChanged(e, t) {
    t && (t.placeholder = e);
  }
  /** @private */
  __timePlaceholderChanged(e, t) {
    t && (t.placeholder = e);
  }
  /** @private */
  __stepChanged(e, t) {
    t && t.step !== e && (t.step = e);
  }
  /** @private */
  __initialPositionChanged(e, t) {
    t && (t.initialPosition = e);
  }
  /** @private */
  __showWeekNumbersChanged(e, t) {
    t && (t.showWeekNumbers = e);
  }
  /** @private */
  __invalidChanged(e, t, r) {
    t && (t.invalid = e), r && (r.invalid = e);
  }
  /** @private */
  __requiredChanged(e, t, r) {
    t && (t.required = e), r && (r.required = e);
  }
  /** @private */
  __disabledChanged(e, t, r) {
    t && (t.disabled = e), r && (r.disabled = e);
  }
  /** @private */
  __readonlyChanged(e, t, r) {
    t && (t.readonly = e), r && (r.readonly = e);
  }
  /**
   * String (ISO date) to Date object
   * @param {string} str e.g. 'yyyy-mm-dd'
   * @return {Date | undefined}
   * @private
   */
  __parseDate(e) {
    return mr(e);
  }
  /**
   * Date object to string (ISO date)
   * @param {Date} date
   * @param {string} defaultValue
   * @return {string} e.g. 'yyyy-mm-dd' (or defaultValue when date is falsy)
   * @private
   */
  __formatDateISO(e, t) {
    return e ? al.prototype._formatISO(e) : t;
  }
  /**
   * Custom time object to string (ISO time)
   * @param {!TimePickerTime} time Time components as properties { hours, minutes, seconds, milliseconds }
   * @return {string} e.g. 'hh:mm', 'hh:mm:ss', 'hh:mm:ss.fff'
   * @private
   */
  __formatTimeISO(e) {
    return Es.formatTime(e);
  }
  /**
   * String (ISO time) to custom time object
   * @param {string} str e.g. 'hh:mm', 'hh:mm:ss', 'hh:mm:ss.fff'
   * @return {!TimePickerTime | undefined} Time components as properties { hours, minutes, seconds, milliseconds }
   * @private
   */
  __parseTimeISO(e) {
    return Es.parseTime(e);
  }
  /**
   * String (ISO date time) to Date object
   * @param {string} str e.g. 'yyyy-mm-ddThh:mm', 'yyyy-mm-ddThh:mm:ss', 'yyyy-mm-ddThh:mm:ss.fff'
   * @return {Date | undefined}
   * @private
   */
  __parseDateTime(e) {
    const [t, r] = e.split("T");
    if (!(t && r))
      return;
    const s = this.__parseDate(t);
    if (!s)
      return;
    const o = this.__parseTimeISO(r);
    if (o)
      return s.setHours(parseInt(o.hours)), s.setMinutes(parseInt(o.minutes || 0)), s.setSeconds(parseInt(o.seconds || 0)), s.setMilliseconds(parseInt(o.milliseconds || 0)), s;
  }
  /**
   * Date object to string (ISO date time)
   * @param {Date} date
   * @return {string} e.g. 'yyyy-mm-ddThh:mm', 'yyyy-mm-ddThh:mm:ss', 'yyyy-mm-ddThh:mm:ss.fff'
   *                  (depending on precision defined by "step" property)
   * @private
   */
  __formatDateTime(e) {
    if (!e)
      return "";
    const t = this.__formatDateISO(e, ""), r = this.__dateToIsoTimeString(e);
    return `${t}T${r}`;
  }
  /**
   * Date object to string (ISO time)
   * @param {Date} date
   * @return {string} e.g. 'hh:mm', 'hh:mm:ss', 'hh:mm:ss.fff' (depending on precision defined by "step" property)
   * @private
   */
  __dateToIsoTimeString(e) {
    return this.__formatTimeISO(
      this.__validateTime({
        hours: e.getHours(),
        minutes: e.getMinutes(),
        seconds: e.getSeconds(),
        milliseconds: e.getMilliseconds()
      })
    );
  }
  /**
   * @param {!TimePickerTime} timeObject
   * @return {!TimePickerTime}
   * @private
   */
  __validateTime(e) {
    if (e) {
      const t = this.__getStepSegment();
      e.seconds = t < 3 ? void 0 : e.seconds, e.milliseconds = t < 4 ? void 0 : e.milliseconds;
    }
    return e;
  }
  /**
   * Returns true if the current input value satisfies all constraints (if any)
   *
   * You can override the `checkValidity` method for custom validations.
   * @return {boolean}
   */
  checkValidity() {
    const e = this.__inputs.some((r) => !r.checkValidity()), t = this.required && this.__inputs.some((r) => !r.value);
    return !(e || t);
  }
  // Copied from vaadin-time-picker
  /** @private */
  __getStepSegment() {
    const e = this.step == null ? 60 : parseFloat(this.step);
    if (e % 3600 === 0)
      return 1;
    if (e % 60 === 0 || !e)
      return 2;
    if (e % 1 === 0)
      return 3;
    if (e < 1)
      return 4;
  }
  /**
   * @param {Date} date1
   * @param {Date} date2
   * @return {boolean}
   * @private
   */
  __dateTimeEquals(e, t) {
    return me(e, t) ? e.getHours() === t.getHours() && e.getMinutes() === t.getMinutes() && e.getSeconds() === t.getSeconds() && e.getMilliseconds() === t.getMilliseconds() : !1;
  }
  /** @private */
  __handleDateTimeChange(e, t, r, s) {
    if (!r) {
      this[e] = "", this[t] = "";
      return;
    }
    const o = this.__parseDateTime(r);
    if (!o) {
      this[e] = s;
      return;
    }
    this.__dateTimeEquals(this[t], o) || (this[t] = o);
  }
  /** @private */
  __valueChanged(e, t) {
    this.__handleDateTimeChange("value", "__selectedDateTime", e, t), t !== void 0 && (this.__dispatchChangeForValue = e), this.toggleAttribute("has-value", !!e), this.__updateTimePickerMinMax();
  }
  /** @private */
  __dispatchChange() {
    this.dispatchEvent(new CustomEvent("change", { bubbles: !0 }));
  }
  /** @private */
  __minChanged(e, t) {
    this.__handleDateTimeChange("min", "__minDateTime", e, t), this.__datePicker && (this.__datePicker.min = this.__formatDateISO(this.__minDateTime, this.__defaultDateMinMaxValue)), this.__updateTimePickerMinMax(), this.__datePicker && this.__timePicker && this.value && this.validate();
  }
  /** @private */
  __maxChanged(e, t) {
    this.__handleDateTimeChange("max", "__maxDateTime", e, t), this.__datePicker && (this.__datePicker.max = this.__formatDateISO(this.__maxDateTime, this.__defaultDateMinMaxValue)), this.__updateTimePickerMinMax(), this.__datePicker && this.__timePicker && this.value && this.validate();
  }
  /** @private */
  __selectedDateTimeChanged(e) {
    const t = this.__formatDateTime(e);
    if (this.value !== t && (this.value = t), !!(this.__datePicker && this.__datePicker.$) && !this.__ignoreInputValueChange) {
      this.__ignoreInputValueChange = !0;
      const [s, o] = this.value.split("T");
      this.__datePicker.value = s || "", this.__timePicker.value = o || "", this.__ignoreInputValueChange = !1;
    }
  }
  /** @private */
  __valueChangedEventHandler() {
    if (this.__ignoreInputValueChange)
      return;
    const e = this.__formattedValue, [t, r] = e.split("T");
    this.__ignoreInputValueChange = !0, this.__updateTimePickerMinMax(), t && r ? e !== this.value && (this.value = e) : this.value = "", this.__ignoreInputValueChange = !1;
  }
  /** @private */
  __autoOpenDisabledChanged(e, t, r) {
    t && (t.autoOpenDisabled = e), r && (r.autoOpenDisabled = e);
  }
  /** @private */
  __themeChanged(e, t, r) {
    !t || !r || [t, r].forEach((s) => {
      e ? s.setAttribute("theme", e) : s.removeAttribute("theme");
    });
  }
  /** @private */
  __overlayClassChanged(e, t, r) {
    !t || !r || (t.overlayClass = e, r.overlayClass = e);
  }
  /** @private */
  __pickersChanged(e, t) {
    !e || !t || this.__isDefaultPicker(e, "date") === this.__isDefaultPicker(t, "time") && (e.value ? this.__valueChangedEventHandler() : this.value && (this.__selectedDateTimeChanged(this.__selectedDateTime), (this.min || this.max) && this.validate()));
  }
  /**
   * Fired when the user commits a value change.
   *
   * @event change
   */
}
O(aC);
const lC = y`
  :host {
    outline: none;
  }

  [part='toggle-button']::before {
    content: var(--lumo-icons-dropdown);
  }
`;
C("vaadin-combo-box", [Wi, lC], { moduleId: "lumo-combo-box" });
/**
 * @license
 * Copyright (c) 2015 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class cC extends Yf(X(Be(N))) {
  static get template() {
    return U`
      <style>
        :host {
          display: block;
        }

        :host([hidden]) {
          display: none;
        }
      </style>
      <span part="checkmark" aria-hidden="true"></span>
      <div part="content">
        <slot></slot>
      </div>
    `;
  }
  static get is() {
    return "vaadin-combo-box-item";
  }
}
O(cC);
/**
 * @license
 * Copyright (c) 2015 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const dC = y`
  #overlay {
    width: var(--vaadin-combo-box-overlay-width, var(--_vaadin-combo-box-overlay-default-width, auto));
  }

  [part='content'] {
    display: flex;
    flex-direction: column;
    height: 100%;
  }
`;
C("vaadin-combo-box-overlay", [sl, dC], {
  moduleId: "vaadin-combo-box-overlay-styles"
});
class uC extends Zf(il(Be(X(N)))) {
  static get is() {
    return "vaadin-combo-box-overlay";
  }
  static get template() {
    return U`
      <div id="backdrop" part="backdrop" hidden></div>
      <div part="overlay" id="overlay">
        <div part="loader"></div>
        <div part="content" id="content"><slot></slot></div>
      </div>
    `;
  }
}
O(uC);
/**
 * @license
 * Copyright (c) 2015 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class hC extends Kf(N) {
  static get is() {
    return "vaadin-combo-box-scroller";
  }
  static get template() {
    return U`
      <style>
        :host {
          display: block;
          min-height: 1px;
          overflow: auto;

          /* Fixes item background from getting on top of scrollbars on Safari */
          transform: translate3d(0, 0, 0);

          /* Enable momentum scrolling on iOS */
          -webkit-overflow-scrolling: touch;

          /* Fixes scrollbar disappearing when 'Show scroll bars: Always' enabled in Safari */
          box-shadow: 0 0 0 white;
        }

        #selector {
          border-width: var(--_vaadin-combo-box-items-container-border-width);
          border-style: var(--_vaadin-combo-box-items-container-border-style);
          border-color: var(--_vaadin-combo-box-items-container-border-color, transparent);
          position: relative;
        }
      </style>
      <div id="selector">
        <slot></slot>
      </div>
    `;
  }
}
O(hC);
/**
 * @license
 * Copyright (c) 2015 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const fC = (i) => class extends i {
  static get properties() {
    return {
      /**
       * Number of items fetched at a time from the dataprovider.
       * @attr {number} page-size
       * @type {number}
       */
      pageSize: {
        type: Number,
        value: 50,
        observer: "_pageSizeChanged"
      },
      /**
       * Total number of items.
       * @type {number | undefined}
       */
      size: {
        type: Number,
        observer: "_sizeChanged"
      },
      /**
       * Function that provides items lazily. Receives arguments `params`, `callback`
       *
       * `params.page` Requested page index
       *
       * `params.pageSize` Current page size
       *
       * `params.filter` Currently applied filter
       *
       * `callback(items, size)` Callback function with arguments:
       *   - `items` Current page of items
       *   - `size` Total number of items.
       * @type {ComboBoxDataProvider | undefined}
       */
      dataProvider: {
        type: Object,
        observer: "_dataProviderChanged"
      },
      /** @private */
      _pendingRequests: {
        value: () => ({})
      },
      /** @private */
      __placeHolder: {
        value: new Or()
      },
      /** @private */
      __previousDataProviderFilter: {
        type: String
      }
    };
  }
  static get observers() {
    return [
      "_dataProviderFilterChanged(filter)",
      "_warnDataProviderValue(dataProvider, value)",
      "_ensureFirstPage(opened)"
    ];
  }
  /** @protected */
  ready() {
    super.ready(), this._scroller.addEventListener("index-requested", (t) => {
      const r = t.detail.index, s = t.detail.currentScrollerPos, o = Math.floor(this.pageSize * 1.5);
      if (!this._shouldSkipIndex(r, o, s) && r !== void 0) {
        const n = this._getPageForIndex(r);
        this._shouldLoadPage(n) && this._loadPage(n);
      }
    });
  }
  /** @private */
  _dataProviderFilterChanged(t) {
    if (this.__previousDataProviderFilter === void 0 && t === "") {
      this.__previousDataProviderFilter = t;
      return;
    }
    this.__previousDataProviderFilter !== t && (this.__previousDataProviderFilter = t, this._pendingRequests = {}, this.loading = this._shouldFetchData(), this.size = void 0, this.clearCache());
  }
  /** @private */
  _shouldFetchData() {
    return this.dataProvider ? this.opened || this.filter && this.filter.length : !1;
  }
  /** @private */
  _ensureFirstPage(t) {
    t && this._shouldLoadPage(0) && this._loadPage(0);
  }
  /** @private */
  _shouldSkipIndex(t, r, s) {
    return s !== 0 && t >= s - r && t <= s + r;
  }
  /** @private */
  _shouldLoadPage(t) {
    if (!this.filteredItems || this._forceNextRequest)
      return this._forceNextRequest = !1, !0;
    const r = this.filteredItems[t * this.pageSize];
    return r !== void 0 ? r instanceof Or : this.size === void 0;
  }
  /** @private */
  _loadPage(t) {
    if (this._pendingRequests[t] || !this.dataProvider)
      return;
    const r = {
      page: t,
      pageSize: this.pageSize,
      filter: this.filter
    }, s = (o, n) => {
      if (this._pendingRequests[t] !== s)
        return;
      const a = this.filteredItems ? [...this.filteredItems] : [];
      a.splice(r.page * r.pageSize, o.length, ...o), this.filteredItems = a, !this.opened && !this._isInputFocused() && this._commitValue(), n !== void 0 && (this.size = n), delete this._pendingRequests[t], Object.keys(this._pendingRequests).length === 0 && (this.loading = !1);
    };
    this._pendingRequests[t] = s, this.loading = !0, this.dataProvider(r, s);
  }
  /** @private */
  _getPageForIndex(t) {
    return Math.floor(t / this.pageSize);
  }
  /**
   * Clears the cached pages and reloads data from dataprovider when needed.
   */
  clearCache() {
    if (!this.dataProvider)
      return;
    this._pendingRequests = {};
    const t = [];
    for (let r = 0; r < (this.size || 0); r++)
      t.push(this.__placeHolder);
    this.filteredItems = t, this._shouldFetchData() ? (this._forceNextRequest = !1, this._loadPage(0)) : this._forceNextRequest = !0;
  }
  /** @private */
  _sizeChanged(t = 0) {
    const r = (this.filteredItems || []).slice(0, t);
    for (let s = 0; s < t; s++)
      r[s] = r[s] !== void 0 ? r[s] : this.__placeHolder;
    this.filteredItems = r, this._flushPendingRequests(t);
  }
  /** @private */
  _pageSizeChanged(t, r) {
    if (Math.floor(t) !== t || t < 1)
      throw this.pageSize = r, new Error("`pageSize` value must be an integer > 0");
    this.clearCache();
  }
  /** @private */
  _dataProviderChanged(t, r) {
    this._ensureItemsOrDataProvider(() => {
      this.dataProvider = r;
    }), this.clearCache();
  }
  /** @private */
  _ensureItemsOrDataProvider(t) {
    if (this.items !== void 0 && this.dataProvider !== void 0)
      throw t(), new Error("Using `items` and `dataProvider` together is not supported");
    this.dataProvider && !this.filteredItems && (this.filteredItems = []);
  }
  /** @private */
  _warnDataProviderValue(t, r) {
    if (t && r !== "" && (this.selectedItem === void 0 || this.selectedItem === null)) {
      const s = this.__getItemIndexByValue(this.filteredItems, r);
      s < 0 || this._getItemLabel(this.filteredItems[s]);
    }
  }
  /**
   * This method cleans up the page callbacks which refers to the
   * non-existing pages, i.e. which item indexes are greater than the
   * changed size.
   * This case is basically happens when:
   * 1. Users scroll fast to the bottom and combo box generates the
   * redundant page request/callback
   * 2. Server side uses undefined size lazy loading and suddenly reaches
   * the exact size which is on the range edge
   * (for default page size = 50, it will be 100, 200, 300, ...).
   * @param size the new size of items
   * @private
   */
  _flushPendingRequests(t) {
    if (this._pendingRequests) {
      const r = Math.ceil(t / this.pageSize);
      Object.entries(this._pendingRequests).forEach(([s, o]) => {
        parseInt(s) >= r && o([], t);
      });
    }
  }
};
/**
 * @license
 * Copyright (c) 2015 - 2023 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
C("vaadin-combo-box", ji, { moduleId: "vaadin-combo-box-styles" });
class pC extends fC(
  Qf(Jf(_o(X(At(N)))))
) {
  static get is() {
    return "vaadin-combo-box";
  }
  static get template() {
    return U`
      <style>
        :host([opened]) {
          pointer-events: auto;
        }
      </style>

      <div class="vaadin-combo-box-container">
        <div part="label">
          <slot name="label"></slot>
          <span part="required-indicator" aria-hidden="true" on-click="focus"></span>
        </div>

        <vaadin-input-container
          part="input-field"
          readonly="[[readonly]]"
          disabled="[[disabled]]"
          invalid="[[invalid]]"
          theme$="[[_theme]]"
        >
          <slot name="prefix" slot="prefix"></slot>
          <slot name="input"></slot>
          <div id="clearButton" part="clear-button" slot="suffix" aria-hidden="true"></div>
          <div id="toggleButton" part="toggle-button" slot="suffix" aria-hidden="true"></div>
        </vaadin-input-container>

        <div part="helper-text">
          <slot name="helper"></slot>
        </div>

        <div part="error-message">
          <slot name="error-message"></slot>
        </div>
      </div>

      <vaadin-combo-box-overlay
        id="overlay"
        opened="[[_overlayOpened]]"
        loading$="[[loading]]"
        theme$="[[_theme]]"
        position-target="[[_positionTarget]]"
        no-vertical-overlap
        restore-focus-node="[[inputElement]]"
      ></vaadin-combo-box-overlay>

      <slot name="tooltip"></slot>
    `;
  }
  static get properties() {
    return {
      /**
       * @protected
       */
      _positionTarget: {
        type: Object
      }
    };
  }
  /**
   * Used by `InputControlMixin` as a reference to the clear button element.
   * @protected
   * @return {!HTMLElement}
   */
  get clearElement() {
    return this.$.clearButton;
  }
  /** @protected */
  ready() {
    super.ready(), this.addController(
      new Bi(this, (e) => {
        this._setInputElement(e), this._setFocusElement(e), this.stateTarget = e, this.ariaTarget = e;
      })
    ), this.addController(new Ui(this.inputElement, this._labelController)), this._tooltipController = new Et(this), this.addController(this._tooltipController), this._tooltipController.setPosition("top"), this._tooltipController.setAriaTarget(this.inputElement), this._tooltipController.setShouldShow((e) => !e.opened), this._positionTarget = this.shadowRoot.querySelector('[part="input-field"]'), this._toggleElement = this.$.toggleButton;
  }
  /**
   * Override the method from `InputControlMixin`
   * to stop event propagation to prevent `ComboBoxMixin`
   * from handling this click event also on its own.
   *
   * @param {Event} event
   * @protected
   * @override
   */
  _onClearButtonClick(e) {
    e.stopPropagation(), super._onClearButtonClick(e);
  }
  /**
   * @param {Event} event
   * @protected
   */
  _onHostClick(e) {
    const t = e.composedPath();
    (t.includes(this._labelNode) || t.includes(this._positionTarget)) && super._onHostClick(e);
  }
}
O(pC);
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const mC = `.col-bg-body-lighter{background-color:var(--ui-col-bg-body-lighter, var(--col-bg-body-lighter))}.col-bg-body{background-color:var(--ui-col-bg-body, var(--col-bg-body))}.col-bg-body-darker{background-color:var(--ui-col-bg-body-darker, var(--col-bg-body-darker))}.col-bg-1-lighter{background-color:var(--ui-col-bg-1-lighter, var(--col-bg-1-lighter))}.col-bg-1{background-color:var(--ui-col-bg-1, var(--ui-col-bg-1, var(--col-bg-1)))}.col-bg-1-darker{background-color:var(--ui-col-bg-1-darker, var(--col-bg-1-darker))}.col-bg-1-input{background-color:var(--ui-col-bg-1-input, var(--col-bg-1-input))}.col-primary-bg-1{background-color:var(--ui-col-primary-bg-1, var(--col-primary-bg-1))}.col-accent-bg-1{background-color:var(--ui-col-accent-bg-1, var(--col-accent-bg-1))}.col-success-bg-1{background-color:var(--ui-col-success-bg-1, var(--col-success-bg-1))}.col-warning-bg-1{background-color:var(--ui-col-warning-bg-1, var(--col-warning-bg-1))}.col-error-bg-1{background-color:var(--ui-col-error-bg-1, var(--col-error-bg-1))}.col-bg-2-lighter{background-color:var(--ui-col-bg-2-lighter, var(--col-bg-2-lighter))}.col-bg-2{background-color:var(--ui-col-bg-2, var(--col-bg-2))}.col-bg-2-darker{background-color:var(--ui-col-bg-2-darker, var(--col-bg-2-darker))}.col-bg-2-button{background-color:var(--ui-col-bg-2-button, var(--col-bg-2-button))}.col-bg-2-input{background-color:var(--ui-col-bg-2-input, var(--col-bg-2-input))}.col-primary-bg-2{background-color:var(--ui-col-primary-bg-2, var(--col-primary-bg-2))}.col-accent-bg-2{background-color:var(--ui-col-accent-bg-2, var(--col-accent-bg-2))}.col-success-bg-2{background-color:var(--ui-col-success-bg-2, var(--col-success-bg-2))}.col-warning-bg-2{background-color:var(--ui-col-warning-bg-2, var(--col-warning-bg-2))}.col-error-bg-2{background-color:var(--ui-col-error-bg-2, var(--col-error-bg-2))}.col-bg-3-lighter{background-color:var(--ui-col-bg-3-lighter, var(--col-bg-3-lighter))}.col-bg-3{background-color:var(--ui-col-bg-3, var(--col-bg-3))}.col-bg-3-darker{background-color:var(--ui-col-bg-3-darker, var(--col-bg-3-darker))}.col-bg-3-button{background-color:var(--ui-col-bg-3-button, var(--col-bg-3-button))}.col-bg-3-input{background-color:var(--ui-col-bg-3-input, var(--col-bg-3-input))}.col-primary-bg-3{background-color:var(--ui-col-primary-bg-3, var(--col-primary-bg-3))}.col-accent-bg-3{background-color:var(--ui-col-accent-bg-3, var(--col-accent-bg-3))}.col-success-bg-3{background-color:var(--ui-col-success-bg-3, var(--col-success-bg-3))}.col-warning-bg-3{background-color:var(--ui-col-warning-bg-3, var(--col-warning-bg-3))}.col-error-bg-3{background-color:var(--ui-col-error-bg-3, var(--col-error-bg-3))}.col-bg-ack-lighter{background-color:var(--ui-col-bg-ack-lighter, var(--col-bg-ack-lighter))}.col-bg-ack{background-color:var(--ui-col-bg-ack, var(--col-bg-ack))}.col-bg-ack-darker{background-color:var(--ui-col-bg-ack-darker, var(--col-bg-ack-darker))}.col-primary-bg-ack{background-color:var(--ui-col-primary-bg-ack, var(--col-primary-bg-ack))}.col-accent-bg-ack{background-color:var(--ui-col-accent-bg-ack, var(--col-accent-bg-ack))}.col-bg-att-lighter{background-color:var(--ui-col-bg-att-lighter, var(--col-bg-att-lighter))}.col-bg-att{background-color:var(--ui-col-bg-att, var(--col-bg-att))}.col-bg-att-darker{background-color:var(--ui-col-bg-att-darker, var(--col-bg-att-darker))}.col-primary-bg-att{background-color:var(--ui-col-primary-bg-att, var(--col-primary-bg-att))}.col-accent-bg-att{background-color:var(--ui-col-accent-bg-att, var(--col-accent-bg-att))}.col-bg-alert-lighter{background-color:var(--ui-col-bg-alert-lighter, var(--col-bg-alert-lighter))}.col-bg-alert{background-color:var(--ui-col-bg-alert, var(--col-bg-alert))}.col-bg-alert-darker{background-color:var(--ui-col-bg-alert-darker, var(--col-bg-alert-darker))}.col-primary-bg-alert{background-color:var(--ui-col-primary-bg-alert, var(--col-primary-bg-alert))}.col-accent-bg-alert{background-color:var(--ui-col-accent-bg-alert, var(--col-accent-bg-alert))}.col-bg-btn-lighter{background-color:var(--ui-col-bg-btn-lighter, var(--col-bg-btn-lighter))}.col-bg-btn{background-color:var(--ui-col-bg-btn, var(--col-bg-btn))}.col-bg-btn-darker{background-color:var(--ui-col-bg-btn-darker, var(--col-bg-btn-darker))}.col-primary-bg-btn{background-color:var(--ui-col-primary-bg-btn, var(--col-primary-bg-btn))}.col-accent-bg-btn{background-color:var(--ui-col-accent-bg-btn, var(--col-accent-bg-btn))}.pattern-diagonal-stripes-sm{background:repeating-linear-gradient(45deg,transparent,transparent 10px,currentColor 10px,currentColor 20px)}.pattern-dots-lg{background-image:radial-gradient(currentColor 1.5px,transparent 1.5px);background-size:15px 15px}.pattern-dots-md{background-image:radial-gradient(currentColor 1px,transparent 1px);background-size:8px 8px}.pattern-dots-medium-dense{background-image:radial-gradient(currentColor .5px,transparent .5px);background-size:3px 3px}.pattern-dots-sm{background-image:radial-gradient(currentColor .5px,transparent .5px);background-size:5px 5px}.pattern-cross-dots-md,.imagelist-background{background-image:radial-gradient(currentColor .7px,transparent 1px),radial-gradient(currentColor .7px,transparent 1px);background-size:6.5px 6.5px;background-position:0 0,3.5px 3.5px}.imagelist-background{background-color:#fff9;background-blend-mode:overlay}:host{box-sizing:border-box;background-color:var(--ui-col-bg-1, var(--ui-col-bg-1, var(--col-bg-1)))}*:not(textarea){-webkit-touch-callout:none;-webkit-user-select:none;-khtml-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}html{font-family:var(--ui-standard-text-font, var(--standard-text-font));font-size:var(--ui-font-size-standard, var(--font-size-standard, 1rem));line-height:var(--ui-line-height-std, var(--line-height-std, 1.5em))}body{height:100%;width:100%}body a{text-decoration:none}label{font-family:var(--ui-monospace-font, var(--monospace-font));font-size:.9em}input,select,textarea{-webkit-user-select:text;-moz-user-select:text;-ms-user-select:text;box-sizing:border-box;border-radius:0;user-select:text;font-family:var(--ui-standard-text-font, var(--standard-text-font));background-color:var(--ui-col-bg-1-input, var(--col-bg-1-input));border:none;height:30px;color:var(--ui-col-primary-bg-1, var(--col-primary-bg-1));padding:var(--ui-input-padding, var(--input-padding, 4px))}input:focus,select:focus,textarea:focus{outline:none}input:focus,select:focus,textarea:focus{border-bottom:2px solid rgb(0,0,0)}h1{font-size:var(--ui-font-size-h1, var(--font-size-h1))}h2{font-size:var(--ui-font-size-h2, var(--font-size-h2))}h3{font-size:var(--ui-font-size-h3, var(--font-size-h3))}h4{font-size:var(--ui-font-size-h4, var(--font-size-h4))}small,.font-small{font-size:var(--ui-font-size-small, var(--font-size-small))}button{width:var(--ui-button-width, 60px);height:var(--ui-button-height, 60px);border-radius:calc(var(--ui-button-height, 60px) / 2);border-style:solid;border-width:2px;background-color:var(--ui-col-bg-btn, var(--col-bg-btn));color:var(--ui-col-primary-bg-btn, var(--col-primary-bg-btn));border-color:var(--ui-col-bg-btn-darker, var(--col-bg-btn-darker));font-family:var(--ui-headline-text-font, var(--headline-text-font));font-size:var(--ui-font-size-h4, var(--font-size-h4));font-weight:700}button:hover,button:focus{outline:none;background-color:var(--ui-col-bg-btn-lighter, var(--col-bg-btn-lighter))}button:active{padding-top:3px;color:var(--ui-col-primary-bg-btn, var(--col-primary-bg-btn));background-color:var(--ui-col-bg-btn-darker, var(--col-bg-btn-darker));border-color:var(--ui-col-bg-btn-darker, var(--col-bg-btn-darker))}button:disabled{opacity:.3}.modal-round-button,.modal-delete,.modal-close,.modal-cancel,.modal-back,.modal-next,.modal-ok,.modal-button{box-sizing:border-box;margin-left:25px;background-image:none;display:inline-block;font-style:normal;font-variant:normal;text-rendering:auto;-webkit-font-smoothing:antialiased;font-family:"Font Awesome 6 Free";font-weight:900;font-size:var(--ui-button-font-size, 24px);line-height:var(--ui-button-font-size, 24px);vertical-align:center;text-align:center}.modal-ok:after{content:var(--icon-bt-ok)}.modal-next:after{padding-left:2px;content:var(--icon-bt-next)}.modal-back:after{padding-right:2px;content:var(--icon-bt-back)}.modal-cancel:after{content:var(--icon-bt-cancel)}.modal-close:before{content:var(--icon-bt-close)}.modal-delete{background-color:var(--ui-col-bg-alert, var(--col-bg-alert));color:var(--ui-col-primary-bg-alert, var(--col-primary-bg-alert))}.modal-delete:before{content:var(--icon-bt-trash)}.modal-delete:hover,.modal-delete:focus{border-color:var(--ui-col-bg-alert, var(--col-bg-alert));background-color:var(--ui-col-bg-alert-lighter, var(--col-bg-alert-lighter));background-size:75%}.modal-delete:active{border-color:var(--ui-col-bg-alert, var(--col-bg-alert));background-color:var(--ui-col-bg-alert-darker, var(--col-bg-alert-darker));color:var(--ui-col-primary-bg-alert, var(--col-primary-bg-alert))}:host{display:block;padding:2px;box-sizing:border-box;background-color:var(--ui-col-bg-body, var(--col-bg-body))}div,p{font-family:var(--ui-standard-text-font, var(--standard-text-font));box-sizing:border-box}.placeholder{width:64px;height:64px;display:flex;justify-content:center;align-items:center}.placeholder i{font-size:2em}img{object-fit:contain}.fa,.fas{font-family:"Font Awesome 6 Free";font-weight:900;font-style:normal}.fa-camera:before{content:""}
`;
var gC = Object.defineProperty, _C = Object.getOwnPropertyDescriptor, ir = (i, e, t, r) => {
  for (var s = r > 1 ? void 0 : r ? _C(e, t) : e, o = i.length - 1, n; o >= 0; o--)
    (n = i[o]) && (s = (r ? n(e, t, s) : n(s)) || s);
  return r && s && gC(e, t, s), s;
};
let Xe = class extends _t {
  constructor() {
    super(), this.observer = void 0, this.visible = !1, this.uuid_file = "", this.resolution = "", this.description = "", this.fitContent = "contain", this.url = "", this.observerCallback = this.observerCallback.bind(this);
  }
  // get visible() {
  //     return (this._visible)
  // }
  //
  // set visible(value: boolean) {
  //     if (value !== this._visible) {
  //         this._visible = value
  //         this.load_image()
  //     }
  // }
  connectedCallback() {
    super.connectedCallback(), this.setAttribute("role", "presentation"), this.initIntersectionObserver();
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.disconnectObserver();
  }
  /**
   * Sets the `intersecting` property when the element is on screen.
   * @param  {[IntersectionObserverEntry]} entries
   * @protected
   */
  observerCallback(i) {
    const e = ({ isIntersecting: t }) => t;
    i.some(e) && (this.visible = !0);
  }
  /**
   * Initializes the IntersectionObserver when the element instantiates.
   * @protected
   */
  initIntersectionObserver() {
    if (!("IntersectionObserver" in window))
      return this.visible = !0;
    if (this.observer)
      return;
    const i = "10px";
    this.observer = new IntersectionObserver(this.observerCallback, { rootMargin: i }), this.observer.observe(this);
  }
  /**
   * Disconnects and unloads the IntersectionObserver.
   * @protected
   */
  disconnectObserver() {
    var i;
    (i = this.observer) == null || i.disconnect(), delete this.observer, this.observer = void 0;
  }
  clicked() {
    this.dispatchEvent(new CustomEvent(
      "select-image",
      { bubbles: !0, composed: !0, detail: this.uuid_file }
    ));
  }
  willUpdate(i) {
    super.willUpdate(i), (i.has("uuid_file") || i.has("resolution")) && (this.url = ""), this.url || this.load_image();
  }
  firstUpdated() {
  }
  reportURL(i) {
    this.url = i;
  }
  fetch_image() {
    this.url = "";
    const i = {
      uuid: this.uuid_file,
      resolution: this.resolution,
      reportURL: this.reportURL.bind(this)
    }, e = new CustomEvent(
      "fetchfile",
      { detail: i, bubbles: !1, composed: !0, cancelable: !1 }
    );
    this.dispatchEvent(e);
  }
  load_image() {
    this.resolution && this.uuid_file && this.visible && this.fetch_image();
  }
  render_image() {
    let i = "";
    switch (this.fitContent) {
      case "fit":
        i = "object-fit: scale-down;max-width:100%";
        break;
      case "scale":
        i = "height: 100%;width:100%";
        break;
      default:
        i = "object-fit: contain";
    }
    return this.visible ? p`
            <img style="${i}" 
                 @click="${this.clicked}" src="${this.url}" 
                 alt="${this.description}"/>` : b;
  }
  render_placeholder() {
    return this.visible ? p`
            <div class="placeholder"><i class="fa fa-camera"></i></div>` : b;
  }
  render() {
    return p`
                    ${this.url ? this.render_image() : this.render_placeholder()}
                    </div>`;
  }
};
Xe.styles = tt(mC);
ir([
  z()
], Xe.prototype, "visible", 2);
ir([
  G()
], Xe.prototype, "uuid_file", 2);
ir([
  G()
], Xe.prototype, "resolution", 2);
ir([
  G()
], Xe.prototype, "description", 2);
ir([
  G()
], Xe.prototype, "fitContent", 2);
ir([
  G()
], Xe.prototype, "url", 2);
Xe = ir([
  Qt("file-view")
], Xe);
const bC = `.col-bg-body-lighter{background-color:var(--ui-col-bg-body-lighter, var(--col-bg-body-lighter))}.col-bg-body{background-color:var(--ui-col-bg-body, var(--col-bg-body))}.col-bg-body-darker{background-color:var(--ui-col-bg-body-darker, var(--col-bg-body-darker))}.col-bg-1-lighter{background-color:var(--ui-col-bg-1-lighter, var(--col-bg-1-lighter))}.col-bg-1{background-color:var(--ui-col-bg-1, var(--ui-col-bg-1, var(--col-bg-1)))}.col-bg-1-darker{background-color:var(--ui-col-bg-1-darker, var(--col-bg-1-darker))}.col-bg-1-input{background-color:var(--ui-col-bg-1-input, var(--col-bg-1-input))}.col-primary-bg-1{background-color:var(--ui-col-primary-bg-1, var(--col-primary-bg-1))}.col-accent-bg-1{background-color:var(--ui-col-accent-bg-1, var(--col-accent-bg-1))}.col-success-bg-1{background-color:var(--ui-col-success-bg-1, var(--col-success-bg-1))}.col-warning-bg-1{background-color:var(--ui-col-warning-bg-1, var(--col-warning-bg-1))}.col-error-bg-1{background-color:var(--ui-col-error-bg-1, var(--col-error-bg-1))}.col-bg-2-lighter{background-color:var(--ui-col-bg-2-lighter, var(--col-bg-2-lighter))}.col-bg-2{background-color:var(--ui-col-bg-2, var(--col-bg-2))}.col-bg-2-darker{background-color:var(--ui-col-bg-2-darker, var(--col-bg-2-darker))}.col-bg-2-button{background-color:var(--ui-col-bg-2-button, var(--col-bg-2-button))}.col-bg-2-input{background-color:var(--ui-col-bg-2-input, var(--col-bg-2-input))}.col-primary-bg-2{background-color:var(--ui-col-primary-bg-2, var(--col-primary-bg-2))}.col-accent-bg-2{background-color:var(--ui-col-accent-bg-2, var(--col-accent-bg-2))}.col-success-bg-2{background-color:var(--ui-col-success-bg-2, var(--col-success-bg-2))}.col-warning-bg-2{background-color:var(--ui-col-warning-bg-2, var(--col-warning-bg-2))}.col-error-bg-2{background-color:var(--ui-col-error-bg-2, var(--col-error-bg-2))}.col-bg-3-lighter{background-color:var(--ui-col-bg-3-lighter, var(--col-bg-3-lighter))}.col-bg-3{background-color:var(--ui-col-bg-3, var(--col-bg-3))}.col-bg-3-darker{background-color:var(--ui-col-bg-3-darker, var(--col-bg-3-darker))}.col-bg-3-button{background-color:var(--ui-col-bg-3-button, var(--col-bg-3-button))}.col-bg-3-input{background-color:var(--ui-col-bg-3-input, var(--col-bg-3-input))}.col-primary-bg-3{background-color:var(--ui-col-primary-bg-3, var(--col-primary-bg-3))}.col-accent-bg-3{background-color:var(--ui-col-accent-bg-3, var(--col-accent-bg-3))}.col-success-bg-3{background-color:var(--ui-col-success-bg-3, var(--col-success-bg-3))}.col-warning-bg-3{background-color:var(--ui-col-warning-bg-3, var(--col-warning-bg-3))}.col-error-bg-3{background-color:var(--ui-col-error-bg-3, var(--col-error-bg-3))}.col-bg-ack-lighter{background-color:var(--ui-col-bg-ack-lighter, var(--col-bg-ack-lighter))}.col-bg-ack{background-color:var(--ui-col-bg-ack, var(--col-bg-ack))}.col-bg-ack-darker{background-color:var(--ui-col-bg-ack-darker, var(--col-bg-ack-darker))}.col-primary-bg-ack{background-color:var(--ui-col-primary-bg-ack, var(--col-primary-bg-ack))}.col-accent-bg-ack{background-color:var(--ui-col-accent-bg-ack, var(--col-accent-bg-ack))}.col-bg-att-lighter{background-color:var(--ui-col-bg-att-lighter, var(--col-bg-att-lighter))}.col-bg-att{background-color:var(--ui-col-bg-att, var(--col-bg-att))}.col-bg-att-darker{background-color:var(--ui-col-bg-att-darker, var(--col-bg-att-darker))}.col-primary-bg-att{background-color:var(--ui-col-primary-bg-att, var(--col-primary-bg-att))}.col-accent-bg-att{background-color:var(--ui-col-accent-bg-att, var(--col-accent-bg-att))}.col-bg-alert-lighter{background-color:var(--ui-col-bg-alert-lighter, var(--col-bg-alert-lighter))}.col-bg-alert{background-color:var(--ui-col-bg-alert, var(--col-bg-alert))}.col-bg-alert-darker{background-color:var(--ui-col-bg-alert-darker, var(--col-bg-alert-darker))}.col-primary-bg-alert{background-color:var(--ui-col-primary-bg-alert, var(--col-primary-bg-alert))}.col-accent-bg-alert{background-color:var(--ui-col-accent-bg-alert, var(--col-accent-bg-alert))}.col-bg-btn-lighter{background-color:var(--ui-col-bg-btn-lighter, var(--col-bg-btn-lighter))}.col-bg-btn{background-color:var(--ui-col-bg-btn, var(--col-bg-btn))}.col-bg-btn-darker{background-color:var(--ui-col-bg-btn-darker, var(--col-bg-btn-darker))}.col-primary-bg-btn{background-color:var(--ui-col-primary-bg-btn, var(--col-primary-bg-btn))}.col-accent-bg-btn{background-color:var(--ui-col-accent-bg-btn, var(--col-accent-bg-btn))}.pattern-diagonal-stripes-sm{background:repeating-linear-gradient(45deg,transparent,transparent 10px,currentColor 10px,currentColor 20px)}.pattern-dots-lg{background-image:radial-gradient(currentColor 1.5px,transparent 1.5px);background-size:15px 15px}.pattern-dots-md{background-image:radial-gradient(currentColor 1px,transparent 1px);background-size:8px 8px}.pattern-dots-medium-dense{background-image:radial-gradient(currentColor .5px,transparent .5px);background-size:3px 3px}.pattern-dots-sm{background-image:radial-gradient(currentColor .5px,transparent .5px);background-size:5px 5px}.pattern-cross-dots-md,.imagelist-background{background-image:radial-gradient(currentColor .7px,transparent 1px),radial-gradient(currentColor .7px,transparent 1px);background-size:6.5px 6.5px;background-position:0 0,3.5px 3.5px}.imagelist-background{background-color:#fff9;background-blend-mode:overlay}:host{box-sizing:border-box;background-color:var(--ui-col-bg-1, var(--ui-col-bg-1, var(--col-bg-1)))}*:not(textarea){-webkit-touch-callout:none;-webkit-user-select:none;-khtml-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}html{font-family:var(--ui-standard-text-font, var(--standard-text-font));font-size:var(--ui-font-size-standard, var(--font-size-standard, 1rem));line-height:var(--ui-line-height-std, var(--line-height-std, 1.5em))}body{height:100%;width:100%}body a{text-decoration:none}label{font-family:var(--ui-monospace-font, var(--monospace-font));font-size:.9em}input,select,textarea{-webkit-user-select:text;-moz-user-select:text;-ms-user-select:text;box-sizing:border-box;border-radius:0;user-select:text;font-family:var(--ui-standard-text-font, var(--standard-text-font));background-color:var(--ui-col-bg-1-input, var(--col-bg-1-input));border:none;height:30px;color:var(--ui-col-primary-bg-1, var(--col-primary-bg-1));padding:var(--ui-input-padding, var(--input-padding, 4px))}input:focus,select:focus,textarea:focus{outline:none}input:focus,select:focus,textarea:focus{border-bottom:2px solid rgb(0,0,0)}h1{font-size:var(--ui-font-size-h1, var(--font-size-h1))}h2{font-size:var(--ui-font-size-h2, var(--font-size-h2))}h3{font-size:var(--ui-font-size-h3, var(--font-size-h3))}h4{font-size:var(--ui-font-size-h4, var(--font-size-h4))}small,.font-small{font-size:var(--ui-font-size-small, var(--font-size-small))}button{width:var(--ui-button-width, 60px);height:var(--ui-button-height, 60px);border-radius:calc(var(--ui-button-height, 60px) / 2);border-style:solid;border-width:2px;background-color:var(--ui-col-bg-btn, var(--col-bg-btn));color:var(--ui-col-primary-bg-btn, var(--col-primary-bg-btn));border-color:var(--ui-col-bg-btn-darker, var(--col-bg-btn-darker));font-family:var(--ui-headline-text-font, var(--headline-text-font));font-size:var(--ui-font-size-h4, var(--font-size-h4));font-weight:700}button:hover,button:focus{outline:none;background-color:var(--ui-col-bg-btn-lighter, var(--col-bg-btn-lighter))}button:active{padding-top:3px;color:var(--ui-col-primary-bg-btn, var(--col-primary-bg-btn));background-color:var(--ui-col-bg-btn-darker, var(--col-bg-btn-darker));border-color:var(--ui-col-bg-btn-darker, var(--col-bg-btn-darker))}button:disabled{opacity:.3}.modal-round-button,.modal-delete,.modal-close,.modal-cancel,.modal-back,.modal-next,.modal-ok,.modal-button{box-sizing:border-box;margin-left:25px;background-image:none;display:inline-block;font-style:normal;font-variant:normal;text-rendering:auto;-webkit-font-smoothing:antialiased;font-family:"Font Awesome 6 Free";font-weight:900;font-size:var(--ui-button-font-size, 24px);line-height:var(--ui-button-font-size, 24px);vertical-align:center;text-align:center}.modal-ok:after{content:var(--icon-bt-ok)}.modal-next:after{padding-left:2px;content:var(--icon-bt-next)}.modal-back:after{padding-right:2px;content:var(--icon-bt-back)}.modal-cancel:after{content:var(--icon-bt-cancel)}.modal-close:before{content:var(--icon-bt-close)}.modal-delete{background-color:var(--ui-col-bg-alert, var(--col-bg-alert));color:var(--ui-col-primary-bg-alert, var(--col-primary-bg-alert))}.modal-delete:before{content:var(--icon-bt-trash)}.modal-delete:hover,.modal-delete:focus{border-color:var(--ui-col-bg-alert, var(--col-bg-alert));background-color:var(--ui-col-bg-alert-lighter, var(--col-bg-alert-lighter));background-size:75%}.modal-delete:active{border-color:var(--ui-col-bg-alert, var(--col-bg-alert));background-color:var(--ui-col-bg-alert-darker, var(--col-bg-alert-darker));color:var(--ui-col-primary-bg-alert, var(--col-primary-bg-alert))}*{box-sizing:border-box}:host{--lumo-contrast-10pct: rgba(0,0,0,0);--lumo-contrast-60pct: var(--col-accent-bg-1);--lumo-text-field-size: 1em;--lumo-font-size: var(--font-size-standard);--lumo-font-family: var(--standard-text-font);width:100%}.developer-info{background-color:#006400;color:#ffffe0;font-size:.7em;display:inline-block;word-wrap:anywhere}.uicomponent-version{position:absolute;transform:translate(-40px);background-color:#00960066;color:#fff;font-family:var(--ui-standard-text-font, var(--standard-text-font));padding:.2em .5em;left:auto;right:0;z-index:10;box-shadow:#0000003d 0 3px 8px}i{font-family:"Font Awesome 6 Free";font-style:normal;font-variant:normal;text-rendering:auto;-webkit-font-smoothing:antialiased;font-weight:900;font-size:.9em}input,textarea{font-size:var(--ui-font-size-standard, var(--font-size-standard, 1rem));width:100%}.input-right-align{text-align:right}.ui-layout,.ui-table-layout,.ui-right-align-layout,.ui-stack-layout,.ui-column-layout{background-color:var(--ui-col-bg-1, var(--ui-col-bg-1, var(--col-bg-1)))}.ui-column-layout{display:grid;grid-template-columns:repeat(auto-fill,minmax(200px,max-content));align-items:end;grid-row-gap:1em}.ui-stack-layout{display:flex;flex-direction:column}.ui-right-align-layout{display:flex;flex-direction:row;justify-content:end}.ui-line{width:100%;height:1px;margin-top:1em;margin-bottom:1em;border-top:solid 1px var(--ui-col-accent-bg-1, var(--col-accent-bg-1))}.ui-line-transparent{height:0px;opacity:0;margin:0;border:none}.element-wrapper{padding:5px}.element-wrapper.new-line{grid-column-start:1}.templateLabel{height:30px;line-height:30px;vertical-align:middle}.light-background{background-color:var(--ui-col-bg-1-lighter, var(--col-bg-1-lighter))}.text-field-div,.combobox-div{margin-left:.5em;margin-right:.5em}.identifier-link{text-decoration:underline;text-decoration-style:dotted;cursor:pointer}.footsteps{transform:rotate(270deg);display:inline-block;margin-right:.5em}.ui-field,.text-field-div,.combobox-div,.read-only-textarea,.read-only-image,.table-header,.text-cell{font-family:var(--ui-standard-text-font, var(--standard-text-font));font-size:var(--ui-font-size-standard, var(--font-size-standard, 1rem));color:var(--ui-col-primary-bg-1, var(--col-primary-bg-1))}.ui-field input:disabled,.text-field-div input:disabled,.combobox-div input:disabled,.read-only-textarea input:disabled,.read-only-image input:disabled,.table-header input:disabled,.text-cell input:disabled,.ui-field textarea:disabled,.text-field-div textarea:disabled,.combobox-div textarea:disabled,.read-only-textarea textarea:disabled,.read-only-image textarea:disabled,.table-header textarea:disabled,.text-cell textarea:disabled{background-color:var(--ui-col-bg-1-lighter, var(--col-bg-1-lighter));color:var(--ui-col-primary-bg-1, var(--col-primary-bg-1))}.text-cell{display:table-cell;background-color:var(--ui-col-bg-1-lighter, var(--col-bg-1-lighter))}table{display:table;table-layout:fixed;border-collapse:collapse;overflow-y:inherit;width:100%}thead tr{position:relative;z-index:1}.table-header{display:table-cell;text-align:left;background-color:var(--ui-col-bg-1-darker, var(--col-bg-1-darker));color:var(--ui-col-accent-bg-1, var(--col-accent-bg-1));padding:var(--ui-input-padding, var(--input-padding, 4px));font-family:var(--ui-monospace-font, var(--monospace-font));font-weight:400;flex-direction:row}th{position:sticky;top:0}.table-header-icon,.table-header-icon-secondary{text-align:center;background-color:var(--ui-col-bg-1-lighter, var(--col-bg-1-lighter));color:var(--ui-col-accent-bg-1, var(--col-accent-bg-1));padding:2px 4px}.table-header-icon-secondary{background-color:var(--ui-col-bg-1-darker, var(--col-bg-1-darker));color:var(--ui-col-primary-bg-1, var(--col-primary-bg-1));opacity:.5}td{border:1px solid var(--ui-col-bg-1-darker, var(--col-bg-1-darker))}td input,td textarea{width:100%}.text-field-div,.combobox-div,.read-only-textarea,.read-only-image{display:flex;flex-direction:column}.text-field-div textarea,.combobox-div textarea,.read-only-textarea textarea,.read-only-image textarea{min-height:5em}.read-only-textarea,.read-only-image{background-color:var(--ui-col-bg-1-lighter, var(--col-bg-1-lighter));color:var(--ui-col-primary-bg-1, var(--col-primary-bg-1));min-height:30px;overflow-y:auto;padding:var(--ui-input-padding, var(--input-padding, 4px))}.multiline-textarea{white-space:pre-wrap}.read-only-image{display:flex}.image-center{margin:auto;overflow:auto}.image-left-align{margin:0;overflow:auto}.file-element-description{text-align:center;white-space:pre-wrap}.combobox-div{margin-bottom:0}vaadin-date-picker{padding:0}vaadin-date-picker,vaadin-time-picker,vaadin-combo-box{margin-left:calc(-1 * (.375em + var(--lumo-border-radius-m) / 4 - 1px));margin-right:calc(-1 * (.375em + var(--lumo-border-radius-m) / 4 - 1px));padding-top:0}vaadin-date-picker>input,vaadin-time-picker>input,vaadin-combo-box>input{--_lumo-text-field-overflow-mask-image: white;--lumo-text-field-size: 22px;background-color:#fff;max-height:30px}vaadin-date-picker>input:disabled,vaadin-time-picker>input:disabled,vaadin-combo-box>input:disabled{background-color:var(--ui-col-bg-1-lighter, var(--col-bg-1-lighter));--lumo-disabled-text-color: $col-primary-bg-1}.ui-gallery-layout{display:grid;width:100%;height:100%;background-color:var(--ui-col-bg-body, var(--col-bg-body));grid-template-columns:repeat(auto-fill,minmax(200px,max-content))}.gallery-item{display:flex;flex-direction:column;box-shadow:3px 3px 6px #c8c8c8;box-sizing:content-box;border-radius:10px;margin-right:12px;margin-bottom:20px}.gallery-item .read-only-image{background:none}
`;
class Co {
  constructor(e, t) {
    this._id = "?", this.renderElementLabels = !0, this._id = e, this.layoutSettings = t;
  }
  requestUpdate() {
    this.onRequestUpdate && this.onRequestUpdate();
  }
  get defaultElementVisibility() {
    var e;
    return ((e = this.layoutSettings) == null ? void 0 : e.default_element_visibility) == null || this.layoutSettings.default_element_visibility === "true" || this.layoutSettings.default_element_visibility == !0 ? !0 : this.layoutSettings.default_element_visibility === "false" || this.layoutSettings.default_element_visibility == !1 ? !1 : this.layoutSettings.default_element_visibility;
  }
  renderLayout(e, t, r, s) {
    const o = e.entry, n = this.getOrderedElements(o).map((a) => s(a, o.ui_elements[a], t));
    return p`
            <div class="${this.cssClass}" style="${r}">
                ${n}
            </div>
        `;
  }
  renderElement(e, t) {
    return p`
            <div class="text-field-div" style="${this.renderLayoutStyles(e)}">
                ${t}
            </div>
        `;
  }
  getOrderedElements(e) {
    var t;
    try {
      if ((t = e.layout_settings) != null && t.order) {
        const r = [...Object.keys(e.ui_elements)], s = [...e.layout_settings.order], o = [];
        for (const a of s)
          if (a === "...")
            o.push("...");
          else {
            let l = r.findIndex((c) => c === a);
            l > -1 && (o.push(r[l]), r.splice(l, 1));
          }
        let n = o.findIndex((a) => a === "...");
        return n > -1 && o.splice(n, 1, ...r), o;
      } else
        return Object.keys(e.ui_elements);
    } catch (r) {
      throw `UILayoutClass.getOrderedElements for layout ${this._id}: ${r}`;
    }
  }
}
class rp extends Co {
  constructor() {
    super(...arguments), this._sortOrder = [];
  }
  _initSorting(e) {
    if (e.uicomponent && e.uicomponent.setSortOrder) {
      let t = e.entry.layout_settings;
      t && this._sortOrder.length == 0 && (this._sortOrder = t.order_records_by || []), this._sortOrder.length > 0 && e.uicomponent.setSortOrder(this._sortOrder);
    }
  }
}
class pn extends Co {
  constructor() {
    super(...arguments), this.cssClass = "ui-column-layout";
  }
  renderLayoutStyles(e) {
    const t = e == null ? void 0 : e.min_width;
    let r = "";
    return t && (t === "max" ? r = "grid-column: 1 / -1;" : r = `grid-column-end: span ${t}`), r;
  }
}
class yC extends Co {
  constructor() {
    super(...arguments), this.cssClass = "ui-stack-layout";
  }
  renderLayoutStyles(e) {
    const t = e == null ? void 0 : e.min_width;
    let r = "";
    return t && (t === "max" ? r = "width: 100%" : r = `width: ${t * 100}px`), r;
  }
}
class vC extends Co {
  constructor() {
    super(...arguments), this.cssClass = "ui-right-align-layout";
  }
  renderLayoutStyles() {
    return "";
  }
}
class wC extends rp {
  constructor() {
    super(...arguments), this.cssClass = "ui-table-layout", this.renderElementLabels = !1;
  }
  // @ts-ignore
  renderLayoutStyles(e) {
    return "";
  }
  headerClicked(e) {
    const t = e.currentTarget.dataset.id;
    let r = this._sortOrder.findIndex((o) => o.startsWith(">") ? o.slice(1) === t : o === t), s = !1;
    t && (r > -1 ? (s = this._sortOrder[r].startsWith(">"), r == 0 && (s = !s), r > 0 && (this._sortOrder[r] = this._sortOrder[0]), this._sortOrder[0] = s ? ">" + t : t) : this._sortOrder.splice(0, 0, t), this.requestUpdate());
  }
  renderSortButton(e) {
    const t = this._sortOrder.findIndex((r) => r.startsWith(">") ? r.slice(1) === e : r === e);
    if (t > -1) {
      const r = this._sortOrder[t], s = t == 0 ? "table-header-icon" : "table-header-icon-secondary";
      return r.startsWith(">") ? p`<span class="${s}"><i></i></span>` : p`<span class="${s}"><i></i></span>`;
    }
    return b;
  }
  renderHeaders(e, t) {
    const r = e.entry.layout_settings, s = r.allow_ordering_by || [], o = r.allow_ordering_by == null;
    return p`
            <thead>
            <tr>
            ${t.map((n) => p`
                <th class="table-header" 
                    style="${this.getTableHeaderStyle(e.entry.ui_elements[n].layout)}"
                    data-id="${n}" @click="${o || s.includes(n) ? this.headerClicked.bind(this) : b}">
                    ${this.renderSortButton(n)}
                    <span class="table-header-text">${e.haulData(e.entry.ui_elements[n].element_type.text)}</span>
                </th>
            `)}
            </tr>
            </thead>
        `;
  }
  getTableHeaderStyle(e) {
    let t = "";
    return e != null && e.min_width && String(e.min_width).indexOf("%") > -1 && (t = `width: ${e.min_width}`), t;
  }
  renderLayout(e, t, r, s) {
    const o = this.getOrderedElements(e.entry), n = [];
    for (e.resetCursor(), this._initSorting(e); e.next(); )
      n.push(p`
                <tr>
                    ${o.map((a) => s(a, e.entry.ui_elements[a], t))}
                </tr>
            `);
    return p`
            <table class="${this.cssClass}" style="${r}">
                ${this.renderHeaders(e, o)}
                <tbody>
                    ${n}
                </tbody>
            </table>
        `;
  }
  renderElement(e, t) {
    return p`
            <td class="text-cell" style="${this.renderLayoutStyles(e)}">
                ${t}
            </td>
        `;
  }
}
class xC extends rp {
  constructor() {
    super(...arguments), this.cssClass = "ui-gallery-layout", this.renderElementLabels = !1, this._sortOrder = [];
  }
  // @ts-ignore
  renderLayoutStyles(e) {
    return "";
  }
  renderLayout(e, t, r, s) {
    const o = this.getOrderedElements(e.entry), n = [];
    for (e.resetCursor(), this._initSorting(e); e.next(); )
      n.push(p`
                <div class="gallery-item">
                    ${o.map((a) => s(a, e.entry.ui_elements[a], t))}
                </div>
            `);
    return p`
            <div class="${this.cssClass}" style="${r}">
                ${n}
            </div>
        `;
  }
  renderElement(e, t) {
    return p`
            <div class="gallery-sub-item" style="${this.renderLayoutStyles(e)}">
                ${t}
            </div>
        `;
  }
}
class sr extends Error {
}
class CC extends sr {
  constructor(e) {
    super(`Invalid DateTime: ${e.toMessage()}`);
  }
}
class kC extends sr {
  constructor(e) {
    super(`Invalid Interval: ${e.toMessage()}`);
  }
}
class AC extends sr {
  constructor(e) {
    super(`Invalid Duration: ${e.toMessage()}`);
  }
}
class li extends sr {
}
class ip extends sr {
  constructor(e) {
    super(`Invalid unit ${e}`);
  }
}
class Ce extends sr {
}
class lt extends sr {
  constructor() {
    super("Zone is an abstract class");
  }
}
const _ = "numeric", He = "short", be = "long", Gs = {
  year: _,
  month: _,
  day: _
}, sp = {
  year: _,
  month: He,
  day: _
}, EC = {
  year: _,
  month: He,
  day: _,
  weekday: He
}, op = {
  year: _,
  month: be,
  day: _
}, np = {
  year: _,
  month: be,
  day: _,
  weekday: be
}, ap = {
  hour: _,
  minute: _
}, lp = {
  hour: _,
  minute: _,
  second: _
}, cp = {
  hour: _,
  minute: _,
  second: _,
  timeZoneName: He
}, dp = {
  hour: _,
  minute: _,
  second: _,
  timeZoneName: be
}, up = {
  hour: _,
  minute: _,
  hourCycle: "h23"
}, hp = {
  hour: _,
  minute: _,
  second: _,
  hourCycle: "h23"
}, fp = {
  hour: _,
  minute: _,
  second: _,
  hourCycle: "h23",
  timeZoneName: He
}, pp = {
  hour: _,
  minute: _,
  second: _,
  hourCycle: "h23",
  timeZoneName: be
}, mp = {
  year: _,
  month: _,
  day: _,
  hour: _,
  minute: _
}, gp = {
  year: _,
  month: _,
  day: _,
  hour: _,
  minute: _,
  second: _
}, _p = {
  year: _,
  month: He,
  day: _,
  hour: _,
  minute: _
}, bp = {
  year: _,
  month: He,
  day: _,
  hour: _,
  minute: _,
  second: _
}, SC = {
  year: _,
  month: He,
  day: _,
  weekday: He,
  hour: _,
  minute: _
}, yp = {
  year: _,
  month: be,
  day: _,
  hour: _,
  minute: _,
  timeZoneName: He
}, vp = {
  year: _,
  month: be,
  day: _,
  hour: _,
  minute: _,
  second: _,
  timeZoneName: He
}, wp = {
  year: _,
  month: be,
  day: _,
  weekday: be,
  hour: _,
  minute: _,
  timeZoneName: be
}, xp = {
  year: _,
  month: be,
  day: _,
  weekday: be,
  hour: _,
  minute: _,
  second: _,
  timeZoneName: be
};
class Ki {
  /**
   * The type of zone
   * @abstract
   * @type {string}
   */
  get type() {
    throw new lt();
  }
  /**
   * The name of this zone.
   * @abstract
   * @type {string}
   */
  get name() {
    throw new lt();
  }
  get ianaName() {
    return this.name;
  }
  /**
   * Returns whether the offset is known to be fixed for the whole year.
   * @abstract
   * @type {boolean}
   */
  get isUniversal() {
    throw new lt();
  }
  /**
   * Returns the offset's common name (such as EST) at the specified timestamp
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the name
   * @param {Object} opts - Options to affect the format
   * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
   * @param {string} opts.locale - What locale to return the offset name in.
   * @return {string}
   */
  offsetName(e, t) {
    throw new lt();
  }
  /**
   * Returns the offset's value as a string
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the offset
   * @param {string} format - What style of offset to return.
   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
   * @return {string}
   */
  formatOffset(e, t) {
    throw new lt();
  }
  /**
   * Return the offset in minutes for this zone at the specified timestamp.
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to compute the offset
   * @return {number}
   */
  offset(e) {
    throw new lt();
  }
  /**
   * Return whether this Zone is equal to another zone
   * @abstract
   * @param {Zone} otherZone - the zone to compare
   * @return {boolean}
   */
  equals(e) {
    throw new lt();
  }
  /**
   * Return whether this Zone is valid.
   * @abstract
   * @type {boolean}
   */
  get isValid() {
    throw new lt();
  }
}
let mn = null;
class ko extends Ki {
  /**
   * Get a singleton instance of the local zone
   * @return {SystemZone}
   */
  static get instance() {
    return mn === null && (mn = new ko()), mn;
  }
  /** @override **/
  get type() {
    return "system";
  }
  /** @override **/
  get name() {
    return new Intl.DateTimeFormat().resolvedOptions().timeZone;
  }
  /** @override **/
  get isUniversal() {
    return !1;
  }
  /** @override **/
  offsetName(e, { format: t, locale: r }) {
    return kp(e, t, r);
  }
  /** @override **/
  formatOffset(e, t) {
    return vi(this.offset(e), t);
  }
  /** @override **/
  offset(e) {
    return -new Date(e).getTimezoneOffset();
  }
  /** @override **/
  equals(e) {
    return e.type === "system";
  }
  /** @override **/
  get isValid() {
    return !0;
  }
}
let Ss = {};
function TC(i) {
  return Ss[i] || (Ss[i] = new Intl.DateTimeFormat("en-US", {
    hour12: !1,
    timeZone: i,
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
    era: "short"
  })), Ss[i];
}
const IC = {
  year: 0,
  month: 1,
  day: 2,
  era: 3,
  hour: 4,
  minute: 5,
  second: 6
};
function DC(i, e) {
  const t = i.format(e).replace(/\u200E/g, ""), r = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(t), [, s, o, n, a, l, c, d] = r;
  return [n, s, o, a, l, c, d];
}
function OC(i, e) {
  const t = i.formatToParts(e), r = [];
  for (let s = 0; s < t.length; s++) {
    const { type: o, value: n } = t[s], a = IC[o];
    o === "era" ? r[a] = n : S(a) || (r[a] = parseInt(n, 10));
  }
  return r;
}
let fs = {};
class et extends Ki {
  /**
   * @param {string} name - Zone name
   * @return {IANAZone}
   */
  static create(e) {
    return fs[e] || (fs[e] = new et(e)), fs[e];
  }
  /**
   * Reset local caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCache() {
    fs = {}, Ss = {};
  }
  /**
   * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.
   * @param {string} s - The string to check validity on
   * @example IANAZone.isValidSpecifier("America/New_York") //=> true
   * @example IANAZone.isValidSpecifier("Sport~~blorp") //=> false
   * @deprecated This method returns false for some valid IANA names. Use isValidZone instead.
   * @return {boolean}
   */
  static isValidSpecifier(e) {
    return this.isValidZone(e);
  }
  /**
   * Returns whether the provided string identifies a real zone
   * @param {string} zone - The string to check
   * @example IANAZone.isValidZone("America/New_York") //=> true
   * @example IANAZone.isValidZone("Fantasia/Castle") //=> false
   * @example IANAZone.isValidZone("Sport~~blorp") //=> false
   * @return {boolean}
   */
  static isValidZone(e) {
    if (!e)
      return !1;
    try {
      return new Intl.DateTimeFormat("en-US", { timeZone: e }).format(), !0;
    } catch {
      return !1;
    }
  }
  constructor(e) {
    super(), this.zoneName = e, this.valid = et.isValidZone(e);
  }
  /** @override **/
  get type() {
    return "iana";
  }
  /** @override **/
  get name() {
    return this.zoneName;
  }
  /** @override **/
  get isUniversal() {
    return !1;
  }
  /** @override **/
  offsetName(e, { format: t, locale: r }) {
    return kp(e, t, r, this.name);
  }
  /** @override **/
  formatOffset(e, t) {
    return vi(this.offset(e), t);
  }
  /** @override **/
  offset(e) {
    const t = new Date(e);
    if (isNaN(t))
      return NaN;
    const r = TC(this.name);
    let [s, o, n, a, l, c, d] = r.formatToParts ? OC(r, t) : DC(r, t);
    a === "BC" && (s = -Math.abs(s) + 1);
    const u = Eo({
      year: s,
      month: o,
      day: n,
      hour: l === 24 ? 0 : l,
      minute: c,
      second: d,
      millisecond: 0
    });
    let h = +t;
    const f = h % 1e3;
    return h -= f >= 0 ? f : 1e3 + f, (u - h) / (60 * 1e3);
  }
  /** @override **/
  equals(e) {
    return e.type === "iana" && e.name === this.name;
  }
  /** @override **/
  get isValid() {
    return this.valid;
  }
}
let gd = {};
function $C(i, e = {}) {
  const t = JSON.stringify([i, e]);
  let r = gd[t];
  return r || (r = new Intl.ListFormat(i, e), gd[t] = r), r;
}
let sa = {};
function oa(i, e = {}) {
  const t = JSON.stringify([i, e]);
  let r = sa[t];
  return r || (r = new Intl.DateTimeFormat(i, e), sa[t] = r), r;
}
let na = {};
function PC(i, e = {}) {
  const t = JSON.stringify([i, e]);
  let r = na[t];
  return r || (r = new Intl.NumberFormat(i, e), na[t] = r), r;
}
let aa = {};
function MC(i, e = {}) {
  const { base: t, ...r } = e, s = JSON.stringify([i, r]);
  let o = aa[s];
  return o || (o = new Intl.RelativeTimeFormat(i, e), aa[s] = o), o;
}
let Ts = null;
function zC() {
  return Ts || (Ts = new Intl.DateTimeFormat().resolvedOptions().locale, Ts);
}
function NC(i) {
  const e = i.indexOf("-x-");
  e !== -1 && (i = i.substring(0, e));
  const t = i.indexOf("-u-");
  if (t === -1)
    return [i];
  {
    let r, s;
    try {
      r = oa(i).resolvedOptions(), s = i;
    } catch {
      const a = i.substring(0, t);
      r = oa(a).resolvedOptions(), s = a;
    }
    const { numberingSystem: o, calendar: n } = r;
    return [s, o, n];
  }
}
function FC(i, e, t) {
  return (t || e) && (i.includes("-u-") || (i += "-u"), t && (i += `-ca-${t}`), e && (i += `-nu-${e}`)), i;
}
function RC(i) {
  const e = [];
  for (let t = 1; t <= 12; t++) {
    const r = w.utc(2009, t, 1);
    e.push(i(r));
  }
  return e;
}
function LC(i) {
  const e = [];
  for (let t = 1; t <= 7; t++) {
    const r = w.utc(2016, 11, 13 + t);
    e.push(i(r));
  }
  return e;
}
function ps(i, e, t, r) {
  const s = i.listingMode();
  return s === "error" ? null : s === "en" ? t(e) : r(e);
}
function VC(i) {
  return i.numberingSystem && i.numberingSystem !== "latn" ? !1 : i.numberingSystem === "latn" || !i.locale || i.locale.startsWith("en") || new Intl.DateTimeFormat(i.intl).resolvedOptions().numberingSystem === "latn";
}
class HC {
  constructor(e, t, r) {
    this.padTo = r.padTo || 0, this.floor = r.floor || !1;
    const { padTo: s, floor: o, ...n } = r;
    if (!t || Object.keys(n).length > 0) {
      const a = { useGrouping: !1, ...r };
      r.padTo > 0 && (a.minimumIntegerDigits = r.padTo), this.inf = PC(e, a);
    }
  }
  format(e) {
    if (this.inf) {
      const t = this.floor ? Math.floor(e) : e;
      return this.inf.format(t);
    } else {
      const t = this.floor ? Math.floor(e) : dl(e, 3);
      return J(t, this.padTo);
    }
  }
}
class BC {
  constructor(e, t, r) {
    this.opts = r, this.originalZone = void 0;
    let s;
    if (this.opts.timeZone)
      this.dt = e;
    else if (e.zone.type === "fixed") {
      const n = -1 * (e.offset / 60), a = n >= 0 ? `Etc/GMT+${n}` : `Etc/GMT${n}`;
      e.offset !== 0 && et.create(a).valid ? (s = a, this.dt = e) : (s = "UTC", this.dt = e.offset === 0 ? e : e.setZone("UTC").plus({ minutes: e.offset }), this.originalZone = e.zone);
    } else
      e.zone.type === "system" ? this.dt = e : e.zone.type === "iana" ? (this.dt = e, s = e.zone.name) : (s = "UTC", this.dt = e.setZone("UTC").plus({ minutes: e.offset }), this.originalZone = e.zone);
    const o = { ...this.opts };
    o.timeZone = o.timeZone || s, this.dtf = oa(t, o);
  }
  format() {
    return this.originalZone ? this.formatToParts().map(({ value: e }) => e).join("") : this.dtf.format(this.dt.toJSDate());
  }
  formatToParts() {
    const e = this.dtf.formatToParts(this.dt.toJSDate());
    return this.originalZone ? e.map((t) => {
      if (t.type === "timeZoneName") {
        const r = this.originalZone.offsetName(this.dt.ts, {
          locale: this.dt.locale,
          format: this.opts.timeZoneName
        });
        return {
          ...t,
          value: r
        };
      } else
        return t;
    }) : e;
  }
  resolvedOptions() {
    return this.dtf.resolvedOptions();
  }
}
class UC {
  constructor(e, t, r) {
    this.opts = { style: "long", ...r }, !t && Cp() && (this.rtf = MC(e, r));
  }
  format(e, t) {
    return this.rtf ? this.rtf.format(e, t) : nk(t, e, this.opts.numeric, this.opts.style !== "long");
  }
  formatToParts(e, t) {
    return this.rtf ? this.rtf.formatToParts(e, t) : [];
  }
}
class V {
  static fromOpts(e) {
    return V.create(e.locale, e.numberingSystem, e.outputCalendar, e.defaultToEN);
  }
  static create(e, t, r, s = !1) {
    const o = e || K.defaultLocale, n = o || (s ? "en-US" : zC()), a = t || K.defaultNumberingSystem, l = r || K.defaultOutputCalendar;
    return new V(n, a, l, o);
  }
  static resetCache() {
    Ts = null, sa = {}, na = {}, aa = {};
  }
  static fromObject({ locale: e, numberingSystem: t, outputCalendar: r } = {}) {
    return V.create(e, t, r);
  }
  constructor(e, t, r, s) {
    const [o, n, a] = NC(e);
    this.locale = o, this.numberingSystem = t || n || null, this.outputCalendar = r || a || null, this.intl = FC(this.locale, this.numberingSystem, this.outputCalendar), this.weekdaysCache = { format: {}, standalone: {} }, this.monthsCache = { format: {}, standalone: {} }, this.meridiemCache = null, this.eraCache = {}, this.specifiedLocale = s, this.fastNumbersCached = null;
  }
  get fastNumbers() {
    return this.fastNumbersCached == null && (this.fastNumbersCached = VC(this)), this.fastNumbersCached;
  }
  listingMode() {
    const e = this.isEnglish(), t = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
    return e && t ? "en" : "intl";
  }
  clone(e) {
    return !e || Object.getOwnPropertyNames(e).length === 0 ? this : V.create(
      e.locale || this.specifiedLocale,
      e.numberingSystem || this.numberingSystem,
      e.outputCalendar || this.outputCalendar,
      e.defaultToEN || !1
    );
  }
  redefaultToEN(e = {}) {
    return this.clone({ ...e, defaultToEN: !0 });
  }
  redefaultToSystem(e = {}) {
    return this.clone({ ...e, defaultToEN: !1 });
  }
  months(e, t = !1) {
    return ps(this, e, Sp, () => {
      const r = t ? { month: e, day: "numeric" } : { month: e }, s = t ? "format" : "standalone";
      return this.monthsCache[s][e] || (this.monthsCache[s][e] = RC((o) => this.extract(o, r, "month"))), this.monthsCache[s][e];
    });
  }
  weekdays(e, t = !1) {
    return ps(this, e, Dp, () => {
      const r = t ? { weekday: e, year: "numeric", month: "long", day: "numeric" } : { weekday: e }, s = t ? "format" : "standalone";
      return this.weekdaysCache[s][e] || (this.weekdaysCache[s][e] = LC(
        (o) => this.extract(o, r, "weekday")
      )), this.weekdaysCache[s][e];
    });
  }
  meridiems() {
    return ps(
      this,
      void 0,
      () => Op,
      () => {
        if (!this.meridiemCache) {
          const e = { hour: "numeric", hourCycle: "h12" };
          this.meridiemCache = [w.utc(2016, 11, 13, 9), w.utc(2016, 11, 13, 19)].map(
            (t) => this.extract(t, e, "dayperiod")
          );
        }
        return this.meridiemCache;
      }
    );
  }
  eras(e) {
    return ps(this, e, $p, () => {
      const t = { era: e };
      return this.eraCache[e] || (this.eraCache[e] = [w.utc(-40, 1, 1), w.utc(2017, 1, 1)].map(
        (r) => this.extract(r, t, "era")
      )), this.eraCache[e];
    });
  }
  extract(e, t, r) {
    const s = this.dtFormatter(e, t), o = s.formatToParts(), n = o.find((a) => a.type.toLowerCase() === r);
    return n ? n.value : null;
  }
  numberFormatter(e = {}) {
    return new HC(this.intl, e.forceSimple || this.fastNumbers, e);
  }
  dtFormatter(e, t = {}) {
    return new BC(e, this.intl, t);
  }
  relFormatter(e = {}) {
    return new UC(this.intl, this.isEnglish(), e);
  }
  listFormatter(e = {}) {
    return $C(this.intl, e);
  }
  isEnglish() {
    return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
  }
  equals(e) {
    return this.locale === e.locale && this.numberingSystem === e.numberingSystem && this.outputCalendar === e.outputCalendar;
  }
}
let gn = null;
class ne extends Ki {
  /**
   * Get a singleton instance of UTC
   * @return {FixedOffsetZone}
   */
  static get utcInstance() {
    return gn === null && (gn = new ne(0)), gn;
  }
  /**
   * Get an instance with a specified offset
   * @param {number} offset - The offset in minutes
   * @return {FixedOffsetZone}
   */
  static instance(e) {
    return e === 0 ? ne.utcInstance : new ne(e);
  }
  /**
   * Get an instance of FixedOffsetZone from a UTC offset string, like "UTC+6"
   * @param {string} s - The offset string to parse
   * @example FixedOffsetZone.parseSpecifier("UTC+6")
   * @example FixedOffsetZone.parseSpecifier("UTC+06")
   * @example FixedOffsetZone.parseSpecifier("UTC-6:00")
   * @return {FixedOffsetZone}
   */
  static parseSpecifier(e) {
    if (e) {
      const t = e.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
      if (t)
        return new ne(So(t[1], t[2]));
    }
    return null;
  }
  constructor(e) {
    super(), this.fixed = e;
  }
  /** @override **/
  get type() {
    return "fixed";
  }
  /** @override **/
  get name() {
    return this.fixed === 0 ? "UTC" : `UTC${vi(this.fixed, "narrow")}`;
  }
  get ianaName() {
    return this.fixed === 0 ? "Etc/UTC" : `Etc/GMT${vi(-this.fixed, "narrow")}`;
  }
  /** @override **/
  offsetName() {
    return this.name;
  }
  /** @override **/
  formatOffset(e, t) {
    return vi(this.fixed, t);
  }
  /** @override **/
  get isUniversal() {
    return !0;
  }
  /** @override **/
  offset() {
    return this.fixed;
  }
  /** @override **/
  equals(e) {
    return e.type === "fixed" && e.fixed === this.fixed;
  }
  /** @override **/
  get isValid() {
    return !0;
  }
}
class qC extends Ki {
  constructor(e) {
    super(), this.zoneName = e;
  }
  /** @override **/
  get type() {
    return "invalid";
  }
  /** @override **/
  get name() {
    return this.zoneName;
  }
  /** @override **/
  get isUniversal() {
    return !1;
  }
  /** @override **/
  offsetName() {
    return null;
  }
  /** @override **/
  formatOffset() {
    return "";
  }
  /** @override **/
  offset() {
    return NaN;
  }
  /** @override **/
  equals() {
    return !1;
  }
  /** @override **/
  get isValid() {
    return !1;
  }
}
function mt(i, e) {
  if (S(i) || i === null)
    return e;
  if (i instanceof Ki)
    return i;
  if (WC(i)) {
    const t = i.toLowerCase();
    return t === "default" ? e : t === "local" || t === "system" ? ko.instance : t === "utc" || t === "gmt" ? ne.utcInstance : ne.parseSpecifier(t) || et.create(i);
  } else
    return Gt(i) ? ne.instance(i) : typeof i == "object" && "offset" in i && typeof i.offset == "function" ? i : new qC(i);
}
let _d = () => Date.now(), bd = "system", yd = null, vd = null, wd = null, xd = 60, Cd;
class K {
  /**
   * Get the callback for returning the current timestamp.
   * @type {function}
   */
  static get now() {
    return _d;
  }
  /**
   * Set the callback for returning the current timestamp.
   * The function should return a number, which will be interpreted as an Epoch millisecond count
   * @type {function}
   * @example Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future
   * @example Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time
   */
  static set now(e) {
    _d = e;
  }
  /**
   * Set the default time zone to create DateTimes in. Does not affect existing instances.
   * Use the value "system" to reset this value to the system's time zone.
   * @type {string}
   */
  static set defaultZone(e) {
    bd = e;
  }
  /**
   * Get the default time zone object currently used to create DateTimes. Does not affect existing instances.
   * The default value is the system's time zone (the one set on the machine that runs this code).
   * @type {Zone}
   */
  static get defaultZone() {
    return mt(bd, ko.instance);
  }
  /**
   * Get the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultLocale() {
    return yd;
  }
  /**
   * Set the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultLocale(e) {
    yd = e;
  }
  /**
   * Get the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultNumberingSystem() {
    return vd;
  }
  /**
   * Set the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultNumberingSystem(e) {
    vd = e;
  }
  /**
   * Get the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultOutputCalendar() {
    return wd;
  }
  /**
   * Set the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultOutputCalendar(e) {
    wd = e;
  }
  /**
   * Get the cutoff year after which a string encoding a year as two digits is interpreted to occur in the current century.
   * @type {number}
   */
  static get twoDigitCutoffYear() {
    return xd;
  }
  /**
   * Set the cutoff year after which a string encoding a year as two digits is interpreted to occur in the current century.
   * @type {number}
   * @example Settings.twoDigitCutoffYear = 0 // cut-off year is 0, so all 'yy' are interpreted as current century
   * @example Settings.twoDigitCutoffYear = 50 // '49' -> 1949; '50' -> 2050
   * @example Settings.twoDigitCutoffYear = 1950 // interpreted as 50
   * @example Settings.twoDigitCutoffYear = 2050 // ALSO interpreted as 50
   */
  static set twoDigitCutoffYear(e) {
    xd = e % 100;
  }
  /**
   * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static get throwOnInvalid() {
    return Cd;
  }
  /**
   * Set whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static set throwOnInvalid(e) {
    Cd = e;
  }
  /**
   * Reset Luxon's global caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCaches() {
    V.resetCache(), et.resetCache();
  }
}
function S(i) {
  return typeof i > "u";
}
function Gt(i) {
  return typeof i == "number";
}
function Ao(i) {
  return typeof i == "number" && i % 1 === 0;
}
function WC(i) {
  return typeof i == "string";
}
function jC(i) {
  return Object.prototype.toString.call(i) === "[object Date]";
}
function Cp() {
  try {
    return typeof Intl < "u" && !!Intl.RelativeTimeFormat;
  } catch {
    return !1;
  }
}
function GC(i) {
  return Array.isArray(i) ? i : [i];
}
function kd(i, e, t) {
  if (i.length !== 0)
    return i.reduce((r, s) => {
      const o = [e(s), s];
      return r && t(r[0], o[0]) === r[0] ? r : o;
    }, null)[1];
}
function YC(i, e) {
  return e.reduce((t, r) => (t[r] = i[r], t), {});
}
function $r(i, e) {
  return Object.prototype.hasOwnProperty.call(i, e);
}
function Qe(i, e, t) {
  return Ao(i) && i >= e && i <= t;
}
function ZC(i, e) {
  return i - e * Math.floor(i / e);
}
function J(i, e = 2) {
  const t = i < 0;
  let r;
  return t ? r = "-" + ("" + -i).padStart(e, "0") : r = ("" + i).padStart(e, "0"), r;
}
function ut(i) {
  if (!(S(i) || i === null || i === ""))
    return parseInt(i, 10);
}
function Mt(i) {
  if (!(S(i) || i === null || i === ""))
    return parseFloat(i);
}
function cl(i) {
  if (!(S(i) || i === null || i === "")) {
    const e = parseFloat("0." + i) * 1e3;
    return Math.floor(e);
  }
}
function dl(i, e, t = !1) {
  const r = 10 ** e;
  return (t ? Math.trunc : Math.round)(i * r) / r;
}
function Qi(i) {
  return i % 4 === 0 && (i % 100 !== 0 || i % 400 === 0);
}
function yi(i) {
  return Qi(i) ? 366 : 365;
}
function Ys(i, e) {
  const t = ZC(e - 1, 12) + 1, r = i + (e - t) / 12;
  return t === 2 ? Qi(r) ? 29 : 28 : [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][t - 1];
}
function Eo(i) {
  let e = Date.UTC(
    i.year,
    i.month - 1,
    i.day,
    i.hour,
    i.minute,
    i.second,
    i.millisecond
  );
  return i.year < 100 && i.year >= 0 && (e = new Date(e), e.setUTCFullYear(i.year, i.month - 1, i.day)), +e;
}
function Zs(i) {
  const e = (i + Math.floor(i / 4) - Math.floor(i / 100) + Math.floor(i / 400)) % 7, t = i - 1, r = (t + Math.floor(t / 4) - Math.floor(t / 100) + Math.floor(t / 400)) % 7;
  return e === 4 || r === 3 ? 53 : 52;
}
function la(i) {
  return i > 99 ? i : i > K.twoDigitCutoffYear ? 1900 + i : 2e3 + i;
}
function kp(i, e, t, r = null) {
  const s = new Date(i), o = {
    hourCycle: "h23",
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit"
  };
  r && (o.timeZone = r);
  const n = { timeZoneName: e, ...o }, a = new Intl.DateTimeFormat(t, n).formatToParts(s).find((l) => l.type.toLowerCase() === "timezonename");
  return a ? a.value : null;
}
function So(i, e) {
  let t = parseInt(i, 10);
  Number.isNaN(t) && (t = 0);
  const r = parseInt(e, 10) || 0, s = t < 0 || Object.is(t, -0) ? -r : r;
  return t * 60 + s;
}
function Ap(i) {
  const e = Number(i);
  if (typeof i == "boolean" || i === "" || Number.isNaN(e))
    throw new Ce(`Invalid unit value ${i}`);
  return e;
}
function Ks(i, e) {
  const t = {};
  for (const r in i)
    if ($r(i, r)) {
      const s = i[r];
      if (s == null)
        continue;
      t[e(r)] = Ap(s);
    }
  return t;
}
function vi(i, e) {
  const t = Math.trunc(Math.abs(i / 60)), r = Math.trunc(Math.abs(i % 60)), s = i >= 0 ? "+" : "-";
  switch (e) {
    case "short":
      return `${s}${J(t, 2)}:${J(r, 2)}`;
    case "narrow":
      return `${s}${t}${r > 0 ? `:${r}` : ""}`;
    case "techie":
      return `${s}${J(t, 2)}${J(r, 2)}`;
    default:
      throw new RangeError(`Value format ${e} is out of range for property format`);
  }
}
function To(i) {
  return YC(i, ["hour", "minute", "second", "millisecond"]);
}
const KC = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
], Ep = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
], QC = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
function Sp(i) {
  switch (i) {
    case "narrow":
      return [...QC];
    case "short":
      return [...Ep];
    case "long":
      return [...KC];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
    case "2-digit":
      return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
    default:
      return null;
  }
}
const Tp = [
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday",
  "Sunday"
], Ip = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"], JC = ["M", "T", "W", "T", "F", "S", "S"];
function Dp(i) {
  switch (i) {
    case "narrow":
      return [...JC];
    case "short":
      return [...Ip];
    case "long":
      return [...Tp];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7"];
    default:
      return null;
  }
}
const Op = ["AM", "PM"], XC = ["Before Christ", "Anno Domini"], ek = ["BC", "AD"], tk = ["B", "A"];
function $p(i) {
  switch (i) {
    case "narrow":
      return [...tk];
    case "short":
      return [...ek];
    case "long":
      return [...XC];
    default:
      return null;
  }
}
function rk(i) {
  return Op[i.hour < 12 ? 0 : 1];
}
function ik(i, e) {
  return Dp(e)[i.weekday - 1];
}
function sk(i, e) {
  return Sp(e)[i.month - 1];
}
function ok(i, e) {
  return $p(e)[i.year < 0 ? 0 : 1];
}
function nk(i, e, t = "always", r = !1) {
  const s = {
    years: ["year", "yr."],
    quarters: ["quarter", "qtr."],
    months: ["month", "mo."],
    weeks: ["week", "wk."],
    days: ["day", "day", "days"],
    hours: ["hour", "hr."],
    minutes: ["minute", "min."],
    seconds: ["second", "sec."]
  }, o = ["hours", "minutes", "seconds"].indexOf(i) === -1;
  if (t === "auto" && o) {
    const u = i === "days";
    switch (e) {
      case 1:
        return u ? "tomorrow" : `next ${s[i][0]}`;
      case -1:
        return u ? "yesterday" : `last ${s[i][0]}`;
      case 0:
        return u ? "today" : `this ${s[i][0]}`;
    }
  }
  const n = Object.is(e, -0) || e < 0, a = Math.abs(e), l = a === 1, c = s[i], d = r ? l ? c[1] : c[2] || c[1] : l ? s[i][0] : i;
  return n ? `${a} ${d} ago` : `in ${a} ${d}`;
}
function Ad(i, e) {
  let t = "";
  for (const r of i)
    r.literal ? t += r.val : t += e(r.val);
  return t;
}
const ak = {
  D: Gs,
  DD: sp,
  DDD: op,
  DDDD: np,
  t: ap,
  tt: lp,
  ttt: cp,
  tttt: dp,
  T: up,
  TT: hp,
  TTT: fp,
  TTTT: pp,
  f: mp,
  ff: _p,
  fff: yp,
  ffff: wp,
  F: gp,
  FF: bp,
  FFF: vp,
  FFFF: xp
};
class ie {
  static create(e, t = {}) {
    return new ie(e, t);
  }
  static parseFormat(e) {
    let t = null, r = "", s = !1;
    const o = [];
    for (let n = 0; n < e.length; n++) {
      const a = e.charAt(n);
      a === "'" ? (r.length > 0 && o.push({ literal: s || /^\s+$/.test(r), val: r }), t = null, r = "", s = !s) : s || a === t ? r += a : (r.length > 0 && o.push({ literal: /^\s+$/.test(r), val: r }), r = a, t = a);
    }
    return r.length > 0 && o.push({ literal: s || /^\s+$/.test(r), val: r }), o;
  }
  static macroTokenToFormatOpts(e) {
    return ak[e];
  }
  constructor(e, t) {
    this.opts = t, this.loc = e, this.systemLoc = null;
  }
  formatWithSystemDefault(e, t) {
    return this.systemLoc === null && (this.systemLoc = this.loc.redefaultToSystem()), this.systemLoc.dtFormatter(e, { ...this.opts, ...t }).format();
  }
  dtFormatter(e, t = {}) {
    return this.loc.dtFormatter(e, { ...this.opts, ...t });
  }
  formatDateTime(e, t) {
    return this.dtFormatter(e, t).format();
  }
  formatDateTimeParts(e, t) {
    return this.dtFormatter(e, t).formatToParts();
  }
  formatInterval(e, t) {
    return this.dtFormatter(e.start, t).dtf.formatRange(e.start.toJSDate(), e.end.toJSDate());
  }
  resolvedOptions(e, t) {
    return this.dtFormatter(e, t).resolvedOptions();
  }
  num(e, t = 0) {
    if (this.opts.forceSimple)
      return J(e, t);
    const r = { ...this.opts };
    return t > 0 && (r.padTo = t), this.loc.numberFormatter(r).format(e);
  }
  formatDateTimeFromString(e, t) {
    const r = this.loc.listingMode() === "en", s = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", o = (f, m) => this.loc.extract(e, f, m), n = (f) => e.isOffsetFixed && e.offset === 0 && f.allowZ ? "Z" : e.isValid ? e.zone.formatOffset(e.ts, f.format) : "", a = () => r ? rk(e) : o({ hour: "numeric", hourCycle: "h12" }, "dayperiod"), l = (f, m) => r ? sk(e, f) : o(m ? { month: f } : { month: f, day: "numeric" }, "month"), c = (f, m) => r ? ik(e, f) : o(
      m ? { weekday: f } : { weekday: f, month: "long", day: "numeric" },
      "weekday"
    ), d = (f) => {
      const m = ie.macroTokenToFormatOpts(f);
      return m ? this.formatWithSystemDefault(e, m) : f;
    }, u = (f) => r ? ok(e, f) : o({ era: f }, "era"), h = (f) => {
      switch (f) {
        case "S":
          return this.num(e.millisecond);
        case "u":
        case "SSS":
          return this.num(e.millisecond, 3);
        case "s":
          return this.num(e.second);
        case "ss":
          return this.num(e.second, 2);
        case "uu":
          return this.num(Math.floor(e.millisecond / 10), 2);
        case "uuu":
          return this.num(Math.floor(e.millisecond / 100));
        case "m":
          return this.num(e.minute);
        case "mm":
          return this.num(e.minute, 2);
        case "h":
          return this.num(e.hour % 12 === 0 ? 12 : e.hour % 12);
        case "hh":
          return this.num(e.hour % 12 === 0 ? 12 : e.hour % 12, 2);
        case "H":
          return this.num(e.hour);
        case "HH":
          return this.num(e.hour, 2);
        case "Z":
          return n({ format: "narrow", allowZ: this.opts.allowZ });
        case "ZZ":
          return n({ format: "short", allowZ: this.opts.allowZ });
        case "ZZZ":
          return n({ format: "techie", allowZ: this.opts.allowZ });
        case "ZZZZ":
          return e.zone.offsetName(e.ts, { format: "short", locale: this.loc.locale });
        case "ZZZZZ":
          return e.zone.offsetName(e.ts, { format: "long", locale: this.loc.locale });
        case "z":
          return e.zoneName;
        case "a":
          return a();
        case "d":
          return s ? o({ day: "numeric" }, "day") : this.num(e.day);
        case "dd":
          return s ? o({ day: "2-digit" }, "day") : this.num(e.day, 2);
        case "c":
          return this.num(e.weekday);
        case "ccc":
          return c("short", !0);
        case "cccc":
          return c("long", !0);
        case "ccccc":
          return c("narrow", !0);
        case "E":
          return this.num(e.weekday);
        case "EEE":
          return c("short", !1);
        case "EEEE":
          return c("long", !1);
        case "EEEEE":
          return c("narrow", !1);
        case "L":
          return s ? o({ month: "numeric", day: "numeric" }, "month") : this.num(e.month);
        case "LL":
          return s ? o({ month: "2-digit", day: "numeric" }, "month") : this.num(e.month, 2);
        case "LLL":
          return l("short", !0);
        case "LLLL":
          return l("long", !0);
        case "LLLLL":
          return l("narrow", !0);
        case "M":
          return s ? o({ month: "numeric" }, "month") : this.num(e.month);
        case "MM":
          return s ? o({ month: "2-digit" }, "month") : this.num(e.month, 2);
        case "MMM":
          return l("short", !1);
        case "MMMM":
          return l("long", !1);
        case "MMMMM":
          return l("narrow", !1);
        case "y":
          return s ? o({ year: "numeric" }, "year") : this.num(e.year);
        case "yy":
          return s ? o({ year: "2-digit" }, "year") : this.num(e.year.toString().slice(-2), 2);
        case "yyyy":
          return s ? o({ year: "numeric" }, "year") : this.num(e.year, 4);
        case "yyyyyy":
          return s ? o({ year: "numeric" }, "year") : this.num(e.year, 6);
        case "G":
          return u("short");
        case "GG":
          return u("long");
        case "GGGGG":
          return u("narrow");
        case "kk":
          return this.num(e.weekYear.toString().slice(-2), 2);
        case "kkkk":
          return this.num(e.weekYear, 4);
        case "W":
          return this.num(e.weekNumber);
        case "WW":
          return this.num(e.weekNumber, 2);
        case "o":
          return this.num(e.ordinal);
        case "ooo":
          return this.num(e.ordinal, 3);
        case "q":
          return this.num(e.quarter);
        case "qq":
          return this.num(e.quarter, 2);
        case "X":
          return this.num(Math.floor(e.ts / 1e3));
        case "x":
          return this.num(e.ts);
        default:
          return d(f);
      }
    };
    return Ad(ie.parseFormat(t), h);
  }
  formatDurationFromString(e, t) {
    const r = (l) => {
      switch (l[0]) {
        case "S":
          return "millisecond";
        case "s":
          return "second";
        case "m":
          return "minute";
        case "h":
          return "hour";
        case "d":
          return "day";
        case "w":
          return "week";
        case "M":
          return "month";
        case "y":
          return "year";
        default:
          return null;
      }
    }, s = (l) => (c) => {
      const d = r(c);
      return d ? this.num(l.get(d), c.length) : c;
    }, o = ie.parseFormat(t), n = o.reduce(
      (l, { literal: c, val: d }) => c ? l : l.concat(d),
      []
    ), a = e.shiftTo(...n.map(r).filter((l) => l));
    return Ad(o, s(a));
  }
}
class Fe {
  constructor(e, t) {
    this.reason = e, this.explanation = t;
  }
  toMessage() {
    return this.explanation ? `${this.reason}: ${this.explanation}` : this.reason;
  }
}
const Pp = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;
function Hr(...i) {
  const e = i.reduce((t, r) => t + r.source, "");
  return RegExp(`^${e}$`);
}
function Br(...i) {
  return (e) => i.reduce(
    ([t, r, s], o) => {
      const [n, a, l] = o(e, s);
      return [{ ...t, ...n }, a || r, l];
    },
    [{}, null, 1]
  ).slice(0, 2);
}
function Ur(i, ...e) {
  if (i == null)
    return [null, null];
  for (const [t, r] of e) {
    const s = t.exec(i);
    if (s)
      return r(s);
  }
  return [null, null];
}
function Mp(...i) {
  return (e, t) => {
    const r = {};
    let s;
    for (s = 0; s < i.length; s++)
      r[i[s]] = ut(e[t + s]);
    return [r, null, t + s];
  };
}
const zp = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/, lk = `(?:${zp.source}?(?:\\[(${Pp.source})\\])?)?`, ul = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/, Np = RegExp(`${ul.source}${lk}`), hl = RegExp(`(?:T${Np.source})?`), ck = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/, dk = /(\d{4})-?W(\d\d)(?:-?(\d))?/, uk = /(\d{4})-?(\d{3})/, hk = Mp("weekYear", "weekNumber", "weekDay"), fk = Mp("year", "ordinal"), pk = /(\d{4})-(\d\d)-(\d\d)/, Fp = RegExp(
  `${ul.source} ?(?:${zp.source}|(${Pp.source}))?`
), mk = RegExp(`(?: ${Fp.source})?`);
function xr(i, e, t) {
  const r = i[e];
  return S(r) ? t : ut(r);
}
function gk(i, e) {
  return [{
    year: xr(i, e),
    month: xr(i, e + 1, 1),
    day: xr(i, e + 2, 1)
  }, null, e + 3];
}
function qr(i, e) {
  return [{
    hours: xr(i, e, 0),
    minutes: xr(i, e + 1, 0),
    seconds: xr(i, e + 2, 0),
    milliseconds: cl(i[e + 3])
  }, null, e + 4];
}
function Ji(i, e) {
  const t = !i[e] && !i[e + 1], r = So(i[e + 1], i[e + 2]), s = t ? null : ne.instance(r);
  return [{}, s, e + 3];
}
function Xi(i, e) {
  const t = i[e] ? et.create(i[e]) : null;
  return [{}, t, e + 1];
}
const _k = RegExp(`^T?${ul.source}$`), bk = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
function yk(i) {
  const [e, t, r, s, o, n, a, l, c] = i, d = e[0] === "-", u = l && l[0] === "-", h = (f, m = !1) => f !== void 0 && (m || f && d) ? -f : f;
  return [
    {
      years: h(Mt(t)),
      months: h(Mt(r)),
      weeks: h(Mt(s)),
      days: h(Mt(o)),
      hours: h(Mt(n)),
      minutes: h(Mt(a)),
      seconds: h(Mt(l), l === "-0"),
      milliseconds: h(cl(c), u)
    }
  ];
}
const vk = {
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};
function fl(i, e, t, r, s, o, n) {
  const a = {
    year: e.length === 2 ? la(ut(e)) : ut(e),
    month: Ep.indexOf(t) + 1,
    day: ut(r),
    hour: ut(s),
    minute: ut(o)
  };
  return n && (a.second = ut(n)), i && (a.weekday = i.length > 3 ? Tp.indexOf(i) + 1 : Ip.indexOf(i) + 1), a;
}
const wk = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
function xk(i) {
  const [
    ,
    e,
    t,
    r,
    s,
    o,
    n,
    a,
    l,
    c,
    d,
    u
  ] = i, h = fl(e, s, r, t, o, n, a);
  let f;
  return l ? f = vk[l] : c ? f = 0 : f = So(d, u), [h, new ne(f)];
}
function Ck(i) {
  return i.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
}
const kk = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/, Ak = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/, Ek = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
function Ed(i) {
  const [, e, t, r, s, o, n, a] = i;
  return [fl(e, s, r, t, o, n, a), ne.utcInstance];
}
function Sk(i) {
  const [, e, t, r, s, o, n, a] = i;
  return [fl(e, a, t, r, s, o, n), ne.utcInstance];
}
const Tk = Hr(ck, hl), Ik = Hr(dk, hl), Dk = Hr(uk, hl), Ok = Hr(Np), Rp = Br(
  gk,
  qr,
  Ji,
  Xi
), $k = Br(
  hk,
  qr,
  Ji,
  Xi
), Pk = Br(
  fk,
  qr,
  Ji,
  Xi
), Mk = Br(
  qr,
  Ji,
  Xi
);
function zk(i) {
  return Ur(
    i,
    [Tk, Rp],
    [Ik, $k],
    [Dk, Pk],
    [Ok, Mk]
  );
}
function Nk(i) {
  return Ur(Ck(i), [wk, xk]);
}
function Fk(i) {
  return Ur(
    i,
    [kk, Ed],
    [Ak, Ed],
    [Ek, Sk]
  );
}
function Rk(i) {
  return Ur(i, [bk, yk]);
}
const Lk = Br(qr);
function Vk(i) {
  return Ur(i, [_k, Lk]);
}
const Hk = Hr(pk, mk), Bk = Hr(Fp), Uk = Br(
  qr,
  Ji,
  Xi
);
function qk(i) {
  return Ur(
    i,
    [Hk, Rp],
    [Bk, Uk]
  );
}
const Wk = "Invalid Duration", Lp = {
  weeks: {
    days: 7,
    hours: 7 * 24,
    minutes: 7 * 24 * 60,
    seconds: 7 * 24 * 60 * 60,
    milliseconds: 7 * 24 * 60 * 60 * 1e3
  },
  days: {
    hours: 24,
    minutes: 24 * 60,
    seconds: 24 * 60 * 60,
    milliseconds: 24 * 60 * 60 * 1e3
  },
  hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1e3 },
  minutes: { seconds: 60, milliseconds: 60 * 1e3 },
  seconds: { milliseconds: 1e3 }
}, jk = {
  years: {
    quarters: 4,
    months: 12,
    weeks: 52,
    days: 365,
    hours: 365 * 24,
    minutes: 365 * 24 * 60,
    seconds: 365 * 24 * 60 * 60,
    milliseconds: 365 * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: 13,
    days: 91,
    hours: 91 * 24,
    minutes: 91 * 24 * 60,
    seconds: 91 * 24 * 60 * 60,
    milliseconds: 91 * 24 * 60 * 60 * 1e3
  },
  months: {
    weeks: 4,
    days: 30,
    hours: 30 * 24,
    minutes: 30 * 24 * 60,
    seconds: 30 * 24 * 60 * 60,
    milliseconds: 30 * 24 * 60 * 60 * 1e3
  },
  ...Lp
}, we = 146097 / 400, dr = 146097 / 4800, Gk = {
  years: {
    quarters: 4,
    months: 12,
    weeks: we / 7,
    days: we,
    hours: we * 24,
    minutes: we * 24 * 60,
    seconds: we * 24 * 60 * 60,
    milliseconds: we * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: we / 28,
    days: we / 4,
    hours: we * 24 / 4,
    minutes: we * 24 * 60 / 4,
    seconds: we * 24 * 60 * 60 / 4,
    milliseconds: we * 24 * 60 * 60 * 1e3 / 4
  },
  months: {
    weeks: dr / 7,
    days: dr,
    hours: dr * 24,
    minutes: dr * 24 * 60,
    seconds: dr * 24 * 60 * 60,
    milliseconds: dr * 24 * 60 * 60 * 1e3
  },
  ...Lp
}, Nt = [
  "years",
  "quarters",
  "months",
  "weeks",
  "days",
  "hours",
  "minutes",
  "seconds",
  "milliseconds"
], Vp = Nt.slice(0).reverse();
function ct(i, e, t = !1) {
  const r = {
    values: t ? e.values : { ...i.values, ...e.values || {} },
    loc: i.loc.clone(e.loc),
    conversionAccuracy: e.conversionAccuracy || i.conversionAccuracy,
    matrix: e.matrix || i.matrix
  };
  return new I(r);
}
function Sd(i) {
  return Math.trunc(i * 1e3) / 1e3;
}
function Hp(i, e, t, r, s) {
  const o = i[s][t], n = e[t] / o, a = Math.floor(n);
  r[s] = Sd(r[s] + a), e[t] = Sd(e[t] - a * o);
}
function Yk(i, e) {
  Vp.reduce((t, r) => S(e[r]) ? t : (t && Hp(i, e, t, e, r), r), null);
}
function Zk(i) {
  const e = {};
  for (const [t, r] of Object.entries(i))
    r !== 0 && (e[t] = r);
  return e;
}
class I {
  /**
   * @private
   */
  constructor(e) {
    const t = e.conversionAccuracy === "longterm" || !1;
    let r = t ? Gk : jk;
    e.matrix && (r = e.matrix), this.values = e.values, this.loc = e.loc || V.create(), this.conversionAccuracy = t ? "longterm" : "casual", this.invalid = e.invalid || null, this.matrix = r, this.isLuxonDuration = !0;
  }
  /**
   * Create Duration from a number of milliseconds.
   * @param {number} count of milliseconds
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  static fromMillis(e, t) {
    return I.fromObject({ milliseconds: e }, t);
  }
  /**
   * Create a Duration from a JavaScript object with keys like 'years' and 'hours'.
   * If this object is empty then a zero milliseconds duration is returned.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.years
   * @param {number} obj.quarters
   * @param {number} obj.months
   * @param {number} obj.weeks
   * @param {number} obj.days
   * @param {number} obj.hours
   * @param {number} obj.minutes
   * @param {number} obj.seconds
   * @param {number} obj.milliseconds
   * @param {Object} [opts=[]] - options for creating this Duration
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the custom conversion system to use
   * @return {Duration}
   */
  static fromObject(e, t = {}) {
    if (e == null || typeof e != "object")
      throw new Ce(
        `Duration.fromObject: argument expected to be an object, got ${e === null ? "null" : typeof e}`
      );
    return new I({
      values: Ks(e, I.normalizeUnit),
      loc: V.fromObject(t),
      conversionAccuracy: t.conversionAccuracy,
      matrix: t.matrix
    });
  }
  /**
   * Create a Duration from DurationLike.
   *
   * @param {Object | number | Duration} durationLike
   * One of:
   * - object with keys like 'years' and 'hours'.
   * - number representing milliseconds
   * - Duration instance
   * @return {Duration}
   */
  static fromDurationLike(e) {
    if (Gt(e))
      return I.fromMillis(e);
    if (I.isDuration(e))
      return e;
    if (typeof e == "object")
      return I.fromObject(e);
    throw new Ce(
      `Unknown duration argument ${e} of type ${typeof e}`
    );
  }
  /**
   * Create a Duration from an ISO 8601 duration string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the preset conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }
   * @example Duration.fromISO('PT23H').toObject() //=> { hours: 23 }
   * @example Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }
   * @return {Duration}
   */
  static fromISO(e, t) {
    const [r] = Rk(e);
    return r ? I.fromObject(r, t) : I.invalid("unparsable", `the input "${e}" can't be parsed as ISO 8601`);
  }
  /**
   * Create a Duration from an ISO 8601 time string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @example Duration.fromISOTime('11:22:33.444').toObject() //=> { hours: 11, minutes: 22, seconds: 33, milliseconds: 444 }
   * @example Duration.fromISOTime('11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @return {Duration}
   */
  static fromISOTime(e, t) {
    const [r] = Vk(e);
    return r ? I.fromObject(r, t) : I.invalid("unparsable", `the input "${e}" can't be parsed as ISO 8601`);
  }
  /**
   * Create an invalid Duration.
   * @param {string} reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Duration}
   */
  static invalid(e, t = null) {
    if (!e)
      throw new Ce("need to specify a reason the Duration is invalid");
    const r = e instanceof Fe ? e : new Fe(e, t);
    if (K.throwOnInvalid)
      throw new AC(r);
    return new I({ invalid: r });
  }
  /**
   * @private
   */
  static normalizeUnit(e) {
    const t = {
      year: "years",
      years: "years",
      quarter: "quarters",
      quarters: "quarters",
      month: "months",
      months: "months",
      week: "weeks",
      weeks: "weeks",
      day: "days",
      days: "days",
      hour: "hours",
      hours: "hours",
      minute: "minutes",
      minutes: "minutes",
      second: "seconds",
      seconds: "seconds",
      millisecond: "milliseconds",
      milliseconds: "milliseconds"
    }[e && e.toLowerCase()];
    if (!t)
      throw new ip(e);
    return t;
  }
  /**
   * Check if an object is a Duration. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDuration(e) {
    return e && e.isLuxonDuration || !1;
  }
  /**
   * Get  the locale of a Duration, such 'en-GB'
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  /**
   * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  /**
   * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:
   * * `S` for milliseconds
   * * `s` for seconds
   * * `m` for minutes
   * * `h` for hours
   * * `d` for days
   * * `w` for weeks
   * * `M` for months
   * * `y` for years
   * Notes:
   * * Add padding by repeating the token, e.g. "yy" pads the years to two digits, "hhhh" pads the hours out to four digits
   * * Tokens can be escaped by wrapping with single quotes.
   * * The duration will be converted to the set of units in the format string using {@link Duration#shiftTo} and the Durations's conversion accuracy setting.
   * @param {string} fmt - the format string
   * @param {Object} opts - options
   * @param {boolean} [opts.floor=true] - floor numerical values
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("y d s") //=> "1 6 2"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("yy dd sss") //=> "01 06 002"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("M S") //=> "12 518402000"
   * @return {string}
   */
  toFormat(e, t = {}) {
    const r = {
      ...t,
      floor: t.round !== !1 && t.floor !== !1
    };
    return this.isValid ? ie.create(this.loc, r).formatDurationFromString(this, e) : Wk;
  }
  /**
   * Returns a string representation of a Duration with all units included.
   * To modify its behavior use the `listStyle` and any Intl.NumberFormat option, though `unitDisplay` is especially relevant.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat
   * @param opts - On option object to override the formatting. Accepts the same keys as the options parameter of the native `Int.NumberFormat` constructor, as well as `listStyle`.
   * @example
   * ```js
   * var dur = Duration.fromObject({ days: 1, hours: 5, minutes: 6 })
   * dur.toHuman() //=> '1 day, 5 hours, 6 minutes'
   * dur.toHuman({ listStyle: "long" }) //=> '1 day, 5 hours, and 6 minutes'
   * dur.toHuman({ unitDisplay: "short" }) //=> '1 day, 5 hr, 6 min'
   * ```
   */
  toHuman(e = {}) {
    const t = Nt.map((r) => {
      const s = this.values[r];
      return S(s) ? null : this.loc.numberFormatter({ style: "unit", unitDisplay: "long", ...e, unit: r.slice(0, -1) }).format(s);
    }).filter((r) => r);
    return this.loc.listFormatter({ type: "conjunction", style: e.listStyle || "narrow", ...e }).format(t);
  }
  /**
   * Returns a JavaScript object with this Duration's values.
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }
   * @return {Object}
   */
  toObject() {
    return this.isValid ? { ...this.values } : {};
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Duration.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'
   * @example Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'
   * @example Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'
   * @example Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'
   * @example Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'
   * @return {string}
   */
  toISO() {
    if (!this.isValid)
      return null;
    let e = "P";
    return this.years !== 0 && (e += this.years + "Y"), (this.months !== 0 || this.quarters !== 0) && (e += this.months + this.quarters * 3 + "M"), this.weeks !== 0 && (e += this.weeks + "W"), this.days !== 0 && (e += this.days + "D"), (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0) && (e += "T"), this.hours !== 0 && (e += this.hours + "H"), this.minutes !== 0 && (e += this.minutes + "M"), (this.seconds !== 0 || this.milliseconds !== 0) && (e += dl(this.seconds + this.milliseconds / 1e3, 3) + "S"), e === "P" && (e += "T0S"), e;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Duration, formatted as a time of day.
   * Note that this will return null if the duration is invalid, negative, or equal to or greater than 24 hours.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example Duration.fromObject({ hours: 11 }).toISOTime() //=> '11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressMilliseconds: true }) //=> '11:00:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressSeconds: true }) //=> '11:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ includePrefix: true }) //=> 'T11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ format: 'basic' }) //=> '110000.000'
   * @return {string}
   */
  toISOTime(e = {}) {
    if (!this.isValid)
      return null;
    const t = this.toMillis();
    return t < 0 || t >= 864e5 ? null : (e = {
      suppressMilliseconds: !1,
      suppressSeconds: !1,
      includePrefix: !1,
      format: "extended",
      ...e,
      includeOffset: !1
    }, w.fromMillis(t, { zone: "UTC" }).toISOTime(e));
  }
  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }
  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.
   * @return {string}
   */
  toString() {
    return this.toISO();
  }
  /**
   * Returns an milliseconds value of this Duration.
   * @return {number}
   */
  toMillis() {
    var e;
    let t = this.values.milliseconds ?? 0;
    for (let r of Vp.slice(1))
      (e = this.values) != null && e[r] && (t += this.values[r] * this.matrix[r].milliseconds);
    return t;
  }
  /**
   * Returns an milliseconds value of this Duration. Alias of {@link toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }
  /**
   * Make this Duration longer by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  plus(e) {
    if (!this.isValid)
      return this;
    const t = I.fromDurationLike(e), r = {};
    for (const s of Nt)
      ($r(t.values, s) || $r(this.values, s)) && (r[s] = t.get(s) + this.get(s));
    return ct(this, { values: r }, !0);
  }
  /**
   * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  minus(e) {
    if (!this.isValid)
      return this;
    const t = I.fromDurationLike(e);
    return this.plus(t.negate());
  }
  /**
   * Scale this Duration by the specified amount. Return a newly-constructed Duration.
   * @param {function} fn - The function to apply to each unit. Arity is 1 or 2: the value of the unit and, optionally, the unit name. Must return a number.
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits(x => x * 2) //=> { hours: 2, minutes: 60 }
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits((x, u) => u === "hours" ? x * 2 : x) //=> { hours: 2, minutes: 30 }
   * @return {Duration}
   */
  mapUnits(e) {
    if (!this.isValid)
      return this;
    const t = {};
    for (const r of Object.keys(this.values))
      t[r] = Ap(e(this.values[r], r));
    return ct(this, { values: t }, !0);
  }
  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example Duration.fromObject({years: 2, days: 3}).get('years') //=> 2
   * @example Duration.fromObject({years: 2, days: 3}).get('months') //=> 0
   * @example Duration.fromObject({years: 2, days: 3}).get('days') //=> 3
   * @return {number}
   */
  get(e) {
    return this[I.normalizeUnit(e)];
  }
  /**
   * "Set" the values of specified units. Return a newly-constructed Duration.
   * @param {Object} values - a mapping of units to numbers
   * @example dur.set({ years: 2017 })
   * @example dur.set({ hours: 8, minutes: 30 })
   * @return {Duration}
   */
  set(e) {
    if (!this.isValid)
      return this;
    const t = { ...this.values, ...Ks(e, I.normalizeUnit) };
    return ct(this, { values: t });
  }
  /**
   * "Set" the locale and/or numberingSystem.  Returns a newly-constructed Duration.
   * @example dur.reconfigure({ locale: 'en-GB' })
   * @return {Duration}
   */
  reconfigure({ locale: e, numberingSystem: t, conversionAccuracy: r, matrix: s } = {}) {
    const o = { loc: this.loc.clone({ locale: e, numberingSystem: t }), matrix: s, conversionAccuracy: r };
    return ct(this, o);
  }
  /**
   * Return the length of the duration in the specified unit.
   * @param {string} unit - a unit such as 'minutes' or 'days'
   * @example Duration.fromObject({years: 1}).as('days') //=> 365
   * @example Duration.fromObject({years: 1}).as('months') //=> 12
   * @example Duration.fromObject({hours: 60}).as('days') //=> 2.5
   * @return {number}
   */
  as(e) {
    return this.isValid ? this.shiftTo(e).get(e) : NaN;
  }
  /**
   * Reduce this Duration to its canonical representation in its current units.
   * @example Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }
   * @example Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }
   * @return {Duration}
   */
  normalize() {
    if (!this.isValid)
      return this;
    const e = this.toObject();
    return this.valueOf() >= 0 ? (Yk(this.matrix, e), ct(this, { values: e }, !0)) : this.negate().normalize().negate();
  }
  /**
   * Rescale units to its largest representation
   * @example Duration.fromObject({ milliseconds: 90000 }).rescale().toObject() //=> { minutes: 1, seconds: 30 }
   * @return {Duration}
   */
  rescale() {
    if (!this.isValid)
      return this;
    const e = Zk(this.normalize().shiftToAll().toObject());
    return ct(this, { values: e }, !0);
  }
  /**
   * Convert this Duration into its representation in a different set of units.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }
   * @return {Duration}
   */
  shiftTo(...e) {
    if (!this.isValid)
      return this;
    if (e.length === 0)
      return this;
    e = e.map((n) => I.normalizeUnit(n));
    const t = {}, r = {}, s = this.toObject();
    let o;
    for (const n of Nt)
      if (e.indexOf(n) >= 0) {
        o = n;
        let a = 0;
        for (const c in r)
          a += this.matrix[c][n] * r[c], r[c] = 0;
        Gt(s[n]) && (a += s[n]);
        const l = Math.trunc(a);
        t[n] = l, r[n] = (a * 1e3 - l * 1e3) / 1e3;
        for (const c in s)
          Nt.indexOf(c) > Nt.indexOf(n) && Hp(this.matrix, s, c, t, n);
      } else
        Gt(s[n]) && (r[n] = s[n]);
    for (const n in r)
      r[n] !== 0 && (t[o] += n === o ? r[n] : r[n] / this.matrix[o][n]);
    return ct(this, { values: t }, !0).normalize();
  }
  /**
   * Shift this Duration to all available units.
   * Same as shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds")
   * @return {Duration}
   */
  shiftToAll() {
    return this.isValid ? this.shiftTo(
      "years",
      "months",
      "weeks",
      "days",
      "hours",
      "minutes",
      "seconds",
      "milliseconds"
    ) : this;
  }
  /**
   * Return the negative of this Duration.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }
   * @return {Duration}
   */
  negate() {
    if (!this.isValid)
      return this;
    const e = {};
    for (const t of Object.keys(this.values))
      e[t] = this.values[t] === 0 ? 0 : -this.values[t];
    return ct(this, { values: e }, !0);
  }
  /**
   * Get the years.
   * @type {number}
   */
  get years() {
    return this.isValid ? this.values.years || 0 : NaN;
  }
  /**
   * Get the quarters.
   * @type {number}
   */
  get quarters() {
    return this.isValid ? this.values.quarters || 0 : NaN;
  }
  /**
   * Get the months.
   * @type {number}
   */
  get months() {
    return this.isValid ? this.values.months || 0 : NaN;
  }
  /**
   * Get the weeks
   * @type {number}
   */
  get weeks() {
    return this.isValid ? this.values.weeks || 0 : NaN;
  }
  /**
   * Get the days.
   * @type {number}
   */
  get days() {
    return this.isValid ? this.values.days || 0 : NaN;
  }
  /**
   * Get the hours.
   * @type {number}
   */
  get hours() {
    return this.isValid ? this.values.hours || 0 : NaN;
  }
  /**
   * Get the minutes.
   * @type {number}
   */
  get minutes() {
    return this.isValid ? this.values.minutes || 0 : NaN;
  }
  /**
   * Get the seconds.
   * @return {number}
   */
  get seconds() {
    return this.isValid ? this.values.seconds || 0 : NaN;
  }
  /**
   * Get the milliseconds.
   * @return {number}
   */
  get milliseconds() {
    return this.isValid ? this.values.milliseconds || 0 : NaN;
  }
  /**
   * Returns whether the Duration is invalid. Invalid durations are returned by diff operations
   * on invalid DateTimes or Intervals.
   * @return {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }
  /**
   * Returns an error code if this Duration became invalid, or null if the Duration is valid
   * @return {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this Duration became invalid, or null if the Duration is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Equality check
   * Two Durations are equal iff they have the same units and the same values for each unit.
   * @param {Duration} other
   * @return {boolean}
   */
  equals(e) {
    if (!this.isValid || !e.isValid || !this.loc.equals(e.loc))
      return !1;
    function t(r, s) {
      return r === void 0 || r === 0 ? s === void 0 || s === 0 : r === s;
    }
    for (const r of Nt)
      if (!t(this.values[r], e.values[r]))
        return !1;
    return !0;
  }
}
const ur = "Invalid Interval";
function Kk(i, e) {
  return !i || !i.isValid ? W.invalid("missing or invalid start") : !e || !e.isValid ? W.invalid("missing or invalid end") : e < i ? W.invalid(
    "end before start",
    `The end of an interval must be after its start, but you had start=${i.toISO()} and end=${e.toISO()}`
  ) : null;
}
class W {
  /**
   * @private
   */
  constructor(e) {
    this.s = e.start, this.e = e.end, this.invalid = e.invalid || null, this.isLuxonInterval = !0;
  }
  /**
   * Create an invalid Interval.
   * @param {string} reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Interval}
   */
  static invalid(e, t = null) {
    if (!e)
      throw new Ce("need to specify a reason the Interval is invalid");
    const r = e instanceof Fe ? e : new Fe(e, t);
    if (K.throwOnInvalid)
      throw new kC(r);
    return new W({ invalid: r });
  }
  /**
   * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.
   * @param {DateTime|Date|Object} start
   * @param {DateTime|Date|Object} end
   * @return {Interval}
   */
  static fromDateTimes(e, t) {
    const r = ri(e), s = ri(t);
    return Kk(r, s) ?? new W({
      start: r,
      end: s
    });
  }
  /**
   * Create an Interval from a start DateTime and a Duration to extend to.
   * @param {DateTime|Date|Object} start
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static after(e, t) {
    const r = I.fromDurationLike(t), s = ri(e);
    return W.fromDateTimes(s, s.plus(r));
  }
  /**
   * Create an Interval from an end DateTime and a Duration to extend backwards to.
   * @param {DateTime|Date|Object} end
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static before(e, t) {
    const r = I.fromDurationLike(t), s = ri(e);
    return W.fromDateTimes(s.minus(r), s);
  }
  /**
   * Create an Interval from an ISO 8601 string.
   * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.
   * @param {string} text - the ISO string to parse
   * @param {Object} [opts] - options to pass {@link DateTime#fromISO} and optionally {@link Duration#fromISO}
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {Interval}
   */
  static fromISO(e, t) {
    const [r, s] = (e || "").split("/", 2);
    if (r && s) {
      let o, n;
      try {
        o = w.fromISO(r, t), n = o.isValid;
      } catch {
        n = !1;
      }
      let a, l;
      try {
        a = w.fromISO(s, t), l = a.isValid;
      } catch {
        l = !1;
      }
      if (n && l)
        return W.fromDateTimes(o, a);
      if (n) {
        const c = I.fromISO(s, t);
        if (c.isValid)
          return W.after(o, c);
      } else if (l) {
        const c = I.fromISO(r, t);
        if (c.isValid)
          return W.before(a, c);
      }
    }
    return W.invalid("unparsable", `the input "${e}" can't be parsed as ISO 8601`);
  }
  /**
   * Check if an object is an Interval. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isInterval(e) {
    return e && e.isLuxonInterval || !1;
  }
  /**
   * Returns the start of the Interval
   * @type {DateTime}
   */
  get start() {
    return this.isValid ? this.s : null;
  }
  /**
   * Returns the end of the Interval
   * @type {DateTime}
   */
  get end() {
    return this.isValid ? this.e : null;
  }
  /**
   * Returns whether this Interval's end is at least its start, meaning that the Interval isn't 'backwards'.
   * @type {boolean}
   */
  get isValid() {
    return this.invalidReason === null;
  }
  /**
   * Returns an error code if this Interval is invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this Interval became invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Returns the length of the Interval in the specified unit.
   * @param {string} unit - the unit (such as 'hours' or 'days') to return the length in.
   * @return {number}
   */
  length(e = "milliseconds") {
    return this.isValid ? this.toDuration(e).get(e) : NaN;
  }
  /**
   * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.
   * Unlike {@link Interval#length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'
   * asks 'what dates are included in this interval?', not 'how many days long is this interval?'
   * @param {string} [unit='milliseconds'] - the unit of time to count.
   * @return {number}
   */
  count(e = "milliseconds") {
    if (!this.isValid)
      return NaN;
    const t = this.start.startOf(e), r = this.end.startOf(e);
    return Math.floor(r.diff(t, e).get(e)) + (r.valueOf() !== this.end.valueOf());
  }
  /**
   * Returns whether this Interval's start and end are both in the same unit of time
   * @param {string} unit - the unit of time to check sameness on
   * @return {boolean}
   */
  hasSame(e) {
    return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, e) : !1;
  }
  /**
   * Return whether this Interval has the same start and end DateTimes.
   * @return {boolean}
   */
  isEmpty() {
    return this.s.valueOf() === this.e.valueOf();
  }
  /**
   * Return whether this Interval's start is after the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isAfter(e) {
    return this.isValid ? this.s > e : !1;
  }
  /**
   * Return whether this Interval's end is before the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isBefore(e) {
    return this.isValid ? this.e <= e : !1;
  }
  /**
   * Return whether this Interval contains the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  contains(e) {
    return this.isValid ? this.s <= e && this.e > e : !1;
  }
  /**
   * "Sets" the start and/or end dates. Returns a newly-constructed Interval.
   * @param {Object} values - the values to set
   * @param {DateTime} values.start - the starting DateTime
   * @param {DateTime} values.end - the ending DateTime
   * @return {Interval}
   */
  set({ start: e, end: t } = {}) {
    return this.isValid ? W.fromDateTimes(e || this.s, t || this.e) : this;
  }
  /**
   * Split this Interval at each of the specified DateTimes
   * @param {...DateTime} dateTimes - the unit of time to count.
   * @return {Array}
   */
  splitAt(...e) {
    if (!this.isValid)
      return [];
    const t = e.map(ri).filter((n) => this.contains(n)).sort(), r = [];
    let { s } = this, o = 0;
    for (; s < this.e; ) {
      const n = t[o] || this.e, a = +n > +this.e ? this.e : n;
      r.push(W.fromDateTimes(s, a)), s = a, o += 1;
    }
    return r;
  }
  /**
   * Split this Interval into smaller Intervals, each of the specified length.
   * Left over time is grouped into a smaller interval
   * @param {Duration|Object|number} duration - The length of each resulting interval.
   * @return {Array}
   */
  splitBy(e) {
    const t = I.fromDurationLike(e);
    if (!this.isValid || !t.isValid || t.as("milliseconds") === 0)
      return [];
    let { s: r } = this, s = 1, o;
    const n = [];
    for (; r < this.e; ) {
      const a = this.start.plus(t.mapUnits((l) => l * s));
      o = +a > +this.e ? this.e : a, n.push(W.fromDateTimes(r, o)), r = o, s += 1;
    }
    return n;
  }
  /**
   * Split this Interval into the specified number of smaller intervals.
   * @param {number} numberOfParts - The number of Intervals to divide the Interval into.
   * @return {Array}
   */
  divideEqually(e) {
    return this.isValid ? this.splitBy(this.length() / e).slice(0, e) : [];
  }
  /**
   * Return whether this Interval overlaps with the specified Interval
   * @param {Interval} other
   * @return {boolean}
   */
  overlaps(e) {
    return this.e > e.s && this.s < e.e;
  }
  /**
   * Return whether this Interval's end is adjacent to the specified Interval's start.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsStart(e) {
    return this.isValid ? +this.e == +e.s : !1;
  }
  /**
   * Return whether this Interval's start is adjacent to the specified Interval's end.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsEnd(e) {
    return this.isValid ? +e.e == +this.s : !1;
  }
  /**
   * Return whether this Interval engulfs the start and end of the specified Interval.
   * @param {Interval} other
   * @return {boolean}
   */
  engulfs(e) {
    return this.isValid ? this.s <= e.s && this.e >= e.e : !1;
  }
  /**
   * Return whether this Interval has the same start and end as the specified Interval.
   * @param {Interval} other
   * @return {boolean}
   */
  equals(e) {
    return !this.isValid || !e.isValid ? !1 : this.s.equals(e.s) && this.e.equals(e.e);
  }
  /**
   * Return an Interval representing the intersection of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.
   * Returns null if the intersection is empty, meaning, the intervals don't intersect.
   * @param {Interval} other
   * @return {Interval}
   */
  intersection(e) {
    if (!this.isValid)
      return this;
    const t = this.s > e.s ? this.s : e.s, r = this.e < e.e ? this.e : e.e;
    return t >= r ? null : W.fromDateTimes(t, r);
  }
  /**
   * Return an Interval representing the union of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.
   * @param {Interval} other
   * @return {Interval}
   */
  union(e) {
    if (!this.isValid)
      return this;
    const t = this.s < e.s ? this.s : e.s, r = this.e > e.e ? this.e : e.e;
    return W.fromDateTimes(t, r);
  }
  /**
   * Merge an array of Intervals into a equivalent minimal set of Intervals.
   * Combines overlapping and adjacent Intervals.
   * @param {Array} intervals
   * @return {Array}
   */
  static merge(e) {
    const [t, r] = e.sort((s, o) => s.s - o.s).reduce(
      ([s, o], n) => o ? o.overlaps(n) || o.abutsStart(n) ? [s, o.union(n)] : [s.concat([o]), n] : [s, n],
      [[], null]
    );
    return r && t.push(r), t;
  }
  /**
   * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.
   * @param {Array} intervals
   * @return {Array}
   */
  static xor(e) {
    let t = null, r = 0;
    const s = [], o = e.map((l) => [
      { time: l.s, type: "s" },
      { time: l.e, type: "e" }
    ]), n = Array.prototype.concat(...o), a = n.sort((l, c) => l.time - c.time);
    for (const l of a)
      r += l.type === "s" ? 1 : -1, r === 1 ? t = l.time : (t && +t != +l.time && s.push(W.fromDateTimes(t, l.time)), t = null);
    return W.merge(s);
  }
  /**
   * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.
   * @param {...Interval} intervals
   * @return {Array}
   */
  difference(...e) {
    return W.xor([this].concat(e)).map((t) => this.intersection(t)).filter((t) => t && !t.isEmpty());
  }
  /**
   * Returns a string representation of this Interval appropriate for debugging.
   * @return {string}
   */
  toString() {
    return this.isValid ? `[${this.s.toISO()} – ${this.e.toISO()})` : ur;
  }
  /**
   * Returns a localized string representing this Interval. Accepts the same options as the
   * Intl.DateTimeFormat constructor and any presets defined by Luxon, such as
   * {@link DateTime.DATE_FULL} or {@link DateTime.TIME_SIMPLE}. The exact behavior of this method
   * is browser-specific, but in general it will return an appropriate representation of the
   * Interval in the assigned locale. Defaults to the system's locale if no locale has been
   * specified.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {Object} [formatOpts=DateTime.DATE_SHORT] - Either a DateTime preset or
   * Intl.DateTimeFormat constructor options.
   * @param {Object} opts - Options to override the configuration of the start DateTime.
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(); //=> 11/7/2022 – 11/8/2022
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL); //=> November 7 – 8, 2022
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL, { locale: 'fr-FR' }); //=> 7–8 novembre 2022
   * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString(DateTime.TIME_SIMPLE); //=> 6:00 – 8:00 PM
   * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> Mon, Nov 07, 6:00 – 8:00 p
   * @return {string}
   */
  toLocaleString(e = Gs, t = {}) {
    return this.isValid ? ie.create(this.s.loc.clone(t), e).formatInterval(this) : ur;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Interval.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISO(e) {
    return this.isValid ? `${this.s.toISO(e)}/${this.e.toISO(e)}` : ur;
  }
  /**
   * Returns an ISO 8601-compliant string representation of date of this Interval.
   * The time components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {string}
   */
  toISODate() {
    return this.isValid ? `${this.s.toISODate()}/${this.e.toISODate()}` : ur;
  }
  /**
   * Returns an ISO 8601-compliant string representation of time of this Interval.
   * The date components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISOTime(e) {
    return this.isValid ? `${this.s.toISOTime(e)}/${this.e.toISOTime(e)}` : ur;
  }
  /**
   * Returns a string representation of this Interval formatted according to the specified format
   * string. **You may not want this.** See {@link Interval#toLocaleString} for a more flexible
   * formatting tool.
   * @param {string} dateFormat - The format string. This string formats the start and end time.
   * See {@link DateTime#toFormat} for details.
   * @param {Object} opts - Options.
   * @param {string} [opts.separator =  ' – '] - A separator to place between the start and end
   * representations.
   * @return {string}
   */
  toFormat(e, { separator: t = " – " } = {}) {
    return this.isValid ? `${this.s.toFormat(e)}${t}${this.e.toFormat(e)}` : ur;
  }
  /**
   * Return a Duration representing the time spanned by this interval.
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }
   * @return {Duration}
   */
  toDuration(e, t) {
    return this.isValid ? this.e.diff(this.s, e, t) : I.invalid(this.invalidReason);
  }
  /**
   * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes
   * @param {function} mapFn
   * @return {Interval}
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))
   */
  mapEndpoints(e) {
    return W.fromDateTimes(e(this.s), e(this.e));
  }
}
class ms {
  /**
   * Return whether the specified zone contains a DST.
   * @param {string|Zone} [zone='local'] - Zone to check. Defaults to the environment's local zone.
   * @return {boolean}
   */
  static hasDST(e = K.defaultZone) {
    const t = w.now().setZone(e).set({ month: 12 });
    return !e.isUniversal && t.offset !== t.set({ month: 6 }).offset;
  }
  /**
   * Return whether the specified zone is a valid IANA specifier.
   * @param {string} zone - Zone to check
   * @return {boolean}
   */
  static isValidIANAZone(e) {
    return et.isValidZone(e);
  }
  /**
   * Converts the input into a {@link Zone} instance.
   *
   * * If `input` is already a Zone instance, it is returned unchanged.
   * * If `input` is a string containing a valid time zone name, a Zone instance
   *   with that name is returned.
   * * If `input` is a string that doesn't refer to a known time zone, a Zone
   *   instance with {@link Zone#isValid} == false is returned.
   * * If `input is a number, a Zone instance with the specified fixed offset
   *   in minutes is returned.
   * * If `input` is `null` or `undefined`, the default zone is returned.
   * @param {string|Zone|number} [input] - the value to be converted
   * @return {Zone}
   */
  static normalizeZone(e) {
    return mt(e, K.defaultZone);
  }
  /**
   * Return an array of standalone month names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @example Info.months()[0] //=> 'January'
   * @example Info.months('short')[0] //=> 'Jan'
   * @example Info.months('numeric')[0] //=> '1'
   * @example Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'
   * @example Info.months('numeric', { locale: 'ar' })[0] //=> '١'
   * @example Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabiʻ I'
   * @return {Array}
   */
  static months(e = "long", { locale: t = null, numberingSystem: r = null, locObj: s = null, outputCalendar: o = "gregory" } = {}) {
    return (s || V.create(t, r, o)).months(e);
  }
  /**
   * Return an array of format month names.
   * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that
   * changes the string.
   * See {@link Info#months}
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @return {Array}
   */
  static monthsFormat(e = "long", { locale: t = null, numberingSystem: r = null, locObj: s = null, outputCalendar: o = "gregory" } = {}) {
    return (s || V.create(t, r, o)).months(e, !0);
  }
  /**
   * Return an array of standalone week names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the weekday representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @example Info.weekdays()[0] //=> 'Monday'
   * @example Info.weekdays('short')[0] //=> 'Mon'
   * @example Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'
   * @example Info.weekdays('short', { locale: 'ar' })[0] //=> 'الاثنين'
   * @return {Array}
   */
  static weekdays(e = "long", { locale: t = null, numberingSystem: r = null, locObj: s = null } = {}) {
    return (s || V.create(t, r, null)).weekdays(e);
  }
  /**
   * Return an array of format week names.
   * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that
   * changes the string.
   * See {@link Info#weekdays}
   * @param {string} [length='long'] - the length of the month representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale=null] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @return {Array}
   */
  static weekdaysFormat(e = "long", { locale: t = null, numberingSystem: r = null, locObj: s = null } = {}) {
    return (s || V.create(t, r, null)).weekdays(e, !0);
  }
  /**
   * Return an array of meridiems.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.meridiems() //=> [ 'AM', 'PM' ]
   * @example Info.meridiems({ locale: 'my' }) //=> [ 'နံနက်', 'ညနေ' ]
   * @return {Array}
   */
  static meridiems({ locale: e = null } = {}) {
    return V.create(e).meridiems();
  }
  /**
   * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.
   * @param {string} [length='short'] - the length of the era representation, such as "short" or "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.eras() //=> [ 'BC', 'AD' ]
   * @example Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]
   * @example Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jésus-Christ', 'après Jésus-Christ' ]
   * @return {Array}
   */
  static eras(e = "short", { locale: t = null } = {}) {
    return V.create(t, null, "gregory").eras(e);
  }
  /**
   * Return the set of available features in this environment.
   * Some features of Luxon are not available in all environments. For example, on older browsers, relative time formatting support is not available. Use this function to figure out if that's the case.
   * Keys:
   * * `relative`: whether this environment supports relative time formatting
   * @example Info.features() //=> { relative: false }
   * @return {Object}
   */
  static features() {
    return { relative: Cp() };
  }
}
function Td(i, e) {
  const t = (s) => s.toUTC(0, { keepLocalTime: !0 }).startOf("day").valueOf(), r = t(e) - t(i);
  return Math.floor(I.fromMillis(r).as("days"));
}
function Qk(i, e, t) {
  const r = [
    ["years", (l, c) => c.year - l.year],
    ["quarters", (l, c) => c.quarter - l.quarter + (c.year - l.year) * 4],
    ["months", (l, c) => c.month - l.month + (c.year - l.year) * 12],
    [
      "weeks",
      (l, c) => {
        const d = Td(l, c);
        return (d - d % 7) / 7;
      }
    ],
    ["days", Td]
  ], s = {}, o = i;
  let n, a;
  for (const [l, c] of r)
    t.indexOf(l) >= 0 && (n = l, s[l] = c(i, e), a = o.plus(s), a > e ? (s[l]--, i = o.plus(s), i > e && (a = i, s[l]--, i = o.plus(s))) : i = a);
  return [i, s, a, n];
}
function Jk(i, e, t, r) {
  let [s, o, n, a] = Qk(i, e, t);
  const l = e - s, c = t.filter(
    (u) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(u) >= 0
  );
  c.length === 0 && (n < e && (n = s.plus({ [a]: 1 })), n !== s && (o[a] = (o[a] || 0) + l / (n - s)));
  const d = I.fromObject(o, r);
  return c.length > 0 ? I.fromMillis(l, r).shiftTo(...c).plus(d) : d;
}
const pl = {
  arab: "[٠-٩]",
  arabext: "[۰-۹]",
  bali: "[᭐-᭙]",
  beng: "[০-৯]",
  deva: "[०-९]",
  fullwide: "[０-９]",
  gujr: "[૦-૯]",
  hanidec: "[〇|一|二|三|四|五|六|七|八|九]",
  khmr: "[០-៩]",
  knda: "[೦-೯]",
  laoo: "[໐-໙]",
  limb: "[᥆-᥏]",
  mlym: "[൦-൯]",
  mong: "[᠐-᠙]",
  mymr: "[၀-၉]",
  orya: "[୦-୯]",
  tamldec: "[௦-௯]",
  telu: "[౦-౯]",
  thai: "[๐-๙]",
  tibt: "[༠-༩]",
  latn: "\\d"
}, Id = {
  arab: [1632, 1641],
  arabext: [1776, 1785],
  bali: [6992, 7001],
  beng: [2534, 2543],
  deva: [2406, 2415],
  fullwide: [65296, 65303],
  gujr: [2790, 2799],
  khmr: [6112, 6121],
  knda: [3302, 3311],
  laoo: [3792, 3801],
  limb: [6470, 6479],
  mlym: [3430, 3439],
  mong: [6160, 6169],
  mymr: [4160, 4169],
  orya: [2918, 2927],
  tamldec: [3046, 3055],
  telu: [3174, 3183],
  thai: [3664, 3673],
  tibt: [3872, 3881]
}, Xk = pl.hanidec.replace(/[\[|\]]/g, "").split("");
function e1(i) {
  let e = parseInt(i, 10);
  if (isNaN(e)) {
    e = "";
    for (let t = 0; t < i.length; t++) {
      const r = i.charCodeAt(t);
      if (i[t].search(pl.hanidec) !== -1)
        e += Xk.indexOf(i[t]);
      else
        for (const s in Id) {
          const [o, n] = Id[s];
          r >= o && r <= n && (e += r - o);
        }
    }
    return parseInt(e, 10);
  } else
    return e;
}
function Me({ numberingSystem: i }, e = "") {
  return new RegExp(`${pl[i || "latn"]}${e}`);
}
const t1 = "missing Intl.DateTimeFormat.formatToParts support";
function P(i, e = (t) => t) {
  return { regex: i, deser: ([t]) => e(e1(t)) };
}
const r1 = String.fromCharCode(160), Bp = `[ ${r1}]`, Up = new RegExp(Bp, "g");
function i1(i) {
  return i.replace(/\./g, "\\.?").replace(Up, Bp);
}
function Dd(i) {
  return i.replace(/\./g, "").replace(Up, " ").toLowerCase();
}
function ze(i, e) {
  return i === null ? null : {
    regex: RegExp(i.map(i1).join("|")),
    deser: ([t]) => i.findIndex((r) => Dd(t) === Dd(r)) + e
  };
}
function Od(i, e) {
  return { regex: i, deser: ([, t, r]) => So(t, r), groups: e };
}
function gs(i) {
  return { regex: i, deser: ([e]) => e };
}
function s1(i) {
  return i.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
}
function o1(i, e) {
  const t = Me(e), r = Me(e, "{2}"), s = Me(e, "{3}"), o = Me(e, "{4}"), n = Me(e, "{6}"), a = Me(e, "{1,2}"), l = Me(e, "{1,3}"), c = Me(e, "{1,6}"), d = Me(e, "{1,9}"), u = Me(e, "{2,4}"), h = Me(e, "{4,6}"), f = (v) => ({ regex: RegExp(s1(v.val)), deser: ([k]) => k, literal: !0 }), m = ((v) => {
    if (i.literal)
      return f(v);
    switch (v.val) {
      case "G":
        return ze(e.eras("short"), 0);
      case "GG":
        return ze(e.eras("long"), 0);
      case "y":
        return P(c);
      case "yy":
        return P(u, la);
      case "yyyy":
        return P(o);
      case "yyyyy":
        return P(h);
      case "yyyyyy":
        return P(n);
      case "M":
        return P(a);
      case "MM":
        return P(r);
      case "MMM":
        return ze(e.months("short", !0), 1);
      case "MMMM":
        return ze(e.months("long", !0), 1);
      case "L":
        return P(a);
      case "LL":
        return P(r);
      case "LLL":
        return ze(e.months("short", !1), 1);
      case "LLLL":
        return ze(e.months("long", !1), 1);
      case "d":
        return P(a);
      case "dd":
        return P(r);
      case "o":
        return P(l);
      case "ooo":
        return P(s);
      case "HH":
        return P(r);
      case "H":
        return P(a);
      case "hh":
        return P(r);
      case "h":
        return P(a);
      case "mm":
        return P(r);
      case "m":
        return P(a);
      case "q":
        return P(a);
      case "qq":
        return P(r);
      case "s":
        return P(a);
      case "ss":
        return P(r);
      case "S":
        return P(l);
      case "SSS":
        return P(s);
      case "u":
        return gs(d);
      case "uu":
        return gs(a);
      case "uuu":
        return P(t);
      case "a":
        return ze(e.meridiems(), 0);
      case "kkkk":
        return P(o);
      case "kk":
        return P(u, la);
      case "W":
        return P(a);
      case "WW":
        return P(r);
      case "E":
      case "c":
        return P(t);
      case "EEE":
        return ze(e.weekdays("short", !1), 1);
      case "EEEE":
        return ze(e.weekdays("long", !1), 1);
      case "ccc":
        return ze(e.weekdays("short", !0), 1);
      case "cccc":
        return ze(e.weekdays("long", !0), 1);
      case "Z":
      case "ZZ":
        return Od(new RegExp(`([+-]${a.source})(?::(${r.source}))?`), 2);
      case "ZZZ":
        return Od(new RegExp(`([+-]${a.source})(${r.source})?`), 2);
      case "z":
        return gs(/[a-z_+-/]{1,256}?/i);
      case " ":
        return gs(/[^\S\n\r]/);
      default:
        return f(v);
    }
  })(i) || {
    invalidReason: t1
  };
  return m.token = i, m;
}
const n1 = {
  year: {
    "2-digit": "yy",
    numeric: "yyyyy"
  },
  month: {
    numeric: "M",
    "2-digit": "MM",
    short: "MMM",
    long: "MMMM"
  },
  day: {
    numeric: "d",
    "2-digit": "dd"
  },
  weekday: {
    short: "EEE",
    long: "EEEE"
  },
  dayperiod: "a",
  dayPeriod: "a",
  hour12: {
    numeric: "h",
    "2-digit": "hh"
  },
  hour24: {
    numeric: "H",
    "2-digit": "HH"
  },
  minute: {
    numeric: "m",
    "2-digit": "mm"
  },
  second: {
    numeric: "s",
    "2-digit": "ss"
  },
  timeZoneName: {
    long: "ZZZZZ",
    short: "ZZZ"
  }
};
function a1(i, e, t) {
  const { type: r, value: s } = i;
  if (r === "literal") {
    const l = /^\s+$/.test(s);
    return {
      literal: !l,
      val: l ? " " : s
    };
  }
  const o = e[r];
  let n = r;
  r === "hour" && (e.hour12 != null ? n = e.hour12 ? "hour12" : "hour24" : e.hourCycle != null ? e.hourCycle === "h11" || e.hourCycle === "h12" ? n = "hour12" : n = "hour24" : n = t.hour12 ? "hour12" : "hour24");
  let a = n1[n];
  if (typeof a == "object" && (a = a[o]), a)
    return {
      literal: !1,
      val: a
    };
}
function l1(i) {
  return [`^${i.map((e) => e.regex).reduce((e, t) => `${e}(${t.source})`, "")}$`, i];
}
function c1(i, e, t) {
  const r = i.match(e);
  if (r) {
    const s = {};
    let o = 1;
    for (const n in t)
      if ($r(t, n)) {
        const a = t[n], l = a.groups ? a.groups + 1 : 1;
        !a.literal && a.token && (s[a.token.val[0]] = a.deser(r.slice(o, o + l))), o += l;
      }
    return [r, s];
  } else
    return [r, {}];
}
function d1(i) {
  const e = (s) => {
    switch (s) {
      case "S":
        return "millisecond";
      case "s":
        return "second";
      case "m":
        return "minute";
      case "h":
      case "H":
        return "hour";
      case "d":
        return "day";
      case "o":
        return "ordinal";
      case "L":
      case "M":
        return "month";
      case "y":
        return "year";
      case "E":
      case "c":
        return "weekday";
      case "W":
        return "weekNumber";
      case "k":
        return "weekYear";
      case "q":
        return "quarter";
      default:
        return null;
    }
  };
  let t = null, r;
  return S(i.z) || (t = et.create(i.z)), S(i.Z) || (t || (t = new ne(i.Z)), r = i.Z), S(i.q) || (i.M = (i.q - 1) * 3 + 1), S(i.h) || (i.h < 12 && i.a === 1 ? i.h += 12 : i.h === 12 && i.a === 0 && (i.h = 0)), i.G === 0 && i.y && (i.y = -i.y), S(i.u) || (i.S = cl(i.u)), [Object.keys(i).reduce((s, o) => {
    const n = e(o);
    return n && (s[n] = i[o]), s;
  }, {}), t, r];
}
let _n = null;
function u1() {
  return _n || (_n = w.fromMillis(1555555555555)), _n;
}
function h1(i, e) {
  if (i.literal)
    return i;
  const t = ie.macroTokenToFormatOpts(i.val), r = jp(t, e);
  return r == null || r.includes(void 0) ? i : r;
}
function qp(i, e) {
  return Array.prototype.concat(...i.map((t) => h1(t, e)));
}
function Wp(i, e, t) {
  const r = qp(ie.parseFormat(t), i), s = r.map((n) => o1(n, i)), o = s.find((n) => n.invalidReason);
  if (o)
    return { input: e, tokens: r, invalidReason: o.invalidReason };
  {
    const [n, a] = l1(s), l = RegExp(n, "i"), [c, d] = c1(e, l, a), [u, h, f] = d ? d1(d) : [null, null, void 0];
    if ($r(d, "a") && $r(d, "H"))
      throw new li(
        "Can't include meridiem when specifying 24-hour format"
      );
    return { input: e, tokens: r, regex: l, rawMatches: c, matches: d, result: u, zone: h, specificOffset: f };
  }
}
function f1(i, e, t) {
  const { result: r, zone: s, specificOffset: o, invalidReason: n } = Wp(i, e, t);
  return [r, s, o, n];
}
function jp(i, e) {
  if (!i)
    return null;
  const t = ie.create(e, i).dtFormatter(u1()), r = t.formatToParts(), s = t.resolvedOptions();
  return r.map((o) => a1(o, i, s));
}
const Gp = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334], Yp = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
function Ae(i, e) {
  return new Fe(
    "unit out of range",
    `you specified ${e} (of type ${typeof e}) as a ${i}, which is invalid`
  );
}
function Zp(i, e, t) {
  const r = new Date(Date.UTC(i, e - 1, t));
  i < 100 && i >= 0 && r.setUTCFullYear(r.getUTCFullYear() - 1900);
  const s = r.getUTCDay();
  return s === 0 ? 7 : s;
}
function Kp(i, e, t) {
  return t + (Qi(i) ? Yp : Gp)[e - 1];
}
function Qp(i, e) {
  const t = Qi(i) ? Yp : Gp, r = t.findIndex((o) => o < e), s = e - t[r];
  return { month: r + 1, day: s };
}
function ca(i) {
  const { year: e, month: t, day: r } = i, s = Kp(e, t, r), o = Zp(e, t, r);
  let n = Math.floor((s - o + 10) / 7), a;
  return n < 1 ? (a = e - 1, n = Zs(a)) : n > Zs(e) ? (a = e + 1, n = 1) : a = e, { weekYear: a, weekNumber: n, weekday: o, ...To(i) };
}
function $d(i) {
  const { weekYear: e, weekNumber: t, weekday: r } = i, s = Zp(e, 1, 4), o = yi(e);
  let n = t * 7 + r - s - 3, a;
  n < 1 ? (a = e - 1, n += yi(a)) : n > o ? (a = e + 1, n -= yi(e)) : a = e;
  const { month: l, day: c } = Qp(a, n);
  return { year: a, month: l, day: c, ...To(i) };
}
function bn(i) {
  const { year: e, month: t, day: r } = i, s = Kp(e, t, r);
  return { year: e, ordinal: s, ...To(i) };
}
function Pd(i) {
  const { year: e, ordinal: t } = i, { month: r, day: s } = Qp(e, t);
  return { year: e, month: r, day: s, ...To(i) };
}
function p1(i) {
  const e = Ao(i.weekYear), t = Qe(i.weekNumber, 1, Zs(i.weekYear)), r = Qe(i.weekday, 1, 7);
  return e ? t ? r ? !1 : Ae("weekday", i.weekday) : Ae("week", i.week) : Ae("weekYear", i.weekYear);
}
function m1(i) {
  const e = Ao(i.year), t = Qe(i.ordinal, 1, yi(i.year));
  return e ? t ? !1 : Ae("ordinal", i.ordinal) : Ae("year", i.year);
}
function Jp(i) {
  const e = Ao(i.year), t = Qe(i.month, 1, 12), r = Qe(i.day, 1, Ys(i.year, i.month));
  return e ? t ? r ? !1 : Ae("day", i.day) : Ae("month", i.month) : Ae("year", i.year);
}
function Xp(i) {
  const { hour: e, minute: t, second: r, millisecond: s } = i, o = Qe(e, 0, 23) || e === 24 && t === 0 && r === 0 && s === 0, n = Qe(t, 0, 59), a = Qe(r, 0, 59), l = Qe(s, 0, 999);
  return o ? n ? a ? l ? !1 : Ae("millisecond", s) : Ae("second", r) : Ae("minute", t) : Ae("hour", e);
}
const yn = "Invalid DateTime", Md = 864e13;
function _s(i) {
  return new Fe("unsupported zone", `the zone "${i.name}" is not supported`);
}
function vn(i) {
  return i.weekData === null && (i.weekData = ca(i.c)), i.weekData;
}
function zt(i, e) {
  const t = {
    ts: i.ts,
    zone: i.zone,
    c: i.c,
    o: i.o,
    loc: i.loc,
    invalid: i.invalid
  };
  return new w({ ...t, ...e, old: t });
}
function em(i, e, t) {
  let r = i - e * 60 * 1e3;
  const s = t.offset(r);
  if (e === s)
    return [r, e];
  r -= (s - e) * 60 * 1e3;
  const o = t.offset(r);
  return s === o ? [r, s] : [i - Math.min(s, o) * 60 * 1e3, Math.max(s, o)];
}
function bs(i, e) {
  i += e * 60 * 1e3;
  const t = new Date(i);
  return {
    year: t.getUTCFullYear(),
    month: t.getUTCMonth() + 1,
    day: t.getUTCDate(),
    hour: t.getUTCHours(),
    minute: t.getUTCMinutes(),
    second: t.getUTCSeconds(),
    millisecond: t.getUTCMilliseconds()
  };
}
function Is(i, e, t) {
  return em(Eo(i), e, t);
}
function zd(i, e) {
  const t = i.o, r = i.c.year + Math.trunc(e.years), s = i.c.month + Math.trunc(e.months) + Math.trunc(e.quarters) * 3, o = {
    ...i.c,
    year: r,
    month: s,
    day: Math.min(i.c.day, Ys(r, s)) + Math.trunc(e.days) + Math.trunc(e.weeks) * 7
  }, n = I.fromObject({
    years: e.years - Math.trunc(e.years),
    quarters: e.quarters - Math.trunc(e.quarters),
    months: e.months - Math.trunc(e.months),
    weeks: e.weeks - Math.trunc(e.weeks),
    days: e.days - Math.trunc(e.days),
    hours: e.hours,
    minutes: e.minutes,
    seconds: e.seconds,
    milliseconds: e.milliseconds
  }).as("milliseconds"), a = Eo(o);
  let [l, c] = em(a, t, i.zone);
  return n !== 0 && (l += n, c = i.zone.offset(l)), { ts: l, o: c };
}
function ti(i, e, t, r, s, o) {
  const { setZone: n, zone: a } = t;
  if (i && Object.keys(i).length !== 0 || e) {
    const l = e || a, c = w.fromObject(i, {
      ...t,
      zone: l,
      specificOffset: o
    });
    return n ? c : c.setZone(a);
  } else
    return w.invalid(
      new Fe("unparsable", `the input "${s}" can't be parsed as ${r}`)
    );
}
function ys(i, e, t = !0) {
  return i.isValid ? ie.create(V.create("en-US"), {
    allowZ: t,
    forceSimple: !0
  }).formatDateTimeFromString(i, e) : null;
}
function wn(i, e) {
  const t = i.c.year > 9999 || i.c.year < 0;
  let r = "";
  return t && i.c.year >= 0 && (r += "+"), r += J(i.c.year, t ? 6 : 4), e ? (r += "-", r += J(i.c.month), r += "-", r += J(i.c.day)) : (r += J(i.c.month), r += J(i.c.day)), r;
}
function Nd(i, e, t, r, s, o) {
  let n = J(i.c.hour);
  return e ? (n += ":", n += J(i.c.minute), (i.c.millisecond !== 0 || i.c.second !== 0 || !t) && (n += ":")) : n += J(i.c.minute), (i.c.millisecond !== 0 || i.c.second !== 0 || !t) && (n += J(i.c.second), (i.c.millisecond !== 0 || !r) && (n += ".", n += J(i.c.millisecond, 3))), s && (i.isOffsetFixed && i.offset === 0 && !o ? n += "Z" : i.o < 0 ? (n += "-", n += J(Math.trunc(-i.o / 60)), n += ":", n += J(Math.trunc(-i.o % 60))) : (n += "+", n += J(Math.trunc(i.o / 60)), n += ":", n += J(Math.trunc(i.o % 60)))), o && (n += "[" + i.zone.ianaName + "]"), n;
}
const tm = {
  month: 1,
  day: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
}, g1 = {
  weekNumber: 1,
  weekday: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
}, _1 = {
  ordinal: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
}, rm = ["year", "month", "day", "hour", "minute", "second", "millisecond"], b1 = [
  "weekYear",
  "weekNumber",
  "weekday",
  "hour",
  "minute",
  "second",
  "millisecond"
], y1 = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
function Fd(i) {
  const e = {
    year: "year",
    years: "year",
    month: "month",
    months: "month",
    day: "day",
    days: "day",
    hour: "hour",
    hours: "hour",
    minute: "minute",
    minutes: "minute",
    quarter: "quarter",
    quarters: "quarter",
    second: "second",
    seconds: "second",
    millisecond: "millisecond",
    milliseconds: "millisecond",
    weekday: "weekday",
    weekdays: "weekday",
    weeknumber: "weekNumber",
    weeksnumber: "weekNumber",
    weeknumbers: "weekNumber",
    weekyear: "weekYear",
    weekyears: "weekYear",
    ordinal: "ordinal"
  }[i.toLowerCase()];
  if (!e)
    throw new ip(i);
  return e;
}
function Rd(i, e) {
  const t = mt(e.zone, K.defaultZone), r = V.fromObject(e), s = K.now();
  let o, n;
  if (S(i.year))
    o = s;
  else {
    for (const c of rm)
      S(i[c]) && (i[c] = tm[c]);
    const a = Jp(i) || Xp(i);
    if (a)
      return w.invalid(a);
    const l = t.offset(s);
    [o, n] = Is(i, l, t);
  }
  return new w({ ts: o, zone: t, loc: r, o: n });
}
function Ld(i, e, t) {
  const r = S(t.round) ? !0 : t.round, s = (n, a) => (n = dl(n, r || t.calendary ? 0 : 2, !0), e.loc.clone(t).relFormatter(t).format(n, a)), o = (n) => t.calendary ? e.hasSame(i, n) ? 0 : e.startOf(n).diff(i.startOf(n), n).get(n) : e.diff(i, n).get(n);
  if (t.unit)
    return s(o(t.unit), t.unit);
  for (const n of t.units) {
    const a = o(n);
    if (Math.abs(a) >= 1)
      return s(a, n);
  }
  return s(i > e ? -0 : 0, t.units[t.units.length - 1]);
}
function Vd(i) {
  let e = {}, t;
  return i.length > 0 && typeof i[i.length - 1] == "object" ? (e = i[i.length - 1], t = Array.from(i).slice(0, i.length - 1)) : t = Array.from(i), [e, t];
}
class w {
  /**
   * @access private
   */
  constructor(e) {
    const t = e.zone || K.defaultZone;
    let r = e.invalid || (Number.isNaN(e.ts) ? new Fe("invalid input") : null) || (t.isValid ? null : _s(t));
    this.ts = S(e.ts) ? K.now() : e.ts;
    let s = null, o = null;
    if (!r)
      if (e.old && e.old.ts === this.ts && e.old.zone.equals(t))
        [s, o] = [e.old.c, e.old.o];
      else {
        const n = t.offset(this.ts);
        s = bs(this.ts, n), r = Number.isNaN(s.year) ? new Fe("invalid input") : null, s = r ? null : s, o = r ? null : n;
      }
    this._zone = t, this.loc = e.loc || V.create(), this.invalid = r, this.weekData = null, this.c = s, this.o = o, this.isLuxonDateTime = !0;
  }
  // CONSTRUCT
  /**
   * Create a DateTime for the current instant, in the system's time zone.
   *
   * Use Settings to override these default values if needed.
   * @example DateTime.now().toISO() //~> now in the ISO format
   * @return {DateTime}
   */
  static now() {
    return new w({});
  }
  /**
   * Create a local DateTime
   * @param {number} [year] - The calendar year. If omitted (as in, call `local()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month, 1-indexed
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @example DateTime.local()                                  //~> now
   * @example DateTime.local({ zone: "America/New_York" })      //~> now, in US east coast time
   * @example DateTime.local(2017)                              //~> 2017-01-01T00:00:00
   * @example DateTime.local(2017, 3)                           //~> 2017-03-01T00:00:00
   * @example DateTime.local(2017, 3, 12, { locale: "fr" })     //~> 2017-03-12T00:00:00, with a French locale
   * @example DateTime.local(2017, 3, 12, 5)                    //~> 2017-03-12T05:00:00
   * @example DateTime.local(2017, 3, 12, 5, { zone: "utc" })   //~> 2017-03-12T05:00:00, in UTC
   * @example DateTime.local(2017, 3, 12, 5, 45)                //~> 2017-03-12T05:45:00
   * @example DateTime.local(2017, 3, 12, 5, 45, 10)            //~> 2017-03-12T05:45:10
   * @example DateTime.local(2017, 3, 12, 5, 45, 10, 765)       //~> 2017-03-12T05:45:10.765
   * @return {DateTime}
   */
  static local() {
    const [e, t] = Vd(arguments), [r, s, o, n, a, l, c] = t;
    return Rd({ year: r, month: s, day: o, hour: n, minute: a, second: l, millisecond: c }, e);
  }
  /**
   * Create a DateTime in UTC
   * @param {number} [year] - The calendar year. If omitted (as in, call `utc()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @param {Object} options - configuration options for the DateTime
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} [options.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [options.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @example DateTime.utc()                                              //~> now
   * @example DateTime.utc(2017)                                          //~> 2017-01-01T00:00:00Z
   * @example DateTime.utc(2017, 3)                                       //~> 2017-03-01T00:00:00Z
   * @example DateTime.utc(2017, 3, 12)                                   //~> 2017-03-12T00:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5)                                //~> 2017-03-12T05:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45)                            //~> 2017-03-12T05:45:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, { locale: "fr" })          //~> 2017-03-12T05:45:00Z with a French locale
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10)                        //~> 2017-03-12T05:45:10Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10, 765, { locale: "fr" }) //~> 2017-03-12T05:45:10.765Z with a French locale
   * @return {DateTime}
   */
  static utc() {
    const [e, t] = Vd(arguments), [r, s, o, n, a, l, c] = t;
    return e.zone = ne.utcInstance, Rd({ year: r, month: s, day: o, hour: n, minute: a, second: l, millisecond: c }, e);
  }
  /**
   * Create a DateTime from a JavaScript Date object. Uses the default zone.
   * @param {Date} date - a JavaScript Date object
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @return {DateTime}
   */
  static fromJSDate(e, t = {}) {
    const r = jC(e) ? e.valueOf() : NaN;
    if (Number.isNaN(r))
      return w.invalid("invalid input");
    const s = mt(t.zone, K.defaultZone);
    return s.isValid ? new w({
      ts: r,
      zone: s,
      loc: V.fromObject(t)
    }) : w.invalid(_s(s));
  }
  /**
   * Create a DateTime from a number of milliseconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} milliseconds - a number of milliseconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromMillis(e, t = {}) {
    if (Gt(e))
      return e < -Md || e > Md ? w.invalid("Timestamp out of range") : new w({
        ts: e,
        zone: mt(t.zone, K.defaultZone),
        loc: V.fromObject(t)
      });
    throw new Ce(
      `fromMillis requires a numerical input, but received a ${typeof e} with value ${e}`
    );
  }
  /**
   * Create a DateTime from a number of seconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} seconds - a number of seconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromSeconds(e, t = {}) {
    if (Gt(e))
      return new w({
        ts: e * 1e3,
        zone: mt(t.zone, K.defaultZone),
        loc: V.fromObject(t)
      });
    throw new Ce("fromSeconds requires a numerical input");
  }
  /**
   * Create a DateTime from a JavaScript object with keys like 'year' and 'hour' with reasonable defaults.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.year - a year, such as 1987
   * @param {number} obj.month - a month, 1-12
   * @param {number} obj.day - a day of the month, 1-31, depending on the month
   * @param {number} obj.ordinal - day of the year, 1-365 or 366
   * @param {number} obj.weekYear - an ISO week year
   * @param {number} obj.weekNumber - an ISO week number, between 1 and 52 or 53, depending on the year
   * @param {number} obj.weekday - an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday
   * @param {number} obj.hour - hour of the day, 0-23
   * @param {number} obj.minute - minute of the hour, 0-59
   * @param {number} obj.second - second of the minute, 0-59
   * @param {number} obj.millisecond - millisecond of the second, 0-999
   * @param {Object} opts - options for creating this DateTime
   * @param {string|Zone} [opts.zone='local'] - interpret the numbers in the context of a particular zone. Can take any value taken as the first argument to setZone()
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'
   * @example DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'utc' }),
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'local' })
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'America/New_York' })
   * @example DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'
   * @return {DateTime}
   */
  static fromObject(e, t = {}) {
    e = e || {};
    const r = mt(t.zone, K.defaultZone);
    if (!r.isValid)
      return w.invalid(_s(r));
    const s = K.now(), o = S(t.specificOffset) ? r.offset(s) : t.specificOffset, n = Ks(e, Fd), a = !S(n.ordinal), l = !S(n.year), c = !S(n.month) || !S(n.day), d = l || c, u = n.weekYear || n.weekNumber, h = V.fromObject(t);
    if ((d || a) && u)
      throw new li(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    if (c && a)
      throw new li("Can't mix ordinal dates with month/day");
    const f = u || n.weekday && !d;
    let m, v, k = bs(s, o);
    f ? (m = b1, v = g1, k = ca(k)) : a ? (m = y1, v = _1, k = bn(k)) : (m = rm, v = tm);
    let M = !1;
    for (const De of m) {
      const Io = n[De];
      S(Io) ? M ? n[De] = v[De] : n[De] = k[De] : M = !0;
    }
    const F = f ? p1(n) : a ? m1(n) : Jp(n), se = F || Xp(n);
    if (se)
      return w.invalid(se);
    const he = f ? $d(n) : a ? Pd(n) : n, [j, Ie] = Is(he, o, r), je = new w({
      ts: j,
      zone: r,
      o: Ie,
      loc: h
    });
    return n.weekday && d && e.weekday !== je.weekday ? w.invalid(
      "mismatched weekday",
      `you can't specify both a weekday of ${n.weekday} and a date of ${je.toISO()}`
    ) : je;
  }
  /**
   * Create a DateTime from an ISO 8601 string
   * @param {string} text - the ISO string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the time to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} [opts.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [opts.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromISO('2016-05-25T09:08:34.123')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})
   * @example DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})
   * @example DateTime.fromISO('2016-W05-4')
   * @return {DateTime}
   */
  static fromISO(e, t = {}) {
    const [r, s] = zk(e);
    return ti(r, s, t, "ISO 8601", e);
  }
  /**
   * Create a DateTime from an RFC 2822 string
   * @param {string} text - the RFC 2822 string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since the offset is always specified in the string itself, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')
   * @example DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23 Z')
   * @return {DateTime}
   */
  static fromRFC2822(e, t = {}) {
    const [r, s] = Nk(e);
    return ti(r, s, t, "RFC 2822", e);
  }
  /**
   * Create a DateTime from an HTTP header date
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @param {string} text - the HTTP header date
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since HTTP dates are always in UTC, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with the fixed-offset zone specified in the string. For HTTP dates, this is always UTC, so this option is equivalent to setting the `zone` option to 'utc', but this option is included for consistency with similar methods.
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sun Nov  6 08:49:37 1994')
   * @return {DateTime}
   */
  static fromHTTP(e, t = {}) {
    const [r, s] = Fk(e);
    return ti(r, s, t, "HTTP", t);
  }
  /**
   * Create a DateTime from an input string and format string.
   * Defaults to en-US if no locale has been specified, regardless of the system's locale. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/parsing?id=table-of-tokens).
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see the link below for the formats)
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromFormat(e, t, r = {}) {
    if (S(e) || S(t))
      throw new Ce("fromFormat requires an input string and a format");
    const { locale: s = null, numberingSystem: o = null } = r, n = V.fromOpts({
      locale: s,
      numberingSystem: o,
      defaultToEN: !0
    }), [a, l, c, d] = f1(n, e, t);
    return d ? w.invalid(d) : ti(a, l, r, `format ${t}`, e, c);
  }
  /**
   * @deprecated use fromFormat instead
   */
  static fromString(e, t, r = {}) {
    return w.fromFormat(e, t, r);
  }
  /**
   * Create a DateTime from a SQL date, time, or datetime
   * Defaults to en-US if no locale has been specified, regardless of the system's locale
   * @param {string} text - the string to parse
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @example DateTime.fromSQL('2017-05-15')
   * @example DateTime.fromSQL('2017-05-15 09:12:34')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })
   * @example DateTime.fromSQL('09:12:34.342')
   * @return {DateTime}
   */
  static fromSQL(e, t = {}) {
    const [r, s] = qk(e);
    return ti(r, s, t, "SQL", e);
  }
  /**
   * Create an invalid DateTime.
   * @param {string} reason - simple string of why this DateTime is invalid. Should not contain parameters or anything else data-dependent.
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {DateTime}
   */
  static invalid(e, t = null) {
    if (!e)
      throw new Ce("need to specify a reason the DateTime is invalid");
    const r = e instanceof Fe ? e : new Fe(e, t);
    if (K.throwOnInvalid)
      throw new CC(r);
    return new w({ invalid: r });
  }
  /**
   * Check if an object is an instance of DateTime. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDateTime(e) {
    return e && e.isLuxonDateTime || !1;
  }
  /**
   * Produce the format string for a set of options
   * @param formatOpts
   * @param localeOpts
   * @returns {string}
   */
  static parseFormatForOpts(e, t = {}) {
    const r = jp(e, V.fromObject(t));
    return r ? r.map((s) => s ? s.val : null).join("") : null;
  }
  /**
   * Produce the the fully expanded format token for the locale
   * Does NOT quote characters, so quoted tokens will not round trip correctly
   * @param fmt
   * @param localeOpts
   * @returns {string}
   */
  static expandFormat(e, t = {}) {
    return qp(ie.parseFormat(e), V.fromObject(t)).map((r) => r.val).join("");
  }
  // INFO
  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example DateTime.local(2017, 7, 4).get('month'); //=> 7
   * @example DateTime.local(2017, 7, 4).get('day'); //=> 4
   * @return {number}
   */
  get(e) {
    return this[e];
  }
  /**
   * Returns whether the DateTime is valid. Invalid DateTimes occur when:
   * * The DateTime was created from invalid calendar information, such as the 13th month or February 30
   * * The DateTime was created by an operation on another invalid date
   * @type {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }
  /**
   * Returns an error code if this DateTime is invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime
   *
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  /**
   * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  /**
   * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime
   *
   * @type {string}
   */
  get outputCalendar() {
    return this.isValid ? this.loc.outputCalendar : null;
  }
  /**
   * Get the time zone associated with this DateTime.
   * @type {Zone}
   */
  get zone() {
    return this._zone;
  }
  /**
   * Get the name of the time zone.
   * @type {string}
   */
  get zoneName() {
    return this.isValid ? this.zone.name : null;
  }
  /**
   * Get the year
   * @example DateTime.local(2017, 5, 25).year //=> 2017
   * @type {number}
   */
  get year() {
    return this.isValid ? this.c.year : NaN;
  }
  /**
   * Get the quarter
   * @example DateTime.local(2017, 5, 25).quarter //=> 2
   * @type {number}
   */
  get quarter() {
    return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
  }
  /**
   * Get the month (1-12).
   * @example DateTime.local(2017, 5, 25).month //=> 5
   * @type {number}
   */
  get month() {
    return this.isValid ? this.c.month : NaN;
  }
  /**
   * Get the day of the month (1-30ish).
   * @example DateTime.local(2017, 5, 25).day //=> 25
   * @type {number}
   */
  get day() {
    return this.isValid ? this.c.day : NaN;
  }
  /**
   * Get the hour of the day (0-23).
   * @example DateTime.local(2017, 5, 25, 9).hour //=> 9
   * @type {number}
   */
  get hour() {
    return this.isValid ? this.c.hour : NaN;
  }
  /**
   * Get the minute of the hour (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30).minute //=> 30
   * @type {number}
   */
  get minute() {
    return this.isValid ? this.c.minute : NaN;
  }
  /**
   * Get the second of the minute (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52
   * @type {number}
   */
  get second() {
    return this.isValid ? this.c.second : NaN;
  }
  /**
   * Get the millisecond of the second (0-999).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654
   * @type {number}
   */
  get millisecond() {
    return this.isValid ? this.c.millisecond : NaN;
  }
  /**
   * Get the week year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 12, 31).weekYear //=> 2015
   * @type {number}
   */
  get weekYear() {
    return this.isValid ? vn(this).weekYear : NaN;
  }
  /**
   * Get the week number of the week year (1-52ish).
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2017, 5, 25).weekNumber //=> 21
   * @type {number}
   */
  get weekNumber() {
    return this.isValid ? vn(this).weekNumber : NaN;
  }
  /**
   * Get the day of the week.
   * 1 is Monday and 7 is Sunday
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 11, 31).weekday //=> 4
   * @type {number}
   */
  get weekday() {
    return this.isValid ? vn(this).weekday : NaN;
  }
  /**
   * Get the ordinal (meaning the day of the year)
   * @example DateTime.local(2017, 5, 25).ordinal //=> 145
   * @type {number|DateTime}
   */
  get ordinal() {
    return this.isValid ? bn(this.c).ordinal : NaN;
  }
  /**
   * Get the human readable short month name, such as 'Oct'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthShort //=> Oct
   * @type {string}
   */
  get monthShort() {
    return this.isValid ? ms.months("short", { locObj: this.loc })[this.month - 1] : null;
  }
  /**
   * Get the human readable long month name, such as 'October'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthLong //=> October
   * @type {string}
   */
  get monthLong() {
    return this.isValid ? ms.months("long", { locObj: this.loc })[this.month - 1] : null;
  }
  /**
   * Get the human readable short weekday, such as 'Mon'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayShort //=> Mon
   * @type {string}
   */
  get weekdayShort() {
    return this.isValid ? ms.weekdays("short", { locObj: this.loc })[this.weekday - 1] : null;
  }
  /**
   * Get the human readable long weekday, such as 'Monday'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayLong //=> Monday
   * @type {string}
   */
  get weekdayLong() {
    return this.isValid ? ms.weekdays("long", { locObj: this.loc })[this.weekday - 1] : null;
  }
  /**
   * Get the UTC offset of this DateTime in minutes
   * @example DateTime.now().offset //=> -240
   * @example DateTime.utc().offset //=> 0
   * @type {number}
   */
  get offset() {
    return this.isValid ? +this.o : NaN;
  }
  /**
   * Get the short human name for the zone's current offset, for example "EST" or "EDT".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameShort() {
    return this.isValid ? this.zone.offsetName(this.ts, {
      format: "short",
      locale: this.locale
    }) : null;
  }
  /**
   * Get the long human name for the zone's current offset, for example "Eastern Standard Time" or "Eastern Daylight Time".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameLong() {
    return this.isValid ? this.zone.offsetName(this.ts, {
      format: "long",
      locale: this.locale
    }) : null;
  }
  /**
   * Get whether this zone's offset ever changes, as in a DST.
   * @type {boolean}
   */
  get isOffsetFixed() {
    return this.isValid ? this.zone.isUniversal : null;
  }
  /**
   * Get whether the DateTime is in a DST.
   * @type {boolean}
   */
  get isInDST() {
    return this.isOffsetFixed ? !1 : this.offset > this.set({ month: 1, day: 1 }).offset || this.offset > this.set({ month: 5 }).offset;
  }
  /**
   * Get those DateTimes which have the same local time as this DateTime, but a different offset from UTC
   * in this DateTime's zone. During DST changes local time can be ambiguous, for example
   * `2023-10-29T02:30:00` in `Europe/Berlin` can have offset `+01:00` or `+02:00`.
   * This method will return both possible DateTimes if this DateTime's local time is ambiguous.
   * @returns {DateTime[]}
   */
  getPossibleOffsets() {
    if (!this.isValid || this.isOffsetFixed)
      return [this];
    const e = 864e5, t = 6e4, r = Eo(this.c), s = this.zone.offset(r - e), o = this.zone.offset(r + e), n = this.zone.offset(r - s * t), a = this.zone.offset(r - o * t);
    if (n === a)
      return [this];
    const l = r - n * t, c = r - a * t, d = bs(l, n), u = bs(c, a);
    return d.hour === u.hour && d.minute === u.minute && d.second === u.second && d.millisecond === u.millisecond ? [zt(this, { ts: l }), zt(this, { ts: c })] : [this];
  }
  /**
   * Returns true if this DateTime is in a leap year, false otherwise
   * @example DateTime.local(2016).isInLeapYear //=> true
   * @example DateTime.local(2013).isInLeapYear //=> false
   * @type {boolean}
   */
  get isInLeapYear() {
    return Qi(this.year);
  }
  /**
   * Returns the number of days in this DateTime's month
   * @example DateTime.local(2016, 2).daysInMonth //=> 29
   * @example DateTime.local(2016, 3).daysInMonth //=> 31
   * @type {number}
   */
  get daysInMonth() {
    return Ys(this.year, this.month);
  }
  /**
   * Returns the number of days in this DateTime's year
   * @example DateTime.local(2016).daysInYear //=> 366
   * @example DateTime.local(2013).daysInYear //=> 365
   * @type {number}
   */
  get daysInYear() {
    return this.isValid ? yi(this.year) : NaN;
  }
  /**
   * Returns the number of weeks in this DateTime's year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2004).weeksInWeekYear //=> 53
   * @example DateTime.local(2013).weeksInWeekYear //=> 52
   * @type {number}
   */
  get weeksInWeekYear() {
    return this.isValid ? Zs(this.weekYear) : NaN;
  }
  /**
   * Returns the resolved Intl options for this DateTime.
   * This is useful in understanding the behavior of formatting methods
   * @param {Object} opts - the same options as toLocaleString
   * @return {Object}
   */
  resolvedLocaleOptions(e = {}) {
    const { locale: t, numberingSystem: r, calendar: s } = ie.create(
      this.loc.clone(e),
      e
    ).resolvedOptions(this);
    return { locale: t, numberingSystem: r, outputCalendar: s };
  }
  // TRANSFORM
  /**
   * "Set" the DateTime's zone to UTC. Returns a newly-constructed DateTime.
   *
   * Equivalent to {@link DateTime#setZone}('utc')
   * @param {number} [offset=0] - optionally, an offset from UTC in minutes
   * @param {Object} [opts={}] - options to pass to `setZone()`
   * @return {DateTime}
   */
  toUTC(e = 0, t = {}) {
    return this.setZone(ne.instance(e), t);
  }
  /**
   * "Set" the DateTime's zone to the host's local zone. Returns a newly-constructed DateTime.
   *
   * Equivalent to `setZone('local')`
   * @return {DateTime}
   */
  toLocal() {
    return this.setZone(K.defaultZone);
  }
  /**
   * "Set" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.
   *
   * By default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will report different local times and consider DSTs when making computations, as with {@link DateTime#plus}. You may wish to use {@link DateTime#toLocal} and {@link DateTime#toUTC} which provide simple convenience wrappers for commonly used zones.
   * @param {string|Zone} [zone='local'] - a zone identifier. As a string, that can be any IANA zone supported by the host environment, or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'. You may also supply an instance of a {@link DateTime#Zone} class.
   * @param {Object} opts - options
   * @param {boolean} [opts.keepLocalTime=false] - If true, adjust the underlying time so that the local time stays the same, but in the target zone. You should rarely need this.
   * @return {DateTime}
   */
  setZone(e, { keepLocalTime: t = !1, keepCalendarTime: r = !1 } = {}) {
    if (e = mt(e, K.defaultZone), e.equals(this.zone))
      return this;
    if (e.isValid) {
      let s = this.ts;
      if (t || r) {
        const o = e.offset(this.ts), n = this.toObject();
        [s] = Is(n, o, e);
      }
      return zt(this, { ts: s, zone: e });
    } else
      return w.invalid(_s(e));
  }
  /**
   * "Set" the locale, numberingSystem, or outputCalendar. Returns a newly-constructed DateTime.
   * @param {Object} properties - the properties to set
   * @example DateTime.local(2017, 5, 25).reconfigure({ locale: 'en-GB' })
   * @return {DateTime}
   */
  reconfigure({ locale: e, numberingSystem: t, outputCalendar: r } = {}) {
    const s = this.loc.clone({ locale: e, numberingSystem: t, outputCalendar: r });
    return zt(this, { loc: s });
  }
  /**
   * "Set" the locale. Returns a newly-constructed DateTime.
   * Just a convenient alias for reconfigure({ locale })
   * @example DateTime.local(2017, 5, 25).setLocale('en-GB')
   * @return {DateTime}
   */
  setLocale(e) {
    return this.reconfigure({ locale: e });
  }
  /**
   * "Set" the values of specified units. Returns a newly-constructed DateTime.
   * You can only set units with this method; for "setting" metadata, see {@link DateTime#reconfigure} and {@link DateTime#setZone}.
   * @param {Object} values - a mapping of units to numbers
   * @example dt.set({ year: 2017 })
   * @example dt.set({ hour: 8, minute: 30 })
   * @example dt.set({ weekday: 5 })
   * @example dt.set({ year: 2005, ordinal: 234 })
   * @return {DateTime}
   */
  set(e) {
    if (!this.isValid)
      return this;
    const t = Ks(e, Fd), r = !S(t.weekYear) || !S(t.weekNumber) || !S(t.weekday), s = !S(t.ordinal), o = !S(t.year), n = !S(t.month) || !S(t.day), a = o || n, l = t.weekYear || t.weekNumber;
    if ((a || s) && l)
      throw new li(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    if (n && s)
      throw new li("Can't mix ordinal dates with month/day");
    let c;
    r ? c = $d({ ...ca(this.c), ...t }) : S(t.ordinal) ? (c = { ...this.toObject(), ...t }, S(t.day) && (c.day = Math.min(Ys(c.year, c.month), c.day))) : c = Pd({ ...bn(this.c), ...t });
    const [d, u] = Is(c, this.o, this.zone);
    return zt(this, { ts: d, o: u });
  }
  /**
   * Add a period of time to this DateTime and return the resulting DateTime
   *
   * Adding hours, minutes, seconds, or milliseconds increases the timestamp by the right number of milliseconds. Adding days, months, or years shifts the calendar, accounting for DSTs and leap years along the way. Thus, `dt.plus({ hours: 24 })` may result in a different time than `dt.plus({ days: 1 })` if there's a DST shift in between.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @example DateTime.now().plus(123) //~> in 123 milliseconds
   * @example DateTime.now().plus({ minutes: 15 }) //~> in 15 minutes
   * @example DateTime.now().plus({ days: 1 }) //~> this time tomorrow
   * @example DateTime.now().plus({ days: -1 }) //~> this time yesterday
   * @example DateTime.now().plus({ hours: 3, minutes: 13 }) //~> in 3 hr, 13 min
   * @example DateTime.now().plus(Duration.fromObject({ hours: 3, minutes: 13 })) //~> in 3 hr, 13 min
   * @return {DateTime}
   */
  plus(e) {
    if (!this.isValid)
      return this;
    const t = I.fromDurationLike(e);
    return zt(this, zd(this, t));
  }
  /**
   * Subtract a period of time to this DateTime and return the resulting DateTime
   * See {@link DateTime#plus}
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   @return {DateTime}
   */
  minus(e) {
    if (!this.isValid)
      return this;
    const t = I.fromDurationLike(e).negate();
    return zt(this, zd(this, t));
  }
  /**
   * "Set" this DateTime to the beginning of a unit of time.
   * @param {string} unit - The unit to go to the beginning of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @example DateTime.local(2014, 3, 3).startOf('month').toISODate(); //=> '2014-03-01'
   * @example DateTime.local(2014, 3, 3).startOf('year').toISODate(); //=> '2014-01-01'
   * @example DateTime.local(2014, 3, 3).startOf('week').toISODate(); //=> '2014-03-03', weeks always start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('day').toISOTime(); //=> '00:00.000-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('hour').toISOTime(); //=> '05:00:00.000-05:00'
   * @return {DateTime}
   */
  startOf(e) {
    if (!this.isValid)
      return this;
    const t = {}, r = I.normalizeUnit(e);
    switch (r) {
      case "years":
        t.month = 1;
      case "quarters":
      case "months":
        t.day = 1;
      case "weeks":
      case "days":
        t.hour = 0;
      case "hours":
        t.minute = 0;
      case "minutes":
        t.second = 0;
      case "seconds":
        t.millisecond = 0;
        break;
    }
    if (r === "weeks" && (t.weekday = 1), r === "quarters") {
      const s = Math.ceil(this.month / 3);
      t.month = (s - 1) * 3 + 1;
    }
    return this.set(t);
  }
  /**
   * "Set" this DateTime to the end (meaning the last millisecond) of a unit of time
   * @param {string} unit - The unit to go to the end of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @example DateTime.local(2014, 3, 3).endOf('month').toISO(); //=> '2014-03-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('year').toISO(); //=> '2014-12-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('week').toISO(); // => '2014-03-09T23:59:59.999-05:00', weeks start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('day').toISO(); //=> '2014-03-03T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('hour').toISO(); //=> '2014-03-03T05:59:59.999-05:00'
   * @return {DateTime}
   */
  endOf(e) {
    return this.isValid ? this.plus({ [e]: 1 }).startOf(e).minus(1) : this;
  }
  // OUTPUT
  /**
   * Returns a string representation of this DateTime formatted according to the specified format string.
   * **You may not want this.** See {@link DateTime#toLocaleString} for a more flexible formatting tool. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/formatting?id=table-of-tokens).
   * Defaults to en-US if no locale has been specified, regardless of the system's locale.
   * @param {string} fmt - the format string
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toFormat('yyyy LLL dd') //=> '2017 Apr 22'
   * @example DateTime.now().setLocale('fr').toFormat('yyyy LLL dd') //=> '2017 avr. 22'
   * @example DateTime.now().toFormat('yyyy LLL dd', { locale: "fr" }) //=> '2017 avr. 22'
   * @example DateTime.now().toFormat("HH 'hours and' mm 'minutes'") //=> '20 hours and 55 minutes'
   * @return {string}
   */
  toFormat(e, t = {}) {
    return this.isValid ? ie.create(this.loc.redefaultToEN(t)).formatDateTimeFromString(this, e) : yn;
  }
  /**
   * Returns a localized string representing this date. Accepts the same options as the Intl.DateTimeFormat constructor and any presets defined by Luxon, such as `DateTime.DATE_FULL` or `DateTime.TIME_SIMPLE`.
   * The exact behavior of this method is browser-specific, but in general it will return an appropriate representation
   * of the DateTime in the assigned locale.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param formatOpts {Object} - Intl.DateTimeFormat constructor options and configuration options
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toLocaleString(); //=> 4/20/2017
   * @example DateTime.now().setLocale('en-gb').toLocaleString(); //=> '20/04/2017'
   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL); //=> 'April 20, 2017'
   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL, { locale: 'fr' }); //=> '28 août 2022'
   * @example DateTime.now().toLocaleString(DateTime.TIME_SIMPLE); //=> '11:32 AM'
   * @example DateTime.now().toLocaleString(DateTime.DATETIME_SHORT); //=> '4/20/2017, 11:32 AM'
   * @example DateTime.now().toLocaleString({ weekday: 'long', month: 'long', day: '2-digit' }); //=> 'Thursday, April 20'
   * @example DateTime.now().toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> 'Thu, Apr 20, 11:27 AM'
   * @example DateTime.now().toLocaleString({ hour: '2-digit', minute: '2-digit', hourCycle: 'h23' }); //=> '11:32'
   * @return {string}
   */
  toLocaleString(e = Gs, t = {}) {
    return this.isValid ? ie.create(this.loc.clone(t), e).formatDateTime(this) : yn;
  }
  /**
   * Returns an array of format "parts", meaning individual tokens along with metadata. This is allows callers to post-process individual sections of the formatted output.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts
   * @param opts {Object} - Intl.DateTimeFormat constructor options, same as `toLocaleString`.
   * @example DateTime.now().toLocaleParts(); //=> [
   *                                   //=>   { type: 'day', value: '25' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'month', value: '05' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'year', value: '1982' }
   *                                   //=> ]
   */
  toLocaleParts(e = {}) {
    return this.isValid ? ie.create(this.loc.clone(e), e).formatDateTimeParts(this) : [];
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.extendedZone=false] - add the time zone format extension
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc(1983, 5, 25).toISO() //=> '1982-05-25T00:00:00.000Z'
   * @example DateTime.now().toISO() //=> '2017-04-22T20:47:05.335-04:00'
   * @example DateTime.now().toISO({ includeOffset: false }) //=> '2017-04-22T20:47:05.335'
   * @example DateTime.now().toISO({ format: 'basic' }) //=> '20170422T204705.335-0400'
   * @return {string}
   */
  toISO({
    format: e = "extended",
    suppressSeconds: t = !1,
    suppressMilliseconds: r = !1,
    includeOffset: s = !0,
    extendedZone: o = !1
  } = {}) {
    if (!this.isValid)
      return null;
    const n = e === "extended";
    let a = wn(this, n);
    return a += "T", a += Nd(this, n, t, r, s, o), a;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's date component
   * @param {Object} opts - options
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc(1982, 5, 25).toISODate() //=> '1982-05-25'
   * @example DateTime.utc(1982, 5, 25).toISODate({ format: 'basic' }) //=> '19820525'
   * @return {string}
   */
  toISODate({ format: e = "extended" } = {}) {
    return this.isValid ? wn(this, e === "extended") : null;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's week date
   * @example DateTime.utc(1982, 5, 25).toISOWeekDate() //=> '1982-W21-2'
   * @return {string}
   */
  toISOWeekDate() {
    return ys(this, "kkkk-'W'WW-c");
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's time component
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.extendedZone=true] - add the time zone format extension
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime() //=> '07:34:19.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34, seconds: 0, milliseconds: 0 }).toISOTime({ suppressSeconds: true }) //=> '07:34Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ format: 'basic' }) //=> '073419.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ includePrefix: true }) //=> 'T07:34:19.361Z'
   * @return {string}
   */
  toISOTime({
    suppressMilliseconds: e = !1,
    suppressSeconds: t = !1,
    includeOffset: r = !0,
    includePrefix: s = !1,
    extendedZone: o = !1,
    format: n = "extended"
  } = {}) {
    return this.isValid ? (s ? "T" : "") + Nd(
      this,
      n === "extended",
      t,
      e,
      r,
      o
    ) : null;
  }
  /**
   * Returns an RFC 2822-compatible string representation of this DateTime
   * @example DateTime.utc(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 +0000'
   * @example DateTime.local(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 -0400'
   * @return {string}
   */
  toRFC2822() {
    return ys(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", !1);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in HTTP headers. The output is always expressed in GMT.
   * Specifically, the string conforms to RFC 1123.
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @example DateTime.utc(2014, 7, 13).toHTTP() //=> 'Sun, 13 Jul 2014 00:00:00 GMT'
   * @example DateTime.utc(2014, 7, 13, 19).toHTTP() //=> 'Sun, 13 Jul 2014 19:00:00 GMT'
   * @return {string}
   */
  toHTTP() {
    return ys(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Date
   * @example DateTime.utc(2014, 7, 13).toSQLDate() //=> '2014-07-13'
   * @return {string}
   */
  toSQLDate() {
    return this.isValid ? wn(this, !0) : null;
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Time
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc().toSQL() //=> '05:15:16.345'
   * @example DateTime.now().toSQL() //=> '05:15:16.345 -04:00'
   * @example DateTime.now().toSQL({ includeOffset: false }) //=> '05:15:16.345'
   * @example DateTime.now().toSQL({ includeZone: false }) //=> '05:15:16.345 America/New_York'
   * @return {string}
   */
  toSQLTime({ includeOffset: e = !0, includeZone: t = !1, includeOffsetSpace: r = !0 } = {}) {
    let s = "HH:mm:ss.SSS";
    return (t || e) && (r && (s += " "), t ? s += "z" : e && (s += "ZZ")), ys(this, s, !0);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 Z'
   * @example DateTime.local(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 -04:00'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeOffset: false }) //=> '2014-07-13 00:00:00.000'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeZone: true }) //=> '2014-07-13 00:00:00.000 America/New_York'
   * @return {string}
   */
  toSQL(e = {}) {
    return this.isValid ? `${this.toSQLDate()} ${this.toSQLTime(e)}` : null;
  }
  /**
   * Returns a string representation of this DateTime appropriate for debugging
   * @return {string}
   */
  toString() {
    return this.isValid ? this.toISO() : yn;
  }
  /**
   * Returns the epoch milliseconds of this DateTime. Alias of {@link DateTime#toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }
  /**
   * Returns the epoch milliseconds of this DateTime.
   * @return {number}
   */
  toMillis() {
    return this.isValid ? this.ts : NaN;
  }
  /**
   * Returns the epoch seconds of this DateTime.
   * @return {number}
   */
  toSeconds() {
    return this.isValid ? this.ts / 1e3 : NaN;
  }
  /**
   * Returns the epoch seconds (as a whole number) of this DateTime.
   * @return {number}
   */
  toUnixInteger() {
    return this.isValid ? Math.floor(this.ts / 1e3) : NaN;
  }
  /**
   * Returns an ISO 8601 representation of this DateTime appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }
  /**
   * Returns a BSON serializable equivalent to this DateTime.
   * @return {Date}
   */
  toBSON() {
    return this.toJSDate();
  }
  /**
   * Returns a JavaScript object with this DateTime's year, month, day, and so on.
   * @param opts - options for generating the object
   * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output
   * @example DateTime.now().toObject() //=> { year: 2017, month: 4, day: 22, hour: 20, minute: 49, second: 42, millisecond: 268 }
   * @return {Object}
   */
  toObject(e = {}) {
    if (!this.isValid)
      return {};
    const t = { ...this.c };
    return e.includeConfig && (t.outputCalendar = this.outputCalendar, t.numberingSystem = this.loc.numberingSystem, t.locale = this.loc.locale), t;
  }
  /**
   * Returns a JavaScript Date equivalent to this DateTime.
   * @return {Date}
   */
  toJSDate() {
    return new Date(this.isValid ? this.ts : NaN);
  }
  // COMPARE
  /**
   * Return the difference between two DateTimes as a Duration.
   * @param {DateTime} otherDateTime - the DateTime to compare this one to
   * @param {string|string[]} [unit=['milliseconds']] - the unit or array of units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example
   * var i1 = DateTime.fromISO('1982-05-25T09:45'),
   *     i2 = DateTime.fromISO('1983-10-14T10:30');
   * i2.diff(i1).toObject() //=> { milliseconds: 43807500000 }
   * i2.diff(i1, 'hours').toObject() //=> { hours: 12168.75 }
   * i2.diff(i1, ['months', 'days']).toObject() //=> { months: 16, days: 19.03125 }
   * i2.diff(i1, ['months', 'days', 'hours']).toObject() //=> { months: 16, days: 19, hours: 0.75 }
   * @return {Duration}
   */
  diff(e, t = "milliseconds", r = {}) {
    if (!this.isValid || !e.isValid)
      return I.invalid("created by diffing an invalid DateTime");
    const s = { locale: this.locale, numberingSystem: this.numberingSystem, ...r }, o = GC(t).map(I.normalizeUnit), n = e.valueOf() > this.valueOf(), a = n ? this : e, l = n ? e : this, c = Jk(a, l, o, s);
    return n ? c.negate() : c;
  }
  /**
   * Return the difference between this DateTime and right now.
   * See {@link DateTime#diff}
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units units (such as 'hours' or 'days') to include in the duration
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  diffNow(e = "milliseconds", t = {}) {
    return this.diff(w.now(), e, t);
  }
  /**
   * Return an Interval spanning between this DateTime and another DateTime
   * @param {DateTime} otherDateTime - the other end point of the Interval
   * @return {Interval}
   */
  until(e) {
    return this.isValid ? W.fromDateTimes(this, e) : this;
  }
  /**
   * Return whether this DateTime is in the same unit of time as another DateTime.
   * Higher-order units must also be identical for this function to return `true`.
   * Note that time zones are **ignored** in this comparison, which compares the **local** calendar time. Use {@link DateTime#setZone} to convert one of the dates if needed.
   * @param {DateTime} otherDateTime - the other DateTime
   * @param {string} unit - the unit of time to check sameness on
   * @example DateTime.now().hasSame(otherDT, 'day'); //~> true if otherDT is in the same current calendar day
   * @return {boolean}
   */
  hasSame(e, t) {
    if (!this.isValid)
      return !1;
    const r = e.valueOf(), s = this.setZone(e.zone, { keepLocalTime: !0 });
    return s.startOf(t) <= r && r <= s.endOf(t);
  }
  /**
   * Equality check
   * Two DateTimes are equal if and only if they represent the same millisecond, have the same zone and location, and are both valid.
   * To compare just the millisecond values, use `+dt1 === +dt2`.
   * @param {DateTime} other - the other DateTime
   * @return {boolean}
   */
  equals(e) {
    return this.isValid && e.isValid && this.valueOf() === e.valueOf() && this.zone.equals(e.zone) && this.loc.equals(e.loc);
  }
  /**
   * Returns a string representation of a this time relative to now, such as "in two days". Can only internationalize if your
   * platform supports Intl.RelativeTimeFormat. Rounds down by default.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} [options.style="long"] - the style of units, must be "long", "short", or "narrow"
   * @param {string|string[]} options.unit - use a specific unit or array of units; if omitted, or an array, the method will pick the best unit. Use an array or one of "years", "quarters", "months", "weeks", "days", "hours", "minutes", or "seconds"
   * @param {boolean} [options.round=true] - whether to round the numbers in the output.
   * @param {number} [options.padding=0] - padding in milliseconds. This allows you to round up the result if it fits inside the threshold. Don't use in combination with {round: false} because the decimal output will include the padding.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelative() //=> "in 1 day"
   * @example DateTime.now().setLocale("es").toRelative({ days: 1 }) //=> "dentro de 1 día"
   * @example DateTime.now().plus({ days: 1 }).toRelative({ locale: "fr" }) //=> "dans 23 heures"
   * @example DateTime.now().minus({ days: 2 }).toRelative() //=> "2 days ago"
   * @example DateTime.now().minus({ days: 2 }).toRelative({ unit: "hours" }) //=> "48 hours ago"
   * @example DateTime.now().minus({ hours: 36 }).toRelative({ round: false }) //=> "1.5 days ago"
   */
  toRelative(e = {}) {
    if (!this.isValid)
      return null;
    const t = e.base || w.fromObject({}, { zone: this.zone }), r = e.padding ? this < t ? -e.padding : e.padding : 0;
    let s = ["years", "months", "days", "hours", "minutes", "seconds"], o = e.unit;
    return Array.isArray(e.unit) && (s = e.unit, o = void 0), Ld(t, this.plus(r), {
      ...e,
      numeric: "always",
      units: s,
      unit: o
    });
  }
  /**
   * Returns a string representation of this date relative to today, such as "yesterday" or "next month".
   * Only internationalizes on platforms that supports Intl.RelativeTimeFormat.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of "years", "quarters", "months", "weeks", or "days"
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar() //=> "tomorrow"
   * @example DateTime.now().setLocale("es").plus({ days: 1 }).toRelative() //=> ""mañana"
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar({ locale: "fr" }) //=> "demain"
   * @example DateTime.now().minus({ days: 2 }).toRelativeCalendar() //=> "2 days ago"
   */
  toRelativeCalendar(e = {}) {
    return this.isValid ? Ld(e.base || w.fromObject({}, { zone: this.zone }), this, {
      ...e,
      numeric: "auto",
      units: ["years", "months", "days"],
      calendary: !0
    }) : null;
  }
  /**
   * Return the min of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the minimum
   * @return {DateTime} the min DateTime, or undefined if called with no argument
   */
  static min(...e) {
    if (!e.every(w.isDateTime))
      throw new Ce("min requires all arguments be DateTimes");
    return kd(e, (t) => t.valueOf(), Math.min);
  }
  /**
   * Return the max of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the maximum
   * @return {DateTime} the max DateTime, or undefined if called with no argument
   */
  static max(...e) {
    if (!e.every(w.isDateTime))
      throw new Ce("max requires all arguments be DateTimes");
    return kd(e, (t) => t.valueOf(), Math.max);
  }
  // MISC
  /**
   * Explain how a string would be parsed by fromFormat()
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see description)
   * @param {Object} options - options taken by fromFormat()
   * @return {Object}
   */
  static fromFormatExplain(e, t, r = {}) {
    const { locale: s = null, numberingSystem: o = null } = r, n = V.fromOpts({
      locale: s,
      numberingSystem: o,
      defaultToEN: !0
    });
    return Wp(n, e, t);
  }
  /**
   * @deprecated use fromFormatExplain instead
   */
  static fromStringExplain(e, t, r = {}) {
    return w.fromFormatExplain(e, t, r);
  }
  // FORMAT PRESETS
  /**
   * {@link DateTime#toLocaleString} format like 10/14/1983
   * @type {Object}
   */
  static get DATE_SHORT() {
    return Gs;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED() {
    return sp;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Fri, Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED_WITH_WEEKDAY() {
    return EC;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983'
   * @type {Object}
   */
  static get DATE_FULL() {
    return op;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Tuesday, October 14, 1983'
   * @type {Object}
   */
  static get DATE_HUGE() {
    return np;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_SIMPLE() {
    return ap;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SECONDS() {
    return lp;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SHORT_OFFSET() {
    return cp;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_LONG_OFFSET() {
    return dp;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_SIMPLE() {
    return up;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SECONDS() {
    return hp;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 EDT', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SHORT_OFFSET() {
    return fp;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_LONG_OFFSET() {
    return pp;
  }
  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT() {
    return mp;
  }
  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT_WITH_SECONDS() {
    return gp;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED() {
    return _p;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_SECONDS() {
    return bp;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Fri, 14 Oct 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_WEEKDAY() {
    return SC;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL() {
    return yp;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL_WITH_SECONDS() {
    return vp;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE() {
    return wp;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE_WITH_SECONDS() {
    return xp;
  }
}
function ri(i) {
  if (w.isDateTime(i))
    return i;
  if (i && i.valueOf && Gt(i.valueOf()))
    return w.fromJSDate(i);
  if (i && typeof i == "object")
    return w.fromObject(i);
  throw new Ce(
    `Unknown datetime argument: ${i}, of type ${typeof i}`
  );
}
function im(i, e) {
  let t = i;
  try {
    if (!i)
      return "";
    const r = new RegExp(String.raw`\$\{(.*?)\}`, "g");
    (typeof t == "string" || t instanceof String) && (t = t.replace(r, (s, o) => {
      try {
        let n = e[o];
        if (n)
          return n;
      } catch {
      }
      return "";
    }));
  } catch {
  }
  return t;
}
function sm(i, e = !0) {
  const t = ["I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX", "X", "XI", "XII"], r = `${i.day}.${t[i.month - 1]}.${i.year}`;
  return e ? r + " " + i.toLocaleString(w.TIME_SIMPLE) : r;
}
class om {
  constructor(e, t, r) {
    this._lastUID = "", this.uicomponent = e, this.layouter = t, this.data = r, this._lastUID = "";
  }
  haulData(e, t) {
    return e === void 0 ? "" : (e = im(e, this.data), this.uicomponent.dataProvider && e != null && (e = this.uicomponent.dataProvider(e, t)), e);
  }
  resetCursor() {
    this._lastUID = "";
  }
  next() {
    return this.uicomponent && this.uicomponent.moveToNextRow ? (this._lastUID = this.uicomponent.moveToNextRow(this._lastUID), this._lastUID !== "") : !1;
  }
}
class v1 extends om {
  constructor(e, t, r, s) {
    super(e, r, s), this.entry = t;
  }
}
class Hd extends om {
  constructor(e, t, r, s) {
    super(e, r, s), this._sortOrder = [], this.entry = t;
  }
  resetCursor() {
    super.resetCursor();
  }
}
class w1 {
  constructor() {
    this._elementClasses = {};
  }
  addUIElementClass(e, t) {
    this._elementClasses[e.toLowerCase()] = t;
  }
  getUIElementClass(e) {
    const t = this._elementClasses[e.toLowerCase()];
    if (!t)
      throw `UIConfigurableElementFactory.getUIElementClass: no element class for ${e}`;
    return t;
  }
}
class Tt {
  static haulData(e, t, r) {
    return e.haulData(t, r);
  }
  static devInfo(e, ...t) {
    if (e.uicomponent.showDevelopmentInfo) {
      const r = [];
      for (const s of t)
        r.push(p`<span class="developer-info"">[${s ?? "undefined"}]</span>`);
      return r;
    } else
      return p``;
  }
  static render(e, t) {
    throw `UIElement.render: Call of abstract method for control ${t}`;
  }
  static isVisible(e, t) {
    let r = e.entry.element_type.visible;
    return r === void 0 && (r = e.layouter.defaultElementVisibility), r === "false" || r == !1 ? !1 : r === "true" || r == !0 ? !0 : r === "." ? !!t : !!this.haulData(e, r);
  }
  static isIdentifier(e) {
    return !!(e.uicomponent.linkIdentifiers && e.entry.element_type.is_identifier);
  }
  static getStyleSetting(e, t, r) {
    return e.style && e.style.hasOwnProperty(t) ? e.style[t] : r;
  }
  static getStyleTextAlign(e) {
    switch (this.getStyleSetting(e, "text-align", "")) {
      case "left":
        return "text-align: left";
      case "right":
        return "text-align: right";
      case "center":
        return "text-align: center";
    }
    return "";
  }
  static addStyle(e, t) {
    return t ? e ? e + ";" : "" + t : e;
  }
}
class x1 extends Tt {
  static renderLabel(e, t, r) {
    return e.layouter.renderElementLabels ? p`
            <label for="${t}">${r || b}
                ${this.devInfo(e, e.entry.element_type.text, e.entry.element_type.value)}
            </label>
        ` : this.devInfo(e, e.entry.element_type.text, e.entry.element_type.value);
  }
  static render(e, t) {
    var r;
    try {
      let s = this.haulData(e, e.entry.element_type.value, t);
      if (!this.isVisible(e, s))
        return p`${b}`;
      let o = this.haulData(e, e.entry.element_type.text), n = this.getStyleSetting(e.entry.element_type, "classes", ""), a = this.addStyle("", this.getStyleTextAlign(e.entry.element_type)), l = this.isIdentifier(e);
      return (r = e.entry.layout) != null && r.max_height && (a = this.addStyle(a, `max-height: ${e.entry.layout.max_height === "max" ? "none" : e.entry.layout.max_height + " em"}`)), this.isIdentifier(e) && (n = (n ? " " : "") + "identifier-link"), e.entry.element_type.multiline ? (typeof s == "string" && (s = s.replaceAll(`\r
`, `
`), s = s.replaceAll("\r", `
`)), !e.entry.element_type.enabled || e.entry.element_type.readonly ? e.layouter.renderElement(e.entry.layout, p`
                        ${this.renderLabel(e, t, o)}
                        <div style="${a || b}" id=${t} class="multiline-textarea read-only-textarea ${n}">${s || b}</div>
                    `) : e.layouter.renderElement(e.entry.layout, p`
                        ${this.renderLabel(e, t, o)}
                        <textarea id=${t} class="${n}" style="${a || b}" name=${t}
                                  @change="${e.uicomponent.fieldChanged}">${s || b}</textarea>
                    `)) : !e.entry.element_type.enabled || e.entry.element_type.readonly ? e.layouter.renderElement(e.entry.layout, p`
                        ${this.renderLabel(e, t, o)}
                        <div style="${a || b}" id=${t} 
                             class="read-only-textarea ${n}"
                             data-identifier="${l ? s : b}"
                             @click="${l ? e.uicomponent.gotoIdentifier : b}"><span>${l ? p`<i class="footsteps"></i>` : b}<span>${s || b}</span></span></div>
                    `) : e.layouter.renderElement(e.entry.layout, p`
                        ${this.renderLabel(e, t, o)}
                        <input id=${t} name=${t} type="text" class="${n}"
                               style="${a || b}"
                               value="${s || b}"
                               @change="${e.uicomponent.fieldChanged}"
                               ?disabled=${!e.entry.element_type.enabled || e.entry.element_type.readonly}/>
                    `);
    } catch (s) {
      throw s;
    }
  }
}
class C1 extends Tt {
  static renderLabel(e, t, r) {
    return e.layouter.renderElementLabels ? p`
            <label for="${t}">${r} 
                ${this.devInfo(e, e.entry.element_type.text, e.entry.element_type.value)}
            </label>
        ` : this.devInfo(e, e.entry.element_type.text, e.entry.element_type.value);
  }
  static render(e, t) {
    try {
      const r = this.haulData(e, e.entry.element_type.value);
      if (!this.isVisible(e, r))
        return p`${b}`;
      let s = this.haulData(e, e.entry.element_type.text);
      const o = this.getStyleSetting(e.entry.element_type, "classes", ""), n = this.addStyle("", this.getStyleTextAlign(e.entry.element_type)), a = w.fromISO(r);
      let l;
      return a.isValid && ((e.entry.element_type.date_format || "latin") === "latin" ? l = sm(a, !1) : l = a.toLocaleString(w.DATE_SHORT)), e.layouter.renderElement(e.entry.layout, p`
                ${this.renderLabel(e, t, s)}
                ${e.entry.element_type.readonly ? p`<input id=${t} name=${t}
                                    class="input-right-align ${o}"
                                    style="${n}"
                                    value="${l || b}"
                                    @change="${e.uicomponent.fieldChanged}"
                                    ?disabled=${e.entry.element_type.readonly}>
                        </input>` : p`
                            <vaadin-date-picker id=${t} name=${t}
                                                class="${o || b}"
                                                style="${n || b}"
                                                value="${l || b}"
                                                @change="${e.uicomponent.fieldChanged}"
                                                ?disabled=${!e.entry.element_type.enabled}>
                            </vaadin-date-picker>`}
            `);
    } catch (r) {
      throw r;
    }
  }
}
class k1 extends Tt {
  static renderLabel(e, t, r) {
    return e.layouter.renderElementLabels ? p`
            <label for="${t}">${r} 
                ${this.devInfo(e, e.entry.element_type.text, e.entry.element_type.value)}
            </label>
        ` : this.devInfo(e, e.entry.element_type.text, e.entry.element_type.value);
  }
  static render(e, t) {
    try {
      const r = this.haulData(e, e.entry.element_type.value);
      if (!this.isVisible(e, r))
        return p`${b}`;
      const s = this.haulData(e, e.entry.element_type.text), o = this.getStyleSetting(e.entry.element_type, "classes", ""), n = this.addStyle("", this.getStyleTextAlign(e.entry.element_type)), a = w.fromISO(r);
      let l = e.entry.element_type.include_time;
      l === void 0 && (l = !0);
      let c;
      return a.isValid && ((e.entry.element_type.date_format || "latin") === "latin" ? c = sm(a, l) : c = l ? a.toLocaleString(w.DATETIME_SHORT) : a.toLocaleString(w.DATE_SHORT)), e.layouter.renderElement(e.entry.layout, p`
                ${this.renderLabel(e, t, s)}
                ${e.entry.element_type.readonly ? p`<input id=${t} name=${t} class="input-right-align ${o}"
                                    style="${n}"
                                    value="${c || b}"
                                    @change="${e.uicomponent.fieldChanged}"
                                    ?disabled=${e.entry.element_type.readonly}>
                        </input>` : p`
                            <vaadin-date-time-picker
                                    id=${t} name=${t} class="${o}"
                                    style="${n}"
                                    value="${c || b}"
                                    @change="${e.uicomponent.fieldChanged}"
                                    ?disabled=${!e.entry.element_type.enabled}>
                            </vaadin-date-time-picker>`}
            `);
    } catch (r) {
      throw r;
    }
  }
}
class A1 extends Tt {
  static render(e, t) {
    const r = e.entry.element_type;
    let s = "", o = "modal-button", n = r.extra_style ? r.extra_style : b;
    if (!this.isVisible(e, ""))
      return p`${b}`;
    switch (r.type) {
      case "cancelButton":
        o = "modal-cancel";
        break;
      case "okButton":
        o = "modal-ok";
        break;
      case "iconButton":
        o = "modal-round-button", s = r.icon;
        break;
    }
    const a = this.getStyleSetting(e.entry.element_type, "classes", "");
    return o = a ? o + " " + a : o, e.layouter.renderElement(e.entry.layout, p`
            <button class="${o}" style="${n}" id=${t} name=${t}
                    @click="${e.uicomponent.fieldChanged}"">
            ${s}
            </button>
        `);
  }
}
class E1 extends Tt {
  static renderLabel(e, t, r) {
    return e.layouter.renderElementLabels && e.entry.element_type.text ? p`
            <label for="${t}">${r}
                ${this.devInfo(e, e.entry.element_type.text, e.entry.element_type.value)}
            </label>
        ` : b;
  }
  static render(e, t) {
    var r;
    const s = this.haulData(e, e.entry.element_type.value);
    if (!this.isVisible(e, s))
      return p`${b}`;
    const o = this.haulData(e, e.entry.element_type.text), n = this.getStyleSetting(e.entry.element_type, "classes", ""), a = this.addStyle("", this.getStyleTextAlign(e.entry.element_type));
    return this.addStyle(a, e.uicomponent.getPaddingStyle((r = e.entry.layout) == null ? void 0 : r.padding).replace("padding", "margin")), e.layouter.renderElement(e.entry.layout, p`
            ${this.renderLabel(e, t, o)}
            <div class="templateLabel ${n}" id=${t} 
                 style="${a || b}">
                ${this.devInfo(e, e.entry.element_type.text, e.entry.element_type.value)}${s || b}
            </div>
        `);
  }
}
class S1 extends Tt {
  static renderLabel(e, t, r) {
    return e.layouter.renderElementLabels ? p`
            <label for="${t}">${r}
                ${this.devInfo(e, e.entry.element_type.text, e.entry.element_type.value)}
            </label>
        ` : this.devInfo(e, e.entry.element_type.text, e.entry.element_type.value);
  }
  static renderReadOnly(e, t, r) {
    let s = this.haulData(e, e.entry.element_type.value, t);
    if (!this.isVisible(e, s))
      return p`${b}`;
    const o = this.getStyleSetting(e.entry.element_type, "classes", ""), n = this.addStyle("", this.getStyleTextAlign(e.entry.element_type));
    return e.layouter.renderElement(
      e.entry.layout,
      p`
                ${this.renderLabel(e, t, r)}
                <input id=${t} name=${t} type="text"
                       class="${o}"
                       style="${n}"
                       value="${s || b}"
                       disabled/>
            `
    );
  }
  static renderWithStaticSelection(e, t, r) {
    const s = [];
    let o = "";
    const n = e.entry.element_type;
    if (Array.isArray(n.items))
      for (const c of n.items) {
        const d = Array.isArray(c) ? c.length > 1 ? c[1] : c[0] : c, u = Array.isArray(c) ? c[0] : c;
        if (s.push(d), e.data[t] === u) {
          const h = {};
          h[t] = d, o = im(e.entry.element_type.value, h);
        }
      }
    const a = this.getStyleSetting(e.entry.element_type, "classes", ""), l = this.addStyle("", this.getStyleTextAlign(e.entry.element_type));
    return e.layouter.renderElement(e.entry.layout, p`
                    ${this.renderLabel(e, t, r)}
                    <vaadin-combo-box id="${t}" name="${t}" .items="${s}"
                                      .selectedItem="${o || b}"
                                      class="${a}"
                                      style="${l}"
                                      @change="${e.uicomponent.fieldChanged}">
                                      ?disabled=${!e.entry.element_type.enabled}
                    </vaadin-combo-box>
                `);
  }
  static renderWithDynamicSelection(e, t, r) {
    let s = "", o = "";
    const n = t in e.data ? e.data[t] : "";
    Array.isArray(n) && n.length == 2 && (s = n[0], o = n[1]);
    const a = this.getStyleSetting(e.entry.element_type, "classes", ""), l = this.addStyle("", this.getStyleTextAlign(e.entry.element_type));
    return e.layouter.renderElement(e.entry.layout, p`
                ${this.renderLabel(e, t, r)}
                <vaadin-combo-box id="${t}" name="${t}"
                                  .selectedItem="${s || b}"
                                  class="${a}"
                                  style="${l}"
                                  value="${s || b}"
                                  data-value="${o}"
                                  @change="${e.uicomponent.fieldChanged}"
                                  ?disabled=${!e.entry.element_type.enabled}>
                </vaadin-combo-box>
            `);
  }
  static render(e, t) {
    try {
      const r = e.entry.element_type;
      let s = this.haulData(e, e.entry.element_type.text);
      return e.entry.element_type.readonly ? this.renderReadOnly(e, t, s) : Array.isArray(r.items) ? this.renderWithStaticSelection(e, t, s) : r.items && "topic" in r.items ? this.renderWithDynamicSelection(e, t, s) : p`
                        <div class="combobox-div" style="${e.layouter.renderLayoutStyles(e.entry.layout)}">
                            <label for="${t}">${s}${this.devInfo(e, e.entry.element_type.text, e.entry.element_type.value)}</label>
                            <div>selection field ${t} is missing a list.</div>
                        </div>`;
    } catch (r) {
      throw r;
    }
  }
}
class T1 extends Tt {
  // line needs a different way of dealing with the defaultElementVisibility
  // @ts-ignore
  static isVisible(e, t) {
    let r = e.entry.element_type.visible;
    return r === void 0 && (r = e.layouter.defaultElementVisibility), r === "false" || r == !1 ? !1 : r === "true" || r == !0 || r === "." ? !0 : !!this.haulData(e, r);
  }
  static render(e, t) {
    if (!this.isVisible(e, ""))
      return p`${b}`;
    let r = this.getStyleSetting(e.entry.element_type, "classes", "");
    r = (r ? r + " " : "") + (e.entry.element_type.transparent ? "ui-line-transparent" : "");
    let s = e.uicomponent.getPaddingStyle(
      e.entry.element_type.padding
    ).replace("padding", "margin");
    const o = this.addStyle(s, e.layouter.renderLayoutStyles(e.entry.layout));
    return e.layouter.renderElement(e.entry.layout, p`
            <div class="ui-line ${r}" id="${t}" style="${o}">
            </div>
        `);
  }
}
class I1 extends Tt {
  static renderLabel(e, t, r) {
    return e.layouter.renderElementLabels ? p`
            <label for="${t}">${r}
                ${this.devInfo(e, e.entry.element_type.text, e.entry.element_type.value)}
            </label>
        ` : this.devInfo(e, e.entry.element_type.text, e.entry.element_type.value);
  }
  static render(e, t) {
    var r, s;
    try {
      let o = this.haulData(e, e.entry.element_type.value), n = this.haulData(e, e.entry.element_type.text), a = this.haulData(e, `#($/images/descriptions/${o})`), l = this.getStyleSetting(e.entry.element_type, "classes", ""), c = this.addStyle("", this.getStyleTextAlign(e.entry.element_type)), d = e.entry.element_type, u = d.file_description || "bottom";
      return (r = e.entry.layout) != null && r.max_height && (c = this.addStyle(c, `max-height: ${e.entry.layout.max_height === "max" ? "" : e.entry.layout.max_height + " px"}`)), (s = e.entry.layout) != null && s.max_width && (c = this.addStyle(c, `max-width: ${e.entry.layout.max_width === "max" ? "" : e.entry.layout.max_width + " px"}`)), e.layouter.renderElement(e.entry.layout, p`
                ${this.renderLabel(e, t, n)}
                <div style="${c || b}" id=${t} class="read-only-image ${l}">
                    <div class="${d.align_image === "left" || d.fit_content === "scale" ? "image-left-align" : "image-center"}">
                        <file-view 
                                id="${o}" 
                                uuid_file="${o}" 
                                resolution="${d.resolution}" 
                                description=${a} 
                                fitcontent="${d.fit_content || "contain"}"
                                @fetchfile="${e.uicomponent.fetchFile}">
                        </file-view>
                    </div>
                    ${u === "bottom" && a ? p`
                            <div class="file-element-description">${a}</div>
                        ` : b}
                </div>
            `);
    } catch (o) {
      throw o;
    }
  }
}
class D1 extends w1 {
  constructor() {
    super(), this.addUIElementClass("textfield", x1), this.addUIElementClass("datefield", C1), this.addUIElementClass("datetimefield", k1), this.addUIElementClass("button", A1), this.addUIElementClass("templatelabel", E1), this.addUIElementClass("selection", S1), this.addUIElementClass("line", T1), this.addUIElementClass("file", I1);
  }
}
var O1 = Object.defineProperty, $1 = Object.getOwnPropertyDescriptor, Te = (i, e, t, r) => {
  for (var s = r > 1 ? void 0 : r ? $1(e, t) : e, o = i.length - 1, n; o >= 0; o--)
    (n = i[o]) && (s = (r ? n(e, t, s) : n(s)) || s);
  return r && s && O1(e, t, s), s;
};
let de = class extends _t {
  constructor() {
    super(), this._messages = {}, this._dsd_to_element_list = {}, this._element_list = {}, this._selection_data = {}, this.uiElementFactory = new D1(), this.uiSchema = null, this.linkIdentifiers = !0, this.showDevelopmentInfo = !1, this.data = {}, this.lookupProvider = null, this.dataProvider = null, this.moveToNextRow = null, this.setSortOrder = null, this.fetchFileProvider = null, this._showError = null, this._messages = {};
  }
  willUpdate(i) {
    i.has("uiSchema") && this.processSchemaDefinition();
  }
  firstUpdated(i) {
    super.firstUpdated(i);
    for (const e of this.renderRoot.querySelectorAll("vaadin-combo-box"))
      if (e && !e.items && this.lookupProvider) {
        let t = this.lookupProvider, r = this.getSchemaElement(e.id);
        if (r.element_type.name.toLowerCase() !== "selection")
          continue;
        const s = r.element_type;
        if (Array.isArray(s.items))
          continue;
        e.dataProvider = async (o, n) => {
          if (!(e.id in this._selection_data))
            t(
              e.id,
              s.items,
              o,
              (a, l) => {
                const c = [];
                this._selection_data[e.id] = {};
                for (const d of a)
                  this._selection_data[e.id][d[1]] = d[0], c.push(d[1]);
                n(c, l);
              }
            );
          else {
            const a = Object.entries(this._selection_data[e.id]).map((l) => l[0]).filter((l) => l.startsWith(o.filter));
            n(a, a.length);
          }
        };
      }
  }
  updated(i) {
    super.updated(i);
  }
  getSchemaElement(i) {
    return this._element_list[i];
  }
  processSchemaDefinition() {
    function i(o) {
      o && Object.entries(o).map(([n, a]) => {
        var l, c;
        const d = new RegExp("^[a-z][a-z0-9\\-_]*$", "gmi");
        if (!n.match(d)) {
          t = `There is an error in the schema definition: the element id "${n}" is illegal. It must start with a letter followed by only letters and numbers`;
          return;
        }
        if (e.find((h) => h === n)) {
          t = `There is an error in the schema definition: the element id "${n}" is used more than once in the UI schema`;
          return;
        }
        e.push(n);
        const u = (c = (l = a.binding) == null ? void 0 : l.field_name) == null ? void 0 : c.toLowerCase();
        u && (u in r ? (t = `There is an error in the schema definition: dsd field "${u}" bound again in element "${n}" in UI schema`, a.element_type.enabled = !1) : r[u] = { id: n, element: a }), a.element_type.enabled === void 0 && (a.element_type.enabled = !0), s[n] = a, a.element_type.name === "layout" && i(a.element_type.ui_elements);
      });
    }
    this._dsd_to_element_list = {};
    const e = [];
    let t = "";
    const r = this._dsd_to_element_list, s = this._element_list;
    this.uiSchema && i(this.uiSchema.ui_elements), this._showError = t;
  }
  gatherData() {
    const i = {};
    return !this._dsd_to_element_list || Object.keys(this._dsd_to_element_list).length === 0 ? {} : (Object.entries(this._dsd_to_element_list).map(([e, t]) => {
      i[e] = this.get_field_value(t.id, t.element);
    }), i);
  }
  fetchFile(i) {
    const e = i.detail;
    this.fetchFileProvider && this.fetchFileProvider(e);
  }
  get_field_value(i, e) {
    const t = this.renderRoot.querySelector(`#${i}`);
    switch (e.element_type.name.toLowerCase()) {
      case "selection":
        return this.getSelectionValue(i, t, e.element_type);
      default:
        return t != null && t.value ? t == null ? void 0 : t.value : "";
    }
  }
  //Todo: This should be in the uielementcombobox.ts
  getSelectionValue(i, e, t) {
    let r = e != null && e.value ? e == null ? void 0 : e.value : "", s;
    if (this._element_list[i].element_type, Array.isArray(t.items) && t.items.length > 0)
      if (Array.isArray(t.items[0])) {
        for (const o of t.items)
          if (o[1] === r) {
            s = o[0];
            break;
          }
      } else
        s = r;
    else if (s = e == null ? void 0 : e.getAttribute("data-value"), r && i in this._selection_data)
      try {
        s = this._selection_data[i][r];
      } catch {
      }
    return s || "";
  }
  fieldChanged(i) {
    if ("currentTarget" in i) {
      const e = {
        detail: {
          srcElement: i.currentTarget.id,
          newData: this.gatherData()
        },
        bubbles: !0
      };
      this.dispatchEvent(new CustomEvent("dataChanged", e));
    }
  }
  getLayoutClass(i, e, t = !1) {
    const r = (e == null ? void 0 : e.type) || "sheet";
    if (t && e && t && (e.readonly = t), e != null && e.orchestration_strategy)
      if (r === "sheet")
        switch (e == null ? void 0 : e.orchestration_strategy.toLowerCase()) {
          case "columns":
            return new pn(i, e);
          case "rightalign":
            return new vC(i, e);
          case "stack":
            return new yC(i, e);
          default:
            throw `Unknown orchestration strategy ${e.orchestration_strategy}`;
        }
      else if (r === "list")
        switch (e == null ? void 0 : e.orchestration_strategy.toLowerCase()) {
          case "columns":
            return new pn(i, e);
          case "table":
            return new wC(i, e);
          case "gallery":
            return new xC(i, e);
          default:
            throw `Unknown orchestration strategy ${e.orchestration_strategy}`;
        }
      else
        throw `Unknown layout type ${r}`;
    else
      return new pn(i, e);
  }
  renderUIElement(i, e, t) {
    var r;
    try {
      if (!this.uiElementFactory)
        throw `UIComponent.renderUIElement: no elementFactory to instantiate ${e.element_type.name}`;
      const s = new v1(this, e, t, this.data), o = this.uiElementFactory.getUIElementClass(e.element_type.name);
      return s.entry.element_type.readonly = s.entry.element_type.readonly || ((r = t == null ? void 0 : t.layoutSettings) == null ? void 0 : r.readonly), o.render(s, i);
    } catch (s) {
      return te`
                    ${e.element_type.name} "${i}": ${s}
                    `;
    }
  }
  renderElement(i, e, t) {
    switch (e.element_type.name.toLowerCase()) {
      case "layout":
        return this.renderLayoutElement(i, e.element_type, t);
      default:
        return this.renderUIElement(i, e, t);
    }
  }
  getPaddingStyle(i) {
    let e = "";
    return typeof i == "number" ? e = `padding: ${i}px` : typeof i == "string" ? e = `padding: ${i}` : i && (e = `padding: ${i.top} ${i.right} ${i.bottom} ${i.left}`), e;
  }
  onRequestUpdate() {
    this.requestUpdate();
  }
  renderLayoutElement(i, e, t) {
    var r, s;
    let o;
    try {
      o = this.getLayoutClass(i, e.layout_settings, (r = t.layoutSettings) == null ? void 0 : r.readonly), o.onRequestUpdate = this.onRequestUpdate;
    } catch (l) {
      return te`cannot create layout ${i}: ${l}`;
    }
    let n = t.renderLayoutStyles(e.layout);
    n += n ? ";" : "" + this.getPaddingStyle((s = e.layout) == null ? void 0 : s.padding);
    const a = new Hd(this, e, o, this.data);
    return o.renderLayout(a, o, n, this.renderElement.bind(this));
  }
  hideDevelopmentInfo() {
    this.renderRoot.querySelectorAll(".developer-info").forEach((i) => i.style.display = "none");
  }
  gotoIdentifier(i) {
    const e = {
      identifier: i.currentTarget.dataset.identifier,
      fieldId: i.currentTarget.id
    }, t = new CustomEvent(
      "goto-identifier",
      { detail: e, bubbles: !1, composed: !0, cancelable: !1 }
    );
    this.dispatchEvent(t);
  }
  render() {
    var i, e, t;
    const r = [];
    let s;
    this.showDevelopmentInfo && r.push(te`<div class="uicomponent-version" @click="${this.hideDevelopmentInfo}">${te`${"0.4.13"}`}</div>`);
    try {
      s = this.getLayoutClass("root", (i = this.uiSchema) == null ? void 0 : i.layout_settings), s.onRequestUpdate = this.onRequestUpdate.bind(this);
    } catch {
      this._showError = `The schema definition is calling an unknown Orchestration Strategy "${(t = (e = this.uiSchema) == null ? void 0 : e.layout_settings) == null ? void 0 : t.orchestration_strategy}"`;
    }
    if (!this._showError)
      try {
        if (this.uiSchema && s) {
          const o = new Hd(this, this.uiSchema, s, this.data);
          r.push(s.renderLayout(o, s, "", this.renderElement.bind(this)));
        }
      } catch (o) {
        this._showError = `An error occurred when rendering this component:
"${o}"`;
      }
    return this._showError && r.push(te`
                <div style="background-color: var(--col-bg-alert); color: var(--col-primary-bg-alert); padding: .5em; font-family: monospace">
                    ${this._showError}
                </div>`), te`${r}`;
  }
};
de.styles = tt(bC);
Te([
  G()
], de.prototype, "uiElementFactory", 2);
Te([
  G()
], de.prototype, "uiSchema", 2);
Te([
  G()
], de.prototype, "linkIdentifiers", 2);
Te([
  G()
], de.prototype, "showDevelopmentInfo", 2);
Te([
  G()
], de.prototype, "data", 2);
Te([
  G()
], de.prototype, "lookupProvider", 2);
Te([
  G()
], de.prototype, "dataProvider", 2);
Te([
  G()
], de.prototype, "moveToNextRow", 2);
Te([
  G()
], de.prototype, "setSortOrder", 2);
Te([
  G()
], de.prototype, "fetchFileProvider", 2);
Te([
  z()
], de.prototype, "_showError", 2);
de = Te([
  Qt("ui-component")
], de);
class Qs extends Ga {
  /**
   * A RecordAccessor for one record that binds to DSD information.
   *
   * @param id the record_type. Serves as root and id at the same time
   * @param dataContext the DataContext with the DSD information
   * @param data A DSDRecord consisting of a "fields" and "record" array
   */
  constructor(e, t, r) {
    super(e, t), this.rootKey = "/" + e, this._dataContext = t, this.assignData(r);
  }
  assignData(e) {
    this._data = {};
    for (let t = 0; t <= e.fields.length; t++)
      this._data[e.fields[t]] = e && e.record ? e.record[t] : void 0;
  }
  get(e, t, r) {
    if (e)
      switch (r) {
        case Re.GET_MODE_DEFAULT:
          if (e !== this.rootKey)
            return;
          break;
        case Re.GET_MODE_ENDS_WITH:
          if (!this.rootKey.endsWith(e))
            return;
          break;
        case Re.GET_MODE_REGEX:
          throw "DSDRecordAccessor.get: Regex not implemented";
        default:
          throw `DSDRecordAccessor.get: Unknown getMode in ${e}${t}`;
      }
    return this._data[t];
  }
}
class Js {
  constructor(e, t, r, s = void 0) {
    this.recordMissing = !1, this._UIDFieldIdx = -1, this._sort_order = [], this._cachedElements = {}, Js.check_part(t, r, e), this._groupId = t, this._part = e.compilation.groups[t].parts[r], this._partId = r, this._document = e, this._dataContext = s, this._partData = void 0, this._initInterpreter();
  }
  get interpreter() {
    return this._interpreter;
  }
  get recordType() {
    return this.layout.record_type;
  }
  static check_part(e, t, r) {
    const s = r.compilation.groups[e].parts[t];
    if (!s.hasOwnProperty("text"))
      throw `KioskViewDocument part ${t} has no text attribute`;
    if (!s.hasOwnProperty("position"))
      throw `KioskViewDocument part ${t} has no position attribute`;
    let o = s.layout || t;
    if (!r.hasOwnProperty(o))
      throw `KioskViewDocument part ${e}, ${t} referring to unknown layout ${o}`;
    this.check_layout(r, o);
  }
  static check_layout(e, t) {
    if (!e.hasOwnProperty(t))
      throw `KioskViewDocument layout ${t} does not exist`;
    const r = e[t];
    for (const s of ["record_type", "view_type", "fields_selection"])
      if (!r.hasOwnProperty(s))
        throw `KioskViewDocument layout ${t} has no ${s} attribute`;
    if (!r.hasOwnProperty("layout_settings"))
      throw `KioskViewDocument layout ${t} has no layout_settings`;
  }
  _initInterpreter() {
    this._dataContext && (this._interpreter = Ka(this._dataContext));
  }
  set dataContext(e) {
    this._dataContext = e, this._initInterpreter();
  }
  get dataContext() {
    return this._dataContext;
  }
  get text() {
    return this._dataContext ? this._interpreter.interpret(this._part.text) : this._part.text;
  }
  get position() {
    return this._part.position;
  }
  get opened() {
    return this._part.opened || !1;
  }
  toggleOpen() {
    this._part.opened = !this._part.opened;
  }
  get partId() {
    return this._partId;
  }
  get cssPartId() {
    return this._partId.replace(/[^a-zA-Z|0-9|\-|_]/, "-");
  }
  get layout() {
    const e = this._part.layout || this._partId;
    if (!this._document.hasOwnProperty(e))
      throw `KioskViewDocument part ${this._partId} referring to unknown layout ${e}`;
    return this._document[e];
  }
  get maxHeight() {
    if (this.layout.view_type === "list")
      return this.layout.max_height;
  }
  get expandable() {
    return this._document.compilation.groups[this._groupId].type === "accordion" ? !0 : this.layout.view_type === "list" && this.layout.max_height_expandable || !1;
  }
  getFieldOrderComparer(e, t, r) {
    let s, o = {}, n = "";
    o.text = {
      inc: (a, l) => ec(a, l),
      dec: (a, l) => ec(l, a)
    }, o.datetime = {
      inc: (a, l) => tc(a, l),
      dec: (a, l) => tc(l, a)
    };
    try {
      s = r.dsd.get_field_data_type(this.recordType, e).toUpperCase(), ["VARCHAR", "TEXT"].includes(s) && (n = "text"), ["DATE", "DATETIME", "TIMESTAMP", "TIME"].includes(s) && (n = "datetime");
    } catch {
      return () => 0;
    }
    return n ? t ? o.text.dec : o.text.inc : (a) => 0;
  }
  createSortOrder(e, t) {
    this._sort_order = [];
    const r = this._partData[0];
    t != null && t.forEach((s) => {
      let o = !1;
      s.startsWith(">") && (s = s.slice(1), o = !0);
      let n = r.findIndex((a) => a === s);
      n > -1 && this._sort_order.push({
        name: s,
        idx: n,
        cmp: this.getFieldOrderComparer(s, o, e)
      });
    });
  }
  orderRecords() {
    if (this._sort_order == null || this._sort_order.length == 0)
      return;
    const e = this._partData.splice(0, 1)[0];
    this._partData.sort((t, r) => {
      for (let s of this._sort_order) {
        const o = s.cmp(t[s.idx], r[s.idx]);
        if (o != 0)
          return o;
      }
      return 0;
    }), this._partData.splice(0, 0, e);
  }
  initDataContextForPart(e) {
    let t, r, s;
    if (this._partData = e.getData()[this.layout.record_type], !this._partData || this._partData.length < 2) {
      if (!this.layout.hasOwnProperty("on_record_missing") || this.layout.on_record_missing === "hide")
        return;
      s = [], this.recordMissing = !0;
    } else
      s = this._partData[1];
    if (this._UIDFieldIdx = this._partData[0].findIndex((o) => o === "uid"), this._UIDFieldIdx != -1)
      return t = this.dataContext.clone(), r = new Qs(
        this.recordType,
        this.dataContext,
        {
          fields: this._partData[0],
          record: s
        }
      ), r && (t.registerAccessor(r), this.dataContext = t), t;
  }
  moveToNextRow(e) {
    let t = -1;
    if (this.recordMissing || !this._partData || (e ? (t = parseInt(e), Number.isNaN(t) && (t = -1)) : t = 0, t += 1, t == 0))
      return "";
    if (t >= this._partData.length)
      return this.dataContext.deleteAccessorIfExists(this.recordType), "";
    const r = new Qs(
      this.recordType,
      this.dataContext,
      {
        fields: this._partData[0],
        record: this._partData[t]
      }
    );
    return this._dataContext.registerAccessor(r), t.toString();
  }
  getPartExpansionSettings() {
    let e, t;
    return this.layout.view_type === "list" && this.maxHeight && (e = this.maxHeight, this.expandable && (t = this.opened ? "close" : "open")), { maxHeight: e, buttonMode: t };
  }
  getGotoIdentifierEvent(e, t, r) {
    const o = this.findElement(t).element_type.links_to;
    let n = o || this.recordType;
    if (o && o !== this.recordType && o !== this._document.compilation.record_type) {
      const a = e.get_fields_with_instruction(o, "identifier");
      if (a.length > 0) {
        r = "";
        for (const l of a) {
          let c = e.get_field_instruction(o, l, "identifier");
          if (c.parameters.length == 0 || c.parameters[0] == "primary") {
            r = this.dataContext.get(`/${o}/${l}`);
            break;
          }
        }
      }
    }
    if (r && n)
      return new CustomEvent(
        "goto-identifier",
        {
          detail: {
            dsdName: t,
            tableName: n,
            identifier: r
          },
          bubbles: !0,
          composed: !0
        }
      );
  }
  findElement(e) {
    let t = [this.layout];
    if (this._cachedElements.hasOwnProperty(e))
      return this._cachedElements[e];
    for (const r of t)
      for (const s of Object.keys(r.ui_elements)) {
        if (s === e)
          return this._cachedElements[e] = r.ui_elements[s], r.ui_elements[s];
        r.ui_elements[s].hasOwnProperty("element_type") && r.ui_elements[s].element_type.hasOwnProperty("ui_elements") && t.push(r.ui_elements[s].element_type);
      }
  }
  _lookup(e, t, r) {
    switch (r.lookup_type) {
      case "record":
        return this._lookup_record(e, t, r);
      case "dictionary":
        return this._lookup_in_dictionary(e, t, r);
    }
    return e;
  }
  _lookup_record(e, t, r) {
    try {
      const s = r.record_type, o = this._document["kioskview.lookup_data"];
      if (!o)
        return e;
      const n = o[s];
      if (!n || n.length < 2)
        return e;
      const a = n[0].findIndex((c) => c === r.display_value), l = n[0].findIndex((c) => c === r.key_field);
      for (let c = 1; c < n.length; c++) {
        const d = n[c];
        if (c > 0 && d[l] === e)
          return d[a];
      }
      return e;
    } catch (s) {
      throw `_lookup_records: ${s}`;
    }
  }
  _lookup_in_dictionary(e, t, r) {
    return this.dataContext.getAccessor("dictionary").get(r.path, e, Re.GET_MODE_DEFAULT);
  }
  resolveDataRequest(e, t) {
    const r = this.interpreter.interpret(e);
    try {
      if (t && r) {
        const s = this.findElement(t);
        if (s && s.element_type.hasOwnProperty("lookup"))
          return this._lookup(r, t, s.element_type.lookup);
      }
      return r;
    } catch (s) {
      return `elementId: ${s}`;
    }
  }
}
const Lt = class Lt {
  constructor() {
    this.ok = !1, this.parameters = [], this.instruction = "", this.err = "s";
  }
  parse(e) {
    const t = new RegExp(Lt.src_regex_function, "g"), r = new RegExp(Lt.src_regex_params, "g");
    this.ok = !1;
    const s = t.exec(e);
    if (s && Object.keys(s.groups).length === 2) {
      this.instruction = s.groups.instruction;
      const o = s.groups.params;
      if (o.trim() === "")
        this.ok = !0;
      else {
        const n = o.matchAll(r);
        for (const a of n) {
          for (const l of ["param_quote", "param_singlequote", "param_noquote"])
            try {
              if (a.groups[l] !== void 0) {
                let c = a.groups[l];
                l !== "param_noquote" && c.toLowerCase() === "null" && (c = `'${c}'`), this.parameters.push(c);
              }
            } catch {
            }
          if (a.groups.end !== ",")
            break;
        }
        this.ok = this.parameters.length > 0;
      }
    } else
      this.err = "too many or too few syntactical groups. 'Instruction' and 'parameters' are expected";
    return this.ok;
  }
  static quickCheck(e) {
    return !!new RegExp(Lt.src_regex_function).exec(e);
  }
};
Oe(Lt, "src_regex_function", String.raw`^\s*(?<instruction>[a-zA-z0-9]+)\((?<params>.*?)\)\s*$`), Oe(Lt, "src_regex_params", String.raw`((\s*"(?<param_quote>.*?)"\s*)|(\s*'(?<param_singlequote>.*?)'\s*)|(\s*(?<param_noquote>[^,]*)))(?<end>,|$)`);
let Xs = Lt;
const nm = class da {
  _check_version(e) {
    if (e != da.CURRENT_DSD_FORMAT_VERSION)
      throw `DataSetDefinition.loadFromJSON: DSD Version ${e} is not supported.`;
  }
  /**
   * loads the dsd data from a dictionary that is a preparsed version of a merely textual DSD
   * Checks if the structure is okay or throws errors.
   *
   * @param version the DSD format's version
   * @param data the DSD Data (only tables, not the header)
   */
  loadFromDict(e, t = da.CURRENT_DSD_FORMAT_VERSION) {
    this._check_version(t), this._check_dsd_structure(e), this._dsd = e;
  }
  _check_dsd_structure(e) {
    for (const t of Object.keys(e)) {
      if (typeof e[t] != "object")
        throw `DataSetDefinition._check_dsd_structure: ${t} definition is foul.`;
      this._check_table_structure(t, e[t]);
    }
  }
  _check_table_structure(e, t) {
    for (const r of Object.keys(t)) {
      if (!Array.isArray(t[r]))
        throw `DataSetDefinition._check_table_field_structure: ${e}.${r} field definition is foul.`;
      this._check_table_field_structure(e, r, t[r]);
    }
  }
  _check_table_field_structure(e, t, r) {
    for (const s of r)
      if (!Xs.quickCheck(s))
        throw `DataSetDefinition._check_table_field_structure: ${e}.${t} has malformed instruction ${s}`;
  }
  get tables() {
    return this.list_tables();
  }
  list_tables() {
    return Object.keys(this._dsd);
  }
  has_table(e) {
    return this._dsd.hasOwnProperty(e);
  }
  list_fields(e) {
    if (!this.has_table(e))
      throw `DataSetDefinition.list_fields: ${e} does not exist`;
    return [...Object.keys(this._dsd[e])];
  }
  has_field(e, t) {
    return this.has_table(e) ? this._dsd[e].hasOwnProperty(t) : !1;
  }
  _extract_field_instructions_from_array(e, t = "") {
    const r = [];
    for (const s of e) {
      let o = new Xs();
      if (o.parse(s)) {
        const n = {
          instruction: o.instruction,
          parameters: [...o.parameters]
        };
        if (t) {
          if (n.instruction === t)
            return [n];
        } else
          r.push(n);
      } else
        throw `${s} syntax error`;
    }
    return r;
  }
  list_field_instructions(e, t) {
    if (!this.has_field(e, t))
      throw `DataSetDefinition.list_field_instructions: ${e}.${t} does not exist`;
    const r = this._dsd[e][t];
    try {
      return this._extract_field_instructions_from_array(r);
    } catch (s) {
      throw `DataSetDefinition.list_field_instructions: ${e}.${t}: ${s}`;
    }
  }
  _has_instruction(e, t) {
    return !!this._extract_field_instructions_from_array(e).find((s) => s.instruction === t);
  }
  /**
   * returns a list with the names of the fields that have the requested instruction.
   * @param tableName
   * @param requestedInstruction
   */
  get_fields_with_instruction(e, t) {
    if (!this.has_table(e))
      throw `DataSetDefinition.get_fields_with_instructions: ${e} does not exist`;
    try {
      return Object.keys(this._dsd[e]).filter(
        (r) => this._has_instruction(this._dsd[e][r], t)
      );
    } catch (r) {
      throw `DataSetDefinition.get_fields_with_instruction: ${e}: ${r}`;
    }
  }
  get_field_instruction(e, t, r) {
    if (!this.has_field(e, t))
      throw `DataSetDefinition.get_field_instructions: ${e}.${t} does not exist`;
    const s = this._dsd[e][t];
    try {
      const o = this._extract_field_instructions_from_array(s, r);
      return o.length != 1 ? void 0 : o[0];
    } catch (o) {
      throw `DataSetDefinition.get_field_instruction: ${e}.${t} / ${r}: ${o}`;
    }
  }
  get_field_instruction_parameters(e, t, r) {
    const s = this.get_field_instruction(e, t, r);
    if (s)
      return s.parameters;
  }
  /**
   * returns an array of the record types that are back-joined by the source table.
   * Only accepts joins with a "1" quantifier as valud back links
   * In a dataset with a join series of site <- unit <- locus this would return ["unit, "site"]
   * @param tableName The source table from where the joins start to get interpreted.
   */
  get_lore_tables(e) {
    const t = [];
    let r = [e];
    for (; r.length; ) {
      const s = r.pop();
      if (this.has_table(s)) {
        s !== e && t.push(s);
        const o = this.get_fields_with_instruction(s, "join");
        for (let n of o) {
          const a = this.get_field_instruction_parameters(s, n, "join");
          (a.length > 2 ? a[2] : "1") == "1" && r.push(a[0]);
        }
      }
    }
    return t;
  }
  /**
   * returns the datatype for a field. If that doesn't succeed an exception will be thrown.
   *
   * @param tableName the name of the table
   * @param fieldName the name of the field
   '
   * @return the data type as a string
   */
  get_field_data_type(e, t) {
    return this.get_field_instruction(e, t, "datatype").parameters[0];
  }
};
nm.CURRENT_DSD_FORMAT_VERSION = 3;
let P1 = nm;
class M1 {
  constructor() {
    this.MAX_VERSION = 1, this._dataContext = void 0;
  }
  set dataContext(e) {
    this._dataContext = e;
  }
  get name() {
    return this._compilation.name;
  }
  get recordType() {
    return this._compilation.record_type;
  }
  get dsd() {
    return this._dsd;
  }
  _check_header(e) {
    if (e.hasOwnProperty("kioskview.header"))
      if (e["kioskview.header"].hasOwnProperty("version")) {
        if (e["kioskview.header"].version <= this.MAX_VERSION)
          return !0;
        throw `Cannot process version ${e["kioskview.header"].version} of ApiKioskViewDocument`;
      } else
        throw "ApiKioskViewDocument has no version in header";
    else
      throw "ApiKioskViewDocument has no header";
  }
  _check_compilation(e) {
    if (!e.hasOwnProperty("compilation"))
      throw "ApiKioskViewDocument has no compilation";
    if (!e.compilation.hasOwnProperty("name"))
      throw "ApiKioskViewDocument.compilation has no name";
    if (!e.compilation.hasOwnProperty("record_type"))
      throw "ApiKioskViewDocument.compilation has no record_type";
    if (!e.compilation.hasOwnProperty("groups") || Object.keys(e.compilation.groups).length == 0)
      throw "ApiKioskViewDocument.compilation has no groups";
    Object.keys(e.compilation.groups).forEach((t) => {
      this._check_group(t, e.compilation.groups[t]), Object.keys(e.compilation.groups[t].parts).forEach(
        (r) => Js.check_part(t, r, e)
      );
    });
  }
  _check_group(e, t) {
    if (!t)
      throw `KioskViewDocument group ${e} empty or compromised`;
    if (!t.hasOwnProperty("parts") || Object.keys(t.parts).length == 0)
      throw `KioskViewDocument group ${e} has no parts`;
    if (!t.hasOwnProperty("type"))
      throw `KioskViewDocument group ${e} has no type`;
    if (t.type !== "accordion" && t.type !== "stacked")
      throw `KioskViewDocument group ${e} has unknown type ${t.type}`;
  }
  _check_data(e) {
    if (!e.hasOwnProperty("kioskview.data"))
      throw "ApiKioskViewDocument has no kioskview.data section";
  }
  _check_dsd(e) {
    if (!e.hasOwnProperty("kioskview.dsd"))
      throw "ApiKioskViewDocument has no kioskview.dsd section";
  }
  load(e) {
    this._data = null, this._check_header(e), this._check_compilation(e), this._check_data(e), this._check_dsd(e), this._data = e, this._dsd = new P1(), this._dsd.loadFromDict(this._data["kioskview.dsd"]), this._compilation = this._data.compilation;
  }
  _assert_data() {
    if (!this._data)
      throw "No valid KioskViewDocument loaded.";
  }
  /**
   * returns a tuple per group consisting of [group-id, group type]
   */
  getGroups() {
    return this._assert_data(), Object.keys(this._compilation.groups).map((e) => [e, this._compilation.groups[e].type]);
  }
  getParts(e) {
    if (!this._data.compilation.groups.hasOwnProperty(e))
      throw `KioskViewDocument.getParts: Group ${e} unknown.`;
    const t = Object.keys(this._compilation.groups[e].parts).map(
      (r) => new Js(this._data, e, r, this._dataContext)
    );
    return t.sort(
      (r, s) => r.position < s.position ? -1 : r.position > s.position ? 1 : 0
    ), t;
  }
  getDSD() {
    return this._data["kioskview.dsd"];
  }
  getData() {
    return this._data["kioskview.data"];
  }
  getImageDescriptions() {
    return this._data["kioskview.images"];
  }
}
class z1 extends Ga {
  constructor(e, t, r = void 0) {
    super(e, t), this.rootKey = "/$/images/descriptions", this.assignEntries(r);
  }
  /**
   * assigns an array of description entries as (not to!) the description dict. So
   * this is replacing the whole dictionary! The path value of the Constant instance follows
   * the "constants" api: there the path would be e.g. "glossary" and the key "some term". In the dictionary that
   * would be accessible as "/$/images/descriptions/uuid"
   * @param descriptions an array of Constant instances.
   */
  assignEntries(e) {
    this.descriptions = e;
  }
  get(e, t, r = 0) {
    let s = this.descriptions[t];
    if (s)
      return s;
  }
}
var N1 = Object.defineProperty, F1 = Object.getOwnPropertyDescriptor, R1 = Object.getPrototypeOf, L1 = Reflect.get, It = (i, e, t, r) => {
  for (var s = r > 1 ? void 0 : r ? F1(e, t) : e, o = i.length - 1, n; o >= 0; o--)
    (n = i[o]) && (s = (r ? n(e, t, s) : n(s)) || s);
  return r && s && N1(e, t, s), s;
}, V1 = (i, e, t) => L1(R1(i), t, e);
const H1 = !1;
let ce = class extends Xt {
  constructor() {
    super(), this.viewDocument = null, this.loadingMessage = "", this.showLocalProgress = !1, this.localError = "", this.dataContext = new Re(), this._groupParts = {};
  }
  static getViewId(i) {
    return `view:${i.tableName}|${i.dsdIdentifierFieldName}|${i.identifier}`;
  }
  firstUpdated(i) {
    super.firstUpdated(i);
  }
  willUpdate(i) {
  }
  updated(i) {
    super.updated(i), i.has("apiContext") || i.has("viewDetails") ? (this.viewDocument = void 0, this.apiContext && (this.constants = void 0, this.dataContext = new Re(), this._groupParts = {}, this.fetchViewFromApi())) : i.has("viewDocument") && this.viewDocument && this.assignUIs();
  }
  fetchViewFromApi() {
    this.loadingMessage = "loading view ...", this.showLocalProgress = !0;
    const i = new URLSearchParams();
    i.append("identifier", this.viewDetails.identifier), this.apiContext.fetchFromApi(
      "queryandview",
      `view/${this.viewDetails.tableName}`,
      {
        method: "GET",
        caller: "kioskview.fetchViewFromApi"
      },
      "v1",
      i
    ).then((e) => {
      this.loadingMessage = "", this.showLocalProgress = !1, "result_msg" in e && e.result_msg !== "ok" || this.loadViewDocument(e);
    }).catch((e) => {
      this.loadingMessage = "", this.showLocalProgress = !1, Sr(this, e, "KioskView.fetchViewFromApi", null);
    });
  }
  loadViewDocument(i) {
    i.hasOwnProperty("document") || (this.localError = "loadViewDocument: the server responded with an empty or invalid response.");
    const e = new M1();
    try {
      e.dataContext = this.dataContext, e.load(i.document), this.viewDocument = e;
    } catch (t) {
      this.localError = `loadViewDocument: the server responded with an invalid document: ${t}`;
    }
    this.assignConstants(), this.assignBasicDataContext(), this.assignLore(), this.assignFileDescriptions();
  }
  assignConstants() {
    if (this.constants) {
      const i = new Ya("dictionary", this.dataContext, this.constants);
      i.assignEntries(this.constants), this.dataContext.registerAccessor(i);
    }
  }
  assignLore() {
    if (this.viewDocument.dsd)
      for (const i of this.viewDocument.dsd.get_lore_tables(this.viewDetails.tableName)) {
        const e = new Qs(
          i,
          this.dataContext,
          {
            fields: this.viewDocument.getData()[i][0],
            record: this.viewDocument.getData()[i][1]
          }
        );
        this.dataContext.registerAccessor(e);
      }
  }
  assignFileDescriptions() {
    const i = this.viewDocument.getImageDescriptions();
    if (i) {
      const e = new z1("imagedescriptions", this.dataContext, i);
      this.dataContext.registerAccessor(e);
    }
  }
  assignBasicDataContext() {
    const i = this.viewDocument.getData()[this.viewDetails.tableName];
    if (i.length < 2)
      return;
    const e = new Qs(
      this.viewDetails.tableName,
      this.dataContext,
      {
        fields: i[0],
        record: i[1]
      }
    );
    this.dataContext.registerAccessor(e);
  }
  loadUI(i) {
    const e = i.layout;
    return {
      header: { version: 1 },
      dsd: this.viewDocument.getDSD(),
      layout_settings: { ...e.layout_settings, readonly: !0 },
      meta: {
        scenario: "view"
      },
      ui_elements: i.layout.ui_elements
    };
  }
  findPart(i) {
    for (const e of Object.values(this._groupParts)) {
      const t = e.findIndex((r) => r.partId === i);
      if (t > -1)
        return e[t];
    }
  }
  getGroupParts(i) {
    return this._groupParts[i] || (this._groupParts[i] = this.viewDocument.getParts(i)), this._groupParts[i];
  }
  fetchFileFromApi(i, e) {
    let t = new URLSearchParams({
      uuid: i,
      resolution: e
    });
    return this.apiContext.fetchBlobFromApi(
      "",
      "files/file",
      {
        method: "GET",
        caller: "kioskview.fetchFileFromApi"
      },
      "v1",
      t
    );
  }
  assignUIs() {
    for (const i of this.viewDocument.getGroups())
      this.getGroupParts(i[0]).forEach((t) => {
        try {
          if (!t.recordMissing) {
            const r = this.renderRoot.querySelector(`#ui-${t.cssPartId}`);
            r && (r.dataProvider = (s, o) => t.resolveDataRequest(s, o), r.moveToNextRow = (s) => t.moveToNextRow(s), r.setSortOrder = (s) => {
              t.createSortOrder(this.viewDocument, s), t.orderRecords();
            }, r.fetchFileProvider = (s) => {
              this.fetchFileFromApi(s.uuid, s.resolution).then((o) => {
                s.reportURL(URL.createObjectURL(o));
              }).catch((o) => {
                o.response.status != 404 && Sr(this, o, "fetchFileProvider", null);
              }), setTimeout(() => {
              }, 2e3);
            }, r.uiSchema = this.loadUI(t), r.showDevelopmentInfo = H1, r.addEventListener("goto-identifier", (s) => {
              s.preventDefault(), s.stopPropagation();
              const o = t.getGotoIdentifierEvent(this.viewDocument.dsd, s.detail.fieldId, s.detail.identifier);
              this.dispatchEvent(o);
            }));
          }
        } catch {
        }
      });
  }
  renderPart(i) {
    return i.recordMissing && i.layout.on_record_missing === "message" ? p`<div class="missing-record-message"><i></i> Sorry, but there is no available data of this type</div>` : p`
                <ui-component id="ui-${i.cssPartId}"></ui-component>`;
  }
  expandHeader(i) {
    const t = i.currentTarget.dataset.partId, r = this.findPart(t);
    r && r.expandable && (r.toggleOpen(), this.requestUpdate());
  }
  renderStackedPartHeader(i) {
    let { maxHeight: e, buttonMode: t } = i.getPartExpansionSettings(), r;
    return t && (r = t == "close" ? p`<i></i>` : p`<i></i>`), p`<div data-part-id=${i.partId} class="part-header" @click="${i.expandable ? this.expandHeader : b}">
            <span>${i.text}</span>
            ${i.expandable ? r : b}
        </div>`;
  }
  renderPartBody(i) {
    let { maxHeight: e, buttonMode: t } = i.getPartExpansionSettings();
    const r = "part-body-" + i.cssPartId;
    return p`<div id="${r}" data-max-height="${e}" 
                         class="part-body" style="${t === "open" ? "max-height:" + e : b}">
            ${this.renderPart(i)}
            </div>`;
  }
  renderStackedGroup(i) {
    const e = this.getGroupParts(i).filter((t) => t.initDataContextForPart(this.viewDocument));
    return p`
            <div class="view-group stacked">
                ${e.map((t) => p`
                    <div class="view-part stacked">
                        ${this.renderStackedPartHeader(t)}
                        ${this.renderPartBody(t)}
                    </div>
                `)}        
            </div>`;
  }
  renderAccordionPartHeader(i) {
    let { maxHeight: e, buttonMode: t } = i.getPartExpansionSettings(), r;
    return t && (r = t == "close" ? p`<i></i>` : p`<i></i>`), p`<div data-part-id=${i.partId} class="accordion-part-header" @click="${i.expandable ? this.expandHeader.bind(this) : b}">
            <div>${i.text}</div>
            <div>${i.expandable ? r : b}</div>
        </div>`;
  }
  renderAccordionPartBody(i) {
    let { maxHeight: e, buttonMode: t } = i.getPartExpansionSettings();
    const r = "part-body-" + i.cssPartId;
    let s = "max-height: " + (e || "100vh");
    return s = s + (t === "open" ? ";display:none" : ""), p`
            <div id="${r}"
                 style="${s}"
                 class="part-body">
                ${this.renderPart(i)}
            </div>`;
  }
  renderAccordionGroup(i) {
    const e = this.getGroupParts(i).filter((t) => t.initDataContextForPart(this.viewDocument));
    return p`
            <div class="view-group stacked">
                ${e.map((t) => p`
                    <div class="view-part stacked">
                        ${this.renderAccordionPartHeader(t)}
                        ${this.renderAccordionPartBody(t)}
                    </div>
                `)}
            </div>`;
  }
  renderGroups() {
    const i = this.viewDocument.getGroups();
    return this.dataContext && this.dataContext.ids.find((e) => e === this.viewDetails.tableName) ? p`
                <div class="kiosk-view">
                    ${i.map((e) => p`
                        ${e[1] === "stacked" ? this.renderStackedGroup(e[0]) : e[1] === "accordion" ? this.renderAccordionGroup(e[0]) : p`unknown group type`}
                    `)}
                </div>` : p`<div class="missing-record-message"><i></i> Sorry, but there is no data available</div>`;
  }
  apiRender() {
    return this.localError ? this.renderLocalError() : p`
                ${this.showLocalProgress || !this.viewDocument ? this.renderProgress(!0) : this.renderGroups()}
            `;
  }
  renderProgress(i = !1) {
    let e = super.renderProgress(i);
    return e ? p`${e}
                  <div class="loading-message">${this.loadingMessage}</div>` : p``;
  }
  renderLocalError() {
    return p`<div class="local-error">${this.localError}</div>`;
  }
};
ce.styles = tt(ex);
ce.properties = {
  ...V1(ce, ce, "properties")
};
It([
  z()
], ce.prototype, "viewDocument", 2);
It([
  z()
], ce.prototype, "uiSchema", 2);
It([
  G()
], ce.prototype, "viewDetails", 2);
It([
  z()
], ce.prototype, "loadingMessage", 2);
It([
  z()
], ce.prototype, "showLocalProgress", 2);
It([
  z()
], ce.prototype, "localError", 2);
It([
  to({ context: ro }),
  z()
], ce.prototype, "constants", 2);
ce = It([
  Qt("kiosk-view")
], ce);
var B1 = Object.defineProperty, U1 = Object.getOwnPropertyDescriptor, q1 = Object.getPrototypeOf, W1 = Reflect.get, or = (i, e, t, r) => {
  for (var s = r > 1 ? void 0 : r ? U1(e, t) : e, o = i.length - 1, n; o >= 0; o--)
    (n = i[o]) && (s = (r ? n(e, t, s) : n(s)) || s);
  return r && s && B1(e, t, s), s;
}, j1 = (i, e, t) => W1(q1(i), t, e);
Kn("/sl_assets");
const Se = class extends Jd {
  constructor() {
    super(), this._messages = {}, this.inSelectQueryMode = !1, this.inGotoIdentifierMode = !1, this.queries = [], this.views = /* @__PURE__ */ new Map(), this.selectQueryTab = null, this.constants = [], this.identifierInfo = [], this.recordTypeAliases = {};
  }
  firstUpdated(e) {
    super.firstUpdated(e);
  }
  getRecordTypeAliases() {
    this.recordTypeAliases = {};
    for (const e of this.constants)
      e.path === "file_repository/recording_context_aliases" && (this.recordTypeAliases[e.key] = e.value);
  }
  fetchConstants() {
    this.showProgress = !0, this.apiContext.fetchFromApi(
      "",
      "constants",
      {
        method: "GET",
        caller: "app.fetchConstants"
      }
    ).then((e) => (this.showProgress = !1, this.constants = e, this.getRecordTypeAliases(), this.apiContext.fetchFromApi(
      "",
      "contexts/full",
      {
        method: "GET",
        caller: "app.fetchConstants"
      }
    ))).then((e) => {
      this.identifierInfo = e.identifiers;
    }).catch((e) => {
      this.showProgress = !1, Sr(this, e, "loadConstants", null);
    });
  }
  apiConnected() {
    this.fetchConstants();
  }
  reloadClicked(e) {
    this.requestUpdate();
  }
  selectQueryClicked(e) {
    this.inSelectQueryMode || (this.inSelectQueryMode = !0);
  }
  selectGoToClicked(e) {
    this.inGotoIdentifierMode || (this.inGotoIdentifierMode = !0);
  }
  queryModeClosed(e) {
    e.detail && this.openQuery(e.detail), this.inSelectQueryMode = !1;
  }
  identifierPopupClosed(e) {
    if (this.inGotoIdentifierMode = !1, e.detail) {
      const t = new CustomEvent(
        "identifierClicked",
        {
          detail: {
            dsdIdentifierFieldName: e.detail.dsdName,
            tableName: e.detail.tableName,
            identifier: e.detail.identifier
          },
          bubbles: !0
        }
      );
      this.onGotoIdentifier(t);
    }
  }
  openQuery(e) {
    if (mi.getKioskQueryTag(e.type)) {
      let r = { uid: ew(), ...e };
      this.queries.push(r), this.requestUpdate(), this.updateComplete.then(() => {
        this.shadowRoot.getElementById("query-layout").selectPage(r.uid);
      });
    }
  }
  gotoIdentifier(e) {
    if (e.currentTarget.id === "btGoto")
      var r = this.renderRoot.querySelector("#devIdentifier"), s = r.value.split("/")[0], o = r.value.split("/")[1], n = "arch_context";
    else
      var a = e.currentTarget, o = a.dataset.identifier, s = a.dataset.tableName, n = a.dataset.fieldName;
    const l = new CustomEvent(
      "identifierClicked",
      {
        detail: {
          dsdIdentifierFieldName: n,
          tableName: s,
          identifier: o
        },
        bubbles: !0
      }
    );
    this.onGotoIdentifier(l);
  }
  onGotoIdentifier(e) {
    let t = e.detail;
    const r = ce.getViewId(t);
    if (!this.views.has(r)) {
      let s = { viewId: r, details: { ...t } };
      this.views.set(r, s), this.requestUpdate(), this.updateComplete.then(() => {
        this.shadowRoot.getElementById("view-layout").selectPage(s.viewId);
      });
    }
  }
  renderToolbar() {
    return te`
            <div class="toolbar">
                <div id="toolbar-left">
                    <div class="toolbar-button" @click="${this.selectQueryClicked}">
                        <i class="fas fa-query"></i>
                    </div>
                    ${this.identifierInfo.length > 0 ? te`
                    <div class="toolbar-button footstep-toolbar-button" @click="${this.selectGoToClicked}">
                        <i class="fas fa-footsteps"></i>
                    </div>` : b}
                </div>
                <div id="toolbar-buttons">
                    <div style="display:none" class="toolbar-button" @click="${this.reloadClicked}">
                        <i class="fas fa-window-restore"></i>
                    </div>
                    <div class="toolbar-button" @click="${this.reloadClicked}">
                        <i class="fas fa-reload"></i>
                    </div>
                </div>
                <div></div>
            </div>`;
  }
  renderQueryMode() {
    return te`
            <kiosk-query-selector
                id="kiosk-query-selector"
                .apiContext="${this.apiContext}"
                @closeSelection="${this.queryModeClosed}"
                style="display:${this.inSelectQueryMode ? "block" : "none"}"
            >
            </kiosk-query-selector>`;
  }
  renderGotoIdentifierMode() {
    return te`
                <select-identifier-popup
                    id="select-identifier-popup"
                    .apiContext="${this.apiContext}"
                    .shown="${this.inGotoIdentifierMode}"
                    .recordTypeAliases="${this.recordTypeAliases}"
                    @closeSelection="${this.identifierPopupClosed}"
                    style="display:${this.inGotoIdentifierMode ? "block" : "none"}"
                >
                </select-identifier-popup>`;
  }
  renderQuery(e) {
    return te`
            <${mi.getKioskQueryTag(e.type)}
                id="${e.uid}"
                .apiContext="${this.apiContext}"
                .queryDefinition="${e}"
                slot="${e.uid}"
            >

            </${mi.getKioskQueryTag(e.type)}>`;
  }
  renderView(e) {
    return te`
            <kiosk-view
                id="${e.details.tableName}${String(I_(e.viewId))}"
                .apiContext="${this.apiContext}"
                .viewDetails="${e.details}"
                @goto-identifier="${this.onGotoIdentifier}"
                slot="${e.viewId}">
            </kiosk-view}>`;
  }
  onCloseQuery(e) {
    const t = e.detail, r = this.queries.findIndex((s) => s.uid === t);
    this.queries.splice(r, 1), this.requestUpdate();
  }
  onCloseView(e) {
    e.detail, this.views.delete(e.detail), this.requestUpdate();
  }
  renderLayout() {
    return te`
            <kiosk-query-layouter id="query-layout"
                                  .apiContext="${this.apiContext}"
                                  .assignedPages="${this.queries.map((e) => [e.uid, e.name])}"
                                  @close="${this.onCloseQuery}"
                                  @identifierClicked="${this.onGotoIdentifier}"
                                  style="display:${this.inSelectQueryMode || this.inGotoIdentifierMode ? "none" : "block"}"
            >
                ${this.queries.map((e) => this.renderQuery(e))}
            </kiosk-query-layouter>
            <div class="splitter"></div>
            <kiosk-query-layouter id="view-layout"
                                  .apiContext="${this.apiContext}"
                                  .assignedPages="${[...this.views.values()].map((e) => [
      e.viewId,
      e.details.identifier
    ])}"
                                  @close="${this.onCloseView}"
                                  @identifierClicked="${this.onGotoIdentifier}"
                                  style="display:${this.inSelectQueryMode || this.inGotoIdentifierMode ? "none" : "block"}"
            >
                ${[...this.views.values()].map((e) => this.renderView(e))}
            </kiosk-query-layouter>`;
  }
  // apiRender is only called once the api is connected.
  apiRender() {
    let e = te``, t = this.renderToolbar();
    const r = this.constants && this.constants.length > 0 ? te`${this.renderQueryMode()}${this.renderGotoIdentifierMode()}${this.renderLayout()}` : b;
    return te`${e}${t}${r}`;
  }
};
Se.styles = tt(X0);
Se.properties = {
  ...j1(Se, Se, "properties")
};
or([
  z()
], Se.prototype, "inSelectQueryMode", 2);
or([
  z()
], Se.prototype, "inGotoIdentifierMode", 2);
or([
  z()
], Se.prototype, "queries", 2);
or([
  z()
], Se.prototype, "views", 2);
or([
  z()
], Se.prototype, "selectQueryTab", 2);
or([
  tu({ context: ro }),
  z()
], Se.prototype, "constants", 2);
or([
  tu({ context: uf }),
  z()
], Se.prototype, "identifierInfo", 2);
let G1 = Se;
window.customElements.define("queryandview-app", G1);
export {
  G1 as QueryAndViewApp
};
