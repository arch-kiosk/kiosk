var nS = Object.getPrototypeOf;
var sS = Reflect.get;
var aS = (r, e) => () => (e || r((e = { exports: {} }).exports, e), e.exports);
var gp = (r, e, t) => sS(nS(r), t, e);
var gM = aS((hN, Vd) => {
  /**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   */
  const sa = globalThis, qd = sa.ShadowRoot && (sa.ShadyCSS === void 0 || sa.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, Em = Symbol(), mp = /* @__PURE__ */ new WeakMap();
  let lS = class {
    constructor(e, t, i) {
      if (this._$cssResult$ = !0, i !== Em) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
      this.cssText = e, this.t = t;
    }
    get styleSheet() {
      let e = this.o;
      const t = this.t;
      if (qd && e === void 0) {
        const i = t !== void 0 && t.length === 1;
        i && (e = mp.get(t)), e === void 0 && ((this.o = e = new CSSStyleSheet()).replaceSync(this.cssText), i && mp.set(t, e));
      }
      return e;
    }
    toString() {
      return this.cssText;
    }
  };
  const Ue = (r) => new lS(typeof r == "string" ? r : r + "", void 0, Em), cS = (r, e) => {
    if (qd) r.adoptedStyleSheets = e.map(((t) => t instanceof CSSStyleSheet ? t : t.styleSheet));
    else for (const t of e) {
      const i = document.createElement("style"), o = sa.litNonce;
      o !== void 0 && i.setAttribute("nonce", o), i.textContent = t.cssText, r.appendChild(i);
    }
  }, bp = qd ? (r) => r : (r) => r instanceof CSSStyleSheet ? ((e) => {
    let t = "";
    for (const i of e.cssRules) t += i.cssText;
    return Ue(t);
  })(r) : r;
  /**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   */
  const { is: dS, defineProperty: uS, getOwnPropertyDescriptor: hS, getOwnPropertyNames: fS, getOwnPropertySymbols: pS, getPrototypeOf: gS } = Object, Ma = globalThis, _p = Ma.trustedTypes, mS = _p ? _p.emptyScript : "", bS = Ma.reactiveElementPolyfillSupport, Sn = (r, e) => r, ma = { toAttribute(r, e) {
    switch (e) {
      case Boolean:
        r = r ? mS : null;
        break;
      case Object:
      case Array:
        r = r == null ? r : JSON.stringify(r);
    }
    return r;
  }, fromAttribute(r, e) {
    let t = r;
    switch (e) {
      case Boolean:
        t = r !== null;
        break;
      case Number:
        t = r === null ? null : Number(r);
        break;
      case Object:
      case Array:
        try {
          t = JSON.parse(r);
        } catch {
          t = null;
        }
    }
    return t;
  } }, Yd = (r, e) => !dS(r, e), vp = { attribute: !0, type: String, converter: ma, reflect: !1, useDefault: !1, hasChanged: Yd };
  Symbol.metadata ??= Symbol("metadata"), Ma.litPropertyMetadata ??= /* @__PURE__ */ new WeakMap();
  let eo = class extends HTMLElement {
    static addInitializer(e) {
      this._$Ei(), (this.l ??= []).push(e);
    }
    static get observedAttributes() {
      return this.finalize(), this._$Eh && [...this._$Eh.keys()];
    }
    static createProperty(e, t = vp) {
      if (t.state && (t.attribute = !1), this._$Ei(), this.prototype.hasOwnProperty(e) && ((t = Object.create(t)).wrapped = !0), this.elementProperties.set(e, t), !t.noAccessor) {
        const i = Symbol(), o = this.getPropertyDescriptor(e, i, t);
        o !== void 0 && uS(this.prototype, e, o);
      }
    }
    static getPropertyDescriptor(e, t, i) {
      const { get: o, set: a } = hS(this.prototype, e) ?? { get() {
        return this[t];
      }, set(l) {
        this[t] = l;
      } };
      return { get: o, set(l) {
        const d = o?.call(this);
        a?.call(this, l), this.requestUpdate(e, d, i);
      }, configurable: !0, enumerable: !0 };
    }
    static getPropertyOptions(e) {
      return this.elementProperties.get(e) ?? vp;
    }
    static _$Ei() {
      if (this.hasOwnProperty(Sn("elementProperties"))) return;
      const e = gS(this);
      e.finalize(), e.l !== void 0 && (this.l = [...e.l]), this.elementProperties = new Map(e.elementProperties);
    }
    static finalize() {
      if (this.hasOwnProperty(Sn("finalized"))) return;
      if (this.finalized = !0, this._$Ei(), this.hasOwnProperty(Sn("properties"))) {
        const t = this.properties, i = [...fS(t), ...pS(t)];
        for (const o of i) this.createProperty(o, t[o]);
      }
      const e = this[Symbol.metadata];
      if (e !== null) {
        const t = litPropertyMetadata.get(e);
        if (t !== void 0) for (const [i, o] of t) this.elementProperties.set(i, o);
      }
      this._$Eh = /* @__PURE__ */ new Map();
      for (const [t, i] of this.elementProperties) {
        const o = this._$Eu(t, i);
        o !== void 0 && this._$Eh.set(o, t);
      }
      this.elementStyles = this.finalizeStyles(this.styles);
    }
    static finalizeStyles(e) {
      const t = [];
      if (Array.isArray(e)) {
        const i = new Set(e.flat(1 / 0).reverse());
        for (const o of i) t.unshift(bp(o));
      } else e !== void 0 && t.push(bp(e));
      return t;
    }
    static _$Eu(e, t) {
      const i = t.attribute;
      return i === !1 ? void 0 : typeof i == "string" ? i : typeof e == "string" ? e.toLowerCase() : void 0;
    }
    constructor() {
      super(), this._$Ep = void 0, this.isUpdatePending = !1, this.hasUpdated = !1, this._$Em = null, this._$Ev();
    }
    _$Ev() {
      this._$ES = new Promise(((e) => this.enableUpdating = e)), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), this.constructor.l?.forEach(((e) => e(this)));
    }
    addController(e) {
      (this._$EO ??= /* @__PURE__ */ new Set()).add(e), this.renderRoot !== void 0 && this.isConnected && e.hostConnected?.();
    }
    removeController(e) {
      this._$EO?.delete(e);
    }
    _$E_() {
      const e = /* @__PURE__ */ new Map(), t = this.constructor.elementProperties;
      for (const i of t.keys()) this.hasOwnProperty(i) && (e.set(i, this[i]), delete this[i]);
      e.size > 0 && (this._$Ep = e);
    }
    createRenderRoot() {
      const e = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
      return cS(e, this.constructor.elementStyles), e;
    }
    connectedCallback() {
      this.renderRoot ??= this.createRenderRoot(), this.enableUpdating(!0), this._$EO?.forEach(((e) => e.hostConnected?.()));
    }
    enableUpdating(e) {
    }
    disconnectedCallback() {
      this._$EO?.forEach(((e) => e.hostDisconnected?.()));
    }
    attributeChangedCallback(e, t, i) {
      this._$AK(e, i);
    }
    _$ET(e, t) {
      const i = this.constructor.elementProperties.get(e), o = this.constructor._$Eu(e, i);
      if (o !== void 0 && i.reflect === !0) {
        const a = (i.converter?.toAttribute !== void 0 ? i.converter : ma).toAttribute(t, i.type);
        this._$Em = e, a == null ? this.removeAttribute(o) : this.setAttribute(o, a), this._$Em = null;
      }
    }
    _$AK(e, t) {
      const i = this.constructor, o = i._$Eh.get(e);
      if (o !== void 0 && this._$Em !== o) {
        const a = i.getPropertyOptions(o), l = typeof a.converter == "function" ? { fromAttribute: a.converter } : a.converter?.fromAttribute !== void 0 ? a.converter : ma;
        this._$Em = o;
        const d = l.fromAttribute(t, a.type);
        this[o] = d ?? this._$Ej?.get(o) ?? d, this._$Em = null;
      }
    }
    requestUpdate(e, t, i) {
      if (e !== void 0) {
        const o = this.constructor, a = this[e];
        if (i ??= o.getPropertyOptions(e), !((i.hasChanged ?? Yd)(a, t) || i.useDefault && i.reflect && a === this._$Ej?.get(e) && !this.hasAttribute(o._$Eu(e, i)))) return;
        this.C(e, t, i);
      }
      this.isUpdatePending === !1 && (this._$ES = this._$EP());
    }
    C(e, t, { useDefault: i, reflect: o, wrapped: a }, l) {
      i && !(this._$Ej ??= /* @__PURE__ */ new Map()).has(e) && (this._$Ej.set(e, l ?? t ?? this[e]), a !== !0 || l !== void 0) || (this._$AL.has(e) || (this.hasUpdated || i || (t = void 0), this._$AL.set(e, t)), o === !0 && this._$Em !== e && (this._$Eq ??= /* @__PURE__ */ new Set()).add(e));
    }
    async _$EP() {
      this.isUpdatePending = !0;
      try {
        await this._$ES;
      } catch (t) {
        Promise.reject(t);
      }
      const e = this.scheduleUpdate();
      return e != null && await e, !this.isUpdatePending;
    }
    scheduleUpdate() {
      return this.performUpdate();
    }
    performUpdate() {
      if (!this.isUpdatePending) return;
      if (!this.hasUpdated) {
        if (this.renderRoot ??= this.createRenderRoot(), this._$Ep) {
          for (const [o, a] of this._$Ep) this[o] = a;
          this._$Ep = void 0;
        }
        const i = this.constructor.elementProperties;
        if (i.size > 0) for (const [o, a] of i) {
          const { wrapped: l } = a, d = this[o];
          l !== !0 || this._$AL.has(o) || d === void 0 || this.C(o, void 0, a, d);
        }
      }
      let e = !1;
      const t = this._$AL;
      try {
        e = this.shouldUpdate(t), e ? (this.willUpdate(t), this._$EO?.forEach(((i) => i.hostUpdate?.())), this.update(t)) : this._$EM();
      } catch (i) {
        throw e = !1, this._$EM(), i;
      }
      e && this._$AE(t);
    }
    willUpdate(e) {
    }
    _$AE(e) {
      this._$EO?.forEach(((t) => t.hostUpdated?.())), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(e)), this.updated(e);
    }
    _$EM() {
      this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = !1;
    }
    get updateComplete() {
      return this.getUpdateComplete();
    }
    getUpdateComplete() {
      return this._$ES;
    }
    shouldUpdate(e) {
      return !0;
    }
    update(e) {
      this._$Eq &&= this._$Eq.forEach(((t) => this._$ET(t, this[t]))), this._$EM();
    }
    updated(e) {
    }
    firstUpdated(e) {
    }
  };
  eo.elementStyles = [], eo.shadowRootOptions = { mode: "open" }, eo[Sn("elementProperties")] = /* @__PURE__ */ new Map(), eo[Sn("finalized")] = /* @__PURE__ */ new Map(), bS?.({ ReactiveElement: eo }), (Ma.reactiveElementVersions ??= []).push("2.1.1");
  /**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   */
  const Gd = globalThis, ba = Gd.trustedTypes, yp = ba ? ba.createPolicy("lit-html", { createHTML: (r) => r }) : void 0, $m = "$lit$", Br = `lit$${Math.random().toFixed(9).slice(2)}$`, Tm = "?" + Br, _S = `<${Tm}>`, Si = document, Dn = () => Si.createComment(""), Pn = (r) => r === null || typeof r != "object" && typeof r != "function", jd = Array.isArray, vS = (r) => jd(r) || typeof r?.[Symbol.iterator] == "function", _c = `[ 	
\f\r]`, ln = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, wp = /-->/g, kp = />/g, ui = RegExp(`>|${_c}(?:([^\\s"'>=/]+)(${_c}*=${_c}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), xp = /'/g, Cp = /"/g, Om = /^(?:script|style|textarea|title)$/i, yS = (r) => (e, ...t) => ({ _$litType$: r, strings: e, values: t }), S = yS(1), Ao = Symbol.for("lit-noChange"), pe = Symbol.for("lit-nothing"), Sp = /* @__PURE__ */ new WeakMap(), mi = Si.createTreeWalker(Si, 129);
  function Dm(r, e) {
    if (!jd(r) || !r.hasOwnProperty("raw")) throw Error("invalid template strings array");
    return yp !== void 0 ? yp.createHTML(e) : e;
  }
  const wS = (r, e) => {
    const t = r.length - 1, i = [];
    let o, a = e === 2 ? "<svg>" : e === 3 ? "<math>" : "", l = ln;
    for (let d = 0; d < t; d++) {
      const u = r[d];
      let f, g, _ = -1, C = 0;
      for (; C < u.length && (l.lastIndex = C, g = l.exec(u), g !== null); ) C = l.lastIndex, l === ln ? g[1] === "!--" ? l = wp : g[1] !== void 0 ? l = kp : g[2] !== void 0 ? (Om.test(g[2]) && (o = RegExp("</" + g[2], "g")), l = ui) : g[3] !== void 0 && (l = ui) : l === ui ? g[0] === ">" ? (l = o ?? ln, _ = -1) : g[1] === void 0 ? _ = -2 : (_ = l.lastIndex - g[2].length, f = g[1], l = g[3] === void 0 ? ui : g[3] === '"' ? Cp : xp) : l === Cp || l === xp ? l = ui : l === wp || l === kp ? l = ln : (l = ui, o = void 0);
      const x = l === ui && r[d + 1].startsWith("/>") ? " " : "";
      a += l === ln ? u + _S : _ >= 0 ? (i.push(f), u.slice(0, _) + $m + u.slice(_) + Br + x) : u + Br + (_ === -2 ? d : x);
    }
    return [Dm(r, a + (r[t] || "<?>") + (e === 2 ? "</svg>" : e === 3 ? "</math>" : "")), i];
  };
  let Qc = class Pm {
    constructor({ strings: e, _$litType$: t }, i) {
      let o;
      this.parts = [];
      let a = 0, l = 0;
      const d = e.length - 1, u = this.parts, [f, g] = wS(e, t);
      if (this.el = Pm.createElement(f, i), mi.currentNode = this.el.content, t === 2 || t === 3) {
        const _ = this.el.content.firstChild;
        _.replaceWith(..._.childNodes);
      }
      for (; (o = mi.nextNode()) !== null && u.length < d; ) {
        if (o.nodeType === 1) {
          if (o.hasAttributes()) for (const _ of o.getAttributeNames()) if (_.endsWith($m)) {
            const C = g[l++], x = o.getAttribute(_).split(Br), D = /([.?@])?(.*)/.exec(C);
            u.push({ type: 1, index: a, name: D[2], strings: x, ctor: D[1] === "." ? xS : D[1] === "?" ? CS : D[1] === "@" ? SS : Na }), o.removeAttribute(_);
          } else _.startsWith(Br) && (u.push({ type: 6, index: a }), o.removeAttribute(_));
          if (Om.test(o.tagName)) {
            const _ = o.textContent.split(Br), C = _.length - 1;
            if (C > 0) {
              o.textContent = ba ? ba.emptyScript : "";
              for (let x = 0; x < C; x++) o.append(_[x], Dn()), mi.nextNode(), u.push({ type: 2, index: ++a });
              o.append(_[C], Dn());
            }
          }
        } else if (o.nodeType === 8) if (o.data === Tm) u.push({ type: 2, index: a });
        else {
          let _ = -1;
          for (; (_ = o.data.indexOf(Br, _ + 1)) !== -1; ) u.push({ type: 7, index: a }), _ += Br.length - 1;
        }
        a++;
      }
    }
    static createElement(e, t) {
      const i = Si.createElement("template");
      return i.innerHTML = e, i;
    }
  };
  function Eo(r, e, t = r, i) {
    if (e === Ao) return e;
    let o = i !== void 0 ? t._$Co?.[i] : t._$Cl;
    const a = Pn(e) ? void 0 : e._$litDirective$;
    return o?.constructor !== a && (o?._$AO?.(!1), a === void 0 ? o = void 0 : (o = new a(r), o._$AT(r, t, i)), i !== void 0 ? (t._$Co ??= [])[i] = o : t._$Cl = o), o !== void 0 && (e = Eo(r, o._$AS(r, e.values), o, i)), e;
  }
  let kS = class {
    constructor(e, t) {
      this._$AV = [], this._$AN = void 0, this._$AD = e, this._$AM = t;
    }
    get parentNode() {
      return this._$AM.parentNode;
    }
    get _$AU() {
      return this._$AM._$AU;
    }
    u(e) {
      const { el: { content: t }, parts: i } = this._$AD, o = (e?.creationScope ?? Si).importNode(t, !0);
      mi.currentNode = o;
      let a = mi.nextNode(), l = 0, d = 0, u = i[0];
      for (; u !== void 0; ) {
        if (l === u.index) {
          let f;
          u.type === 2 ? f = new Zd(a, a.nextSibling, this, e) : u.type === 1 ? f = new u.ctor(a, u.name, u.strings, this, e) : u.type === 6 && (f = new AS(a, this, e)), this._$AV.push(f), u = i[++d];
        }
        l !== u?.index && (a = mi.nextNode(), l++);
      }
      return mi.currentNode = Si, o;
    }
    p(e) {
      let t = 0;
      for (const i of this._$AV) i !== void 0 && (i.strings !== void 0 ? (i._$AI(e, i, t), t += i.strings.length - 2) : i._$AI(e[t])), t++;
    }
  }, Zd = class Im {
    get _$AU() {
      return this._$AM?._$AU ?? this._$Cv;
    }
    constructor(e, t, i, o) {
      this.type = 2, this._$AH = pe, this._$AN = void 0, this._$AA = e, this._$AB = t, this._$AM = i, this.options = o, this._$Cv = o?.isConnected ?? !0;
    }
    get parentNode() {
      let e = this._$AA.parentNode;
      const t = this._$AM;
      return t !== void 0 && e?.nodeType === 11 && (e = t.parentNode), e;
    }
    get startNode() {
      return this._$AA;
    }
    get endNode() {
      return this._$AB;
    }
    _$AI(e, t = this) {
      e = Eo(this, e, t), Pn(e) ? e === pe || e == null || e === "" ? (this._$AH !== pe && this._$AR(), this._$AH = pe) : e !== this._$AH && e !== Ao && this._(e) : e._$litType$ !== void 0 ? this.$(e) : e.nodeType !== void 0 ? this.T(e) : vS(e) ? this.k(e) : this._(e);
    }
    O(e) {
      return this._$AA.parentNode.insertBefore(e, this._$AB);
    }
    T(e) {
      this._$AH !== e && (this._$AR(), this._$AH = this.O(e));
    }
    _(e) {
      this._$AH !== pe && Pn(this._$AH) ? this._$AA.nextSibling.data = e : this.T(Si.createTextNode(e)), this._$AH = e;
    }
    $(e) {
      const { values: t, _$litType$: i } = e, o = typeof i == "number" ? this._$AC(e) : (i.el === void 0 && (i.el = Qc.createElement(Dm(i.h, i.h[0]), this.options)), i);
      if (this._$AH?._$AD === o) this._$AH.p(t);
      else {
        const a = new kS(o, this), l = a.u(this.options);
        a.p(t), this.T(l), this._$AH = a;
      }
    }
    _$AC(e) {
      let t = Sp.get(e.strings);
      return t === void 0 && Sp.set(e.strings, t = new Qc(e)), t;
    }
    k(e) {
      jd(this._$AH) || (this._$AH = [], this._$AR());
      const t = this._$AH;
      let i, o = 0;
      for (const a of e) o === t.length ? t.push(i = new Im(this.O(Dn()), this.O(Dn()), this, this.options)) : i = t[o], i._$AI(a), o++;
      o < t.length && (this._$AR(i && i._$AB.nextSibling, o), t.length = o);
    }
    _$AR(e = this._$AA.nextSibling, t) {
      for (this._$AP?.(!1, !0, t); e !== this._$AB; ) {
        const i = e.nextSibling;
        e.remove(), e = i;
      }
    }
    setConnected(e) {
      this._$AM === void 0 && (this._$Cv = e, this._$AP?.(e));
    }
  }, Na = class {
    get tagName() {
      return this.element.tagName;
    }
    get _$AU() {
      return this._$AM._$AU;
    }
    constructor(e, t, i, o, a) {
      this.type = 1, this._$AH = pe, this._$AN = void 0, this.element = e, this.name = t, this._$AM = o, this.options = a, i.length > 2 || i[0] !== "" || i[1] !== "" ? (this._$AH = Array(i.length - 1).fill(new String()), this.strings = i) : this._$AH = pe;
    }
    _$AI(e, t = this, i, o) {
      const a = this.strings;
      let l = !1;
      if (a === void 0) e = Eo(this, e, t, 0), l = !Pn(e) || e !== this._$AH && e !== Ao, l && (this._$AH = e);
      else {
        const d = e;
        let u, f;
        for (e = a[0], u = 0; u < a.length - 1; u++) f = Eo(this, d[i + u], t, u), f === Ao && (f = this._$AH[u]), l ||= !Pn(f) || f !== this._$AH[u], f === pe ? e = pe : e !== pe && (e += (f ?? "") + a[u + 1]), this._$AH[u] = f;
      }
      l && !o && this.j(e);
    }
    j(e) {
      e === pe ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, e ?? "");
    }
  }, xS = class extends Na {
    constructor() {
      super(...arguments), this.type = 3;
    }
    j(e) {
      this.element[this.name] = e === pe ? void 0 : e;
    }
  }, CS = class extends Na {
    constructor() {
      super(...arguments), this.type = 4;
    }
    j(e) {
      this.element.toggleAttribute(this.name, !!e && e !== pe);
    }
  }, SS = class extends Na {
    constructor(e, t, i, o, a) {
      super(e, t, i, o, a), this.type = 5;
    }
    _$AI(e, t = this) {
      if ((e = Eo(this, e, t, 0) ?? pe) === Ao) return;
      const i = this._$AH, o = e === pe && i !== pe || e.capture !== i.capture || e.once !== i.once || e.passive !== i.passive, a = e !== pe && (i === pe || o);
      o && this.element.removeEventListener(this.name, this, i), a && this.element.addEventListener(this.name, this, e), this._$AH = e;
    }
    handleEvent(e) {
      typeof this._$AH == "function" ? this._$AH.call(this.options?.host ?? this.element, e) : this._$AH.handleEvent(e);
    }
  }, AS = class {
    constructor(e, t, i) {
      this.element = e, this.type = 6, this._$AN = void 0, this._$AM = t, this.options = i;
    }
    get _$AU() {
      return this._$AM._$AU;
    }
    _$AI(e) {
      Eo(this, e);
    }
  };
  const ES = Gd.litHtmlPolyfillSupport;
  ES?.(Qc, Zd), (Gd.litHtmlVersions ??= []).push("3.3.1");
  const $S = (r, e, t) => {
    const i = t?.renderBefore ?? e;
    let o = i._$litPart$;
    if (o === void 0) {
      const a = t?.renderBefore ?? null;
      i._$litPart$ = o = new Zd(e.insertBefore(Dn(), a), a, void 0, t ?? {});
    }
    return o._$AI(r), o;
  };
  /**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   */
  const Kd = globalThis;
  let so = class extends eo {
    constructor() {
      super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
    }
    createRenderRoot() {
      const e = super.createRenderRoot();
      return this.renderOptions.renderBefore ??= e.firstChild, e;
    }
    update(e) {
      const t = this.render();
      this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(e), this._$Do = $S(t, this.renderRoot, this.renderOptions);
    }
    connectedCallback() {
      super.connectedCallback(), this._$Do?.setConnected(!0);
    }
    disconnectedCallback() {
      super.disconnectedCallback(), this._$Do?.setConnected(!1);
    }
    render() {
      return Ao;
    }
  };
  so._$litElement$ = !0, so.finalized = !0, Kd.litElementHydrateSupport?.({ LitElement: so });
  const TS = Kd.litElementPolyfillSupport;
  TS?.({ LitElement: so });
  (Kd.litElementVersions ??= []).push("4.2.1");
  const Mm = 2, ed = 3;
  /**
  @license
  Copyright (c) 2018 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */
  const Nm = (r) => (e) => class extends e {
    connectedCallback() {
      super.connectedCallback && super.connectedCallback(), this._storeUnsubscribe = r.subscribe(() => this.stateChanged(r.getState())), this.stateChanged(r.getState());
    }
    disconnectedCallback() {
      this._storeUnsubscribe(), super.disconnectedCallback && super.disconnectedCallback();
    }
    /**
     * The `stateChanged(state)` method will be called when the state is updated.
     */
    stateChanged(t) {
    }
  };
  function OS(r) {
    var e, t = r.Symbol;
    return typeof t == "function" ? t.observable ? e = t.observable : (e = t("observable"), t.observable = e) : e = "@@observable", e;
  }
  var to;
  typeof self < "u" ? to = self : typeof window < "u" ? to = window : typeof global < "u" ? to = global : typeof Vd < "u" ? to = Vd : to = Function("return this")();
  var Ap = OS(to), Ep = function() {
    return Math.random().toString(36).substring(7).split("").join(".");
  }, $p = {
    INIT: "@@redux/INIT" + Ep(),
    REPLACE: "@@redux/REPLACE" + Ep()
  };
  function DS(r) {
    if (typeof r != "object" || r === null) return !1;
    for (var e = r; Object.getPrototypeOf(e) !== null; )
      e = Object.getPrototypeOf(e);
    return Object.getPrototypeOf(r) === e;
  }
  function Lm(r, e, t) {
    var i;
    if (typeof e == "function" && typeof t == "function" || typeof t == "function" && typeof arguments[3] == "function")
      throw new Error("It looks like you are passing several store enhancers to createStore(). This is not supported. Instead, compose them together to a single function.");
    if (typeof e == "function" && typeof t > "u" && (t = e, e = void 0), typeof t < "u") {
      if (typeof t != "function")
        throw new Error("Expected the enhancer to be a function.");
      return t(Lm)(r, e);
    }
    if (typeof r != "function")
      throw new Error("Expected the reducer to be a function.");
    var o = r, a = e, l = [], d = l, u = !1;
    function f() {
      d === l && (d = l.slice());
    }
    function g() {
      if (u)
        throw new Error("You may not call store.getState() while the reducer is executing. The reducer has already received the state as an argument. Pass it down from the top reducer instead of reading it from the store.");
      return a;
    }
    function _(P) {
      if (typeof P != "function")
        throw new Error("Expected the listener to be a function.");
      if (u)
        throw new Error("You may not call store.subscribe() while the reducer is executing. If you would like to be notified after the store has been updated, subscribe from a component and invoke store.getState() in the callback to access the latest state. See https://redux.js.org/api-reference/store#subscribelistener for more details.");
      var I = !0;
      return f(), d.push(P), function() {
        if (I) {
          if (u)
            throw new Error("You may not unsubscribe from a store listener while the reducer is executing. See https://redux.js.org/api-reference/store#subscribelistener for more details.");
          I = !1, f();
          var H = d.indexOf(P);
          d.splice(H, 1), l = null;
        }
      };
    }
    function C(P) {
      if (!DS(P))
        throw new Error("Actions must be plain objects. Use custom middleware for async actions.");
      if (typeof P.type > "u")
        throw new Error('Actions may not have an undefined "type" property. Have you misspelled a constant?');
      if (u)
        throw new Error("Reducers may not dispatch actions.");
      try {
        u = !0, a = o(a, P);
      } finally {
        u = !1;
      }
      for (var I = l = d, F = 0; F < I.length; F++) {
        var H = I[F];
        H();
      }
      return P;
    }
    function x(P) {
      if (typeof P != "function")
        throw new Error("Expected the nextReducer to be a function.");
      o = P, C({
        type: $p.REPLACE
      });
    }
    function D() {
      var P, I = _;
      return P = {
        /**
         * The minimal observable subscription method.
         * @param {Object} observer Any object that can be used as an observer.
         * The observer object should have a `next` method.
         * @returns {subscription} An object with an `unsubscribe` method that can
         * be used to unsubscribe the observable from the store, and prevent further
         * emission of values from the observable.
         */
        subscribe: function(H) {
          if (typeof H != "object" || H === null)
            throw new TypeError("Expected the observer to be an object.");
          function Y() {
            H.next && H.next(g());
          }
          Y();
          var W = I(Y);
          return {
            unsubscribe: W
          };
        }
      }, P[Ap] = function() {
        return this;
      }, P;
    }
    return C({
      type: $p.INIT
    }), i = {
      dispatch: C,
      subscribe: _,
      getState: g,
      replaceReducer: x
    }, i[Ap] = D, i;
  }
  const PS = "INIT_APP", Rm = "SET_SELECTOR", Fm = "SET_DATAVIEW_CLASSVALUE", zm = "SET_CONSTANTS", IS = "SET_INIT_STATE";
  class MS {
  }
  const tr = (r, e) => ({
    type: Rm,
    selectorName: r,
    value: e
  }), NS = (r) => ({
    type: zm,
    constants: r
  }), LS = (r, e, t) => ({
    type: Fm,
    dataView: r,
    key: e,
    value: t
  });
  class RS {
    constructor() {
      this.selectors = {}, this.dataviews = {}, this.constants = [], this.initState = 0;
    }
  }
  const FS = new RS(), zS = (r = FS, e) => {
    switch (e.type) {
      case PS:
        return r;
      case IS: {
        let t = { ...r };
        return t.initState = e.value, t;
      }
      case Rm: {
        let t = { ...r };
        const i = e.selectorName;
        return t.selectors[i] = e.value, t;
      }
      case Fm: {
        let t = e, i = { ...r };
        const o = t.dataView;
        o in i.dataviews || (i.dataviews[o] = {});
        let a = i.dataviews[o];
        return a[t.key] = t.value, i;
      }
      case zm: {
        let t = { ...r };
        return t.constants = e.constants, t.initState == 0 && (t.initState = 1), t;
      }
      case "@@INIT":
        return r;
      default:
        return r;
    }
  }, je = Lm(
    zS,
    // @ts-ignore
    window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()
  ), Ru = class Ru extends Nm(je)(so) {
    constructor() {
      super(), this.kiosk_base_url = "/", this.appErrors = [], this.apiContext = void 0, this.showProgress = !1;
    }
    onAppMessage(e) {
      this.addAppError(e.detail.headline + "<br>" + e.detail.body);
    }
    firstUpdated(e) {
      super.firstUpdated(e), this.addEventListener("send-message", this.onAppMessage);
    }
    updated(e) {
      e.has("apiContext") && (this.showProgress = !1, this.apiContext && this.apiContext.status === ed && this.addAppError("Cannot connect to Kiosk API."), !e.apiContext && this.apiContext && this.apiConnected());
    }
    apiConnected() {
    }
    render() {
      let e;
      return this.apiContext && this.apiContext.status === Mm ? e = this.apiRender() : this.apiContext && this.apiContext.status === ed ? e = this.renderApiError() : e = this.renderNoContextYet(), S`
            <style>
                .system-message {
                    border-style: solid;
                    border-width: 2px;
                    padding: 2px 1em;
                    position: relative;
                    margin-bottom: 10px;
                    background: linear-gradient(135deg, #882501, #bb3302);
                    color: #fabc02;
                }
                .loading {
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    height: 5px;
                    width: 100vw;
                    background-color: black;
                }
                .loading-progress {
                    height: 5px;
                    width: 100%;
                    border-radius: 3px;
                    background: linear-gradient(
                        90deg,
                        red 0%,
                        yellow 15%,
                        lime 30%,
                        cyan 50%,
                        blue 65%,
                        magenta 80%,
                        red 100%
                    );
                    background-size: 200%;
                    animation: move-gradient 2s ease-in infinite;
                }
                @keyframes move-gradient {
                    0% {
                        background-position: 0% 0%;
                    }
                    100% {
                        background-position: -200% 0%;
                    }
                }
            </style>
            <link rel="stylesheet" href="${this.kiosk_base_url}static/styles.css" />
            ${this.renderProgress()} ${this.renderErrors()} ${e}
        `;
    }
    renderNoContextYet() {
      return S` <link rel="stylesheet" href="${this.kiosk_base_url}static/styles.css" /> `;
    }
    renderApiError() {
    }
    renderErrors() {
      if (this.appErrors.length > 0)
        return S` ${this.appErrors.map((e) => S`<div class="system-message" @click="${this.errorClicked}">${e}</div>`)} `;
    }
    errorClicked(e) {
      this.deleteError(e.target.textContent);
    }
    renderProgress(e = !1) {
      if (e || this.showProgress)
        return S` <div class="loading">
                <div class="loading-progress"></div>
            </div>`;
    }
    addAppError(e) {
      this.appErrors.push(e), this.requestUpdate();
    }
    deleteError(e) {
      let t = -1;
      this.appErrors.find((i, o) => i === e ? (t = o, !0) : !1), t > -1 && (this.appErrors.splice(t, 1), this.appErrors = [...this.appErrors]);
    }
  };
  Ru.properties = {
    /**
     * The Api Context
     */
    apiContext: { type: Object },
    appErrors: { type: Array },
    showProgress: { type: Boolean }
  };
  let td = Ru;
  /**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   */
  const HS = Symbol.for(""), US = (r) => {
    if (r?.r === HS) return r?._$litStatic$;
  }, Tp = /* @__PURE__ */ new Map(), WS = (r) => (e, ...t) => {
    const i = t.length;
    let o, a;
    const l = [], d = [];
    let u, f = 0, g = !1;
    for (; f < i; ) {
      for (u = e[f]; f < i && (a = t[f], (o = US(a)) !== void 0); ) u += o + e[++f], g = !0;
      f !== i && d.push(a), l.push(u), f++;
    }
    if (f === i && l.push(e[i]), g) {
      const _ = l.join("$$lit$$");
      (e = Tp.get(_)) === void 0 && (l.raw = l, Tp.set(_, e = l)), t = d;
    }
    return r(e, ...t);
  }, cn = WS(S);
  function BS(r, e = {}) {
    return kioskErrorToast(r, e);
  }
  function VS(r, e = {}) {
    return kioskSuccessToast(r, e);
  }
  const qS = 5, YS = 0, vc = "MSG_NETWORK_ERROR";
  let GS = {
    MSG_LOGGED_OUT: {
      severity: 10
    },
    MSG_NETWORK_ERROR: {
      severity: 10
    }
  };
  class jS {
    constructor(e, t, i = "") {
      this.messageId = e, this.headline = t, this.body = i;
    }
  }
  function yc(r, e, t, i = "") {
    let o = new jS(
      e,
      t,
      i
    );
    r.dispatchEvent(new CustomEvent(
      "send-message",
      { bubbles: !0, composed: !0, detail: o }
    ));
  }
  function ZS(r, e, t = null, i = !1) {
    if (!(e.messageId in r)) {
      let o = GS[e.messageId], a = {};
      t ? a = {
        onClosing: t
      } : i && (a = {
        onClosing: () => {
          KS(r, e.messageId);
        }
      }), o.severity >= qS ? (r[e.messageId] = e, BS("<strong>" + e.headline + "</strong><br><br>" + e.body, a)) : o.severity >= YS && (r[e.messageId] = e, VS("<strong>" + e.headline + "</strong><br><br>" + e.body, a));
    }
  }
  function KS(r, e) {
    e in r && delete r[e];
  }
  const rd = [
    "unit-info-widget",
    "narrative-widget",
    "file-widget",
    "locus-widget",
    "cm-widget",
    "feature-widget",
    "deletion-info-widget",
    "archival-entity-widget"
  ];
  function Zr(r) {
    const e = (r.getMonth() + 1).toString().padStart(2, "0"), t = r.getDate().toString().padStart(2, "0");
    return `${r.getFullYear()}-${e}-${t}`;
  }
  function xr(r) {
    const e = r.split("-");
    return new Date(parseInt(e[0]), parseInt(e[1]) - 1, parseInt(e[2]));
  }
  function La(r) {
    let e = {};
    for (let t = 0; t < r.length; t++) {
      let i = r[t];
      try {
        i.path === "file_repository/recording_context_aliases" && (e[i.key] = i.value);
      } catch {
      }
    }
    return e;
  }
  function JS(r) {
    let e = {}, t = r.split("\r");
    for (const i of t) {
      const o = i.split("=");
      e[o[0]] = o[1];
    }
    return e;
  }
  function Ye(r, e, t = !1, i = "") {
    let o = "", a = {};
    for (let l = 0; l < r.length; l++) {
      let d = r[l];
      try {
        if (d.path === "constants/labels" && d.key === e && (o = d.value, !t))
          return o;
        if (t && d.path === "constants/labels" && d.key === "plurals" && (a = JS(d.value)), o && Object.keys(a).length > 0) break;
      } catch {
      }
    }
    try {
      o && a && (o = a[o]);
    } catch {
      o = i;
    }
    return o || i;
  }
  function _a(r, e) {
    return r && e in r ? r[e] : e;
  }
  function dt(r, e, t = "", i = null) {
    if (t && (t += ": "), e.response) {
      if (e.response.status == 403 || e.response.status == 401) {
        yc(
          r,
          vc,
          `${t}You are not logged in properly or your session has timed out`,
          '<a href="/logout">Please log in again.</a>'
        );
        return;
      }
      i ? i(e) : yc(
        r,
        vc,
        `${t}Kiosk server responded with an error.`,
        `(${e.response.statusText}). 
                The server might be down or perhaps you are not logged in properly.`
      );
    } else {
      yc(
        r,
        vc,
        `${t}Kiosk server responded with a network error.`,
        `(${e}). 
            The server might be down or perhaps you are not logged in properly.`
      );
      return;
    }
  }
  function XS(r) {
    const e = [];
    try {
      r.constants?.length > 0 && (rd.forEach((t) => {
        let i = { id: t, displayName: "", active: !0, order: -1 };
        switch (t) {
          case "unit-info-widget":
            i.displayName = `${Ye(
              r.constants,
              "standard_term_for_unit",
              !1,
              "unit"
            )} information`, i.order = 0;
            break;
          case "narrative-widget":
            i.displayName = `${Ye(
              r.constants,
              "standard_term_for_unit",
              !1,
              "unit"
            )} narratives`, i.order = 1;
            break;
          case "file-widget":
            i.displayName = "images and files", i.order = 2;
            break;
          case "locus-widget":
            i.displayName = `${Ye(
              r.constants,
              "standard_term_for_loci",
              !0,
              "loci"
            )}`, i.order = 3;
            break;
          case "cm-widget":
            i.displayName = `${Ye(
              r.constants,
              "standard_term_for_cm",
              !0,
              "collected materials"
            )}`, i.order = 4;
            break;
          case "feature-widget":
            i.displayName = `${Ye(
              r.constants,
              "standard_term_for_feature_unit",
              !0,
              "features"
            )}`, i.order = 5;
            break;
          case "deletion-info-widget":
            i.displayName = "deletions", i.order = 6;
            break;
          case "archival-entity-widget":
            i.displayName = "archival entities", i.order = 7;
            break;
        }
        i.order !== -1 && e.push(i);
      }), e.sort((t, i) => t.order - i.order));
    } catch {
    }
    return e;
  }
  const QS = '.col-bg-body-lighter{background-color:var(--col-bg-body-lighter)}.col-bg-body{background-color:var(--col-bg-body)}.col-bg-body-darker{background-color:var(--col-bg-body-darker)}.col-bg-1-lighter{background-color:var(--col-bg-1-lighter)}.col-bg-1{background-color:var(--col-bg-1)}.col-bg-1-darker{background-color:var(--col-bg-1-darker)}.col-bg-1-input{background-color:var(--col-bg-1-input)}.col-primary-bg-1{background-color:var(--col-primary-bg-1)}.col-accent-bg-1{background-color:var(--col-accent-bg-1)}.col-success-bg-1{background-color:var(--col-success-bg-1)}.col-warning-bg-1{background-color:var(--col-warning-bg-1)}.col-error-bg-1{background-color:var(--col-error-bg-1)}.col-bg-2-lighter{background-color:var(--col-bg-2-lighter)}.col-bg-2{background-color:var(--col-bg-2)}.col-bg-2-darker{background-color:var(--col-bg-2-darker)}.col-bg-2-button{background-color:var(--col-bg-2-button)}.col-bg-2-input{background-color:var(--col-bg-2-input)}.col-primary-bg-2{background-color:var(--col-primary-bg-2)}.col-accent-bg-2{background-color:var(--col-accent-bg-2)}.col-success-bg-2{background-color:var(--col-success-bg-2)}.col-warning-bg-2{background-color:var(--col-warning-bg-2)}.col-error-bg-2{background-color:var(--col-error-bg-2)}.col-bg-3-lighter{background-color:var(--col-bg-3-lighter)}.col-bg-3{background-color:var(--col-bg-3)}.col-bg-3-darker{background-color:var(--col-bg-3-darker)}.col-bg-3-button{background-color:var(--col-bg-3-button)}.col-bg-3-input{background-color:var(--col-bg-3-input)}.col-primary-bg-3{background-color:var(--col-primary-bg-3)}.col-accent-bg-3{background-color:var(--col-accent-bg-3)}.col-success-bg-3{background-color:var(--col-success-bg-3)}.col-warning-bg-3{background-color:var(--col-warning-bg-3)}.col-error-bg-3{background-color:var(--col-error-bg-3)}.col-bg-ack-lighter{background-color:var(--col-bg-ack-lighter)}.col-bg-ack{background-color:var(--col-bg-ack)}.col-bg-ack-darker{background-color:var(--col-bg-ack-darker)}.col-primary-bg-ack{background-color:var(--col-primary-bg-ack)}.col-accent-bg-ack{background-color:var(--col-accent-bg-ack)}.col-bg-att-lighter{background-color:var(--col-bg-att-lighter)}.col-bg-att{background-color:var(--col-bg-att)}.col-bg-att-darker{background-color:var(--col-bg-att-darker)}.col-primary-bg-att{background-color:var(--col-primary-bg-att)}.col-accent-bg-att{background-color:var(--col-accent-bg-att)}.col-bg-alert-lighter{background-color:var(--col-bg-alert-lighter)}.col-bg-alert{background-color:var(--col-bg-alert)}.col-bg-alert-darker{background-color:var(--col-bg-alert-darker)}.col-primary-bg-alert{background-color:var(--col-primary-bg-alert)}.col-accent-bg-alert{background-color:var(--col-accent-bg-alert)}.col-bg-btn-lighter{background-color:var(--col-bg-btn-lighter)}.col-bg-btn{background-color:var(--col-bg-btn)}.col-bg-btn-darker{background-color:var(--col-bg-btn-darker)}.col-primary-bg-btn{background-color:var(--col-primary-bg-btn)}.col-accent-bg-btn{background-color:var(--col-accent-bg-btn)}.pattern-diagonal-stripes-sm,.directors-view-frame{background:repeating-linear-gradient(45deg,transparent,transparent 10px,currentColor 10px,currentColor 20px)}.pattern-dots-lg{background-image:radial-gradient(currentColor 1.5px,transparent 1.5px);background-size:15px 15px}.pattern-dots-md{background-image:radial-gradient(currentColor 1px,transparent 1px);background-size:8px 8px}.pattern-dots-medium-dense{background-image:radial-gradient(currentColor .5px,transparent .5px);background-size:3px 3px}.pattern-dots-sm{background-image:radial-gradient(currentColor .5px,transparent .5px);background-size:5px 5px}.pattern-cross-dots-md,.imagelist-background{background-image:radial-gradient(currentColor .7px,transparent 1px),radial-gradient(currentColor .7px,transparent 1px);background-size:6.5px 6.5px;background-position:0 0,3.5px 3.5px}.imagelist-background{background-color:#fff9;background-blend-mode:overlay}p,div{padding:0;margin:0;border:0px;user-select:text;-webkit-user-select:text}select{user-select:none;-webkit-user-select:none}.fa,.fas{font-family:"Font Awesome 5 Free";font-weight:900;font-style:normal}.fa-trash:before{content:""}.fa-view-grid:before{content:""}.fa-view-list:before{content:""}.fa-camera:before{content:""}.fa-view-image:before{content:""}.fa-check:before{content:""}.fa-exclamation-circle:before{content:""}.fa-list-check:before{content:""}.fa-backward:before{content:""}.fa-forward:before{content:""}.fa-backward-fast:before{content:""}.fa-forward-fast:before{content:""}:host{background-color:var(--col-bg-body);display:block;height:100%;overflow-x:hidden;overflow-y:scroll}div,p{font-family:var(--standard-text-font)}.center-div{display:flex;flex-direction:column;align-items:center}.wait-for-login{display:grid;place-items:center;height:100vh;background-color:var(--col-bg-body)}.wait-for-login p{font-family:var(--main-headline-text-font);font-size:2em}.logged-in-message{background-color:var(--col-bg-ack);color:var(--col-accent-bg-ack);display:grid;place-items:center;font-family:var(--standard-text-font)}.development{background-color:#8b0000;color:#fff;font-family:Courier New,sans-serif;font-size:18px;text-align:center}.directors-view-frame{position:absolute;background-color:#fffffffa;background-blend-mode:overlay;min-height:100%;width:100%}selection-frame{position:sticky;top:0}';
  /**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   */
  const tt = (r) => (e, t) => {
    t !== void 0 ? t.addInitializer((() => {
      customElements.define(r, e);
    })) : customElements.define(r, e);
  };
  /**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   */
  const eA = { attribute: !0, type: String, converter: ma, reflect: !1, hasChanged: Yd }, tA = (r = eA, e, t) => {
    const { kind: i, metadata: o } = t;
    let a = globalThis.litPropertyMetadata.get(o);
    if (a === void 0 && globalThis.litPropertyMetadata.set(o, a = /* @__PURE__ */ new Map()), i === "setter" && ((r = Object.create(r)).wrapped = !0), a.set(t.name, r), i === "accessor") {
      const { name: l } = t;
      return { set(d) {
        const u = e.get.call(this);
        e.set.call(this, d), this.requestUpdate(l, u, r);
      }, init(d) {
        return d !== void 0 && this.C(l, void 0, r, d), d;
      } };
    }
    if (i === "setter") {
      const { name: l } = t;
      return function(d) {
        const u = this[l];
        e.call(this, d), this.requestUpdate(l, u, r);
      };
    }
    throw Error("Unsupported decorator location: " + i);
  };
  function rA(r) {
    return (e, t) => typeof t == "object" ? tA(r, e, t) : ((i, o, a) => {
      const l = o.hasOwnProperty(a);
      return o.constructor.createProperty(a, i), l ? Object.getOwnPropertyDescriptor(o, a) : void 0;
    })(r, e, t);
  }
  /**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   */
  function Jd(r) {
    return rA({ ...r, state: !0, attribute: !1 });
  }
  const iA = ".col-bg-body-lighter{background-color:var(--col-bg-body-lighter)}.col-bg-body{background-color:var(--col-bg-body)}.col-bg-body-darker{background-color:var(--col-bg-body-darker)}.col-bg-1-lighter{background-color:var(--col-bg-1-lighter)}.col-bg-1{background-color:var(--col-bg-1)}.col-bg-1-darker{background-color:var(--col-bg-1-darker)}.col-bg-1-input{background-color:var(--col-bg-1-input)}.col-primary-bg-1{background-color:var(--col-primary-bg-1)}.col-accent-bg-1{background-color:var(--col-accent-bg-1)}.col-success-bg-1{background-color:var(--col-success-bg-1)}.col-warning-bg-1{background-color:var(--col-warning-bg-1)}.col-error-bg-1{background-color:var(--col-error-bg-1)}.col-bg-2-lighter{background-color:var(--col-bg-2-lighter)}.col-bg-2{background-color:var(--col-bg-2)}.col-bg-2-darker{background-color:var(--col-bg-2-darker)}.col-bg-2-button{background-color:var(--col-bg-2-button)}.col-bg-2-input{background-color:var(--col-bg-2-input)}.col-primary-bg-2{background-color:var(--col-primary-bg-2)}.col-accent-bg-2{background-color:var(--col-accent-bg-2)}.col-success-bg-2{background-color:var(--col-success-bg-2)}.col-warning-bg-2{background-color:var(--col-warning-bg-2)}.col-error-bg-2{background-color:var(--col-error-bg-2)}.col-bg-3-lighter{background-color:var(--col-bg-3-lighter)}.col-bg-3{background-color:var(--col-bg-3)}.col-bg-3-darker{background-color:var(--col-bg-3-darker)}.col-bg-3-button{background-color:var(--col-bg-3-button)}.col-bg-3-input{background-color:var(--col-bg-3-input)}.col-primary-bg-3{background-color:var(--col-primary-bg-3)}.col-accent-bg-3{background-color:var(--col-accent-bg-3)}.col-success-bg-3{background-color:var(--col-success-bg-3)}.col-warning-bg-3{background-color:var(--col-warning-bg-3)}.col-error-bg-3{background-color:var(--col-error-bg-3)}.col-bg-ack-lighter{background-color:var(--col-bg-ack-lighter)}.col-bg-ack{background-color:var(--col-bg-ack)}.col-bg-ack-darker{background-color:var(--col-bg-ack-darker)}.col-primary-bg-ack{background-color:var(--col-primary-bg-ack)}.col-accent-bg-ack{background-color:var(--col-accent-bg-ack)}.col-bg-att-lighter{background-color:var(--col-bg-att-lighter)}.col-bg-att{background-color:var(--col-bg-att)}.col-bg-att-darker{background-color:var(--col-bg-att-darker)}.col-primary-bg-att{background-color:var(--col-primary-bg-att)}.col-accent-bg-att{background-color:var(--col-accent-bg-att)}.col-bg-alert-lighter{background-color:var(--col-bg-alert-lighter)}.col-bg-alert{background-color:var(--col-bg-alert)}.col-bg-alert-darker{background-color:var(--col-bg-alert-darker)}.col-primary-bg-alert{background-color:var(--col-primary-bg-alert)}.col-accent-bg-alert{background-color:var(--col-accent-bg-alert)}.col-bg-btn-lighter{background-color:var(--col-bg-btn-lighter)}.col-bg-btn{background-color:var(--col-bg-btn)}.col-bg-btn-darker{background-color:var(--col-bg-btn-darker)}.col-primary-bg-btn{background-color:var(--col-primary-bg-btn)}.col-accent-bg-btn{background-color:var(--col-accent-bg-btn)}.pattern-diagonal-stripes-sm{background:repeating-linear-gradient(45deg,transparent,transparent 10px,currentColor 10px,currentColor 20px)}.pattern-dots-lg{background-image:radial-gradient(currentColor 1.5px,transparent 1.5px);background-size:15px 15px}.pattern-dots-md{background-image:radial-gradient(currentColor 1px,transparent 1px);background-size:8px 8px}.pattern-dots-medium-dense{background-image:radial-gradient(currentColor .5px,transparent .5px);background-size:3px 3px}.pattern-dots-sm{background-image:radial-gradient(currentColor .5px,transparent .5px);background-size:5px 5px}.pattern-cross-dots-md,.imagelist-background{background-image:radial-gradient(currentColor .7px,transparent 1px),radial-gradient(currentColor .7px,transparent 1px);background-size:6.5px 6.5px;background-position:0 0,3.5px 3.5px}.imagelist-background{background-color:#fff9;background-blend-mode:overlay}p,div{padding:0;margin:0;border:0px;user-select:text;-webkit-user-select:text}select{user-select:none;-webkit-user-select:none}div,p{font-family:var(--standard-text-font)}:host{display:block;position:sticky;top:0;z-index:2}";
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  class oA extends HTMLElement {
    static get version() {
      return "23.6.1";
    }
  }
  customElements.define("vaadin-lumo-styles", oA);
  /**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   */
  const aa = window, Xd = aa.ShadowRoot && (aa.ShadyCSS === void 0 || aa.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, Qd = Symbol(), Op = /* @__PURE__ */ new WeakMap();
  let eu = class {
    constructor(e, t, i) {
      if (this._$cssResult$ = !0, i !== Qd) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
      this.cssText = e, this.t = t;
    }
    get styleSheet() {
      let e = this.o;
      const t = this.t;
      if (Xd && e === void 0) {
        const i = t !== void 0 && t.length === 1;
        i && (e = Op.get(t)), e === void 0 && ((this.o = e = new CSSStyleSheet()).replaceSync(this.cssText), i && Op.set(t, e));
      }
      return e;
    }
    toString() {
      return this.cssText;
    }
  };
  const nA = (r) => new eu(typeof r == "string" ? r : r + "", void 0, Qd), me = (r, ...e) => {
    const t = r.length === 1 ? r[0] : e.reduce(((i, o, a) => i + ((l) => {
      if (l._$cssResult$ === !0) return l.cssText;
      if (typeof l == "number") return l;
      throw Error("Value passed to 'css' function must be a 'css' function result: " + l + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
    })(o) + r[a + 1]), r[0]);
    return new eu(t, r, Qd);
  }, sA = (r, e) => {
    Xd ? r.adoptedStyleSheets = e.map(((t) => t instanceof CSSStyleSheet ? t : t.styleSheet)) : e.forEach(((t) => {
      const i = document.createElement("style"), o = aa.litNonce;
      o !== void 0 && i.setAttribute("nonce", o), i.textContent = t.cssText, r.appendChild(i);
    }));
  }, Dp = Xd ? (r) => r : (r) => r instanceof CSSStyleSheet ? ((e) => {
    let t = "";
    for (const i of e.cssRules) t += i.cssText;
    return nA(t);
  })(r) : r;
  /**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   */
  var wc;
  const va = window, Pp = va.trustedTypes, aA = Pp ? Pp.emptyScript : "", Ip = va.reactiveElementPolyfillSupport, id = { toAttribute(r, e) {
    switch (e) {
      case Boolean:
        r = r ? aA : null;
        break;
      case Object:
      case Array:
        r = r == null ? r : JSON.stringify(r);
    }
    return r;
  }, fromAttribute(r, e) {
    let t = r;
    switch (e) {
      case Boolean:
        t = r !== null;
        break;
      case Number:
        t = r === null ? null : Number(r);
        break;
      case Object:
      case Array:
        try {
          t = JSON.parse(r);
        } catch {
          t = null;
        }
    }
    return t;
  } }, Hm = (r, e) => e !== r && (e == e || r == r), kc = { attribute: !0, type: String, converter: id, reflect: !1, hasChanged: Hm }, od = "finalized";
  let ro = class extends HTMLElement {
    constructor() {
      super(), this._$Ei = /* @__PURE__ */ new Map(), this.isUpdatePending = !1, this.hasUpdated = !1, this._$El = null, this._$Eu();
    }
    static addInitializer(e) {
      var t;
      this.finalize(), ((t = this.h) !== null && t !== void 0 ? t : this.h = []).push(e);
    }
    static get observedAttributes() {
      this.finalize();
      const e = [];
      return this.elementProperties.forEach(((t, i) => {
        const o = this._$Ep(i, t);
        o !== void 0 && (this._$Ev.set(o, i), e.push(o));
      })), e;
    }
    static createProperty(e, t = kc) {
      if (t.state && (t.attribute = !1), this.finalize(), this.elementProperties.set(e, t), !t.noAccessor && !this.prototype.hasOwnProperty(e)) {
        const i = typeof e == "symbol" ? Symbol() : "__" + e, o = this.getPropertyDescriptor(e, i, t);
        o !== void 0 && Object.defineProperty(this.prototype, e, o);
      }
    }
    static getPropertyDescriptor(e, t, i) {
      return { get() {
        return this[t];
      }, set(o) {
        const a = this[e];
        this[t] = o, this.requestUpdate(e, a, i);
      }, configurable: !0, enumerable: !0 };
    }
    static getPropertyOptions(e) {
      return this.elementProperties.get(e) || kc;
    }
    static finalize() {
      if (this.hasOwnProperty(od)) return !1;
      this[od] = !0;
      const e = Object.getPrototypeOf(this);
      if (e.finalize(), e.h !== void 0 && (this.h = [...e.h]), this.elementProperties = new Map(e.elementProperties), this._$Ev = /* @__PURE__ */ new Map(), this.hasOwnProperty("properties")) {
        const t = this.properties, i = [...Object.getOwnPropertyNames(t), ...Object.getOwnPropertySymbols(t)];
        for (const o of i) this.createProperty(o, t[o]);
      }
      return this.elementStyles = this.finalizeStyles(this.styles), !0;
    }
    static finalizeStyles(e) {
      const t = [];
      if (Array.isArray(e)) {
        const i = new Set(e.flat(1 / 0).reverse());
        for (const o of i) t.unshift(Dp(o));
      } else e !== void 0 && t.push(Dp(e));
      return t;
    }
    static _$Ep(e, t) {
      const i = t.attribute;
      return i === !1 ? void 0 : typeof i == "string" ? i : typeof e == "string" ? e.toLowerCase() : void 0;
    }
    _$Eu() {
      var e;
      this._$E_ = new Promise(((t) => this.enableUpdating = t)), this._$AL = /* @__PURE__ */ new Map(), this._$Eg(), this.requestUpdate(), (e = this.constructor.h) === null || e === void 0 || e.forEach(((t) => t(this)));
    }
    addController(e) {
      var t, i;
      ((t = this._$ES) !== null && t !== void 0 ? t : this._$ES = []).push(e), this.renderRoot !== void 0 && this.isConnected && ((i = e.hostConnected) === null || i === void 0 || i.call(e));
    }
    removeController(e) {
      var t;
      (t = this._$ES) === null || t === void 0 || t.splice(this._$ES.indexOf(e) >>> 0, 1);
    }
    _$Eg() {
      this.constructor.elementProperties.forEach(((e, t) => {
        this.hasOwnProperty(t) && (this._$Ei.set(t, this[t]), delete this[t]);
      }));
    }
    createRenderRoot() {
      var e;
      const t = (e = this.shadowRoot) !== null && e !== void 0 ? e : this.attachShadow(this.constructor.shadowRootOptions);
      return sA(t, this.constructor.elementStyles), t;
    }
    connectedCallback() {
      var e;
      this.renderRoot === void 0 && (this.renderRoot = this.createRenderRoot()), this.enableUpdating(!0), (e = this._$ES) === null || e === void 0 || e.forEach(((t) => {
        var i;
        return (i = t.hostConnected) === null || i === void 0 ? void 0 : i.call(t);
      }));
    }
    enableUpdating(e) {
    }
    disconnectedCallback() {
      var e;
      (e = this._$ES) === null || e === void 0 || e.forEach(((t) => {
        var i;
        return (i = t.hostDisconnected) === null || i === void 0 ? void 0 : i.call(t);
      }));
    }
    attributeChangedCallback(e, t, i) {
      this._$AK(e, i);
    }
    _$EO(e, t, i = kc) {
      var o;
      const a = this.constructor._$Ep(e, i);
      if (a !== void 0 && i.reflect === !0) {
        const l = (((o = i.converter) === null || o === void 0 ? void 0 : o.toAttribute) !== void 0 ? i.converter : id).toAttribute(t, i.type);
        this._$El = e, l == null ? this.removeAttribute(a) : this.setAttribute(a, l), this._$El = null;
      }
    }
    _$AK(e, t) {
      var i;
      const o = this.constructor, a = o._$Ev.get(e);
      if (a !== void 0 && this._$El !== a) {
        const l = o.getPropertyOptions(a), d = typeof l.converter == "function" ? { fromAttribute: l.converter } : ((i = l.converter) === null || i === void 0 ? void 0 : i.fromAttribute) !== void 0 ? l.converter : id;
        this._$El = a, this[a] = d.fromAttribute(t, l.type), this._$El = null;
      }
    }
    requestUpdate(e, t, i) {
      let o = !0;
      e !== void 0 && (((i = i || this.constructor.getPropertyOptions(e)).hasChanged || Hm)(this[e], t) ? (this._$AL.has(e) || this._$AL.set(e, t), i.reflect === !0 && this._$El !== e && (this._$EC === void 0 && (this._$EC = /* @__PURE__ */ new Map()), this._$EC.set(e, i))) : o = !1), !this.isUpdatePending && o && (this._$E_ = this._$Ej());
    }
    async _$Ej() {
      this.isUpdatePending = !0;
      try {
        await this._$E_;
      } catch (t) {
        Promise.reject(t);
      }
      const e = this.scheduleUpdate();
      return e != null && await e, !this.isUpdatePending;
    }
    scheduleUpdate() {
      return this.performUpdate();
    }
    performUpdate() {
      var e;
      if (!this.isUpdatePending) return;
      this.hasUpdated, this._$Ei && (this._$Ei.forEach(((o, a) => this[a] = o)), this._$Ei = void 0);
      let t = !1;
      const i = this._$AL;
      try {
        t = this.shouldUpdate(i), t ? (this.willUpdate(i), (e = this._$ES) === null || e === void 0 || e.forEach(((o) => {
          var a;
          return (a = o.hostUpdate) === null || a === void 0 ? void 0 : a.call(o);
        })), this.update(i)) : this._$Ek();
      } catch (o) {
        throw t = !1, this._$Ek(), o;
      }
      t && this._$AE(i);
    }
    willUpdate(e) {
    }
    _$AE(e) {
      var t;
      (t = this._$ES) === null || t === void 0 || t.forEach(((i) => {
        var o;
        return (o = i.hostUpdated) === null || o === void 0 ? void 0 : o.call(i);
      })), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(e)), this.updated(e);
    }
    _$Ek() {
      this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = !1;
    }
    get updateComplete() {
      return this.getUpdateComplete();
    }
    getUpdateComplete() {
      return this._$E_;
    }
    shouldUpdate(e) {
      return !0;
    }
    update(e) {
      this._$EC !== void 0 && (this._$EC.forEach(((t, i) => this._$EO(i, this[i], t))), this._$EC = void 0), this._$Ek();
    }
    updated(e) {
    }
    firstUpdated(e) {
    }
  };
  ro[od] = !0, ro.elementProperties = /* @__PURE__ */ new Map(), ro.elementStyles = [], ro.shadowRootOptions = { mode: "open" }, Ip?.({ ReactiveElement: ro }), ((wc = va.reactiveElementVersions) !== null && wc !== void 0 ? wc : va.reactiveElementVersions = []).push("1.6.3");
  /**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   */
  var xc;
  const ya = window, $o = ya.trustedTypes, Mp = $o ? $o.createPolicy("lit-html", { createHTML: (r) => r }) : void 0, nd = "$lit$", Vr = `lit$${(Math.random() + "").slice(9)}$`, Um = "?" + Vr, lA = `<${Um}>`, Ai = document, In = () => Ai.createComment(""), Mn = (r) => r === null || typeof r != "object" && typeof r != "function", Wm = Array.isArray, cA = (r) => Wm(r) || typeof r?.[Symbol.iterator] == "function", Cc = `[ 	
\f\r]`, dn = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, Np = /-->/g, Lp = />/g, hi = RegExp(`>|${Cc}(?:([^\\s"'>=/]+)(${Cc}*=${Cc}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), Rp = /'/g, Fp = /"/g, Bm = /^(?:script|style|textarea|title)$/i, To = Symbol.for("lit-noChange"), Ne = Symbol.for("lit-nothing"), zp = /* @__PURE__ */ new WeakMap(), bi = Ai.createTreeWalker(Ai, 129, null, !1);
  function Vm(r, e) {
    if (!Array.isArray(r) || !r.hasOwnProperty("raw")) throw Error("invalid template strings array");
    return Mp !== void 0 ? Mp.createHTML(e) : e;
  }
  const dA = (r, e) => {
    const t = r.length - 1, i = [];
    let o, a = e === 2 ? "<svg>" : "", l = dn;
    for (let d = 0; d < t; d++) {
      const u = r[d];
      let f, g, _ = -1, C = 0;
      for (; C < u.length && (l.lastIndex = C, g = l.exec(u), g !== null); ) C = l.lastIndex, l === dn ? g[1] === "!--" ? l = Np : g[1] !== void 0 ? l = Lp : g[2] !== void 0 ? (Bm.test(g[2]) && (o = RegExp("</" + g[2], "g")), l = hi) : g[3] !== void 0 && (l = hi) : l === hi ? g[0] === ">" ? (l = o ?? dn, _ = -1) : g[1] === void 0 ? _ = -2 : (_ = l.lastIndex - g[2].length, f = g[1], l = g[3] === void 0 ? hi : g[3] === '"' ? Fp : Rp) : l === Fp || l === Rp ? l = hi : l === Np || l === Lp ? l = dn : (l = hi, o = void 0);
      const x = l === hi && r[d + 1].startsWith("/>") ? " " : "";
      a += l === dn ? u + lA : _ >= 0 ? (i.push(f), u.slice(0, _) + nd + u.slice(_) + Vr + x) : u + Vr + (_ === -2 ? (i.push(void 0), d) : x);
    }
    return [Vm(r, a + (r[t] || "<?>") + (e === 2 ? "</svg>" : "")), i];
  };
  let sd = class qm {
    constructor({ strings: e, _$litType$: t }, i) {
      let o;
      this.parts = [];
      let a = 0, l = 0;
      const d = e.length - 1, u = this.parts, [f, g] = dA(e, t);
      if (this.el = qm.createElement(f, i), bi.currentNode = this.el.content, t === 2) {
        const _ = this.el.content, C = _.firstChild;
        C.remove(), _.append(...C.childNodes);
      }
      for (; (o = bi.nextNode()) !== null && u.length < d; ) {
        if (o.nodeType === 1) {
          if (o.hasAttributes()) {
            const _ = [];
            for (const C of o.getAttributeNames()) if (C.endsWith(nd) || C.startsWith(Vr)) {
              const x = g[l++];
              if (_.push(C), x !== void 0) {
                const D = o.getAttribute(x.toLowerCase() + nd).split(Vr), P = /([.?@])?(.*)/.exec(x);
                u.push({ type: 1, index: a, name: P[2], strings: D, ctor: P[1] === "." ? hA : P[1] === "?" ? pA : P[1] === "@" ? gA : Ra });
              } else u.push({ type: 6, index: a });
            }
            for (const C of _) o.removeAttribute(C);
          }
          if (Bm.test(o.tagName)) {
            const _ = o.textContent.split(Vr), C = _.length - 1;
            if (C > 0) {
              o.textContent = $o ? $o.emptyScript : "";
              for (let x = 0; x < C; x++) o.append(_[x], In()), bi.nextNode(), u.push({ type: 2, index: ++a });
              o.append(_[C], In());
            }
          }
        } else if (o.nodeType === 8) if (o.data === Um) u.push({ type: 2, index: a });
        else {
          let _ = -1;
          for (; (_ = o.data.indexOf(Vr, _ + 1)) !== -1; ) u.push({ type: 7, index: a }), _ += Vr.length - 1;
        }
        a++;
      }
    }
    static createElement(e, t) {
      const i = Ai.createElement("template");
      return i.innerHTML = e, i;
    }
  };
  function Oo(r, e, t = r, i) {
    var o, a, l, d;
    if (e === To) return e;
    let u = i !== void 0 ? (o = t._$Co) === null || o === void 0 ? void 0 : o[i] : t._$Cl;
    const f = Mn(e) ? void 0 : e._$litDirective$;
    return u?.constructor !== f && ((a = u?._$AO) === null || a === void 0 || a.call(u, !1), f === void 0 ? u = void 0 : (u = new f(r), u._$AT(r, t, i)), i !== void 0 ? ((l = (d = t)._$Co) !== null && l !== void 0 ? l : d._$Co = [])[i] = u : t._$Cl = u), u !== void 0 && (e = Oo(r, u._$AS(r, e.values), u, i)), e;
  }
  let uA = class {
    constructor(e, t) {
      this._$AV = [], this._$AN = void 0, this._$AD = e, this._$AM = t;
    }
    get parentNode() {
      return this._$AM.parentNode;
    }
    get _$AU() {
      return this._$AM._$AU;
    }
    u(e) {
      var t;
      const { el: { content: i }, parts: o } = this._$AD, a = ((t = e?.creationScope) !== null && t !== void 0 ? t : Ai).importNode(i, !0);
      bi.currentNode = a;
      let l = bi.nextNode(), d = 0, u = 0, f = o[0];
      for (; f !== void 0; ) {
        if (d === f.index) {
          let g;
          f.type === 2 ? g = new tu(l, l.nextSibling, this, e) : f.type === 1 ? g = new f.ctor(l, f.name, f.strings, this, e) : f.type === 6 && (g = new mA(l, this, e)), this._$AV.push(g), f = o[++u];
        }
        d !== f?.index && (l = bi.nextNode(), d++);
      }
      return bi.currentNode = Ai, a;
    }
    v(e) {
      let t = 0;
      for (const i of this._$AV) i !== void 0 && (i.strings !== void 0 ? (i._$AI(e, i, t), t += i.strings.length - 2) : i._$AI(e[t])), t++;
    }
  }, tu = class Ym {
    constructor(e, t, i, o) {
      var a;
      this.type = 2, this._$AH = Ne, this._$AN = void 0, this._$AA = e, this._$AB = t, this._$AM = i, this.options = o, this._$Cp = (a = o?.isConnected) === null || a === void 0 || a;
    }
    get _$AU() {
      var e, t;
      return (t = (e = this._$AM) === null || e === void 0 ? void 0 : e._$AU) !== null && t !== void 0 ? t : this._$Cp;
    }
    get parentNode() {
      let e = this._$AA.parentNode;
      const t = this._$AM;
      return t !== void 0 && e?.nodeType === 11 && (e = t.parentNode), e;
    }
    get startNode() {
      return this._$AA;
    }
    get endNode() {
      return this._$AB;
    }
    _$AI(e, t = this) {
      e = Oo(this, e, t), Mn(e) ? e === Ne || e == null || e === "" ? (this._$AH !== Ne && this._$AR(), this._$AH = Ne) : e !== this._$AH && e !== To && this._(e) : e._$litType$ !== void 0 ? this.g(e) : e.nodeType !== void 0 ? this.$(e) : cA(e) ? this.T(e) : this._(e);
    }
    k(e) {
      return this._$AA.parentNode.insertBefore(e, this._$AB);
    }
    $(e) {
      this._$AH !== e && (this._$AR(), this._$AH = this.k(e));
    }
    _(e) {
      this._$AH !== Ne && Mn(this._$AH) ? this._$AA.nextSibling.data = e : this.$(Ai.createTextNode(e)), this._$AH = e;
    }
    g(e) {
      var t;
      const { values: i, _$litType$: o } = e, a = typeof o == "number" ? this._$AC(e) : (o.el === void 0 && (o.el = sd.createElement(Vm(o.h, o.h[0]), this.options)), o);
      if (((t = this._$AH) === null || t === void 0 ? void 0 : t._$AD) === a) this._$AH.v(i);
      else {
        const l = new uA(a, this), d = l.u(this.options);
        l.v(i), this.$(d), this._$AH = l;
      }
    }
    _$AC(e) {
      let t = zp.get(e.strings);
      return t === void 0 && zp.set(e.strings, t = new sd(e)), t;
    }
    T(e) {
      Wm(this._$AH) || (this._$AH = [], this._$AR());
      const t = this._$AH;
      let i, o = 0;
      for (const a of e) o === t.length ? t.push(i = new Ym(this.k(In()), this.k(In()), this, this.options)) : i = t[o], i._$AI(a), o++;
      o < t.length && (this._$AR(i && i._$AB.nextSibling, o), t.length = o);
    }
    _$AR(e = this._$AA.nextSibling, t) {
      var i;
      for ((i = this._$AP) === null || i === void 0 || i.call(this, !1, !0, t); e && e !== this._$AB; ) {
        const o = e.nextSibling;
        e.remove(), e = o;
      }
    }
    setConnected(e) {
      var t;
      this._$AM === void 0 && (this._$Cp = e, (t = this._$AP) === null || t === void 0 || t.call(this, e));
    }
  }, Ra = class {
    constructor(e, t, i, o, a) {
      this.type = 1, this._$AH = Ne, this._$AN = void 0, this.element = e, this.name = t, this._$AM = o, this.options = a, i.length > 2 || i[0] !== "" || i[1] !== "" ? (this._$AH = Array(i.length - 1).fill(new String()), this.strings = i) : this._$AH = Ne;
    }
    get tagName() {
      return this.element.tagName;
    }
    get _$AU() {
      return this._$AM._$AU;
    }
    _$AI(e, t = this, i, o) {
      const a = this.strings;
      let l = !1;
      if (a === void 0) e = Oo(this, e, t, 0), l = !Mn(e) || e !== this._$AH && e !== To, l && (this._$AH = e);
      else {
        const d = e;
        let u, f;
        for (e = a[0], u = 0; u < a.length - 1; u++) f = Oo(this, d[i + u], t, u), f === To && (f = this._$AH[u]), l || (l = !Mn(f) || f !== this._$AH[u]), f === Ne ? e = Ne : e !== Ne && (e += (f ?? "") + a[u + 1]), this._$AH[u] = f;
      }
      l && !o && this.j(e);
    }
    j(e) {
      e === Ne ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, e ?? "");
    }
  }, hA = class extends Ra {
    constructor() {
      super(...arguments), this.type = 3;
    }
    j(e) {
      this.element[this.name] = e === Ne ? void 0 : e;
    }
  };
  const fA = $o ? $o.emptyScript : "";
  let pA = class extends Ra {
    constructor() {
      super(...arguments), this.type = 4;
    }
    j(e) {
      e && e !== Ne ? this.element.setAttribute(this.name, fA) : this.element.removeAttribute(this.name);
    }
  }, gA = class extends Ra {
    constructor(e, t, i, o, a) {
      super(e, t, i, o, a), this.type = 5;
    }
    _$AI(e, t = this) {
      var i;
      if ((e = (i = Oo(this, e, t, 0)) !== null && i !== void 0 ? i : Ne) === To) return;
      const o = this._$AH, a = e === Ne && o !== Ne || e.capture !== o.capture || e.once !== o.once || e.passive !== o.passive, l = e !== Ne && (o === Ne || a);
      a && this.element.removeEventListener(this.name, this, o), l && this.element.addEventListener(this.name, this, e), this._$AH = e;
    }
    handleEvent(e) {
      var t, i;
      typeof this._$AH == "function" ? this._$AH.call((i = (t = this.options) === null || t === void 0 ? void 0 : t.host) !== null && i !== void 0 ? i : this.element, e) : this._$AH.handleEvent(e);
    }
  }, mA = class {
    constructor(e, t, i) {
      this.element = e, this.type = 6, this._$AN = void 0, this._$AM = t, this.options = i;
    }
    get _$AU() {
      return this._$AM._$AU;
    }
    _$AI(e) {
      Oo(this, e);
    }
  };
  const Hp = ya.litHtmlPolyfillSupport;
  Hp?.(sd, tu), ((xc = ya.litHtmlVersions) !== null && xc !== void 0 ? xc : ya.litHtmlVersions = []).push("2.8.0");
  const bA = (r, e, t) => {
    var i, o;
    const a = (i = t?.renderBefore) !== null && i !== void 0 ? i : e;
    let l = a._$litPart$;
    if (l === void 0) {
      const d = (o = t?.renderBefore) !== null && o !== void 0 ? o : null;
      a._$litPart$ = l = new tu(e.insertBefore(In(), d), d, void 0, t ?? {});
    }
    return l._$AI(r), l;
  };
  /**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   */
  var Sc, Ac;
  let la = class extends ro {
    constructor() {
      super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
    }
    createRenderRoot() {
      var e, t;
      const i = super.createRenderRoot();
      return (e = (t = this.renderOptions).renderBefore) !== null && e !== void 0 || (t.renderBefore = i.firstChild), i;
    }
    update(e) {
      const t = this.render();
      this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(e), this._$Do = bA(t, this.renderRoot, this.renderOptions);
    }
    connectedCallback() {
      var e;
      super.connectedCallback(), (e = this._$Do) === null || e === void 0 || e.setConnected(!0);
    }
    disconnectedCallback() {
      var e;
      super.disconnectedCallback(), (e = this._$Do) === null || e === void 0 || e.setConnected(!1);
    }
    render() {
      return To;
    }
  };
  la.finalized = !0, la._$litElement$ = !0, (Sc = globalThis.litElementHydrateSupport) === null || Sc === void 0 || Sc.call(globalThis, { LitElement: la });
  const Up = globalThis.litElementPolyfillSupport;
  Up?.({ LitElement: la });
  ((Ac = globalThis.litElementVersions) !== null && Ac !== void 0 ? Ac : globalThis.litElementVersions = []).push("3.3.3");
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  const _A = (r) => class extends r {
    static get properties() {
      return {
        /**
         * Helper property with theme attribute value facilitating propagation
         * in shadow DOM.
         *
         * Enables the component implementation to propagate the `theme`
         * attribute value to the sub-components in Shadow DOM by binding
         * the sub-component’s "theme" attribute to the `theme` property of
         * the host.
         *
         * **NOTE:** Extending the mixin only provides the property for binding,
         * and does not make the propagation alone.
         *
         * See [Styling Components: Sub-components](https://vaadin.com/docs/latest/styling/custom-theme/styling-components/#sub-components).
         * page for more information.
         *
         * @deprecated The `theme` property is not supposed for public use and will be dropped in Vaadin 24.
         * Please, use the `theme` attribute instead.
         * @protected
         */
        theme: {
          type: String,
          reflectToAttribute: !0,
          observer: "__deprecatedThemePropertyChanged"
        },
        /**
         * Helper property with theme attribute value facilitating propagation
         * in shadow DOM.
         *
         * Enables the component implementation to propagate the `theme`
         * attribute value to the sub-components in Shadow DOM by binding
         * the sub-component’s "theme" attribute to the `theme` property of
         * the host.
         *
         * **NOTE:** Extending the mixin only provides the property for binding,
         * and does not make the propagation alone.
         *
         * See [Styling Components: Sub-components](https://vaadin.com/docs/latest/styling/custom-theme/styling-components/#sub-components).
         * page for more information.
         *
         * @protected
         */
        _theme: {
          type: String,
          readOnly: !0
        }
      };
    }
    /** @private */
    __deprecatedThemePropertyChanged(t) {
      this._set_theme(t);
    }
  };
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  const Gm = [];
  function Te(r, e, t = {}) {
    r && CA(r), e = wA(e), window.Vaadin && window.Vaadin.styleModules ? window.Vaadin.styleModules.registerStyles(r, e, t) : Gm.push({
      themeFor: r,
      styles: e,
      include: t.include,
      moduleId: t.moduleId
    });
  }
  function ad() {
    return window.Vaadin && window.Vaadin.styleModules ? window.Vaadin.styleModules.getAllThemes() : Gm;
  }
  function vA(r, e) {
    return (r || "").split(" ").some((t) => new RegExp(`^${t.split("*").join(".*")}$`).test(e));
  }
  function yA(r = "") {
    let e = 0;
    return r.startsWith("lumo-") || r.startsWith("material-") ? e = 1 : r.startsWith("vaadin-") && (e = 2), e;
  }
  function wA(r = []) {
    return [r].flat(1 / 0).filter((e) => e instanceof eu);
  }
  function jm(r) {
    const e = [];
    return r.include && [].concat(r.include).forEach((t) => {
      const i = ad().find((o) => o.moduleId === t);
      i && e.push(...jm(i), ...i.styles);
    }, r.styles), e;
  }
  function kA(r, e) {
    const t = document.createElement("style");
    t.innerHTML = r.map((i) => i.cssText).join(`
`), e.content.appendChild(t);
  }
  function xA(r) {
    const e = `${r}-default-theme`, t = ad().filter((i) => i.moduleId !== e && vA(i.themeFor, r)).map((i) => ({
      ...i,
      // Prepend styles from included themes
      styles: [...jm(i), ...i.styles],
      // Map moduleId to includePriority
      includePriority: yA(i.moduleId)
    })).sort((i, o) => o.includePriority - i.includePriority);
    return t.length > 0 ? t : ad().filter((i) => i.moduleId === e);
  }
  function CA(r) {
    return Zm(customElements.get(r));
  }
  function Zm(r) {
    return r && Object.prototype.hasOwnProperty.call(r, "__themes");
  }
  const Kr = (r) => class extends _A(r) {
    /**
     * Covers PolymerElement based component styling
     * @protected
     */
    static finalize() {
      if (super.finalize(), this.elementStyles)
        return;
      const t = this.prototype._template;
      !t || Zm(this) || kA(this.getStylesForThis(), t);
    }
    /**
     * Covers LitElement based component styling
     *
     * @protected
     */
    static finalizeStyles(t) {
      const i = this.getStylesForThis();
      return t ? [...super.finalizeStyles(t), ...i] : i;
    }
    /**
     * Get styles for the component type
     *
     * @private
     */
    static getStylesForThis() {
      const t = Object.getPrototypeOf(this.prototype), i = (t ? t.constructor.__themes : []) || [];
      this.__themes = [...i, ...xA(this.is)];
      const o = this.__themes.flatMap((a) => a.styles);
      return o.filter((a, l) => l === o.lastIndexOf(a));
    }
  };
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  const SA = me`
  :host {
    /* Base (background) */
    --lumo-base-color: #fff;

    /* Tint */
    --lumo-tint-5pct: hsla(0, 0%, 100%, 0.3);
    --lumo-tint-10pct: hsla(0, 0%, 100%, 0.37);
    --lumo-tint-20pct: hsla(0, 0%, 100%, 0.44);
    --lumo-tint-30pct: hsla(0, 0%, 100%, 0.5);
    --lumo-tint-40pct: hsla(0, 0%, 100%, 0.57);
    --lumo-tint-50pct: hsla(0, 0%, 100%, 0.64);
    --lumo-tint-60pct: hsla(0, 0%, 100%, 0.7);
    --lumo-tint-70pct: hsla(0, 0%, 100%, 0.77);
    --lumo-tint-80pct: hsla(0, 0%, 100%, 0.84);
    --lumo-tint-90pct: hsla(0, 0%, 100%, 0.9);
    --lumo-tint: #fff;

    /* Shade */
    --lumo-shade-5pct: hsla(214, 61%, 25%, 0.05);
    --lumo-shade-10pct: hsla(214, 57%, 24%, 0.1);
    --lumo-shade-20pct: hsla(214, 53%, 23%, 0.16);
    --lumo-shade-30pct: hsla(214, 50%, 22%, 0.26);
    --lumo-shade-40pct: hsla(214, 47%, 21%, 0.38);
    --lumo-shade-50pct: hsla(214, 45%, 20%, 0.52);
    --lumo-shade-60pct: hsla(214, 43%, 19%, 0.6);
    --lumo-shade-70pct: hsla(214, 42%, 18%, 0.69);
    --lumo-shade-80pct: hsla(214, 41%, 17%, 0.83);
    --lumo-shade-90pct: hsla(214, 40%, 16%, 0.94);
    --lumo-shade: hsl(214, 35%, 15%);

    /* Contrast */
    --lumo-contrast-5pct: var(--lumo-shade-5pct);
    --lumo-contrast-10pct: var(--lumo-shade-10pct);
    --lumo-contrast-20pct: var(--lumo-shade-20pct);
    --lumo-contrast-30pct: var(--lumo-shade-30pct);
    --lumo-contrast-40pct: var(--lumo-shade-40pct);
    --lumo-contrast-50pct: var(--lumo-shade-50pct);
    --lumo-contrast-60pct: var(--lumo-shade-60pct);
    --lumo-contrast-70pct: var(--lumo-shade-70pct);
    --lumo-contrast-80pct: var(--lumo-shade-80pct);
    --lumo-contrast-90pct: var(--lumo-shade-90pct);
    --lumo-contrast: var(--lumo-shade);

    /* Text */
    --lumo-header-text-color: var(--lumo-contrast);
    --lumo-body-text-color: var(--lumo-contrast-90pct);
    --lumo-secondary-text-color: var(--lumo-contrast-70pct);
    --lumo-tertiary-text-color: var(--lumo-contrast-50pct);
    --lumo-disabled-text-color: var(--lumo-contrast-30pct);

    /* Primary */
    --lumo-primary-color: hsl(214, 100%, 48%);
    --lumo-primary-color-50pct: hsla(214, 100%, 49%, 0.76);
    --lumo-primary-color-10pct: hsla(214, 100%, 60%, 0.13);
    --lumo-primary-text-color: hsl(214, 100%, 43%);
    --lumo-primary-contrast-color: #fff;

    /* Error */
    --lumo-error-color: hsl(3, 85%, 48%);
    --lumo-error-color-50pct: hsla(3, 85%, 49%, 0.5);
    --lumo-error-color-10pct: hsla(3, 85%, 49%, 0.1);
    --lumo-error-text-color: hsl(3, 89%, 42%);
    --lumo-error-contrast-color: #fff;

    /* Success */
    --lumo-success-color: hsl(145, 72%, 30%);
    --lumo-success-color-50pct: hsla(145, 72%, 31%, 0.5);
    --lumo-success-color-10pct: hsla(145, 72%, 31%, 0.1);
    --lumo-success-text-color: hsl(145, 85%, 25%);
    --lumo-success-contrast-color: #fff;
  }
`, Km = document.createElement("template");
  Km.innerHTML = `<style>${SA.toString().replace(":host", "html")}</style>`;
  document.head.appendChild(Km.content);
  const Jm = me`
  [theme~='dark'] {
    /* Base (background) */
    --lumo-base-color: hsl(214, 35%, 21%);

    /* Tint */
    --lumo-tint-5pct: hsla(214, 65%, 85%, 0.06);
    --lumo-tint-10pct: hsla(214, 60%, 80%, 0.14);
    --lumo-tint-20pct: hsla(214, 64%, 82%, 0.23);
    --lumo-tint-30pct: hsla(214, 69%, 84%, 0.32);
    --lumo-tint-40pct: hsla(214, 73%, 86%, 0.41);
    --lumo-tint-50pct: hsla(214, 78%, 88%, 0.5);
    --lumo-tint-60pct: hsla(214, 82%, 90%, 0.58);
    --lumo-tint-70pct: hsla(214, 87%, 92%, 0.69);
    --lumo-tint-80pct: hsla(214, 91%, 94%, 0.8);
    --lumo-tint-90pct: hsla(214, 96%, 96%, 0.9);
    --lumo-tint: hsl(214, 100%, 98%);

    /* Shade */
    --lumo-shade-5pct: hsla(214, 0%, 0%, 0.07);
    --lumo-shade-10pct: hsla(214, 4%, 2%, 0.15);
    --lumo-shade-20pct: hsla(214, 8%, 4%, 0.23);
    --lumo-shade-30pct: hsla(214, 12%, 6%, 0.32);
    --lumo-shade-40pct: hsla(214, 16%, 8%, 0.41);
    --lumo-shade-50pct: hsla(214, 20%, 10%, 0.5);
    --lumo-shade-60pct: hsla(214, 24%, 12%, 0.6);
    --lumo-shade-70pct: hsla(214, 28%, 13%, 0.7);
    --lumo-shade-80pct: hsla(214, 32%, 13%, 0.8);
    --lumo-shade-90pct: hsla(214, 33%, 13%, 0.9);
    --lumo-shade: hsl(214, 33%, 13%);

    /* Contrast */
    --lumo-contrast-5pct: var(--lumo-tint-5pct);
    --lumo-contrast-10pct: var(--lumo-tint-10pct);
    --lumo-contrast-20pct: var(--lumo-tint-20pct);
    --lumo-contrast-30pct: var(--lumo-tint-30pct);
    --lumo-contrast-40pct: var(--lumo-tint-40pct);
    --lumo-contrast-50pct: var(--lumo-tint-50pct);
    --lumo-contrast-60pct: var(--lumo-tint-60pct);
    --lumo-contrast-70pct: var(--lumo-tint-70pct);
    --lumo-contrast-80pct: var(--lumo-tint-80pct);
    --lumo-contrast-90pct: var(--lumo-tint-90pct);
    --lumo-contrast: var(--lumo-tint);

    /* Text */
    --lumo-header-text-color: var(--lumo-contrast);
    --lumo-body-text-color: var(--lumo-contrast-90pct);
    --lumo-secondary-text-color: var(--lumo-contrast-70pct);
    --lumo-tertiary-text-color: var(--lumo-contrast-50pct);
    --lumo-disabled-text-color: var(--lumo-contrast-30pct);

    /* Primary */
    --lumo-primary-color: hsl(214, 90%, 48%);
    --lumo-primary-color-50pct: hsla(214, 90%, 70%, 0.69);
    --lumo-primary-color-10pct: hsla(214, 90%, 55%, 0.13);
    --lumo-primary-text-color: hsl(214, 90%, 77%);
    --lumo-primary-contrast-color: #fff;

    /* Error */
    --lumo-error-color: hsl(3, 79%, 49%);
    --lumo-error-color-50pct: hsla(3, 75%, 62%, 0.5);
    --lumo-error-color-10pct: hsla(3, 75%, 62%, 0.14);
    --lumo-error-text-color: hsl(3, 100%, 80%);

    /* Success */
    --lumo-success-color: hsl(145, 72%, 30%);
    --lumo-success-color-50pct: hsla(145, 92%, 51%, 0.5);
    --lumo-success-color-10pct: hsla(145, 92%, 51%, 0.1);
    --lumo-success-text-color: hsl(145, 85%, 46%);
  }

  html {
    color: var(--lumo-body-text-color);
    background-color: var(--lumo-base-color);
    color-scheme: light;
  }

  [theme~='dark'] {
    color: var(--lumo-body-text-color);
    background-color: var(--lumo-base-color);
    color-scheme: dark;
  }

  h1,
  h2,
  h3,
  h4,
  h5,
  h6 {
    color: var(--lumo-header-text-color);
  }

  a:where(:any-link) {
    color: var(--lumo-primary-text-color);
  }

  a:not(:any-link) {
    color: var(--lumo-disabled-text-color);
  }

  blockquote {
    color: var(--lumo-secondary-text-color);
  }

  code,
  pre {
    background-color: var(--lumo-contrast-10pct);
    border-radius: var(--lumo-border-radius-m);
  }
`;
  Te("", Jm, { moduleId: "lumo-color" });
  const AA = me`
  :host {
    color: var(--lumo-body-text-color) !important;
    background-color: var(--lumo-base-color) !important;
  }
`;
  Te("", [Jm, AA], { moduleId: "lumo-color-legacy" });
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  const EA = me`
  :host {
    --lumo-size-xs: 1.625rem;
    --lumo-size-s: 1.875rem;
    --lumo-size-m: 2.25rem;
    --lumo-size-l: 2.75rem;
    --lumo-size-xl: 3.5rem;

    /* Icons */
    --lumo-icon-size-s: 1.25em;
    --lumo-icon-size-m: 1.5em;
    --lumo-icon-size-l: 2.25em;
    /* For backwards compatibility */
    --lumo-icon-size: var(--lumo-icon-size-m);
  }
`, Xm = document.createElement("template");
  Xm.innerHTML = `<style>${EA.toString().replace(":host", "html")}</style>`;
  document.head.appendChild(Xm.content);
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  const $A = me`
  :host {
    /* Border radius */
    --lumo-border-radius-s: 0.25em; /* Checkbox, badge, date-picker year indicator, etc */
    --lumo-border-radius-m: var(--lumo-border-radius, 0.25em); /* Button, text field, menu overlay, etc */
    --lumo-border-radius-l: 0.5em; /* Dialog, notification, etc */
    --lumo-border-radius: 0.25em; /* Deprecated */

    /* Shadow */
    --lumo-box-shadow-xs: 0 1px 4px -1px var(--lumo-shade-50pct);
    --lumo-box-shadow-s: 0 2px 4px -1px var(--lumo-shade-20pct), 0 3px 12px -1px var(--lumo-shade-30pct);
    --lumo-box-shadow-m: 0 2px 6px -1px var(--lumo-shade-20pct), 0 8px 24px -4px var(--lumo-shade-40pct);
    --lumo-box-shadow-l: 0 3px 18px -2px var(--lumo-shade-20pct), 0 12px 48px -6px var(--lumo-shade-40pct);
    --lumo-box-shadow-xl: 0 4px 24px -3px var(--lumo-shade-20pct), 0 18px 64px -8px var(--lumo-shade-40pct);

    /* Clickable element cursor */
    --lumo-clickable-cursor: default;
  }
`;
  me`
  html {
    --vaadin-checkbox-size: calc(var(--lumo-size-m) / 2);
    --vaadin-radio-button-size: calc(var(--lumo-size-m) / 2);
  }
`;
  const Qm = document.createElement("template");
  Qm.innerHTML = `<style>${$A.toString().replace(":host", "html")}$</style>`;
  document.head.appendChild(Qm.content);
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  const TA = me`
  :host {
    /* prettier-ignore */
    --lumo-font-family: -apple-system, BlinkMacSystemFont, 'Roboto', 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';

    /* Font sizes */
    --lumo-font-size-xxs: 0.75rem;
    --lumo-font-size-xs: 0.8125rem;
    --lumo-font-size-s: 0.875rem;
    --lumo-font-size-m: 1rem;
    --lumo-font-size-l: 1.125rem;
    --lumo-font-size-xl: 1.375rem;
    --lumo-font-size-xxl: 1.75rem;
    --lumo-font-size-xxxl: 2.5rem;

    /* Line heights */
    --lumo-line-height-xs: 1.25;
    --lumo-line-height-s: 1.375;
    --lumo-line-height-m: 1.625;
  }
`, OA = me`
  html,
  :host {
    font-family: var(--lumo-font-family);
    font-size: var(--lumo-font-size, var(--lumo-font-size-m));
    line-height: var(--lumo-line-height-m);
    -webkit-text-size-adjust: 100%;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }

  small,
  [theme~='font-size-s'] {
    font-size: var(--lumo-font-size-s);
    line-height: var(--lumo-line-height-s);
  }

  [theme~='font-size-xs'] {
    font-size: var(--lumo-font-size-xs);
    line-height: var(--lumo-line-height-xs);
  }

  h1,
  h2,
  h3,
  h4,
  h5,
  h6 {
    font-weight: 600;
    line-height: var(--lumo-line-height-xs);
    margin-top: 1.25em;
  }

  h1 {
    font-size: var(--lumo-font-size-xxxl);
    margin-bottom: 0.75em;
  }

  h2 {
    font-size: var(--lumo-font-size-xxl);
    margin-bottom: 0.5em;
  }

  h3 {
    font-size: var(--lumo-font-size-xl);
    margin-bottom: 0.5em;
  }

  h4 {
    font-size: var(--lumo-font-size-l);
    margin-bottom: 0.5em;
  }

  h5 {
    font-size: var(--lumo-font-size-m);
    margin-bottom: 0.25em;
  }

  h6 {
    font-size: var(--lumo-font-size-xs);
    margin-bottom: 0;
    text-transform: uppercase;
    letter-spacing: 0.03em;
  }

  p,
  blockquote {
    margin-top: 0.5em;
    margin-bottom: 0.75em;
  }

  a {
    text-decoration: none;
  }

  a:where(:any-link):hover {
    text-decoration: underline;
  }

  hr {
    display: block;
    align-self: stretch;
    height: 1px;
    border: 0;
    padding: 0;
    margin: var(--lumo-space-s) calc(var(--lumo-border-radius-m) / 2);
    background-color: var(--lumo-contrast-10pct);
  }

  blockquote {
    border-left: 2px solid var(--lumo-contrast-30pct);
  }

  b,
  strong {
    font-weight: 600;
  }

  /* RTL specific styles */
  blockquote[dir='rtl'] {
    border-left: none;
    border-right: 2px solid var(--lumo-contrast-30pct);
  }
`;
  Te("", OA, { moduleId: "lumo-typography" });
  const eb = document.createElement("template");
  eb.innerHTML = `<style>${TA.toString().replace(":host", "html")}</style>`;
  document.head.appendChild(eb.content);
  Te(
    "vaadin-input-container",
    me`
    :host {
      border-radius: var(--lumo-border-radius-m);
      background-color: var(--lumo-contrast-10pct);
      padding: 0 calc(0.375em + var(--lumo-border-radius-m) / 4 - 1px);
      font-weight: 500;
      line-height: 1;
      position: relative;
      cursor: text;
      box-sizing: border-box;
    }

    /* Used for hover and activation effects */
    :host::after {
      content: '';
      position: absolute;
      top: 0;
      right: 0;
      bottom: 0;
      left: 0;
      border-radius: inherit;
      pointer-events: none;
      background-color: var(--lumo-contrast-50pct);
      opacity: 0;
      transition: transform 0.15s, opacity 0.2s;
      transform-origin: 100% 0;
    }

    ::slotted(:not([slot$='fix'])) {
      cursor: inherit;
      min-height: var(--lumo-text-field-size, var(--lumo-size-m));
      padding: 0 0.25em;
      --_lumo-text-field-overflow-mask-image: linear-gradient(to left, transparent, #000 1.25em);
      -webkit-mask-image: var(--_lumo-text-field-overflow-mask-image);
      mask-image: var(--_lumo-text-field-overflow-mask-image);
    }

    /* Read-only */
    :host([readonly]) {
      color: var(--lumo-secondary-text-color);
      background-color: transparent;
      cursor: default;
    }

    :host([readonly])::after {
      background-color: transparent;
      opacity: 1;
      border: 1px dashed var(--lumo-contrast-30pct);
    }

    /* Disabled */
    :host([disabled]) {
      background-color: var(--lumo-contrast-5pct);
    }

    :host([disabled]) ::slotted(*) {
      color: var(--lumo-disabled-text-color);
      -webkit-text-fill-color: var(--lumo-disabled-text-color);
    }

    /* Invalid */
    :host([invalid]) {
      background-color: var(--lumo-error-color-10pct);
    }

    :host([invalid])::after {
      background-color: var(--lumo-error-color-50pct);
    }

    /* Slotted icons */
    ::slotted(iron-icon),
    ::slotted(vaadin-icon) {
      color: var(--lumo-contrast-60pct);
      width: var(--lumo-icon-size-m);
      height: var(--lumo-icon-size-m);
    }

    /* Vaadin icons are based on a 16x16 grid (unlike Lumo and Material icons with 24x24), so they look too big by default */
    ::slotted(iron-icon[icon^='vaadin:']),
    ::slotted(vaadin-icon[icon^='vaadin:']) {
      padding: 0.25em;
      box-sizing: border-box !important;
    }

    /* Text align */
    :host([dir='rtl']) ::slotted(:not([slot$='fix'])) {
      --_lumo-text-field-overflow-mask-image: linear-gradient(to right, transparent, #000 1.25em);
    }

    @-moz-document url-prefix() {
      :host([dir='rtl']) ::slotted(:not([slot$='fix'])) {
        mask-image: var(--_lumo-text-field-overflow-mask-image);
      }
    }

    :host([theme~='align-left']) ::slotted(:not([slot$='fix'])) {
      text-align: start;
      --_lumo-text-field-overflow-mask-image: none;
    }

    :host([theme~='align-center']) ::slotted(:not([slot$='fix'])) {
      text-align: center;
      --_lumo-text-field-overflow-mask-image: none;
    }

    :host([theme~='align-right']) ::slotted(:not([slot$='fix'])) {
      text-align: end;
      --_lumo-text-field-overflow-mask-image: none;
    }

    @-moz-document url-prefix() {
      /* Firefox is smart enough to align overflowing text to right */
      :host([theme~='align-right']) ::slotted(:not([slot$='fix'])) {
        --_lumo-text-field-overflow-mask-image: linear-gradient(to right, transparent 0.25em, #000 1.5em);
      }
    }

    @-moz-document url-prefix() {
      /* Firefox is smart enough to align overflowing text to right */
      :host([theme~='align-left']) ::slotted(:not([slot$='fix'])) {
        --_lumo-text-field-overflow-mask-image: linear-gradient(to left, transparent 0.25em, #000 1.5em);
      }
    }

    /* RTL specific styles */
    :host([dir='rtl'])::after {
      transform-origin: 0% 0;
    }

    :host([theme~='align-left'][dir='rtl']) ::slotted(:not([slot$='fix'])) {
      --_lumo-text-field-overflow-mask-image: none;
    }

    :host([theme~='align-center'][dir='rtl']) ::slotted(:not([slot$='fix'])) {
      --_lumo-text-field-overflow-mask-image: none;
    }

    :host([theme~='align-right'][dir='rtl']) ::slotted(:not([slot$='fix'])) {
      --_lumo-text-field-overflow-mask-image: none;
    }

    @-moz-document url-prefix() {
      /* Firefox is smart enough to align overflowing text to right */
      :host([theme~='align-right'][dir='rtl']) ::slotted(:not([slot$='fix'])) {
        --_lumo-text-field-overflow-mask-image: linear-gradient(to right, transparent 0.25em, #000 1.5em);
      }
    }

    @-moz-document url-prefix() {
      /* Firefox is smart enough to align overflowing text to right */
      :host([theme~='align-left'][dir='rtl']) ::slotted(:not([slot$='fix'])) {
        --_lumo-text-field-overflow-mask-image: linear-gradient(to left, transparent 0.25em, #000 1.5em);
      }
    }
  `,
    { moduleId: "lumo-input-container" }
  );
  /**
  @license
  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */
  window.JSCompiler_renameProperty = function(r, e) {
    return r;
  };
  /**
  @license
  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */
  let DA = /(url\()([^)]*)(\))/g, PA = /(^\/[^\/])|(^#)|(^[\w-\d]*:)/, Zs, kt;
  function An(r, e) {
    if (r && PA.test(r) || r === "//")
      return r;
    if (Zs === void 0) {
      Zs = !1;
      try {
        const t = new URL("b", "http://a");
        t.pathname = "c%20d", Zs = t.href === "http://a/c%20d";
      } catch {
      }
    }
    if (e || (e = document.baseURI || window.location.href), Zs)
      try {
        return new URL(r, e).href;
      } catch {
        return r;
      }
    return kt || (kt = document.implementation.createHTMLDocument("temp"), kt.base = kt.createElement("base"), kt.head.appendChild(kt.base), kt.anchor = kt.createElement("a"), kt.body.appendChild(kt.anchor)), kt.base.href = e, kt.anchor.href = r, kt.anchor.href || r;
  }
  function ru(r, e) {
    return r.replace(DA, function(t, i, o, a) {
      return i + "'" + An(o.replace(/["']/g, ""), e) + "'" + a;
    });
  }
  function iu(r) {
    return r.substring(0, r.lastIndexOf("/") + 1);
  }
  /**
  @license
  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */
  const tb = !window.ShadyDOM || !window.ShadyDOM.inUse;
  !window.ShadyCSS || window.ShadyCSS.nativeCss;
  const IA = tb && "adoptedStyleSheets" in Document.prototype && "replaceSync" in CSSStyleSheet.prototype && // Since spec may change, feature detect exact API we need
  (() => {
    try {
      const r = new CSSStyleSheet();
      r.replaceSync("");
      const e = document.createElement("div");
      return e.attachShadow({ mode: "open" }), e.shadowRoot.adoptedStyleSheets = [r], e.shadowRoot.adoptedStyleSheets[0] === r;
    } catch {
      return !1;
    }
  })();
  let MA = window.Polymer && window.Polymer.rootPath || iu(document.baseURI || window.location.href), wa = window.Polymer && window.Polymer.sanitizeDOMValue || void 0;
  window.Polymer && window.Polymer.setPassiveTouchGestures;
  let ka = window.Polymer && window.Polymer.strictTemplatePolicy || !1, NA = window.Polymer && window.Polymer.allowTemplateFromDomModule || !1, rb = window.Polymer && window.Polymer.legacyOptimizations || !1, ib = window.Polymer && window.Polymer.legacyWarnings || !1, LA = window.Polymer && window.Polymer.syncInitialRender || !1, ld = window.Polymer && window.Polymer.legacyUndefined || !1, RA = window.Polymer && window.Polymer.orderedComputed || !1, Wp = window.Polymer && window.Polymer.removeNestedTemplates || !1, FA = window.Polymer && window.Polymer.fastDomIf || !1, Bp = window.Polymer && window.Polymer.suppressTemplateNotifications || !1;
  window.Polymer && window.Polymer.legacyNoObservedAttributes;
  let zA = window.Polymer && window.Polymer.useAdoptedStyleSheetsWithBuiltCSS || !1;
  /**
  @license
  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */
  let HA = 0;
  const Oe = function(r) {
    let e = (
      /** @type {!MixinFunction} */
      r.__mixinApplications
    );
    e || (e = /* @__PURE__ */ new WeakMap(), r.__mixinApplications = e);
    let t = HA++;
    function i(o) {
      let a = (
        /** @type {!MixinFunction} */
        o.__mixinSet
      );
      if (a && a[t])
        return o;
      let l = e, d = l.get(o);
      if (!d) {
        d = /** @type {!Function} */
        r(o), l.set(o, d);
        let u = Object.create(
          /** @type {!MixinFunction} */
          d.__mixinSet || a || null
        );
        u[t] = !0, d.__mixinSet = u;
      }
      return d;
    }
    return i;
  };
  /**
  @license
  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */
  let ou = {}, ob = {};
  function Vp(r, e) {
    ou[r] = ob[r.toLowerCase()] = e;
  }
  function qp(r) {
    return ou[r] || ob[r.toLowerCase()];
  }
  function UA(r) {
    r.querySelector("style");
  }
  class Nn extends HTMLElement {
    /** @override */
    static get observedAttributes() {
      return ["id"];
    }
    /**
     * Retrieves the element specified by the css `selector` in the module
     * registered by `id`. For example, this.import('foo', 'img');
     * @param {string} id The id of the dom-module in which to search.
     * @param {string=} selector The css selector by which to find the element.
     * @return {Element} Returns the element which matches `selector` in the
     * module registered at the specified `id`.
     *
     * @export
     * @nocollapse Referred to indirectly in style-gather.js
     */
    static import(e, t) {
      if (e) {
        let i = qp(e);
        return i && t ? i.querySelector(t) : i;
      }
      return null;
    }
    /* eslint-disable no-unused-vars */
    /**
     * @param {string} name Name of attribute.
     * @param {?string} old Old value of attribute.
     * @param {?string} value Current value of attribute.
     * @param {?string} namespace Attribute namespace.
     * @return {void}
     * @override
     */
    attributeChangedCallback(e, t, i, o) {
      t !== i && this.register();
    }
    /* eslint-enable no-unused-args */
    /**
     * The absolute URL of the original location of this `dom-module`.
     *
     * This value will differ from this element's `ownerDocument` in the
     * following ways:
     * - Takes into account any `assetpath` attribute added during bundling
     *   to indicate the original location relative to the bundled location
     * - Uses the HTMLImports polyfill's `importForElement` API to ensure
     *   the path is relative to the import document's location since
     *   `ownerDocument` is not currently polyfilled
     */
    get assetpath() {
      if (!this.__assetpath) {
        const e = window.HTMLImports && HTMLImports.importForElement ? HTMLImports.importForElement(this) || document : this.ownerDocument, t = An(
          this.getAttribute("assetpath") || "",
          e.baseURI
        );
        this.__assetpath = iu(t);
      }
      return this.__assetpath;
    }
    /**
     * Registers the dom-module at a given id. This method should only be called
     * when a dom-module is imperatively created. For
     * example, `document.createElement('dom-module').register('foo')`.
     * @param {string=} id The id at which to register the dom-module.
     * @return {void}
     */
    register(e) {
      if (e = e || this.id, e) {
        if (ka && qp(e) !== void 0)
          throw Vp(e, null), new Error(`strictTemplatePolicy: dom-module ${e} re-registered`);
        this.id = e, Vp(e, this), UA(this);
      }
    }
  }
  Nn.prototype.modules = ou;
  customElements.define("dom-module", Nn);
  /**
  @license
  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */
  const WA = "link[rel=import][type~=css]", BA = "include", Yp = "shady-unscoped";
  function nb(r) {
    return (
      /** @type {?DomModule} */
      Nn.import(r)
    );
  }
  function Gp(r) {
    let e = r.body ? r.body : r;
    const t = ru(
      e.textContent,
      r.baseURI
    ), i = document.createElement("style");
    return i.textContent = t, i;
  }
  function VA(r) {
    const e = r.trim().split(/\s+/), t = [];
    for (let i = 0; i < e.length; i++)
      t.push(...qA(e[i]));
    return t;
  }
  function qA(r) {
    const e = nb(r);
    if (!e)
      return [];
    if (e._styles === void 0) {
      const t = [];
      t.push(...ab(e));
      const i = (
        /** @type {?HTMLTemplateElement} */
        e.querySelector("template")
      );
      i && t.push(...sb(
        i,
        /** @type {templateWithAssetPath} */
        e.assetpath
      )), e._styles = t;
    }
    return e._styles;
  }
  function sb(r, e) {
    if (!r._styles) {
      const t = [], i = r.content.querySelectorAll("style");
      for (let o = 0; o < i.length; o++) {
        let a = i[o], l = a.getAttribute(BA);
        l && t.push(...VA(l).filter(function(d, u, f) {
          return f.indexOf(d) === u;
        })), e && (a.textContent = ru(
          a.textContent,
          /** @type {string} */
          e
        )), t.push(a);
      }
      r._styles = t;
    }
    return r._styles;
  }
  function YA(r) {
    let e = nb(r);
    return e ? ab(e) : [];
  }
  function ab(r) {
    const e = [], t = r.querySelectorAll(WA);
    for (let i = 0; i < t.length; i++) {
      let o = t[i];
      if (o.import) {
        const a = o.import, l = o.hasAttribute(Yp);
        if (l && !a._unscopedStyle) {
          const d = Gp(a);
          d.setAttribute(Yp, ""), a._unscopedStyle = d;
        } else a._style || (a._style = Gp(a));
        e.push(l ? a._unscopedStyle : a._style);
      }
    }
    return e;
  }
  /**
  @license
  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */
  const ye = window.ShadyDOM && window.ShadyDOM.noPatch && window.ShadyDOM.wrap ? window.ShadyDOM.wrap : window.ShadyDOM ? (r) => ShadyDOM.patch(r) : (r) => r;
  /**
  @license
  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */
  function cd(r) {
    return r.indexOf(".") >= 0;
  }
  function Ti(r) {
    let e = r.indexOf(".");
    return e === -1 ? r : r.slice(0, e);
  }
  function lb(r, e) {
    return r.indexOf(e + ".") === 0;
  }
  function Ln(r, e) {
    return e.indexOf(r + ".") === 0;
  }
  function Rn(r, e, t) {
    return e + t.slice(r.length);
  }
  function GA(r, e) {
    return r === e || lb(r, e) || Ln(r, e);
  }
  function vn(r) {
    if (Array.isArray(r)) {
      let e = [];
      for (let t = 0; t < r.length; t++) {
        let i = r[t].toString().split(".");
        for (let o = 0; o < i.length; o++)
          e.push(i[o]);
      }
      return e.join(".");
    } else
      return r;
  }
  function cb(r) {
    return Array.isArray(r) ? vn(r).split(".") : r.toString().split(".");
  }
  function at(r, e, t) {
    let i = r, o = cb(e);
    for (let a = 0; a < o.length; a++) {
      if (!i)
        return;
      let l = o[a];
      i = i[l];
    }
    return t && (t.path = o.join(".")), i;
  }
  function jp(r, e, t) {
    let i = r, o = cb(e), a = o[o.length - 1];
    if (o.length > 1) {
      for (let l = 0; l < o.length - 1; l++) {
        let d = o[l];
        if (i = i[d], !i)
          return;
      }
      i[a] = t;
    } else
      i[e] = t;
    return o.join(".");
  }
  /**
  @license
  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */
  const xa = {}, jA = /-[a-z]/g, ZA = /([A-Z])/g;
  function db(r) {
    return xa[r] || (xa[r] = r.indexOf("-") < 0 ? r : r.replace(
      jA,
      (e) => e[1].toUpperCase()
    ));
  }
  function Fa(r) {
    return xa[r] || (xa[r] = r.replace(ZA, "-$1").toLowerCase());
  }
  /**
  @license
  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */
  let KA = 0, ub = 0, ao = [], JA = 0, dd = !1, hb = document.createTextNode("");
  new window.MutationObserver(XA).observe(hb, { characterData: !0 });
  function XA() {
    dd = !1;
    const r = ao.length;
    for (let e = 0; e < r; e++) {
      let t = ao[e];
      if (t)
        try {
          t();
        } catch (i) {
          setTimeout(() => {
            throw i;
          });
        }
    }
    ao.splice(0, r), ub += r;
  }
  const QA = {
    /**
     * Returns a sub-module with the async interface providing the provided
     * delay.
     *
     * @memberof timeOut
     * @param {number=} delay Time to wait before calling callbacks in ms
     * @return {!AsyncInterface} An async timeout interface
     */
    after(r) {
      return {
        run(e) {
          return window.setTimeout(e, r);
        },
        cancel(e) {
          window.clearTimeout(e);
        }
      };
    },
    /**
     * Enqueues a function called in the next task.
     *
     * @memberof timeOut
     * @param {!Function} fn Callback to run
     * @param {number=} delay Delay in milliseconds
     * @return {number} Handle used for canceling task
     */
    run(r, e) {
      return window.setTimeout(r, e);
    },
    /**
     * Cancels a previously enqueued `timeOut` callback.
     *
     * @memberof timeOut
     * @param {number} handle Handle returned from `run` of callback to cancel
     * @return {void}
     */
    cancel(r) {
      window.clearTimeout(r);
    }
  }, nu = {
    /**
     * Enqueues a function called at microtask timing.
     *
     * @memberof microTask
     * @param {!Function=} callback Callback to run
     * @return {number} Handle used for canceling task
     */
    run(r) {
      return dd || (dd = !0, hb.textContent = JA++), ao.push(r), KA++;
    },
    /**
     * Cancels a previously enqueued `microTask` callback.
     *
     * @memberof microTask
     * @param {number} handle Handle returned from `run` of callback to cancel
     * @return {void}
     */
    cancel(r) {
      const e = r - ub;
      if (e >= 0) {
        if (!ao[e])
          throw new Error("invalid async handle: " + r);
        ao[e] = null;
      }
    }
  };
  /**
  @license
  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */
  const eE = nu, fb = Oe(
    /**
     * @template T
     * @param {function(new:T)} superClass Class to apply mixin to.
     * @return {function(new:T)} superClass with mixin applied.
     */
    (r) => {
      class e extends r {
        /**
         * Creates property accessors for the given property names.
         * @param {!Object} props Object whose keys are names of accessors.
         * @return {void}
         * @protected
         * @nocollapse
         */
        static createProperties(i) {
          const o = this.prototype;
          for (let a in i)
            a in o || o._createPropertyAccessor(a);
        }
        /**
         * Returns an attribute name that corresponds to the given property.
         * The attribute name is the lowercased property name. Override to
         * customize this mapping.
         * @param {string} property Property to convert
         * @return {string} Attribute name corresponding to the given property.
         *
         * @protected
         * @nocollapse
         */
        static attributeNameForProperty(i) {
          return i.toLowerCase();
        }
        /**
         * Override point to provide a type to which to deserialize a value to
         * a given property.
         * @param {string} name Name of property
         *
         * @protected
         * @nocollapse
         */
        static typeForProperty(i) {
        }
        //eslint-disable-line no-unused-vars
        /**
         * Creates a setter/getter pair for the named property with its own
         * local storage.  The getter returns the value in the local storage,
         * and the setter calls `_setProperty`, which updates the local storage
         * for the property and enqueues a `_propertiesChanged` callback.
         *
         * This method may be called on a prototype or an instance.  Calling
         * this method may overwrite a property value that already exists on
         * the prototype/instance by creating the accessor.
         *
         * @param {string} property Name of the property
         * @param {boolean=} readOnly When true, no setter is created; the
         *   protected `_setProperty` function must be used to set the property
         * @return {void}
         * @protected
         * @override
         */
        _createPropertyAccessor(i, o) {
          this._addPropertyToAttributeMap(i), this.hasOwnProperty(JSCompiler_renameProperty("__dataHasAccessor", this)) || (this.__dataHasAccessor = Object.assign({}, this.__dataHasAccessor)), this.__dataHasAccessor[i] || (this.__dataHasAccessor[i] = !0, this._definePropertyAccessor(i, o));
        }
        /**
         * Adds the given `property` to a map matching attribute names
         * to property names, using `attributeNameForProperty`. This map is
         * used when deserializing attribute values to properties.
         *
         * @param {string} property Name of the property
         * @override
         */
        _addPropertyToAttributeMap(i) {
          this.hasOwnProperty(JSCompiler_renameProperty("__dataAttributes", this)) || (this.__dataAttributes = Object.assign({}, this.__dataAttributes));
          let o = this.__dataAttributes[i];
          return o || (o = this.constructor.attributeNameForProperty(i), this.__dataAttributes[o] = i), o;
        }
        /**
         * Defines a property accessor for the given property.
         * @param {string} property Name of the property
         * @param {boolean=} readOnly When true, no setter is created
         * @return {void}
         * @override
         */
        _definePropertyAccessor(i, o) {
          Object.defineProperty(this, i, {
            /* eslint-disable valid-jsdoc */
            /** @this {PropertiesChanged} */
            get() {
              return this.__data[i];
            },
            /** @this {PropertiesChanged} */
            set: o ? function() {
            } : function(a) {
              this._setPendingProperty(i, a, !0) && this._invalidateProperties();
            }
            /* eslint-enable */
          });
        }
        constructor() {
          super(), this.__dataEnabled = !1, this.__dataReady = !1, this.__dataInvalid = !1, this.__data = {}, this.__dataPending = null, this.__dataOld = null, this.__dataInstanceProps = null, this.__dataCounter = 0, this.__serializing = !1, this._initializeProperties();
        }
        /**
         * Lifecycle callback called when properties are enabled via
         * `_enableProperties`.
         *
         * Users may override this function to implement behavior that is
         * dependent on the element having its property data initialized, e.g.
         * from defaults (initialized from `constructor`, `_initializeProperties`),
         * `attributeChangedCallback`, or values propagated from host e.g. via
         * bindings.  `super.ready()` must be called to ensure the data system
         * becomes enabled.
         *
         * @return {void}
         * @public
         * @override
         */
        ready() {
          this.__dataReady = !0, this._flushProperties();
        }
        /**
         * Initializes the local storage for property accessors.
         *
         * Provided as an override point for performing any setup work prior
         * to initializing the property accessor system.
         *
         * @return {void}
         * @protected
         * @override
         */
        _initializeProperties() {
          for (let i in this.__dataHasAccessor)
            this.hasOwnProperty(i) && (this.__dataInstanceProps = this.__dataInstanceProps || {}, this.__dataInstanceProps[i] = this[i], delete this[i]);
        }
        /**
         * Called at ready time with bag of instance properties that overwrote
         * accessors when the element upgraded.
         *
         * The default implementation sets these properties back into the
         * setter at ready time.  This method is provided as an override
         * point for customizing or providing more efficient initialization.
         *
         * @param {Object} props Bag of property values that were overwritten
         *   when creating property accessors.
         * @return {void}
         * @protected
         * @override
         */
        _initializeInstanceProperties(i) {
          Object.assign(this, i);
        }
        /**
         * Updates the local storage for a property (via `_setPendingProperty`)
         * and enqueues a `_proeprtiesChanged` callback.
         *
         * @param {string} property Name of the property
         * @param {*} value Value to set
         * @return {void}
         * @protected
         * @override
         */
        _setProperty(i, o) {
          this._setPendingProperty(i, o) && this._invalidateProperties();
        }
        /**
         * Returns the value for the given property.
         * @param {string} property Name of property
         * @return {*} Value for the given property
         * @protected
         * @override
         */
        _getProperty(i) {
          return this.__data[i];
        }
        /* eslint-disable no-unused-vars */
        /**
         * Updates the local storage for a property, records the previous value,
         * and adds it to the set of "pending changes" that will be passed to the
         * `_propertiesChanged` callback.  This method does not enqueue the
         * `_propertiesChanged` callback.
         *
         * @param {string} property Name of the property
         * @param {*} value Value to set
         * @param {boolean=} ext Not used here; affordance for closure
         * @return {boolean} Returns true if the property changed
         * @protected
         * @override
         */
        _setPendingProperty(i, o, a) {
          let l = this.__data[i], d = this._shouldPropertyChange(i, o, l);
          return d && (this.__dataPending || (this.__dataPending = {}, this.__dataOld = {}), this.__dataOld && !(i in this.__dataOld) && (this.__dataOld[i] = l), this.__data[i] = o, this.__dataPending[i] = o), d;
        }
        /* eslint-enable */
        /**
         * @param {string} property Name of the property
         * @return {boolean} Returns true if the property is pending.
         */
        _isPropertyPending(i) {
          return !!(this.__dataPending && this.__dataPending.hasOwnProperty(i));
        }
        /**
         * Marks the properties as invalid, and enqueues an async
         * `_propertiesChanged` callback.
         *
         * @return {void}
         * @protected
         * @override
         */
        _invalidateProperties() {
          !this.__dataInvalid && this.__dataReady && (this.__dataInvalid = !0, eE.run(() => {
            this.__dataInvalid && (this.__dataInvalid = !1, this._flushProperties());
          }));
        }
        /**
         * Call to enable property accessor processing. Before this method is
         * called accessor values will be set but side effects are
         * queued. When called, any pending side effects occur immediately.
         * For elements, generally `connectedCallback` is a normal spot to do so.
         * It is safe to call this method multiple times as it only turns on
         * property accessors once.
         *
         * @return {void}
         * @protected
         * @override
         */
        _enableProperties() {
          this.__dataEnabled || (this.__dataEnabled = !0, this.__dataInstanceProps && (this._initializeInstanceProperties(this.__dataInstanceProps), this.__dataInstanceProps = null), this.ready());
        }
        /**
         * Calls the `_propertiesChanged` callback with the current set of
         * pending changes (and old values recorded when pending changes were
         * set), and resets the pending set of changes. Generally, this method
         * should not be called in user code.
         *
         * @return {void}
         * @protected
         * @override
         */
        _flushProperties() {
          this.__dataCounter++;
          const i = this.__data, o = this.__dataPending, a = this.__dataOld;
          this._shouldPropertiesChange(i, o, a) && (this.__dataPending = null, this.__dataOld = null, this._propertiesChanged(i, o, a)), this.__dataCounter--;
        }
        /**
         * Called in `_flushProperties` to determine if `_propertiesChanged`
         * should be called. The default implementation returns true if
         * properties are pending. Override to customize when
         * `_propertiesChanged` is called.
         * @param {!Object} currentProps Bag of all current accessor values
         * @param {?Object} changedProps Bag of properties changed since the last
         *   call to `_propertiesChanged`
         * @param {?Object} oldProps Bag of previous values for each property
         *   in `changedProps`
         * @return {boolean} true if changedProps is truthy
         * @override
         */
        _shouldPropertiesChange(i, o, a) {
          return !!o;
        }
        /**
         * Callback called when any properties with accessors created via
         * `_createPropertyAccessor` have been set.
         *
         * @param {!Object} currentProps Bag of all current accessor values
         * @param {?Object} changedProps Bag of properties changed since the last
         *   call to `_propertiesChanged`
         * @param {?Object} oldProps Bag of previous values for each property
         *   in `changedProps`
         * @return {void}
         * @protected
         * @override
         */
        _propertiesChanged(i, o, a) {
        }
        /**
         * Method called to determine whether a property value should be
         * considered as a change and cause the `_propertiesChanged` callback
         * to be enqueued.
         *
         * The default implementation returns `true` if a strict equality
         * check fails. The method always returns false for `NaN`.
         *
         * Override this method to e.g. provide stricter checking for
         * Objects/Arrays when using immutable patterns.
         *
         * @param {string} property Property name
         * @param {*} value New property value
         * @param {*} old Previous property value
         * @return {boolean} Whether the property should be considered a change
         *   and enqueue a `_proeprtiesChanged` callback
         * @protected
         * @override
         */
        _shouldPropertyChange(i, o, a) {
          return (
            // Strict equality check
            a !== o && // This ensures (old==NaN, value==NaN) always returns false
            (a === a || o === o)
          );
        }
        /**
         * Implements native Custom Elements `attributeChangedCallback` to
         * set an attribute value to a property via `_attributeToProperty`.
         *
         * @param {string} name Name of attribute that changed
         * @param {?string} old Old attribute value
         * @param {?string} value New attribute value
         * @param {?string} namespace Attribute namespace.
         * @return {void}
         * @suppress {missingProperties} Super may or may not implement the callback
         * @override
         */
        attributeChangedCallback(i, o, a, l) {
          o !== a && this._attributeToProperty(i, a), super.attributeChangedCallback && super.attributeChangedCallback(i, o, a, l);
        }
        /**
         * Deserializes an attribute to its associated property.
         *
         * This method calls the `_deserializeValue` method to convert the string to
         * a typed value.
         *
         * @param {string} attribute Name of attribute to deserialize.
         * @param {?string} value of the attribute.
         * @param {*=} type type to deserialize to, defaults to the value
         * returned from `typeForProperty`
         * @return {void}
         * @override
         */
        _attributeToProperty(i, o, a) {
          if (!this.__serializing) {
            const l = this.__dataAttributes, d = l && l[i] || i;
            this[d] = this._deserializeValue(o, a || this.constructor.typeForProperty(d));
          }
        }
        /**
         * Serializes a property to its associated attribute.
         *
         * @suppress {invalidCasts} Closure can't figure out `this` is an element.
         *
         * @param {string} property Property name to reflect.
         * @param {string=} attribute Attribute name to reflect to.
         * @param {*=} value Property value to refect.
         * @return {void}
         * @override
         */
        _propertyToAttribute(i, o, a) {
          this.__serializing = !0, a = arguments.length < 3 ? this[i] : a, this._valueToNodeAttribute(
            /** @type {!HTMLElement} */
            this,
            a,
            o || this.constructor.attributeNameForProperty(i)
          ), this.__serializing = !1;
        }
        /**
         * Sets a typed value to an HTML attribute on a node.
         *
         * This method calls the `_serializeValue` method to convert the typed
         * value to a string.  If the `_serializeValue` method returns `undefined`,
         * the attribute will be removed (this is the default for boolean
         * type `false`).
         *
         * @param {Element} node Element to set attribute to.
         * @param {*} value Value to serialize.
         * @param {string} attribute Attribute name to serialize to.
         * @return {void}
         * @override
         */
        _valueToNodeAttribute(i, o, a) {
          const l = this._serializeValue(o);
          (a === "class" || a === "name" || a === "slot") && (i = /** @type {?Element} */
          ye(i)), l === void 0 ? i.removeAttribute(a) : i.setAttribute(
            a,
            // Closure's type for `setAttribute`'s second parameter incorrectly
            // excludes `TrustedScript`.
            l === "" && window.trustedTypes ? (
              /** @type {?} */
              window.trustedTypes.emptyScript
            ) : l
          );
        }
        /**
         * Converts a typed JavaScript value to a string.
         *
         * This method is called when setting JS property values to
         * HTML attributes.  Users may override this method to provide
         * serialization for custom types.
         *
         * @param {*} value Property value to serialize.
         * @return {string | undefined} String serialized from the provided
         * property  value.
         * @override
         */
        _serializeValue(i) {
          switch (typeof i) {
            case "boolean":
              return i ? "" : void 0;
            default:
              return i?.toString();
          }
        }
        /**
         * Converts a string to a typed JavaScript value.
         *
         * This method is called when reading HTML attribute values to
         * JS properties.  Users may override this method to provide
         * deserialization for custom `type`s. Types for `Boolean`, `String`,
         * and `Number` convert attributes to the expected types.
         *
         * @param {?string} value Value to deserialize.
         * @param {*=} type Type to deserialize the string to.
         * @return {*} Typed value deserialized from the provided string.
         * @override
         */
        _deserializeValue(i, o) {
          switch (o) {
            case Boolean:
              return i !== null;
            case Number:
              return Number(i);
            default:
              return i;
          }
        }
      }
      return e;
    }
  );
  /**
  @license
  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */
  const pb = {};
  let Ks = HTMLElement.prototype;
  for (; Ks; ) {
    let r = Object.getOwnPropertyNames(Ks);
    for (let e = 0; e < r.length; e++)
      pb[r[e]] = !0;
    Ks = Object.getPrototypeOf(Ks);
  }
  const tE = window.trustedTypes ? (r) => trustedTypes.isHTML(r) || trustedTypes.isScript(r) || trustedTypes.isScriptURL(r) : () => !1;
  function rE(r, e) {
    if (!pb[e]) {
      let t = r[e];
      t !== void 0 && (r.__data ? r._setPendingProperty(e, t) : (r.__dataProto ? r.hasOwnProperty(JSCompiler_renameProperty("__dataProto", r)) || (r.__dataProto = Object.create(r.__dataProto)) : r.__dataProto = {}, r.__dataProto[e] = t));
    }
  }
  const iE = Oe((r) => {
    const e = fb(r);
    class t extends e {
      /**
       * Generates property accessors for all attributes in the standard
       * static `observedAttributes` array.
       *
       * Attribute names are mapped to property names using the `dash-case` to
       * `camelCase` convention
       *
       * @return {void}
       * @nocollapse
       */
      static createPropertiesForAttributes() {
        let o = (
          /** @type {?} */
          this.observedAttributes
        );
        for (let a = 0; a < o.length; a++)
          this.prototype._createPropertyAccessor(db(o[a]));
      }
      /**
       * Returns an attribute name that corresponds to the given property.
       * By default, converts camel to dash case, e.g. `fooBar` to `foo-bar`.
       * @param {string} property Property to convert
       * @return {string} Attribute name corresponding to the given property.
       *
       * @protected
       * @nocollapse
       */
      static attributeNameForProperty(o) {
        return Fa(o);
      }
      /**
       * Overrides PropertiesChanged implementation to initialize values for
       * accessors created for values that already existed on the element
       * prototype.
       *
       * @return {void}
       * @protected
       * @override
       */
      _initializeProperties() {
        this.__dataProto && (this._initializeProtoProperties(this.__dataProto), this.__dataProto = null), super._initializeProperties();
      }
      /**
       * Called at instance time with bag of properties that were overwritten
       * by accessors on the prototype when accessors were created.
       *
       * The default implementation sets these properties back into the
       * setter at instance time.  This method is provided as an override
       * point for customizing or providing more efficient initialization.
       *
       * @param {Object} props Bag of property values that were overwritten
       *   when creating property accessors.
       * @return {void}
       * @protected
       * @override
       */
      _initializeProtoProperties(o) {
        for (let a in o)
          this._setProperty(a, o[a]);
      }
      /**
       * Ensures the element has the given attribute. If it does not,
       * assigns the given value to the attribute.
       *
       * @suppress {invalidCasts} Closure can't figure out `this` is infact an
       *     element
       *
       * @param {string} attribute Name of attribute to ensure is set.
       * @param {string} value of the attribute.
       * @return {void}
       * @override
       */
      _ensureAttribute(o, a) {
        const l = (
          /** @type {!HTMLElement} */
          this
        );
        l.hasAttribute(o) || this._valueToNodeAttribute(l, a, o);
      }
      /**
       * Overrides PropertiesChanged implemention to serialize objects as JSON.
       *
       * @param {*} value Property value to serialize.
       * @return {string | undefined} String serialized from the provided property
       *     value.
       * @override
       */
      _serializeValue(o) {
        switch (typeof o) {
          case "object":
            if (o instanceof Date)
              return o.toString();
            if (o) {
              if (tE(o))
                return (
                  /** @type {?} */
                  o
                );
              try {
                return JSON.stringify(o);
              } catch {
                return "";
              }
            }
          default:
            return super._serializeValue(o);
        }
      }
      /**
       * Converts a string to a typed JavaScript value.
       *
       * This method is called by Polymer when reading HTML attribute values to
       * JS properties.  Users may override this method on Polymer element
       * prototypes to provide deserialization for custom `type`s.  Note,
       * the `type` argument is the value of the `type` field provided in the
       * `properties` configuration object for a given property, and is
       * by convention the constructor for the type to deserialize.
       *
       *
       * @param {?string} value Attribute value to deserialize.
       * @param {*=} type Type to deserialize the string to.
       * @return {*} Typed value deserialized from the provided string.
       * @override
       */
      _deserializeValue(o, a) {
        let l;
        switch (a) {
          case Object:
            try {
              l = JSON.parse(
                /** @type {string} */
                o
              );
            } catch {
              l = o;
            }
            break;
          case Array:
            try {
              l = JSON.parse(
                /** @type {string} */
                o
              );
            } catch {
              l = null;
            }
            break;
          case Date:
            l = isNaN(o) ? String(o) : Number(o), l = new Date(l);
            break;
          default:
            l = super._deserializeValue(o, a);
            break;
        }
        return l;
      }
      /* eslint-enable no-fallthrough */
      /**
       * Overrides PropertiesChanged implementation to save existing prototype
       * property value so that it can be reset.
       * @param {string} property Name of the property
       * @param {boolean=} readOnly When true, no setter is created
       *
       * When calling on a prototype, any overwritten values are saved in
       * `__dataProto`, and it is up to the subclasser to decide how/when
       * to set those properties back into the accessor.  When calling on an
       * instance, the overwritten value is set via `_setPendingProperty`,
       * and the user should call `_invalidateProperties` or `_flushProperties`
       * for the values to take effect.
       * @protected
       * @return {void}
       * @override
       */
      _definePropertyAccessor(o, a) {
        rE(this, o), super._definePropertyAccessor(o, a);
      }
      /**
       * Returns true if this library created an accessor for the given property.
       *
       * @param {string} property Property name
       * @return {boolean} True if an accessor was created
       * @override
       */
      _hasAccessor(o) {
        return this.__dataHasAccessor && this.__dataHasAccessor[o];
      }
      /**
       * Returns true if the specified property has a pending change.
       *
       * @param {string} prop Property name
       * @return {boolean} True if property has a pending change
       * @protected
       * @override
       */
      _isPropertyPending(o) {
        return !!(this.__dataPending && o in this.__dataPending);
      }
    }
    return t;
  });
  /**
  @license
  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */
  const oE = {
    "dom-if": !0,
    "dom-repeat": !0
  };
  let Zp = !1, Kp = !1;
  function nE() {
    if (!Zp) {
      Zp = !0;
      const r = document.createElement("textarea");
      r.placeholder = "a", Kp = r.placeholder === r.textContent;
    }
    return Kp;
  }
  function sE(r) {
    nE() && r.localName === "textarea" && r.placeholder && r.placeholder === r.textContent && (r.textContent = null);
  }
  const aE = (() => {
    const r = window.trustedTypes && window.trustedTypes.createPolicy(
      "polymer-template-event-attribute-policy",
      {
        createScript: (e) => e
      }
    );
    return (e, t, i) => {
      const o = t.getAttribute(i);
      if (r && i.startsWith("on-")) {
        e.setAttribute(
          i,
          r.createScript(o, i)
        );
        return;
      }
      e.setAttribute(i, o);
    };
  })();
  function lE(r) {
    let e = r.getAttribute("is");
    if (e && oE[e]) {
      let t = r;
      for (t.removeAttribute("is"), r = t.ownerDocument.createElement(e), t.parentNode.replaceChild(r, t), r.appendChild(t); t.attributes.length; ) {
        const { name: i } = t.attributes[0];
        aE(r, t, i), t.removeAttribute(i);
      }
    }
    return r;
  }
  function gb(r, e) {
    let t = e.parentInfo && gb(r, e.parentInfo);
    if (t) {
      for (let i = t.firstChild, o = 0; i; i = i.nextSibling)
        if (e.parentIndex === o++)
          return i;
    } else
      return r;
  }
  function cE(r, e, t, i) {
    i.id && (e[i.id] = t);
  }
  function dE(r, e, t) {
    if (t.events && t.events.length)
      for (let i = 0, o = t.events, a; i < o.length && (a = o[i]); i++)
        r._addMethodEventListenerToNode(e, a.name, a.value, r);
  }
  function uE(r, e, t, i) {
    t.templateInfo && (e._templateInfo = t.templateInfo, e._parentTemplateInfo = i);
  }
  function hE(r, e, t) {
    return r = r._methodHost || r, function(o) {
      r[t] && r[t](o, o.detail);
    };
  }
  const fE = Oe(
    /**
     * @template T
     * @param {function(new:T)} superClass Class to apply mixin to.
     * @return {function(new:T)} superClass with mixin applied.
     */
    (r) => {
      class e extends r {
        /**
         * Scans a template to produce template metadata.
         *
         * Template-specific metadata are stored in the object returned, and node-
         * specific metadata are stored in objects in its flattened `nodeInfoList`
         * array.  Only nodes in the template that were parsed as nodes of
         * interest contain an object in `nodeInfoList`.  Each `nodeInfo` object
         * contains an `index` (`childNodes` index in parent) and optionally
         * `parent`, which points to node info of its parent (including its index).
         *
         * The template metadata object returned from this method has the following
         * structure (many fields optional):
         *
         * ```js
         *   {
         *     // Flattened list of node metadata (for nodes that generated metadata)
         *     nodeInfoList: [
         *       {
         *         // `id` attribute for any nodes with id's for generating `$` map
         *         id: {string},
         *         // `on-event="handler"` metadata
         *         events: [
         *           {
         *             name: {string},   // event name
         *             value: {string},  // handler method name
         *           }, ...
         *         ],
         *         // Notes when the template contained a `<slot>` for shady DOM
         *         // optimization purposes
         *         hasInsertionPoint: {boolean},
         *         // For nested `<template>`` nodes, nested template metadata
         *         templateInfo: {object}, // nested template metadata
         *         // Metadata to allow efficient retrieval of instanced node
         *         // corresponding to this metadata
         *         parentInfo: {number},   // reference to parent nodeInfo>
         *         parentIndex: {number},  // index in parent's `childNodes` collection
         *         infoIndex: {number},    // index of this `nodeInfo` in `templateInfo.nodeInfoList`
         *       },
         *       ...
         *     ],
         *     // When true, the template had the `strip-whitespace` attribute
         *     // or was nested in a template with that setting
         *     stripWhitespace: {boolean},
         *     // For nested templates, nested template content is moved into
         *     // a document fragment stored here; this is an optimization to
         *     // avoid the cost of nested template cloning
         *     content: {DocumentFragment}
         *   }
         * ```
         *
         * This method kicks off a recursive treewalk as follows:
         *
         * ```
         *    _parseTemplate <---------------------+
         *      _parseTemplateContent              |
         *        _parseTemplateNode  <------------|--+
         *          _parseTemplateNestedTemplate --+  |
         *          _parseTemplateChildNodes ---------+
         *          _parseTemplateNodeAttributes
         *            _parseTemplateNodeAttribute
         *
         * ```
         *
         * These methods may be overridden to add custom metadata about templates
         * to either `templateInfo` or `nodeInfo`.
         *
         * Note that this method may be destructive to the template, in that
         * e.g. event annotations may be removed after being noted in the
         * template metadata.
         *
         * @param {!HTMLTemplateElement} template Template to parse
         * @param {TemplateInfo=} outerTemplateInfo Template metadata from the outer
         *   template, for parsing nested templates
         * @return {!TemplateInfo} Parsed template metadata
         * @nocollapse
         */
        static _parseTemplate(i, o) {
          if (!i._templateInfo) {
            let a = i._templateInfo = {};
            a.nodeInfoList = [], a.nestedTemplate = !!o, a.stripWhiteSpace = o && o.stripWhiteSpace || i.hasAttribute && i.hasAttribute("strip-whitespace"), this._parseTemplateContent(
              i,
              a,
              /** @type {?} */
              { parent: null }
            );
          }
          return i._templateInfo;
        }
        /**
         * See docs for _parseTemplateNode.
         *
         * @param {!HTMLTemplateElement} template .
         * @param {!TemplateInfo} templateInfo .
         * @param {!NodeInfo} nodeInfo .
         * @return {boolean} .
         * @nocollapse
         */
        static _parseTemplateContent(i, o, a) {
          return this._parseTemplateNode(i.content, o, a);
        }
        /**
         * Parses template node and adds template and node metadata based on
         * the current node, and its `childNodes` and `attributes`.
         *
         * This method may be overridden to add custom node or template specific
         * metadata based on this node.
         *
         * @param {Node} node Node to parse
         * @param {!TemplateInfo} templateInfo Template metadata for current template
         * @param {!NodeInfo} nodeInfo Node metadata for current template.
         * @return {boolean} `true` if the visited node added node-specific
         *   metadata to `nodeInfo`
         * @nocollapse
         */
        static _parseTemplateNode(i, o, a) {
          let l = !1, d = (
            /** @type {!HTMLTemplateElement} */
            i
          );
          return d.localName == "template" && !d.hasAttribute("preserve-content") ? l = this._parseTemplateNestedTemplate(d, o, a) || l : d.localName === "slot" && (o.hasInsertionPoint = !0), sE(d), d.firstChild && this._parseTemplateChildNodes(d, o, a), d.hasAttributes && d.hasAttributes() && (l = this._parseTemplateNodeAttributes(d, o, a) || l), l || a.noted;
        }
        /**
         * Parses template child nodes for the given root node.
         *
         * This method also wraps whitelisted legacy template extensions
         * (`is="dom-if"` and `is="dom-repeat"`) with their equivalent element
         * wrappers, collapses text nodes, and strips whitespace from the template
         * if the `templateInfo.stripWhitespace` setting was provided.
         *
         * @param {Node} root Root node whose `childNodes` will be parsed
         * @param {!TemplateInfo} templateInfo Template metadata for current template
         * @param {!NodeInfo} nodeInfo Node metadata for current template.
         * @return {void}
         */
        static _parseTemplateChildNodes(i, o, a) {
          if (!(i.localName === "script" || i.localName === "style"))
            for (let l = i.firstChild, d = 0, u; l; l = u) {
              if (l.localName == "template" && (l = lE(l)), u = l.nextSibling, l.nodeType === Node.TEXT_NODE) {
                let g = u;
                for (; g && g.nodeType === Node.TEXT_NODE; )
                  l.textContent += g.textContent, u = g.nextSibling, i.removeChild(g), g = u;
                if (o.stripWhiteSpace && !l.textContent.trim()) {
                  i.removeChild(l);
                  continue;
                }
              }
              let f = (
                /** @type {!NodeInfo} */
                { parentIndex: d, parentInfo: a }
              );
              this._parseTemplateNode(l, o, f) && (f.infoIndex = o.nodeInfoList.push(f) - 1), l.parentNode && d++;
            }
        }
        /**
         * Parses template content for the given nested `<template>`.
         *
         * Nested template info is stored as `templateInfo` in the current node's
         * `nodeInfo`. `template.content` is removed and stored in `templateInfo`.
         * It will then be the responsibility of the host to set it back to the
         * template and for users stamping nested templates to use the
         * `_contentForTemplate` method to retrieve the content for this template
         * (an optimization to avoid the cost of cloning nested template content).
         *
         * @param {HTMLTemplateElement} node Node to parse (a <template>)
         * @param {TemplateInfo} outerTemplateInfo Template metadata for current template
         *   that includes the template `node`
         * @param {!NodeInfo} nodeInfo Node metadata for current template.
         * @return {boolean} `true` if the visited node added node-specific
         *   metadata to `nodeInfo`
         * @nocollapse
         */
        static _parseTemplateNestedTemplate(i, o, a) {
          let l = (
            /** @type {!HTMLTemplateElement} */
            i
          ), d = this._parseTemplate(l, o);
          return (d.content = l.content.ownerDocument.createDocumentFragment()).appendChild(l.content), a.templateInfo = d, !0;
        }
        /**
         * Parses template node attributes and adds node metadata to `nodeInfo`
         * for nodes of interest.
         *
         * @param {Element} node Node to parse
         * @param {!TemplateInfo} templateInfo Template metadata for current
         *     template
         * @param {!NodeInfo} nodeInfo Node metadata for current template.
         * @return {boolean} `true` if the visited node added node-specific
         *   metadata to `nodeInfo`
         * @nocollapse
         */
        static _parseTemplateNodeAttributes(i, o, a) {
          let l = !1, d = Array.from(i.attributes);
          for (let u = d.length - 1, f; f = d[u]; u--)
            l = this._parseTemplateNodeAttribute(i, o, a, f.name, f.value) || l;
          return l;
        }
        /**
         * Parses a single template node attribute and adds node metadata to
         * `nodeInfo` for attributes of interest.
         *
         * This implementation adds metadata for `on-event="handler"` attributes
         * and `id` attributes.
         *
         * @param {Element} node Node to parse
         * @param {!TemplateInfo} templateInfo Template metadata for current template
         * @param {!NodeInfo} nodeInfo Node metadata for current template.
         * @param {string} name Attribute name
         * @param {string} value Attribute value
         * @return {boolean} `true` if the visited node added node-specific
         *   metadata to `nodeInfo`
         * @nocollapse
         */
        static _parseTemplateNodeAttribute(i, o, a, l, d) {
          return l.slice(0, 3) === "on-" ? (i.removeAttribute(l), a.events = a.events || [], a.events.push({
            name: l.slice(3),
            value: d
          }), !0) : l === "id" ? (a.id = d, !0) : !1;
        }
        /**
         * Returns the `content` document fragment for a given template.
         *
         * For nested templates, Polymer performs an optimization to cache nested
         * template content to avoid the cost of cloning deeply nested templates.
         * This method retrieves the cached content for a given template.
         *
         * @param {HTMLTemplateElement} template Template to retrieve `content` for
         * @return {DocumentFragment} Content fragment
         * @nocollapse
         */
        static _contentForTemplate(i) {
          let o = (
            /** @type {HTMLTemplateElementWithInfo} */
            i._templateInfo
          );
          return o && o.content || i.content;
        }
        /**
         * Clones the provided template content and returns a document fragment
         * containing the cloned dom.
         *
         * The template is parsed (once and memoized) using this library's
         * template parsing features, and provides the following value-added
         * features:
         * * Adds declarative event listeners for `on-event="handler"` attributes
         * * Generates an "id map" for all nodes with id's under `$` on returned
         *   document fragment
         * * Passes template info including `content` back to templates as
         *   `_templateInfo` (a performance optimization to avoid deep template
         *   cloning)
         *
         * Note that the memoized template parsing process is destructive to the
         * template: attributes for bindings and declarative event listeners are
         * removed after being noted in notes, and any nested `<template>.content`
         * is removed and stored in notes as well.
         *
         * @param {!HTMLTemplateElement} template Template to stamp
         * @param {TemplateInfo=} templateInfo Optional template info associated
         *   with the template to be stamped; if omitted the template will be
         *   automatically parsed.
         * @return {!StampedTemplate} Cloned template content
         * @override
         */
        _stampTemplate(i, o) {
          i && !i.content && window.HTMLTemplateElement && HTMLTemplateElement.decorate && HTMLTemplateElement.decorate(i), o = o || this.constructor._parseTemplate(i);
          let a = o.nodeInfoList, l = o.content || i.content, d = (
            /** @type {DocumentFragment} */
            document.importNode(l, !0)
          );
          d.__noInsertionPoint = !o.hasInsertionPoint;
          let u = d.nodeList = new Array(a.length);
          d.$ = {};
          for (let f = 0, g = a.length, _; f < g && (_ = a[f]); f++) {
            let C = u[f] = gb(d, _);
            cE(this, d.$, C, _), uE(this, C, _, o), dE(this, C, _);
          }
          return d = /** @type {!StampedTemplate} */
          d, d;
        }
        /**
         * Adds an event listener by method name for the event provided.
         *
         * This method generates a handler function that looks up the method
         * name at handling time.
         *
         * @param {!EventTarget} node Node to add listener on
         * @param {string} eventName Name of event
         * @param {string} methodName Name of method
         * @param {*=} context Context the method will be called on (defaults
         *   to `node`)
         * @return {Function} Generated handler function
         * @override
         */
        _addMethodEventListenerToNode(i, o, a, l) {
          l = l || i;
          let d = hE(l, o, a);
          return this._addEventListenerToNode(i, o, d), d;
        }
        /**
         * Override point for adding custom or simulated event handling.
         *
         * @param {!EventTarget} node Node to add event listener to
         * @param {string} eventName Name of event
         * @param {function(!Event):void} handler Listener function to add
         * @return {void}
         * @override
         */
        _addEventListenerToNode(i, o, a) {
          i.addEventListener(o, a);
        }
        /**
         * Override point for adding custom or simulated event handling.
         *
         * @param {!EventTarget} node Node to remove event listener from
         * @param {string} eventName Name of event
         * @param {function(!Event):void} handler Listener function to remove
         * @return {void}
         * @override
         */
        _removeEventListenerFromNode(i, o, a) {
          i.removeEventListener(o, a);
        }
      }
      return e;
    }
  );
  /**
   * @fileoverview
   * @suppress {checkPrototypalTypes}
   * @license Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt The complete set of authors may be found
   * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may
   * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by
   * Google as part of the polymer project is also subject to an additional IP
   * rights grant found at http://polymer.github.io/PATENTS.txt
   */
  let Fn = 0;
  const zn = [], ne = {
    COMPUTE: "__computeEffects",
    REFLECT: "__reflectEffects",
    NOTIFY: "__notifyEffects",
    PROPAGATE: "__propagateEffects",
    OBSERVE: "__observeEffects",
    READ_ONLY: "__readOnly"
  }, mb = "__computeInfo", pE = /[A-Z]/;
  function Ec(r, e, t) {
    let i = r[e];
    if (!i)
      i = r[e] = {};
    else if (!r.hasOwnProperty(e) && (i = r[e] = Object.create(r[e]), t))
      for (let o in i) {
        let a = i[o], l = i[o] = Array(a.length);
        for (let d = 0; d < a.length; d++)
          l[d] = a[d];
      }
    return i;
  }
  function yn(r, e, t, i, o, a) {
    if (e) {
      let l = !1;
      const d = Fn++;
      for (let u in t) {
        let f = o ? Ti(u) : u, g = e[f];
        if (g)
          for (let _ = 0, C = g.length, x; _ < C && (x = g[_]); _++)
            (!x.info || x.info.lastRun !== d) && (!o || su(u, x.trigger)) && (x.info && (x.info.lastRun = d), x.fn(r, u, t, i, x.info, o, a), l = !0);
      }
      return l;
    }
    return !1;
  }
  function gE(r, e, t, i, o, a, l, d) {
    let u = !1, f = l ? Ti(i) : i, g = e[f];
    if (g)
      for (let _ = 0, C = g.length, x; _ < C && (x = g[_]); _++)
        (!x.info || x.info.lastRun !== t) && (!l || su(i, x.trigger)) && (x.info && (x.info.lastRun = t), x.fn(r, i, o, a, x.info, l, d), u = !0);
    return u;
  }
  function su(r, e) {
    if (e) {
      let t = (
        /** @type {string} */
        e.name
      );
      return t == r || !!(e.structured && lb(t, r)) || !!(e.wildcard && Ln(t, r));
    } else
      return !0;
  }
  function Jp(r, e, t, i, o) {
    let a = typeof o.method == "string" ? r[o.method] : o.method, l = o.property;
    a ? a.call(r, r.__data[l], i[l]) : o.dynamicFn;
  }
  function mE(r, e, t, i, o) {
    let a = r[ne.NOTIFY], l, d = Fn++;
    for (let f in e)
      e[f] && (a && gE(r, a, d, f, t, i, o) || o && bE(r, f, t)) && (l = !0);
    let u;
    l && (u = r.__dataHost) && u._invalidateProperties && u._invalidateProperties();
  }
  function bE(r, e, t) {
    let i = Ti(e);
    if (i !== e) {
      let o = Fa(i) + "-changed";
      return bb(r, o, t[e], e), !0;
    }
    return !1;
  }
  function bb(r, e, t, i) {
    let o = {
      value: t,
      queueProperty: !0
    };
    i && (o.path = i), ye(
      /** @type {!HTMLElement} */
      r
    ).dispatchEvent(new CustomEvent(e, { detail: o }));
  }
  function _E(r, e, t, i, o, a) {
    let d = (a ? Ti(e) : e) != e ? e : null, u = d ? at(r, d) : r.__data[e];
    d && u === void 0 && (u = t[e]), bb(r, o.eventName, u, d);
  }
  function vE(r, e, t, i, o) {
    let a, l = (
      /** @type {Object} */
      r.detail
    ), d = l && l.path;
    d ? (i = Rn(t, i, d), a = l && l.value) : a = r.currentTarget[t], a = o ? !a : a, (!e[ne.READ_ONLY] || !e[ne.READ_ONLY][i]) && e._setPendingPropertyOrPath(i, a, !0, !!d) && (!l || !l.queueProperty) && e._invalidateProperties();
  }
  function yE(r, e, t, i, o) {
    let a = r.__data[e];
    wa && (a = wa(
      a,
      o.attrName,
      "attribute",
      /** @type {Node} */
      r
    )), r._propertyToAttribute(e, o.attrName, a);
  }
  function wE(r, e, t, i) {
    let o = r[ne.COMPUTE];
    if (o)
      if (RA) {
        Fn++;
        const a = xE(r), l = [];
        for (let u in e)
          Xp(u, o, l, a, i);
        let d;
        for (; d = l.shift(); )
          _b(r, "", e, t, d) && Xp(d.methodInfo, o, l, a, i);
        Object.assign(
          /** @type {!Object} */
          t,
          r.__dataOld
        ), Object.assign(
          /** @type {!Object} */
          e,
          r.__dataPending
        ), r.__dataPending = null;
      } else {
        let a = e;
        for (; yn(r, o, a, t, i); )
          Object.assign(
            /** @type {!Object} */
            t,
            r.__dataOld
          ), Object.assign(
            /** @type {!Object} */
            e,
            r.__dataPending
          ), a = r.__dataPending, r.__dataPending = null;
      }
  }
  const kE = (r, e, t) => {
    let i = 0, o = e.length - 1, a = -1;
    for (; i <= o; ) {
      const l = i + o >> 1, d = t.get(e[l].methodInfo) - t.get(r.methodInfo);
      if (d < 0)
        i = l + 1;
      else if (d > 0)
        o = l - 1;
      else {
        a = l;
        break;
      }
    }
    a < 0 && (a = o + 1), e.splice(a, 0, r);
  }, Xp = (r, e, t, i, o) => {
    const a = o ? Ti(r) : r, l = e[a];
    if (l)
      for (let d = 0; d < l.length; d++) {
        const u = l[d];
        u.info.lastRun !== Fn && (!o || su(r, u.trigger)) && (u.info.lastRun = Fn, kE(u.info, t, i));
      }
  };
  function xE(r) {
    let e = r.constructor.__orderedComputedDeps;
    if (!e) {
      e = /* @__PURE__ */ new Map();
      const t = r[ne.COMPUTE];
      let { counts: i, ready: o, total: a } = CE(r), l;
      for (; l = o.shift(); ) {
        e.set(l, e.size);
        const d = t[l];
        d && d.forEach((u) => {
          const f = u.info.methodInfo;
          --a, --i[f] === 0 && o.push(f);
        });
      }
      if (a !== 0) {
        const d = (
          /** @type {HTMLElement} */
          r
        );
      }
      r.constructor.__orderedComputedDeps = e;
    }
    return e;
  }
  function CE(r) {
    const e = r[mb], t = {}, i = r[ne.COMPUTE], o = [];
    let a = 0;
    for (let l in e) {
      const d = e[l];
      a += t[l] = d.args.filter((u) => !u.literal).length + (d.dynamicFn ? 1 : 0);
    }
    for (let l in i)
      e[l] || o.push(l);
    return { counts: t, ready: o, total: a };
  }
  function _b(r, e, t, i, o) {
    let a = ud(r, e, t, i, o);
    if (a === zn)
      return !1;
    let l = o.methodInfo;
    return r.__dataHasAccessor && r.__dataHasAccessor[l] ? r._setPendingProperty(l, a, !0) : (r[l] = a, !1);
  }
  function SE(r, e, t) {
    let i = r.__dataLinkedPaths;
    if (i) {
      let o;
      for (let a in i) {
        let l = i[a];
        Ln(a, e) ? (o = Rn(a, l, e), r._setPendingPropertyOrPath(o, t, !0, !0)) : Ln(l, e) && (o = Rn(l, a, e), r._setPendingPropertyOrPath(o, t, !0, !0));
      }
    }
  }
  function $c(r, e, t, i, o, a, l) {
    t.bindings = t.bindings || [];
    let d = { kind: i, target: o, parts: a, literal: l, isCompound: a.length !== 1 };
    if (t.bindings.push(d), OE(d)) {
      let { event: f, negate: g } = d.parts[0];
      d.listenerEvent = f || Fa(o) + "-changed", d.listenerNegate = g;
    }
    let u = e.nodeInfoList.length;
    for (let f = 0; f < d.parts.length; f++) {
      let g = d.parts[f];
      g.compoundIndex = f, AE(r, e, d, g, u);
    }
  }
  function AE(r, e, t, i, o) {
    if (!i.literal && !(t.kind === "attribute" && t.target[0] === "-")) {
      let a = i.dependencies, l = { index: o, binding: t, part: i, evaluator: r };
      for (let d = 0; d < a.length; d++) {
        let u = a[d];
        typeof u == "string" && (u = yb(u), u.wildcard = !0), r._addTemplatePropertyEffect(e, u.rootProperty, {
          fn: EE,
          info: l,
          trigger: u
        });
      }
    }
  }
  function EE(r, e, t, i, o, a, l) {
    let d = l[o.index], u = o.binding, f = o.part;
    if (a && f.source && e.length > f.source.length && u.kind == "property" && !u.isCompound && d.__isPropertyEffectsClient && d.__dataHasAccessor && d.__dataHasAccessor[u.target]) {
      let g = t[e];
      e = Rn(f.source, u.target, e), d._setPendingPropertyOrPath(e, g, !1, !0) && r._enqueueClient(d);
    } else {
      let g = o.evaluator._evaluateBinding(r, f, e, t, i, a);
      g !== zn && $E(r, d, u, f, g);
    }
  }
  function $E(r, e, t, i, o) {
    if (o = TE(e, o, t, i), wa && (o = wa(o, t.target, t.kind, e)), t.kind == "attribute")
      r._valueToNodeAttribute(
        /** @type {Element} */
        e,
        o,
        t.target
      );
    else {
      let a = t.target;
      e.__isPropertyEffectsClient && e.__dataHasAccessor && e.__dataHasAccessor[a] ? (!e[ne.READ_ONLY] || !e[ne.READ_ONLY][a]) && e._setPendingProperty(a, o) && r._enqueueClient(e) : r._setUnmanagedPropertyToNode(e, a, o);
    }
  }
  function TE(r, e, t, i) {
    if (t.isCompound) {
      let o = r.__dataCompoundStorage[t.target];
      o[i.compoundIndex] = e, e = o.join("");
    }
    return t.kind !== "attribute" && (t.target === "textContent" || t.target === "value" && (r.localName === "input" || r.localName === "textarea")) && (e = e ?? ""), e;
  }
  function OE(r) {
    return !!r.target && r.kind != "attribute" && r.kind != "text" && !r.isCompound && r.parts[0].mode === "{";
  }
  function DE(r, e) {
    let { nodeList: t, nodeInfoList: i } = e;
    if (i.length)
      for (let o = 0; o < i.length; o++) {
        let a = i[o], l = t[o], d = a.bindings;
        if (d)
          for (let u = 0; u < d.length; u++) {
            let f = d[u];
            PE(l, f), IE(l, r, f);
          }
        l.__dataHost = r;
      }
  }
  function PE(r, e) {
    if (e.isCompound) {
      let t = r.__dataCompoundStorage || (r.__dataCompoundStorage = {}), i = e.parts, o = new Array(i.length);
      for (let l = 0; l < i.length; l++)
        o[l] = i[l].literal;
      let a = e.target;
      t[a] = o, e.literal && e.kind == "property" && (a === "className" && (r = ye(r)), r[a] = e.literal);
    }
  }
  function IE(r, e, t) {
    if (t.listenerEvent) {
      let i = t.parts[0];
      r.addEventListener(t.listenerEvent, function(o) {
        vE(o, e, t.target, i.source, i.negate);
      });
    }
  }
  function Qp(r, e, t, i, o, a) {
    a = e.static || a && (typeof a != "object" || a[e.methodName]);
    let l = {
      methodName: e.methodName,
      args: e.args,
      methodInfo: o,
      dynamicFn: a
    };
    for (let d = 0, u; d < e.args.length && (u = e.args[d]); d++)
      u.literal || r._addPropertyEffect(u.rootProperty, t, {
        fn: i,
        info: l,
        trigger: u
      });
    return a && r._addPropertyEffect(e.methodName, t, {
      fn: i,
      info: l
    }), l;
  }
  function ud(r, e, t, i, o) {
    let a = r._methodHost || r, l = a[o.methodName];
    if (l) {
      let d = r._marshalArgs(o.args, e, t);
      return d === zn ? zn : l.apply(a, d);
    } else o.dynamicFn;
  }
  const ME = [], vb = "(?:[a-zA-Z_$][\\w.:$\\-*]*)", NE = "(?:[-+]?[0-9]*\\.?[0-9]+(?:[eE][-+]?[0-9]+)?)", LE = "(?:'(?:[^'\\\\]|\\\\.)*')", RE = '(?:"(?:[^"\\\\]|\\\\.)*")', FE = "(?:" + LE + "|" + RE + ")", eg = "(?:(" + vb + "|" + NE + "|" + FE + ")\\s*)", zE = "(?:" + eg + "(?:,\\s*" + eg + ")*)", HE = "(?:\\(\\s*(?:" + zE + "?)\\)\\s*)", UE = "(" + vb + "\\s*" + HE + "?)", WE = "(\\[\\[|{{)\\s*", BE = "(?:]]|}})", VE = "(?:(!)\\s*)?", qE = WE + VE + UE + BE, tg = new RegExp(qE, "g");
  function rg(r) {
    let e = "";
    for (let t = 0; t < r.length; t++) {
      let i = r[t].literal;
      e += i || "";
    }
    return e;
  }
  function Tc(r) {
    let e = r.match(/([^\s]+?)\(([\s\S]*)\)/);
    if (e) {
      let i = { methodName: e[1], static: !0, args: ME };
      if (e[2].trim()) {
        let o = e[2].replace(/\\,/g, "&comma;").split(",");
        return YE(o, i);
      } else
        return i;
    }
    return null;
  }
  function YE(r, e) {
    return e.args = r.map(function(t) {
      let i = yb(t);
      return i.literal || (e.static = !1), i;
    }, this), e;
  }
  function yb(r) {
    let e = r.trim().replace(/&comma;/g, ",").replace(/\\(.)/g, "$1"), t = {
      name: e,
      value: "",
      literal: !1
    }, i = e[0];
    switch (i === "-" && (i = e[1]), i >= "0" && i <= "9" && (i = "#"), i) {
      case "'":
      case '"':
        t.value = e.slice(1, -1), t.literal = !0;
        break;
      case "#":
        t.value = Number(e), t.literal = !0;
        break;
    }
    return t.literal || (t.rootProperty = Ti(e), t.structured = cd(e), t.structured && (t.wildcard = e.slice(-2) == ".*", t.wildcard && (t.name = e.slice(0, -2)))), t;
  }
  function ig(r, e, t) {
    let i = at(r, t);
    return i === void 0 && (i = e[t]), i;
  }
  function wb(r, e, t, i) {
    const o = { indexSplices: i };
    ld && !r._overrideLegacyUndefined && (e.splices = o), r.notifyPath(t + ".splices", o), r.notifyPath(t + ".length", e.length), ld && !r._overrideLegacyUndefined && (o.indexSplices = []);
  }
  function un(r, e, t, i, o, a) {
    wb(r, e, t, [{
      index: i,
      addedCount: o,
      removed: a,
      object: e,
      type: "splice"
    }]);
  }
  function GE(r) {
    return r[0].toUpperCase() + r.substring(1);
  }
  const au = Oe((r) => {
    const e = fE(iE(r));
    class t extends e {
      constructor() {
        super(), this.__isPropertyEffectsClient = !0, this.__dataClientsReady, this.__dataPendingClients, this.__dataToNotify, this.__dataLinkedPaths, this.__dataHasPaths, this.__dataCompoundStorage, this.__dataHost, this.__dataTemp, this.__dataClientsInitialized, this.__data, this.__dataPending, this.__dataOld, this.__computeEffects, this.__computeInfo, this.__reflectEffects, this.__notifyEffects, this.__propagateEffects, this.__observeEffects, this.__readOnly, this.__templateInfo, this._overrideLegacyUndefined;
      }
      get PROPERTY_EFFECT_TYPES() {
        return ne;
      }
      /**
       * @override
       * @return {void}
       */
      _initializeProperties() {
        super._initializeProperties(), this._registerHost(), this.__dataClientsReady = !1, this.__dataPendingClients = null, this.__dataToNotify = null, this.__dataLinkedPaths = null, this.__dataHasPaths = !1, this.__dataCompoundStorage = this.__dataCompoundStorage || null, this.__dataHost = this.__dataHost || null, this.__dataTemp = {}, this.__dataClientsInitialized = !1;
      }
      _registerHost() {
        if (hn.length) {
          let o = hn[hn.length - 1];
          o._enqueueClient(this), this.__dataHost = o;
        }
      }
      /**
       * Overrides `PropertyAccessors` implementation to provide a
       * more efficient implementation of initializing properties from
       * the prototype on the instance.
       *
       * @override
       * @param {Object} props Properties to initialize on the prototype
       * @return {void}
       */
      _initializeProtoProperties(o) {
        this.__data = Object.create(o), this.__dataPending = Object.create(o), this.__dataOld = {};
      }
      /**
       * Overrides `PropertyAccessors` implementation to avoid setting
       * `_setProperty`'s `shouldNotify: true`.
       *
       * @override
       * @param {Object} props Properties to initialize on the instance
       * @return {void}
       */
      _initializeInstanceProperties(o) {
        let a = this[ne.READ_ONLY];
        for (let l in o)
          (!a || !a[l]) && (this.__dataPending = this.__dataPending || {}, this.__dataOld = this.__dataOld || {}, this.__data[l] = this.__dataPending[l] = o[l]);
      }
      // Prototype setup ----------------------------------------
      /**
       * Equivalent to static `addPropertyEffect` API but can be called on
       * an instance to add effects at runtime.  See that method for
       * full API docs.
       *
       * @override
       * @param {string} property Property that should trigger the effect
       * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
       * @param {Object=} effect Effect metadata object
       * @return {void}
       * @protected
       */
      _addPropertyEffect(o, a, l) {
        this._createPropertyAccessor(o, a == ne.READ_ONLY);
        let d = Ec(this, a, !0)[o];
        d || (d = this[a][o] = []), d.push(l);
      }
      /**
       * Removes the given property effect.
       *
       * @override
       * @param {string} property Property the effect was associated with
       * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
       * @param {Object=} effect Effect metadata object to remove
       * @return {void}
       */
      _removePropertyEffect(o, a, l) {
        let d = Ec(this, a, !0)[o], u = d.indexOf(l);
        u >= 0 && d.splice(u, 1);
      }
      /**
       * Returns whether the current prototype/instance has a property effect
       * of a certain type.
       *
       * @override
       * @param {string} property Property name
       * @param {string=} type Effect type, from this.PROPERTY_EFFECT_TYPES
       * @return {boolean} True if the prototype/instance has an effect of this
       *     type
       * @protected
       */
      _hasPropertyEffect(o, a) {
        let l = this[a];
        return !!(l && l[o]);
      }
      /**
       * Returns whether the current prototype/instance has a "read only"
       * accessor for the given property.
       *
       * @override
       * @param {string} property Property name
       * @return {boolean} True if the prototype/instance has an effect of this
       *     type
       * @protected
       */
      _hasReadOnlyEffect(o) {
        return this._hasPropertyEffect(o, ne.READ_ONLY);
      }
      /**
       * Returns whether the current prototype/instance has a "notify"
       * property effect for the given property.
       *
       * @override
       * @param {string} property Property name
       * @return {boolean} True if the prototype/instance has an effect of this
       *     type
       * @protected
       */
      _hasNotifyEffect(o) {
        return this._hasPropertyEffect(o, ne.NOTIFY);
      }
      /**
       * Returns whether the current prototype/instance has a "reflect to
       * attribute" property effect for the given property.
       *
       * @override
       * @param {string} property Property name
       * @return {boolean} True if the prototype/instance has an effect of this
       *     type
       * @protected
       */
      _hasReflectEffect(o) {
        return this._hasPropertyEffect(o, ne.REFLECT);
      }
      /**
       * Returns whether the current prototype/instance has a "computed"
       * property effect for the given property.
       *
       * @override
       * @param {string} property Property name
       * @return {boolean} True if the prototype/instance has an effect of this
       *     type
       * @protected
       */
      _hasComputedEffect(o) {
        return this._hasPropertyEffect(o, ne.COMPUTE);
      }
      // Runtime ----------------------------------------
      /**
       * Sets a pending property or path.  If the root property of the path in
       * question had no accessor, the path is set, otherwise it is enqueued
       * via `_setPendingProperty`.
       *
       * This function isolates relatively expensive functionality necessary
       * for the public API (`set`, `setProperties`, `notifyPath`, and property
       * change listeners via {{...}} bindings), such that it is only done
       * when paths enter the system, and not at every propagation step.  It
       * also sets a `__dataHasPaths` flag on the instance which is used to
       * fast-path slower path-matching code in the property effects host paths.
       *
       * `path` can be a path string or array of path parts as accepted by the
       * public API.
       *
       * @override
       * @param {string | !Array<number|string>} path Path to set
       * @param {*} value Value to set
       * @param {boolean=} shouldNotify Set to true if this change should
       *  cause a property notification event dispatch
       * @param {boolean=} isPathNotification If the path being set is a path
       *   notification of an already changed value, as opposed to a request
       *   to set and notify the change.  In the latter `false` case, a dirty
       *   check is performed and then the value is set to the path before
       *   enqueuing the pending property change.
       * @return {boolean} Returns true if the property/path was enqueued in
       *   the pending changes bag.
       * @protected
       */
      _setPendingPropertyOrPath(o, a, l, d) {
        if (d || Ti(Array.isArray(o) ? o[0] : o) !== o) {
          if (!d) {
            let u = at(this, o);
            if (o = /** @type {string} */
            jp(this, o, a), !o || !super._shouldPropertyChange(o, a, u))
              return !1;
          }
          if (this.__dataHasPaths = !0, this._setPendingProperty(
            /**@type{string}*/
            o,
            a,
            l
          ))
            return SE(
              this,
              /**@type{string}*/
              o,
              a
            ), !0;
        } else {
          if (this.__dataHasAccessor && this.__dataHasAccessor[o])
            return this._setPendingProperty(
              /**@type{string}*/
              o,
              a,
              l
            );
          this[o] = a;
        }
        return !1;
      }
      /**
       * Applies a value to a non-Polymer element/node's property.
       *
       * The implementation makes a best-effort at binding interop:
       * Some native element properties have side-effects when
       * re-setting the same value (e.g. setting `<input>.value` resets the
       * cursor position), so we do a dirty-check before setting the value.
       * However, for better interop with non-Polymer custom elements that
       * accept objects, we explicitly re-set object changes coming from the
       * Polymer world (which may include deep object changes without the
       * top reference changing), erring on the side of providing more
       * information.
       *
       * Users may override this method to provide alternate approaches.
       *
       * @override
       * @param {!Node} node The node to set a property on
       * @param {string} prop The property to set
       * @param {*} value The value to set
       * @return {void}
       * @protected
       */
      _setUnmanagedPropertyToNode(o, a, l) {
        (l !== o[a] || typeof l == "object") && (a === "className" && (o = /** @type {!Node} */
        ye(o)), o[a] = l);
      }
      /**
       * Overrides the `PropertiesChanged` implementation to introduce special
       * dirty check logic depending on the property & value being set:
       *
       * 1. Any value set to a path (e.g. 'obj.prop': 42 or 'obj.prop': {...})
       *    Stored in `__dataTemp`, dirty checked against `__dataTemp`
       * 2. Object set to simple property (e.g. 'prop': {...})
       *    Stored in `__dataTemp` and `__data`, dirty checked against
       *    `__dataTemp` by default implementation of `_shouldPropertyChange`
       * 3. Primitive value set to simple property (e.g. 'prop': 42)
       *    Stored in `__data`, dirty checked against `__data`
       *
       * The dirty-check is important to prevent cycles due to two-way
       * notification, but paths and objects are only dirty checked against any
       * previous value set during this turn via a "temporary cache" that is
       * cleared when the last `_propertiesChanged` exits. This is so:
       * a. any cached array paths (e.g. 'array.3.prop') may be invalidated
       *    due to array mutations like shift/unshift/splice; this is fine
       *    since path changes are dirty-checked at user entry points like `set`
       * b. dirty-checking for objects only lasts one turn to allow the user
       *    to mutate the object in-place and re-set it with the same identity
       *    and have all sub-properties re-propagated in a subsequent turn.
       *
       * The temp cache is not necessarily sufficient to prevent invalid array
       * paths, since a splice can happen during the same turn (with pathological
       * user code); we could introduce a "fixup" for temporarily cached array
       * paths if needed: https://github.com/Polymer/polymer/issues/4227
       *
       * @override
       * @param {string} property Name of the property
       * @param {*} value Value to set
       * @param {boolean=} shouldNotify True if property should fire notification
       *   event (applies only for `notify: true` properties)
       * @return {boolean} Returns true if the property changed
       */
      _setPendingProperty(o, a, l) {
        let d = this.__dataHasPaths && cd(o), u = d ? this.__dataTemp : this.__data;
        return this._shouldPropertyChange(o, a, u[o]) ? (this.__dataPending || (this.__dataPending = {}, this.__dataOld = {}), o in this.__dataOld || (this.__dataOld[o] = this.__data[o]), d ? this.__dataTemp[o] = a : this.__data[o] = a, this.__dataPending[o] = a, (d || this[ne.NOTIFY] && this[ne.NOTIFY][o]) && (this.__dataToNotify = this.__dataToNotify || {}, this.__dataToNotify[o] = l), !0) : !1;
      }
      /**
       * Overrides base implementation to ensure all accessors set `shouldNotify`
       * to true, for per-property notification tracking.
       *
       * @override
       * @param {string} property Name of the property
       * @param {*} value Value to set
       * @return {void}
       */
      _setProperty(o, a) {
        this._setPendingProperty(o, a, !0) && this._invalidateProperties();
      }
      /**
       * Overrides `PropertyAccessor`'s default async queuing of
       * `_propertiesChanged`: if `__dataReady` is false (has not yet been
       * manually flushed), the function no-ops; otherwise flushes
       * `_propertiesChanged` synchronously.
       *
       * @override
       * @return {void}
       */
      _invalidateProperties() {
        this.__dataReady && this._flushProperties();
      }
      /**
       * Enqueues the given client on a list of pending clients, whose
       * pending property changes can later be flushed via a call to
       * `_flushClients`.
       *
       * @override
       * @param {Object} client PropertyEffects client to enqueue
       * @return {void}
       * @protected
       */
      _enqueueClient(o) {
        this.__dataPendingClients = this.__dataPendingClients || [], o !== this && this.__dataPendingClients.push(o);
      }
      /**
       * Flushes any clients previously enqueued via `_enqueueClient`, causing
       * their `_flushProperties` method to run.
       *
       * @override
       * @return {void}
       * @protected
       */
      _flushClients() {
        this.__dataClientsReady ? this.__enableOrFlushClients() : (this.__dataClientsReady = !0, this._readyClients(), this.__dataReady = !0);
      }
      // NOTE: We ensure clients either enable or flush as appropriate. This
      // handles two corner cases:
      // (1) clients flush properly when connected/enabled before the host
      // enables; e.g.
      //   (a) Templatize stamps with no properties and does not flush and
      //   (b) the instance is inserted into dom and
      //   (c) then the instance flushes.
      // (2) clients enable properly when not connected/enabled when the host
      // flushes; e.g.
      //   (a) a template is runtime stamped and not yet connected/enabled
      //   (b) a host sets a property, causing stamped dom to flush
      //   (c) the stamped dom enables.
      __enableOrFlushClients() {
        let o = this.__dataPendingClients;
        if (o) {
          this.__dataPendingClients = null;
          for (let a = 0; a < o.length; a++) {
            let l = o[a];
            l.__dataEnabled ? l.__dataPending && l._flushProperties() : l._enableProperties();
          }
        }
      }
      /**
       * Perform any initial setup on client dom. Called before the first
       * `_flushProperties` call on client dom and before any element
       * observers are called.
       *
       * @override
       * @return {void}
       * @protected
       */
      _readyClients() {
        this.__enableOrFlushClients();
      }
      /**
       * Sets a bag of property changes to this instance, and
       * synchronously processes all effects of the properties as a batch.
       *
       * Property names must be simple properties, not paths.  Batched
       * path propagation is not supported.
       *
       * @override
       * @param {Object} props Bag of one or more key-value pairs whose key is
       *   a property and value is the new value to set for that property.
       * @param {boolean=} setReadOnly When true, any private values set in
       *   `props` will be set. By default, `setProperties` will not set
       *   `readOnly: true` root properties.
       * @return {void}
       * @public
       */
      setProperties(o, a) {
        for (let l in o)
          (a || !this[ne.READ_ONLY] || !this[ne.READ_ONLY][l]) && this._setPendingPropertyOrPath(l, o[l], !0);
        this._invalidateProperties();
      }
      /**
       * Overrides `PropertyAccessors` so that property accessor
       * side effects are not enabled until after client dom is fully ready.
       * Also calls `_flushClients` callback to ensure client dom is enabled
       * that was not enabled as a result of flushing properties.
       *
       * @override
       * @return {void}
       */
      ready() {
        this._flushProperties(), this.__dataClientsReady || this._flushClients(), this.__dataPending && this._flushProperties();
      }
      /**
       * Implements `PropertyAccessors`'s properties changed callback.
       *
       * Runs each class of effects for the batch of changed properties in
       * a specific order (compute, propagate, reflect, observe, notify).
       *
       * @override
       * @param {!Object} currentProps Bag of all current accessor values
       * @param {?Object} changedProps Bag of properties changed since the last
       *   call to `_propertiesChanged`
       * @param {?Object} oldProps Bag of previous values for each property
       *   in `changedProps`
       * @return {void}
       */
      _propertiesChanged(o, a, l) {
        let d = this.__dataHasPaths;
        this.__dataHasPaths = !1;
        let u;
        wE(this, a, l, d), u = this.__dataToNotify, this.__dataToNotify = null, this._propagatePropertyChanges(a, l, d), this._flushClients(), yn(this, this[ne.REFLECT], a, l, d), yn(this, this[ne.OBSERVE], a, l, d), u && mE(this, u, a, l, d), this.__dataCounter == 1 && (this.__dataTemp = {});
      }
      /**
       * Called to propagate any property changes to stamped template nodes
       * managed by this element.
       *
       * @override
       * @param {Object} changedProps Bag of changed properties
       * @param {Object} oldProps Bag of previous values for changed properties
       * @param {boolean} hasPaths True with `props` contains one or more paths
       * @return {void}
       * @protected
       */
      _propagatePropertyChanges(o, a, l) {
        this[ne.PROPAGATE] && yn(this, this[ne.PROPAGATE], o, a, l), this.__templateInfo && this._runEffectsForTemplate(this.__templateInfo, o, a, l);
      }
      _runEffectsForTemplate(o, a, l, d) {
        const u = (f, g) => {
          yn(
            this,
            o.propertyEffects,
            f,
            l,
            g,
            o.nodeList
          );
          for (let _ = o.firstChild; _; _ = _.nextSibling)
            this._runEffectsForTemplate(_, f, l, g);
        };
        o.runEffects ? o.runEffects(u, a, d) : u(a, d);
      }
      /**
       * Aliases one data path as another, such that path notifications from one
       * are routed to the other.
       *
       * @override
       * @param {string | !Array<string|number>} to Target path to link.
       * @param {string | !Array<string|number>} from Source path to link.
       * @return {void}
       * @public
       */
      linkPaths(o, a) {
        o = vn(o), a = vn(a), this.__dataLinkedPaths = this.__dataLinkedPaths || {}, this.__dataLinkedPaths[o] = a;
      }
      /**
       * Removes a data path alias previously established with `_linkPaths`.
       *
       * Note, the path to unlink should be the target (`to`) used when
       * linking the paths.
       *
       * @override
       * @param {string | !Array<string|number>} path Target path to unlink.
       * @return {void}
       * @public
       */
      unlinkPaths(o) {
        o = vn(o), this.__dataLinkedPaths && delete this.__dataLinkedPaths[o];
      }
      /**
       * Notify that an array has changed.
       *
       * Example:
       *
       *     this.items = [ {name: 'Jim'}, {name: 'Todd'}, {name: 'Bill'} ];
       *     ...
       *     this.items.splice(1, 1, {name: 'Sam'});
       *     this.items.push({name: 'Bob'});
       *     this.notifySplices('items', [
       *       { index: 1, removed: [{name: 'Todd'}], addedCount: 1,
       *         object: this.items, type: 'splice' },
       *       { index: 3, removed: [], addedCount: 1,
       *         object: this.items, type: 'splice'}
       *     ]);
       *
       * @param {string} path Path that should be notified.
       * @param {Array} splices Array of splice records indicating ordered
       *   changes that occurred to the array. Each record should have the
       *   following fields:
       *    * index: index at which the change occurred
       *    * removed: array of items that were removed from this index
       *    * addedCount: number of new items added at this index
       *    * object: a reference to the array in question
       *    * type: the string literal 'splice'
       *
       *   Note that splice records _must_ be normalized such that they are
       *   reported in index order (raw results from `Object.observe` are not
       *   ordered and must be normalized/merged before notifying).
       *
       * @override
       * @return {void}
       * @public
       */
      notifySplices(o, a) {
        let l = { path: "" }, d = (
          /** @type {Array} */
          at(this, o, l)
        );
        wb(this, d, l.path, a);
      }
      /**
       * Convenience method for reading a value from a path.
       *
       * Note, if any part in the path is undefined, this method returns
       * `undefined` (this method does not throw when dereferencing undefined
       * paths).
       *
       * @override
       * @param {(string|!Array<(string|number)>)} path Path to the value
       *   to read.  The path may be specified as a string (e.g. `foo.bar.baz`)
       *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that
       *   bracketed expressions are not supported; string-based path parts
       *   *must* be separated by dots.  Note that when dereferencing array
       *   indices, the index may be used as a dotted part directly
       *   (e.g. `users.12.name` or `['users', 12, 'name']`).
       * @param {Object=} root Root object from which the path is evaluated.
       * @return {*} Value at the path, or `undefined` if any part of the path
       *   is undefined.
       * @public
       */
      get(o, a) {
        return at(a || this, o);
      }
      /**
       * Convenience method for setting a value to a path and notifying any
       * elements bound to the same path.
       *
       * Note, if any part in the path except for the last is undefined,
       * this method does nothing (this method does not throw when
       * dereferencing undefined paths).
       *
       * @override
       * @param {(string|!Array<(string|number)>)} path Path to the value
       *   to write.  The path may be specified as a string (e.g. `'foo.bar.baz'`)
       *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that
       *   bracketed expressions are not supported; string-based path parts
       *   *must* be separated by dots.  Note that when dereferencing array
       *   indices, the index may be used as a dotted part directly
       *   (e.g. `'users.12.name'` or `['users', 12, 'name']`).
       * @param {*} value Value to set at the specified path.
       * @param {Object=} root Root object from which the path is evaluated.
       *   When specified, no notification will occur.
       * @return {void}
       * @public
       */
      set(o, a, l) {
        l ? jp(l, o, a) : (!this[ne.READ_ONLY] || !this[ne.READ_ONLY][
          /** @type {string} */
          o
        ]) && this._setPendingPropertyOrPath(o, a, !0) && this._invalidateProperties();
      }
      /**
       * Adds items onto the end of the array at the path specified.
       *
       * The arguments after `path` and return value match that of
       * `Array.prototype.push`.
       *
       * This method notifies other paths to the same array that a
       * splice occurred to the array.
       *
       * @override
       * @param {string | !Array<string|number>} path Path to array.
       * @param {...*} items Items to push onto array
       * @return {number} New length of the array.
       * @public
       */
      push(o, ...a) {
        let l = { path: "" }, d = (
          /** @type {Array}*/
          at(this, o, l)
        ), u = d.length, f = d.push(...a);
        return a.length && un(this, d, l.path, u, a.length, []), f;
      }
      /**
       * Removes an item from the end of array at the path specified.
       *
       * The arguments after `path` and return value match that of
       * `Array.prototype.pop`.
       *
       * This method notifies other paths to the same array that a
       * splice occurred to the array.
       *
       * @override
       * @param {string | !Array<string|number>} path Path to array.
       * @return {*} Item that was removed.
       * @public
       */
      pop(o) {
        let a = { path: "" }, l = (
          /** @type {Array} */
          at(this, o, a)
        ), d = !!l.length, u = l.pop();
        return d && un(this, l, a.path, l.length, 0, [u]), u;
      }
      /**
       * Starting from the start index specified, removes 0 or more items
       * from the array and inserts 0 or more new items in their place.
       *
       * The arguments after `path` and return value match that of
       * `Array.prototype.splice`.
       *
       * This method notifies other paths to the same array that a
       * splice occurred to the array.
       *
       * @override
       * @param {string | !Array<string|number>} path Path to array.
       * @param {number} start Index from which to start removing/inserting.
       * @param {number=} deleteCount Number of items to remove.
       * @param {...*} items Items to insert into array.
       * @return {!Array} Array of removed items.
       * @public
       */
      splice(o, a, l, ...d) {
        let u = { path: "" }, f = (
          /** @type {Array} */
          at(this, o, u)
        );
        a < 0 ? a = f.length - Math.floor(-a) : a && (a = Math.floor(a));
        let g;
        return arguments.length === 2 ? g = f.splice(a) : g = f.splice(a, l, ...d), (d.length || g.length) && un(this, f, u.path, a, d.length, g), g;
      }
      /**
       * Removes an item from the beginning of array at the path specified.
       *
       * The arguments after `path` and return value match that of
       * `Array.prototype.pop`.
       *
       * This method notifies other paths to the same array that a
       * splice occurred to the array.
       *
       * @override
       * @param {string | !Array<string|number>} path Path to array.
       * @return {*} Item that was removed.
       * @public
       */
      shift(o) {
        let a = { path: "" }, l = (
          /** @type {Array} */
          at(this, o, a)
        ), d = !!l.length, u = l.shift();
        return d && un(this, l, a.path, 0, 0, [u]), u;
      }
      /**
       * Adds items onto the beginning of the array at the path specified.
       *
       * The arguments after `path` and return value match that of
       * `Array.prototype.push`.
       *
       * This method notifies other paths to the same array that a
       * splice occurred to the array.
       *
       * @override
       * @param {string | !Array<string|number>} path Path to array.
       * @param {...*} items Items to insert info array
       * @return {number} New length of the array.
       * @public
       */
      unshift(o, ...a) {
        let l = { path: "" }, d = (
          /** @type {Array} */
          at(this, o, l)
        ), u = d.unshift(...a);
        return a.length && un(this, d, l.path, 0, a.length, []), u;
      }
      /**
       * Notify that a path has changed.
       *
       * Example:
       *
       *     this.item.user.name = 'Bob';
       *     this.notifyPath('item.user.name');
       *
       * @override
       * @param {string} path Path that should be notified.
       * @param {*=} value Value at the path (optional).
       * @return {void}
       * @public
       */
      notifyPath(o, a) {
        let l;
        if (arguments.length == 1) {
          let d = { path: "" };
          a = at(this, o, d), l = d.path;
        } else Array.isArray(o) ? l = vn(o) : l = /** @type{string} */
        o;
        this._setPendingPropertyOrPath(l, a, !0, !0) && this._invalidateProperties();
      }
      /**
       * Equivalent to static `createReadOnlyProperty` API but can be called on
       * an instance to add effects at runtime.  See that method for
       * full API docs.
       *
       * @override
       * @param {string} property Property name
       * @param {boolean=} protectedSetter Creates a custom protected setter
       *   when `true`.
       * @return {void}
       * @protected
       */
      _createReadOnlyProperty(o, a) {
        this._addPropertyEffect(o, ne.READ_ONLY), a && (this["_set" + GE(o)] = /** @this {PropertyEffects} */
        function(l) {
          this._setProperty(o, l);
        });
      }
      /**
       * Equivalent to static `createPropertyObserver` API but can be called on
       * an instance to add effects at runtime.  See that method for
       * full API docs.
       *
       * @override
       * @param {string} property Property name
       * @param {string|function(*,*)} method Function or name of observer method
       *     to call
       * @param {boolean=} dynamicFn Whether the method name should be included as
       *   a dependency to the effect.
       * @return {void}
       * @protected
       */
      _createPropertyObserver(o, a, l) {
        let d = { property: o, method: a, dynamicFn: !!l };
        this._addPropertyEffect(o, ne.OBSERVE, {
          fn: Jp,
          info: d,
          trigger: { name: o }
        }), l && this._addPropertyEffect(
          /** @type {string} */
          a,
          ne.OBSERVE,
          {
            fn: Jp,
            info: d,
            trigger: { name: a }
          }
        );
      }
      /**
       * Equivalent to static `createMethodObserver` API but can be called on
       * an instance to add effects at runtime.  See that method for
       * full API docs.
       *
       * @override
       * @param {string} expression Method expression
       * @param {boolean|Object=} dynamicFn Boolean or object map indicating
       *   whether method names should be included as a dependency to the effect.
       * @return {void}
       * @protected
       */
      _createMethodObserver(o, a) {
        let l = Tc(o);
        if (!l)
          throw new Error("Malformed observer expression '" + o + "'");
        Qp(this, l, ne.OBSERVE, ud, null, a);
      }
      /**
       * Equivalent to static `createNotifyingProperty` API but can be called on
       * an instance to add effects at runtime.  See that method for
       * full API docs.
       *
       * @override
       * @param {string} property Property name
       * @return {void}
       * @protected
       */
      _createNotifyingProperty(o) {
        this._addPropertyEffect(o, ne.NOTIFY, {
          fn: _E,
          info: {
            eventName: Fa(o) + "-changed",
            property: o
          }
        });
      }
      /**
       * Equivalent to static `createReflectedProperty` API but can be called on
       * an instance to add effects at runtime.  See that method for
       * full API docs.
       *
       * @override
       * @param {string} property Property name
       * @return {void}
       * @protected
       * @suppress {missingProperties} go/missingfnprops
       */
      _createReflectedProperty(o) {
        let a = this.constructor.attributeNameForProperty(o);
        a[0] === "-" || this._addPropertyEffect(o, ne.REFLECT, {
          fn: yE,
          info: {
            attrName: a
          }
        });
      }
      /**
       * Equivalent to static `createComputedProperty` API but can be called on
       * an instance to add effects at runtime.  See that method for
       * full API docs.
       *
       * @override
       * @param {string} property Name of computed property to set
       * @param {string} expression Method expression
       * @param {boolean|Object=} dynamicFn Boolean or object map indicating
       *   whether method names should be included as a dependency to the effect.
       * @return {void}
       * @protected
       */
      _createComputedProperty(o, a, l) {
        let d = Tc(a);
        if (!d)
          throw new Error("Malformed computed expression '" + a + "'");
        const u = Qp(this, d, ne.COMPUTE, _b, o, l);
        Ec(this, mb)[o] = u;
      }
      /**
       * Gather the argument values for a method specified in the provided array
       * of argument metadata.
       *
       * The `path` and `value` arguments are used to fill in wildcard descriptor
       * when the method is being called as a result of a path notification.
       *
       * @param {!Array<!MethodArg>} args Array of argument metadata
       * @param {string} path Property/path name that triggered the method effect
       * @param {Object} props Bag of current property changes
       * @return {!Array<*>} Array of argument values
       * @private
       */
      _marshalArgs(o, a, l) {
        const d = this.__data, u = [];
        for (let f = 0, g = o.length; f < g; f++) {
          let { name: _, structured: C, wildcard: x, value: D, literal: P } = o[f];
          if (!P)
            if (x) {
              const I = Ln(_, a), F = ig(d, l, I ? a : _);
              D = {
                path: I ? a : _,
                value: F,
                base: I ? at(d, _) : F
              };
            } else
              D = C ? ig(d, l, _) : d[_];
          if (ld && !this._overrideLegacyUndefined && D === void 0 && o.length > 1)
            return zn;
          u[f] = D;
        }
        return u;
      }
      // -- static class methods ------------
      /**
       * Ensures an accessor exists for the specified property, and adds
       * to a list of "property effects" that will run when the accessor for
       * the specified property is set.  Effects are grouped by "type", which
       * roughly corresponds to a phase in effect processing.  The effect
       * metadata should be in the following form:
       *
       *     {
       *       fn: effectFunction, // Reference to function to call to perform effect
       *       info: { ... }       // Effect metadata passed to function
       *       trigger: {          // Optional triggering metadata; if not provided
       *         name: string      // the property is treated as a wildcard
       *         structured: boolean
       *         wildcard: boolean
       *       }
       *     }
       *
       * Effects are called from `_propertiesChanged` in the following order by
       * type:
       *
       * 1. COMPUTE
       * 2. PROPAGATE
       * 3. REFLECT
       * 4. OBSERVE
       * 5. NOTIFY
       *
       * Effect functions are called with the following signature:
       *
       *     effectFunction(inst, path, props, oldProps, info, hasPaths)
       *
       * @param {string} property Property that should trigger the effect
       * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
       * @param {Object=} effect Effect metadata object
       * @return {void}
       * @protected
       * @nocollapse
       */
      static addPropertyEffect(o, a, l) {
        this.prototype._addPropertyEffect(o, a, l);
      }
      /**
       * Creates a single-property observer for the given property.
       *
       * @param {string} property Property name
       * @param {string|function(*,*)} method Function or name of observer method to call
       * @param {boolean=} dynamicFn Whether the method name should be included as
       *   a dependency to the effect.
       * @return {void}
       * @protected
       * @nocollapse
       */
      static createPropertyObserver(o, a, l) {
        this.prototype._createPropertyObserver(o, a, l);
      }
      /**
       * Creates a multi-property "method observer" based on the provided
       * expression, which should be a string in the form of a normal JavaScript
       * function signature: `'methodName(arg1, [..., argn])'`.  Each argument
       * should correspond to a property or path in the context of this
       * prototype (or instance), or may be a literal string or number.
       *
       * @param {string} expression Method expression
       * @param {boolean|Object=} dynamicFn Boolean or object map indicating
       * @return {void}
       *   whether method names should be included as a dependency to the effect.
       * @protected
       * @nocollapse
       */
      static createMethodObserver(o, a) {
        this.prototype._createMethodObserver(o, a);
      }
      /**
       * Causes the setter for the given property to dispatch `<property>-changed`
       * events to notify of changes to the property.
       *
       * @param {string} property Property name
       * @return {void}
       * @protected
       * @nocollapse
       */
      static createNotifyingProperty(o) {
        this.prototype._createNotifyingProperty(o);
      }
      /**
       * Creates a read-only accessor for the given property.
       *
       * To set the property, use the protected `_setProperty` API.
       * To create a custom protected setter (e.g. `_setMyProp()` for
       * property `myProp`), pass `true` for `protectedSetter`.
       *
       * Note, if the property will have other property effects, this method
       * should be called first, before adding other effects.
       *
       * @param {string} property Property name
       * @param {boolean=} protectedSetter Creates a custom protected setter
       *   when `true`.
       * @return {void}
       * @protected
       * @nocollapse
       */
      static createReadOnlyProperty(o, a) {
        this.prototype._createReadOnlyProperty(o, a);
      }
      /**
       * Causes the setter for the given property to reflect the property value
       * to a (dash-cased) attribute of the same name.
       *
       * @param {string} property Property name
       * @return {void}
       * @protected
       * @nocollapse
       */
      static createReflectedProperty(o) {
        this.prototype._createReflectedProperty(o);
      }
      /**
       * Creates a computed property whose value is set to the result of the
       * method described by the given `expression` each time one or more
       * arguments to the method changes.  The expression should be a string
       * in the form of a normal JavaScript function signature:
       * `'methodName(arg1, [..., argn])'`
       *
       * @param {string} property Name of computed property to set
       * @param {string} expression Method expression
       * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether
       *   method names should be included as a dependency to the effect.
       * @return {void}
       * @protected
       * @nocollapse
       */
      static createComputedProperty(o, a, l) {
        this.prototype._createComputedProperty(o, a, l);
      }
      /**
       * Parses the provided template to ensure binding effects are created
       * for them, and then ensures property accessors are created for any
       * dependent properties in the template.  Binding effects for bound
       * templates are stored in a linked list on the instance so that
       * templates can be efficiently stamped and unstamped.
       *
       * @param {!HTMLTemplateElement} template Template containing binding
       *   bindings
       * @return {!TemplateInfo} Template metadata object
       * @protected
       * @nocollapse
       */
      static bindTemplate(o) {
        return this.prototype._bindTemplate(o);
      }
      // -- binding ----------------------------------------------
      /*
       * Overview of binding flow:
       *
       * During finalization (`instanceBinding==false`, `wasPreBound==false`):
       *  `_bindTemplate(t, false)` called directly during finalization - parses
       *  the template (for the first time), and then assigns that _prototypical_
       *  template info to `__preboundTemplateInfo` _on the prototype_; note in
       *  this case `wasPreBound` is false; this is the first time we're binding
       *  it, thus we create accessors.
       *
       * During first stamping (`instanceBinding==true`, `wasPreBound==true`):
       *   `_stampTemplate` calls `_bindTemplate(t, true)`: the `templateInfo`
       *   returned matches the prebound one, and so this is `wasPreBound == true`
       *   state; thus we _skip_ creating accessors, but _do_ create an instance
       *   of the template info to serve as the start of our linked list (needs to
       *   be an instance, not the prototypical one, so that we can add `nodeList`
       *   to it to contain the `nodeInfo`-ordered list of instance nodes for
       *   bindings, and so we can chain runtime-stamped template infos off of
       *   it). At this point, the call to `_stampTemplate` calls
       *   `applyTemplateInfo` for each nested `<template>` found during parsing
       *   to hand prototypical `_templateInfo` to them; we also pass the _parent_
       *   `templateInfo` to the `<template>` so that we have the instance-time
       *   parent to link the `templateInfo` under in the case it was
       *   runtime-stamped.
       *
       * During subsequent runtime stamping (`instanceBinding==true`,
       *   `wasPreBound==false`): `_stampTemplate` calls `_bindTemplate(t, true)`
       *   - here `templateInfo` is guaranteed to _not_ match the prebound one,
       *   because it was either a different template altogether, or even if it
       *   was the same template, the step above created a instance of the info;
       *   in this case `wasPreBound == false`, so we _do_ create accessors, _and_
       *   link a instance into the linked list.
       */
      /**
       * Equivalent to static `bindTemplate` API but can be called on an instance
       * to add effects at runtime.  See that method for full API docs.
       *
       * This method may be called on the prototype (for prototypical template
       * binding, to avoid creating accessors every instance) once per prototype,
       * and will be called with `runtimeBinding: true` by `_stampTemplate` to
       * create and link an instance of the template metadata associated with a
       * particular stamping.
       *
       * @override
       * @param {!HTMLTemplateElement} template Template containing binding
       * bindings
       * @param {boolean=} instanceBinding When false (default), performs
       * "prototypical" binding of the template and overwrites any previously
       * bound template for the class. When true (as passed from
       * `_stampTemplate`), the template info is instanced and linked into the
       * list of bound templates.
       * @return {!TemplateInfo} Template metadata object; for `runtimeBinding`,
       * this is an instance of the prototypical template info
       * @protected
       * @suppress {missingProperties} go/missingfnprops
       */
      _bindTemplate(o, a) {
        let l = this.constructor._parseTemplate(o), d = this.__preBoundTemplateInfo == l;
        if (!d)
          for (let u in l.propertyEffects)
            this._createPropertyAccessor(u);
        if (a)
          if (l = /** @type {!TemplateInfo} */
          Object.create(l), l.wasPreBound = d, !this.__templateInfo)
            this.__templateInfo = l;
          else {
            const u = o._parentTemplateInfo || this.__templateInfo, f = u.lastChild;
            l.parent = u, u.lastChild = l, l.previousSibling = f, f ? f.nextSibling = l : u.firstChild = l;
          }
        else
          this.__preBoundTemplateInfo = l;
        return l;
      }
      /**
       * Adds a property effect to the given template metadata, which is run
       * at the "propagate" stage of `_propertiesChanged` when the template
       * has been bound to the element via `_bindTemplate`.
       *
       * The `effect` object should match the format in `_addPropertyEffect`.
       *
       * @param {Object} templateInfo Template metadata to add effect to
       * @param {string} prop Property that should trigger the effect
       * @param {Object=} effect Effect metadata object
       * @return {void}
       * @protected
       * @nocollapse
       */
      static _addTemplatePropertyEffect(o, a, l) {
        let d = o.hostProps = o.hostProps || {};
        d[a] = !0;
        let u = o.propertyEffects = o.propertyEffects || {};
        (u[a] = u[a] || []).push(l);
      }
      /**
       * Stamps the provided template and performs instance-time setup for
       * Polymer template features, including data bindings, declarative event
       * listeners, and the `this.$` map of `id`'s to nodes.  A document fragment
       * is returned containing the stamped DOM, ready for insertion into the
       * DOM.
       *
       * This method may be called more than once; however note that due to
       * `shadycss` polyfill limitations, only styles from templates prepared
       * using `ShadyCSS.prepareTemplate` will be correctly polyfilled (scoped
       * to the shadow root and support CSS custom properties), and note that
       * `ShadyCSS.prepareTemplate` may only be called once per element. As such,
       * any styles required by in runtime-stamped templates must be included
       * in the main element template.
       *
       * @param {!HTMLTemplateElement} template Template to stamp
       * @param {TemplateInfo=} templateInfo Optional bound template info associated
       *   with the template to be stamped; if omitted the template will be
       *   automatically bound.
       * @return {!StampedTemplate} Cloned template content
       * @override
       * @protected
       */
      _stampTemplate(o, a) {
        a = a || /** @type {!TemplateInfo} */
        this._bindTemplate(o, !0), hn.push(this);
        let l = super._stampTemplate(o, a);
        if (hn.pop(), a.nodeList = l.nodeList, !a.wasPreBound) {
          let d = a.childNodes = [];
          for (let u = l.firstChild; u; u = u.nextSibling)
            d.push(u);
        }
        return l.templateInfo = a, DE(this, a), this.__dataClientsReady && (this._runEffectsForTemplate(a, this.__data, null, !1), this._flushClients()), l;
      }
      /**
       * Removes and unbinds the nodes previously contained in the provided
       * DocumentFragment returned from `_stampTemplate`.
       *
       * @override
       * @param {!StampedTemplate} dom DocumentFragment previously returned
       *   from `_stampTemplate` associated with the nodes to be removed
       * @return {void}
       * @protected
       */
      _removeBoundDom(o) {
        const a = o.templateInfo, { previousSibling: l, nextSibling: d, parent: u } = a;
        l ? l.nextSibling = d : u && (u.firstChild = d), d ? d.previousSibling = l : u && (u.lastChild = l), a.nextSibling = a.previousSibling = null;
        let f = a.childNodes;
        for (let g = 0; g < f.length; g++) {
          let _ = f[g];
          ye(ye(_).parentNode).removeChild(_);
        }
      }
      /**
       * Overrides default `TemplateStamp` implementation to add support for
       * parsing bindings from `TextNode`'s' `textContent`.  A `bindings`
       * array is added to `nodeInfo` and populated with binding metadata
       * with information capturing the binding target, and a `parts` array
       * with one or more metadata objects capturing the source(s) of the
       * binding.
       *
       * @param {Node} node Node to parse
       * @param {TemplateInfo} templateInfo Template metadata for current template
       * @param {NodeInfo} nodeInfo Node metadata for current template node
       * @return {boolean} `true` if the visited node added node-specific
       *   metadata to `nodeInfo`
       * @protected
       * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
       * @nocollapse
       */
      static _parseTemplateNode(o, a, l) {
        let d = e._parseTemplateNode.call(
          this,
          o,
          a,
          l
        );
        if (o.nodeType === Node.TEXT_NODE) {
          let u = this._parseBindings(o.textContent, a);
          u && (o.textContent = rg(u) || " ", $c(this, a, l, "text", "textContent", u), d = !0);
        }
        return d;
      }
      /**
       * Overrides default `TemplateStamp` implementation to add support for
       * parsing bindings from attributes.  A `bindings`
       * array is added to `nodeInfo` and populated with binding metadata
       * with information capturing the binding target, and a `parts` array
       * with one or more metadata objects capturing the source(s) of the
       * binding.
       *
       * @param {Element} node Node to parse
       * @param {TemplateInfo} templateInfo Template metadata for current template
       * @param {NodeInfo} nodeInfo Node metadata for current template node
       * @param {string} name Attribute name
       * @param {string} value Attribute value
       * @return {boolean} `true` if the visited node added node-specific
       *   metadata to `nodeInfo`
       * @protected
       * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
       * @nocollapse
       */
      static _parseTemplateNodeAttribute(o, a, l, d, u) {
        let f = this._parseBindings(u, a);
        if (f) {
          let g = d, _ = "property";
          pE.test(d) ? _ = "attribute" : d[d.length - 1] == "$" && (d = d.slice(0, -1), _ = "attribute");
          let C = rg(f);
          return C && _ == "attribute" && (d == "class" && o.hasAttribute("class") && (C += " " + o.getAttribute(d)), o.setAttribute(d, C)), _ == "attribute" && g == "disable-upgrade$" && o.setAttribute(d, ""), o.localName === "input" && g === "value" && o.setAttribute(g, ""), o.removeAttribute(g), _ === "property" && (d = db(d)), $c(this, a, l, _, d, f, C), !0;
        } else
          return e._parseTemplateNodeAttribute.call(
            this,
            o,
            a,
            l,
            d,
            u
          );
      }
      /**
       * Overrides default `TemplateStamp` implementation to add support for
       * binding the properties that a nested template depends on to the template
       * as `_host_<property>`.
       *
       * @param {Node} node Node to parse
       * @param {TemplateInfo} templateInfo Template metadata for current template
       * @param {NodeInfo} nodeInfo Node metadata for current template node
       * @return {boolean} `true` if the visited node added node-specific
       *   metadata to `nodeInfo`
       * @protected
       * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
       * @nocollapse
       */
      static _parseTemplateNestedTemplate(o, a, l) {
        let d = e._parseTemplateNestedTemplate.call(
          this,
          o,
          a,
          l
        );
        const u = o.parentNode, f = l.templateInfo, g = u.localName === "dom-if", _ = u.localName === "dom-repeat";
        Wp && (g || _) && (u.removeChild(o), l = l.parentInfo, l.templateInfo = f, l.noted = !0, d = !1);
        let C = f.hostProps;
        if (FA && g)
          C && (a.hostProps = Object.assign(a.hostProps || {}, C), Wp || (l.parentInfo.noted = !0));
        else {
          let x = "{";
          for (let D in C) {
            let P = [{ mode: x, source: D, dependencies: [D], hostProp: !0 }];
            $c(this, a, l, "property", "_host_" + D, P);
          }
        }
        return d;
      }
      /**
       * Called to parse text in a template (either attribute values or
       * textContent) into binding metadata.
       *
       * Any overrides of this method should return an array of binding part
       * metadata  representing one or more bindings found in the provided text
       * and any "literal" text in between.  Any non-literal parts will be passed
       * to `_evaluateBinding` when any dependencies change.  The only required
       * fields of each "part" in the returned array are as follows:
       *
       * - `dependencies` - Array containing trigger metadata for each property
       *   that should trigger the binding to update
       * - `literal` - String containing text if the part represents a literal;
       *   in this case no `dependencies` are needed
       *
       * Additional metadata for use by `_evaluateBinding` may be provided in
       * each part object as needed.
       *
       * The default implementation handles the following types of bindings
       * (one or more may be intermixed with literal strings):
       * - Property binding: `[[prop]]`
       * - Path binding: `[[object.prop]]`
       * - Negated property or path bindings: `[[!prop]]` or `[[!object.prop]]`
       * - Two-way property or path bindings (supports negation):
       *   `{{prop}}`, `{{object.prop}}`, `{{!prop}}` or `{{!object.prop}}`
       * - Inline computed method (supports negation):
       *   `[[compute(a, 'literal', b)]]`, `[[!compute(a, 'literal', b)]]`
       *
       * The default implementation uses a regular expression for best
       * performance. However, the regular expression uses a white-list of
       * allowed characters in a data-binding, which causes problems for
       * data-bindings that do use characters not in this white-list.
       *
       * Instead of updating the white-list with all allowed characters,
       * there is a StrictBindingParser (see lib/mixins/strict-binding-parser)
       * that uses a state machine instead. This state machine is able to handle
       * all characters. However, it is slightly less performant, therefore we
       * extracted it into a separate optional mixin.
       *
       * @param {string} text Text to parse from attribute or textContent
       * @param {Object} templateInfo Current template metadata
       * @return {Array<!BindingPart>} Array of binding part metadata
       * @protected
       * @nocollapse
       */
      static _parseBindings(o, a) {
        let l = [], d = 0, u;
        for (; (u = tg.exec(o)) !== null; ) {
          u.index > d && l.push({ literal: o.slice(d, u.index) });
          let f = u[1][0], g = !!u[2], _ = u[3].trim(), C = !1, x = "", D = -1;
          f == "{" && (D = _.indexOf("::")) > 0 && (x = _.substring(D + 2), _ = _.substring(0, D), C = !0);
          let P = Tc(_), I = [];
          if (P) {
            let { args: F, methodName: H } = P;
            for (let W = 0; W < F.length; W++) {
              let G = F[W];
              G.literal || I.push(G);
            }
            let Y = a.dynamicFns;
            (Y && Y[H] || P.static) && (I.push(H), P.dynamicFn = !0);
          } else
            I.push(_);
          l.push({
            source: _,
            mode: f,
            negate: g,
            customEvent: C,
            signature: P,
            dependencies: I,
            event: x
          }), d = tg.lastIndex;
        }
        if (d && d < o.length) {
          let f = o.substring(d);
          f && l.push({
            literal: f
          });
        }
        return l.length ? l : null;
      }
      /**
       * Called to evaluate a previously parsed binding part based on a set of
       * one or more changed dependencies.
       *
       * @param {!Polymer_PropertyEffects} inst Element that should be used as
       *     scope for binding dependencies
       * @param {BindingPart} part Binding part metadata
       * @param {string} path Property/path that triggered this effect
       * @param {Object} props Bag of current property changes
       * @param {Object} oldProps Bag of previous values for changed properties
       * @param {boolean} hasPaths True with `props` contains one or more paths
       * @return {*} Value the binding part evaluated to
       * @protected
       * @nocollapse
       */
      static _evaluateBinding(o, a, l, d, u, f) {
        let g;
        return a.signature ? g = ud(o, l, d, u, a.signature) : l != a.source ? g = at(o, a.source) : f && cd(l) ? g = at(o, l) : g = o.__data[l], a.negate && (g = !g), g;
      }
    }
    return t;
  }), hn = [];
  /**
  @license
  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */
  /**
  @license
  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */
  function jE(r) {
    const e = {};
    for (let t in r) {
      const i = r[t];
      e[t] = typeof i == "function" ? { type: i } : i;
    }
    return e;
  }
  const ZE = Oe((r) => {
    const e = fb(r);
    function t(a) {
      const l = Object.getPrototypeOf(a);
      return l.prototype instanceof o ? (
        /** @type {!PropertiesMixinConstructor} */
        l
      ) : null;
    }
    function i(a) {
      if (!a.hasOwnProperty(JSCompiler_renameProperty("__ownProperties", a))) {
        let l = null;
        if (a.hasOwnProperty(JSCompiler_renameProperty("properties", a))) {
          const d = a.properties;
          d && (l = jE(d));
        }
        a.__ownProperties = l;
      }
      return a.__ownProperties;
    }
    class o extends e {
      /**
       * Implements standard custom elements getter to observes the attributes
       * listed in `properties`.
       * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
       * @nocollapse
       */
      static get observedAttributes() {
        if (!this.hasOwnProperty(JSCompiler_renameProperty("__observedAttributes", this))) {
          this.prototype;
          const l = this._properties;
          this.__observedAttributes = l ? Object.keys(l).map((d) => this.prototype._addPropertyToAttributeMap(d)) : [];
        }
        return this.__observedAttributes;
      }
      /**
       * Finalizes an element definition, including ensuring any super classes
       * are also finalized. This includes ensuring property
       * accessors exist on the element prototype. This method calls
       * `_finalizeClass` to finalize each constructor in the prototype chain.
       * @return {void}
       * @nocollapse
       */
      static finalize() {
        if (!this.hasOwnProperty(JSCompiler_renameProperty("__finalized", this))) {
          const l = t(
            /** @type {!PropertiesMixinConstructor} */
            this
          );
          l && l.finalize(), this.__finalized = !0, this._finalizeClass();
        }
      }
      /**
       * Finalize an element class. This includes ensuring property
       * accessors exist on the element prototype. This method is called by
       * `finalize` and finalizes the class constructor.
       *
       * @protected
       * @nocollapse
       */
      static _finalizeClass() {
        const l = i(
          /** @type {!PropertiesMixinConstructor} */
          this
        );
        l && this.createProperties(l);
      }
      /**
       * Returns a memoized version of all properties, including those inherited
       * from super classes. Properties not in object format are converted to
       * at least {type}.
       *
       * @return {Object} Object containing properties for this class
       * @protected
       * @nocollapse
       */
      static get _properties() {
        if (!this.hasOwnProperty(
          JSCompiler_renameProperty("__properties", this)
        )) {
          const l = t(
            /** @type {!PropertiesMixinConstructor} */
            this
          );
          this.__properties = Object.assign(
            {},
            l && l._properties,
            i(
              /** @type {PropertiesMixinConstructor} */
              this
            )
          );
        }
        return this.__properties;
      }
      /**
       * Overrides `PropertiesChanged` method to return type specified in the
       * static `properties` object for the given property.
       * @param {string} name Name of property
       * @return {*} Type to which to deserialize attribute
       *
       * @protected
       * @nocollapse
       */
      static typeForProperty(l) {
        const d = this._properties[l];
        return d && d.type;
      }
      /**
       * Overrides `PropertiesChanged` method and adds a call to
       * `finalize` which lazily configures the element's property accessors.
       * @override
       * @return {void}
       */
      _initializeProperties() {
        this.constructor.finalize(), super._initializeProperties();
      }
      /**
       * Called when the element is added to a document.
       * Calls `_enableProperties` to turn on property system from
       * `PropertiesChanged`.
       * @suppress {missingProperties} Super may or may not implement the callback
       * @return {void}
       * @override
       */
      connectedCallback() {
        super.connectedCallback && super.connectedCallback(), this._enableProperties();
      }
      /**
       * Called when the element is removed from a document
       * @suppress {missingProperties} Super may or may not implement the callback
       * @return {void}
       * @override
       */
      disconnectedCallback() {
        super.disconnectedCallback && super.disconnectedCallback();
      }
    }
    return o;
  });
  /**
   * @fileoverview
   * @suppress {checkPrototypalTypes}
   * @license Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt The complete set of authors may be found
   * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may
   * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by
   * Google as part of the polymer project is also subject to an additional IP
   * rights grant found at http://polymer.github.io/PATENTS.txt
   */
  const KE = "3.5.2", og = window.ShadyCSS && window.ShadyCSS.cssBuild, kb = Oe((r) => {
    const e = ZE(au(r));
    function t(u) {
      if (!u.hasOwnProperty(
        JSCompiler_renameProperty("__propertyDefaults", u)
      )) {
        u.__propertyDefaults = null;
        let f = u._properties;
        for (let g in f) {
          let _ = f[g];
          "value" in _ && (u.__propertyDefaults = u.__propertyDefaults || {}, u.__propertyDefaults[g] = _);
        }
      }
      return u.__propertyDefaults;
    }
    function i(u) {
      return u.hasOwnProperty(
        JSCompiler_renameProperty("__ownObservers", u)
      ) || (u.__ownObservers = u.hasOwnProperty(
        JSCompiler_renameProperty("observers", u)
      ) ? (
        /** @type {PolymerElementConstructor} */
        u.observers
      ) : null), u.__ownObservers;
    }
    function o(u, f, g, _) {
      g.computed && (g.readOnly = !0), g.computed && (u._hasReadOnlyEffect(f) || u._createComputedProperty(f, g.computed, _)), g.readOnly && !u._hasReadOnlyEffect(f) ? u._createReadOnlyProperty(f, !g.computed) : g.readOnly === !1 && u._hasReadOnlyEffect(f), g.reflectToAttribute && !u._hasReflectEffect(f) ? u._createReflectedProperty(f) : g.reflectToAttribute === !1 && u._hasReflectEffect(f), g.notify && !u._hasNotifyEffect(f) ? u._createNotifyingProperty(f) : g.notify === !1 && u._hasNotifyEffect(f), g.observer && u._createPropertyObserver(f, g.observer, _[g.observer]), u._addPropertyToAttributeMap(f);
    }
    function a(u, f, g, _) {
      if (!og) {
        const C = f.content.querySelectorAll("style"), x = sb(f), D = YA(g), P = f.content.firstElementChild;
        for (let F = 0; F < D.length; F++) {
          let H = D[F];
          H.textContent = u._processStyleText(H.textContent, _), f.content.insertBefore(H, P);
        }
        let I = 0;
        for (let F = 0; F < x.length; F++) {
          let H = x[F], Y = C[I];
          Y !== H ? (H = H.cloneNode(!0), Y.parentNode.insertBefore(H, Y)) : I++, H.textContent = u._processStyleText(H.textContent, _);
        }
      }
      if (window.ShadyCSS && window.ShadyCSS.prepareTemplate(f, g), zA && og && IA) {
        const C = f.content.querySelectorAll("style");
        if (C) {
          let x = "";
          Array.from(C).forEach((D) => {
            x += D.textContent, D.parentNode.removeChild(D);
          }), u._styleSheet = new CSSStyleSheet(), u._styleSheet.replaceSync(x);
        }
      }
    }
    function l(u) {
      let f = null;
      if (u && (!ka || NA) && (f = /** @type {?HTMLTemplateElement} */
      Nn.import(u, "template"), ka && !f))
        throw new Error(`strictTemplatePolicy: expecting dom-module or null template for ${u}`);
      return f;
    }
    class d extends e {
      /**
       * Current Polymer version in Semver notation.
       * @type {string} Semver notation of the current version of Polymer.
       * @nocollapse
       */
      static get polymerElementVersion() {
        return KE;
      }
      /**
       * Override of PropertiesMixin _finalizeClass to create observers and
       * find the template.
       * @return {void}
       * @protected
       * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
       * @nocollapse
       */
      static _finalizeClass() {
        e._finalizeClass.call(this);
        const f = i(this);
        f && this.createObservers(f, this._properties), this._prepareTemplate();
      }
      /** @nocollapse */
      static _prepareTemplate() {
        let f = (
          /** @type {PolymerElementConstructor} */
          this.template
        );
        f && (typeof f == "string" ? f = null : rb || (f = f.cloneNode(!0))), this.prototype._template = f;
      }
      /**
       * Override of PropertiesChanged createProperties to create accessors
       * and property effects for all of the properties.
       * @param {!Object} props .
       * @return {void}
       * @protected
       * @nocollapse
       */
      static createProperties(f) {
        for (let g in f)
          o(
            /** @type {?} */
            this.prototype,
            g,
            f[g],
            f
          );
      }
      /**
       * Creates observers for the given `observers` array.
       * Leverages `PropertyEffects` to create observers.
       * @param {Object} observers Array of observer descriptors for
       *   this class
       * @param {Object} dynamicFns Object containing keys for any properties
       *   that are functions and should trigger the effect when the function
       *   reference is changed
       * @return {void}
       * @protected
       * @nocollapse
       */
      static createObservers(f, g) {
        const _ = this.prototype;
        for (let C = 0; C < f.length; C++)
          _._createMethodObserver(f[C], g);
      }
      /**
       * Returns the template that will be stamped into this element's shadow root.
       *
       * If a `static get is()` getter is defined, the default implementation will
       * return the first `<template>` in a `dom-module` whose `id` matches this
       * element's `is` (note that a `_template` property on the class prototype
       * takes precedence over the `dom-module` template, to maintain legacy
       * element semantics; a subclass will subsequently fall back to its super
       * class template if neither a `prototype._template` or a `dom-module` for
       * the class's `is` was found).
       *
       * Users may override this getter to return an arbitrary template
       * (in which case the `is` getter is unnecessary). The template returned
       * must be an `HTMLTemplateElement`.
       *
       * Note that when subclassing, if the super class overrode the default
       * implementation and the subclass would like to provide an alternate
       * template via a `dom-module`, it should override this getter and
       * return `DomModule.import(this.is, 'template')`.
       *
       * If a subclass would like to modify the super class template, it should
       * clone it rather than modify it in place.  If the getter does expensive
       * work such as cloning/modifying a template, it should memoize the
       * template for maximum performance:
       *
       *   let memoizedTemplate;
       *   class MySubClass extends MySuperClass {
       *     static get template() {
       *       if (!memoizedTemplate) {
       *         memoizedTemplate = super.template.cloneNode(true);
       *         let subContent = document.createElement('div');
       *         subContent.textContent = 'This came from MySubClass';
       *         memoizedTemplate.content.appendChild(subContent);
       *       }
       *       return memoizedTemplate;
       *     }
       *   }
       *
       * @return {!HTMLTemplateElement|string} Template to be stamped
       * @nocollapse
       */
      static get template() {
        if (!this.hasOwnProperty(JSCompiler_renameProperty("_template", this))) {
          let f = this.prototype.hasOwnProperty(
            JSCompiler_renameProperty("_template", this.prototype)
          ) ? this.prototype._template : void 0;
          typeof f == "function" && (f = f()), this._template = // If user has put template on prototype (e.g. in legacy via registered
          // callback or info object), prefer that first. Note that `null` is
          // used as a sentinel to indicate "no template" and can be used to
          // override a super template, whereas `undefined` is used as a
          // sentinel to mean "fall-back to default template lookup" via
          // dom-module and/or super.template.
          f !== void 0 ? f : (
            // Look in dom-module associated with this element's is
            this.hasOwnProperty(JSCompiler_renameProperty("is", this)) && l(
              /** @type {PolymerElementConstructor}*/
              this.is
            ) || // Next look for superclass template (call the super impl this
            // way so that `this` points to the superclass)
            Object.getPrototypeOf(
              /** @type {PolymerElementConstructor}*/
              this.prototype
            ).constructor.template
          );
        }
        return this._template;
      }
      /**
       * Set the template.
       *
       * @param {!HTMLTemplateElement|string} value Template to set.
       * @nocollapse
       */
      static set template(f) {
        this._template = f;
      }
      /**
       * Path matching the url from which the element was imported.
       *
       * This path is used to resolve url's in template style cssText.
       * The `importPath` property is also set on element instances and can be
       * used to create bindings relative to the import path.
       *
       * For elements defined in ES modules, users should implement
       * `static get importMeta() { return import.meta; }`, and the default
       * implementation of `importPath` will  return `import.meta.url`'s path.
       * For elements defined in HTML imports, this getter will return the path
       * to the document containing a `dom-module` element matching this
       * element's static `is` property.
       *
       * Note, this path should contain a trailing `/`.
       *
       * @return {string} The import path for this element class
       * @suppress {missingProperties}
       * @nocollapse
       */
      static get importPath() {
        if (!this.hasOwnProperty(JSCompiler_renameProperty("_importPath", this))) {
          const f = this.importMeta;
          if (f)
            this._importPath = iu(f.url);
          else {
            const g = Nn.import(
              /** @type {PolymerElementConstructor} */
              this.is
            );
            this._importPath = g && g.assetpath || Object.getPrototypeOf(
              /** @type {PolymerElementConstructor}*/
              this.prototype
            ).constructor.importPath;
          }
        }
        return this._importPath;
      }
      constructor() {
        super(), this._template, this._importPath, this.rootPath, this.importPath, this.root, this.$;
      }
      /**
       * Overrides the default `PropertyAccessors` to ensure class
       * metaprogramming related to property accessors and effects has
       * completed (calls `finalize`).
       *
       * It also initializes any property defaults provided via `value` in
       * `properties` metadata.
       *
       * @return {void}
       * @override
       * @suppress {invalidCasts,missingProperties} go/missingfnprops
       */
      _initializeProperties() {
        this.constructor.finalize(), this.constructor._finalizeTemplate(
          /** @type {!HTMLElement} */
          this.localName
        ), super._initializeProperties(), this.rootPath = MA, this.importPath = this.constructor.importPath;
        let f = t(this.constructor);
        if (f)
          for (let g in f) {
            let _ = f[g];
            if (this._canApplyPropertyDefault(g)) {
              let C = typeof _.value == "function" ? _.value.call(this) : _.value;
              this._hasAccessor(g) ? this._setPendingProperty(g, C, !0) : this[g] = C;
            }
          }
      }
      /**
       * Determines if a property dfeault can be applied. For example, this
       * prevents a default from being applied when a property that has no
       * accessor is overridden by its host before upgrade (e.g. via a binding).
       * @override
       * @param {string} property Name of the property
       * @return {boolean} Returns true if the property default can be applied.
       */
      _canApplyPropertyDefault(f) {
        return !this.hasOwnProperty(f);
      }
      /**
       * Gather style text for a style element in the template.
       *
       * @param {string} cssText Text containing styling to process
       * @param {string} baseURI Base URI to rebase CSS paths against
       * @return {string} The processed CSS text
       * @protected
       * @nocollapse
       */
      static _processStyleText(f, g) {
        return ru(f, g);
      }
      /**
      * Configures an element `proto` to function with a given `template`.
      * The element name `is` and extends `ext` must be specified for ShadyCSS
      * style scoping.
      *
      * @param {string} is Tag name (or type extension name) for this element
      * @return {void}
      * @protected
      * @nocollapse
      */
      static _finalizeTemplate(f) {
        const g = this.prototype._template;
        if (g && !g.__polymerFinalized) {
          g.__polymerFinalized = !0;
          const _ = this.importPath, C = _ ? An(_) : "";
          a(this, g, f, C), this.prototype._bindTemplate(g);
        }
      }
      /**
       * Provides a default implementation of the standard Custom Elements
       * `connectedCallback`.
       *
       * The default implementation enables the property effects system and
       * flushes any pending properties, and updates shimmed CSS properties
       * when using the ShadyCSS scoping/custom properties polyfill.
       *
       * @override
       * @suppress {missingProperties, invalidCasts} Super may or may not
       *     implement the callback
       * @return {void}
       */
      connectedCallback() {
        window.ShadyCSS && this._template && window.ShadyCSS.styleElement(
          /** @type {!HTMLElement} */
          this
        ), super.connectedCallback();
      }
      /**
       * Stamps the element template.
       *
       * @return {void}
       * @override
       */
      ready() {
        this._template && (this.root = this._stampTemplate(this._template), this.$ = this.root.$), super.ready();
      }
      /**
       * Implements `PropertyEffects`'s `_readyClients` call. Attaches
       * element dom by calling `_attachDom` with the dom stamped from the
       * element's template via `_stampTemplate`. Note that this allows
       * client dom to be attached to the element prior to any observers
       * running.
       *
       * @return {void}
       * @override
       */
      _readyClients() {
        this._template && (this.root = this._attachDom(
          /** @type {StampedTemplate} */
          this.root
        )), super._readyClients();
      }
      /**
       * Attaches an element's stamped dom to itself. By default,
       * this method creates a `shadowRoot` and adds the dom to it.
       * However, this method may be overridden to allow an element
       * to put its dom in another location.
       *
       * @override
       * @throws {Error}
       * @suppress {missingReturn}
       * @param {StampedTemplate} dom to attach to the element.
       * @return {ShadowRoot} node to which the dom has been attached.
       */
      _attachDom(f) {
        const g = ye(this);
        if (g.attachShadow)
          return f ? (g.shadowRoot || (g.attachShadow({ mode: "open", shadyUpgradeFragment: f }), g.shadowRoot.appendChild(f), this.constructor._styleSheet && (g.shadowRoot.adoptedStyleSheets = [this.constructor._styleSheet])), LA && window.ShadyDOM && window.ShadyDOM.flushInitial(g.shadowRoot), g.shadowRoot) : null;
        throw new Error("ShadowDOM not available. PolymerElement can create dom as children instead of in ShadowDOM by setting `this.root = this;` before `ready`.");
      }
      /**
       * When using the ShadyCSS scoping and custom property shim, causes all
       * shimmed styles in this element (and its subtree) to be updated
       * based on current custom property values.
       *
       * The optional parameter overrides inline custom property styles with an
       * object of properties where the keys are CSS properties, and the values
       * are strings.
       *
       * Example: `this.updateStyles({'--color': 'blue'})`
       *
       * These properties are retained unless a value of `null` is set.
       *
       * Note: This function does not support updating CSS mixins.
       * You can not dynamically change the value of an `@apply`.
       *
       * @override
       * @param {Object=} properties Bag of custom property key/values to
       *   apply to this element.
       * @return {void}
       * @suppress {invalidCasts}
       */
      updateStyles(f) {
        window.ShadyCSS && window.ShadyCSS.styleSubtree(
          /** @type {!HTMLElement} */
          this,
          f
        );
      }
      /**
       * Rewrites a given URL relative to a base URL. The base URL defaults to
       * the original location of the document containing the `dom-module` for
       * this element. This method will return the same URL before and after
       * bundling.
       *
       * Note that this function performs no resolution for URLs that start
       * with `/` (absolute URLs) or `#` (hash identifiers).  For general purpose
       * URL resolution, use `window.URL`.
       *
       * @override
       * @param {string} url URL to resolve.
       * @param {string=} base Optional base URL to resolve against, defaults
       * to the element's `importPath`
       * @return {string} Rewritten URL relative to base
       */
      resolveUrl(f, g) {
        return !g && this.importPath && (g = An(this.importPath)), An(f, g);
      }
      /**
       * Overrides `PropertyEffects` to add map of dynamic functions on
       * template info, for consumption by `PropertyEffects` template binding
       * code. This map determines which method templates should have accessors
       * created for them.
       *
       * @param {!HTMLTemplateElement} template Template
       * @param {!TemplateInfo} templateInfo Template metadata for current template
       * @param {!NodeInfo} nodeInfo Node metadata for current template.
       * @return {boolean} .
       * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
       * @nocollapse
       */
      static _parseTemplateContent(f, g, _) {
        return g.dynamicFns = g.dynamicFns || this._properties, e._parseTemplateContent.call(
          this,
          f,
          g,
          _
        );
      }
      /**
       * Overrides `PropertyEffects` to warn on use of undeclared properties in
       * template.
       *
       * @param {Object} templateInfo Template metadata to add effect to
       * @param {string} prop Property that should trigger the effect
       * @param {Object=} effect Effect metadata object
       * @return {void}
       * @protected
       * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
       * @nocollapse
       */
      static _addTemplatePropertyEffect(f, g, _) {
        return ib && !(g in this._properties) && // Methods used in templates with no dependencies (or only literal
        // dependencies) become accessors with template effects; ignore these
        !(_.info.part.signature && _.info.part.signature.static) && // Warnings for bindings added to nested templates are handled by
        // templatizer so ignore both the host-to-template bindings
        // (`hostProp`) and TemplateInstance-to-child bindings
        // (`nestedTemplate`)
        !_.info.part.hostProp && f.nestedTemplate, e._addTemplatePropertyEffect.call(
          this,
          f,
          g,
          _
        );
      }
    }
    return d;
  });
  /**
  @license
  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */
  const ng = window.trustedTypes && trustedTypes.createPolicy("polymer-html-literal", { createHTML: (r) => r });
  class xb {
    /**
     * @param {!ITemplateArray} strings Constant parts of tagged template literal
     * @param {!Array<*>} values Variable parts of tagged template literal
     */
    constructor(e, t) {
      Sb(e, t);
      const i = t.reduce(
        (o, a, l) => o + Cb(a) + e[l + 1],
        e[0]
      );
      this.value = i.toString();
    }
    /**
     * @return {string} LiteralString string value
     * @override
     */
    toString() {
      return this.value;
    }
  }
  function Cb(r) {
    if (r instanceof xb)
      return (
        /** @type {!LiteralString} */
        r.value
      );
    throw new Error(
      `non-literal value passed to Polymer's htmlLiteral function: ${r}`
    );
  }
  function JE(r) {
    if (r instanceof HTMLTemplateElement)
      return (
        /** @type {!HTMLTemplateElement } */
        r.innerHTML
      );
    if (r instanceof xb)
      return Cb(r);
    throw new Error(
      `non-template value passed to Polymer's html function: ${r}`
    );
  }
  const Ar = function(e, ...t) {
    Sb(e, t);
    const i = (
      /** @type {!HTMLTemplateElement} */
      document.createElement("template")
    );
    let o = t.reduce(
      (a, l, d) => a + JE(l) + e[d + 1],
      e[0]
    );
    return ng && (o = ng.createHTML(o)), i.innerHTML = o, i;
  }, Sb = (r, e) => {
    if (!Array.isArray(r) || !Array.isArray(r.raw) || e.length !== r.length - 1)
      throw new TypeError("Invalid call to the html template tag");
  };
  /**
  @license
  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */
  const Gt = kb(HTMLElement);
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  class lo {
    /**
     * Get the scroll type in the current browser view.
     *
     * @return {string} the scroll type. Possible values are `default|reverse|negative`
     */
    static detectScrollType() {
      const e = document.createElement("div");
      e.textContent = "ABCD", e.dir = "rtl", e.style.fontSize = "14px", e.style.width = "4px", e.style.height = "1px", e.style.position = "absolute", e.style.top = "-1000px", e.style.overflow = "scroll", document.body.appendChild(e);
      let t = "reverse";
      return e.scrollLeft > 0 ? t = "default" : (e.scrollLeft = 2, e.scrollLeft < 2 && (t = "negative")), document.body.removeChild(e), t;
    }
    /**
     * Get the scrollLeft value of the element relative to the direction
     *
     * @param {string} scrollType type of the scroll detected with `detectScrollType`
     * @param {string} direction current direction of the element
     * @param {Element} element
     * @return {number} the scrollLeft value.
     */
    static getNormalizedScrollLeft(e, t, i) {
      const { scrollLeft: o } = i;
      if (t !== "rtl" || !e)
        return o;
      switch (e) {
        case "negative":
          return i.scrollWidth - i.clientWidth + o;
        case "reverse":
          return i.scrollWidth - i.clientWidth - o;
        default:
          return o;
      }
    }
    /**
     * Set the scrollLeft value of the element relative to the direction
     *
     * @param {string} scrollType type of the scroll detected with `detectScrollType`
     * @param {string} direction current direction of the element
     * @param {Element} element
     * @param {number} scrollLeft the scrollLeft value to be set
     */
    static setNormalizedScrollLeft(e, t, i, o) {
      if (t !== "rtl" || !e) {
        i.scrollLeft = o;
        return;
      }
      switch (e) {
        case "negative":
          i.scrollLeft = i.clientWidth - i.scrollWidth + o;
          break;
        case "reverse":
          i.scrollLeft = i.scrollWidth - i.clientWidth - o;
          break;
        default:
          i.scrollLeft = o;
          break;
      }
    }
  }
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  const vr = [];
  function XE() {
    const r = fd();
    vr.forEach((e) => {
      hd(e, r);
    });
  }
  let Js;
  const QE = new MutationObserver(XE);
  QE.observe(document.documentElement, { attributes: !0, attributeFilter: ["dir"] });
  function hd(r, e, t = r.getAttribute("dir")) {
    e ? r.setAttribute("dir", e) : t != null && r.removeAttribute("dir");
  }
  function fd() {
    return document.documentElement.getAttribute("dir");
  }
  const Kn = (r) => class extends r {
    static get properties() {
      return {
        /**
         * @protected
         */
        dir: {
          type: String,
          value: "",
          reflectToAttribute: !0,
          converter: {
            fromAttribute: (t) => t || "",
            toAttribute: (t) => t === "" ? null : t
          }
        }
      };
    }
    /** @protected */
    static finalize() {
      super.finalize(), Js || (Js = lo.detectScrollType());
    }
    /** @protected */
    connectedCallback() {
      super.connectedCallback(), (!this.hasAttribute("dir") || this.__restoreSubscription) && (this.__subscribe(), hd(this, fd(), null));
    }
    /** @protected */
    attributeChangedCallback(t, i, o) {
      if (super.attributeChangedCallback(t, i, o), t !== "dir")
        return;
      const a = fd(), l = o === a && vr.indexOf(this) === -1, d = !o && i && vr.indexOf(this) === -1;
      l || d ? (this.__subscribe(), hd(this, a, o)) : o !== a && i === a && this.__unsubscribe();
    }
    /** @protected */
    disconnectedCallback() {
      super.disconnectedCallback(), this.__restoreSubscription = vr.includes(this), this.__unsubscribe();
    }
    /** @protected */
    _valueToNodeAttribute(t, i, o) {
      o === "dir" && i === "" && !t.hasAttribute("dir") || super._valueToNodeAttribute(t, i, o);
    }
    /** @protected */
    _attributeToProperty(t, i, o) {
      t === "dir" && !i ? this.dir = "" : super._attributeToProperty(t, i, o);
    }
    /** @private */
    __subscribe() {
      vr.includes(this) || vr.push(this);
    }
    /** @private */
    __unsubscribe() {
      vr.includes(this) && vr.splice(vr.indexOf(this), 1);
    }
    /**
     * @param {Element} element
     * @return {number}
     * @protected
     */
    __getNormalizedScrollLeft(t) {
      return lo.getNormalizedScrollLeft(Js, this.getAttribute("dir") || "ltr", t);
    }
    /**
     * @param {Element} element
     * @param {number} scrollLeft
     * @protected
     */
    __setNormalizedScrollLeft(t, i) {
      return lo.setNormalizedScrollLeft(Js, this.getAttribute("dir") || "ltr", t, i);
    }
  };
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  class sg extends Kr(Kn(Gt)) {
    static get is() {
      return "vaadin-input-container";
    }
    static get template() {
      return Ar`
      <style>
        :host {
          display: flex;
          align-items: center;
          flex: 0 1 auto;
        }

        :host([hidden]) {
          display: none !important;
        }

        /* Reset the native input styles */
        ::slotted(input) {
          -webkit-appearance: none;
          -moz-appearance: none;
          flex: auto;
          white-space: nowrap;
          overflow: hidden;
          width: 100%;
          height: 100%;
          outline: none;
          margin: 0;
          padding: 0;
          border: 0;
          border-radius: 0;
          min-width: 0;
          font: inherit;
          line-height: normal;
          color: inherit;
          background-color: transparent;
          /* Disable default invalid style in Firefox */
          box-shadow: none;
        }

        ::slotted(*) {
          flex: none;
        }

        ::slotted(:is(input, textarea))::placeholder {
          /* Use ::slotted(input:placeholder-shown) in themes to style the placeholder. */
          /* because ::slotted(...)::placeholder does not work in Safari. */
          font: inherit;
          color: inherit;
          /* Override default opacity in Firefox */
          opacity: 1;
        }
      </style>
      <slot name="prefix"></slot>
      <slot></slot>
      <slot name="suffix"></slot>
    `;
    }
    static get properties() {
      return {
        /**
         * If true, the user cannot interact with this element.
         */
        disabled: {
          type: Boolean,
          reflectToAttribute: !0
        },
        /**
         * Set to true to make this element read-only.
         */
        readonly: {
          type: Boolean,
          reflectToAttribute: !0
        },
        /**
         * Set to true when the element is invalid.
         */
        invalid: {
          type: Boolean,
          reflectToAttribute: !0
        }
      };
    }
    /** @protected */
    ready() {
      super.ready(), this.addEventListener("pointerdown", (e) => {
        e.target === this && e.preventDefault();
      }), this.addEventListener("click", (e) => {
        e.target === this && this.shadowRoot.querySelector("slot:not([name])").assignedNodes({ flatten: !0 }).forEach((t) => t.focus && t.focus());
      });
    }
  }
  customElements.define(sg.is, sg);
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  const e$ = me`
  :host {
    /* Square */
    --lumo-space-xs: 0.25rem;
    --lumo-space-s: 0.5rem;
    --lumo-space-m: 1rem;
    --lumo-space-l: 1.5rem;
    --lumo-space-xl: 2.5rem;

    /* Wide */
    --lumo-space-wide-xs: calc(var(--lumo-space-xs) / 2) var(--lumo-space-xs);
    --lumo-space-wide-s: calc(var(--lumo-space-s) / 2) var(--lumo-space-s);
    --lumo-space-wide-m: calc(var(--lumo-space-m) / 2) var(--lumo-space-m);
    --lumo-space-wide-l: calc(var(--lumo-space-l) / 2) var(--lumo-space-l);
    --lumo-space-wide-xl: calc(var(--lumo-space-xl) / 2) var(--lumo-space-xl);

    /* Tall */
    --lumo-space-tall-xs: var(--lumo-space-xs) calc(var(--lumo-space-xs) / 2);
    --lumo-space-tall-s: var(--lumo-space-s) calc(var(--lumo-space-s) / 2);
    --lumo-space-tall-m: var(--lumo-space-m) calc(var(--lumo-space-m) / 2);
    --lumo-space-tall-l: var(--lumo-space-l) calc(var(--lumo-space-l) / 2);
    --lumo-space-tall-xl: var(--lumo-space-xl) calc(var(--lumo-space-xl) / 2);
  }
`, Ab = document.createElement("template");
  Ab.innerHTML = `<style>${e$.toString().replace(":host", "html")}</style>`;
  document.head.appendChild(Ab.content);
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  const lu = me`
  :host {
    top: var(--lumo-space-m);
    right: var(--lumo-space-m);
    bottom: var(--lumo-space-m);
    left: var(--lumo-space-m);
    /* Workaround for Edge issue (only on Surface), where an overflowing vaadin-list-box inside vaadin-select-overlay makes the overlay transparent */
    /* stylelint-disable-next-line */
    outline: 0px solid transparent;
  }

  [part='overlay'] {
    background-color: var(--lumo-base-color);
    background-image: linear-gradient(var(--lumo-tint-5pct), var(--lumo-tint-5pct));
    border-radius: var(--lumo-border-radius-m);
    box-shadow: 0 0 0 1px var(--lumo-shade-5pct), var(--lumo-box-shadow-m);
    color: var(--lumo-body-text-color);
    font-family: var(--lumo-font-family);
    font-size: var(--lumo-font-size-m);
    font-weight: 400;
    line-height: var(--lumo-line-height-m);
    letter-spacing: 0;
    text-transform: none;
    -webkit-text-size-adjust: 100%;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }

  [part='content'] {
    padding: var(--lumo-space-xs);
  }

  [part='backdrop'] {
    background-color: var(--lumo-shade-20pct);
    animation: 0.2s lumo-overlay-backdrop-enter both;
    will-change: opacity;
  }

  @keyframes lumo-overlay-backdrop-enter {
    0% {
      opacity: 0;
    }
  }

  :host([closing]) [part='backdrop'] {
    animation: 0.2s lumo-overlay-backdrop-exit both;
  }

  @keyframes lumo-overlay-backdrop-exit {
    100% {
      opacity: 0;
    }
  }

  @keyframes lumo-overlay-dummy-animation {
    0% {
      opacity: 1;
    }

    100% {
      opacity: 1;
    }
  }
`;
  Te("", lu, { moduleId: "lumo-overlay" });
  Te("vaadin-overlay", lu, { moduleId: "lumo-vaadin-overlay" });
  /**
  @license
  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */
  function fn(r, e, t) {
    return {
      index: r,
      removed: e,
      addedCount: t
    };
  }
  const Eb = 0, $b = 1, pd = 2, gd = 3;
  function t$(r, e, t, i, o, a) {
    let l = a - o + 1, d = t - e + 1, u = new Array(l);
    for (let f = 0; f < l; f++)
      u[f] = new Array(d), u[f][0] = f;
    for (let f = 0; f < d; f++)
      u[0][f] = f;
    for (let f = 1; f < l; f++)
      for (let g = 1; g < d; g++)
        if (cu(r[e + g - 1], i[o + f - 1]))
          u[f][g] = u[f - 1][g - 1];
        else {
          let _ = u[f - 1][g] + 1, C = u[f][g - 1] + 1;
          u[f][g] = _ < C ? _ : C;
        }
    return u;
  }
  function r$(r) {
    let e = r.length - 1, t = r[0].length - 1, i = r[e][t], o = [];
    for (; e > 0 || t > 0; ) {
      if (e == 0) {
        o.push(pd), t--;
        continue;
      }
      if (t == 0) {
        o.push(gd), e--;
        continue;
      }
      let a = r[e - 1][t - 1], l = r[e - 1][t], d = r[e][t - 1], u;
      l < d ? u = l < a ? l : a : u = d < a ? d : a, u == a ? (a == i ? o.push(Eb) : (o.push($b), i = a), e--, t--) : u == l ? (o.push(gd), e--, i = l) : (o.push(pd), t--, i = d);
    }
    return o.reverse(), o;
  }
  function i$(r, e, t, i, o, a) {
    let l = 0, d = 0, u, f = Math.min(t - e, a - o);
    if (e == 0 && o == 0 && (l = o$(r, i, f)), t == r.length && a == i.length && (d = n$(r, i, f - l)), e += l, o += l, t -= d, a -= d, t - e == 0 && a - o == 0)
      return [];
    if (e == t) {
      for (u = fn(e, [], 0); o < a; )
        u.removed.push(i[o++]);
      return [u];
    } else if (o == a)
      return [fn(e, [], t - e)];
    let g = r$(
      t$(
        r,
        e,
        t,
        i,
        o,
        a
      )
    );
    u = void 0;
    let _ = [], C = e, x = o;
    for (let D = 0; D < g.length; D++)
      switch (g[D]) {
        case Eb:
          u && (_.push(u), u = void 0), C++, x++;
          break;
        case $b:
          u || (u = fn(C, [], 0)), u.addedCount++, C++, u.removed.push(i[x]), x++;
          break;
        case pd:
          u || (u = fn(C, [], 0)), u.addedCount++, C++;
          break;
        case gd:
          u || (u = fn(C, [], 0)), u.removed.push(i[x]), x++;
          break;
      }
    return u && _.push(u), _;
  }
  function o$(r, e, t) {
    for (let i = 0; i < t; i++)
      if (!cu(r[i], e[i]))
        return i;
    return t;
  }
  function n$(r, e, t) {
    let i = r.length, o = e.length, a = 0;
    for (; a < t && cu(r[--i], e[--o]); )
      a++;
    return a;
  }
  function s$(r, e) {
    return i$(
      r,
      0,
      r.length,
      e,
      0,
      e.length
    );
  }
  function cu(r, e) {
    return r === e;
  }
  /**
  @license
  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */
  function Ki(r) {
    return r.localName === "slot";
  }
  let Ca = class {
    /**
     * Returns the list of flattened nodes for the given `node`.
     * This list consists of a node's children and, for any children
     * that are `<slot>` elements, the expanded flattened list of `assignedNodes`.
     * For example, if the observed node has children `<a></a><slot></slot><b></b>`
     * and the `<slot>` has one `<div>` assigned to it, then the flattened
     * nodes list is `<a></a><div></div><b></b>`. If the `<slot>` has other
     * `<slot>` elements assigned to it, these are flattened as well.
     *
     * @param {!HTMLElement|!HTMLSlotElement} node The node for which to
     *      return the list of flattened nodes.
     * @return {!Array<!Node>} The list of flattened nodes for the given `node`.
     * @nocollapse See https://github.com/google/closure-compiler/issues/2763
     */
    // eslint-disable-next-line
    static getFlattenedNodes(r) {
      const e = ye(r);
      if (Ki(r))
        return r = /** @type {!HTMLSlotElement} */
        r, e.assignedNodes({ flatten: !0 });
      {
        const t = [];
        for (let i = 0; i < e.childNodes.length; i++) {
          const o = e.childNodes[i];
          if (Ki(o)) {
            const a = (
              /** @type {!HTMLSlotElement} */
              o
            );
            t.push(...ye(a).assignedNodes({ flatten: !0 }));
          } else
            t.push(o);
        }
        return t;
      }
    }
    /**
     * @param {!HTMLElement} target Node on which to listen for changes.
     * @param {?function(this: Element, { target: !HTMLElement, addedNodes: !Array<!Element>, removedNodes: !Array<!Element> }):void} callback Function called when there are additions
     * or removals from the target's list of flattened nodes.
     */
    // eslint-disable-next-line
    constructor(r, e) {
      this._shadyChildrenObserver = null, this._nativeChildrenObserver = null, this._connected = !1, this._target = r, this.callback = e, this._effectiveNodes = [], this._observer = null, this._scheduled = !1, this._boundSchedule = () => {
        this._schedule();
      }, this.connect(), this._schedule();
    }
    /**
     * Activates an observer. This method is automatically called when
     * a `FlattenedNodesObserver` is created. It should only be called to
     * re-activate an observer that has been deactivated via the `disconnect` method.
     *
     * @return {void}
     */
    connect() {
      Ki(this._target) ? this._listenSlots([this._target]) : ye(this._target).children && (this._listenSlots(
        /** @type {!NodeList<!Node>} */
        ye(this._target).children
      ), window.ShadyDOM ? this._shadyChildrenObserver = window.ShadyDOM.observeChildren(this._target, (r) => {
        this._processMutations(r);
      }) : (this._nativeChildrenObserver = new MutationObserver((r) => {
        this._processMutations(r);
      }), this._nativeChildrenObserver.observe(this._target, { childList: !0 }))), this._connected = !0;
    }
    /**
     * Deactivates the flattened nodes observer. After calling this method
     * the observer callback will not be called when changes to flattened nodes
     * occur. The `connect` method may be subsequently called to reactivate
     * the observer.
     *
     * @return {void}
     * @override
     */
    disconnect() {
      Ki(this._target) ? this._unlistenSlots([this._target]) : ye(this._target).children && (this._unlistenSlots(
        /** @type {!NodeList<!Node>} */
        ye(this._target).children
      ), window.ShadyDOM && this._shadyChildrenObserver ? (window.ShadyDOM.unobserveChildren(this._shadyChildrenObserver), this._shadyChildrenObserver = null) : this._nativeChildrenObserver && (this._nativeChildrenObserver.disconnect(), this._nativeChildrenObserver = null)), this._connected = !1;
    }
    /**
     * @return {void}
     * @private
     */
    _schedule() {
      this._scheduled || (this._scheduled = !0, nu.run(() => this.flush()));
    }
    /**
     * @param {Array<MutationRecord>} mutations Mutations signaled by the mutation observer
     * @return {void}
     * @private
     */
    _processMutations(r) {
      this._processSlotMutations(r), this.flush();
    }
    /**
     * @param {Array<MutationRecord>} mutations Mutations signaled by the mutation observer
     * @return {void}
     * @private
     */
    _processSlotMutations(r) {
      if (r)
        for (let e = 0; e < r.length; e++) {
          let t = r[e];
          t.addedNodes && this._listenSlots(t.addedNodes), t.removedNodes && this._unlistenSlots(t.removedNodes);
        }
    }
    /**
     * Flushes the observer causing any pending changes to be immediately
     * delivered the observer callback. By default these changes are delivered
     * asynchronously at the next microtask checkpoint.
     *
     * @return {boolean} Returns true if any pending changes caused the observer
     * callback to run.
     */
    flush() {
      if (!this._connected)
        return !1;
      window.ShadyDOM && ShadyDOM.flush(), this._nativeChildrenObserver ? this._processSlotMutations(this._nativeChildrenObserver.takeRecords()) : this._shadyChildrenObserver && this._processSlotMutations(this._shadyChildrenObserver.takeRecords()), this._scheduled = !1;
      let r = {
        target: this._target,
        addedNodes: [],
        removedNodes: []
      }, e = this.constructor.getFlattenedNodes(this._target), t = s$(
        e,
        this._effectiveNodes
      );
      for (let o = 0, a; o < t.length && (a = t[o]); o++)
        for (let l = 0, d; l < a.removed.length && (d = a.removed[l]); l++)
          r.removedNodes.push(d);
      for (let o = 0, a; o < t.length && (a = t[o]); o++)
        for (let l = a.index; l < a.index + a.addedCount; l++)
          r.addedNodes.push(e[l]);
      this._effectiveNodes = e;
      let i = !1;
      return (r.addedNodes.length || r.removedNodes.length) && (i = !0, this.callback.call(this._target, r)), i;
    }
    /**
     * @param {!Array<!Node>|!NodeList<!Node>} nodeList Nodes that could change
     * @return {void}
     * @private
     */
    _listenSlots(r) {
      for (let e = 0; e < r.length; e++) {
        let t = r[e];
        Ki(t) && t.addEventListener("slotchange", this._boundSchedule);
      }
    }
    /**
     * @param {!Array<!Node>|!NodeList<!Node>} nodeList Nodes that could change
     * @return {void}
     * @private
     */
    _unlistenSlots(r) {
      for (let e = 0; e < r.length; e++) {
        let t = r[e];
        Ki(t) && t.removeEventListener("slotchange", this._boundSchedule);
      }
    }
  };
  /**
  @license
  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */
  let md = !1, a$ = [], Tb = [];
  function l$() {
    md = !0, requestAnimationFrame(function() {
      md = !1, c$(a$), setTimeout(function() {
        d$(Tb);
      });
    });
  }
  function c$(r) {
    for (; r.length; )
      Ob(r.shift());
  }
  function d$(r) {
    for (let e = 0, t = r.length; e < t; e++)
      Ob(r.shift());
  }
  function Ob(r) {
    const e = r[0], t = r[1], i = r[2];
    try {
      t.apply(e, i);
    } catch (o) {
      setTimeout(() => {
        throw o;
      });
    }
  }
  function Db(r, e, t) {
    md || l$(), Tb.push([r, e, t]);
  }
  /**
  @license
  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */
  function du(r, e, t, i, o) {
    let a;
    o && (a = typeof t == "object" && t !== null, a && (i = r.__dataTemp[e]));
    let l = i !== t && (i === i || t === t);
    return a && l && (r.__dataTemp[e] = t), l;
  }
  const uu = Oe((r) => {
    class e extends r {
      /**
       * Overrides `PropertyEffects` to provide option for skipping
       * strict equality checking for Objects and Arrays.
       *
       * This method pulls the value to dirty check against from the `__dataTemp`
       * cache (rather than the normal `__data` cache) for Objects.  Since the temp
       * cache is cleared at the end of a turn, this implementation allows
       * side-effects of deep object changes to be processed by re-setting the
       * same object (using the temp cache as an in-turn backstop to prevent
       * cycles due to 2-way notification).
       *
       * @param {string} property Property name
       * @param {*} value New property value
       * @param {*} old Previous property value
       * @return {boolean} Whether the property should be considered a change
       * @protected
       */
      _shouldPropertyChange(i, o, a) {
        return du(this, i, o, a, !0);
      }
    }
    return e;
  }), u$ = Oe((r) => {
    class e extends r {
      /** @nocollapse */
      static get properties() {
        return {
          /**
           * Instance-level flag for configuring the dirty-checking strategy
           * for this element.  When true, Objects and Arrays will skip dirty
           * checking, otherwise strict equality checking will be used.
           */
          mutableData: Boolean
        };
      }
      /**
       * Overrides `PropertyEffects` to provide option for skipping
       * strict equality checking for Objects and Arrays.
       *
       * When `this.mutableData` is true on this instance, this method
       * pulls the value to dirty check against from the `__dataTemp` cache
       * (rather than the normal `__data` cache) for Objects.  Since the temp
       * cache is cleared at the end of a turn, this implementation allows
       * side-effects of deep object changes to be processed by re-setting the
       * same object (using the temp cache as an in-turn backstop to prevent
       * cycles due to 2-way notification).
       *
       * @param {string} property Property name
       * @param {*} value New property value
       * @param {*} old Previous property value
       * @return {boolean} Whether the property should be considered a change
       * @protected
       */
      _shouldPropertyChange(i, o, a) {
        return du(this, i, o, a, this.mutableData);
      }
    }
    return e;
  });
  uu._mutablePropertyChange = du;
  /**
  @license
  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */
  let bd = null;
  function _d() {
    return bd;
  }
  _d.prototype = Object.create(HTMLTemplateElement.prototype, {
    constructor: {
      value: _d,
      writable: !0
    }
  });
  const Pb = au(_d), h$ = uu(Pb);
  function f$(r, e) {
    bd = r, Object.setPrototypeOf(r, e.prototype), new e(), bd = null;
  }
  const p$ = au(class {
  });
  function g$(r, e) {
    for (let t = 0; t < e.length; t++) {
      let i = e[t];
      if (!!r != !!i.__hideTemplateChildren__)
        if (i.nodeType === Node.TEXT_NODE)
          r ? (i.__polymerTextContent__ = i.textContent, i.textContent = "") : i.textContent = i.__polymerTextContent__;
        else if (i.localName === "slot")
          if (r)
            i.__polymerReplaced__ = document.createComment("hidden-slot"), ye(ye(i).parentNode).replaceChild(i.__polymerReplaced__, i);
          else {
            const o = i.__polymerReplaced__;
            o && ye(ye(o).parentNode).replaceChild(i, o);
          }
        else i.style && (r ? (i.__polymerDisplay__ = i.style.display, i.style.display = "none") : i.style.display = i.__polymerDisplay__);
      i.__hideTemplateChildren__ = r, i._showHideChildren && i._showHideChildren(r);
    }
  }
  class Jr extends p$ {
    constructor(e) {
      super(), this._configureProperties(e), this.root = this._stampTemplate(this.__dataHost);
      let t = [];
      this.children = /** @type {!NodeList} */
      t;
      for (let o = this.root.firstChild; o; o = o.nextSibling)
        t.push(o), o.__templatizeInstance = this;
      this.__templatizeOwner && this.__templatizeOwner.__hideTemplateChildren__ && this._showHideChildren(!0);
      let i = this.__templatizeOptions;
      (e && i.instanceProps || !i.instanceProps) && this._enableProperties();
    }
    /**
     * Configure the given `props` by calling `_setPendingProperty`. Also
     * sets any properties stored in `__hostProps`.
     * @private
     * @param {Object} props Object of property name-value pairs to set.
     * @return {void}
     */
    _configureProperties(e) {
      if (this.__templatizeOptions.forwardHostProp)
        for (let i in this.__hostProps)
          this._setPendingProperty(i, this.__dataHost["_host_" + i]);
      for (let i in e)
        this._setPendingProperty(i, e[i]);
    }
    /**
     * Forwards a host property to this instance.  This method should be
     * called on instances from the `options.forwardHostProp` callback
     * to propagate changes of host properties to each instance.
     *
     * Note this method enqueues the change, which are flushed as a batch.
     *
     * @param {string} prop Property or path name
     * @param {*} value Value of the property to forward
     * @return {void}
     */
    forwardHostProp(e, t) {
      this._setPendingPropertyOrPath(e, t, !1, !0) && this.__dataHost._enqueueClient(this);
    }
    /**
     * Override point for adding custom or simulated event handling.
     *
     * @override
     * @param {!Node} node Node to add event listener to
     * @param {string} eventName Name of event
     * @param {function(!Event):void} handler Listener function to add
     * @return {void}
     */
    _addEventListenerToNode(e, t, i) {
      if (this._methodHost && this.__templatizeOptions.parentModel)
        this._methodHost._addEventListenerToNode(e, t, (o) => {
          o.model = this, i(o);
        });
      else {
        let o = this.__dataHost.__dataHost;
        o && o._addEventListenerToNode(e, t, i);
      }
    }
    /**
     * Shows or hides the template instance top level child elements. For
     * text nodes, `textContent` is removed while "hidden" and replaced when
     * "shown."
     * @param {boolean} hide Set to true to hide the children;
     * set to false to show them.
     * @return {void}
     * @protected
     */
    _showHideChildren(e) {
      g$(e, this.children);
    }
    /**
     * Overrides default property-effects implementation to intercept
     * textContent bindings while children are "hidden" and cache in
     * private storage for later retrieval.
     *
     * @override
     * @param {!Node} node The node to set a property on
     * @param {string} prop The property to set
     * @param {*} value The value to set
     * @return {void}
     * @protected
     */
    _setUnmanagedPropertyToNode(e, t, i) {
      e.__hideTemplateChildren__ && e.nodeType == Node.TEXT_NODE && t == "textContent" ? e.__polymerTextContent__ = i : super._setUnmanagedPropertyToNode(e, t, i);
    }
    /**
     * Find the parent model of this template instance.  The parent model
     * is either another templatize instance that had option `parentModel: true`,
     * or else the host element.
     *
     * @return {!Polymer_PropertyEffects} The parent model of this instance
     */
    get parentModel() {
      let e = this.__parentModel;
      if (!e) {
        let t;
        e = this;
        do
          e = e.__dataHost.__dataHost;
        while ((t = e.__templatizeOptions) && !t.parentModel);
        this.__parentModel = e;
      }
      return e;
    }
    /**
     * Stub of HTMLElement's `dispatchEvent`, so that effects that may
     * dispatch events safely no-op.
     *
     * @param {Event} event Event to dispatch
     * @return {boolean} Always true.
     * @override
     */
    dispatchEvent(e) {
      return !0;
    }
  }
  Jr.prototype.__dataHost;
  Jr.prototype.__templatizeOptions;
  Jr.prototype._methodHost;
  Jr.prototype.__templatizeOwner;
  Jr.prototype.__hostProps;
  const m$ = uu(
    // This cast shouldn't be neccessary, but Closure doesn't understand that
    // TemplateInstanceBase is a constructor function.
    /** @type {function(new:TemplateInstanceBase)} */
    Jr
  );
  function ag(r) {
    let e = r.__dataHost;
    return e && e._methodHost || e;
  }
  function b$(r, e, t) {
    let i = t.mutableData ? m$ : Jr;
    Hn.mixin && (i = Hn.mixin(i));
    let o = class extends i {
    };
    return o.prototype.__templatizeOptions = t, o.prototype._bindTemplate(r), y$(o, r, e, t), o;
  }
  function _$(r, e, t, i) {
    let o = t.forwardHostProp;
    if (o && e.hasHostProps) {
      const a = r.localName == "template";
      let l = e.templatizeTemplateClass;
      if (!l) {
        if (a) {
          let u = t.mutableData ? h$ : Pb;
          class f extends u {
          }
          l = e.templatizeTemplateClass = f;
        } else {
          const u = r.constructor;
          class f extends u {
          }
          l = e.templatizeTemplateClass = f;
        }
        let d = e.hostProps;
        for (let u in d)
          l.prototype._addPropertyEffect(
            "_host_" + u,
            l.prototype.PROPERTY_EFFECT_TYPES.PROPAGATE,
            { fn: v$(u, o) }
          ), l.prototype._createNotifyingProperty("_host_" + u);
        ib && i && x$(e, t, i);
      }
      if (r.__dataProto && Object.assign(r.__data, r.__dataProto), a)
        f$(r, l), r.__dataTemp = {}, r.__dataPending = null, r.__dataOld = null, r._enableProperties();
      else {
        Object.setPrototypeOf(r, l.prototype);
        const d = e.hostProps;
        for (let u in d)
          if (u = "_host_" + u, u in r) {
            const f = r[u];
            delete r[u], r.__data[u] = f;
          }
      }
    }
  }
  function v$(r, e) {
    return function(i, o, a) {
      e.call(
        i.__templatizeOwner,
        o.substring(6),
        a[o]
      );
    };
  }
  function y$(r, e, t, i) {
    let o = t.hostProps || {};
    for (let a in i.instanceProps) {
      delete o[a];
      let l = i.notifyInstanceProp;
      l && r.prototype._addPropertyEffect(
        a,
        r.prototype.PROPERTY_EFFECT_TYPES.NOTIFY,
        { fn: w$(a, l) }
      );
    }
    if (i.forwardHostProp && e.__dataHost)
      for (let a in o)
        t.hasHostProps || (t.hasHostProps = !0), r.prototype._addPropertyEffect(
          a,
          r.prototype.PROPERTY_EFFECT_TYPES.NOTIFY,
          { fn: k$() }
        );
  }
  function w$(r, e) {
    return function(i, o, a) {
      e.call(
        i.__templatizeOwner,
        i,
        o,
        a[o]
      );
    };
  }
  function k$() {
    return function(e, t, i) {
      e.__dataHost._setPendingPropertyOrPath("_host_" + t, i[t], !0, !0);
    };
  }
  function Hn(r, e, t) {
    if (ka && !ag(r))
      throw new Error("strictTemplatePolicy: template owner not trusted");
    if (t = /** @type {!TemplatizeOptions} */
    t || {}, r.__templatizeOwner)
      throw new Error("A <template> can only be templatized once");
    r.__templatizeOwner = e;
    let o = (e ? e.constructor : Jr)._parseTemplate(r), a = o.templatizeInstanceClass;
    a || (a = b$(r, o, t), o.templatizeInstanceClass = a);
    const l = ag(r);
    _$(r, o, t, l);
    let d = class extends a {
    };
    return d.prototype._methodHost = l, d.prototype.__dataHost = /** @type {!DataTemplate} */
    r, d.prototype.__templatizeOwner = /** @type {!Object} */
    e, d.prototype.__hostProps = o.hostProps, d = /** @type {function(new:TemplateInstanceBase)} */
    d, d;
  }
  function x$(r, e, t) {
    const i = t.constructor._properties, { propertyEffects: o } = r, { instanceProps: a } = e;
    for (let l in o)
      if (!i[l] && !(a && a[l])) {
        const d = o[l];
        for (let u = 0; u < d.length; u++) {
          const { part: f } = d[u].info;
          if (!(f.signature && f.signature.static))
            break;
        }
      }
  }
  function C$(r, e) {
    let t;
    for (; e; )
      if (t = e.__dataHost ? e : e.__templatizeInstance)
        if (t.__dataHost != r)
          e = t.__dataHost;
        else
          return t;
      else
        e = ye(e).parentNode;
    return null;
  }
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  const za = (r) => r.test(navigator.userAgent), vd = (r) => r.test(navigator.platform), S$ = (r) => r.test(navigator.vendor);
  za(/Android/);
  za(/Chrome/) && S$(/Google Inc/);
  const A$ = za(/Firefox/), E$ = vd(/^iPad/) || vd(/^Mac/) && navigator.maxTouchPoints > 1, $$ = vd(/^iPhone/), Ib = $$ || E$;
  za(/^((?!chrome|android).)*safari/i);
  const T$ = (() => {
    try {
      return document.createEvent("TouchEvent"), !0;
    } catch {
      return !1;
    }
  })();
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  const Oi = Oe(
    (r) => class extends r {
      constructor() {
        super(), this.__controllers = /* @__PURE__ */ new Set();
      }
      /** @protected */
      connectedCallback() {
        super.connectedCallback(), this.__controllers.forEach((t) => {
          t.hostConnected && t.hostConnected();
        });
      }
      /** @protected */
      disconnectedCallback() {
        super.disconnectedCallback(), this.__controllers.forEach((t) => {
          t.hostDisconnected && t.hostDisconnected();
        });
      }
      /**
       * Registers a controller to participate in the element update cycle.
       *
       * @param {ReactiveController} controller
       * @protected
       */
      addController(t) {
        this.__controllers.add(t), this.$ !== void 0 && this.isConnected && t.hostConnected && t.hostConnected();
      }
      /**
       * Removes a controller from the element.
       *
       * @param {ReactiveController} controller
       * @protected
       */
      removeController(t) {
        this.__controllers.delete(t);
      }
    }
  );
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  let hu = !1;
  window.addEventListener(
    "keydown",
    () => {
      hu = !0;
    },
    { capture: !0 }
  );
  window.addEventListener(
    "mousedown",
    () => {
      hu = !1;
    },
    { capture: !0 }
  );
  function O$() {
    return hu;
  }
  function Mb(r) {
    const e = r.style;
    if (e.visibility === "hidden" || e.display === "none")
      return !0;
    const t = window.getComputedStyle(r);
    return t.visibility === "hidden" || t.display === "none";
  }
  function D$(r) {
    if (!M$(r))
      return -1;
    const e = r.getAttribute("tabindex") || 0;
    return Number(e);
  }
  function P$(r, e) {
    const t = Math.max(r.tabIndex, 0), i = Math.max(e.tabIndex, 0);
    return t === 0 || i === 0 ? i > t : t > i;
  }
  function I$(r, e) {
    const t = [];
    for (; r.length > 0 && e.length > 0; )
      P$(r[0], e[0]) ? t.push(e.shift()) : t.push(r.shift());
    return t.concat(r, e);
  }
  function yd(r) {
    const e = r.length;
    if (e < 2)
      return r;
    const t = Math.ceil(e / 2), i = yd(r.slice(0, t)), o = yd(r.slice(t));
    return I$(i, o);
  }
  function Nb(r, e) {
    if (r.nodeType !== Node.ELEMENT_NODE || Mb(r))
      return !1;
    const t = (
      /** @type {HTMLElement} */
      r
    ), i = D$(t);
    let o = i > 0;
    i >= 0 && e.push(t);
    let a = [];
    return t.localName === "slot" ? a = t.assignedNodes({ flatten: !0 }) : a = (t.shadowRoot || t).children, [...a].forEach((l) => {
      o = Nb(l, e) || o;
    }), o;
  }
  function lg(r) {
    return r.offsetParent === null && r.clientWidth === 0 && r.clientHeight === 0 ? !0 : Mb(r);
  }
  function M$(r) {
    return r.matches('[tabindex="-1"]') ? !1 : r.matches("input, select, textarea, button, object") ? r.matches(":not([disabled])") : r.matches("a[href], area[href], iframe, [tabindex], [contentEditable]");
  }
  function Lb(r) {
    return r.getRootNode().activeElement === r;
  }
  function N$(r) {
    const e = [];
    return Nb(r, e) ? yd(e) : e;
  }
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  const Oc = [];
  class L$ {
    /**
     * @param {HTMLElement} host
     */
    constructor(e) {
      this.host = e, this.__trapNode = null, this.__onKeyDown = this.__onKeyDown.bind(this);
    }
    hostConnected() {
      document.addEventListener("keydown", this.__onKeyDown);
    }
    hostDisconnected() {
      document.removeEventListener("keydown", this.__onKeyDown);
    }
    /**
     * Activates a focus trap for a DOM node that will prevent focus from escaping the node.
     * The trap can be deactivated with the `.releaseFocus()` method.
     *
     * If focus is initially outside the trap, the method will move focus inside,
     * on the first focusable element of the trap in the tab order.
     * The first focusable element can be the trap node itself if it is focusable
     * and comes first in the tab order.
     *
     * If there are no focusable elements, the method will throw an exception
     * and the trap will not be set.
     *
     * @param {HTMLElement} trapNode
     */
    trapFocus(e) {
      if (this.__trapNode = e, this.__focusableElements.length === 0)
        throw this.__trapNode = null, new Error("The trap node should have at least one focusable descendant or be focusable itself.");
      Oc.push(this), this.__focusedElementIndex === -1 && this.__focusableElements[0].focus();
    }
    /**
     * Deactivates the focus trap set with the `.trapFocus()` method
     * so that it becomes possible to tab outside the trap node.
     */
    releaseFocus() {
      this.__trapNode = null, Oc.pop();
    }
    /**
     * A `keydown` event handler that manages tabbing navigation when the trap is enabled.
     *
     * - Moves focus to the next focusable element of the trap on `Tab` press.
     * When no next element to focus, the method moves focus to the first focusable element.
     * - Moves focus to the prev focusable element of the trap on `Shift+Tab` press.
     * When no prev element to focus, the method moves focus to the last focusable element.
     *
     * @param {KeyboardEvent} event
     * @private
     */
    __onKeyDown(e) {
      if (this.__trapNode && this === Array.from(Oc).pop() && e.key === "Tab") {
        e.preventDefault();
        const t = e.shiftKey;
        this.__focusNextElement(t);
      }
    }
    /**
     * - Moves focus to the next focusable element if `backward === false`.
     * When no next element to focus, the method moves focus to the first focusable element.
     * - Moves focus to the prev focusable element if `backward === true`.
     * When no prev element to focus the method moves focus to the last focusable element.
     *
     * If no focusable elements, the method returns immediately.
     *
     * @param {boolean} backward
     * @private
     */
    __focusNextElement(e = !1) {
      const t = this.__focusableElements, i = e ? -1 : 1, o = this.__focusedElementIndex, a = (t.length + o + i) % t.length, l = t[a];
      l.focus(), l.localName === "input" && l.select();
    }
    /**
     * An array of tab-ordered focusable elements inside the trap node.
     *
     * @return {HTMLElement[]}
     * @private
     */
    get __focusableElements() {
      return N$(this.__trapNode);
    }
    /**
     * The index of the element inside the trap node that currently has focus.
     *
     * @return {HTMLElement | undefined}
     * @private
     */
    get __focusedElementIndex() {
      const e = this.__focusableElements;
      return e.indexOf(e.filter(Lb).pop());
    }
  }
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  class wr extends Kr(Kn(Oi(Gt))) {
    static get template() {
      return Ar`
      <style>
        :host {
          z-index: 200;
          position: fixed;

          /* Despite of what the names say, <vaadin-overlay> is just a container
          for position/sizing/alignment. The actual overlay is the overlay part. */

          /* Default position constraints: the entire viewport. Note: themes can
          override this to introduce gaps between the overlay and the viewport. */
          top: 0;
          right: 0;
          bottom: var(--vaadin-overlay-viewport-bottom);
          left: 0;

          /* Use flexbox alignment for the overlay part. */
          display: flex;
          flex-direction: column; /* makes dropdowns sizing easier */
          /* Align to center by default. */
          align-items: center;
          justify-content: center;

          /* Allow centering when max-width/max-height applies. */
          margin: auto;

          /* The host is not clickable, only the overlay part is. */
          pointer-events: none;

          /* Remove tap highlight on touch devices. */
          -webkit-tap-highlight-color: transparent;

          /* CSS API for host */
          --vaadin-overlay-viewport-bottom: 0;
        }

        :host([hidden]),
        :host(:not([opened]):not([closing])),
        :host(:not([opened]):not([closing])) [part='overlay'] {
          display: none !important;
        }

        [part='overlay'] {
          -webkit-overflow-scrolling: touch;
          overflow: auto;
          pointer-events: auto;

          /* Prevent overflowing the host in MSIE 11 */
          max-width: 100%;
          box-sizing: border-box;

          -webkit-tap-highlight-color: initial; /* reenable tap highlight inside */
        }

        [part='backdrop'] {
          z-index: -1;
          content: '';
          background: rgba(0, 0, 0, 0.5);
          position: fixed;
          top: 0;
          left: 0;
          bottom: 0;
          right: 0;
          pointer-events: auto;
        }
      </style>

      <div id="backdrop" part="backdrop" hidden$="[[!withBackdrop]]"></div>
      <div part="overlay" id="overlay" tabindex="0">
        <div part="content" id="content">
          <slot></slot>
        </div>
      </div>
    `;
    }
    static get is() {
      return "vaadin-overlay";
    }
    static get properties() {
      return {
        /**
         * When true, the overlay is visible and attached to body.
         */
        opened: {
          type: Boolean,
          notify: !0,
          observer: "_openedChanged",
          reflectToAttribute: !0
        },
        /**
         * Owner element passed with renderer function
         * @type {HTMLElement}
         */
        owner: Element,
        /**
         * Custom function for rendering the content of the overlay.
         * Receives three arguments:
         *
         * - `root` The root container DOM element. Append your content to it.
         * - `owner` The host element of the renderer function.
         * - `model` The object with the properties related with rendering.
         * @type {OverlayRenderer | null | undefined}
         */
        renderer: Function,
        /**
         * The template of the overlay content.
         * @type {HTMLTemplateElement | null | undefined}
         */
        template: {
          type: Object,
          notify: !0
        },
        /**
         * References the content container after the template is stamped.
         * @type {!HTMLElement | undefined}
         */
        content: {
          type: Object,
          notify: !0
        },
        /**
         * When true the overlay has backdrop on top of content when opened.
         * @type {boolean}
         */
        withBackdrop: {
          type: Boolean,
          value: !1,
          reflectToAttribute: !0
        },
        /**
         * Object with properties that is passed to `renderer` function
         */
        model: Object,
        /**
         * When true the overlay won't disable the main content, showing
         * it doesn’t change the functionality of the user interface.
         * @type {boolean}
         */
        modeless: {
          type: Boolean,
          value: !1,
          reflectToAttribute: !0,
          observer: "_modelessChanged"
        },
        /**
         * When set to true, the overlay is hidden. This also closes the overlay
         * immediately in case there is a closing animation in progress.
         * @type {boolean}
         */
        hidden: {
          type: Boolean,
          reflectToAttribute: !0,
          observer: "_hiddenChanged"
        },
        /**
         * When true move focus to the first focusable element in the overlay,
         * or to the overlay if there are no focusable elements.
         * @type {boolean}
         */
        focusTrap: {
          type: Boolean,
          value: !1
        },
        /**
         * Set to true to enable restoring of focus when overlay is closed.
         * @type {boolean}
         */
        restoreFocusOnClose: {
          type: Boolean,
          value: !1
        },
        /**
         * Set to specify the element which should be focused on overlay close,
         * if `restoreFocusOnClose` is set to true.
         * @type {HTMLElement}
         */
        restoreFocusNode: {
          type: HTMLElement
        },
        /** @private */
        _mouseDownInside: {
          type: Boolean
        },
        /** @private */
        _mouseUpInside: {
          type: Boolean
        },
        /** @private */
        _instance: {
          type: Object
        },
        /** @private */
        _originalContentPart: Object,
        /** @private */
        _contentNodes: Array,
        /** @private */
        _oldOwner: Element,
        /** @private */
        _oldModel: Object,
        /** @private */
        _oldTemplate: Object,
        /** @private */
        _oldRenderer: Object,
        /** @private */
        _oldOpened: Boolean
      };
    }
    static get observers() {
      return ["_templateOrRendererChanged(template, renderer, owner, model, opened)"];
    }
    constructor() {
      super(), this._boundMouseDownListener = this._mouseDownListener.bind(this), this._boundMouseUpListener = this._mouseUpListener.bind(this), this._boundOutsideClickListener = this._outsideClickListener.bind(this), this._boundKeydownListener = this._keydownListener.bind(this), this._observer = new Ca(this, (e) => {
        this._setTemplateFromNodes(e.addedNodes);
      }), this._boundIronOverlayCanceledListener = this._ironOverlayCanceled.bind(this), Ib && (this._boundIosResizeListener = () => this._detectIosNavbar()), this.__focusTrapController = new L$(this);
    }
    /** @protected */
    ready() {
      super.ready(), this._observer.flush(), this.addEventListener("click", () => {
      }), this.$.backdrop.addEventListener("click", () => {
      }), this.addEventListener("mouseup", () => {
        document.activeElement === document.body && this.$.overlay.getAttribute("tabindex") === "0" && this.$.overlay.focus();
      }), this.addController(this.__focusTrapController);
    }
    /** @private */
    _detectIosNavbar() {
      if (!this.opened)
        return;
      const e = window.innerHeight, i = window.innerWidth > e, o = document.documentElement.clientHeight;
      i && o > e ? this.style.setProperty("--vaadin-overlay-viewport-bottom", `${o - e}px`) : this.style.setProperty("--vaadin-overlay-viewport-bottom", "0");
    }
    /**
     * @param {!Array<!Element>} nodes
     * @protected
     */
    _setTemplateFromNodes(e) {
      this.template = e.find((t) => t.localName && t.localName === "template") || this.template;
    }
    /**
     * @param {Event=} sourceEvent
     * @event vaadin-overlay-close
     * fired before the `vaadin-overlay` will be closed. If canceled the closing of the overlay is canceled as well.
     */
    close(e) {
      const t = new CustomEvent("vaadin-overlay-close", {
        bubbles: !0,
        cancelable: !0,
        detail: { sourceEvent: e }
      });
      this.dispatchEvent(t), t.defaultPrevented || (this.opened = !1);
    }
    /** @protected */
    connectedCallback() {
      super.connectedCallback(), this._boundIosResizeListener && (this._detectIosNavbar(), window.addEventListener("resize", this._boundIosResizeListener));
    }
    /** @protected */
    disconnectedCallback() {
      super.disconnectedCallback(), this._boundIosResizeListener && window.removeEventListener("resize", this._boundIosResizeListener);
    }
    /**
     * Requests an update for the content of the overlay.
     * While performing the update, it invokes the renderer passed in the `renderer` property.
     *
     * It is not guaranteed that the update happens immediately (synchronously) after it is requested.
     */
    requestContentUpdate() {
      this.renderer && this.renderer.call(this.owner, this.content, this.owner, this.model);
    }
    /** @private */
    _ironOverlayCanceled(e) {
      e.preventDefault();
    }
    /** @private */
    _mouseDownListener(e) {
      this._mouseDownInside = e.composedPath().indexOf(this.$.overlay) >= 0;
    }
    /** @private */
    _mouseUpListener(e) {
      this._mouseUpInside = e.composedPath().indexOf(this.$.overlay) >= 0;
    }
    /**
     * We need to listen on 'click' / 'tap' event and capture it and close the overlay before
     * propagating the event to the listener in the button. Otherwise, if the clicked button would call
     * open(), this would happen: https://www.youtube.com/watch?v=Z86V_ICUCD4
     *
     * @event vaadin-overlay-outside-click
     * fired before the `vaadin-overlay` will be closed on outside click. If canceled the closing of the overlay is canceled as well.
     *
     * @private
     */
    _outsideClickListener(e) {
      if (e.composedPath().includes(this.$.overlay) || this._mouseDownInside || this._mouseUpInside) {
        this._mouseDownInside = !1, this._mouseUpInside = !1;
        return;
      }
      if (!this._last)
        return;
      const t = new CustomEvent("vaadin-overlay-outside-click", {
        bubbles: !0,
        cancelable: !0,
        detail: { sourceEvent: e }
      });
      this.dispatchEvent(t), this.opened && !t.defaultPrevented && this.close(e);
    }
    /**
     * @event vaadin-overlay-escape-press
     * fired before the `vaadin-overlay` will be closed on ESC button press. If canceled the closing of the overlay is canceled as well.
     *
     * @private
     */
    _keydownListener(e) {
      if (this._last && !(this.modeless && !e.composedPath().includes(this.$.overlay)) && e.key === "Escape") {
        const t = new CustomEvent("vaadin-overlay-escape-press", {
          bubbles: !0,
          cancelable: !0,
          detail: { sourceEvent: e }
        });
        this.dispatchEvent(t), this.opened && !t.defaultPrevented && this.close(e);
      }
    }
    /** @protected */
    _ensureTemplatized() {
      this._setTemplateFromNodes(Array.from(this.children));
    }
    /**
     * @event vaadin-overlay-open
     * fired after the `vaadin-overlay` is opened.
     *
     * @private
     */
    _openedChanged(e, t) {
      this._instance || this._ensureTemplatized(), e ? (this.__restoreFocusNode = this._getActiveElement(), this._animatedOpening(), Db(this, () => {
        this.focusTrap && this.__focusTrapController.trapFocus(this.$.overlay);
        const i = new CustomEvent("vaadin-overlay-open", { bubbles: !0 });
        this.dispatchEvent(i);
      }), document.addEventListener("keydown", this._boundKeydownListener), this.modeless || this._addGlobalListeners()) : t && (this.focusTrap && this.__focusTrapController.releaseFocus(), this._animatedClosing(), document.removeEventListener("keydown", this._boundKeydownListener), this.modeless || this._removeGlobalListeners());
    }
    /** @private */
    _hiddenChanged(e) {
      e && this.hasAttribute("closing") && this._flushAnimation("closing");
    }
    /**
     * @return {boolean}
     * @protected
     */
    _shouldAnimate() {
      const e = getComputedStyle(this).getPropertyValue("animation-name");
      return !(getComputedStyle(this).getPropertyValue("display") === "none") && e && e !== "none";
    }
    /**
     * @param {string} type
     * @param {Function} callback
     * @protected
     */
    _enqueueAnimation(e, t) {
      const i = `__${e}Handler`, o = (a) => {
        a && a.target !== this || (t(), this.removeEventListener("animationend", o), delete this[i]);
      };
      this[i] = o, this.addEventListener("animationend", o);
    }
    /**
     * @param {string} type
     * @protected
     */
    _flushAnimation(e) {
      const t = `__${e}Handler`;
      typeof this[t] == "function" && this[t]();
    }
    /** @protected */
    _animatedOpening() {
      this.parentNode === document.body && this.hasAttribute("closing") && this._flushAnimation("closing"), this._attachOverlay(), this.modeless || this._enterModalState(), this.setAttribute("opening", ""), this._shouldAnimate() ? this._enqueueAnimation("opening", () => {
        this._finishOpening();
      }) : this._finishOpening();
    }
    /** @protected */
    _attachOverlay() {
      this._placeholder = document.createComment("vaadin-overlay-placeholder"), this.parentNode.insertBefore(this._placeholder, this), document.body.appendChild(this), this.bringToFront();
    }
    /** @protected */
    _finishOpening() {
      document.addEventListener("iron-overlay-canceled", this._boundIronOverlayCanceledListener), this.removeAttribute("opening");
    }
    /** @protected */
    _finishClosing() {
      document.removeEventListener("iron-overlay-canceled", this._boundIronOverlayCanceledListener), this._detachOverlay(), this.$.overlay.style.removeProperty("pointer-events"), this.removeAttribute("closing");
    }
    /**
     * @event vaadin-overlay-closing
     * Fired when the overlay will be closed.
     *
     * @protected
     */
    _animatedClosing() {
      if (this.hasAttribute("opening") && this._flushAnimation("opening"), this._placeholder) {
        this._exitModalState();
        const e = this.restoreFocusNode || this.__restoreFocusNode;
        if (this.restoreFocusOnClose && e) {
          const t = this._getActiveElement();
          (t === document.body || this._deepContains(t)) && setTimeout(() => e.focus()), this.__restoreFocusNode = null;
        }
        this.setAttribute("closing", ""), this.dispatchEvent(new CustomEvent("vaadin-overlay-closing")), this._shouldAnimate() ? this._enqueueAnimation("closing", () => {
          this._finishClosing();
        }) : this._finishClosing();
      }
    }
    /** @protected */
    _detachOverlay() {
      this._placeholder.parentNode.insertBefore(this, this._placeholder), this._placeholder.parentNode.removeChild(this._placeholder);
    }
    /**
     * Returns all attached overlays in visual stacking order.
     * @private
     */
    static get __attachedInstances() {
      return Array.from(document.body.children).filter((e) => e instanceof wr && !e.hasAttribute("closing")).sort((e, t) => e.__zIndex - t.__zIndex || 0);
    }
    /**
     * Returns true if this is the last one in the opened overlays stack
     * @return {boolean}
     * @protected
     */
    get _last() {
      return this === wr.__attachedInstances.pop();
    }
    /** @private */
    _modelessChanged(e) {
      e ? (this._removeGlobalListeners(), this._exitModalState()) : this.opened && (this._addGlobalListeners(), this._enterModalState());
    }
    /** @protected */
    _addGlobalListeners() {
      document.addEventListener("mousedown", this._boundMouseDownListener), document.addEventListener("mouseup", this._boundMouseUpListener), document.documentElement.addEventListener("click", this._boundOutsideClickListener, !0);
    }
    /** @protected */
    _enterModalState() {
      document.body.style.pointerEvents !== "none" && (this._previousDocumentPointerEvents = document.body.style.pointerEvents, document.body.style.pointerEvents = "none"), wr.__attachedInstances.forEach((e) => {
        e !== this && (e.shadowRoot.querySelector('[part="overlay"]').style.pointerEvents = "none");
      });
    }
    /** @protected */
    _removeGlobalListeners() {
      document.removeEventListener("mousedown", this._boundMouseDownListener), document.removeEventListener("mouseup", this._boundMouseUpListener), document.documentElement.removeEventListener("click", this._boundOutsideClickListener, !0);
    }
    /** @protected */
    _exitModalState() {
      this._previousDocumentPointerEvents !== void 0 && (document.body.style.pointerEvents = this._previousDocumentPointerEvents, delete this._previousDocumentPointerEvents);
      const e = wr.__attachedInstances;
      let t;
      for (; (t = e.pop()) && !(t !== this && (t.shadowRoot.querySelector('[part="overlay"]').style.removeProperty("pointer-events"), !t.modeless)); )
        ;
    }
    /** @protected */
    _removeOldContent() {
      !this.content || !this._contentNodes || (this._observer.disconnect(), this._contentNodes.forEach((e) => {
        e.parentNode === this.content && this.content.removeChild(e);
      }), this._originalContentPart && (this.$.content.parentNode.replaceChild(this._originalContentPart, this.$.content), this.$.content = this._originalContentPart, this._originalContentPart = void 0), this._observer.connect(), this._contentNodes = void 0, this.content = void 0);
    }
    /**
     * @param {!HTMLTemplateElement} template
     * @protected
     */
    _stampOverlayTemplate(e) {
      this._removeOldContent(), e._Templatizer || (e._Templatizer = Hn(e, this, {
        forwardHostProp(i, o) {
          this._instance && this._instance.forwardHostProp(i, o);
        }
      })), this._instance = new e._Templatizer({}), this._contentNodes = Array.from(this._instance.root.childNodes);
      const t = e._templateRoot || (e._templateRoot = e.getRootNode());
      if (t !== document) {
        this.$.content.shadowRoot || this.$.content.attachShadow({ mode: "open" });
        let i = Array.from(t.querySelectorAll("style")).reduce(
          (o, a) => o + a.textContent,
          ""
        );
        if (i = i.replace(/:host/g, ":host-nomatch"), i) {
          const o = document.createElement("style");
          o.textContent = i, this.$.content.shadowRoot.appendChild(o), this._contentNodes.unshift(o);
        }
        this.$.content.shadowRoot.appendChild(this._instance.root), this.content = this.$.content.shadowRoot;
      } else
        this.appendChild(this._instance.root), this.content = this;
    }
    /** @private */
    _removeNewRendererOrTemplate(e, t, i, o) {
      e !== t ? this.template = void 0 : i !== o && (this.renderer = void 0);
    }
    /** @private */
    // eslint-disable-next-line max-params
    _templateOrRendererChanged(e, t, i, o, a) {
      if (e && t)
        throw this._removeNewRendererOrTemplate(e, this._oldTemplate, t, this._oldRenderer), new Error("You should only use either a renderer or a template for overlay content");
      const l = this._oldOwner !== i || this._oldModel !== o;
      this._oldModel = o, this._oldOwner = i;
      const d = this._oldTemplate !== e;
      this._oldTemplate = e;
      const u = this._oldRenderer !== t;
      this._oldRenderer = t;
      const f = this._oldOpened !== a;
      this._oldOpened = a, u && (this.content = this, this.content.innerHTML = "", delete this.content._$litPart$), e && d ? this._stampOverlayTemplate(e) : t && (u || f || l) && a && this.requestContentUpdate();
    }
    /**
     * @return {!Element}
     * @protected
     */
    _getActiveElement() {
      let e = document.activeElement || document.body;
      for (; e.shadowRoot && e.shadowRoot.activeElement; )
        e = e.shadowRoot.activeElement;
      return e;
    }
    /**
     * @param {!Node} node
     * @return {boolean}
     * @protected
     */
    _deepContains(e) {
      if (this.contains(e))
        return !0;
      let t = e;
      const i = e.ownerDocument;
      for (; t && t !== i && t !== this; )
        t = t.parentNode || t.host;
      return t === this;
    }
    /**
     * Brings the overlay as visually the frontmost one
     */
    bringToFront() {
      let e = "";
      const t = wr.__attachedInstances.filter((i) => i !== this).pop();
      t && (e = t.__zIndex + 1), this.style.zIndex = e, this.__zIndex = e || parseFloat(getComputedStyle(this).zIndex);
    }
  }
  customElements.define(wr.is, wr);
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  const Rb = me`
  :host([opening]),
  :host([closing]) {
    animation: 0.14s lumo-overlay-dummy-animation;
  }

  [part='overlay'] {
    will-change: opacity, transform;
  }

  :host([opening]) [part='overlay'] {
    animation: 0.1s lumo-menu-overlay-enter ease-out both;
  }

  @keyframes lumo-menu-overlay-enter {
    0% {
      opacity: 0;
      transform: translateY(-4px);
    }
  }

  :host([closing]) [part='overlay'] {
    animation: 0.1s lumo-menu-overlay-exit both;
  }

  @keyframes lumo-menu-overlay-exit {
    100% {
      opacity: 0;
    }
  }
`;
  Te("", Rb, { moduleId: "lumo-menu-overlay-core" });
  const R$ = me`
  /* Small viewport (bottom sheet) styles */
  /* Use direct media queries instead of the state attributes ([phone] and [fullscreen]) provided by the elements */
  @media (max-width: 420px), (max-height: 420px) {
    :host {
      top: 0 !important;
      right: 0 !important;
      bottom: var(--vaadin-overlay-viewport-bottom, 0) !important;
      left: 0 !important;
      align-items: stretch !important;
      justify-content: flex-end !important;
    }

    [part='overlay'] {
      max-height: 50vh;
      width: 100vw;
      border-radius: 0;
      box-shadow: var(--lumo-box-shadow-xl);
    }

    /* The content part scrolls instead of the overlay part, because of the gradient fade-out */
    [part='content'] {
      padding: 30px var(--lumo-space-m);
      max-height: inherit;
      box-sizing: border-box;
      -webkit-overflow-scrolling: touch;
      overflow: auto;
      -webkit-mask-image: linear-gradient(transparent, #000 40px, #000 calc(100% - 40px), transparent);
      mask-image: linear-gradient(transparent, #000 40px, #000 calc(100% - 40px), transparent);
    }

    [part='backdrop'] {
      display: block;
    }

    /* Animations */

    :host([opening]) [part='overlay'] {
      animation: 0.2s lumo-mobile-menu-overlay-enter cubic-bezier(0.215, 0.61, 0.355, 1) both;
    }

    :host([closing]),
    :host([closing]) [part='backdrop'] {
      animation-delay: 0.14s;
    }

    :host([closing]) [part='overlay'] {
      animation: 0.14s 0.14s lumo-mobile-menu-overlay-exit cubic-bezier(0.55, 0.055, 0.675, 0.19) both;
    }
  }

  @keyframes lumo-mobile-menu-overlay-enter {
    0% {
      transform: translateY(150%);
    }
  }

  @keyframes lumo-mobile-menu-overlay-exit {
    100% {
      transform: translateY(150%);
    }
  }
`, Fb = [lu, Rb, R$];
  Te("", Fb, { moduleId: "lumo-menu-overlay" });
  const F$ = me`
  [part='overlay'] {
    /*
  Width:
      date cell widths
    + month calendar side padding
    + year scroller width
  */
    /* prettier-ignore */
    width:
    calc(
        var(--lumo-size-m) * 7
      + var(--lumo-space-xs) * 2
      + 57px
    );
    height: 100%;
    max-height: calc(var(--lumo-size-m) * 14);
    overflow: hidden;
    -webkit-tap-highlight-color: transparent;
  }

  [part='overlay'] {
    flex-direction: column;
  }

  [part='content'] {
    padding: 0;
    height: 100%;
    overflow: hidden;
    -webkit-mask-image: none;
    mask-image: none;
  }

  :host([top-aligned]) [part~='overlay'] {
    margin-top: var(--lumo-space-xs);
  }

  :host([bottom-aligned]) [part~='overlay'] {
    margin-bottom: var(--lumo-space-xs);
  }

  @media (max-width: 420px), (max-height: 420px) {
    [part='overlay'] {
      width: 100vw;
      height: 70vh;
      max-height: 70vh;
    }
  }
`;
  Te("vaadin-date-picker-overlay", [Fb, F$], {
    moduleId: "lumo-date-picker-overlay"
  });
  const z$ = me`
  :host {
    /* Sizing */
    --lumo-button-size: var(--lumo-size-m);
    min-width: calc(var(--lumo-button-size) * 2);
    height: var(--lumo-button-size);
    padding: 0 calc(var(--lumo-button-size) / 3 + var(--lumo-border-radius-m) / 2);
    margin: var(--lumo-space-xs) 0;
    box-sizing: border-box;
    /* Style */
    font-family: var(--lumo-font-family);
    font-size: var(--lumo-font-size-m);
    font-weight: 500;
    color: var(--_lumo-button-color, var(--lumo-primary-text-color));
    background-color: var(--_lumo-button-background-color, var(--lumo-contrast-5pct));
    border-radius: var(--lumo-border-radius-m);
    cursor: var(--lumo-clickable-cursor);
    -webkit-tap-highlight-color: transparent;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }

  /* Set only for the internal parts so we don't affect the host vertical alignment */
  [part='label'],
  [part='prefix'],
  [part='suffix'] {
    line-height: var(--lumo-line-height-xs);
  }

  [part='label'] {
    padding: calc(var(--lumo-button-size) / 6) 0;
  }

  :host([theme~='small']) {
    font-size: var(--lumo-font-size-s);
    --lumo-button-size: var(--lumo-size-s);
  }

  :host([theme~='large']) {
    font-size: var(--lumo-font-size-l);
    --lumo-button-size: var(--lumo-size-l);
  }

  /* For interaction states */
  :host::before,
  :host::after {
    content: '';
    /* We rely on the host always being relative */
    position: absolute;
    z-index: 1;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    background-color: currentColor;
    border-radius: inherit;
    opacity: 0;
    pointer-events: none;
  }

  /* Hover */

  @media (any-hover: hover) {
    :host(:hover)::before {
      opacity: 0.02;
    }
  }

  /* Active */

  :host::after {
    transition: opacity 1.4s, transform 0.1s;
    filter: blur(8px);
  }

  :host([active])::before {
    opacity: 0.05;
    transition-duration: 0s;
  }

  :host([active])::after {
    opacity: 0.1;
    transition-duration: 0s, 0s;
    transform: scale(0);
  }

  /* Keyboard focus */

  :host([focus-ring]) {
    box-shadow: 0 0 0 2px var(--lumo-primary-color-50pct);
  }

  :host([theme~='primary'][focus-ring]) {
    box-shadow: 0 0 0 1px var(--lumo-base-color), 0 0 0 3px var(--lumo-primary-color-50pct);
  }

  /* Types (primary, tertiary, tertiary-inline */

  :host([theme~='tertiary']),
  :host([theme~='tertiary-inline']) {
    background-color: transparent !important;
    min-width: 0;
  }

  :host([theme~='tertiary']) {
    padding: 0 calc(var(--lumo-button-size) / 6);
  }

  :host([theme~='tertiary-inline'])::before {
    display: none;
  }

  :host([theme~='tertiary-inline']) {
    margin: 0;
    height: auto;
    padding: 0;
    line-height: inherit;
    font-size: inherit;
  }

  :host([theme~='tertiary-inline']) [part='label'] {
    padding: 0;
    overflow: visible;
    line-height: inherit;
  }

  :host([theme~='primary']) {
    background-color: var(--_lumo-button-primary-background-color, var(--lumo-primary-color));
    color: var(--_lumo-button-primary-color, var(--lumo-primary-contrast-color));
    font-weight: 600;
    min-width: calc(var(--lumo-button-size) * 2.5);
  }

  :host([theme~='primary'])::before {
    background-color: black;
  }

  @media (any-hover: hover) {
    :host([theme~='primary']:hover)::before {
      opacity: 0.05;
    }
  }

  :host([theme~='primary'][active])::before {
    opacity: 0.1;
  }

  :host([theme~='primary'][active])::after {
    opacity: 0.2;
  }

  /* Colors (success, error, contrast) */

  :host([theme~='success']) {
    color: var(--lumo-success-text-color);
  }

  :host([theme~='success'][theme~='primary']) {
    background-color: var(--lumo-success-color);
    color: var(--lumo-success-contrast-color);
  }

  :host([theme~='error']) {
    color: var(--lumo-error-text-color);
  }

  :host([theme~='error'][theme~='primary']) {
    background-color: var(--lumo-error-color);
    color: var(--lumo-error-contrast-color);
  }

  :host([theme~='contrast']) {
    color: var(--lumo-contrast);
  }

  :host([theme~='contrast'][theme~='primary']) {
    background-color: var(--lumo-contrast);
    color: var(--lumo-base-color);
  }

  /* Disabled state. Keep selectors after other color variants. */

  :host([disabled]) {
    pointer-events: none;
    color: var(--lumo-disabled-text-color);
  }

  :host([theme~='primary'][disabled]) {
    background-color: var(--lumo-contrast-30pct);
    color: var(--lumo-base-color);
  }

  :host([theme~='primary'][disabled]) [part] {
    opacity: 0.7;
  }

  /* Icons */

  [part] ::slotted(vaadin-icon),
  [part] ::slotted(iron-icon) {
    display: inline-block;
    width: var(--lumo-icon-size-m);
    height: var(--lumo-icon-size-m);
  }

  /* Vaadin icons are based on a 16x16 grid (unlike Lumo and Material icons with 24x24), so they look too big by default */
  [part] ::slotted(vaadin-icon[icon^='vaadin:']),
  [part] ::slotted(iron-icon[icon^='vaadin:']) {
    padding: 0.25em;
    box-sizing: border-box !important;
  }

  [part='prefix'] {
    margin-left: -0.25em;
    margin-right: 0.25em;
  }

  [part='suffix'] {
    margin-left: 0.25em;
    margin-right: -0.25em;
  }

  /* Icon-only */

  :host([theme~='icon']:not([theme~='tertiary-inline'])) {
    min-width: var(--lumo-button-size);
    padding-left: calc(var(--lumo-button-size) / 4);
    padding-right: calc(var(--lumo-button-size) / 4);
  }

  :host([theme~='icon']) [part='prefix'],
  :host([theme~='icon']) [part='suffix'] {
    margin-left: 0;
    margin-right: 0;
  }

  /* RTL specific styles */

  :host([dir='rtl']) [part='prefix'] {
    margin-left: 0.25em;
    margin-right: -0.25em;
  }

  :host([dir='rtl']) [part='suffix'] {
    margin-left: -0.25em;
    margin-right: 0.25em;
  }

  :host([dir='rtl'][theme~='icon']) [part='prefix'],
  :host([dir='rtl'][theme~='icon']) [part='suffix'] {
    margin-left: 0;
    margin-right: 0;
  }
`;
  Te("vaadin-button", z$, { moduleId: "lumo-button" });
  const H$ = /\/\*[\*!]\s+vaadin-dev-mode:start([\s\S]*)vaadin-dev-mode:end\s+\*\*\//i, ca = window.Vaadin && window.Vaadin.Flow && window.Vaadin.Flow.clients;
  function U$() {
    function r() {
      return !0;
    }
    return zb(r);
  }
  function W$() {
    try {
      return B$() ? !0 : V$() ? ca ? !q$() : !U$() : !1;
    } catch {
      return !1;
    }
  }
  function B$() {
    return localStorage.getItem("vaadin.developmentmode.force");
  }
  function V$() {
    return ["localhost", "127.0.0.1"].indexOf(window.location.hostname) >= 0;
  }
  function q$() {
    return !!(ca && Object.keys(ca).map((e) => ca[e]).filter((e) => e.productionMode).length > 0);
  }
  function zb(r, e) {
    if (typeof r != "function")
      return;
    const t = H$.exec(r.toString());
    if (t)
      try {
        r = new Function(t[1]);
      } catch {
      }
    return r(e);
  }
  window.Vaadin = window.Vaadin || {};
  const cg = function(r, e) {
    if (window.Vaadin.developmentMode)
      return zb(r, e);
  };
  window.Vaadin.developmentMode === void 0 && (window.Vaadin.developmentMode = W$());
  function Y$() {
    /*! vaadin-dev-mode:start
      (function () {
    'use strict';
    
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    
    var classCallCheck = function (instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    };
    
    var createClass = function () {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
    
      return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    
    var getPolymerVersion = function getPolymerVersion() {
      return window.Polymer && window.Polymer.version;
    };
    
    var StatisticsGatherer = function () {
      function StatisticsGatherer(logger) {
        classCallCheck(this, StatisticsGatherer);
    
        this.now = new Date().getTime();
        this.logger = logger;
      }
    
      createClass(StatisticsGatherer, [{
        key: 'frameworkVersionDetectors',
        value: function frameworkVersionDetectors() {
          return {
            'Flow': function Flow() {
              if (window.Vaadin && window.Vaadin.Flow && window.Vaadin.Flow.clients) {
                var flowVersions = Object.keys(window.Vaadin.Flow.clients).map(function (key) {
                  return window.Vaadin.Flow.clients[key];
                }).filter(function (client) {
                  return client.getVersionInfo;
                }).map(function (client) {
                  return client.getVersionInfo().flow;
                });
                if (flowVersions.length > 0) {
                  return flowVersions[0];
                }
              }
            },
            'Vaadin Framework': function VaadinFramework() {
              if (window.vaadin && window.vaadin.clients) {
                var frameworkVersions = Object.values(window.vaadin.clients).filter(function (client) {
                  return client.getVersionInfo;
                }).map(function (client) {
                  return client.getVersionInfo().vaadinVersion;
                });
                if (frameworkVersions.length > 0) {
                  return frameworkVersions[0];
                }
              }
            },
            'AngularJs': function AngularJs() {
              if (window.angular && window.angular.version && window.angular.version) {
                return window.angular.version.full;
              }
            },
            'Angular': function Angular() {
              if (window.ng) {
                var tags = document.querySelectorAll("[ng-version]");
                if (tags.length > 0) {
                  return tags[0].getAttribute("ng-version");
                }
                return "Unknown";
              }
            },
            'Backbone.js': function BackboneJs() {
              if (window.Backbone) {
                return window.Backbone.VERSION;
              }
            },
            'React': function React() {
              var reactSelector = '[data-reactroot], [data-reactid]';
              if (!!document.querySelector(reactSelector)) {
                // React does not publish the version by default
                return "unknown";
              }
            },
            'Ember': function Ember() {
              if (window.Em && window.Em.VERSION) {
                return window.Em.VERSION;
              } else if (window.Ember && window.Ember.VERSION) {
                return window.Ember.VERSION;
              }
            },
            'jQuery': function (_jQuery) {
              function jQuery() {
                return _jQuery.apply(this, arguments);
              }
    
              jQuery.toString = function () {
                return _jQuery.toString();
              };
    
              return jQuery;
            }(function () {
              if (typeof jQuery === 'function' && jQuery.prototype.jquery !== undefined) {
                return jQuery.prototype.jquery;
              }
            }),
            'Polymer': function Polymer() {
              var version = getPolymerVersion();
              if (version) {
                return version;
              }
            },
            'LitElement': function LitElement() {
              var version = window.litElementVersions && window.litElementVersions[0];
              if (version) {
                return version;
              }
            },
            'LitHtml': function LitHtml() {
              var version = window.litHtmlVersions && window.litHtmlVersions[0];
              if (version) {
                return version;
              }
            },
            'Vue.js': function VueJs() {
              if (window.Vue) {
                return window.Vue.version;
              }
            }
          };
        }
      }, {
        key: 'getUsedVaadinElements',
        value: function getUsedVaadinElements(elements) {
          var version = getPolymerVersion();
          var elementClasses = void 0;
          // NOTE: In case you edit the code here, YOU MUST UPDATE any statistics reporting code in Flow.
          // Check all locations calling the method getEntries() in
          // https://github.com/vaadin/flow/blob/master/flow-server/src/main/java/com/vaadin/flow/internal/UsageStatistics.java#L106
          // Currently it is only used by BootstrapHandler.
          if (version && version.indexOf('2') === 0) {
            // Polymer 2: components classes are stored in window.Vaadin
            elementClasses = Object.keys(window.Vaadin).map(function (c) {
              return window.Vaadin[c];
            }).filter(function (c) {
              return c.is;
            });
          } else {
            // Polymer 3: components classes are stored in window.Vaadin.registrations
            elementClasses = window.Vaadin.registrations || [];
          }
          elementClasses.forEach(function (klass) {
            var version = klass.version ? klass.version : "0.0.0";
            elements[klass.is] = { version: version };
          });
        }
      }, {
        key: 'getUsedVaadinThemes',
        value: function getUsedVaadinThemes(themes) {
          ['Lumo', 'Material'].forEach(function (themeName) {
            var theme;
            var version = getPolymerVersion();
            if (version && version.indexOf('2') === 0) {
              // Polymer 2: themes are stored in window.Vaadin
              theme = window.Vaadin[themeName];
            } else {
              // Polymer 3: themes are stored in custom element registry
              theme = customElements.get('vaadin-' + themeName.toLowerCase() + '-styles');
            }
            if (theme && theme.version) {
              themes[themeName] = { version: theme.version };
            }
          });
        }
      }, {
        key: 'getFrameworks',
        value: function getFrameworks(frameworks) {
          var detectors = this.frameworkVersionDetectors();
          Object.keys(detectors).forEach(function (framework) {
            var detector = detectors[framework];
            try {
              var version = detector();
              if (version) {
                frameworks[framework] = { version: version };
              }
            } catch (e) {}
          });
        }
      }, {
        key: 'gather',
        value: function gather(storage) {
          var storedStats = storage.read();
          var gatheredStats = {};
          var types = ["elements", "frameworks", "themes"];
    
          types.forEach(function (type) {
            gatheredStats[type] = {};
            if (!storedStats[type]) {
              storedStats[type] = {};
            }
          });
    
          var previousStats = JSON.stringify(storedStats);
    
          this.getUsedVaadinElements(gatheredStats.elements);
          this.getFrameworks(gatheredStats.frameworks);
          this.getUsedVaadinThemes(gatheredStats.themes);
    
          var now = this.now;
          types.forEach(function (type) {
            var keys = Object.keys(gatheredStats[type]);
            keys.forEach(function (key) {
              if (!storedStats[type][key] || _typeof(storedStats[type][key]) != _typeof({})) {
                storedStats[type][key] = { firstUsed: now };
              }
              // Discards any previously logged version number
              storedStats[type][key].version = gatheredStats[type][key].version;
              storedStats[type][key].lastUsed = now;
            });
          });
    
          var newStats = JSON.stringify(storedStats);
          storage.write(newStats);
          if (newStats != previousStats && Object.keys(storedStats).length > 0) {
            this.logger.debug("New stats: " + newStats);
          }
        }
      }]);
      return StatisticsGatherer;
    }();
    
    var StatisticsStorage = function () {
      function StatisticsStorage(key) {
        classCallCheck(this, StatisticsStorage);
    
        this.key = key;
      }
    
      createClass(StatisticsStorage, [{
        key: 'read',
        value: function read() {
          var localStorageStatsString = localStorage.getItem(this.key);
          try {
            return JSON.parse(localStorageStatsString ? localStorageStatsString : '{}');
          } catch (e) {
            return {};
          }
        }
      }, {
        key: 'write',
        value: function write(data) {
          localStorage.setItem(this.key, data);
        }
      }, {
        key: 'clear',
        value: function clear() {
          localStorage.removeItem(this.key);
        }
      }, {
        key: 'isEmpty',
        value: function isEmpty() {
          var storedStats = this.read();
          var empty = true;
          Object.keys(storedStats).forEach(function (key) {
            if (Object.keys(storedStats[key]).length > 0) {
              empty = false;
            }
          });
    
          return empty;
        }
      }]);
      return StatisticsStorage;
    }();
    
    var StatisticsSender = function () {
      function StatisticsSender(url, logger) {
        classCallCheck(this, StatisticsSender);
    
        this.url = url;
        this.logger = logger;
      }
    
      createClass(StatisticsSender, [{
        key: 'send',
        value: function send(data, errorHandler) {
          var logger = this.logger;
    
          if (navigator.onLine === false) {
            logger.debug("Offline, can't send");
            errorHandler();
            return;
          }
          logger.debug("Sending data to " + this.url);
    
          var req = new XMLHttpRequest();
          req.withCredentials = true;
          req.addEventListener("load", function () {
            // Stats sent, nothing more to do
            logger.debug("Response: " + req.responseText);
          });
          req.addEventListener("error", function () {
            logger.debug("Send failed");
            errorHandler();
          });
          req.addEventListener("abort", function () {
            logger.debug("Send aborted");
            errorHandler();
          });
          req.open("POST", this.url);
          req.setRequestHeader("Content-Type", "application/json");
          req.send(data);
        }
      }]);
      return StatisticsSender;
    }();
    
    var StatisticsLogger = function () {
      function StatisticsLogger(id) {
        classCallCheck(this, StatisticsLogger);
    
        this.id = id;
      }
    
      createClass(StatisticsLogger, [{
        key: '_isDebug',
        value: function _isDebug() {
          return localStorage.getItem("vaadin." + this.id + ".debug");
        }
      }, {
        key: 'debug',
        value: function debug(msg) {
          if (this._isDebug()) {
            console.info(this.id + ": " + msg);
          }
        }
      }]);
      return StatisticsLogger;
    }();
    
    var UsageStatistics = function () {
      function UsageStatistics() {
        classCallCheck(this, UsageStatistics);
    
        this.now = new Date();
        this.timeNow = this.now.getTime();
        this.gatherDelay = 10; // Delay between loading this file and gathering stats
        this.initialDelay = 24 * 60 * 60;
    
        this.logger = new StatisticsLogger("statistics");
        this.storage = new StatisticsStorage("vaadin.statistics.basket");
        this.gatherer = new StatisticsGatherer(this.logger);
        this.sender = new StatisticsSender("https://tools.vaadin.com/usage-stats/submit", this.logger);
      }
    
      createClass(UsageStatistics, [{
        key: 'maybeGatherAndSend',
        value: function maybeGatherAndSend() {
          var _this = this;
    
          if (localStorage.getItem(UsageStatistics.optOutKey)) {
            return;
          }
          this.gatherer.gather(this.storage);
          setTimeout(function () {
            _this.maybeSend();
          }, this.gatherDelay * 1000);
        }
      }, {
        key: 'lottery',
        value: function lottery() {
          return true;
        }
      }, {
        key: 'currentMonth',
        value: function currentMonth() {
          return this.now.getYear() * 12 + this.now.getMonth();
        }
      }, {
        key: 'maybeSend',
        value: function maybeSend() {
          var firstUse = Number(localStorage.getItem(UsageStatistics.firstUseKey));
          var monthProcessed = Number(localStorage.getItem(UsageStatistics.monthProcessedKey));
    
          if (!firstUse) {
            // Use a grace period to avoid interfering with tests, incognito mode etc
            firstUse = this.timeNow;
            localStorage.setItem(UsageStatistics.firstUseKey, firstUse);
          }
    
          if (this.timeNow < firstUse + this.initialDelay * 1000) {
            this.logger.debug("No statistics will be sent until the initial delay of " + this.initialDelay + "s has passed");
            return;
          }
          if (this.currentMonth() <= monthProcessed) {
            this.logger.debug("This month has already been processed");
            return;
          }
          localStorage.setItem(UsageStatistics.monthProcessedKey, this.currentMonth());
          // Use random sampling
          if (this.lottery()) {
            this.logger.debug("Congratulations, we have a winner!");
          } else {
            this.logger.debug("Sorry, no stats from you this time");
            return;
          }
    
          this.send();
        }
      }, {
        key: 'send',
        value: function send() {
          // Ensure we have the latest data
          this.gatherer.gather(this.storage);
    
          // Read, send and clean up
          var data = this.storage.read();
          data["firstUse"] = Number(localStorage.getItem(UsageStatistics.firstUseKey));
          data["usageStatisticsVersion"] = UsageStatistics.version;
          var info = 'This request contains usage statistics gathered from the application running in development mode. \n\nStatistics gathering is automatically disabled and excluded from production builds.\n\nFor details and to opt-out, see https://github.com/vaadin/vaadin-usage-statistics.\n\n\n\n';
          var self = this;
          this.sender.send(info + JSON.stringify(data), function () {
            // Revert the 'month processed' flag
            localStorage.setItem(UsageStatistics.monthProcessedKey, self.currentMonth() - 1);
          });
        }
      }], [{
        key: 'version',
        get: function get$1() {
          return '2.1.2';
        }
      }, {
        key: 'firstUseKey',
        get: function get$1() {
          return 'vaadin.statistics.firstuse';
        }
      }, {
        key: 'monthProcessedKey',
        get: function get$1() {
          return 'vaadin.statistics.monthProcessed';
        }
      }, {
        key: 'optOutKey',
        get: function get$1() {
          return 'vaadin.statistics.optout';
        }
      }]);
      return UsageStatistics;
    }();
    
    try {
      window.Vaadin = window.Vaadin || {};
      window.Vaadin.usageStatsChecker = window.Vaadin.usageStatsChecker || new UsageStatistics();
      window.Vaadin.usageStatsChecker.maybeGatherAndSend();
    } catch (e) {
      // Intentionally ignored as this is not a problem in the app being developed
    }
    
    }());
    
      vaadin-dev-mode:end **/
  }
  const G$ = function() {
    if (typeof cg == "function")
      return cg(Y$);
  };
  /**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
   */
  let dg = 0, Hb = 0;
  const co = [];
  let ug = 0, wd = !1;
  const Ub = document.createTextNode("");
  new window.MutationObserver(j$).observe(Ub, { characterData: !0 });
  function j$() {
    wd = !1;
    const r = co.length;
    for (let e = 0; e < r; e++) {
      const t = co[e];
      if (t)
        try {
          t();
        } catch (i) {
          setTimeout(() => {
            throw i;
          });
        }
    }
    co.splice(0, r), Hb += r;
  }
  const Un = {
    /**
     * Returns a sub-module with the async interface providing the provided
     * delay.
     *
     * @memberof timeOut
     * @param {number=} delay Time to wait before calling callbacks in ms
     * @return {!AsyncInterface} An async timeout interface
     */
    after(r) {
      return {
        run(e) {
          return window.setTimeout(e, r);
        },
        cancel(e) {
          window.clearTimeout(e);
        }
      };
    },
    /**
     * Enqueues a function called in the next task.
     *
     * @memberof timeOut
     * @param {!Function} fn Callback to run
     * @param {number=} delay Delay in milliseconds
     * @return {number} Handle used for canceling task
     */
    run(r, e) {
      return window.setTimeout(r, e);
    },
    /**
     * Cancels a previously enqueued `timeOut` callback.
     *
     * @memberof timeOut
     * @param {number} handle Handle returned from `run` of callback to cancel
     * @return {void}
     */
    cancel(r) {
      window.clearTimeout(r);
    }
  }, Z$ = {
    /**
     * Enqueues a function called at `requestIdleCallback` timing.
     *
     * @memberof idlePeriod
     * @param {function(!IdleDeadline):void} fn Callback to run
     * @return {number} Handle used for canceling task
     */
    run(r) {
      return window.requestIdleCallback ? window.requestIdleCallback(r) : window.setTimeout(r, 16);
    },
    /**
     * Cancels a previously enqueued `idlePeriod` callback.
     *
     * @memberof idlePeriod
     * @param {number} handle Handle returned from `run` of callback to cancel
     * @return {void}
     */
    cancel(r) {
      window.cancelIdleCallback ? window.cancelIdleCallback(r) : window.clearTimeout(r);
    }
  }, K$ = {
    /**
     * Enqueues a function called at microtask timing.
     *
     * @memberof microTask
     * @param {!Function=} callback Callback to run
     * @return {number} Handle used for canceling task
     */
    run(r) {
      wd || (wd = !0, Ub.textContent = ug, ug += 1), co.push(r);
      const e = dg;
      return dg += 1, e;
    },
    /**
     * Cancels a previously enqueued `microTask` callback.
     *
     * @memberof microTask
     * @param {number} handle Handle returned from `run` of callback to cancel
     * @return {void}
     */
    cancel(r) {
      const e = r - Hb;
      if (e >= 0) {
        if (!co[e])
          throw new Error(`invalid async handle: ${r}`);
        co[e] = null;
      }
    }
  };
  /**
  @license
  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */
  let Do = class kd {
    /**
     * Creates a debouncer if no debouncer is passed as a parameter
     * or it cancels an active debouncer otherwise. The following
     * example shows how a debouncer can be called multiple times within a
     * microtask and "debounced" such that the provided callback function is
     * called once. Add this method to a custom element:
     *
     * ```js
     * import {microTask} from '@vaadin/component-base/src/async.js';
     * import {Debouncer} from '@vaadin/component-base/src/debounce.js';
     * // ...
     *
     * _debounceWork() {
     *   this._debounceJob = Debouncer.debounce(this._debounceJob,
     *       microTask, () => this._doWork());
     * }
     * ```
     *
     * If the `_debounceWork` method is called multiple times within the same
     * microtask, the `_doWork` function will be called only once at the next
     * microtask checkpoint.
     *
     * Note: In testing it is often convenient to avoid asynchrony. To accomplish
     * this with a debouncer, you can use `enqueueDebouncer` and
     * `flush`. For example, extend the above example by adding
     * `enqueueDebouncer(this._debounceJob)` at the end of the
     * `_debounceWork` method. Then in a test, call `flush` to ensure
     * the debouncer has completed.
     *
     * @param {Debouncer?} debouncer Debouncer object.
     * @param {!AsyncInterface} asyncModule Object with Async interface
     * @param {function()} callback Callback to run.
     * @return {!Debouncer} Returns a debouncer object.
     */
    static debounce(e, t, i) {
      return e instanceof kd ? e._cancelAsync() : e = new kd(), e.setConfig(t, i), e;
    }
    constructor() {
      this._asyncModule = null, this._callback = null, this._timer = null;
    }
    /**
     * Sets the scheduler; that is, a module with the Async interface,
     * a callback and optional arguments to be passed to the run function
     * from the async module.
     *
     * @param {!AsyncInterface} asyncModule Object with Async interface.
     * @param {function()} callback Callback to run.
     * @return {void}
     */
    setConfig(e, t) {
      this._asyncModule = e, this._callback = t, this._timer = this._asyncModule.run(() => {
        this._timer = null, xd.delete(this), this._callback();
      });
    }
    /**
     * Cancels an active debouncer and returns a reference to itself.
     *
     * @return {void}
     */
    cancel() {
      this.isActive() && (this._cancelAsync(), xd.delete(this));
    }
    /**
     * Cancels a debouncer's async callback.
     *
     * @return {void}
     */
    _cancelAsync() {
      this.isActive() && (this._asyncModule.cancel(
        /** @type {number} */
        this._timer
      ), this._timer = null);
    }
    /**
     * Flushes an active debouncer and returns a reference to itself.
     *
     * @return {void}
     */
    flush() {
      this.isActive() && (this.cancel(), this._callback());
    }
    /**
     * Returns true if the debouncer is active.
     *
     * @return {boolean} True if active.
     */
    isActive() {
      return this._timer != null;
    }
  }, xd = /* @__PURE__ */ new Set();
  function J$(r) {
    xd.add(r);
  }
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  window.Vaadin = window.Vaadin || {};
  window.Vaadin.registrations = window.Vaadin.registrations || [];
  window.Vaadin.developmentModeCallback = window.Vaadin.developmentModeCallback || {};
  window.Vaadin.developmentModeCallback["vaadin-usage-statistics"] = function() {
    G$();
  };
  let Dc;
  const hg = /* @__PURE__ */ new Set(), fu = (r) => class extends Kn(r) {
    static get version() {
      return "23.6.1";
    }
    /** @protected */
    static finalize() {
      super.finalize();
      const { is: t } = this;
      t && !hg.has(t) && (window.Vaadin.registrations.push(this), hg.add(t), window.Vaadin.developmentModeCallback && (Dc = Do.debounce(Dc, Z$, () => {
        window.Vaadin.developmentModeCallback["vaadin-usage-statistics"]();
      }), J$(Dc)));
    }
    constructor() {
      super(), document.doctype;
    }
  };
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  let X$ = 0;
  function Q$() {
    return X$++;
  }
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  class Di extends EventTarget {
    /**
     * Ensure that every instance has unique ID.
     *
     * @param {string} slotName
     * @param {HTMLElement} host
     * @return {string}
     * @protected
     */
    static generateId(e, t) {
      return `${e || "default"}-${t.localName}-${Q$()}`;
    }
    constructor(e, t, i, o, a) {
      super(), this.host = e, this.slotName = t, this.slotFactory = i, this.slotInitializer = o, a && (this.defaultId = Di.generateId(t, e));
    }
    hostConnected() {
      if (!this.initialized) {
        let e = this.getSlotChild();
        e ? (this.node = e, this.initCustomNode(e)) : e = this.attachDefaultNode(), this.initNode(e), this.observe(), this.initialized = !0;
      }
    }
    /**
     * Create and attach default node using the slot factory.
     * @return {Node | undefined}
     * @protected
     */
    attachDefaultNode() {
      const { host: e, slotName: t, slotFactory: i } = this;
      let o = this.defaultNode;
      return !o && i && (o = i(e), o instanceof Element && (t !== "" && o.setAttribute("slot", t), this.node = o, this.defaultNode = o)), o && e.appendChild(o), o;
    }
    /**
     * Return a reference to the node managed by the controller.
     * @return {Node}
     */
    getSlotChild() {
      const { slotName: e } = this;
      return Array.from(this.host.childNodes).find((t) => t.nodeType === Node.ELEMENT_NODE && t.slot === e || t.nodeType === Node.TEXT_NODE && t.textContent.trim() && e === "");
    }
    /**
     * @param {Node} node
     * @protected
     */
    initNode(e) {
      const { slotInitializer: t } = this;
      t && t(this.host, e);
    }
    /**
     * Override to initialize the newly added custom node.
     *
     * @param {Node} _node
     * @protected
     */
    initCustomNode(e) {
    }
    /**
     * Override to teardown slotted node when it's removed.
     *
     * @param {Node} _node
     * @protected
     */
    teardownNode(e) {
    }
    /**
     * Setup the observer to manage slot content changes.
     * @protected
     */
    observe() {
      const { slotName: e } = this, t = e === "" ? "slot:not([name])" : `slot[name=${e}]`, i = this.host.shadowRoot.querySelector(t);
      this.__slotObserver = new Ca(i, (o) => {
        const a = this.node, l = o.addedNodes.find((d) => d !== a);
        o.removedNodes.length && o.removedNodes.forEach((d) => {
          this.teardownNode(d);
        }), l && (a && a.isConnected && this.host.removeChild(a), this.node = l, l !== this.defaultNode && (this.initCustomNode(l), this.initNode(l)));
      });
    }
  }
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  class pu extends Di {
    constructor(e) {
      super(e, "tooltip"), this.setTarget(e);
    }
    /**
     * Override to initialize the newly added custom tooltip.
     *
     * @param {Node} tooltipNode
     * @protected
     * @override
     */
    initCustomNode(e) {
      e.target = this.target, this.context !== void 0 && (e.context = this.context), this.manual !== void 0 && (e.manual = this.manual), this.opened !== void 0 && (e.opened = this.opened), this.position !== void 0 && (e._position = this.position), this.shouldShow !== void 0 && (e.shouldShow = this.shouldShow);
    }
    /**
     * Set a context object to be used by generator.
     * @param {object} context
     */
    setContext(e) {
      this.context = e;
      const t = this.node;
      t && (t.context = e);
    }
    /**
     * Toggle manual state on the slotted tooltip.
     * @param {boolean} manual
     */
    setManual(e) {
      this.manual = e;
      const t = this.node;
      t && (t.manual = e);
    }
    /**
     * Toggle opened state on the slotted tooltip.
     * @param {boolean} opened
     */
    setOpened(e) {
      this.opened = e;
      const t = this.node;
      t && (t.opened = e);
    }
    /**
     * Set default position for the slotted tooltip.
     * This can be overridden by setting the position
     * using corresponding property or attribute.
     * @param {string} position
     */
    setPosition(e) {
      this.position = e;
      const t = this.node;
      t && (t._position = e);
    }
    /**
     * Set function used to detect whether to show
     * the tooltip based on a condition.
     * @param {Function} shouldShow
     */
    setShouldShow(e) {
      this.shouldShow = e;
      const t = this.node;
      t && (t.shouldShow = e);
    }
    /**
     * Set an HTML element to attach the tooltip to.
     * @param {HTMLElement} target
     */
    setTarget(e) {
      this.target = e;
      const t = this.node;
      t && (t.target = e);
    }
  }
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  const Wb = Oe(
    (r) => class extends r {
      static get properties() {
        return {
          /**
           * If true, the user cannot interact with this element.
           */
          disabled: {
            type: Boolean,
            value: !1,
            observer: "_disabledChanged",
            reflectToAttribute: !0
          }
        };
      }
      /**
       * @param {boolean} disabled
       * @protected
       */
      _disabledChanged(t) {
        this._setAriaDisabled(t);
      }
      /**
       * @param {boolean} disabled
       * @protected
       */
      _setAriaDisabled(t) {
        t ? this.setAttribute("aria-disabled", "true") : this.removeAttribute("aria-disabled");
      }
      /**
       * Overrides the default element `click` method in order to prevent
       * firing the `click` event when the element is disabled.
       * @protected
       * @override
       */
      click() {
        this.disabled || super.click();
      }
    }
  );
  /**
  @license
  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */
  const eT = (r) => r, Bb = typeof document.head.style.touchAction == "string", Cd = "__polymerGestures", Pc = "__polymerGesturesHandled", Sd = "__polymerGesturesTouchAction", fg = 25, pg = 5, tT = 2, rT = ["mousedown", "mousemove", "mouseup", "click"], iT = [0, 1, 4, 2], oT = (function() {
    try {
      return new MouseEvent("test", { buttons: 1 }).buttons === 1;
    } catch {
      return !1;
    }
  })();
  function gu(r) {
    return rT.indexOf(r) > -1;
  }
  let nT = !1;
  (function() {
    try {
      const r = Object.defineProperty({}, "passive", {
        // eslint-disable-next-line getter-return
        get() {
          nT = !0;
        }
      });
      window.addEventListener("test", null, r), window.removeEventListener("test", null, r);
    } catch {
    }
  })();
  function sT(r) {
    gu(r);
  }
  const aT = navigator.userAgent.match(/iP(?:[oa]d|hone)|Android/), lT = {
    button: !0,
    command: !0,
    fieldset: !0,
    input: !0,
    keygen: !0,
    optgroup: !0,
    option: !0,
    select: !0,
    textarea: !0
  };
  function wi(r) {
    const e = r.type;
    if (!gu(e))
      return !1;
    if (e === "mousemove") {
      let i = r.buttons === void 0 ? 1 : r.buttons;
      return r instanceof window.MouseEvent && !oT && (i = iT[r.which] || 0), !!(i & 1);
    }
    return (r.button === void 0 ? 0 : r.button) === 0;
  }
  function cT(r) {
    if (r.type === "click") {
      if (r.detail === 0)
        return !0;
      const e = Gr(r);
      if (!e.nodeType || /** @type {Element} */
      e.nodeType !== Node.ELEMENT_NODE)
        return !0;
      const t = (
        /** @type {Element} */
        e.getBoundingClientRect()
      ), i = r.pageX, o = r.pageY;
      return !(i >= t.left && i <= t.right && o >= t.top && o <= t.bottom);
    }
    return !1;
  }
  const yr = {
    touch: {
      x: 0,
      y: 0,
      id: -1,
      scrollDecided: !1
    }
  };
  function dT(r) {
    let e = "auto";
    const t = qb(r);
    for (let i = 0, o; i < t.length; i++)
      if (o = t[i], o[Sd]) {
        e = o[Sd];
        break;
      }
    return e;
  }
  function Vb(r, e, t) {
    r.movefn = e, r.upfn = t, document.addEventListener("mousemove", e), document.addEventListener("mouseup", t);
  }
  function uo(r) {
    document.removeEventListener("mousemove", r.movefn), document.removeEventListener("mouseup", r.upfn), r.movefn = null, r.upfn = null;
  }
  const qb = window.ShadyDOM && window.ShadyDOM.noPatch ? window.ShadyDOM.composedPath : (r) => r.composedPath && r.composedPath() || [], mu = {}, _i = [];
  function uT(r, e) {
    let t = document.elementFromPoint(r, e), i = t;
    for (; i && i.shadowRoot && !window.ShadyDOM; ) {
      const o = i;
      if (i = i.shadowRoot.elementFromPoint(r, e), o === i)
        break;
      i && (t = i);
    }
    return t;
  }
  function Gr(r) {
    const e = qb(
      /** @type {?Event} */
      r
    );
    return e.length > 0 ? e[0] : r.target;
  }
  function hT(r) {
    const e = r.type, i = r.currentTarget[Cd];
    if (!i)
      return;
    const o = i[e];
    if (!o)
      return;
    if (!r[Pc] && (r[Pc] = {}, e.startsWith("touch"))) {
      const l = r.changedTouches[0];
      if (e === "touchstart" && r.touches.length === 1 && (yr.touch.id = l.identifier), yr.touch.id !== l.identifier)
        return;
      Bb || (e === "touchstart" || e === "touchmove") && fT(r);
    }
    const a = r[Pc];
    if (!a.skip) {
      for (let l = 0, d; l < _i.length; l++)
        d = _i[l], o[d.name] && !a[d.name] && d.flow && d.flow.start.indexOf(r.type) > -1 && d.reset && d.reset();
      for (let l = 0, d; l < _i.length; l++)
        d = _i[l], o[d.name] && !a[d.name] && (a[d.name] = !0, d[e](r));
    }
  }
  function fT(r) {
    const e = r.changedTouches[0], t = r.type;
    if (t === "touchstart")
      yr.touch.x = e.clientX, yr.touch.y = e.clientY, yr.touch.scrollDecided = !1;
    else if (t === "touchmove") {
      if (yr.touch.scrollDecided)
        return;
      yr.touch.scrollDecided = !0;
      const i = dT(r);
      let o = !1;
      const a = Math.abs(yr.touch.x - e.clientX), l = Math.abs(yr.touch.y - e.clientY);
      r.cancelable && (i === "none" ? o = !0 : i === "pan-x" ? o = l > a : i === "pan-y" && (o = a > l)), o ? r.preventDefault() : Sa("track");
    }
  }
  function er(r, e, t) {
    return mu[e] ? (pT(r, e, t), !0) : !1;
  }
  function pT(r, e, t) {
    const i = mu[e], o = i.deps, a = i.name;
    let l = r[Cd];
    l || (r[Cd] = l = {});
    for (let d = 0, u, f; d < o.length; d++)
      u = o[d], !(aT && gu(u) && u !== "click") && (f = l[u], f || (l[u] = f = { _count: 0 }), f._count === 0 && r.addEventListener(u, hT, sT(u)), f[a] = (f[a] || 0) + 1, f._count = (f._count || 0) + 1);
    r.addEventListener(e, t), i.touchAction && Yb(r, i.touchAction);
  }
  function bu(r) {
    _i.push(r);
    for (let e = 0; e < r.emits.length; e++)
      mu[r.emits[e]] = r;
  }
  function gT(r) {
    for (let e = 0, t; e < _i.length; e++) {
      t = _i[e];
      for (let i = 0, o; i < t.emits.length; i++)
        if (o = t.emits[i], o === r)
          return t;
    }
    return null;
  }
  function Yb(r, e) {
    Bb && r instanceof HTMLElement && K$.run(() => {
      r.style.touchAction = e;
    }), r[Sd] = e;
  }
  function _u(r, e, t) {
    const i = new Event(e, { bubbles: !0, cancelable: !0, composed: !0 });
    if (i.detail = t, eT(
      /** @type {!Node} */
      r
    ).dispatchEvent(i), i.defaultPrevented) {
      const o = t.preventer || t.sourceEvent;
      o && o.preventDefault && o.preventDefault();
    }
  }
  function Sa(r) {
    const e = gT(r);
    e.info && (e.info.prevent = !0);
  }
  bu({
    name: "downup",
    deps: ["mousedown", "touchstart", "touchend"],
    flow: {
      start: ["mousedown", "touchstart"],
      end: ["mouseup", "touchend"]
    },
    emits: ["down", "up"],
    info: {
      movefn: null,
      upfn: null
    },
    /**
     * @this {GestureRecognizer}
     * @return {void}
     */
    reset() {
      uo(this.info);
    },
    /**
     * @this {GestureRecognizer}
     * @param {MouseEvent} e
     * @return {void}
     */
    mousedown(r) {
      if (!wi(r))
        return;
      const e = Gr(r), t = this, i = (a) => {
        wi(a) || (pn("up", e, a), uo(t.info));
      }, o = (a) => {
        wi(a) && pn("up", e, a), uo(t.info);
      };
      Vb(this.info, i, o), pn("down", e, r);
    },
    /**
     * @this {GestureRecognizer}
     * @param {TouchEvent} e
     * @return {void}
     */
    touchstart(r) {
      pn("down", Gr(r), r.changedTouches[0], r);
    },
    /**
     * @this {GestureRecognizer}
     * @param {TouchEvent} e
     * @return {void}
     */
    touchend(r) {
      pn("up", Gr(r), r.changedTouches[0], r);
    }
  });
  function pn(r, e, t, i) {
    e && _u(e, r, {
      x: t.clientX,
      y: t.clientY,
      sourceEvent: t,
      preventer: i,
      prevent(o) {
        return Sa(o);
      }
    });
  }
  bu({
    name: "track",
    touchAction: "none",
    deps: ["mousedown", "touchstart", "touchmove", "touchend"],
    flow: {
      start: ["mousedown", "touchstart"],
      end: ["mouseup", "touchend"]
    },
    emits: ["track"],
    info: {
      x: 0,
      y: 0,
      state: "start",
      started: !1,
      moves: [],
      /** @this {GestureInfo} */
      addMove(r) {
        this.moves.length > tT && this.moves.shift(), this.moves.push(r);
      },
      movefn: null,
      upfn: null,
      prevent: !1
    },
    /**
     * @this {GestureRecognizer}
     * @return {void}
     */
    reset() {
      this.info.state = "start", this.info.started = !1, this.info.moves = [], this.info.x = 0, this.info.y = 0, this.info.prevent = !1, uo(this.info);
    },
    /**
     * @this {GestureRecognizer}
     * @param {MouseEvent} e
     * @return {void}
     */
    mousedown(r) {
      if (!wi(r))
        return;
      const e = Gr(r), t = this, i = (a) => {
        const l = a.clientX, d = a.clientY;
        gg(t.info, l, d) && (t.info.state = t.info.started ? a.type === "mouseup" ? "end" : "track" : "start", t.info.state === "start" && Sa("tap"), t.info.addMove({ x: l, y: d }), wi(a) || (t.info.state = "end", uo(t.info)), e && Ic(t.info, e, a), t.info.started = !0);
      }, o = (a) => {
        t.info.started && i(a), uo(t.info);
      };
      Vb(this.info, i, o), this.info.x = r.clientX, this.info.y = r.clientY;
    },
    /**
     * @this {GestureRecognizer}
     * @param {TouchEvent} e
     * @return {void}
     */
    touchstart(r) {
      const e = r.changedTouches[0];
      this.info.x = e.clientX, this.info.y = e.clientY;
    },
    /**
     * @this {GestureRecognizer}
     * @param {TouchEvent} e
     * @return {void}
     */
    touchmove(r) {
      const e = Gr(r), t = r.changedTouches[0], i = t.clientX, o = t.clientY;
      gg(this.info, i, o) && (this.info.state === "start" && Sa("tap"), this.info.addMove({ x: i, y: o }), Ic(this.info, e, t), this.info.state = "track", this.info.started = !0);
    },
    /**
     * @this {GestureRecognizer}
     * @param {TouchEvent} e
     * @return {void}
     */
    touchend(r) {
      const e = Gr(r), t = r.changedTouches[0];
      this.info.started && (this.info.state = "end", this.info.addMove({ x: t.clientX, y: t.clientY }), Ic(this.info, e, t));
    }
  });
  function gg(r, e, t) {
    if (r.prevent)
      return !1;
    if (r.started)
      return !0;
    const i = Math.abs(r.x - e), o = Math.abs(r.y - t);
    return i >= pg || o >= pg;
  }
  function Ic(r, e, t) {
    if (!e)
      return;
    const i = r.moves[r.moves.length - 2], o = r.moves[r.moves.length - 1], a = o.x - r.x, l = o.y - r.y;
    let d, u = 0;
    i && (d = o.x - i.x, u = o.y - i.y), _u(e, "track", {
      state: r.state,
      x: t.clientX,
      y: t.clientY,
      dx: a,
      dy: l,
      ddx: d,
      ddy: u,
      sourceEvent: t,
      hover() {
        return uT(t.clientX, t.clientY);
      }
    });
  }
  bu({
    name: "tap",
    deps: ["mousedown", "click", "touchstart", "touchend"],
    flow: {
      start: ["mousedown", "touchstart"],
      end: ["click", "touchend"]
    },
    emits: ["tap"],
    info: {
      x: NaN,
      y: NaN,
      prevent: !1
    },
    /**
     * @this {GestureRecognizer}
     * @return {void}
     */
    reset() {
      this.info.x = NaN, this.info.y = NaN, this.info.prevent = !1;
    },
    /**
     * @this {GestureRecognizer}
     * @param {MouseEvent} e
     * @return {void}
     */
    mousedown(r) {
      wi(r) && (this.info.x = r.clientX, this.info.y = r.clientY);
    },
    /**
     * @this {GestureRecognizer}
     * @param {MouseEvent} e
     * @return {void}
     */
    click(r) {
      wi(r) && mg(this.info, r);
    },
    /**
     * @this {GestureRecognizer}
     * @param {TouchEvent} e
     * @return {void}
     */
    touchstart(r) {
      const e = r.changedTouches[0];
      this.info.x = e.clientX, this.info.y = e.clientY;
    },
    /**
     * @this {GestureRecognizer}
     * @param {TouchEvent} e
     * @return {void}
     */
    touchend(r) {
      mg(this.info, r.changedTouches[0], r);
    }
  });
  function mg(r, e, t) {
    const i = Math.abs(e.clientX - r.x), o = Math.abs(e.clientY - r.y), a = Gr(t || e);
    !a || lT[
      /** @type {!HTMLElement} */
      a.localName
    ] && a.hasAttribute("disabled") || (isNaN(i) || isNaN(o) || i <= fg && o <= fg || cT(e)) && (r.prevent || _u(a, "tap", {
      x: e.clientX,
      y: e.clientY,
      sourceEvent: e,
      preventer: t
    }));
  }
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  const Ha = Oe(
    (r) => class extends r {
      /** @protected */
      ready() {
        super.ready(), this.addEventListener("keydown", (t) => {
          this._onKeyDown(t);
        }), this.addEventListener("keyup", (t) => {
          this._onKeyUp(t);
        });
      }
      /**
       * A handler for the `keydown` event. By default, it calls
       * separate methods for handling "Enter" and "Escape" keys.
       * Override the method to implement your own behavior.
       *
       * @param {KeyboardEvent} event
       * @protected
       */
      _onKeyDown(t) {
        switch (t.key) {
          case "Enter":
            this._onEnter(t);
            break;
          case "Escape":
            this._onEscape(t);
            break;
        }
      }
      /**
       * A handler for the `keyup` event. By default, it does nothing.
       * Override the method to implement your own behavior.
       *
       * @param {KeyboardEvent} _event
       * @protected
       */
      _onKeyUp(t) {
      }
      /**
       * A handler for the "Enter" key. By default, it does nothing.
       * Override the method to implement your own behavior.
       *
       * @param {KeyboardEvent} _event
       * @protected
       */
      _onEnter(t) {
      }
      /**
       * A handler for the "Escape" key. By default, it does nothing.
       * Override the method to implement your own behavior.
       *
       * @param {KeyboardEvent} _event
       * @protected
       */
      _onEscape(t) {
      }
    }
  );
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  const Gb = (r) => class extends Wb(Ha(r)) {
    /**
     * An array of activation keys.
     *
     * See possible values here:
     * https://developer.mozilla.org/ru/docs/Web/API/KeyboardEvent/key/Key_Values
     *
     * @protected
     * @return {!Array<!string>}
     */
    get _activeKeys() {
      return [" "];
    }
    /** @protected */
    ready() {
      super.ready(), er(this, "down", (t) => {
        this._shouldSetActive(t) && this._setActive(!0);
      }), er(this, "up", () => {
        this._setActive(!1);
      });
    }
    /** @protected */
    disconnectedCallback() {
      super.disconnectedCallback(), this._setActive(!1);
    }
    /**
     * @param {KeyboardEvent | MouseEvent} _event
     * @protected
     */
    _shouldSetActive(t) {
      return !this.disabled;
    }
    /**
     * Sets the `active` attribute on the element if an activation key is pressed.
     *
     * @param {KeyboardEvent} event
     * @protected
     * @override
     */
    _onKeyDown(t) {
      super._onKeyDown(t), this._shouldSetActive(t) && this._activeKeys.includes(t.key) && (this._setActive(!0), document.addEventListener(
        "keyup",
        (i) => {
          this._activeKeys.includes(i.key) && this._setActive(!1);
        },
        { once: !0 }
      ));
    }
    /**
     * Toggles the `active` attribute on the element.
     *
     * @param {boolean} active
     * @protected
     */
    _setActive(t) {
      this.toggleAttribute("active", t);
    }
  };
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  const Ua = Oe(
    (r) => class extends r {
      /**
       * @protected
       * @return {boolean}
       */
      get _keyboardActive() {
        return O$();
      }
      /** @protected */
      ready() {
        this.addEventListener("focusin", (t) => {
          this._shouldSetFocus(t) && this._setFocused(!0);
        }), this.addEventListener("focusout", (t) => {
          this._shouldRemoveFocus(t) && this._setFocused(!1);
        }), super.ready();
      }
      /** @protected */
      disconnectedCallback() {
        super.disconnectedCallback(), this.hasAttribute("focused") && this._setFocused(!1);
      }
      /**
       * Override to change how focused and focus-ring attributes are set.
       *
       * @param {boolean} focused
       * @protected
       */
      _setFocused(t) {
        this.toggleAttribute("focused", t), this.toggleAttribute("focus-ring", t && this._keyboardActive);
      }
      /**
       * Override to define if the field receives focus based on the event.
       *
       * @param {FocusEvent} _event
       * @return {boolean}
       * @protected
       */
      _shouldSetFocus(t) {
        return !0;
      }
      /**
       * Override to define if the field loses focus based on the event.
       *
       * @param {FocusEvent} _event
       * @return {boolean}
       * @protected
       */
      _shouldRemoveFocus(t) {
        return !0;
      }
    }
  );
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  const jb = (r) => class extends Wb(r) {
    static get properties() {
      return {
        /**
         * Indicates whether the element can be focused and where it participates in sequential keyboard navigation.
         *
         * @protected
         */
        tabindex: {
          type: Number,
          reflectToAttribute: !0,
          observer: "_tabindexChanged"
        },
        /**
         * Stores the last known tabindex since the element has been disabled.
         *
         * @protected
         */
        _lastTabIndex: {
          type: Number
        }
      };
    }
    /**
     * When the element gets disabled, the observer saves the last known tabindex
     * and makes the element not focusable by setting tabindex to -1.
     * As soon as the element gets enabled, the observer restores the last known tabindex
     * so that the element can be focusable again.
     *
     * @protected
     * @override
     */
    _disabledChanged(t, i) {
      super._disabledChanged(t, i), t ? (this.tabindex !== void 0 && (this._lastTabIndex = this.tabindex), this.tabindex = -1) : i && (this.tabindex = this._lastTabIndex);
    }
    /**
     * When the user has changed tabindex while the element is disabled,
     * the observer reverts tabindex to -1 and rather saves the new tabindex value to apply it later.
     * The new value will be applied as soon as the element becomes enabled.
     *
     * @protected
     */
    _tabindexChanged(t) {
      this.disabled && t !== -1 && (this._lastTabIndex = t, this.tabindex = -1);
    }
  };
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  const mT = (r) => class extends Gb(jb(Ua(r))) {
    static get properties() {
      return {
        /**
         * Indicates whether the element can be focused and where it participates in sequential keyboard navigation.
         *
         * @override
         * @protected
         */
        tabindex: {
          value: 0
        }
      };
    }
    /**
     * By default, `Space` is the only possible activation key for a focusable HTML element.
     * Nonetheless, the button is an exception as it can be also activated by pressing `Enter`.
     * See the "Keyboard Support" section in https://www.w3.org/TR/wai-aria-practices/examples/button/button.html.
     *
     * @protected
     * @override
     */
    get _activeKeys() {
      return ["Enter", " "];
    }
    /** @protected */
    ready() {
      super.ready(), this.hasAttribute("role") || this.setAttribute("role", "button");
    }
    /**
     * Since the button component is designed on the base of the `[role=button]` attribute,
     * and doesn't have a native <button> inside, in order to be fully accessible from the keyboard,
     * it should manually fire the `click` event once an activation key is pressed,
     * as it follows from the WAI-ARIA specifications:
     * https://www.w3.org/TR/wai-aria-practices-1.1/#button
     *
     * According to the UI Events specifications,
     * the `click` event should be fired exactly on `keydown`:
     * https://www.w3.org/TR/uievents/#event-type-keydown
     *
     * @param {KeyboardEvent} event
     * @protected
     * @override
     */
    _onKeyDown(t) {
      super._onKeyDown(t), this._activeKeys.includes(t.key) && (t.preventDefault(), this.click());
    }
  };
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  class bg extends mT(fu(Kr(Oi(Gt)))) {
    static get is() {
      return "vaadin-button";
    }
    static get template() {
      return Ar`
      <style>
        :host {
          display: inline-block;
          position: relative;
          outline: none;
          white-space: nowrap;
          -webkit-user-select: none;
          -moz-user-select: none;
          user-select: none;
        }

        :host([hidden]) {
          display: none !important;
        }

        /* Aligns the button with form fields when placed on the same line.
          Note, to make it work, the form fields should have the same "::before" pseudo-element. */
        .vaadin-button-container::before {
          content: '\\2003';
          display: inline-block;
          width: 0;
          max-height: 100%;
        }

        .vaadin-button-container {
          display: inline-flex;
          align-items: center;
          justify-content: center;
          text-align: center;
          width: 100%;
          height: 100%;
          min-height: inherit;
          text-shadow: inherit;
        }

        [part='prefix'],
        [part='suffix'] {
          flex: none;
        }

        [part='label'] {
          white-space: nowrap;
          overflow: hidden;
          text-overflow: ellipsis;
        }
      </style>
      <div class="vaadin-button-container">
        <span part="prefix" aria-hidden="true">
          <slot name="prefix"></slot>
        </span>
        <span part="label">
          <slot></slot>
        </span>
        <span part="suffix" aria-hidden="true">
          <slot name="suffix"></slot>
        </span>
      </div>
      <slot name="tooltip"></slot>
    `;
    }
    /** @protected */
    ready() {
      super.ready(), this._tooltipController = new pu(this), this.addController(this._tooltipController);
    }
  }
  customElements.define(bg.is, bg);
  Te(
    "vaadin-date-picker-overlay-content",
    me`
    :host {
      position: relative;
      /* Background for the year scroller, placed here as we are using a mask image on the actual years part */
      background-image: linear-gradient(var(--lumo-shade-5pct), var(--lumo-shade-5pct));
      background-size: 57px 100%;
      background-position: top right;
      background-repeat: no-repeat;
      cursor: default;
    }

    /* Month scroller */

    [part='months'] {
      /* Month calendar height:
              header height + margin-bottom
            + weekdays height + margin-bottom
            + date cell heights
            + small margin between month calendars
        */
      /* prettier-ignore */
      --vaadin-infinite-scroller-item-height:
          calc(
              var(--lumo-font-size-l) + var(--lumo-space-m)
            + var(--lumo-font-size-xs) + var(--lumo-space-s)
            + var(--lumo-size-m) * 6
            + var(--lumo-space-s)
          );
      --vaadin-infinite-scroller-buffer-offset: 10%;
      -webkit-mask-image: linear-gradient(transparent, #000 10%, #000 85%, transparent);
      mask-image: linear-gradient(transparent, #000 10%, #000 85%, transparent);
      position: relative;
      margin-right: 57px;
    }

    /* Year scroller */
    [part='years'] {
      /* TODO get rid of fixed magic number */
      --vaadin-infinite-scroller-buffer-width: 97px;
      width: 57px;
      height: auto;
      top: 0;
      bottom: 0;
      font-size: var(--lumo-font-size-s);
      box-shadow: inset 2px 0 4px 0 var(--lumo-shade-5pct);
      -webkit-mask-image: linear-gradient(transparent, #000 35%, #000 65%, transparent);
      mask-image: linear-gradient(transparent, #000 35%, #000 65%, transparent);
      cursor: var(--lumo-clickable-cursor);
    }

    [part='year-number']:not([current]),
    [part='year-separator'] {
      opacity: 0.7;
      transition: 0.2s opacity;
    }

    [part='years']:hover [part='year-number'],
    [part='years']:hover [part='year-separator'] {
      opacity: 1;
    }

    /* TODO unsupported selector */
    #scrollers {
      position: static;
      display: block;
    }

    /* TODO unsupported selector, should fix this in vaadin-date-picker that it adapts to the
       * width of the year scroller */
    #scrollers[desktop] [part='months'] {
      right: auto;
    }

    /* Year scroller position indicator */
    [part='years']::before {
      border: none;
      width: 1em;
      height: 1em;
      background-color: var(--lumo-base-color);
      background-image: linear-gradient(var(--lumo-tint-5pct), var(--lumo-tint-5pct));
      transform: translate(-75%, -50%) rotate(45deg);
      border-top-right-radius: var(--lumo-border-radius-s);
      box-shadow: 2px -2px 6px 0 var(--lumo-shade-5pct);
      z-index: 1;
    }

    [part='year-number'],
    [part='year-separator'] {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 50%;
      transform: translateY(-50%);
    }

    [part='years'] [part='year-separator']::after {
      color: var(--lumo-disabled-text-color);
      content: '•';
    }

    /* Current year */

    [part='years'] [part='year-number'][current] {
      color: var(--lumo-primary-text-color);
    }

    /* Toolbar (footer) */

    [part='toolbar'] {
      padding: var(--lumo-space-s);
      border-bottom-left-radius: var(--lumo-border-radius-l);
      margin-right: 57px;
    }

    /* Today and Cancel buttons */

    [part='toolbar'] [part\$='button'] {
      margin: 0;
    }

    /* Narrow viewport mode (fullscreen) */

    :host([fullscreen]) [part='toolbar'] {
      order: -1;
      background-color: var(--lumo-base-color);
    }

    :host([fullscreen]) [part='overlay-header'] {
      order: -2;
      height: var(--lumo-size-m);
      padding: var(--lumo-space-s);
      position: absolute;
      left: 0;
      right: 0;
      justify-content: center;
    }

    :host([fullscreen]) [part='toggle-button'],
    :host([fullscreen]) [part='clear-button'],
    [part='overlay-header'] [part='label'] {
      display: none;
    }

    /* Very narrow screen (year scroller initially hidden) */

    [part='years-toggle-button'] {
      display: flex;
      align-items: center;
      height: var(--lumo-size-s);
      padding: 0 0.5em;
      border-radius: var(--lumo-border-radius-m);
      z-index: 3;
      color: var(--lumo-primary-text-color);
      font-weight: 500;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    :host([years-visible]) [part='years-toggle-button'] {
      background-color: var(--lumo-primary-color);
      color: var(--lumo-primary-contrast-color);
    }

    /* TODO magic number (same as used for media-query in vaadin-date-picker-overlay-content) */
    @media screen and (max-width: 374px) {
      :host {
        background-image: none;
      }

      [part='years'] {
        background-color: var(--lumo-shade-5pct);
      }

      [part='toolbar'],
      [part='months'] {
        margin-right: 0;
      }

      /* TODO make date-picker adapt to the width of the years part */
      [part='years'] {
        --vaadin-infinite-scroller-buffer-width: 90px;
        width: 50px;
      }

      :host([years-visible]) [part='months'] {
        padding-left: 50px;
      }
    }
  `,
    { moduleId: "lumo-date-picker-overlay-content" }
  );
  Te(
    "vaadin-month-calendar",
    me`
    :host {
      -moz-user-select: none;
      -webkit-user-select: none;
      -webkit-tap-highlight-color: transparent;
      user-select: none;
      font-size: var(--lumo-font-size-m);
      color: var(--lumo-body-text-color);
      text-align: center;
      padding: 0 var(--lumo-space-xs);
    }

    /* Month header */

    [part='month-header'] {
      color: var(--lumo-header-text-color);
      font-size: var(--lumo-font-size-l);
      line-height: 1;
      font-weight: 500;
      margin-bottom: var(--lumo-space-m);
    }

    /* Week days and numbers */

    [part='weekdays'],
    [part='weekday'],
    [part='week-number'] {
      font-size: var(--lumo-font-size-xxs);
      line-height: 1;
      color: var(--lumo-secondary-text-color);
    }

    [part='weekdays'] {
      margin-bottom: var(--lumo-space-s);
    }

    [part='weekday']:empty,
    [part='week-number'] {
      width: var(--lumo-size-xs);
    }

    /* Date and week number cells */

    [part='date'],
    [part='week-number'] {
      box-sizing: border-box;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      height: var(--lumo-size-m);
      position: relative;
    }

    [part='date'] {
      transition: color 0.1s;
    }

    [part='date']:not(:empty) {
      cursor: var(--lumo-clickable-cursor);
    }

    :host([week-numbers]) [part='weekday']:not(:empty),
    :host([week-numbers]) [part='date'] {
      width: calc((100% - var(--lumo-size-xs)) / 7);
    }

    /* Today date */

    [part='date'][today] {
      color: var(--lumo-primary-text-color);
    }

    /* Focused date */

    [part='date']::before {
      content: '';
      position: absolute;
      z-index: -1;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      min-width: 2em;
      min-height: 2em;
      width: 80%;
      height: 80%;
      max-height: 100%;
      max-width: 100%;
      border-radius: var(--lumo-border-radius-m);
    }

    [part='date'][focused]::before {
      box-shadow: 0 0 0 1px var(--lumo-base-color), 0 0 0 3px var(--lumo-primary-color-50pct);
    }

    :host(:not([focused])) [part='date'][focused]::before {
      animation: vaadin-date-picker-month-calendar-focus-date 1.4s infinite;
    }

    @keyframes vaadin-date-picker-month-calendar-focus-date {
      50% {
        box-shadow: 0 0 0 1px var(--lumo-base-color), 0 0 0 3px transparent;
      }
    }

    [part='date']:not(:empty):not([disabled]):not([selected]):hover::before {
      background-color: var(--lumo-primary-color-10pct);
    }

    [part='date'][selected] {
      color: var(--lumo-primary-contrast-color);
    }

    [part='date'][selected]::before {
      background-color: var(--lumo-primary-color);
    }

    [part='date'][disabled] {
      color: var(--lumo-disabled-text-color);
    }

    @media (pointer: coarse) {
      [part='date']:hover:not([selected])::before,
      [part='date'][focused]:not([selected])::before {
        display: none;
      }

      [part='date']:not(:empty):not([disabled]):active::before {
        display: block;
      }

      [part='date'][selected]::before {
        box-shadow: none;
      }
    }

    /* Disabled */

    :host([disabled]) * {
      color: var(--lumo-disabled-text-color) !important;
    }
  `,
    { moduleId: "lumo-month-calendar" }
  );
  const Zb = document.createElement("template");
  Zb.innerHTML = `
  <style>
    @keyframes vaadin-date-picker-month-calendar-focus-date {
      50% {
        box-shadow: 0 0 0 2px transparent;
      }
    }
  </style>
`;
  document.head.appendChild(Zb.content);
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  const Kb = document.createElement("template");
  Kb.innerHTML = `
  <style>
    @font-face {
      font-family: 'lumo-icons';
      src: url(data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAABEgAAsAAAAAIjQAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABCAAAADsAAABUIIslek9TLzIAAAFEAAAAQwAAAFZAIUuKY21hcAAAAYgAAAD4AAADrsCU8d5nbHlmAAACgAAAC2cAABeAWri7U2hlYWQAAA3oAAAAMAAAADZa/6SsaGhlYQAADhgAAAAdAAAAJAbpA35obXR4AAAOOAAAABAAAACspBAAAGxvY2EAAA5IAAAAWAAAAFh57oA4bWF4cAAADqAAAAAfAAAAIAFKAXBuYW1lAAAOwAAAATEAAAIuUUJZCHBvc3QAAA/0AAABKwAAAelm8SzVeJxjYGRgYOBiMGCwY2BycfMJYeDLSSzJY5BiYGGAAJA8MpsxJzM9kYEDxgPKsYBpDiBmg4gCACY7BUgAeJxjYGS+yDiBgZWBgamKaQ8DA0MPhGZ8wGDIyAQUZWBlZsAKAtJcUxgcXjG+0mIO+p/FEMUcxDANKMwIkgMABn8MLQB4nO3SWW6DMABF0UtwCEnIPM/zhLK8LqhfXRybSP14XUYtHV9hGYQwQBNIo3cUIPkhQeM7rib1ekqnXg981XuC1qvy84lzojleh3puxL0hPjGjRU473teloEefAUNGjJkwZcacBUtWrNmwZceeA0dOnLlw5cadB09elPGhGf+j0NTI/65KfXerT6JhqKnpRKtgOpuqaTrtKjPUlqHmhto21I7pL6i6hlqY3q7qGWrfUAeGOjTUkaGODXViqFNDnRnq3FAXhro01JWhrg11Y6hbQ90Z6t5QD4Z6NNSToZ4N9WKoV0O9GerdUB+G+jTUl6GWRvkL24BkEXictVh9bFvVFb/nxvbz+7Rf/N6zHcd2bCfP+Wic1Z9N0jpNHCD9SNqqoVBgbQoMjY+pjA4hNnWa2pV1rHSIif0DGkyT2k10Kmu1Cag6huj4ZpqYBHSqJsTEJgZCG3TaVBFv595nO3ZIv4RIrPPuvefe884599zzO/cRF8G/tgn6CFFImNgkR0ggX8wlspbhSSWSdrC5ozd30s2dw5afzvgtyz9/zG9t1hV4RtF1pXolowvtzc2z6L2aYUQM45jKH9WDTvd1LRDoDASYWhfTzTyvboXz6uZX4ARX5wrF39y+HM2+CJ8d0pkyqBIqoze3D12ez4DrFoYzxI8dWwMrDlZ2DMqQAR9AROsJU+2smlTPaTTco52BVxXa2a2+I8vvqd2dVHm1LoPeTn/AZPRYGthDYOeZjBjKoFsVGulR3lGU95SeCK44oHU7MhWUGUKZDT3oSUcG2GWuh+EDDfUYA/jhIhl0TOsJNYSEu7mQmi3UzfXwZKA4BsVsHLXQYGgJW95qEtpJ1VcW9HiTriZBlFEqxsDjA09yCNUoQxxwd7KWSTt2y3GTKifkqHRCoWZc3m11Wa/dKdFgXD4kSYfkeJBKd8KMz7J8dZn/cGRCcLGDnA2Ge3bKzcvlnTDNthFWLH7Xt80ua5FMjA4WKelWv5Xo16vHuYzpRbJhhdVlftuRK0VlR27D9lu5TF0DPBi60OrHNO0AfP/uRWvhn/U3LXICE+nh+3IHPUJ8JE6GyBjZQLbjGchlrSgYngF8zyrIF4NJD3atUcgWsWunGN/UHX5B5/yg7uF87Nqp4Gf52F3gH73DjEZNRoqCKAr9giQJp5rGJABpiVE2htNhW9R8nw0jqYjCYcY4LIjwYNScf4WN06IZnZCEqsI4cFaQbo4Z1TsZBx40YhXkHOecaYE5oY37IIQ+iJJ+UsDYSun5MuRSBRZRUUhlY2DqOGajOR6zrSU/5My6l2DnusH1GQgnw5BZP7iuYM/ahcfQ7Z8y51ddfutvuwNqWQ0cBYr8fj0U0vsHpwerVaB2sWhXT2NExi2r1KUE2tUuVMnkepVQrxTmpQrZTG4iu8he8iPyM3KcPE/+RP5KPoE2CEAKclCBzXATxkYOtUY/o961PWRqsj0chRrHFBbtrjP9/P0ven5pcbRdpL94vfsy33e5+izuwz3nFLFPVNayPZx/jdG1fOChflFRvYzsW6L18efgLrSWIgvcqnGJYi4skO4xREURjbDuxKke5v0T3Mrzkt2fi31uyZlLLrqIpEuXXsMlgw442Jb0GAxjS1DM20kBoCzHLXm/jEm0IltdcvU0fEW24jgiwwRjVd9u4NJHcIyoHJcwvyVqgqj5hqBJ1ZWSJryh9p56UWhX1XbhRbW2ZopuZWsQd5y8mEQ8M+C6xjRYxZbDKWf5AgY+Qq/l6wSPk16zDFjowYuu+wjx13mfkxbyDDxadYT/LijZyI0THB+6yfLaWsRcO82zo9mWTNtpO18qlorZoIVMwSN40tky5DOQ1MCIAe24mvlsuwIIxPb10+uXDQ4uWz/9m3rj+ql7p6bufZARuPVq5tXtsn6KwfP8Jy0TeWOyNhUJN6mhX5rkUTtUppQWEMNTqEdaCGKFYKJaQrCE4JtDLYOlNEKmO5kBTPGY2A0N2sY3+dVlo1N9ycBsIGtOjQ2p/tlZvzo0ur4v6cOh8NTospB7U/X40KahoU3bGIH97dnwmtHlYffVG3R1YOwKM2vNhrPhCT5zk64sG53oS4b31aYjqe/B7+kQiXBN+b6h21hNUPMq29B8CU4elINdygMPKF1B+WBTG7Z9ZshpN/xwEuuDQZR+nuoo4CDaAiiwXmLpmukMQyPf/JMclqgL1ixZQ/nnP2VbdUODFGt2fgBvL123rlLYu/6A9ckb7F3K0/CyBMEu6aQoPscroCcacVehvyQyCZAsizsWWBkoLC+WAiWnOksLKaeuQDzGuqSk42aiYTiJ4zf9afl17SrqaTO1f+XlZAfIuYcq7/IqYMaMrksOJ6vHkOCPDq943xcCnHqVD9pHFRpMqSPXrIua1WNs+tOz1U+ciTCDpPk+c4QYJIHnYhxP/kVPAq+ahFpVhPcHp8qyarhiF+HsBU9Hrl+UZa876fbKipL0KqB6OdUveErgtOI97fZ63ae9SvWU6k2w1JfwqnUbHsYcFCJFrC/W12zIMMirWYEHxMPs6LGYSdkSZ5TsNP9PCpwnWC3HKZ1lydNjWHC2Mn3l6vL0dHn1ldP3LTSrX+vKrBqv7KmMr8p0SR6P1NqF63or6XRlIyO90f7+kf7+myOhvt4tq7f09oUiTc2/dycGgqFQcCDRLYmi1NL7fk0CknVMxEg/cdfs/TnpJMNkgqwj17B8beVazSrVbU4lG67IZYOCnWrYy3yBR9cyWcChywos3LJBEdhhFoAdYjiw0rLGm0xU5OzoGm5/ZfmHjVZpNNg6SznzGKDdwv2cCtVn6Eaxo12cfxLprpVtTcZ6hVx6dow7Yq7e8LXO8PY9Jgjoze9yCtU5FNbegcKkQMdCbt9au/te4Ebe0jkc0ukUL32eYnTpNs20h0KpUOhZPYwVcfhZnfdqeCvDfXiuCbAoYWcXERPc/mDQD3/hdF+wK4i/xv3kYfprIpAuMkk2kW3kdtS0kBIKpZwp8KxmsCyfM1MFzAss9LBkDxRyThiaqTLwKYKJVTwmWTudMyz+yks09346MDh4m72yOxCKrt1XMlQ1qPVlTEVVQ1ofdK/sCWjtZu9qGwZ8YZ9PPWlo1IV3eW3+U0aXblP39zrt+JPf6UhEQ1rUjNBULN+utyuaDNW34kpAVuSOeMTyWbSNWnooFu+QFNWQ4d/Ox4IPWx41fP/fB/Rjeoz08ezPA9TysMtmnOXfGN7Ui3xIYLDALrlDLOP09qtJuY2OeL0+QZXdRnR1nxRVBF/SOyKKPpcrn9mWzH4rH9IidE+PTNU2182+hOgSItrE1slByS24vaLvJpxOqe4Pduf3HJkZ+jLqUz9rRzB7p8gKcgWZwV1L8JtUS5Z2JxZSOCuBoMTQihMzLbCPA0KqGMAljRQjONklW/wjnXKy8vxT/Elvm3/KiMUMOoV0/vnDYlhec0SMKtt3/kKMyOt33tj2bqxQLsTjSGLl+EAsNhCnTyRGktW55EgCn/A4PlnWn+Mg8bgZrWqHxTbPwMuyy1u5YeZF2SUM7JRhddwRgiRuxpmgJmxn9ZW7XpcF3ViX/ar6ptRpGJ0S9Adg4qhb9sI3vbL7qNJV/y4i07t5TZBiho1imFoMz3gED+CtjYUxvP4SOxov4bFoNPg5aR1e+G4UgDPoedJTpogyCJ7oYvRqoVS0MQAy+CoNEdTDUjok5ZHZL/WtjV7rFj3PKQE3iKp7ou+rIxN3b9LB1dGjeT4cvKo3FrnWpYpuaFd/h3dtV8UeKN1Y9hpR3dt4p0H/zKuPQq0kZQUIIpuDfoiETsnIk+gCWMJZUXHtE8V9LkUc2TE8vOMbO4ax/MACabzyaGXc7u3FBr11ThBdB8SIeMAlCntG2KThHSPsaj2Dc9KNyY2a0KZ7ODaTHoRiFkeYz+shZBpCS4X6471KKKnuHd84edfk5F37d1XO5bbkcltu2ZLNbvnPXiUVAnVvprJrP+NObryjxrllS65md6Tm6wzFHRR4dY3QUUjb7MgxaIixU8hspi98fl/Xc+IB4iU66eCVL9YfAfahiSUt4TONS8x0D8W7u8vd3fGWx6OXlM/U1IoU/s61PGhpyXRFa3eReq2qG56lvmYtXavCC1iN7lbiBpWxXHU+cSlztVLVz0tVN600fVsLxaVDknhYioeoXP3t4lqV1r79MAw0GCI1FTL1YIGzPL1MMlJ9ZsN9P7lvA2yr9ZFUzwzPrVgxN/x/SS+chwB4nGNgZGBgAOLPrYdY4vltvjJwM78AijDUqG5oRND/XzNPZboF5HIwMIFEAU/lC+J4nGNgZGBgDvqfBSRfMAAB81QGRgZUoA0AVvYDbwAAAHicY2BgYGB+MTQwAM8EJo8AAAAAAE4AmgDoAQoBLAFOAXABmgHEAe4CGgKcAugEmgS8BNYE8gUOBSoFegXQBf4GRAZmBrYHGAeQCBgIUghqCP4JRgm+CdoKBAo+CoQKugr0C1QLmgvAeJxjYGRgYNBmTGEQZQABJiDmAkIGhv9gPgMAGJQBvAB4nG2RPU7DMBiG3/QP0UoIBGJh8QILavozdmRo9w7d09RpUzlx5LgVvQMn4BAcgoEzcAgOwVvzSZVQbcnf48fvFysJgGt8IcJxROiG9TgauODuj5ukG+EW+UG4jR4ehTv0Q+EunjER7uEWmk+IWpc0d3gVbuAKb8JN+nfhFvlDuI17fAp36L+Fu1jgR7iHp+jF7Arbz1Nb1nO93pnEncSJFtrVuS3VKB6e5EyX2iVer9TyoOr9eux9pjJnCzW1pdfGWFU5u9WpjzfeV5PBIBMfp7aAwQ4FLPrIkbKWqDHn+67pDRK4s4lzbsEux5qHvcIIMb/nueSMyTKkE3jWFdNLHLjW2PPmMa1Hxn3GjGW/wjT0HtOG09JU4WxLk9LH2ISuiv9twJn9y8fh9uIXI+BknAAAAHicbY7ZboMwEEW5CVBCSLrv+76kfJRjTwHFsdGAG+Xvy5JUfehIHp0rnxmNN/D6ir3/a4YBhvARIMQOIowQY4wEE0yxiz3s4wCHOMIxTnCKM5zjApe4wjVucIs73OMBj3jCM17wije84wMzfHqJ0EVmUkmmJo77oOmrHvfIRZbXsTCZplTZldlgb3TYGVHProwFs11t1A57tcON2rErR3PBqcwF1/6ctI6k0GSU4JHMSS6WghdJQ99sTbfuN7QLJ9vQ37dNrgyktnIxlDYLJNuqitpRbYWKFNuyDT6pog6oOYKHtKakeakqKjHXpPwlGRcsC+OqxLIiJpXqoqqDMreG2l5bv9Ri3TRX+c23DZna9WFFgmXuO6Ps1Jm/w6ErW8N3FbHn/QC444j0AA==) format('woff');
      font-weight: normal;
      font-style: normal;
    }

    html {
      --lumo-icons-align-center: "\\ea01";
      --lumo-icons-align-left: "\\ea02";
      --lumo-icons-align-right: "\\ea03";
      --lumo-icons-angle-down: "\\ea04";
      --lumo-icons-angle-left: "\\ea05";
      --lumo-icons-angle-right: "\\ea06";
      --lumo-icons-angle-up: "\\ea07";
      --lumo-icons-arrow-down: "\\ea08";
      --lumo-icons-arrow-left: "\\ea09";
      --lumo-icons-arrow-right: "\\ea0a";
      --lumo-icons-arrow-up: "\\ea0b";
      --lumo-icons-bar-chart: "\\ea0c";
      --lumo-icons-bell: "\\ea0d";
      --lumo-icons-calendar: "\\ea0e";
      --lumo-icons-checkmark: "\\ea0f";
      --lumo-icons-chevron-down: "\\ea10";
      --lumo-icons-chevron-left: "\\ea11";
      --lumo-icons-chevron-right: "\\ea12";
      --lumo-icons-chevron-up: "\\ea13";
      --lumo-icons-clock: "\\ea14";
      --lumo-icons-cog: "\\ea15";
      --lumo-icons-cross: "\\ea16";
      --lumo-icons-download: "\\ea17";
      --lumo-icons-dropdown: "\\ea18";
      --lumo-icons-edit: "\\ea19";
      --lumo-icons-error: "\\ea1a";
      --lumo-icons-eye: "\\ea1b";
      --lumo-icons-eye-disabled: "\\ea1c";
      --lumo-icons-menu: "\\ea1d";
      --lumo-icons-minus: "\\ea1e";
      --lumo-icons-ordered-list: "\\ea1f";
      --lumo-icons-phone: "\\ea20";
      --lumo-icons-photo: "\\ea21";
      --lumo-icons-play: "\\ea22";
      --lumo-icons-plus: "\\ea23";
      --lumo-icons-redo: "\\ea24";
      --lumo-icons-reload: "\\ea25";
      --lumo-icons-search: "\\ea26";
      --lumo-icons-undo: "\\ea27";
      --lumo-icons-unordered-list: "\\ea28";
      --lumo-icons-upload: "\\ea29";
      --lumo-icons-user: "\\ea2a";
    }
  </style>
`;
  document.head.appendChild(Kb.content);
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  const Jb = me`
  [part$='button'] {
    flex: none;
    width: 1em;
    height: 1em;
    line-height: 1;
    font-size: var(--lumo-icon-size-m);
    text-align: center;
    color: var(--lumo-contrast-60pct);
    transition: 0.2s color;
    cursor: var(--lumo-clickable-cursor);
  }

  [part$='button']:hover {
    color: var(--lumo-contrast-90pct);
  }

  :host([disabled]) [part$='button'],
  :host([readonly]) [part$='button'] {
    color: var(--lumo-contrast-20pct);
    cursor: default;
  }

  [part$='button']::before {
    font-family: 'lumo-icons';
    display: block;
  }
`;
  Te("", Jb, { moduleId: "lumo-field-button" });
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  const bT = me`
  :host([has-helper]) [part='helper-text']::before {
    content: '';
    display: block;
    height: 0.4em;
  }

  [part='helper-text'] {
    display: block;
    color: var(--lumo-secondary-text-color);
    font-size: var(--lumo-font-size-xs);
    line-height: var(--lumo-line-height-xs);
    margin-left: calc(var(--lumo-border-radius-m) / 4);
    transition: color 0.2s;
  }

  :host(:hover:not([readonly])) [part='helper-text'] {
    color: var(--lumo-body-text-color);
  }

  :host([disabled]) [part='helper-text'] {
    color: var(--lumo-disabled-text-color);
    -webkit-text-fill-color: var(--lumo-disabled-text-color);
  }

  :host([has-helper][theme~='helper-above-field']) [part='helper-text']::before {
    display: none;
  }

  :host([has-helper][theme~='helper-above-field']) [part='helper-text']::after {
    content: '';
    display: block;
    height: 0.4em;
  }

  :host([has-helper][theme~='helper-above-field']) [part='label'] {
    order: 0;
    padding-bottom: 0.4em;
  }

  :host([has-helper][theme~='helper-above-field']) [part='helper-text'] {
    order: 1;
  }

  :host([has-helper][theme~='helper-above-field']) [part='label'] + * {
    order: 2;
  }

  :host([has-helper][theme~='helper-above-field']) [part='error-message'] {
    order: 3;
  }
`;
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  const Xb = me`
  [part='label'] {
    align-self: flex-start;
    color: var(--lumo-secondary-text-color);
    font-weight: 500;
    font-size: var(--lumo-font-size-s);
    margin-left: calc(var(--lumo-border-radius-m) / 4);
    transition: color 0.2s;
    line-height: 1;
    padding-right: 1em;
    padding-bottom: 0.5em;
    /* As a workaround for diacritics being cut off, add a top padding and a 
    negative margin to compensate */
    padding-top: 0.25em;
    margin-top: -0.25em;
    overflow: hidden;
    white-space: nowrap;
    text-overflow: ellipsis;
    position: relative;
    max-width: 100%;
    box-sizing: border-box;
  }

  :host([has-label])::before {
    margin-top: calc(var(--lumo-font-size-s) * 1.5);
  }

  :host([has-label][theme~='small'])::before {
    margin-top: calc(var(--lumo-font-size-xs) * 1.5);
  }

  :host([has-label]) {
    padding-top: var(--lumo-space-m);
  }

  :host([has-label]) ::slotted([slot='tooltip']) {
    --vaadin-tooltip-offset-bottom: calc((var(--lumo-space-m) - var(--lumo-space-xs)) * -1);
  }

  :host([required]) [part='required-indicator']::after {
    content: var(--lumo-required-field-indicator, '•');
    transition: opacity 0.2s;
    color: var(--lumo-required-field-indicator-color, var(--lumo-primary-text-color));
    position: absolute;
    right: 0;
    width: 1em;
    text-align: center;
  }

  :host([invalid]) [part='required-indicator']::after {
    color: var(--lumo-required-field-indicator-color, var(--lumo-error-text-color));
  }

  [part='error-message'] {
    margin-left: calc(var(--lumo-border-radius-m) / 4);
    font-size: var(--lumo-font-size-xs);
    line-height: var(--lumo-line-height-xs);
    color: var(--lumo-error-text-color);
    will-change: max-height;
    transition: 0.4s max-height;
    max-height: 5em;
  }

  :host([has-error-message]) [part='error-message']::before,
  :host([has-error-message]) [part='error-message']::after {
    content: '';
    display: block;
    height: 0.4em;
  }

  :host(:not([invalid])) [part='error-message'] {
    max-height: 0;
    overflow: hidden;
  }

  /* RTL specific styles */

  :host([dir='rtl']) [part='label'] {
    margin-left: 0;
    margin-right: calc(var(--lumo-border-radius-m) / 4);
  }

  :host([dir='rtl']) [part='label'] {
    padding-left: 1em;
    padding-right: 0;
  }

  :host([dir='rtl']) [part='required-indicator']::after {
    right: auto;
    left: 0;
  }

  :host([dir='rtl']) [part='error-message'] {
    margin-left: 0;
    margin-right: calc(var(--lumo-border-radius-m) / 4);
  }
`;
  Te("", Xb, { moduleId: "lumo-required-field" });
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  const _T = me`
  :host {
    --lumo-text-field-size: var(--lumo-size-m);
    color: var(--lumo-body-text-color);
    font-size: var(--lumo-font-size-m);
    font-family: var(--lumo-font-family);
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    -webkit-tap-highlight-color: transparent;
    padding: var(--lumo-space-xs) 0;
  }

  :host::before {
    height: var(--lumo-text-field-size);
    box-sizing: border-box;
    display: inline-flex;
    align-items: center;
  }

  :host([focused]:not([readonly])) [part='label'] {
    color: var(--lumo-primary-text-color);
  }

  :host([focused]) [part='input-field'] ::slotted(:is(input, textarea)) {
    -webkit-mask-image: none;
    mask-image: none;
  }

  ::slotted(:is(input, textarea):placeholder-shown) {
    color: var(--lumo-secondary-text-color);
  }

  /* Hover */
  :host(:hover:not([readonly]):not([focused])) [part='label'] {
    color: var(--lumo-body-text-color);
  }

  :host(:hover:not([readonly]):not([focused])) [part='input-field']::after {
    opacity: 0.1;
  }

  /* Touch device adjustment */
  @media (pointer: coarse) {
    :host(:hover:not([readonly]):not([focused])) [part='label'] {
      color: var(--lumo-secondary-text-color);
    }

    :host(:hover:not([readonly]):not([focused])) [part='input-field']::after {
      opacity: 0;
    }

    :host(:active:not([readonly]):not([focused])) [part='input-field']::after {
      opacity: 0.2;
    }
  }

  /* Trigger when not focusing using the keyboard */
  :host([focused]:not([focus-ring]):not([readonly])) [part='input-field']::after {
    transform: scaleX(0);
    transition-duration: 0.15s, 1s;
  }

  /* Focus-ring */
  :host([focus-ring]) [part='input-field'] {
    box-shadow: 0 0 0 2px var(--lumo-primary-color-50pct);
  }

  /* Read-only and disabled */
  :host(:is([readonly], [disabled])) ::slotted(:is(input, textarea):placeholder-shown) {
    opacity: 0;
  }

  /* Disabled style */
  :host([disabled]) {
    pointer-events: none;
  }

  :host([disabled]) [part='label'],
  :host([disabled]) [part='input-field'] ::slotted(*) {
    color: var(--lumo-disabled-text-color);
    -webkit-text-fill-color: var(--lumo-disabled-text-color);
  }

  /* Invalid style */
  :host([invalid][focus-ring]) [part='input-field'] {
    box-shadow: 0 0 0 2px var(--lumo-error-color-50pct);
  }

  :host([input-prevented]) [part='input-field'] {
    animation: shake 0.15s infinite;
  }

  @keyframes shake {
    25% {
      transform: translateX(4px);
    }
    75% {
      transform: translateX(-4px);
    }
  }

  /* Small theme */
  :host([theme~='small']) {
    font-size: var(--lumo-font-size-s);
    --lumo-text-field-size: var(--lumo-size-s);
  }

  :host([theme~='small']) [part='label'] {
    font-size: var(--lumo-font-size-xs);
  }

  :host([theme~='small']) [part='error-message'] {
    font-size: var(--lumo-font-size-xxs);
  }

  /* Slotted content */
  [part='input-field'] ::slotted(:not(iron-icon):not(vaadin-icon):not(input):not(textarea)) {
    color: var(--lumo-secondary-text-color);
    font-weight: 400;
  }

  [part='clear-button']::before {
    content: var(--lumo-icons-cross);
  }
`, Qb = [Xb, Jb, bT, _T];
  Te("", Qb, {
    moduleId: "lumo-input-field-shared-styles"
  });
  const vT = me`
  :host {
    outline: none;
  }

  [part='toggle-button']::before {
    content: var(--lumo-icons-calendar);
  }

  [part='clear-button']::before {
    content: var(--lumo-icons-cross);
  }

  @media (max-width: 420px), (max-height: 420px) {
    [part='overlay-content'] {
      height: 70vh;
    }
  }

  :host([dir='rtl']) [part='input-field'] ::slotted(input) {
    --_lumo-text-field-overflow-mask-image: linear-gradient(to left, transparent, #000 1.25em);
  }

  :host([dir='rtl']) [part='input-field'] ::slotted(input:placeholder-shown) {
    --_lumo-text-field-overflow-mask-image: none;
  }
`;
  Te("vaadin-date-picker", [Qb, vT], { moduleId: "lumo-date-picker" });
  /**
   * @fileoverview
   * @suppress {checkPrototypalTypes}
   * @license Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt The complete set of authors may be found
   * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may
   * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by
   * Google as part of the polymer project is also subject to an additional IP
   * rights grant found at http://polymer.github.io/PATENTS.txt
   */
  const Mc = "disable-upgrade", yT = (r) => {
    for (; r; ) {
      const e = Object.getOwnPropertyDescriptor(r, "observedAttributes");
      if (e)
        return e.get;
      r = Object.getPrototypeOf(r.prototype).constructor;
    }
    return () => [];
  }, wT = Oe((r) => {
    const e = kb(r);
    let t = yT(e);
    class i extends e {
      constructor() {
        super(), this.__isUpgradeDisabled;
      }
      static get observedAttributes() {
        return t.call(this).concat(Mc);
      }
      // Prevent element from initializing properties when it's upgrade disabled.
      /** @override */
      _initializeProperties() {
        this.hasAttribute(Mc) ? this.__isUpgradeDisabled = !0 : super._initializeProperties();
      }
      // Prevent element from enabling properties when it's upgrade disabled.
      // Normally overriding connectedCallback would be enough, but dom-* elements
      /** @override */
      _enableProperties() {
        this.__isUpgradeDisabled || super._enableProperties();
      }
      // If the element starts upgrade-disabled and a property is set for
      // which an accessor exists, the default should not be applied.
      // This additional check is needed because defaults are applied via
      // `_initializeProperties` which is called after initial properties
      // have been set when the element starts upgrade-disabled.
      /** @override */
      _canApplyPropertyDefault(a) {
        return super._canApplyPropertyDefault(a) && !(this.__isUpgradeDisabled && this._isPropertyPending(a));
      }
      /**
       * @override
       * @param {string} name Attribute name.
       * @param {?string} old The previous value for the attribute.
       * @param {?string} value The new value for the attribute.
       * @param {?string} namespace The XML namespace for the attribute.
       * @return {void}
       */
      attributeChangedCallback(a, l, d, u) {
        a == Mc ? this.__isUpgradeDisabled && d == null && (super._initializeProperties(), this.__isUpgradeDisabled = !1, ye(this).isConnected && super.connectedCallback()) : super.attributeChangedCallback(
          a,
          l,
          d,
          /** @type {null|string} */
          u
        );
      }
      // Prevent element from connecting when it's upgrade disabled.
      // This prevents user code in `attached` from being called.
      /** @override */
      connectedCallback() {
        this.__isUpgradeDisabled || super.connectedCallback();
      }
      // Prevent element from disconnecting when it's upgrade disabled.
      // This avoids allowing user code `detached` from being called without a
      // paired call to `attached`.
      /** @override */
      disconnectedCallback() {
        this.__isUpgradeDisabled || super.disconnectedCallback();
      }
    }
    return i;
  });
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  function kT(r) {
    const e = [];
    for (; r; ) {
      if (r.nodeType === Node.DOCUMENT_NODE) {
        e.push(r);
        break;
      }
      if (r.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
        e.push(r), r = r.host;
        continue;
      }
      if (r.assignedSlot) {
        r = r.assignedSlot;
        continue;
      }
      r = r.parentNode;
    }
    return e;
  }
  function e_(r) {
    return r ? new Set(r.split(" ")) : /* @__PURE__ */ new Set();
  }
  function t_(r) {
    return [...r].join(" ");
  }
  function xT(r, e, t) {
    const i = e_(r.getAttribute(e));
    i.add(t), r.setAttribute(e, t_(i));
  }
  function CT(r, e, t) {
    const i = e_(r.getAttribute(e));
    if (i.delete(t), i.size === 0) {
      r.removeAttribute(e);
      return;
    }
    r.setAttribute(e, t_(i));
  }
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  const Nc = {
    start: "top",
    end: "bottom"
  }, Lc = {
    start: "left",
    end: "right"
  }, _g = new ResizeObserver((r) => {
    setTimeout(() => {
      r.forEach((e) => {
        e.target.__overlay && e.target.__overlay._updatePosition();
      });
    });
  }), ST = (r) => class extends r {
    static get properties() {
      return {
        /**
         * The element next to which this overlay should be aligned.
         * The position of the overlay relative to the positionTarget can be adjusted
         * with properties `horizontalAlign`, `verticalAlign`, `noHorizontalOverlap`
         * and `noVerticalOverlap`.
         */
        positionTarget: {
          type: Object,
          value: null
        },
        /**
         * When `positionTarget` is set, this property defines whether to align the overlay's
         * left or right side to the target element by default.
         * Possible values are `start` and `end`.
         * RTL is taken into account when interpreting the value.
         * The overlay is automatically flipped to the opposite side when it doesn't fit into
         * the default side defined by this property.
         *
         * @attr {start|end} horizontal-align
         */
        horizontalAlign: {
          type: String,
          value: "start"
        },
        /**
         * When `positionTarget` is set, this property defines whether to align the overlay's
         * top or bottom side to the target element by default.
         * Possible values are `top` and `bottom`.
         * The overlay is automatically flipped to the opposite side when it doesn't fit into
         * the default side defined by this property.
         *
         * @attr {top|bottom} vertical-align
         */
        verticalAlign: {
          type: String,
          value: "top"
        },
        /**
         * When `positionTarget` is set, this property defines whether the overlay should overlap
         * the target element in the x-axis, or be positioned right next to it.
         *
         * @attr {boolean} no-horizontal-overlap
         */
        noHorizontalOverlap: {
          type: Boolean,
          value: !1
        },
        /**
         * When `positionTarget` is set, this property defines whether the overlay should overlap
         * the target element in the y-axis, or be positioned right above/below it.
         *
         * @attr {boolean} no-vertical-overlap
         */
        noVerticalOverlap: {
          type: Boolean,
          value: !1
        },
        /**
         * If the overlay content has no intrinsic height, this property can be used to set
         * the minimum vertical space (in pixels) required by the overlay. Setting a value to
         * the property effectively disables the content measurement in favor of using this
         * fixed value for determining the open direction.
         *
         * @attr {number} required-vertical-space
         */
        requiredVerticalSpace: {
          type: Number,
          value: 0
        }
      };
    }
    static get observers() {
      return [
        "__positionSettingsChanged(horizontalAlign, verticalAlign, noHorizontalOverlap, noVerticalOverlap, requiredVerticalSpace)",
        "__overlayOpenedChanged(opened, positionTarget)"
      ];
    }
    constructor() {
      super(), this.__onScroll = this.__onScroll.bind(this), this._updatePosition = this._updatePosition.bind(this);
    }
    /** @protected */
    connectedCallback() {
      super.connectedCallback(), this.opened && this.__addUpdatePositionEventListeners();
    }
    /** @protected */
    disconnectedCallback() {
      super.disconnectedCallback(), this.__removeUpdatePositionEventListeners();
    }
    /** @private */
    __addUpdatePositionEventListeners() {
      window.addEventListener("resize", this._updatePosition), this.__positionTargetAncestorRootNodes = kT(this.positionTarget), this.__positionTargetAncestorRootNodes.forEach((t) => {
        t.addEventListener("scroll", this.__onScroll, !0);
      });
    }
    /** @private */
    __removeUpdatePositionEventListeners() {
      window.removeEventListener("resize", this._updatePosition), this.__positionTargetAncestorRootNodes && (this.__positionTargetAncestorRootNodes.forEach((t) => {
        t.removeEventListener("scroll", this.__onScroll, !0);
      }), this.__positionTargetAncestorRootNodes = null);
    }
    /** @private */
    __overlayOpenedChanged(t, i) {
      if (this.__removeUpdatePositionEventListeners(), i && (i.__overlay = null, _g.unobserve(i), t && (this.__addUpdatePositionEventListeners(), i.__overlay = this, _g.observe(i))), t) {
        const o = getComputedStyle(this);
        this.__margins || (this.__margins = {}, ["top", "bottom", "left", "right"].forEach((a) => {
          this.__margins[a] = parseInt(o[a], 10);
        })), this.setAttribute("dir", o.direction), this._updatePosition(), requestAnimationFrame(() => this._updatePosition());
      }
    }
    get __isRTL() {
      return this.getAttribute("dir") === "rtl";
    }
    __positionSettingsChanged() {
      this._updatePosition();
    }
    /** @private */
    __onScroll(t) {
      this.contains(t.target) || this._updatePosition();
    }
    _updatePosition() {
      if (!this.positionTarget || !this.opened)
        return;
      const t = this.positionTarget.getBoundingClientRect();
      if (t.width === 0 && t.height === 0 && this.opened) {
        this.opened = !1;
        return;
      }
      const i = this.__shouldAlignStartVertically(t);
      this.style.justifyContent = i ? "flex-start" : "flex-end";
      const o = this.__shouldAlignStartHorizontally(t, this.__isRTL), a = !this.__isRTL && o || this.__isRTL && !o;
      this.style.alignItems = a ? "flex-start" : "flex-end";
      const l = this.getBoundingClientRect(), d = this.__calculatePositionInOneDimension(
        t,
        l,
        this.noVerticalOverlap,
        Nc,
        this,
        i
      ), u = this.__calculatePositionInOneDimension(
        t,
        l,
        this.noHorizontalOverlap,
        Lc,
        this,
        o
      );
      Object.assign(this.style, d, u), this.toggleAttribute("bottom-aligned", !i), this.toggleAttribute("top-aligned", i), this.toggleAttribute("end-aligned", !a), this.toggleAttribute("start-aligned", a);
    }
    __shouldAlignStartHorizontally(t, i) {
      const o = Math.max(this.__oldContentWidth || 0, this.$.overlay.offsetWidth);
      this.__oldContentWidth = this.$.overlay.offsetWidth;
      const a = Math.min(window.innerWidth, document.documentElement.clientWidth), l = !i && this.horizontalAlign === "start" || i && this.horizontalAlign === "end";
      return this.__shouldAlignStart(
        t,
        o,
        a,
        this.__margins,
        l,
        this.noHorizontalOverlap,
        Lc
      );
    }
    __shouldAlignStartVertically(t) {
      const i = this.requiredVerticalSpace || Math.max(this.__oldContentHeight || 0, this.$.overlay.offsetHeight);
      this.__oldContentHeight = this.$.overlay.offsetHeight;
      const o = Math.min(window.innerHeight, document.documentElement.clientHeight), a = this.verticalAlign === "top";
      return this.__shouldAlignStart(
        t,
        i,
        o,
        this.__margins,
        a,
        this.noVerticalOverlap,
        Nc
      );
    }
    // eslint-disable-next-line max-params
    __shouldAlignStart(t, i, o, a, l, d, u) {
      const f = o - t[d ? u.end : u.start] - a[u.end], g = t[d ? u.start : u.end] - a[u.start], _ = l ? f : g, x = _ > (l ? g : f) || _ > i;
      return l === x;
    }
    /**
     * Returns an adjusted value after resizing the browser window,
     * to avoid wrong calculations when e.g. previously set `bottom`
     * CSS property value is larger than the updated viewport height.
     * See https://github.com/vaadin/web-components/issues/4604
     */
    __adjustBottomProperty(t, i, o) {
      let a;
      if (t === i.end) {
        if (i.end === Nc.end) {
          const l = Math.min(window.innerHeight, document.documentElement.clientHeight);
          if (o > l && this.__oldViewportHeight) {
            const d = this.__oldViewportHeight - l;
            a = o - d;
          }
          this.__oldViewportHeight = l;
        }
        if (i.end === Lc.end) {
          const l = Math.min(window.innerWidth, document.documentElement.clientWidth);
          if (o > l && this.__oldViewportWidth) {
            const d = this.__oldViewportWidth - l;
            a = o - d;
          }
          this.__oldViewportWidth = l;
        }
      }
      return a;
    }
    /**
     * Returns an object with CSS position properties to set,
     * e.g. { top: "100px" }
     */
    // eslint-disable-next-line max-params
    __calculatePositionInOneDimension(t, i, o, a, l, d) {
      const u = d ? a.start : a.end, f = d ? a.end : a.start, g = parseFloat(l.style[u] || getComputedStyle(l)[u]), _ = this.__adjustBottomProperty(u, a, g), C = i[d ? a.start : a.end] - t[o === d ? a.end : a.start], x = _ ? `${_}px` : `${g + C * (d ? -1 : 1)}px`;
      return {
        [u]: x,
        [f]: ""
      };
    }
  };
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  const AT = me`
  :host([dir='rtl']) [part='input-field'] {
    direction: ltr;
  }

  :host([dir='rtl']) [part='input-field'] ::slotted(input)::placeholder {
    direction: rtl;
    text-align: left;
  }
`, ET = me`
  [part='overlay'] {
    display: flex;
    flex: auto;
  }

  [part~='content'] {
    flex: auto;
  }
`;
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  Te("vaadin-date-picker-overlay", ET, {
    moduleId: "vaadin-date-picker-overlay-styles"
  });
  let Xs;
  class vg extends wT(ST(wr)) {
    static get is() {
      return "vaadin-date-picker-overlay";
    }
    static get template() {
      return Xs || (Xs = super.template.cloneNode(!0), Xs.content.querySelector('[part~="overlay"]').removeAttribute("tabindex")), Xs;
    }
  }
  customElements.define(vg.is, vg);
  /**
  @license
  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */
  class Aa {
    constructor() {
      this._asyncModule = null, this._callback = null, this._timer = null;
    }
    /**
     * Sets the scheduler; that is, a module with the Async interface,
     * a callback and optional arguments to be passed to the run function
     * from the async module.
     *
     * @param {!AsyncInterface} asyncModule Object with Async interface.
     * @param {function()} callback Callback to run.
     * @return {void}
     */
    setConfig(e, t) {
      this._asyncModule = e, this._callback = t, this._timer = this._asyncModule.run(() => {
        this._timer = null, Wn.delete(this), this._callback();
      });
    }
    /**
     * Cancels an active debouncer and returns a reference to itself.
     *
     * @return {void}
     */
    cancel() {
      this.isActive() && (this._cancelAsync(), Wn.delete(this));
    }
    /**
     * Cancels a debouncer's async callback.
     *
     * @return {void}
     */
    _cancelAsync() {
      this.isActive() && (this._asyncModule.cancel(
        /** @type {number} */
        this._timer
      ), this._timer = null);
    }
    /**
     * Flushes an active debouncer and returns a reference to itself.
     *
     * @return {void}
     */
    flush() {
      this.isActive() && (this.cancel(), this._callback());
    }
    /**
     * Returns true if the debouncer is active.
     *
     * @return {boolean} True if active.
     */
    isActive() {
      return this._timer != null;
    }
    /**
     * Creates a debouncer if no debouncer is passed as a parameter
     * or it cancels an active debouncer otherwise. The following
     * example shows how a debouncer can be called multiple times within a
     * microtask and "debounced" such that the provided callback function is
     * called once. Add this method to a custom element:
     *
     * ```js
     * import {microTask} from '@polymer/polymer/lib/utils/async.js';
     * import {Debouncer} from '@polymer/polymer/lib/utils/debounce.js';
     * // ...
     *
     * _debounceWork() {
     *   this._debounceJob = Debouncer.debounce(this._debounceJob,
     *       microTask, () => this._doWork());
     * }
     * ```
     *
     * If the `_debounceWork` method is called multiple times within the same
     * microtask, the `_doWork` function will be called only once at the next
     * microtask checkpoint.
     *
     * Note: In testing it is often convenient to avoid asynchrony. To accomplish
     * this with a debouncer, you can use `enqueueDebouncer` and
     * `flush`. For example, extend the above example by adding
     * `enqueueDebouncer(this._debounceJob)` at the end of the
     * `_debounceWork` method. Then in a test, call `flush` to ensure
     * the debouncer has completed.
     *
     * @param {Debouncer?} debouncer Debouncer object.
     * @param {!AsyncInterface} asyncModule Object with Async interface
     * @param {function()} callback Callback to run.
     * @return {!Debouncer} Returns a debouncer object.
     */
    static debounce(e, t, i) {
      return e instanceof Aa ? e._cancelAsync() : e = new Aa(), e.setConfig(t, i), e;
    }
  }
  let Wn = /* @__PURE__ */ new Set();
  const $T = function(r) {
    Wn.add(r);
  }, TT = function() {
    const r = !!Wn.size;
    return Wn.forEach((e) => {
      try {
        e.flush();
      } catch (t) {
        setTimeout(() => {
          throw t;
        });
      }
    }), r;
  };
  /**
  @license
  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */
  const OT = function() {
    let r, e;
    do
      r = window.ShadyDOM && ShadyDOM.flush(), window.ShadyCSS && window.ShadyCSS.ScopingShim && window.ShadyCSS.ScopingShim.flush(), e = TT();
    while (r || e);
  };
  /**
  @license
  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */
  let yg = !1;
  function DT() {
    if (rb && !tb) {
      if (!yg) {
        yg = !0;
        const r = document.createElement("style");
        r.textContent = "dom-bind,dom-if,dom-repeat{display:none;}", document.head.appendChild(r);
      }
      return !0;
    }
    return !1;
  }
  /**
  @license
  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */
  const PT = u$(Gt);
  class wg extends PT {
    // Not needed to find template; can be removed once the analyzer
    // can find the tag name from customElements.define call
    static get is() {
      return "dom-repeat";
    }
    static get template() {
      return null;
    }
    static get properties() {
      return {
        /**
         * An array containing items determining how many instances of the template
         * to stamp and that that each template instance should bind to.
         */
        items: {
          type: Array
        },
        /**
         * The name of the variable to add to the binding scope for the array
         * element associated with a given template instance.
         */
        as: {
          type: String,
          value: "item"
        },
        /**
         * The name of the variable to add to the binding scope with the index
         * of the instance in the sorted and filtered list of rendered items.
         * Note, for the index in the `this.items` array, use the value of the
         * `itemsIndexAs` property.
         */
        indexAs: {
          type: String,
          value: "index"
        },
        /**
         * The name of the variable to add to the binding scope with the index
         * of the instance in the `this.items` array. Note, for the index of
         * this instance in the sorted and filtered list of rendered items,
         * use the value of the `indexAs` property.
         */
        itemsIndexAs: {
          type: String,
          value: "itemsIndex"
        },
        /**
         * A function that should determine the sort order of the items.  This
         * property should either be provided as a string, indicating a method
         * name on the element's host, or else be an actual function.  The
         * function should match the sort function passed to `Array.sort`.
         * Using a sort function has no effect on the underlying `items` array.
         */
        sort: {
          type: Function,
          observer: "__sortChanged"
        },
        /**
         * A function that can be used to filter items out of the view.  This
         * property should either be provided as a string, indicating a method
         * name on the element's host, or else be an actual function.  The
         * function should match the sort function passed to `Array.filter`.
         * Using a filter function has no effect on the underlying `items` array.
         */
        filter: {
          type: Function,
          observer: "__filterChanged"
        },
        /**
         * When using a `filter` or `sort` function, the `observe` property
         * should be set to a space-separated list of the names of item
         * sub-fields that should trigger a re-sort or re-filter when changed.
         * These should generally be fields of `item` that the sort or filter
         * function depends on.
         */
        observe: {
          type: String,
          observer: "__observeChanged"
        },
        /**
         * When using a `filter` or `sort` function, the `delay` property
         * determines a debounce time in ms after a change to observed item
         * properties that must pass before the filter or sort is re-run.
         * This is useful in rate-limiting shuffling of the view when
         * item changes may be frequent.
         */
        delay: Number,
        /**
         * Count of currently rendered items after `filter` (if any) has been applied.
         * If "chunking mode" is enabled, `renderedItemCount` is updated each time a
         * set of template instances is rendered.
         *
         */
        renderedItemCount: {
          type: Number,
          notify: !Bp,
          readOnly: !0
        },
        /**
         * When greater than zero, defines an initial count of template instances
         * to render after setting the `items` array, before the next paint, and
         * puts the `dom-repeat` into "chunking mode".  The remaining items (and
         * any future items as a result of pushing onto the array) will be created
         * and rendered incrementally at each animation frame thereof until all
         * instances have been rendered.
         */
        initialCount: {
          type: Number
        },
        /**
         * When `initialCount` is used, this property defines a frame rate (in
         * fps) to target by throttling the number of instances rendered each
         * frame to not exceed the budget for the target frame rate.  The
         * framerate is effectively the number of `requestAnimationFrame`s that
         * it tries to allow to actually fire in a given second. It does this
         * by measuring the time between `rAF`s and continuously adjusting the
         * number of items created each `rAF` to maintain the target framerate.
         * Setting this to a higher number allows lower latency and higher
         * throughput for event handlers and other tasks, but results in a
         * longer time for the remaining items to complete rendering.
         */
        targetFramerate: {
          type: Number,
          value: 20
        },
        _targetFrameTime: {
          type: Number,
          computed: "__computeFrameTime(targetFramerate)"
        },
        /**
         * When the global `suppressTemplateNotifications` setting is used, setting
         * `notifyDomChange: true` will enable firing `dom-change` events on this
         * element.
         */
        notifyDomChange: {
          type: Boolean
        },
        /**
         * When chunking is enabled via `initialCount` and the `items` array is
         * set to a new array, this flag controls whether the previously rendered
         * instances are reused or not.
         *
         * When `true`, any previously rendered template instances are updated in
         * place to their new item values synchronously in one shot, and then any
         * further items (if any) are chunked out.  When `false`, the list is
         * returned back to its `initialCount` (any instances over the initial
         * count are discarded) and the remainder of the list is chunked back in.
         * Set this to `true` to avoid re-creating the list and losing scroll
         * position, although note that when changing the list to completely
         * different data the render thread will be blocked until all existing
         * instances are updated to their new data.
         */
        reuseChunkedInstances: {
          type: Boolean
        }
      };
    }
    static get observers() {
      return ["__itemsChanged(items.*)"];
    }
    constructor() {
      super(), this.__instances = [], this.__renderDebouncer = null, this.__itemsIdxToInstIdx = {}, this.__chunkCount = null, this.__renderStartTime = null, this.__itemsArrayChanged = !1, this.__shouldMeasureChunk = !1, this.__shouldContinueChunking = !1, this.__chunkingId = 0, this.__sortFn = null, this.__filterFn = null, this.__observePaths = null, this.__ctor = null, this.__isDetached = !0, this.template = null, this._templateInfo;
    }
    /**
     * @override
     * @return {void}
     */
    disconnectedCallback() {
      super.disconnectedCallback(), this.__isDetached = !0;
      for (let e = 0; e < this.__instances.length; e++)
        this.__detachInstance(e);
      this.__chunkingId && cancelAnimationFrame(this.__chunkingId);
    }
    /**
     * @override
     * @return {void}
     */
    connectedCallback() {
      if (super.connectedCallback(), DT() || (this.style.display = "none"), this.__isDetached) {
        this.__isDetached = !1;
        let e = ye(ye(this).parentNode);
        for (let t = 0; t < this.__instances.length; t++)
          this.__attachInstance(t, e);
        this.__chunkingId && this.__render();
      }
    }
    __ensureTemplatized() {
      if (!this.__ctor) {
        const e = (
          /** @type {!HTMLTemplateElement} */
          /** @type {!HTMLElement} */
          this
        );
        let t = this.template = e._templateInfo ? e : (
          /** @type {!HTMLTemplateElement} */
          this.querySelector("template")
        );
        if (!t) {
          let o = new MutationObserver(() => {
            if (this.querySelector("template"))
              o.disconnect(), this.__render();
            else
              throw new Error("dom-repeat requires a <template> child");
          });
          return o.observe(this, { childList: !0 }), !1;
        }
        let i = {};
        i[this.as] = !0, i[this.indexAs] = !0, i[this.itemsIndexAs] = !0, this.__ctor = Hn(t, this, {
          mutableData: this.mutableData,
          parentModel: !0,
          instanceProps: i,
          /**
           * @this {DomRepeat}
           * @param {string} prop Property to set
           * @param {*} value Value to set property to
           */
          forwardHostProp: function(o, a) {
            let l = this.__instances;
            for (let d = 0, u; d < l.length && (u = l[d]); d++)
              u.forwardHostProp(o, a);
          },
          /**
           * @this {DomRepeat}
           * @param {Object} inst Instance to notify
           * @param {string} prop Property to notify
           * @param {*} value Value to notify
           */
          notifyInstanceProp: function(o, a, l) {
            if (GA(this.as, a)) {
              let d = o[this.itemsIndexAs];
              a == this.as && (this.items[d] = l);
              let u = Rn(this.as, `${JSCompiler_renameProperty("items", this)}.${d}`, a);
              this.notifyPath(u, l);
            }
          }
        });
      }
      return !0;
    }
    __getMethodHost() {
      return this.__dataHost._methodHost || this.__dataHost;
    }
    __functionFromPropertyValue(e) {
      if (typeof e == "string") {
        let t = e, i = this.__getMethodHost();
        return function() {
          return i[t].apply(i, arguments);
        };
      }
      return e;
    }
    __sortChanged(e) {
      this.__sortFn = this.__functionFromPropertyValue(e), this.items && this.__debounceRender(this.__render);
    }
    __filterChanged(e) {
      this.__filterFn = this.__functionFromPropertyValue(e), this.items && this.__debounceRender(this.__render);
    }
    __computeFrameTime(e) {
      return Math.ceil(1e3 / e);
    }
    __observeChanged() {
      this.__observePaths = this.observe && this.observe.replace(".*", ".").split(" ");
    }
    __handleObservedPaths(e) {
      if (this.__sortFn || this.__filterFn) {
        if (!e)
          this.__debounceRender(this.__render, this.delay);
        else if (this.__observePaths) {
          let t = this.__observePaths;
          for (let i = 0; i < t.length; i++)
            e.indexOf(t[i]) === 0 && this.__debounceRender(this.__render, this.delay);
        }
      }
    }
    __itemsChanged(e) {
      this.items && Array.isArray(this.items), this.__handleItemPath(e.path, e.value) || (e.path === "items" && (this.__itemsArrayChanged = !0), this.__debounceRender(this.__render));
    }
    /**
     * @param {function(this:DomRepeat)} fn Function to debounce.
     * @param {number=} delay Delay in ms to debounce by.
     */
    __debounceRender(e, t = 0) {
      this.__renderDebouncer = Aa.debounce(
        this.__renderDebouncer,
        t > 0 ? QA.after(t) : nu,
        e.bind(this)
      ), $T(this.__renderDebouncer);
    }
    /**
     * Forces the element to render its content. Normally rendering is
     * asynchronous to a provoking change. This is done for efficiency so
     * that multiple changes trigger only a single render. The render method
     * should be called if, for example, template rendering is required to
     * validate application state.
     * @return {void}
     */
    render() {
      this.__debounceRender(this.__render), OT();
    }
    __render() {
      if (!this.__ensureTemplatized())
        return;
      let e = this.items || [];
      const t = this.__sortAndFilterItems(e), i = this.__calculateLimit(t.length);
      this.__updateInstances(e, i, t), this.initialCount && (this.__shouldMeasureChunk || this.__shouldContinueChunking) && (cancelAnimationFrame(this.__chunkingId), this.__chunkingId = requestAnimationFrame(() => {
        this.__chunkingId = null, this.__continueChunking();
      })), this._setRenderedItemCount(this.__instances.length), (!Bp || this.notifyDomChange) && this.dispatchEvent(new CustomEvent("dom-change", {
        bubbles: !0,
        composed: !0
      }));
    }
    __sortAndFilterItems(e) {
      let t = new Array(e.length);
      for (let i = 0; i < e.length; i++)
        t[i] = i;
      return this.__filterFn && (t = t.filter((i, o, a) => this.__filterFn(e[i], o, a))), this.__sortFn && t.sort((i, o) => this.__sortFn(e[i], e[o])), t;
    }
    __calculateLimit(e) {
      let t = e;
      const i = this.__instances.length;
      if (this.initialCount) {
        let o;
        !this.__chunkCount || this.__itemsArrayChanged && !this.reuseChunkedInstances ? (t = Math.min(e, this.initialCount), o = Math.max(t - i, 0), this.__chunkCount = o || 1) : (o = Math.min(
          Math.max(e - i, 0),
          this.__chunkCount
        ), t = Math.min(i + o, e)), this.__shouldMeasureChunk = o === this.__chunkCount, this.__shouldContinueChunking = t < e, this.__renderStartTime = performance.now();
      }
      return this.__itemsArrayChanged = !1, t;
    }
    __continueChunking() {
      if (this.__shouldMeasureChunk) {
        const e = performance.now() - this.__renderStartTime, t = this._targetFrameTime / e;
        this.__chunkCount = Math.round(this.__chunkCount * t) || 1;
      }
      this.__shouldContinueChunking && this.__debounceRender(this.__render);
    }
    __updateInstances(e, t, i) {
      const o = this.__itemsIdxToInstIdx = {};
      let a;
      for (a = 0; a < t; a++) {
        let l = this.__instances[a], d = i[a], u = e[d];
        o[d] = a, l ? (l._setPendingProperty(this.as, u), l._setPendingProperty(this.indexAs, a), l._setPendingProperty(this.itemsIndexAs, d), l._flushProperties()) : this.__insertInstance(u, a, d);
      }
      for (let l = this.__instances.length - 1; l >= a; l--)
        this.__detachAndRemoveInstance(l);
    }
    __detachInstance(e) {
      let t = this.__instances[e];
      const i = ye(t.root);
      for (let o = 0; o < t.children.length; o++) {
        let a = t.children[o];
        i.appendChild(a);
      }
      return t;
    }
    __attachInstance(e, t) {
      let i = this.__instances[e];
      t.insertBefore(i.root, this);
    }
    __detachAndRemoveInstance(e) {
      this.__detachInstance(e), this.__instances.splice(e, 1);
    }
    __stampInstance(e, t, i) {
      let o = {};
      return o[this.as] = e, o[this.indexAs] = t, o[this.itemsIndexAs] = i, new this.__ctor(o);
    }
    __insertInstance(e, t, i) {
      const o = this.__stampInstance(e, t, i);
      let a = this.__instances[t + 1], l = a ? a.children[0] : this;
      return ye(ye(this).parentNode).insertBefore(o.root, l), this.__instances[t] = o, o;
    }
    // Implements extension point from Templatize mixin
    /**
     * Shows or hides the template instance top level child elements. For
     * text nodes, `textContent` is removed while "hidden" and replaced when
     * "shown."
     * @param {boolean} hidden Set to true to hide the children;
     * set to false to show them.
     * @return {void}
     * @protected
     */
    _showHideChildren(e) {
      for (let t = 0; t < this.__instances.length; t++)
        this.__instances[t]._showHideChildren(e);
    }
    // Called as a side effect of a host items.<key>.<path> path change,
    // responsible for notifying item.<path> changes to inst for key
    __handleItemPath(e, t) {
      let i = e.slice(6), o = i.indexOf("."), a = o < 0 ? i : i.substring(0, o);
      if (a == parseInt(a, 10)) {
        let l = o < 0 ? "" : i.substring(o + 1);
        this.__handleObservedPaths(l);
        let d = this.__itemsIdxToInstIdx[a], u = this.__instances[d];
        if (u) {
          let f = this.as + (l ? "." + l : "");
          u._setPendingPropertyOrPath(f, t, !1, !0), u._flushProperties();
        }
        return !0;
      }
    }
    /**
     * Returns the item associated with a given element stamped by
     * this `dom-repeat`.
     *
     * Note, to modify sub-properties of the item,
     * `modelForElement(el).set('item.<sub-prop>', value)`
     * should be used.
     *
     * @param {!HTMLElement} el Element for which to return the item.
     * @return {*} Item associated with the element.
     */
    itemForElement(e) {
      let t = this.modelForElement(e);
      return t && t[this.as];
    }
    /**
     * Returns the inst index for a given element stamped by this `dom-repeat`.
     * If `sort` is provided, the index will reflect the sorted order (rather
     * than the original array order).
     *
     * @param {!HTMLElement} el Element for which to return the index.
     * @return {?number} Row index associated with the element (note this may
     *   not correspond to the array index if a user `sort` is applied).
     */
    indexForElement(e) {
      let t = this.modelForElement(e);
      return t && t[this.indexAs];
    }
    /**
     * Returns the template "model" associated with a given element, which
     * serves as the binding scope for the template instance the element is
     * contained in. A template model
     * should be used to manipulate data associated with this template instance.
     *
     * Example:
     *
     *   let model = modelForElement(el);
     *   if (model.index < 10) {
     *     model.set('item.checked', true);
     *   }
     *
     * @param {!HTMLElement} el Element for which to return a template model.
     * @return {TemplateInstanceBase} Model representing the binding scope for
     *   the element.
     */
    modelForElement(e) {
      return C$(this.template, e);
    }
  }
  customElements.define(wg.is, wg);
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  function IT(r) {
    let e = r.getDay();
    e === 0 && (e = 7);
    const t = 4 - e, i = new Date(r.getTime() + t * 24 * 3600 * 1e3), o = new Date(0, 0);
    o.setFullYear(i.getFullYear());
    const a = i.getTime() - o.getTime(), l = Math.round(a / (24 * 3600 * 1e3));
    return Math.floor(l / 7 + 1);
  }
  function kr(r, e) {
    return r instanceof Date && e instanceof Date && r.getFullYear() === e.getFullYear() && r.getMonth() === e.getMonth() && r.getDate() === e.getDate();
  }
  function En(r, e, t) {
    return (!e || r >= e) && (!t || r <= t);
  }
  function r_(r, e) {
    return e.filter((t) => t !== void 0).reduce((t, i) => {
      if (!i)
        return t;
      if (!t)
        return i;
      const o = Math.abs(r.getTime() - i.getTime()), a = Math.abs(t.getTime() - r.getTime());
      return o < a ? i : t;
    });
  }
  function i_(r) {
    return {
      day: r.getDate(),
      month: r.getMonth(),
      year: r.getFullYear()
    };
  }
  function MT(r, e, t = 0, i = 1) {
    if (e > 99)
      throw new Error("The provided year cannot have more than 2 digits.");
    if (e < 0)
      throw new Error("The provided year cannot be negative.");
    let o = e + Math.floor(r.getFullYear() / 100) * 100;
    return r < new Date(o - 50, t, i) ? o -= 100 : r > new Date(o + 50, t, i) && (o += 100), o;
  }
  function gn(r) {
    const e = /^([-+]\d{1}|\d{2,4}|[-+]\d{6})-(\d{1,2})-(\d{1,2})$/.exec(r);
    if (!e)
      return;
    const t = new Date(0, 0);
    return t.setFullYear(parseInt(e[1], 10)), t.setMonth(parseInt(e[2], 10) - 1), t.setDate(parseInt(e[3], 10)), t;
  }
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  class kg extends Ua(Kr(Gt)) {
    static get template() {
      return Ar`
      <style>
        :host {
          display: block;
        }

        #monthGrid {
          width: 100%;
          border-collapse: collapse;
        }

        #days-container tr,
        #weekdays-container tr {
          display: flex;
        }

        [part='date'] {
          outline: none;
        }

        [part='week-number'][hidden],
        [part='weekday'][hidden] {
          display: none;
        }

        [part='weekday'],
        [part='date'] {
          width: calc(100% / 7);
          padding: 0;
          font-weight: normal;
        }

        [part='weekday']:empty,
        [part='week-number'] {
          width: 12.5%;
          flex-shrink: 0;
          padding: 0;
        }

        :host([week-numbers]) [part='weekday']:not(:empty),
        :host([week-numbers]) [part='date'] {
          width: 12.5%;
        }
      </style>

      <div part="month-header" id="month-header" aria-hidden="true">[[_getTitle(month, i18n.monthNames)]]</div>
      <table
        id="monthGrid"
        role="grid"
        aria-labelledby="month-header"
        on-touchend="_preventDefault"
        on-touchstart="_onMonthGridTouchStart"
      >
        <thead id="weekdays-container">
          <tr role="row" part="weekdays">
            <th
              part="weekday"
              aria-hidden="true"
              hidden$="[[!_showWeekSeparator(showWeekNumbers, i18n.firstDayOfWeek)]]"
            ></th>
            <template
              is="dom-repeat"
              items="[[_getWeekDayNames(i18n.weekdays, i18n.weekdaysShort, showWeekNumbers, i18n.firstDayOfWeek)]]"
            >
              <th role="columnheader" part="weekday" scope="col" abbr$="[[item.weekDay]]" aria-hidden="true">
                [[item.weekDayShort]]
              </th>
            </template>
          </tr>
        </thead>
        <tbody id="days-container">
          <template is="dom-repeat" items="[[_weeks]]" as="week">
            <tr role="row">
              <td
                part="week-number"
                aria-hidden="true"
                hidden$="[[!_showWeekSeparator(showWeekNumbers, i18n.firstDayOfWeek)]]"
              >
                [[__getWeekNumber(week)]]
              </td>
              <template is="dom-repeat" items="[[week]]">
                <td
                  role="gridcell"
                  part="date"
                  date="[[item]]"
                  today$="[[_isToday(item)]]"
                  focused$="[[__isDayFocused(item, focusedDate)]]"
                  tabindex$="[[__getDayTabindex(item, focusedDate)]]"
                  selected$="[[__isDaySelected(item, selectedDate)]]"
                  disabled$="[[__isDayDisabled(item, minDate, maxDate)]]"
                  aria-selected$="[[__getDayAriaSelected(item, selectedDate)]]"
                  aria-disabled$="[[__getDayAriaDisabled(item, minDate, maxDate)]]"
                  aria-label$="[[__getDayAriaLabel(item)]]"
                  >[[_getDate(item)]]</td
                >
              </template>
            </tr>
          </template>
        </tbody>
      </table>
    `;
    }
    static get is() {
      return "vaadin-month-calendar";
    }
    static get properties() {
      return {
        /**
         * A `Date` object defining the month to be displayed. Only year and
         * month properties are actually used.
         */
        month: {
          type: Date,
          value: /* @__PURE__ */ new Date()
        },
        /**
         * A `Date` object for the currently selected date.
         */
        selectedDate: {
          type: Date,
          notify: !0
        },
        /**
         * A `Date` object for the currently focused date.
         */
        focusedDate: Date,
        showWeekNumbers: {
          type: Boolean,
          value: !1
        },
        i18n: {
          type: Object
        },
        /**
         * Flag stating whether taps on the component should be ignored.
         */
        ignoreTaps: Boolean,
        _notTapping: Boolean,
        /**
         * The earliest date that can be selected. All earlier dates will be disabled.
         */
        minDate: {
          type: Date,
          value: null
        },
        /**
         * The latest date that can be selected. All later dates will be disabled.
         */
        maxDate: {
          type: Date,
          value: null
        },
        _days: {
          type: Array,
          computed: "_getDays(month, i18n.firstDayOfWeek, minDate, maxDate)"
        },
        _weeks: {
          type: Array,
          computed: "_getWeeks(_days)"
        },
        disabled: {
          type: Boolean,
          reflectToAttribute: !0,
          computed: "_isDisabled(month, minDate, maxDate)"
        }
      };
    }
    static get observers() {
      return [
        "_showWeekNumbersChanged(showWeekNumbers, i18n.firstDayOfWeek)",
        "__focusedDateChanged(focusedDate, _days)"
      ];
    }
    /** @protected */
    ready() {
      super.ready(), er(this.$.monthGrid, "tap", this._handleTap.bind(this));
    }
    get focusableDateElement() {
      return [...this.shadowRoot.querySelectorAll("[part=date]")].find((e) => kr(e.date, this.focusedDate));
    }
    /* Returns true if all the dates in the month are out of the allowed range */
    _isDisabled(e, t, i) {
      const o = new Date(0, 0);
      o.setFullYear(e.getFullYear()), o.setMonth(e.getMonth()), o.setDate(1);
      const a = new Date(0, 0);
      return a.setFullYear(e.getFullYear()), a.setMonth(e.getMonth() + 1), a.setDate(0), t && i && t.getMonth() === i.getMonth() && t.getMonth() === e.getMonth() && i.getDate() - t.getDate() >= 0 ? !1 : !En(o, t, i) && !En(a, t, i);
    }
    _getTitle(e, t) {
      if (!(e === void 0 || t === void 0))
        return this.i18n.formatTitle(t[e.getMonth()], e.getFullYear());
    }
    _onMonthGridTouchStart() {
      this._notTapping = !1, setTimeout(() => {
        this._notTapping = !0;
      }, 300);
    }
    _dateAdd(e, t) {
      e.setDate(e.getDate() + t);
    }
    _applyFirstDayOfWeek(e, t) {
      if (!(e === void 0 || t === void 0))
        return e.slice(t).concat(e.slice(0, t));
    }
    _getWeekDayNames(e, t, i, o) {
      if (!(e === void 0 || t === void 0 || i === void 0 || o === void 0))
        return e = this._applyFirstDayOfWeek(e, o), t = this._applyFirstDayOfWeek(t, o), e = e.map((a, l) => ({
          weekDay: a,
          weekDayShort: t[l]
        })), e;
    }
    __focusedDateChanged(e, t) {
      t.some((i) => kr(i, e)) ? this.removeAttribute("aria-hidden") : this.setAttribute("aria-hidden", "true");
    }
    _getDate(e) {
      return e ? e.getDate() : "";
    }
    _showWeekNumbersChanged(e, t) {
      e && t === 1 ? this.setAttribute("week-numbers", "") : this.removeAttribute("week-numbers");
    }
    _showWeekSeparator(e, t) {
      return e && t === 1;
    }
    _isToday(e) {
      return kr(/* @__PURE__ */ new Date(), e);
    }
    _getDays(e, t) {
      if (e === void 0 || t === void 0)
        return;
      const i = new Date(0, 0);
      for (i.setFullYear(e.getFullYear()), i.setMonth(e.getMonth()), i.setDate(1); i.getDay() !== t; )
        this._dateAdd(i, -1);
      const o = [], a = i.getMonth(), l = e.getMonth();
      for (; i.getMonth() === l || i.getMonth() === a; )
        o.push(i.getMonth() === l ? new Date(i.getTime()) : null), this._dateAdd(i, 1);
      return o;
    }
    _getWeeks(e) {
      return e.reduce((t, i, o) => (o % 7 === 0 && t.push([]), t[t.length - 1].push(i), t), []);
    }
    _handleTap(e) {
      !this.ignoreTaps && !this._notTapping && e.target.date && !e.target.hasAttribute("disabled") && (this.selectedDate = e.target.date, this.dispatchEvent(
        new CustomEvent("date-tap", { detail: { date: e.target.date }, bubbles: !0, composed: !0 })
      ));
    }
    _preventDefault(e) {
      e.preventDefault();
    }
    __getWeekNumber(e) {
      const t = e.reduce((i, o) => !i && o ? o : i);
      return IT(t);
    }
    __isDayFocused(e, t) {
      return kr(e, t);
    }
    __isDaySelected(e, t) {
      return kr(e, t);
    }
    __getDayAriaSelected(e, t) {
      if (this.__isDaySelected(e, t))
        return "true";
    }
    __isDayDisabled(e, t, i) {
      return !En(e, t, i);
    }
    __getDayAriaDisabled(e, t, i) {
      if (!(e === void 0 || t === void 0 || i === void 0) && this.__isDayDisabled(e, t, i))
        return "true";
    }
    __getDayAriaLabel(e) {
      if (!e)
        return "";
      let t = `${this._getDate(e)} ${this.i18n.monthNames[e.getMonth()]} ${e.getFullYear()}, ${this.i18n.weekdays[e.getDay()]}`;
      return this._isToday(e) && (t += `, ${this.i18n.today}`), t;
    }
    __getDayTabindex(e, t) {
      return this.__isDayFocused(e, t) ? "0" : "-1";
    }
  }
  customElements.define(kg.is, kg);
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  class Bn extends Gt {
    static get template() {
      return Ar`
      <style>
        :host {
          display: block;
          overflow: hidden;
          height: 500px;
        }

        #scroller {
          position: relative;
          height: 100%;
          overflow: auto;
          outline: none;
          margin-right: -40px;
          -webkit-overflow-scrolling: touch;
          overflow-x: hidden;
        }

        #scroller.notouchscroll {
          -webkit-overflow-scrolling: auto;
        }

        #scroller::-webkit-scrollbar {
          display: none;
        }

        .buffer {
          position: absolute;
          width: var(--vaadin-infinite-scroller-buffer-width, 100%);
          box-sizing: border-box;
          padding-right: 40px;
          top: var(--vaadin-infinite-scroller-buffer-offset, 0);
          animation: fadein 0.2s;
        }

        @keyframes fadein {
          from {
            opacity: 0;
          }
          to {
            opacity: 1;
          }
        }
      </style>

      <div id="scroller" on-scroll="_scroll">
        <div class="buffer"></div>
        <div class="buffer"></div>
        <div id="fullHeight"></div>
      </div>
    `;
    }
    static get is() {
      return "vaadin-infinite-scroller";
    }
    static get properties() {
      return {
        /**
         * Count of individual items in each buffer.
         * The scroller has 2 buffers altogether so bufferSize of 20
         * will result in 40 buffered DOM items in total.
         * Changing after initialization not supported.
         */
        bufferSize: {
          type: Number,
          value: 20
        },
        /**
         * The amount of initial scroll top. Needed in order for the
         * user to be able to scroll backwards.
         * @private
         */
        _initialScroll: {
          value: 5e5
        },
        /**
         * The index/position mapped at _initialScroll point.
         * @private
         */
        _initialIndex: {
          value: 0
        },
        /** @private */
        _buffers: Array,
        /** @private */
        _preventScrollEvent: Boolean,
        /** @private */
        _mayHaveMomentum: Boolean,
        /** @private */
        _initialized: Boolean,
        active: {
          type: Boolean,
          observer: "_activated"
        }
      };
    }
    /** @protected */
    ready() {
      super.ready(), this._buffers = [...this.shadowRoot.querySelectorAll(".buffer")], this.$.fullHeight.style.height = `${this._initialScroll * 2}px`;
      const e = this.querySelector("template");
      this._TemplateClass = Hn(e, this, {
        forwardHostProp(t, i) {
          t !== "index" && this._buffers.forEach((o) => {
            [...o.children].forEach((a) => {
              a._itemWrapper.instance[t] = i;
            });
          });
        }
      }), A$ && (this.$.scroller.tabIndex = -1);
    }
    /**
     * Force the scroller to update clones after a reset, without
     * waiting for the debouncer to resolve.
     */
    forceUpdate() {
      this._debouncerUpdateClones && (this._buffers[0].updated = this._buffers[1].updated = !1, this._updateClones(), this._debouncerUpdateClones.cancel());
    }
    /** @private */
    _activated(e) {
      e && !this._initialized && (this._createPool(), this._initialized = !0);
    }
    /** @private */
    _finishInit() {
      this._initDone || (this._buffers.forEach((e) => {
        [...e.children].forEach((t) => {
          this._ensureStampedInstance(t._itemWrapper);
        });
      }), this._buffers[0].translateY || this._reset(), this._initDone = !0);
    }
    /** @private */
    _translateBuffer(e) {
      const t = e ? 1 : 0;
      this._buffers[t].translateY = this._buffers[t ? 0 : 1].translateY + this._bufferHeight * (t ? -1 : 1), this._buffers[t].style.transform = `translate3d(0, ${this._buffers[t].translateY}px, 0)`, this._buffers[t].updated = !1, this._buffers.reverse();
    }
    /** @private */
    _scroll() {
      if (this._scrollDisabled)
        return;
      const e = this.$.scroller.scrollTop;
      (e < this._bufferHeight || e > this._initialScroll * 2 - this._bufferHeight) && (this._initialIndex = ~~this.position, this._reset());
      const t = this.itemHeight + this.bufferOffset, i = e > this._buffers[1].translateY + t, o = e < this._buffers[0].translateY + t;
      (i || o) && (this._translateBuffer(o), this._updateClones()), this._preventScrollEvent || (this.dispatchEvent(new CustomEvent("custom-scroll", { bubbles: !1, composed: !0 })), this._mayHaveMomentum = !0), this._preventScrollEvent = !1, this._debouncerScrollFinish = Do.debounce(this._debouncerScrollFinish, Un.after(200), () => {
        const a = this.$.scroller.getBoundingClientRect();
        !this._isVisible(this._buffers[0], a) && !this._isVisible(this._buffers[1], a) && (this.position = this.position);
      });
    }
    /**
     * @return {number}
     */
    get bufferOffset() {
      return this._buffers[0].offsetTop;
    }
    /**
     * @return {number}
     */
    get position() {
      return (this.$.scroller.scrollTop - this._buffers[0].translateY) / this.itemHeight + this._firstIndex;
    }
    /**
     * Current scroller position as index. Can be a fractional number.
     *
     * @type {number}
     */
    set position(e) {
      this._preventScrollEvent = !0, e > this._firstIndex && e < this._firstIndex + this.bufferSize * 2 ? this.$.scroller.scrollTop = this.itemHeight * (e - this._firstIndex) + this._buffers[0].translateY : (this._initialIndex = ~~e, this._reset(), this._scrollDisabled = !0, this.$.scroller.scrollTop += e % 1 * this.itemHeight, this._scrollDisabled = !1), this._mayHaveMomentum && (this.$.scroller.classList.add("notouchscroll"), this._mayHaveMomentum = !1, setTimeout(() => {
        this.$.scroller.classList.remove("notouchscroll");
      }, 10));
    }
    /**
     * @return {number}
     */
    get itemHeight() {
      if (!this._itemHeightVal) {
        const e = getComputedStyle(this).getPropertyValue("--vaadin-infinite-scroller-item-height"), t = "background-position";
        this.$.fullHeight.style.setProperty(t, e);
        const i = getComputedStyle(this.$.fullHeight).getPropertyValue(t);
        this.$.fullHeight.style.removeProperty(t), this._itemHeightVal = parseFloat(i);
      }
      return this._itemHeightVal;
    }
    /** @private */
    get _bufferHeight() {
      return this.itemHeight * this.bufferSize;
    }
    /** @private */
    _reset() {
      this._scrollDisabled = !0, this.$.scroller.scrollTop = this._initialScroll, this._buffers[0].translateY = this._initialScroll - this._bufferHeight, this._buffers[1].translateY = this._initialScroll, this._buffers.forEach((e) => {
        e.style.transform = `translate3d(0, ${e.translateY}px, 0)`;
      }), this._buffers[0].updated = this._buffers[1].updated = !1, this._updateClones(!0), this._debouncerUpdateClones = Do.debounce(this._debouncerUpdateClones, Un.after(200), () => {
        this._buffers[0].updated = this._buffers[1].updated = !1, this._updateClones();
      }), this._scrollDisabled = !1;
    }
    /** @private */
    _createPool() {
      const e = this.getBoundingClientRect();
      this._buffers.forEach((t) => {
        for (let i = 0; i < this.bufferSize; i++) {
          const o = document.createElement("div");
          o.style.height = `${this.itemHeight}px`, o.instance = {};
          const l = `vaadin-infinite-scroller-item-content-${Bn._contentIndex = Bn._contentIndex + 1 || 0}`, d = document.createElement("slot");
          d.setAttribute("name", l), d._itemWrapper = o, t.appendChild(d), o.setAttribute("slot", l), this.appendChild(o), setTimeout(() => {
            this._isVisible(o, e) && this._ensureStampedInstance(o);
          }, 1);
        }
      }), setTimeout(() => {
        Db(this, this._finishInit.bind(this));
      }, 1);
    }
    /** @private */
    _ensureStampedInstance(e) {
      if (e.firstElementChild)
        return;
      const t = e.instance;
      e.instance = new this._TemplateClass({}), e.appendChild(e.instance.root), Object.keys(t).forEach((i) => {
        e.instance.set(i, t[i]);
      });
    }
    /** @private */
    _updateClones(e) {
      const t = (this._buffers[0].translateY - this._initialScroll) / this.itemHeight;
      if (isNaN(t))
        return;
      this._firstIndex = Math.round(t) + this._initialIndex;
      const i = e ? this.$.scroller.getBoundingClientRect() : void 0;
      this._buffers.forEach((o, a) => {
        if (!o.updated) {
          const l = this._firstIndex + this.bufferSize * a;
          [...o.children].forEach((d, u) => {
            const f = d._itemWrapper;
            (!e || this._isVisible(f, i)) && (f.instance.index = l + u);
          }), o.updated = !0;
        }
      });
    }
    /** @private */
    _isVisible(e, t) {
      const i = e.getBoundingClientRect();
      return i.bottom > t.top && i.top < t.bottom;
    }
  }
  customElements.define(Bn.is, Bn);
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  class o_ {
    constructor(e, t) {
      this.query = e, this.callback = t, this._boundQueryHandler = this._queryHandler.bind(this);
    }
    hostConnected() {
      this._removeListener(), this._mediaQuery = window.matchMedia(this.query), this._addListener(), this._queryHandler(this._mediaQuery);
    }
    hostDisconnected() {
      this._removeListener();
    }
    /** @private */
    _addListener() {
      this._mediaQuery && this._mediaQuery.addListener(this._boundQueryHandler);
    }
    /** @private */
    _removeListener() {
      this._mediaQuery && this._mediaQuery.removeListener(this._boundQueryHandler), this._mediaQuery = null;
    }
    /** @private */
    _queryHandler(e) {
      typeof this.callback == "function" && this.callback(e.matches);
    }
  }
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  class xg extends Oi(Kr(Kn(Gt))) {
    static get template() {
      return Ar`
      <style>
        :host {
          display: flex;
          flex-direction: column;
          height: 100%;
          width: 100%;
          outline: none;
        }

        [part='overlay-header'] {
          display: flex;
          flex-shrink: 0;
          flex-wrap: nowrap;
          align-items: center;
        }

        :host(:not([fullscreen])) [part='overlay-header'] {
          display: none;
        }

        [part='label'] {
          flex-grow: 1;
        }

        [hidden] {
          display: none !important;
        }

        [part='years-toggle-button'] {
          display: flex;
        }

        #scrollers {
          display: flex;
          height: 100%;
          width: 100%;
          position: relative;
          overflow: hidden;
        }

        [part='months'],
        [part='years'] {
          height: 100%;
        }

        [part='months'] {
          --vaadin-infinite-scroller-item-height: 270px;
          position: absolute;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
        }

        #scrollers[desktop] [part='months'] {
          right: 50px;
          transform: none !important;
        }

        [part='years'] {
          --vaadin-infinite-scroller-item-height: 80px;
          width: 50px;
          position: absolute;
          right: 0;
          transform: translateX(100%);
          -webkit-tap-highlight-color: transparent;
          -webkit-user-select: none;
          -moz-user-select: none;
          user-select: none;
          /* Center the year scroller position. */
          --vaadin-infinite-scroller-buffer-offset: 50%;
        }

        #scrollers[desktop] [part='years'] {
          position: absolute;
          transform: none !important;
        }

        [part='years']::before {
          content: '';
          display: block;
          background: transparent;
          width: 0;
          height: 0;
          position: absolute;
          left: 0;
          top: 50%;
          transform: translateY(-50%);
          border-width: 6px;
          border-style: solid;
          border-color: transparent;
          border-left-color: #000;
        }

        :host(.animate) [part='months'],
        :host(.animate) [part='years'] {
          transition: all 200ms;
        }

        [part='toolbar'] {
          display: flex;
          justify-content: space-between;
          z-index: 2;
          flex-shrink: 0;
        }
      </style>

      <div part="overlay-header" on-touchend="_preventDefault" desktop$="[[_desktopMode]]" aria-hidden="true">
        <div part="label">[[_formatDisplayed(selectedDate, i18n.formatDate, label)]]</div>
        <div part="clear-button" hidden$="[[!selectedDate]]"></div>
        <div part="toggle-button"></div>

        <div part="years-toggle-button" hidden$="[[_desktopMode]]" aria-hidden="true">
          [[_yearAfterXMonths(_visibleMonthIndex)]]
        </div>
      </div>

      <div id="scrollers" desktop$="[[_desktopMode]]">
        <vaadin-infinite-scroller
          id="monthScroller"
          on-custom-scroll="_onMonthScroll"
          on-touchstart="_onMonthScrollTouchStart"
          buffer-size="3"
          active="[[initialPosition]]"
          part="months"
        >
          <template>
            <vaadin-month-calendar
              i18n="[[i18n]]"
              month="[[_dateAfterXMonths(index)]]"
              selected-date="{{selectedDate}}"
              focused-date="[[focusedDate]]"
              ignore-taps="[[_ignoreTaps]]"
              show-week-numbers="[[showWeekNumbers]]"
              min-date="[[minDate]]"
              max-date="[[maxDate]]"
              part="month"
              theme$="[[_theme]]"
              on-keydown="__onMonthCalendarKeyDown"
            >
            </vaadin-month-calendar>
          </template>
        </vaadin-infinite-scroller>
        <vaadin-infinite-scroller
          id="yearScroller"
          on-custom-scroll="_onYearScroll"
          on-touchstart="_onYearScrollTouchStart"
          buffer-size="12"
          active="[[initialPosition]]"
          part="years"
          aria-hidden="true"
        >
          <template>
            <div
              part="year-number"
              current$="[[_isCurrentYear(index)]]"
              selected$="[[_isSelectedYear(index, selectedDate)]]"
            >
              [[_yearAfterXYears(index)]]
            </div>
            <div part="year-separator" aria-hidden="true"></div>
          </template>
        </vaadin-infinite-scroller>
      </div>

      <div on-touchend="_preventDefault" role="toolbar" part="toolbar">
        <vaadin-button
          id="todayButton"
          part="today-button"
          theme="tertiary"
          disabled="[[!_isTodayAllowed(minDate, maxDate)]]"
          on-keydown="__onTodayButtonKeyDown"
        >
          [[i18n.today]]
        </vaadin-button>
        <vaadin-button id="cancelButton" part="cancel-button" theme="tertiary" on-keydown="__onCancelButtonKeyDown">
          [[i18n.cancel]]
        </vaadin-button>
      </div>
    `;
    }
    static get is() {
      return "vaadin-date-picker-overlay-content";
    }
    static get properties() {
      return {
        scrollDuration: {
          type: Number,
          value: 300
        },
        /**
         * The value for this element.
         */
        selectedDate: {
          type: Date,
          value: null
        },
        /**
         * Date value which is focused using keyboard.
         */
        focusedDate: {
          type: Date,
          notify: !0,
          observer: "_focusedDateChanged"
        },
        _focusedMonthDate: Number,
        /**
         * Date which should be visible when there is no value selected.
         */
        initialPosition: {
          type: Date,
          observer: "_initialPositionChanged"
        },
        _originDate: {
          value: /* @__PURE__ */ new Date()
        },
        _visibleMonthIndex: Number,
        _desktopMode: Boolean,
        _desktopMediaQuery: {
          type: String,
          value: "(min-width: 375px)"
        },
        _translateX: {
          observer: "_translateXChanged"
        },
        _yearScrollerWidth: {
          value: 50
        },
        i18n: {
          type: Object
        },
        showWeekNumbers: {
          type: Boolean
        },
        _ignoreTaps: Boolean,
        _notTapping: Boolean,
        /**
         * The earliest date that can be selected. All earlier dates will be disabled.
         */
        minDate: Date,
        /**
         * The latest date that can be selected. All later dates will be disabled.
         */
        maxDate: Date,
        /**
         * Input label
         */
        label: String
      };
    }
    get __isRTL() {
      return this.getAttribute("dir") === "rtl";
    }
    /**
     * Whether to scroll to a sub-month position when scrolling to a date.
     * This is active if the month scroller is not large enough to fit a
     * full month. In that case we want to scroll to a position between
     * two months in order to have the focused date in the visible area.
     * @returns {boolean} whether to use sub-month scrolling
     * @private
     */
    get __useSubMonthScrolling() {
      return this.$.monthScroller.clientHeight < this.$.monthScroller.itemHeight + this.$.monthScroller.bufferOffset;
    }
    get calendars() {
      return [...this.shadowRoot.querySelectorAll("vaadin-month-calendar")];
    }
    get focusableDateElement() {
      return this.calendars.map((e) => e.focusableDateElement).find(Boolean);
    }
    ready() {
      super.ready(), this.setAttribute("role", "dialog"), er(this.$.scrollers, "track", this._track.bind(this)), er(this.shadowRoot.querySelector('[part="clear-button"]'), "tap", this._clear.bind(this)), er(this.shadowRoot.querySelector('[part="today-button"]'), "tap", this._onTodayTap.bind(this)), er(this.shadowRoot.querySelector('[part="cancel-button"]'), "tap", this._cancel.bind(this)), er(this.shadowRoot.querySelector('[part="toggle-button"]'), "tap", this._cancel.bind(this)), er(this.shadowRoot.querySelector('[part="years"]'), "tap", this._onYearTap.bind(this)), er(
        this.shadowRoot.querySelector('[part="years-toggle-button"]'),
        "tap",
        this._toggleYearScroller.bind(this)
      ), this.addController(
        new o_(this._desktopMediaQuery, (e) => {
          this._desktopMode = e;
        })
      );
    }
    /**
     * Fired when the scroller reaches the target scrolling position.
     * @event scroll-animation-finished
     * @param {Number} detail.position new position
     * @param {Number} detail.oldPosition old position
     */
    connectedCallback() {
      super.connectedCallback(), this._closeYearScroller(), this._toggleAnimateClass(!0), Yb(this.$.scrollers, "pan-y");
    }
    /**
     * Focuses the cancel button
     */
    focusCancel() {
      this.$.cancelButton.focus();
    }
    /**
     * Scrolls the list to the given Date.
     */
    scrollToDate(e, t) {
      const i = this.__useSubMonthScrolling ? this._calculateWeekScrollOffset(e) : 0;
      this._scrollToPosition(this._differenceInMonths(e, this._originDate) + i, t), this.$.monthScroller.forceUpdate();
    }
    /**
     * Select a date and fire event indicating user interaction.
     * @protected
     */
    _selectDate(e) {
      this.selectedDate = e, this.dispatchEvent(
        new CustomEvent("date-selected", { detail: { date: e }, bubbles: !0, composed: !0 })
      );
    }
    _focusedDateChanged(e) {
      this.revealDate(e);
    }
    _isCurrentYear(e) {
      return e === 0;
    }
    _isSelectedYear(e, t) {
      if (t)
        return t.getFullYear() === this._originDate.getFullYear() + e;
    }
    /**
     * Scrolls the month and year scrollers enough to reveal the given date.
     */
    revealDate(e, t = !0) {
      if (!e)
        return;
      const i = this._differenceInMonths(e, this._originDate);
      if (this.__useSubMonthScrolling) {
        const u = this._calculateWeekScrollOffset(e);
        this._scrollToPosition(i + u, t);
        return;
      }
      const o = this.$.monthScroller.position > i, l = Math.max(
        this.$.monthScroller.itemHeight,
        this.$.monthScroller.clientHeight - this.$.monthScroller.bufferOffset * 2
      ) / this.$.monthScroller.itemHeight, d = this.$.monthScroller.position + l - 1 < i;
      o ? this._scrollToPosition(i, t) : d && this._scrollToPosition(i - l + 1, t);
    }
    /**
     * Calculates an offset to be added to the month scroll position
     * when using sub-month scrolling, in order ensure that the week
     * that the date is in is visible even for small scroll areas.
     * As the month scroller uses a month as minimal scroll unit
     * (a value of `1` equals one month), we can not exactly identify
     * the position of a specific week. This is a best effort
     * implementation based on manual testing.
     * @param date the date for which to calculate the offset
     * @returns {number} the offset
     * @private
     */
    _calculateWeekScrollOffset(e) {
      const t = new Date(0, 0);
      t.setFullYear(e.getFullYear()), t.setMonth(e.getMonth()), t.setDate(1);
      let i = 0;
      for (; t.getDate() < e.getDate(); )
        t.setDate(t.getDate() + 1), t.getDay() === this.i18n.firstDayOfWeek && (i += 1);
      return i / 6;
    }
    _initialPositionChanged(e) {
      this.scrollToDate(e);
    }
    _repositionYearScroller() {
      this._visibleMonthIndex = Math.floor(this.$.monthScroller.position), this.$.yearScroller.position = (this.$.monthScroller.position + this._originDate.getMonth()) / 12;
    }
    _repositionMonthScroller() {
      this.$.monthScroller.position = this.$.yearScroller.position * 12 - this._originDate.getMonth(), this._visibleMonthIndex = Math.floor(this.$.monthScroller.position);
    }
    _onMonthScroll() {
      this._repositionYearScroller(), this._doIgnoreTaps();
    }
    _onYearScroll() {
      this._repositionMonthScroller(), this._doIgnoreTaps();
    }
    _onYearScrollTouchStart() {
      this._notTapping = !1, setTimeout(() => {
        this._notTapping = !0;
      }, 300), this._repositionMonthScroller();
    }
    _onMonthScrollTouchStart() {
      this._repositionYearScroller();
    }
    _doIgnoreTaps() {
      this._ignoreTaps = !0, this._debouncer = Do.debounce(this._debouncer, Un.after(300), () => {
        this._ignoreTaps = !1;
      });
    }
    _formatDisplayed(e, t, i) {
      return e ? t(i_(e)) : i;
    }
    _onTodayTap() {
      const e = /* @__PURE__ */ new Date();
      Math.abs(this.$.monthScroller.position - this._differenceInMonths(e, this._originDate)) < 1e-3 ? (this._selectDate(e), this._close()) : this._scrollToCurrentMonth();
    }
    _scrollToCurrentMonth() {
      this.focusedDate && (this.focusedDate = /* @__PURE__ */ new Date()), this.scrollToDate(/* @__PURE__ */ new Date(), !0);
    }
    _onYearTap(e) {
      if (!this._ignoreTaps && !this._notTapping) {
        const i = (e.detail.y - (this.$.yearScroller.getBoundingClientRect().top + this.$.yearScroller.clientHeight / 2)) / this.$.yearScroller.itemHeight;
        this._scrollToPosition(this.$.monthScroller.position + i * 12, !0);
      }
    }
    _scrollToPosition(e, t) {
      if (this._targetPosition !== void 0) {
        this._targetPosition = e;
        return;
      }
      if (!t) {
        this.$.monthScroller.position = e, this._targetPosition = void 0, this._repositionYearScroller(), this.__tryFocusDate();
        return;
      }
      this._targetPosition = e;
      let i;
      this._revealPromise = new Promise((u) => {
        i = u;
      });
      const o = (u, f, g, _) => (u /= _ / 2, u < 1 ? g / 2 * u * u + f : (u -= 1, -g / 2 * (u * (u - 2) - 1) + f));
      let a = 0;
      const l = this.$.monthScroller.position, d = (u) => {
        a = a || u;
        const f = u - a;
        if (f < this.scrollDuration) {
          const g = o(
            f,
            l,
            this._targetPosition - l,
            this.scrollDuration
          );
          this.$.monthScroller.position = g, window.requestAnimationFrame(d);
        } else
          this.dispatchEvent(
            new CustomEvent("scroll-animation-finished", {
              bubbles: !0,
              composed: !0,
              detail: {
                position: this._targetPosition,
                oldPosition: l
              }
            })
          ), this.$.monthScroller.position = this._targetPosition, this._targetPosition = void 0, i(), this._revealPromise = void 0;
        setTimeout(this._repositionYearScroller.bind(this), 1);
      };
      window.requestAnimationFrame(d);
    }
    _limit(e, t) {
      return Math.min(t.max, Math.max(t.min, e));
    }
    _handleTrack(e) {
      if (Math.abs(e.detail.dx) < 10 || Math.abs(e.detail.ddy) > 10)
        return;
      Math.abs(e.detail.ddx) > this._yearScrollerWidth / 3 && this._toggleAnimateClass(!0);
      const t = this._translateX + e.detail.ddx;
      this._translateX = this._limit(t, {
        min: 0,
        max: this._yearScrollerWidth
      });
    }
    _track(e) {
      if (!this._desktopMode)
        switch (e.detail.state) {
          case "start":
            this._toggleAnimateClass(!1);
            break;
          case "track":
            this._handleTrack(e);
            break;
          case "end":
            this._toggleAnimateClass(!0), this._translateX >= this._yearScrollerWidth / 2 ? this._closeYearScroller() : this._openYearScroller();
            break;
        }
    }
    _toggleAnimateClass(e) {
      e ? this.classList.add("animate") : this.classList.remove("animate");
    }
    _toggleYearScroller() {
      this._isYearScrollerVisible() ? this._closeYearScroller() : this._openYearScroller();
    }
    _openYearScroller() {
      this._translateX = 0, this.setAttribute("years-visible", "");
    }
    _closeYearScroller() {
      this.removeAttribute("years-visible"), this._translateX = this._yearScrollerWidth;
    }
    _isYearScrollerVisible() {
      return this._translateX < this._yearScrollerWidth / 2;
    }
    _translateXChanged(e) {
      this._desktopMode || (this.$.monthScroller.style.transform = `translateX(${e - this._yearScrollerWidth}px)`, this.$.yearScroller.style.transform = `translateX(${e}px)`);
    }
    _yearAfterXYears(e) {
      const t = new Date(this._originDate);
      return t.setFullYear(parseInt(e) + this._originDate.getFullYear()), t.getFullYear();
    }
    _yearAfterXMonths(e) {
      return this._dateAfterXMonths(e).getFullYear();
    }
    _dateAfterXMonths(e) {
      const t = new Date(this._originDate);
      return t.setDate(1), t.setMonth(parseInt(e) + this._originDate.getMonth()), t;
    }
    _differenceInMonths(e, t) {
      return (e.getFullYear() - t.getFullYear()) * 12 - t.getMonth() + e.getMonth();
    }
    _clear() {
      this._selectDate("");
    }
    _close() {
      this.dispatchEvent(new CustomEvent("close", { bubbles: !0, composed: !0 }));
    }
    _cancel() {
      this.focusedDate = this.selectedDate, this._close();
    }
    _preventDefault(e) {
      e.preventDefault();
    }
    __toggleDate(e) {
      kr(e, this.selectedDate) ? (this._clear(), this.focusedDate = e) : this._selectDate(e);
    }
    __onMonthCalendarKeyDown(e) {
      let t = !1;
      switch (e.key) {
        case "ArrowDown":
          this._moveFocusByDays(7), t = !0;
          break;
        case "ArrowUp":
          this._moveFocusByDays(-7), t = !0;
          break;
        case "ArrowRight":
          this._moveFocusByDays(this.__isRTL ? -1 : 1), t = !0;
          break;
        case "ArrowLeft":
          this._moveFocusByDays(this.__isRTL ? 1 : -1), t = !0;
          break;
        case "Enter":
          this._selectDate(this.focusedDate), this._close(), t = !0;
          break;
        case " ":
          this.__toggleDate(this.focusedDate), t = !0;
          break;
        case "Home":
          this._moveFocusInsideMonth(this.focusedDate, "minDate"), t = !0;
          break;
        case "End":
          this._moveFocusInsideMonth(this.focusedDate, "maxDate"), t = !0;
          break;
        case "PageDown":
          this._moveFocusByMonths(e.shiftKey ? 12 : 1), t = !0;
          break;
        case "PageUp":
          this._moveFocusByMonths(e.shiftKey ? -12 : -1), t = !0;
          break;
        case "Tab":
          this._onTabKeyDown(e, "calendar");
          break;
      }
      t && (e.preventDefault(), e.stopPropagation());
    }
    _onTabKeyDown(e, t) {
      switch (e.stopPropagation(), t) {
        case "calendar":
          e.shiftKey && (e.preventDefault(), this.hasAttribute("fullscreen") ? this.$.cancelButton.focus() : this.__focusInput());
          break;
        case "today":
          e.shiftKey && (e.preventDefault(), this.focusDateElement());
          break;
        case "cancel":
          e.shiftKey || (e.preventDefault(), this.hasAttribute("fullscreen") ? this.focusDateElement() : this.__focusInput());
          break;
      }
    }
    __onTodayButtonKeyDown(e) {
      e.key === "Tab" && this._onTabKeyDown(e, "today");
    }
    __onCancelButtonKeyDown(e) {
      e.key === "Tab" && this._onTabKeyDown(e, "cancel");
    }
    __focusInput() {
      this.dispatchEvent(new CustomEvent("focus-input", { bubbles: !0, composed: !0 }));
    }
    __tryFocusDate() {
      if (this.__pendingDateFocus) {
        const t = this.focusableDateElement;
        t && kr(t.date, this.__pendingDateFocus) && (delete this.__pendingDateFocus, t.focus());
      }
    }
    async focusDate(e, t) {
      const i = e || this.selectedDate || this.initialPosition || /* @__PURE__ */ new Date();
      this.focusedDate = i, t || (this._focusedMonthDate = i.getDate()), await this.focusDateElement(!1);
    }
    async focusDateElement(e = !0) {
      this.__pendingDateFocus = this.focusedDate, this.calendars.length || await new Promise((t) => {
        setTimeout(t);
      }), e && this.revealDate(this.focusedDate), this._revealPromise && await this._revealPromise, this.__tryFocusDate();
    }
    _focusClosestDate(e) {
      this.focusDate(r_(e, [this.minDate, this.maxDate]));
    }
    _moveFocusByDays(e) {
      const t = this.focusedDate, i = new Date(0, 0);
      i.setFullYear(t.getFullYear()), i.setMonth(t.getMonth()), i.setDate(t.getDate() + e), this._dateAllowed(i, this.minDate, this.maxDate) ? this.focusDate(i) : this._dateAllowed(t, this.minDate, this.maxDate) ? e > 0 ? this.focusDate(this.maxDate) : this.focusDate(this.minDate) : this._focusClosestDate(t);
    }
    _moveFocusByMonths(e) {
      const t = this.focusedDate, i = new Date(0, 0);
      i.setFullYear(t.getFullYear()), i.setMonth(t.getMonth() + e);
      const o = i.getMonth();
      i.setDate(this._focusedMonthDate || (this._focusedMonthDate = t.getDate())), i.getMonth() !== o && i.setDate(0), this._dateAllowed(i, this.minDate, this.maxDate) ? this.focusDate(i, !0) : this._dateAllowed(t, this.minDate, this.maxDate) ? e > 0 ? this.focusDate(this.maxDate) : this.focusDate(this.minDate) : this._focusClosestDate(t);
    }
    _moveFocusInsideMonth(e, t) {
      const i = new Date(0, 0);
      i.setFullYear(e.getFullYear()), t === "minDate" ? (i.setMonth(e.getMonth()), i.setDate(1)) : (i.setMonth(e.getMonth() + 1), i.setDate(0)), this._dateAllowed(i, this.minDate, this.maxDate) ? this.focusDate(i) : this._dateAllowed(e, this.minDate, this.maxDate) ? this.focusDate(this[t]) : this._focusClosestDate(e);
    }
    _dateAllowed(e, t, i) {
      return (!t || e >= t) && (!i || e <= i);
    }
    _isTodayAllowed(e, t) {
      const i = /* @__PURE__ */ new Date(), o = new Date(0, 0);
      return o.setFullYear(i.getFullYear()), o.setMonth(i.getMonth()), o.setDate(i.getDate()), this._dateAllowed(o, e, t);
    }
  }
  customElements.define(xg.is, xg);
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  const n_ = Oe(
    (r) => class extends Ua(jb(r)) {
      static get properties() {
        return {
          /**
           * Specify that this control should have input focus when the page loads.
           */
          autofocus: {
            type: Boolean
          },
          /**
           * A reference to the focusable element controlled by the mixin.
           * It can be an input, textarea, button or any element with tabindex > -1.
           *
           * Any component implementing this mixin is expected to provide it
           * by using `this._setFocusElement(input)` Polymer API.
           *
           * Toggling `tabindex` attribute on the host element propagates its value to `focusElement`.
           *
           * @protected
           * @type {!HTMLElement}
           */
          focusElement: {
            type: Object,
            readOnly: !0,
            observer: "_focusElementChanged"
          },
          /**
           * Override the property from `TabIndexMixin`
           * to ensure the `tabindex` attribute of the focus element
           * will be restored to `0` after re-enabling the element.
           *
           * @protected
           * @override
           */
          _lastTabIndex: {
            value: 0
          }
        };
      }
      constructor() {
        super(), this._boundOnBlur = this._onBlur.bind(this), this._boundOnFocus = this._onFocus.bind(this);
      }
      /** @protected */
      ready() {
        super.ready(), this.autofocus && !this.disabled && requestAnimationFrame(() => {
          this.focus(), this.setAttribute("focus-ring", "");
        });
      }
      /**
       * @protected
       * @override
       */
      focus() {
        !this.focusElement || this.disabled || (this.focusElement.focus(), this._setFocused(!0));
      }
      /**
       * @protected
       * @override
       */
      blur() {
        this.focusElement && (this.focusElement.blur(), this._setFocused(!1));
      }
      /**
       * @protected
       * @override
       */
      click() {
        this.focusElement && !this.disabled && this.focusElement.click();
      }
      /** @protected */
      _focusElementChanged(t, i) {
        t ? (t.disabled = this.disabled, this._addFocusListeners(t), this.__forwardTabIndex(this.tabindex)) : i && this._removeFocusListeners(i);
      }
      /**
       * @param {HTMLElement} element
       * @protected
       */
      _addFocusListeners(t) {
        t.addEventListener("blur", this._boundOnBlur), t.addEventListener("focus", this._boundOnFocus);
      }
      /**
       * @param {HTMLElement} element
       * @protected
       */
      _removeFocusListeners(t) {
        t.removeEventListener("blur", this._boundOnBlur), t.removeEventListener("focus", this._boundOnFocus);
      }
      /**
       * Focus event does not bubble, so we dispatch it manually
       * on the host element to support adding focus listeners
       * when the focusable element is placed in light DOM.
       * @param {FocusEvent} event
       * @protected
       */
      _onFocus(t) {
        t.stopPropagation(), this.dispatchEvent(new Event("focus"));
      }
      /**
       * Blur event does not bubble, so we dispatch it manually
       * on the host element to support adding blur listeners
       * when the focusable element is placed in light DOM.
       * @param {FocusEvent} event
       * @protected
       */
      _onBlur(t) {
        t.stopPropagation(), this.dispatchEvent(new Event("blur"));
      }
      /**
       * @param {Event} event
       * @return {boolean}
       * @protected
       * @override
       */
      _shouldSetFocus(t) {
        return t.target === this.focusElement;
      }
      /**
       * @param {boolean} disabled
       * @param {boolean} oldDisabled
       * @protected
       * @override
       */
      _disabledChanged(t, i) {
        super._disabledChanged(t, i), this.focusElement && (this.focusElement.disabled = t), t && this.blur();
      }
      /**
       * Override an observer from `TabindexMixin`.
       * Do not call super to remove tabindex attribute
       * from the host after it has been forwarded.
       * @param {string} tabindex
       * @protected
       * @override
       */
      _tabindexChanged(t) {
        this.__forwardTabIndex(t);
      }
      /** @private */
      __forwardTabIndex(t) {
        t !== void 0 && this.focusElement && (this.focusElement.tabIndex = t, t !== -1 && (this.tabindex = void 0)), this.disabled && t && (t !== -1 && (this._lastTabIndex = t), this.tabindex = void 0);
      }
    }
  );
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  class NT extends Di {
    constructor(e) {
      super(
        e,
        "error-message",
        () => document.createElement("div"),
        (t, i) => {
          this.__updateErrorId(i), this.__updateHasError();
        },
        !0
      );
    }
    /**
     * ID attribute value set on the error message element.
     *
     * @return {string}
     */
    get errorId() {
      return this.node && this.node.id;
    }
    /**
     * Set the error message element text content.
     *
     * @param {string} errorMessage
     */
    setErrorMessage(e) {
      this.errorMessage = e, this.__updateHasError();
    }
    /**
     * Set invalid state for detecting whether to show error message.
     *
     * @param {boolean} invalid
     */
    setInvalid(e) {
      this.invalid = e, this.__updateHasError();
    }
    /**
     * Override to initialize the newly added custom error message.
     *
     * @param {Node} errorNode
     * @protected
     * @override
     */
    initCustomNode(e) {
      this.__updateErrorId(e), e.textContent && !this.errorMessage && (this.errorMessage = e.textContent.trim()), this.__updateHasError();
    }
    /**
     * Override to cleanup error message node when it's removed.
     *
     * @param {Node} node
     * @protected
     * @override
     */
    teardownNode(e) {
      let t = this.getSlotChild();
      !t && e !== this.defaultNode && (t = this.attachDefaultNode(), this.initNode(t)), this.__updateHasError();
    }
    /**
     * @param {string} error
     * @private
     */
    __isNotEmpty(e) {
      return !!(e && e.trim() !== "");
    }
    /** @private */
    __updateHasError() {
      const e = this.node, t = !!(this.invalid && this.__isNotEmpty(this.errorMessage));
      e && (e.textContent = t ? this.errorMessage : "", e.hidden = !t, t ? e.setAttribute("role", "alert") : e.removeAttribute("role")), this.host.toggleAttribute("has-error-message", t);
    }
    /**
     * @param {HTMLElement} errorNode
     * @private
     */
    __updateErrorId(e) {
      e.id || (e.id = this.defaultId);
    }
  }
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  class LT {
    constructor(e) {
      this.host = e, this.__required = !1;
    }
    /**
     * Sets a target element to which ARIA attributes are added.
     *
     * @param {HTMLElement} target
     */
    setTarget(e) {
      this.__target = e, this.__setAriaRequiredAttribute(this.__required), this.__setLabelIdToAriaAttribute(this.__labelId), this.__setErrorIdToAriaAttribute(this.__errorId), this.__setHelperIdToAriaAttribute(this.__helperId);
    }
    /**
     * Toggles the `aria-required` attribute on the target element
     * if the target is the host component (e.g. a field group).
     * Otherwise, it does nothing.
     *
     * @param {boolean} required
     */
    setRequired(e) {
      this.__setAriaRequiredAttribute(e), this.__required = e;
    }
    /**
     * Links the target element with a slotted label element
     * via the target's attribute `aria-labelledby`.
     *
     * To unlink the previous slotted label element, pass `null` as `labelId`.
     *
     * @param {string | null} labelId
     */
    setLabelId(e) {
      this.__setLabelIdToAriaAttribute(e, this.__labelId), this.__labelId = e;
    }
    /**
     * Links the target element with a slotted error element via the target's attribute:
     * - `aria-labelledby` if the target is the host component (e.g a field group).
     * - `aria-describedby` otherwise.
     *
     * To unlink the previous slotted error element, pass `null` as `errorId`.
     *
     * @param {string | null} errorId
     */
    setErrorId(e) {
      this.__setErrorIdToAriaAttribute(e, this.__errorId), this.__errorId = e;
    }
    /**
     * Links the target element with a slotted helper element via the target's attribute:
     * - `aria-labelledby` if the target is the host component (e.g a field group).
     * - `aria-describedby` otherwise.
     *
     * To unlink the previous slotted helper element, pass `null` as `helperId`.
     *
     * @param {string | null} helperId
     */
    setHelperId(e) {
      this.__setHelperIdToAriaAttribute(e, this.__helperId), this.__helperId = e;
    }
    /**
     * `true` if the target element is the host component itself, `false` otherwise.
     *
     * @return {boolean}
     * @private
     */
    get __isGroupField() {
      return this.__target === this.host;
    }
    /**
     * @param {string | null | undefined} labelId
     * @param {string | null | undefined} oldLabelId
     * @private
     */
    __setLabelIdToAriaAttribute(e, t) {
      this.__setAriaAttributeId("aria-labelledby", e, t);
    }
    /**
     * @param {string | null | undefined} errorId
     * @param {string | null | undefined} oldErrorId
     * @private
     */
    __setErrorIdToAriaAttribute(e, t) {
      this.__isGroupField ? this.__setAriaAttributeId("aria-labelledby", e, t) : this.__setAriaAttributeId("aria-describedby", e, t);
    }
    /**
     * @param {string | null | undefined} helperId
     * @param {string | null | undefined} oldHelperId
     * @private
     */
    __setHelperIdToAriaAttribute(e, t) {
      this.__isGroupField ? this.__setAriaAttributeId("aria-labelledby", e, t) : this.__setAriaAttributeId("aria-describedby", e, t);
    }
    /**
     * @param {boolean} required
     * @private
     */
    __setAriaRequiredAttribute(e) {
      this.__target && (["input", "textarea"].includes(this.__target.localName) || (e ? this.__target.setAttribute("aria-required", "true") : this.__target.removeAttribute("aria-required")));
    }
    /**
     * @param {string | null | undefined} newId
     * @param {string | null | undefined} oldId
     * @private
     */
    __setAriaAttributeId(e, t, i) {
      this.__target && (i && CT(this.__target, e, i), t && xT(this.__target, e, t));
    }
  }
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  class RT extends Di {
    constructor(e) {
      super(e, "helper", null, null, !0);
    }
    get helperId() {
      return this.node && this.node.id;
    }
    /**
     * Override to initialize the newly added custom helper.
     *
     * @param {Node} helperNode
     * @protected
     * @override
     */
    initCustomNode(e) {
      this.__updateHelperId(e), this.__observeHelper(e);
      const t = this.__hasHelper(e);
      this.__toggleHasHelper(t);
    }
    /**
     * Override to cleanup helper node when it's removed.
     *
     * @param {Node} _node
     * @protected
     * @override
     */
    teardownNode(e) {
      this.__helperIdObserver && this.__helperIdObserver.disconnect();
      const t = this.getSlotChild();
      if (t && t !== this.defaultNode) {
        const i = this.__hasHelper(t);
        this.__toggleHasHelper(i);
      } else
        this.__applyDefaultHelper(this.helperText, t);
    }
    /**
     * Set helper text based on corresponding host property.
     * @param {string} helperText
     */
    setHelperText(e) {
      this.helperText = e;
      const t = this.getSlotChild();
      (!t || t === this.defaultNode) && this.__applyDefaultHelper(e, t);
    }
    /**
     * @param {HTMLElement} helperNode
     * @return {boolean}
     * @private
     */
    __hasHelper(e) {
      return e ? e.children.length > 0 || e.nodeType === Node.ELEMENT_NODE && customElements.get(e.localName) || this.__isNotEmpty(e.textContent) : !1;
    }
    /**
     * @param {string} helperText
     * @private
     */
    __isNotEmpty(e) {
      return e && e.trim() !== "";
    }
    /**
     * @param {string} helperText
     * @param {Node} helperNode
     * @private
     */
    __applyDefaultHelper(e, t) {
      const i = this.__isNotEmpty(e);
      i && !t && (this.slotFactory = () => document.createElement("div"), t = this.attachDefaultNode(), this.__updateHelperId(t), this.__observeHelper(t)), t && (t.textContent = e), this.__toggleHasHelper(i);
    }
    /**
     * @param {HTMLElement} helperNode
     * @private
     */
    __observeHelper(e) {
      this.__helperObserver = new MutationObserver((t) => {
        t.forEach((i) => {
          const o = i.target, a = o === this.node;
          if (i.type === "attributes")
            a && o.id !== this.defaultId && this.__updateHelperId(o);
          else if (a || o.parentElement === this.node) {
            const l = this.__hasHelper(this.node);
            this.__toggleHasHelper(l);
          }
        });
      }), this.__helperObserver.observe(e, {
        attributes: !0,
        attributeFilter: ["id"],
        childList: !0,
        subtree: !0,
        characterData: !0
      });
    }
    /**
     * @param {boolean} hasHelper
     * @private
     */
    __toggleHasHelper(e) {
      this.host.toggleAttribute("has-helper", e), this.dispatchEvent(
        new CustomEvent("helper-changed", {
          detail: {
            hasHelper: e,
            node: this.node
          }
        })
      );
    }
    /**
     * @param {HTMLElement} helperNode
     * @private
     */
    __updateHelperId(e) {
      e.id || (e.id = this.defaultId);
    }
  }
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  class FT extends Di {
    constructor(e) {
      super(
        e,
        "label",
        () => document.createElement("label"),
        (t, i) => {
          this.__updateLabelId(i), this.__updateDefaultLabel(this.label), this.__observeLabel(i);
        },
        !0
      );
    }
    /**
     * @return {string}
     */
    get labelId() {
      return this.node.id;
    }
    /**
     * Override to initialize the newly added custom label.
     *
     * @param {Node} labelNode
     * @protected
     * @override
     */
    initCustomNode(e) {
      this.__updateLabelId(e);
      const t = this.__hasLabel(e);
      this.__toggleHasLabel(t);
    }
    /**
     * Override to cleanup label node when it's removed.
     *
     * @param {Node} node
     * @protected
     * @override
     */
    teardownNode(e) {
      this.__labelObserver && this.__labelObserver.disconnect();
      let t = this.getSlotChild();
      !t && e !== this.defaultNode && (t = this.attachDefaultNode(), this.initNode(t));
      const i = this.__hasLabel(t);
      this.__toggleHasLabel(i);
    }
    /**
     * Set label based on corresponding host property.
     *
     * @param {string} label
     */
    setLabel(e) {
      this.label = e, this.__updateDefaultLabel(e);
    }
    /**
     * @param {HTMLElement} labelNode
     * @return {boolean}
     * @private
     */
    __hasLabel(e) {
      return e ? e.children.length > 0 || this.__isNotEmpty(e.textContent) : !1;
    }
    /**
     * @param {string} label
     * @private
     */
    __isNotEmpty(e) {
      return !!(e && e.trim() !== "");
    }
    /**
     * @param {HTMLElement} labelNode
     * @private
     */
    __observeLabel(e) {
      this.__labelObserver = new MutationObserver((t) => {
        t.forEach((i) => {
          const o = i.target, a = o === this.node;
          if (i.type === "attributes")
            a && o.id !== this.defaultId && this.__updateLabelId(o);
          else if (a || o.parentElement === this.node) {
            const l = this.__hasLabel(this.node);
            this.__toggleHasLabel(l);
          }
        });
      }), this.__labelObserver.observe(e, {
        attributes: !0,
        attributeFilter: ["id"],
        childList: !0,
        subtree: !0,
        characterData: !0
      });
    }
    /**
     * @param {boolean} hasLabel
     * @private
     */
    __toggleHasLabel(e) {
      this.host.toggleAttribute("has-label", e), this.dispatchEvent(
        new CustomEvent("label-changed", {
          detail: {
            hasLabel: e,
            node: this.node
          }
        })
      );
    }
    /**
     * @param {string} label
     * @private
     */
    __updateDefaultLabel(e) {
      if (this.defaultNode && (this.defaultNode.textContent = e, this.defaultNode === this.node)) {
        const t = this.__isNotEmpty(e);
        this.__toggleHasLabel(t);
      }
    }
    /**
     * @param {HTMLElement} labelNode
     * @private
     */
    __updateLabelId(e) {
      e.id || (e.id = this.defaultId);
    }
  }
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  const zT = Oe(
    (r) => class extends Oi(r) {
      static get properties() {
        return {
          /**
           * The label text for the input node.
           * When no light dom defined via [slot=label], this value will be used.
           */
          label: {
            type: String,
            observer: "_labelChanged"
          }
        };
      }
      /** @protected */
      get _labelId() {
        return this._labelController.labelId;
      }
      /** @protected */
      get _labelNode() {
        return this._labelController.node;
      }
      constructor() {
        super(), this._labelController = new FT(this);
      }
      /** @protected */
      ready() {
        super.ready(), this.addController(this._labelController);
      }
      /** @protected */
      _labelChanged(t) {
        this._labelController.setLabel(t);
      }
    }
  );
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  const s_ = Oe(
    (r) => class extends r {
      static get properties() {
        return {
          /**
           * Set to true when the field is invalid.
           */
          invalid: {
            type: Boolean,
            reflectToAttribute: !0,
            notify: !0,
            value: !1
          },
          /**
           * Specifies that the user must fill in a value.
           */
          required: {
            type: Boolean,
            reflectToAttribute: !0
          }
        };
      }
      /**
       * Validates the field and sets the `invalid` property based on the result.
       *
       * The method fires a `validated` event with the result of the validation.
       *
       * @return {boolean} True if the value is valid.
       */
      validate() {
        const t = this.checkValidity();
        return this._setInvalid(!t), this.dispatchEvent(new CustomEvent("validated", { detail: { valid: t } })), t;
      }
      /**
       * Returns true if the field value satisfies all constraints (if any).
       *
       * @return {boolean}
       */
      checkValidity() {
        return !this.required || !!this.value;
      }
      /**
       * @param {boolean} invalid
       * @protected
       */
      _setInvalid(t) {
        this._shouldSetInvalid(t) && (this.invalid = t);
      }
      /**
       * Override this method to define whether the given `invalid` state should be set.
       *
       * @param {boolean} _invalid
       * @return {boolean}
       * @protected
       */
      _shouldSetInvalid(t) {
        return !0;
      }
      /**
       * Fired whenever the field is validated.
       *
       * @event validated
       * @param {Object} detail
       * @param {boolean} detail.valid the result of the validation.
       */
    }
  );
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  const HT = (r) => class extends s_(zT(Oi(r))) {
    static get properties() {
      return {
        /**
         * A target element to which ARIA attributes are set.
         * @protected
         */
        ariaTarget: {
          type: Object,
          observer: "_ariaTargetChanged"
        },
        /**
         * Error to show when the field is invalid.
         *
         * @attr {string} error-message
         */
        errorMessage: {
          type: String,
          observer: "_errorMessageChanged"
        },
        /**
         * String used for the helper text.
         * @attr {string} helper-text
         */
        helperText: {
          type: String,
          observer: "_helperTextChanged"
        }
      };
    }
    static get observers() {
      return ["_invalidChanged(invalid)", "_requiredChanged(required)"];
    }
    /** @protected */
    get _errorId() {
      return this._errorController.errorId;
    }
    /**
     * @protected
     * @return {HTMLElement}
     */
    get _errorNode() {
      return this._errorController.node;
    }
    /** @protected */
    get _helperId() {
      return this._helperController.helperId;
    }
    /**
     * @protected
     * @return {HTMLElement}
     */
    get _helperNode() {
      return this._helperController.node;
    }
    constructor() {
      super(), this._fieldAriaController = new LT(this), this._helperController = new RT(this), this._errorController = new NT(this), this._labelController.addEventListener("label-changed", (t) => {
        const { hasLabel: i, node: o } = t.detail;
        this.__labelChanged(i, o);
      }), this._helperController.addEventListener("helper-changed", (t) => {
        const { hasHelper: i, node: o } = t.detail;
        this.__helperChanged(i, o);
      });
    }
    /** @protected */
    ready() {
      super.ready(), this.addController(this._fieldAriaController), this.addController(this._helperController), this.addController(this._errorController);
    }
    /** @private */
    __helperChanged(t, i) {
      t ? this._fieldAriaController.setHelperId(i.id) : this._fieldAriaController.setHelperId(null);
    }
    /** @private */
    __labelChanged(t, i) {
      t ? this._fieldAriaController.setLabelId(i.id) : this._fieldAriaController.setLabelId(null);
    }
    /**
     * @param {string | null | undefined} errorMessage
     * @protected
     */
    _errorMessageChanged(t) {
      this._errorController.setErrorMessage(t);
    }
    /**
     * @param {string} helperText
     * @protected
     */
    _helperTextChanged(t) {
      this._helperController.setHelperText(t);
    }
    /**
     * @param {HTMLElement | null | undefined} target
     * @protected
     */
    _ariaTargetChanged(t) {
      t && this._fieldAriaController.setTarget(t);
    }
    /**
     * @param {boolean} required
     * @protected
     */
    _requiredChanged(t) {
      this._fieldAriaController.setRequired(t);
    }
    /**
     * @param {boolean} invalid
     * @protected
     */
    _invalidChanged(t) {
      this._errorController.setInvalid(t), setTimeout(() => {
        t ? this._fieldAriaController.setErrorId(this._errorController.errorId) : this._fieldAriaController.setErrorId(null);
      });
    }
  };
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  const UT = Oe(
    (r) => class extends r {
      static get properties() {
        return {
          /**
           * A target element to which attributes and properties are delegated.
           * @protected
           */
          stateTarget: {
            type: Object,
            observer: "_stateTargetChanged"
          }
        };
      }
      /**
       * An array of the host attributes to delegate to the target element.
       */
      static get delegateAttrs() {
        return [];
      }
      /**
       * An array of the host properties to delegate to the target element.
       */
      static get delegateProps() {
        return [];
      }
      /** @protected */
      ready() {
        super.ready(), this._createDelegateAttrsObserver(), this._createDelegatePropsObserver();
      }
      /** @protected */
      _stateTargetChanged(t) {
        t && (this._ensureAttrsDelegated(), this._ensurePropsDelegated());
      }
      /** @protected */
      _createDelegateAttrsObserver() {
        this._createMethodObserver(`_delegateAttrsChanged(${this.constructor.delegateAttrs.join(", ")})`);
      }
      /** @protected */
      _createDelegatePropsObserver() {
        this._createMethodObserver(`_delegatePropsChanged(${this.constructor.delegateProps.join(", ")})`);
      }
      /** @protected */
      _ensureAttrsDelegated() {
        this.constructor.delegateAttrs.forEach((t) => {
          this._delegateAttribute(t, this[t]);
        });
      }
      /** @protected */
      _ensurePropsDelegated() {
        this.constructor.delegateProps.forEach((t) => {
          this._delegateProperty(t, this[t]);
        });
      }
      /** @protected */
      _delegateAttrsChanged(...t) {
        this.constructor.delegateAttrs.forEach((i, o) => {
          this._delegateAttribute(i, t[o]);
        });
      }
      /** @protected */
      _delegatePropsChanged(...t) {
        this.constructor.delegateProps.forEach((i, o) => {
          this._delegateProperty(i, t[o]);
        });
      }
      /** @protected */
      _delegateAttribute(t, i) {
        this.stateTarget && (t === "invalid" && this._delegateAttribute("aria-invalid", i ? "true" : !1), typeof i == "boolean" ? this.stateTarget.toggleAttribute(t, i) : i ? this.stateTarget.setAttribute(t, i) : this.stateTarget.removeAttribute(t));
      }
      /** @protected */
      _delegateProperty(t, i) {
        this.stateTarget && (this.stateTarget[t] = i);
      }
    }
  );
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  const WT = Oe(
    (r) => class extends r {
      static get properties() {
        return {
          /**
           * A reference to the input element controlled by the mixin.
           * Any component implementing this mixin is expected to provide it
           * by using `this._setInputElement(input)` Polymer API.
           *
           * A typical case is using `InputController` that does this automatically.
           * However, the input element does not have to always be native <input>:
           * as an example, <vaadin-combo-box-light> accepts other components.
           *
           * @protected
           * @type {!HTMLElement}
           */
          inputElement: {
            type: Object,
            readOnly: !0,
            observer: "_inputElementChanged"
          },
          /**
           * String used to define input type.
           * @protected
           */
          type: {
            type: String,
            readOnly: !0
          },
          /**
           * The value of the field.
           */
          value: {
            type: String,
            value: "",
            observer: "_valueChanged",
            notify: !0
          },
          /**
           * When true, the input element has a non-empty value entered by the user.
           * @protected
           */
          _hasInputValue: {
            type: Boolean,
            value: !1,
            observer: "_hasInputValueChanged"
          }
        };
      }
      constructor() {
        super(), this._boundOnInput = this.__onInput.bind(this), this._boundOnChange = this._onChange.bind(this);
      }
      /**
       * Clear the value of the field.
       */
      clear() {
        this.value = "";
      }
      /**
       * Add event listeners to the input element instance.
       * Override this method to add custom listeners.
       * @param {!HTMLElement} input
       * @protected
       */
      _addInputListeners(t) {
        t.addEventListener("input", this._boundOnInput), t.addEventListener("change", this._boundOnChange);
      }
      /**
       * Remove event listeners from the input element instance.
       * @param {!HTMLElement} input
       * @protected
       */
      _removeInputListeners(t) {
        t.removeEventListener("input", this._boundOnInput), t.removeEventListener("change", this._boundOnChange);
      }
      /**
       * A method to forward the value property set on the field
       * programmatically back to the input element value.
       * Override this method to perform additional checks,
       * for example to skip this in certain conditions.
       * @param {string} value
       * @protected
       */
      _forwardInputValue(t) {
        this.inputElement && (t != null ? this.inputElement.value = t : this.inputElement.value = "");
      }
      /**
       * @param {HTMLElement | undefined} input
       * @param {HTMLElement | undefined} oldInput
       * @protected
       */
      _inputElementChanged(t, i) {
        t ? this._addInputListeners(t) : i && this._removeInputListeners(i);
      }
      /**
       * Observer to notify about the change of private property.
       *
       * @private
       */
      _hasInputValueChanged(t, i) {
        (t || i) && this.dispatchEvent(new CustomEvent("has-input-value-changed"));
      }
      /**
       * An input event listener used to update `_hasInputValue` property.
       * Do not override this method.
       *
       * @param {Event} event
       * @private
       */
      __onInput(t) {
        this._setHasInputValue(t), this._onInput(t);
      }
      /**
       * An input event listener used to update the field value.
       *
       * @param {Event} event
       * @protected
       */
      _onInput(t) {
        const i = t.composedPath()[0];
        this.__userInput = t.isTrusted, this.value = i.value, this.__userInput = !1;
      }
      /**
       * A change event listener.
       * Override this method with an actual implementation.
       * @param {Event} _event
       * @protected
       */
      _onChange(t) {
      }
      /**
       * Toggle the has-value attribute based on the value property.
       *
       * @param {boolean} hasValue
       * @protected
       */
      _toggleHasValue(t) {
        this.toggleAttribute("has-value", t);
      }
      /**
       * Observer called when a value property changes.
       * @param {string | undefined} newVal
       * @param {string | undefined} oldVal
       * @protected
       */
      _valueChanged(t, i) {
        this._toggleHasValue(this._hasValue), !(t === "" && i === void 0) && (this.__userInput || this._forwardInputValue(t));
      }
      /**
       * Indicates whether the value is different from the default one.
       * Override if the `value` property has a type other than `string`.
       *
       * @protected
       */
      get _hasValue() {
        return this.value != null && this.value !== "";
      }
      /**
       * Sets the `_hasInputValue` property based on the `input` event.
       *
       * @param {InputEvent} event
       * @protected
       */
      _setHasInputValue(t) {
        const i = t.composedPath()[0];
        this._hasInputValue = i.value.length > 0;
      }
    }
  );
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  const a_ = Oe(
    (r) => class extends UT(s_(WT(r))) {
      /**
       * An array of attributes which participate in the input validation.
       * Changing these attributes will cause the input to re-validate.
       *
       * IMPORTANT: The attributes should be properly delegated to the input element
       * from the host using `delegateAttrs` getter (see `DelegateStateMixin`).
       * The `required` attribute is already delegated.
       */
      static get constraints() {
        return ["required"];
      }
      static get delegateAttrs() {
        return [...super.delegateAttrs, "required"];
      }
      /** @protected */
      ready() {
        super.ready(), this._createConstraintsObserver();
      }
      /**
       * Returns true if the current input value satisfies all constraints (if any).
       * @return {boolean}
       */
      checkValidity() {
        return this.inputElement && this._hasValidConstraints(this.constructor.constraints.map((t) => this[t])) ? this.inputElement.checkValidity() : !this.invalid;
      }
      /**
       * Returns true if some of the provided set of constraints are valid.
       * @param {Array} constraints
       * @return {boolean}
       * @protected
       */
      _hasValidConstraints(t) {
        return t.some((i) => this.__isValidConstraint(i));
      }
      /**
       * Override this method to customize setting up constraints observer.
       * @protected
       */
      _createConstraintsObserver() {
        this._createMethodObserver(`_constraintsChanged(stateTarget, ${this.constructor.constraints.join(", ")})`);
      }
      /**
       * Override this method to implement custom validation constraints.
       * @param {HTMLElement | undefined} stateTarget
       * @param {unknown[]} constraints
       * @protected
       */
      _constraintsChanged(t, ...i) {
        if (!t)
          return;
        const o = this._hasValidConstraints(i), a = this.__previousHasConstraints && !o;
        (this._hasValue || this.invalid) && o ? this.validate() : a && this._setInvalid(!1), this.__previousHasConstraints = o;
      }
      /**
       * Override an event listener inherited from `InputMixin`
       * to capture native `change` event and make sure that
       * a new one is dispatched after validation runs.
       * @param {Event} event
       * @protected
       * @override
       */
      _onChange(t) {
        t.stopPropagation(), this.validate(), this.dispatchEvent(
          new CustomEvent("change", {
            detail: {
              sourceEvent: t
            },
            bubbles: t.bubbles,
            cancelable: t.cancelable
          })
        );
      }
      /** @private */
      __isValidConstraint(t) {
        return !!t || t === 0;
      }
    }
  );
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  const Rc = /* @__PURE__ */ new WeakMap();
  function BT(r) {
    return Rc.has(r) || Rc.set(r, /* @__PURE__ */ new Set()), Rc.get(r);
  }
  function VT(r, e) {
    const t = document.createElement("style");
    t.textContent = r, e === document ? document.head.appendChild(t) : e.insertBefore(t, e.firstChild);
  }
  const qT = Oe(
    (r) => class extends r {
      /**
       * List of styles to insert into root.
       * @protected
       */
      get slotStyles() {
        return {};
      }
      /** @protected */
      connectedCallback() {
        super.connectedCallback(), this.__applySlotStyles();
      }
      /** @private */
      __applySlotStyles() {
        const t = this.getRootNode(), i = BT(t);
        this.slotStyles.forEach((o) => {
          i.has(o) || (VT(o, t), i.add(o));
        });
      }
    }
  );
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  const YT = (r) => class extends qT(
    n_(a_(HT(Ha(r))))
  ) {
    static get properties() {
      return {
        /**
         * A pattern matched against individual characters the user inputs.
         *
         * When set, the field will prevent:
         * - `keydown` events if the entered key doesn't match `/^allowedCharPattern$/`
         * - `paste` events if the pasted text doesn't match `/^allowedCharPattern*$/`
         * - `drop` events if the dropped text doesn't match `/^allowedCharPattern*$/`
         *
         * For example, to allow entering only numbers and minus signs, use:
         * `allowedCharPattern = "[\\d-]"`
         * @attr {string} allowed-char-pattern
         */
        allowedCharPattern: {
          type: String,
          observer: "_allowedCharPatternChanged"
        },
        /**
         * If true, the input text gets fully selected when the field is focused using click or touch / tap.
         */
        autoselect: {
          type: Boolean,
          value: !1
        },
        /**
         * Set to true to display the clear icon which clears the input.
         * @attr {boolean} clear-button-visible
         */
        clearButtonVisible: {
          type: Boolean,
          reflectToAttribute: !0,
          value: !1
        },
        /**
         * The name of this field.
         */
        name: {
          type: String,
          reflectToAttribute: !0
        },
        /**
         * A hint to the user of what can be entered in the field.
         */
        placeholder: {
          type: String,
          reflectToAttribute: !0
        },
        /**
         * When present, it specifies that the field is read-only.
         */
        readonly: {
          type: Boolean,
          value: !1,
          reflectToAttribute: !0
        },
        /**
         * The text usually displayed in a tooltip popup when the mouse is over the field.
         */
        title: {
          type: String,
          reflectToAttribute: !0
        }
      };
    }
    static get delegateAttrs() {
      return [...super.delegateAttrs, "name", "type", "placeholder", "readonly", "invalid", "title"];
    }
    constructor() {
      super(), this._boundOnPaste = this._onPaste.bind(this), this._boundOnDrop = this._onDrop.bind(this), this._boundOnBeforeInput = this._onBeforeInput.bind(this);
    }
    /**
     * Any element extending this mixin is required to implement this getter.
     * It returns the reference to the clear button element.
     * @protected
     * @return {Element | null | undefined}
     */
    get clearElement() {
      return null;
    }
    /** @protected */
    get slotStyles() {
      return [
        `
          :is(input[slot='input'], textarea[slot='textarea'])::placeholder {
            font: inherit;
            color: inherit;
          }
        `
      ];
    }
    /** @protected */
    ready() {
      super.ready(), this.clearElement && (this.clearElement.addEventListener("click", (t) => this._onClearButtonClick(t)), this.clearElement.addEventListener("mousedown", (t) => this._onClearButtonMouseDown(t)));
    }
    /**
     * @param {Event} event
     * @protected
     */
    _onClearButtonClick(t) {
      t.preventDefault(), this.__clear();
    }
    /**
     * @param {Event} event
     * @protected
     */
    _onClearButtonMouseDown(t) {
      t.preventDefault(), T$ || this.inputElement.focus();
    }
    /**
     * Override an event listener from `DelegateFocusMixin`.
     * @param {FocusEvent} event
     * @protected
     * @override
     */
    _onFocus(t) {
      super._onFocus(t), this.autoselect && this.inputElement && this.inputElement.select();
    }
    /**
     * Override an event listener inherited from `KeydownMixin` to clear on Esc.
     * Components that extend this mixin can prevent this behavior by overriding
     * this method without calling `super._onEscape` to provide custom logic.
     * @param {KeyboardEvent} event
     * @protected
     * @override
     */
    _onEscape(t) {
      super._onEscape(t), this.clearButtonVisible && this.value && (t.stopPropagation(), this.__clear());
    }
    /**
     * Override an event listener inherited from `InputMixin`
     * to capture native `change` event and make sure that
     * a new one is dispatched after validation runs.
     * @param {Event} event
     * @protected
     * @override
     */
    _onChange(t) {
      t.stopPropagation(), this.validate(), this.dispatchEvent(
        new CustomEvent("change", {
          detail: {
            sourceEvent: t
          },
          bubbles: t.bubbles,
          cancelable: t.cancelable
        })
      );
    }
    /** @private */
    __clear() {
      this.clear(), this.inputElement.dispatchEvent(new Event("input", { bubbles: !0, composed: !0 })), this.inputElement.dispatchEvent(new Event("change", { bubbles: !0 }));
    }
    /**
     * Override a method from `InputMixin`.
     * @param {!HTMLElement} input
     * @protected
     * @override
     */
    _addInputListeners(t) {
      super._addInputListeners(t), t.addEventListener("paste", this._boundOnPaste), t.addEventListener("drop", this._boundOnDrop), t.addEventListener("beforeinput", this._boundOnBeforeInput);
    }
    /**
     * Override a method from `InputMixin`.
     * @param {!HTMLElement} input
     * @protected
     * @override
     */
    _removeInputListeners(t) {
      super._removeInputListeners(t), t.removeEventListener("paste", this._boundOnPaste), t.removeEventListener("drop", this._boundOnDrop), t.removeEventListener("beforeinput", this._boundOnBeforeInput);
    }
    /**
     * Override an event listener from `KeyboardMixin`.
     * @param {!KeyboardEvent} event
     * @protected
     * @override
     */
    _onKeyDown(t) {
      super._onKeyDown(t), this.allowedCharPattern && !this.__shouldAcceptKey(t) && (t.preventDefault(), this._markInputPrevented());
    }
    /** @protected */
    _markInputPrevented() {
      this.setAttribute("input-prevented", ""), this._preventInputDebouncer = Do.debounce(this._preventInputDebouncer, Un.after(200), () => {
        this.removeAttribute("input-prevented");
      });
    }
    /** @private */
    __shouldAcceptKey(t) {
      return t.metaKey || t.ctrlKey || !t.key || // Allow typing anything if event.key is not supported
      t.key.length !== 1 || // Allow "Backspace", "ArrowLeft" etc.
      this.__allowedCharRegExp.test(t.key);
    }
    /** @private */
    _onPaste(t) {
      if (this.allowedCharPattern) {
        const i = t.clipboardData.getData("text");
        this.__allowedTextRegExp.test(i) || (t.preventDefault(), this._markInputPrevented());
      }
    }
    /** @private */
    _onDrop(t) {
      if (this.allowedCharPattern) {
        const i = t.dataTransfer.getData("text");
        this.__allowedTextRegExp.test(i) || (t.preventDefault(), this._markInputPrevented());
      }
    }
    /** @private */
    _onBeforeInput(t) {
      this.allowedCharPattern && t.data && !this.__allowedTextRegExp.test(t.data) && (t.preventDefault(), this._markInputPrevented());
    }
    /** @private */
    _allowedCharPatternChanged(t) {
      if (t)
        try {
          this.__allowedCharRegExp = new RegExp(`^${t}$`), this.__allowedTextRegExp = new RegExp(`^${t}*$`);
        } catch {
        }
    }
    /**
     * Fired when the user commits a value change.
     *
     * @event change
     */
    /**
     * Fired when the value is changed by the user: on every typing keystroke,
     * and the value is cleared using the clear button.
     *
     * @event input
     */
  };
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  class GT extends Di {
    constructor(e, t) {
      super(
        e,
        "input",
        () => document.createElement("input"),
        (i, o) => {
          i.value && (o.value = i.value), i.type && o.setAttribute("type", i.type), o.id = this.defaultId, typeof t == "function" && t(o);
        },
        !0
      );
    }
  }
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  class jT {
    constructor(e, t) {
      this.input = e, this.__preventDuplicateLabelClick = this.__preventDuplicateLabelClick.bind(this), t.addEventListener("label-changed", (i) => {
        this.__initLabel(i.detail.node);
      }), this.__initLabel(t.node);
    }
    /**
     * @param {HTMLElement} label
     * @private
     */
    __initLabel(e) {
      e && (e.addEventListener("click", this.__preventDuplicateLabelClick), this.input && e.setAttribute("for", this.input.id));
    }
    /**
     * The native platform fires an event for both the click on the label, and also
     * the subsequent click on the native input element caused by label click.
     * This results in two click events arriving at the host, but we only want one.
     * This method prevents the duplicate click and ensures the correct isTrusted event
     * with the correct event.target arrives at the host.
     * @private
     */
    __preventDuplicateLabelClick() {
      const e = (t) => {
        t.stopImmediatePropagation(), this.input.removeEventListener("click", e);
      };
      this.input.addEventListener("click", e);
    }
  }
  /**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   */
  const da = window, vu = da.ShadowRoot && (da.ShadyCSS === void 0 || da.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, yu = Symbol(), Cg = /* @__PURE__ */ new WeakMap();
  let l_ = class {
    constructor(e, t, i) {
      if (this._$cssResult$ = !0, i !== yu) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
      this.cssText = e, this.t = t;
    }
    get styleSheet() {
      let e = this.o;
      const t = this.t;
      if (vu && e === void 0) {
        const i = t !== void 0 && t.length === 1;
        i && (e = Cg.get(t)), e === void 0 && ((this.o = e = new CSSStyleSheet()).replaceSync(this.cssText), i && Cg.set(t, e));
      }
      return e;
    }
    toString() {
      return this.cssText;
    }
  };
  const ZT = (r) => new l_(typeof r == "string" ? r : r + "", void 0, yu), wu = (r, ...e) => {
    const t = r.length === 1 ? r[0] : e.reduce(((i, o, a) => i + ((l) => {
      if (l._$cssResult$ === !0) return l.cssText;
      if (typeof l == "number") return l;
      throw Error("Value passed to 'css' function must be a 'css' function result: " + l + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
    })(o) + r[a + 1]), r[0]);
    return new l_(t, r, yu);
  }, KT = (r, e) => {
    vu ? r.adoptedStyleSheets = e.map(((t) => t instanceof CSSStyleSheet ? t : t.styleSheet)) : e.forEach(((t) => {
      const i = document.createElement("style"), o = da.litNonce;
      o !== void 0 && i.setAttribute("nonce", o), i.textContent = t.cssText, r.appendChild(i);
    }));
  }, Sg = vu ? (r) => r : (r) => r instanceof CSSStyleSheet ? ((e) => {
    let t = "";
    for (const i of e.cssRules) t += i.cssText;
    return ZT(t);
  })(r) : r;
  /**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   */
  var Fc;
  const Ea = window, Ag = Ea.trustedTypes, JT = Ag ? Ag.emptyScript : "", Eg = Ea.reactiveElementPolyfillSupport, Ad = { toAttribute(r, e) {
    switch (e) {
      case Boolean:
        r = r ? JT : null;
        break;
      case Object:
      case Array:
        r = r == null ? r : JSON.stringify(r);
    }
    return r;
  }, fromAttribute(r, e) {
    let t = r;
    switch (e) {
      case Boolean:
        t = r !== null;
        break;
      case Number:
        t = r === null ? null : Number(r);
        break;
      case Object:
      case Array:
        try {
          t = JSON.parse(r);
        } catch {
          t = null;
        }
    }
    return t;
  } }, c_ = (r, e) => e !== r && (e == e || r == r), zc = { attribute: !0, type: String, converter: Ad, reflect: !1, hasChanged: c_ }, Ed = "finalized";
  let io = class extends HTMLElement {
    constructor() {
      super(), this._$Ei = /* @__PURE__ */ new Map(), this.isUpdatePending = !1, this.hasUpdated = !1, this._$El = null, this._$Eu();
    }
    static addInitializer(e) {
      var t;
      this.finalize(), ((t = this.h) !== null && t !== void 0 ? t : this.h = []).push(e);
    }
    static get observedAttributes() {
      this.finalize();
      const e = [];
      return this.elementProperties.forEach(((t, i) => {
        const o = this._$Ep(i, t);
        o !== void 0 && (this._$Ev.set(o, i), e.push(o));
      })), e;
    }
    static createProperty(e, t = zc) {
      if (t.state && (t.attribute = !1), this.finalize(), this.elementProperties.set(e, t), !t.noAccessor && !this.prototype.hasOwnProperty(e)) {
        const i = typeof e == "symbol" ? Symbol() : "__" + e, o = this.getPropertyDescriptor(e, i, t);
        o !== void 0 && Object.defineProperty(this.prototype, e, o);
      }
    }
    static getPropertyDescriptor(e, t, i) {
      return { get() {
        return this[t];
      }, set(o) {
        const a = this[e];
        this[t] = o, this.requestUpdate(e, a, i);
      }, configurable: !0, enumerable: !0 };
    }
    static getPropertyOptions(e) {
      return this.elementProperties.get(e) || zc;
    }
    static finalize() {
      if (this.hasOwnProperty(Ed)) return !1;
      this[Ed] = !0;
      const e = Object.getPrototypeOf(this);
      if (e.finalize(), e.h !== void 0 && (this.h = [...e.h]), this.elementProperties = new Map(e.elementProperties), this._$Ev = /* @__PURE__ */ new Map(), this.hasOwnProperty("properties")) {
        const t = this.properties, i = [...Object.getOwnPropertyNames(t), ...Object.getOwnPropertySymbols(t)];
        for (const o of i) this.createProperty(o, t[o]);
      }
      return this.elementStyles = this.finalizeStyles(this.styles), !0;
    }
    static finalizeStyles(e) {
      const t = [];
      if (Array.isArray(e)) {
        const i = new Set(e.flat(1 / 0).reverse());
        for (const o of i) t.unshift(Sg(o));
      } else e !== void 0 && t.push(Sg(e));
      return t;
    }
    static _$Ep(e, t) {
      const i = t.attribute;
      return i === !1 ? void 0 : typeof i == "string" ? i : typeof e == "string" ? e.toLowerCase() : void 0;
    }
    _$Eu() {
      var e;
      this._$E_ = new Promise(((t) => this.enableUpdating = t)), this._$AL = /* @__PURE__ */ new Map(), this._$Eg(), this.requestUpdate(), (e = this.constructor.h) === null || e === void 0 || e.forEach(((t) => t(this)));
    }
    addController(e) {
      var t, i;
      ((t = this._$ES) !== null && t !== void 0 ? t : this._$ES = []).push(e), this.renderRoot !== void 0 && this.isConnected && ((i = e.hostConnected) === null || i === void 0 || i.call(e));
    }
    removeController(e) {
      var t;
      (t = this._$ES) === null || t === void 0 || t.splice(this._$ES.indexOf(e) >>> 0, 1);
    }
    _$Eg() {
      this.constructor.elementProperties.forEach(((e, t) => {
        this.hasOwnProperty(t) && (this._$Ei.set(t, this[t]), delete this[t]);
      }));
    }
    createRenderRoot() {
      var e;
      const t = (e = this.shadowRoot) !== null && e !== void 0 ? e : this.attachShadow(this.constructor.shadowRootOptions);
      return KT(t, this.constructor.elementStyles), t;
    }
    connectedCallback() {
      var e;
      this.renderRoot === void 0 && (this.renderRoot = this.createRenderRoot()), this.enableUpdating(!0), (e = this._$ES) === null || e === void 0 || e.forEach(((t) => {
        var i;
        return (i = t.hostConnected) === null || i === void 0 ? void 0 : i.call(t);
      }));
    }
    enableUpdating(e) {
    }
    disconnectedCallback() {
      var e;
      (e = this._$ES) === null || e === void 0 || e.forEach(((t) => {
        var i;
        return (i = t.hostDisconnected) === null || i === void 0 ? void 0 : i.call(t);
      }));
    }
    attributeChangedCallback(e, t, i) {
      this._$AK(e, i);
    }
    _$EO(e, t, i = zc) {
      var o;
      const a = this.constructor._$Ep(e, i);
      if (a !== void 0 && i.reflect === !0) {
        const l = (((o = i.converter) === null || o === void 0 ? void 0 : o.toAttribute) !== void 0 ? i.converter : Ad).toAttribute(t, i.type);
        this._$El = e, l == null ? this.removeAttribute(a) : this.setAttribute(a, l), this._$El = null;
      }
    }
    _$AK(e, t) {
      var i;
      const o = this.constructor, a = o._$Ev.get(e);
      if (a !== void 0 && this._$El !== a) {
        const l = o.getPropertyOptions(a), d = typeof l.converter == "function" ? { fromAttribute: l.converter } : ((i = l.converter) === null || i === void 0 ? void 0 : i.fromAttribute) !== void 0 ? l.converter : Ad;
        this._$El = a, this[a] = d.fromAttribute(t, l.type), this._$El = null;
      }
    }
    requestUpdate(e, t, i) {
      let o = !0;
      e !== void 0 && (((i = i || this.constructor.getPropertyOptions(e)).hasChanged || c_)(this[e], t) ? (this._$AL.has(e) || this._$AL.set(e, t), i.reflect === !0 && this._$El !== e && (this._$EC === void 0 && (this._$EC = /* @__PURE__ */ new Map()), this._$EC.set(e, i))) : o = !1), !this.isUpdatePending && o && (this._$E_ = this._$Ej());
    }
    async _$Ej() {
      this.isUpdatePending = !0;
      try {
        await this._$E_;
      } catch (t) {
        Promise.reject(t);
      }
      const e = this.scheduleUpdate();
      return e != null && await e, !this.isUpdatePending;
    }
    scheduleUpdate() {
      return this.performUpdate();
    }
    performUpdate() {
      var e;
      if (!this.isUpdatePending) return;
      this.hasUpdated, this._$Ei && (this._$Ei.forEach(((o, a) => this[a] = o)), this._$Ei = void 0);
      let t = !1;
      const i = this._$AL;
      try {
        t = this.shouldUpdate(i), t ? (this.willUpdate(i), (e = this._$ES) === null || e === void 0 || e.forEach(((o) => {
          var a;
          return (a = o.hostUpdate) === null || a === void 0 ? void 0 : a.call(o);
        })), this.update(i)) : this._$Ek();
      } catch (o) {
        throw t = !1, this._$Ek(), o;
      }
      t && this._$AE(i);
    }
    willUpdate(e) {
    }
    _$AE(e) {
      var t;
      (t = this._$ES) === null || t === void 0 || t.forEach(((i) => {
        var o;
        return (o = i.hostUpdated) === null || o === void 0 ? void 0 : o.call(i);
      })), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(e)), this.updated(e);
    }
    _$Ek() {
      this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = !1;
    }
    get updateComplete() {
      return this.getUpdateComplete();
    }
    getUpdateComplete() {
      return this._$E_;
    }
    shouldUpdate(e) {
      return !0;
    }
    update(e) {
      this._$EC !== void 0 && (this._$EC.forEach(((t, i) => this._$EO(i, this[i], t))), this._$EC = void 0), this._$Ek();
    }
    updated(e) {
    }
    firstUpdated(e) {
    }
  };
  io[Ed] = !0, io.elementProperties = /* @__PURE__ */ new Map(), io.elementStyles = [], io.shadowRootOptions = { mode: "open" }, Eg?.({ ReactiveElement: io }), ((Fc = Ea.reactiveElementVersions) !== null && Fc !== void 0 ? Fc : Ea.reactiveElementVersions = []).push("1.6.3");
  /**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   */
  var Hc;
  const $a = window, Po = $a.trustedTypes, $g = Po ? Po.createPolicy("lit-html", { createHTML: (r) => r }) : void 0, $d = "$lit$", qr = `lit$${(Math.random() + "").slice(9)}$`, d_ = "?" + qr, XT = `<${d_}>`, Ei = document, Vn = () => Ei.createComment(""), qn = (r) => r === null || typeof r != "object" && typeof r != "function", u_ = Array.isArray, QT = (r) => u_(r) || typeof r?.[Symbol.iterator] == "function", Uc = `[ 	
\f\r]`, mn = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, Tg = /-->/g, Og = />/g, fi = RegExp(`>|${Uc}(?:([^\\s"'>=/]+)(${Uc}*=${Uc}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), Dg = /'/g, Pg = /"/g, h_ = /^(?:script|style|textarea|title)$/i, Io = Symbol.for("lit-noChange"), Le = Symbol.for("lit-nothing"), Ig = /* @__PURE__ */ new WeakMap(), vi = Ei.createTreeWalker(Ei, 129, null, !1);
  function f_(r, e) {
    if (!Array.isArray(r) || !r.hasOwnProperty("raw")) throw Error("invalid template strings array");
    return $g !== void 0 ? $g.createHTML(e) : e;
  }
  const eO = (r, e) => {
    const t = r.length - 1, i = [];
    let o, a = e === 2 ? "<svg>" : "", l = mn;
    for (let d = 0; d < t; d++) {
      const u = r[d];
      let f, g, _ = -1, C = 0;
      for (; C < u.length && (l.lastIndex = C, g = l.exec(u), g !== null); ) C = l.lastIndex, l === mn ? g[1] === "!--" ? l = Tg : g[1] !== void 0 ? l = Og : g[2] !== void 0 ? (h_.test(g[2]) && (o = RegExp("</" + g[2], "g")), l = fi) : g[3] !== void 0 && (l = fi) : l === fi ? g[0] === ">" ? (l = o ?? mn, _ = -1) : g[1] === void 0 ? _ = -2 : (_ = l.lastIndex - g[2].length, f = g[1], l = g[3] === void 0 ? fi : g[3] === '"' ? Pg : Dg) : l === Pg || l === Dg ? l = fi : l === Tg || l === Og ? l = mn : (l = fi, o = void 0);
      const x = l === fi && r[d + 1].startsWith("/>") ? " " : "";
      a += l === mn ? u + XT : _ >= 0 ? (i.push(f), u.slice(0, _) + $d + u.slice(_) + qr + x) : u + qr + (_ === -2 ? (i.push(void 0), d) : x);
    }
    return [f_(r, a + (r[t] || "<?>") + (e === 2 ? "</svg>" : "")), i];
  };
  class Yn {
    constructor({ strings: e, _$litType$: t }, i) {
      let o;
      this.parts = [];
      let a = 0, l = 0;
      const d = e.length - 1, u = this.parts, [f, g] = eO(e, t);
      if (this.el = Yn.createElement(f, i), vi.currentNode = this.el.content, t === 2) {
        const _ = this.el.content, C = _.firstChild;
        C.remove(), _.append(...C.childNodes);
      }
      for (; (o = vi.nextNode()) !== null && u.length < d; ) {
        if (o.nodeType === 1) {
          if (o.hasAttributes()) {
            const _ = [];
            for (const C of o.getAttributeNames()) if (C.endsWith($d) || C.startsWith(qr)) {
              const x = g[l++];
              if (_.push(C), x !== void 0) {
                const D = o.getAttribute(x.toLowerCase() + $d).split(qr), P = /([.?@])?(.*)/.exec(x);
                u.push({ type: 1, index: a, name: P[2], strings: D, ctor: P[1] === "." ? rO : P[1] === "?" ? oO : P[1] === "@" ? nO : Wa });
              } else u.push({ type: 6, index: a });
            }
            for (const C of _) o.removeAttribute(C);
          }
          if (h_.test(o.tagName)) {
            const _ = o.textContent.split(qr), C = _.length - 1;
            if (C > 0) {
              o.textContent = Po ? Po.emptyScript : "";
              for (let x = 0; x < C; x++) o.append(_[x], Vn()), vi.nextNode(), u.push({ type: 2, index: ++a });
              o.append(_[C], Vn());
            }
          }
        } else if (o.nodeType === 8) if (o.data === d_) u.push({ type: 2, index: a });
        else {
          let _ = -1;
          for (; (_ = o.data.indexOf(qr, _ + 1)) !== -1; ) u.push({ type: 7, index: a }), _ += qr.length - 1;
        }
        a++;
      }
    }
    static createElement(e, t) {
      const i = Ei.createElement("template");
      return i.innerHTML = e, i;
    }
  }
  function Mo(r, e, t = r, i) {
    var o, a, l, d;
    if (e === Io) return e;
    let u = i !== void 0 ? (o = t._$Co) === null || o === void 0 ? void 0 : o[i] : t._$Cl;
    const f = qn(e) ? void 0 : e._$litDirective$;
    return u?.constructor !== f && ((a = u?._$AO) === null || a === void 0 || a.call(u, !1), f === void 0 ? u = void 0 : (u = new f(r), u._$AT(r, t, i)), i !== void 0 ? ((l = (d = t)._$Co) !== null && l !== void 0 ? l : d._$Co = [])[i] = u : t._$Cl = u), u !== void 0 && (e = Mo(r, u._$AS(r, e.values), u, i)), e;
  }
  class tO {
    constructor(e, t) {
      this._$AV = [], this._$AN = void 0, this._$AD = e, this._$AM = t;
    }
    get parentNode() {
      return this._$AM.parentNode;
    }
    get _$AU() {
      return this._$AM._$AU;
    }
    u(e) {
      var t;
      const { el: { content: i }, parts: o } = this._$AD, a = ((t = e?.creationScope) !== null && t !== void 0 ? t : Ei).importNode(i, !0);
      vi.currentNode = a;
      let l = vi.nextNode(), d = 0, u = 0, f = o[0];
      for (; f !== void 0; ) {
        if (d === f.index) {
          let g;
          f.type === 2 ? g = new Jn(l, l.nextSibling, this, e) : f.type === 1 ? g = new f.ctor(l, f.name, f.strings, this, e) : f.type === 6 && (g = new sO(l, this, e)), this._$AV.push(g), f = o[++u];
        }
        d !== f?.index && (l = vi.nextNode(), d++);
      }
      return vi.currentNode = Ei, a;
    }
    v(e) {
      let t = 0;
      for (const i of this._$AV) i !== void 0 && (i.strings !== void 0 ? (i._$AI(e, i, t), t += i.strings.length - 2) : i._$AI(e[t])), t++;
    }
  }
  class Jn {
    constructor(e, t, i, o) {
      var a;
      this.type = 2, this._$AH = Le, this._$AN = void 0, this._$AA = e, this._$AB = t, this._$AM = i, this.options = o, this._$Cp = (a = o?.isConnected) === null || a === void 0 || a;
    }
    get _$AU() {
      var e, t;
      return (t = (e = this._$AM) === null || e === void 0 ? void 0 : e._$AU) !== null && t !== void 0 ? t : this._$Cp;
    }
    get parentNode() {
      let e = this._$AA.parentNode;
      const t = this._$AM;
      return t !== void 0 && e?.nodeType === 11 && (e = t.parentNode), e;
    }
    get startNode() {
      return this._$AA;
    }
    get endNode() {
      return this._$AB;
    }
    _$AI(e, t = this) {
      e = Mo(this, e, t), qn(e) ? e === Le || e == null || e === "" ? (this._$AH !== Le && this._$AR(), this._$AH = Le) : e !== this._$AH && e !== Io && this._(e) : e._$litType$ !== void 0 ? this.g(e) : e.nodeType !== void 0 ? this.$(e) : QT(e) ? this.T(e) : this._(e);
    }
    k(e) {
      return this._$AA.parentNode.insertBefore(e, this._$AB);
    }
    $(e) {
      this._$AH !== e && (this._$AR(), this._$AH = this.k(e));
    }
    _(e) {
      this._$AH !== Le && qn(this._$AH) ? this._$AA.nextSibling.data = e : this.$(Ei.createTextNode(e)), this._$AH = e;
    }
    g(e) {
      var t;
      const { values: i, _$litType$: o } = e, a = typeof o == "number" ? this._$AC(e) : (o.el === void 0 && (o.el = Yn.createElement(f_(o.h, o.h[0]), this.options)), o);
      if (((t = this._$AH) === null || t === void 0 ? void 0 : t._$AD) === a) this._$AH.v(i);
      else {
        const l = new tO(a, this), d = l.u(this.options);
        l.v(i), this.$(d), this._$AH = l;
      }
    }
    _$AC(e) {
      let t = Ig.get(e.strings);
      return t === void 0 && Ig.set(e.strings, t = new Yn(e)), t;
    }
    T(e) {
      u_(this._$AH) || (this._$AH = [], this._$AR());
      const t = this._$AH;
      let i, o = 0;
      for (const a of e) o === t.length ? t.push(i = new Jn(this.k(Vn()), this.k(Vn()), this, this.options)) : i = t[o], i._$AI(a), o++;
      o < t.length && (this._$AR(i && i._$AB.nextSibling, o), t.length = o);
    }
    _$AR(e = this._$AA.nextSibling, t) {
      var i;
      for ((i = this._$AP) === null || i === void 0 || i.call(this, !1, !0, t); e && e !== this._$AB; ) {
        const o = e.nextSibling;
        e.remove(), e = o;
      }
    }
    setConnected(e) {
      var t;
      this._$AM === void 0 && (this._$Cp = e, (t = this._$AP) === null || t === void 0 || t.call(this, e));
    }
  }
  class Wa {
    constructor(e, t, i, o, a) {
      this.type = 1, this._$AH = Le, this._$AN = void 0, this.element = e, this.name = t, this._$AM = o, this.options = a, i.length > 2 || i[0] !== "" || i[1] !== "" ? (this._$AH = Array(i.length - 1).fill(new String()), this.strings = i) : this._$AH = Le;
    }
    get tagName() {
      return this.element.tagName;
    }
    get _$AU() {
      return this._$AM._$AU;
    }
    _$AI(e, t = this, i, o) {
      const a = this.strings;
      let l = !1;
      if (a === void 0) e = Mo(this, e, t, 0), l = !qn(e) || e !== this._$AH && e !== Io, l && (this._$AH = e);
      else {
        const d = e;
        let u, f;
        for (e = a[0], u = 0; u < a.length - 1; u++) f = Mo(this, d[i + u], t, u), f === Io && (f = this._$AH[u]), l || (l = !qn(f) || f !== this._$AH[u]), f === Le ? e = Le : e !== Le && (e += (f ?? "") + a[u + 1]), this._$AH[u] = f;
      }
      l && !o && this.j(e);
    }
    j(e) {
      e === Le ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, e ?? "");
    }
  }
  class rO extends Wa {
    constructor() {
      super(...arguments), this.type = 3;
    }
    j(e) {
      this.element[this.name] = e === Le ? void 0 : e;
    }
  }
  const iO = Po ? Po.emptyScript : "";
  class oO extends Wa {
    constructor() {
      super(...arguments), this.type = 4;
    }
    j(e) {
      e && e !== Le ? this.element.setAttribute(this.name, iO) : this.element.removeAttribute(this.name);
    }
  }
  class nO extends Wa {
    constructor(e, t, i, o, a) {
      super(e, t, i, o, a), this.type = 5;
    }
    _$AI(e, t = this) {
      var i;
      if ((e = (i = Mo(this, e, t, 0)) !== null && i !== void 0 ? i : Le) === Io) return;
      const o = this._$AH, a = e === Le && o !== Le || e.capture !== o.capture || e.once !== o.once || e.passive !== o.passive, l = e !== Le && (o === Le || a);
      a && this.element.removeEventListener(this.name, this, o), l && this.element.addEventListener(this.name, this, e), this._$AH = e;
    }
    handleEvent(e) {
      var t, i;
      typeof this._$AH == "function" ? this._$AH.call((i = (t = this.options) === null || t === void 0 ? void 0 : t.host) !== null && i !== void 0 ? i : this.element, e) : this._$AH.handleEvent(e);
    }
  }
  class sO {
    constructor(e, t, i) {
      this.element = e, this.type = 6, this._$AN = void 0, this._$AM = t, this.options = i;
    }
    get _$AU() {
      return this._$AM._$AU;
    }
    _$AI(e) {
      Mo(this, e);
    }
  }
  const Mg = $a.litHtmlPolyfillSupport;
  Mg?.(Yn, Jn), ((Hc = $a.litHtmlVersions) !== null && Hc !== void 0 ? Hc : $a.litHtmlVersions = []).push("2.8.0");
  const aO = (r, e, t) => {
    var i, o;
    const a = (i = t?.renderBefore) !== null && i !== void 0 ? i : e;
    let l = a._$litPart$;
    if (l === void 0) {
      const d = (o = t?.renderBefore) !== null && o !== void 0 ? o : null;
      a._$litPart$ = l = new Jn(e.insertBefore(Vn(), d), d, void 0, t ?? {});
    }
    return l._$AI(r), l;
  };
  /**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   */
  var Wc, Bc;
  let ua = class extends io {
    constructor() {
      super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
    }
    createRenderRoot() {
      var e, t;
      const i = super.createRenderRoot();
      return (e = (t = this.renderOptions).renderBefore) !== null && e !== void 0 || (t.renderBefore = i.firstChild), i;
    }
    update(e) {
      const t = this.render();
      this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(e), this._$Do = aO(t, this.renderRoot, this.renderOptions);
    }
    connectedCallback() {
      var e;
      super.connectedCallback(), (e = this._$Do) === null || e === void 0 || e.setConnected(!0);
    }
    disconnectedCallback() {
      var e;
      super.disconnectedCallback(), (e = this._$Do) === null || e === void 0 || e.setConnected(!1);
    }
    render() {
      return Io;
    }
  };
  ua.finalized = !0, ua._$litElement$ = !0, (Wc = globalThis.litElementHydrateSupport) === null || Wc === void 0 || Wc.call(globalThis, { LitElement: ua });
  const Ng = globalThis.litElementPolyfillSupport;
  Ng?.({ LitElement: ua });
  ((Bc = globalThis.litElementVersions) !== null && Bc !== void 0 ? Bc : globalThis.litElementVersions = []).push("3.3.3");
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  const lO = wu`
  [part='clear-button'] {
    display: none;
    cursor: default;
  }

  [part='clear-button']::before {
    content: '✕';
  }

  :host([clear-button-visible][has-value]:not([disabled]):not([readonly])) [part='clear-button'] {
    display: block;
  }
`;
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  const cO = wu`
  :host {
    display: inline-flex;
    outline: none;
  }

  :host::before {
    content: '\\2003';
    width: 0;
    display: inline-block;
    /* Size and position this element on the same vertical position as the input-field element
          to make vertical align for the host element work as expected */
  }

  :host([hidden]) {
    display: none !important;
  }

  :host(:not([has-label])) [part='label'] {
    display: none;
  }
`;
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  const dO = wu`
  [class$='container'] {
    display: flex;
    flex-direction: column;
    min-width: 100%;
    max-width: 100%;
    width: var(--vaadin-field-default-width, 12em);
  }
`;
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  const uO = [cO, dO, lO];
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  class hO {
    /**
     * @param {{ inputElement?: HTMLElement; opened: boolean } & HTMLElement} host
     */
    constructor(e) {
      this.host = e, e.addEventListener("opened-changed", () => {
        e.opened || this.__setVirtualKeyboardEnabled(!1);
      }), e.addEventListener("blur", () => this.__setVirtualKeyboardEnabled(!0)), e.addEventListener("touchstart", () => this.__setVirtualKeyboardEnabled(!0));
    }
    /** @private */
    __setVirtualKeyboardEnabled(e) {
      this.host.inputElement && (this.host.inputElement.inputMode = e ? "" : "none");
    }
  }
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  const fO = (r) => class extends Oi(
    n_(a_(Ha(r)))
  ) {
    static get properties() {
      return {
        /**
         * The current selected date.
         * @type {Date | undefined}
         * @protected
         */
        _selectedDate: {
          type: Date
        },
        /**
         * @type {Date | undefined}
         * @protected
         */
        _focusedDate: Date,
        /**
         * Selected date.
         *
         * Supported date formats:
         * - ISO 8601 `"YYYY-MM-DD"` (default)
         * - 6-digit extended ISO 8601 `"+YYYYYY-MM-DD"`, `"-YYYYYY-MM-DD"`
         *
         * @type {string}
         */
        value: {
          type: String,
          notify: !0,
          value: ""
        },
        /**
         * Date which should be visible when there is no value selected.
         *
         * The same date formats as for the `value` property are supported.
         * @attr {string} initial-position
         */
        initialPosition: String,
        /**
         * Set true to open the date selector overlay.
         */
        opened: {
          type: Boolean,
          reflectToAttribute: !0,
          notify: !0,
          observer: "_openedChanged"
        },
        /**
         * Set true to prevent the overlay from opening automatically.
         * @attr {boolean} auto-open-disabled
         */
        autoOpenDisabled: Boolean,
        /**
         * Set true to display ISO-8601 week numbers in the calendar. Notice that
         * displaying week numbers is only supported when `i18n.firstDayOfWeek`
         * is 1 (Monday).
         * @attr {boolean} show-week-numbers
         */
        showWeekNumbers: {
          type: Boolean
        },
        /**
         * @type {boolean}
         * @protected
         */
        _fullscreen: {
          type: Boolean,
          value: !1
        },
        /**
         * @type {string}
         * @protected
         */
        _fullscreenMediaQuery: {
          value: "(max-width: 420px), (max-height: 420px)"
        },
        /**
         * The object used to localize this component.
         * To change the default localization, replace the entire
         * `i18n` object with a custom one.
         *
         * To update individual properties, extend the existing i18n object like so:
         * ```
         * datePicker.i18n = { ...datePicker.i18n, {
         *   formatDate: date => { ... },
         *   parseDate: value => { ... },
         * }};
         * ```
         *
         * The object has the following JSON structure and default values:
         *
         * ```
         * {
         *   // An array with the full names of months starting
         *   // with January.
         *   monthNames: [
         *     'January', 'February', 'March', 'April', 'May',
         *     'June', 'July', 'August', 'September',
         *     'October', 'November', 'December'
         *   ],
         *
         *   // An array of weekday names starting with Sunday. Used
         *   // in screen reader announcements.
         *   weekdays: [
         *     'Sunday', 'Monday', 'Tuesday', 'Wednesday',
         *     'Thursday', 'Friday', 'Saturday'
         *   ],
         *
         *   // An array of short weekday names starting with Sunday.
         *   // Displayed in the calendar.
         *   weekdaysShort: [
         *     'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'
         *   ],
         *
         *   // An integer indicating the first day of the week
         *   // (0 = Sunday, 1 = Monday, etc.).
         *   firstDayOfWeek: 0,
         *
         *   // Used in screen reader announcements along with week
         *   // numbers, if they are displayed.
         *   week: 'Week',
         *
         *   // Translation of the Calendar icon button title.
         *   calendar: 'Calendar',
         *
         *   // Translation of the Today shortcut button text.
         *   today: 'Today',
         *
         *   // Translation of the Cancel button text.
         *   cancel: 'Cancel',
         *
         *   // Used for adjusting the year value when parsing dates with short years.
         *   // The year values between 0 and 99 are evaluated and adjusted.
         *   // Example: for a referenceDate of 1970-10-30;
         *   //   dateToBeParsed: 40-10-30, result: 1940-10-30
         *   //   dateToBeParsed: 80-10-30, result: 1980-10-30
         *   //   dateToBeParsed: 10-10-30, result: 2010-10-30
         *   // Supported date format: ISO 8601 `"YYYY-MM-DD"` (default)
         *   // The default value is the current date.
         *   referenceDate: '',
         *
         *   // A function to format given `Object` as
         *   // date string. Object is in the format `{ day: ..., month: ..., year: ... }`
         *   // Note: The argument month is 0-based. This means that January = 0 and December = 11.
         *   formatDate: d => {
         *     // returns a string representation of the given
         *     // object in 'MM/DD/YYYY' -format
         *   },
         *
         *   // A function to parse the given text to an `Object` in the format `{ day: ..., month: ..., year: ... }`.
         *   // Must properly parse (at least) text formatted by `formatDate`.
         *   // Setting the property to null will disable keyboard input feature.
         *   // Note: The argument month is 0-based. This means that January = 0 and December = 11.
         *   parseDate: text => {
         *     // Parses a string in 'MM/DD/YY', 'MM/DD' or 'DD' -format to
         *     // an `Object` in the format `{ day: ..., month: ..., year: ... }`.
         *   }
         *
         *   // A function to format given `monthName` and
         *   // `fullYear` integer as calendar title string.
         *   formatTitle: (monthName, fullYear) => {
         *     return monthName + ' ' + fullYear;
         *   }
         * }
         * ```
         *
         * @type {!DatePickerI18n}
         * @default {English/US}
         */
        i18n: {
          type: Object,
          value: () => ({
            monthNames: [
              "January",
              "February",
              "March",
              "April",
              "May",
              "June",
              "July",
              "August",
              "September",
              "October",
              "November",
              "December"
            ],
            weekdays: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
            weekdaysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            firstDayOfWeek: 0,
            week: "Week",
            calendar: "Calendar",
            today: "Today",
            cancel: "Cancel",
            referenceDate: "",
            formatDate(t) {
              const i = String(t.year).replace(/\d+/, (o) => "0000".substr(o.length) + o);
              return [t.month + 1, t.day, i].join("/");
            },
            parseDate(t) {
              const i = t.split("/"), o = /* @__PURE__ */ new Date();
              let a, l = o.getMonth(), d = o.getFullYear();
              if (i.length === 3) {
                if (l = parseInt(i[0]) - 1, a = parseInt(i[1]), d = parseInt(i[2]), i[2].length < 3 && d >= 0) {
                  const u = this.referenceDate ? gn(this.referenceDate) : /* @__PURE__ */ new Date();
                  d = MT(u, d, l, a);
                }
              } else i.length === 2 ? (l = parseInt(i[0]) - 1, a = parseInt(i[1])) : i.length === 1 && (a = parseInt(i[0]));
              if (a !== void 0)
                return { day: a, month: l, year: d };
            },
            formatTitle: (t, i) => `${t} ${i}`
          })
        },
        /**
         * The earliest date that can be selected. All earlier dates will be disabled.
         *
         * Supported date formats:
         * - ISO 8601 `"YYYY-MM-DD"` (default)
         * - 6-digit extended ISO 8601 `"+YYYYYY-MM-DD"`, `"-YYYYYY-MM-DD"`
         *
         * @type {string | undefined}
         */
        min: {
          type: String
        },
        /**
         * The latest date that can be selected. All later dates will be disabled.
         *
         * Supported date formats:
         * - ISO 8601 `"YYYY-MM-DD"` (default)
         * - 6-digit extended ISO 8601 `"+YYYYYY-MM-DD"`, `"-YYYYYY-MM-DD"`
         *
         * @type {string | undefined}
         */
        max: {
          type: String
        },
        /**
         * The earliest date that can be selected. All earlier dates will be disabled.
         * @type {Date | undefined}
         * @protected
         */
        _minDate: {
          type: Date,
          computed: "__computeMinOrMaxDate(min)"
        },
        /**
         * The latest date that can be selected. All later dates will be disabled.
         * @type {Date | undefined}
         * @protected
         */
        _maxDate: {
          type: Date,
          computed: "__computeMinOrMaxDate(max)"
        },
        /** @private */
        _noInput: {
          type: Boolean,
          computed: "_isNoInput(inputElement, _fullscreen, _ios, i18n, opened, autoOpenDisabled)"
        },
        /** @private */
        _ios: {
          type: Boolean,
          value: Ib
        },
        /** @private */
        _focusOverlayOnOpen: Boolean,
        /** @protected */
        _overlayInitialized: Boolean
      };
    }
    static get observers() {
      return [
        "_selectedDateChanged(_selectedDate, i18n.formatDate)",
        "_focusedDateChanged(_focusedDate, i18n.formatDate)"
      ];
    }
    static get constraints() {
      return [...super.constraints, "min", "max"];
    }
    /**
     * Override a getter from `InputControlMixin` to make it optional
     * and to prevent warning when a clear button is missing,
     * for example when using <vaadin-date-picker-light>.
     * @protected
     * @return {Element | null | undefined}
     */
    get clearElement() {
      return null;
    }
    /** @protected */
    get _inputValue() {
      return this.inputElement ? this.inputElement.value : void 0;
    }
    /** @protected */
    set _inputValue(t) {
      this.inputElement && (this.inputElement.value = t);
    }
    /** @private */
    get _nativeInput() {
      return this.inputElement ? this.inputElement.focusElement || this.inputElement : null;
    }
    constructor() {
      super(), this._boundOnClick = this._onClick.bind(this), this._boundOnScroll = this._onScroll.bind(this);
    }
    /**
     * Override an event listener from `DelegateFocusMixin`
     * @protected
     */
    _onFocus(t) {
      super._onFocus(t), this._noInput && t.target.blur();
    }
    /**
     * Override an event listener from `DelegateFocusMixin`
     * @protected
     */
    _onBlur(t) {
      super._onBlur(t), this.opened || (this.autoOpenDisabled && this._selectParsedOrFocusedDate(), this.validate(), this._inputValue === "" && this.value !== "" && (this.value = ""));
    }
    /** @protected */
    ready() {
      super.ready(), this.addEventListener("click", this._boundOnClick), this.addController(
        new o_(this._fullscreenMediaQuery, (t) => {
          this._fullscreen = t;
        })
      ), this.addController(new hO(this));
    }
    /** @protected */
    disconnectedCallback() {
      super.disconnectedCallback(), this.opened = !1;
    }
    /**
     * Override Polymer lifecycle callback to dispatch `change` event if needed.
     * This is necessary to ensure `change` is fired after `value-changed`.
     *
     * @param {!Object} currentProps Current accessor values
     * @param {?Object} changedProps Properties changed since the last call
     * @param {?Object} oldProps Previous values for each changed property
     * @protected
     * @override
     */
    _propertiesChanged(t, i, o) {
      super._propertiesChanged(t, i, o), "value" in i && this.__dispatchChange && (this.dispatchEvent(new CustomEvent("change", { bubbles: !0 })), this.__dispatchChange = !1);
    }
    /**
     * Opens the dropdown.
     */
    open() {
      !this.disabled && !this.readonly && (this.opened = !0);
    }
    /**
     * Closes the dropdown.
     */
    close() {
      (this._overlayInitialized || this.autoOpenDisabled) && this.$.overlay.close();
    }
    /** @protected */
    _initOverlay() {
      this.$.overlay.removeAttribute("disable-upgrade"), this._overlayInitialized = !0, this.$.overlay.addEventListener("opened-changed", (t) => {
        this.opened = t.detail.value;
      }), this.$.overlay.addEventListener("vaadin-overlay-escape-press", () => {
        this._focusedDate = this._selectedDate, this._close();
      }), this._overlayContent.addEventListener("close", () => {
        this._close();
      }), this._overlayContent.addEventListener("focus-input", this._focusAndSelect.bind(this)), this._overlayContent.addEventListener("date-tap", (t) => {
        this.__userConfirmedDate = !0, this._selectDate(t.detail.date), this._close();
      }), this._overlayContent.addEventListener("date-selected", (t) => {
        this.__userConfirmedDate = !!t.detail.date, this._selectDate(t.detail.date);
      }), this._overlayContent.addEventListener("focusin", () => {
        this._keyboardActive && this._setFocused(!0);
      }), this._overlayContent.addEventListener("click", (t) => t.stopPropagation()), this.addEventListener("mousedown", () => this.__bringToFront()), this.addEventListener("touchstart", () => this.__bringToFront());
    }
    /**
     * Returns true if the current input value satisfies all constraints (if any)
     *
     * Override the `checkValidity` method for custom validations.
     *
     * @return {boolean} True if the value is valid
     */
    checkValidity() {
      const t = !this._inputValue || !!this._selectedDate && this._inputValue === this._getFormattedDate(this.i18n.formatDate, this._selectedDate), i = !this._selectedDate || En(this._selectedDate, this._minDate, this._maxDate);
      let o = !0;
      return this.inputElement && (this.inputElement.checkValidity ? o = this.inputElement.checkValidity() : this.inputElement.validate && (o = this.inputElement.validate())), t && i && o;
    }
    /**
     * Override method inherited from `FocusMixin`
     * to not call `_setFocused(true)` when focus
     * is restored after closing overlay on click,
     * and to avoid removing `focus-ring` attribute.
     *
     * @param {!FocusEvent} _event
     * @return {boolean}
     * @protected
     * @override
     */
    _shouldSetFocus(t) {
      return !this._shouldKeepFocusRing;
    }
    /**
     * Override method inherited from `FocusMixin`
     * to prevent removing the `focused` attribute:
     * - when moving focus to the overlay content,
     * - when closing on date click / outside click.
     *
     * @param {!FocusEvent} _event
     * @return {boolean}
     * @protected
     * @override
     */
    _shouldRemoveFocus(t) {
      return !this.opened;
    }
    /**
     * Override method inherited from `FocusMixin`
     * to store the `focus-ring` state to restore
     * it later when closing on outside click.
     *
     * @param {boolean} focused
     * @protected
     * @override
     */
    _setFocused(t) {
      super._setFocused(t), this._shouldKeepFocusRing = t && this._keyboardActive;
    }
    /**
     * Select date on user interaction and set the flag
     * to fire change event if necessary.
     *
     * @param {Date} dateToSelect
     * @protected
     */
    _selectDate(t) {
      const i = this._formatISO(t);
      this.value !== i && (this.__dispatchChange = !0), this._selectedDate = t;
    }
    /** @private */
    _close() {
      this._focus(), this.close();
    }
    /** @private */
    __bringToFront() {
      requestAnimationFrame(() => {
        this.$.overlay.bringToFront();
      });
    }
    /** @private */
    // eslint-disable-next-line max-params
    _isNoInput(t, i, o, a, l, d) {
      return !t || i && (!d || l) || o && l || !a.parseDate;
    }
    /** @private */
    _formatISO(t) {
      if (!(t instanceof Date))
        return "";
      const i = (g, _ = "00") => (_ + g).substr((_ + g).length - _.length);
      let o = "", a = "0000", l = t.getFullYear();
      l < 0 ? (l = -l, o = "-", a = "000000") : t.getFullYear() >= 1e4 && (o = "+", a = "000000");
      const d = o + i(l, a), u = i(t.getMonth() + 1), f = i(t.getDate());
      return [d, u, f].join("-");
    }
    /** @protected */
    _inputElementChanged(t) {
      super._inputElementChanged(t), t && (t.autocomplete = "off", t.setAttribute("role", "combobox"), t.setAttribute("aria-haspopup", "dialog"), t.setAttribute("aria-expanded", !!this.opened), this._applyInputValue(this._selectedDate));
    }
    /** @protected */
    _openedChanged(t) {
      t && !this._overlayInitialized && this._initOverlay(), this._overlayInitialized && (this.$.overlay.opened = t), this.inputElement && this.inputElement.setAttribute("aria-expanded", t);
    }
    /** @private */
    _selectedDateChanged(t, i) {
      if (t === void 0 || i === void 0)
        return;
      const o = this._formatISO(t);
      this.__keepInputValue || this._applyInputValue(t), o !== this.value && (this.validate(), this.value = o), this._ignoreFocusedDateChange = !0, this._focusedDate = t, this._ignoreFocusedDateChange = !1;
    }
    /** @private */
    _focusedDateChanged(t, i) {
      t === void 0 || i === void 0 || !this._ignoreFocusedDateChange && !this._noInput && this._applyInputValue(t);
    }
    /** @private */
    __getOverlayTheme(t, i) {
      if (i)
        return t;
    }
    /**
     * Override the value observer from `InputMixin` to implement custom
     * handling of the `value` property. The date-picker doesn't forward
     * the value directly to the input like the default implementation of `InputMixin`.
     * Instead, it parses the value into a date, puts it in `_selectedDate` which
     * is then displayed in the input with respect to the specified date format.
     *
     * @param {string | undefined} value
     * @param {string | undefined} oldValue
     * @protected
     * @override
     */
    _valueChanged(t, i) {
      const o = gn(t);
      if (t && !o) {
        this.value = i;
        return;
      }
      t ? kr(this._selectedDate, o) || (this._selectedDate = o, i !== void 0 && this.validate()) : this._selectedDate = null, this._toggleHasValue(this._hasValue);
    }
    /** @protected */
    _onOverlayOpened() {
      const t = gn(this.initialPosition), i = this._selectedDate || this._overlayContent.initialPosition || t || /* @__PURE__ */ new Date();
      t || En(i, this._minDate, this._maxDate) ? this._overlayContent.initialPosition = i : this._overlayContent.initialPosition = r_(i, [this._minDate, this._maxDate]), this._overlayContent.scrollToDate(this._overlayContent.focusedDate || this._overlayContent.initialPosition), this._ignoreFocusedDateChange = !0, this._overlayContent.focusedDate = this._overlayContent.focusedDate || this._overlayContent.initialPosition, this._ignoreFocusedDateChange = !1, window.addEventListener("scroll", this._boundOnScroll, !0), this._focusOverlayOnOpen ? (this._overlayContent.focusDateElement(), this._focusOverlayOnOpen = !1) : this._focus(), this._noInput && this.focusElement && (this.focusElement.blur(), this._overlayContent.focusDateElement());
    }
    /** @private */
    _selectParsedOrFocusedDate() {
      if (this._ignoreFocusedDateChange = !0, this.i18n.parseDate) {
        const t = this._inputValue || "", i = this._getParsedDate(t);
        this._isValidDate(i) ? this._selectDate(i) : (this.__keepInputValue = !0, this._selectDate(null), this._selectedDate = null, this.__keepInputValue = !1);
      } else this._focusedDate && this._selectDate(this._focusedDate);
      this._ignoreFocusedDateChange = !1;
    }
    /** @protected */
    _onOverlayClosed() {
      window.removeEventListener("scroll", this._boundOnScroll, !0), this.__userConfirmedDate ? this.__userConfirmedDate = !1 : this._selectParsedOrFocusedDate(), this._nativeInput && this._nativeInput.selectionStart && (this._nativeInput.selectionStart = this._nativeInput.selectionEnd), this.value || this.validate();
    }
    /** @private */
    _onScroll(t) {
      (t.target === window || !this._overlayContent.contains(t.target)) && this._overlayContent._repositionYearScroller();
    }
    /** @protected */
    _focus() {
      this._noInput || this.inputElement.focus();
    }
    /** @private */
    _focusAndSelect() {
      this._focus(), this._setSelectionRange(0, this._inputValue.length);
    }
    /** @private */
    _applyInputValue(t) {
      this._inputValue = t ? this._getFormattedDate(this.i18n.formatDate, t) : "";
    }
    /** @private */
    _getFormattedDate(t, i) {
      return t(i_(i));
    }
    /** @private */
    _setSelectionRange(t, i) {
      this._nativeInput && this._nativeInput.setSelectionRange && this._nativeInput.setSelectionRange(t, i);
    }
    /** @private */
    _isValidDate(t) {
      return t && !isNaN(t.getTime());
    }
    /**
     * Override an event listener from `InputConstraintsMixin`
     * to have date-picker fully control when to fire a change event.
     * @protected
     */
    _onChange(t) {
      this._inputValue === "" && (this.__dispatchChange = !0), t.stopPropagation();
    }
    /**
     * @param {Event} event
     * @private
     */
    _onClick(t) {
      this._isClearButton(t) || this._onHostClick(t);
    }
    /**
     * @param {Event} event
     * @private
     */
    _onHostClick(t) {
      (!this.autoOpenDisabled || this._noInput) && (t.preventDefault(), this.open());
    }
    /**
     * Override an event listener from `InputControlMixin`
     * to validate and dispatch change on clear.
     * @protected
     */
    _onClearButtonClick(t) {
      t.preventDefault(), this.value = "", this._inputValue = "", this.validate(), this.dispatchEvent(new CustomEvent("change", { bubbles: !0 }));
    }
    /**
     * Override an event listener from `KeyboardMixin`.
     * @param {KeyboardEvent} e
     * @protected
     * @override
     */
    _onKeyDown(t) {
      switch (super._onKeyDown(t), this._noInput && [
        9
        // Tab
      ].indexOf(t.keyCode) === -1 && t.preventDefault(), t.key) {
        case "ArrowDown":
        case "ArrowUp":
          t.preventDefault(), this.opened ? this._overlayContent.focusDateElement() : (this._focusOverlayOnOpen = !0, this.open());
          break;
        case "Tab":
          this.opened && (t.preventDefault(), t.stopPropagation(), this._setSelectionRange(0, 0), t.shiftKey ? this._overlayContent.focusCancel() : this._overlayContent.focusDateElement());
          break;
      }
    }
    /**
     * Override an event listener from `KeyboardMixin`.
     *
     * @param {!KeyboardEvent} _event
     * @protected
     * @override
     */
    _onEnter(t) {
      const i = this.value;
      this.opened ? this.close() : this._selectParsedOrFocusedDate(), i === this.value && this.validate();
    }
    /**
     * Override an event listener from `KeyboardMixin`.
     * Do not call `super` in order to override clear
     * button logic defined in `InputControlMixin`.
     *
     * @param {!KeyboardEvent} event
     * @protected
     * @override
     */
    _onEscape(t) {
      if (!this.opened) {
        if (this.clearButtonVisible && this.value) {
          t.stopPropagation(), this._onClearButtonClick(t);
          return;
        }
        this.autoOpenDisabled ? (this.inputElement.value === "" && this._selectDate(null), this._applyInputValue(this._selectedDate)) : (this._focusedDate = this._selectedDate, this._selectParsedOrFocusedDate());
      }
    }
    /** @private */
    _getParsedDate(t = this._inputValue) {
      const i = this.i18n.parseDate && this.i18n.parseDate(t);
      return i && gn(`${i.year}-${i.month + 1}-${i.day}`);
    }
    /** @protected */
    _isClearButton(t) {
      return t.composedPath()[0] === this.clearElement;
    }
    /**
     * Override an event listener from `InputMixin`
     * @protected
     */
    _onInput() {
      !this.opened && this.inputElement.value && !this.autoOpenDisabled && this.open(), this._userInputValueChanged();
    }
    /** @private */
    _userInputValueChanged() {
      if (this._inputValue) {
        const t = this._getParsedDate();
        this._isValidDate(t) && (this._ignoreFocusedDateChange = !0, kr(t, this._focusedDate) || (this._focusedDate = t), this._ignoreFocusedDateChange = !1);
      }
    }
    /** @private */
    get _overlayContent() {
      return this.$.overlay.content.querySelector("#overlay-content");
    }
    /** @private */
    __computeMinOrMaxDate(t) {
      return gn(t);
    }
    /**
     * Fired when the user commits a value change.
     *
     * @event change
     */
    /**
     * Fired when `value` property value changes.
     *
     * @event value-changed
     */
    /**
     * Fired when `opened` property value changes.
     *
     * @event opened-changed
     */
  };
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  Te("vaadin-date-picker", [uO, AT], { moduleId: "vaadin-date-picker-styles" });
  class Lg extends fO(YT(Kr(fu(Gt)))) {
    static get is() {
      return "vaadin-date-picker";
    }
    static get template() {
      return Ar`
      <style>
        :host([opened]) {
          pointer-events: auto;
        }
      </style>

      <div class="vaadin-date-picker-container">
        <div part="label">
          <slot name="label"></slot>
          <span part="required-indicator" aria-hidden="true" on-click="focus"></span>
        </div>

        <vaadin-input-container
          part="input-field"
          readonly="[[readonly]]"
          disabled="[[disabled]]"
          invalid="[[invalid]]"
          theme$="[[_theme]]"
        >
          <slot name="prefix" slot="prefix"></slot>
          <slot name="input"></slot>
          <div id="clearButton" part="clear-button" slot="suffix" aria-hidden="true"></div>
          <div part="toggle-button" slot="suffix" aria-hidden="true" on-click="_toggle"></div>
        </vaadin-input-container>

        <div part="helper-text">
          <slot name="helper"></slot>
        </div>

        <div part="error-message">
          <slot name="error-message"></slot>
        </div>
      </div>

      <vaadin-date-picker-overlay
        id="overlay"
        fullscreen$="[[_fullscreen]]"
        theme$="[[__getOverlayTheme(_theme, _overlayInitialized)]]"
        on-vaadin-overlay-open="_onOverlayOpened"
        on-vaadin-overlay-closing="_onOverlayClosed"
        restore-focus-on-close
        restore-focus-node="[[inputElement]]"
        disable-upgrade
      >
        <template>
          <vaadin-date-picker-overlay-content
            id="overlay-content"
            i18n="[[i18n]]"
            fullscreen$="[[_fullscreen]]"
            label="[[label]]"
            selected-date="[[_selectedDate]]"
            focused-date="{{_focusedDate}}"
            show-week-numbers="[[showWeekNumbers]]"
            min-date="[[_minDate]]"
            max-date="[[_maxDate]]"
            part="overlay-content"
            theme$="[[__getOverlayTheme(_theme, _overlayInitialized)]]"
          ></vaadin-date-picker-overlay-content>
        </template>
      </vaadin-date-picker-overlay>

      <slot name="tooltip"></slot>
    `;
    }
    /**
     * Used by `InputControlMixin` as a reference to the clear button element.
     * @protected
     * @return {!HTMLElement}
     */
    get clearElement() {
      return this.$.clearButton;
    }
    /** @protected */
    ready() {
      super.ready(), this.addController(
        new GT(this, (t) => {
          this._setInputElement(t), this._setFocusElement(t), this.stateTarget = t, this.ariaTarget = t;
        })
      ), this.addController(new jT(this.inputElement, this._labelController)), this._tooltipController = new pu(this), this.addController(this._tooltipController), this._tooltipController.setPosition("top"), this._tooltipController.setShouldShow((t) => !t.opened), this.shadowRoot.querySelector('[part="toggle-button"]').addEventListener("mousedown", (t) => t.preventDefault());
    }
    /** @protected */
    _initOverlay() {
      super._initOverlay(), this.$.overlay.addEventListener("vaadin-overlay-close", this._onVaadinOverlayClose.bind(this));
    }
    /** @private */
    _onVaadinOverlayClose(e) {
      e.detail.sourceEvent && e.detail.sourceEvent.composedPath().includes(this) && e.preventDefault();
    }
    /** @private */
    _toggle(e) {
      e.stopPropagation(), this[this._overlayInitialized && this.$.overlay.opened ? "close" : "open"]();
    }
    // Workaround https://github.com/vaadin/web-components/issues/2855
    /** @protected */
    _openedChanged(e) {
      super._openedChanged(e), this.$.overlay.positionTarget = this.shadowRoot.querySelector('[part="input-field"]'), this.$.overlay.noVerticalOverlap = !0;
    }
  }
  customElements.define(Lg.is, Lg);
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  const pO = ".col-bg-body-lighter{background-color:var(--col-bg-body-lighter)}.col-bg-body{background-color:var(--col-bg-body)}.col-bg-body-darker{background-color:var(--col-bg-body-darker)}.col-bg-1-lighter{background-color:var(--col-bg-1-lighter)}.col-bg-1{background-color:var(--col-bg-1)}.col-bg-1-darker{background-color:var(--col-bg-1-darker)}.col-bg-1-input{background-color:var(--col-bg-1-input)}.col-primary-bg-1{background-color:var(--col-primary-bg-1)}.col-accent-bg-1{background-color:var(--col-accent-bg-1)}.col-success-bg-1{background-color:var(--col-success-bg-1)}.col-warning-bg-1{background-color:var(--col-warning-bg-1)}.col-error-bg-1{background-color:var(--col-error-bg-1)}.col-bg-2-lighter{background-color:var(--col-bg-2-lighter)}.col-bg-2{background-color:var(--col-bg-2)}.col-bg-2-darker{background-color:var(--col-bg-2-darker)}.col-bg-2-button{background-color:var(--col-bg-2-button)}.col-bg-2-input{background-color:var(--col-bg-2-input)}.col-primary-bg-2{background-color:var(--col-primary-bg-2)}.col-accent-bg-2{background-color:var(--col-accent-bg-2)}.col-success-bg-2{background-color:var(--col-success-bg-2)}.col-warning-bg-2{background-color:var(--col-warning-bg-2)}.col-error-bg-2{background-color:var(--col-error-bg-2)}.col-bg-3-lighter{background-color:var(--col-bg-3-lighter)}.col-bg-3{background-color:var(--col-bg-3)}.col-bg-3-darker{background-color:var(--col-bg-3-darker)}.col-bg-3-button{background-color:var(--col-bg-3-button)}.col-bg-3-input{background-color:var(--col-bg-3-input)}.col-primary-bg-3{background-color:var(--col-primary-bg-3)}.col-accent-bg-3{background-color:var(--col-accent-bg-3)}.col-success-bg-3{background-color:var(--col-success-bg-3)}.col-warning-bg-3{background-color:var(--col-warning-bg-3)}.col-error-bg-3{background-color:var(--col-error-bg-3)}.col-bg-ack-lighter{background-color:var(--col-bg-ack-lighter)}.col-bg-ack{background-color:var(--col-bg-ack)}.col-bg-ack-darker{background-color:var(--col-bg-ack-darker)}.col-primary-bg-ack{background-color:var(--col-primary-bg-ack)}.col-accent-bg-ack{background-color:var(--col-accent-bg-ack)}.col-bg-att-lighter{background-color:var(--col-bg-att-lighter)}.col-bg-att{background-color:var(--col-bg-att)}.col-bg-att-darker{background-color:var(--col-bg-att-darker)}.col-primary-bg-att{background-color:var(--col-primary-bg-att)}.col-accent-bg-att{background-color:var(--col-accent-bg-att)}.col-bg-alert-lighter{background-color:var(--col-bg-alert-lighter)}.col-bg-alert{background-color:var(--col-bg-alert)}.col-bg-alert-darker{background-color:var(--col-bg-alert-darker)}.col-primary-bg-alert{background-color:var(--col-primary-bg-alert)}.col-accent-bg-alert{background-color:var(--col-accent-bg-alert)}.col-bg-btn-lighter{background-color:var(--col-bg-btn-lighter)}.col-bg-btn{background-color:var(--col-bg-btn)}.col-bg-btn-darker{background-color:var(--col-bg-btn-darker)}.col-primary-bg-btn{background-color:var(--col-primary-bg-btn)}.col-accent-bg-btn{background-color:var(--col-accent-bg-btn)}.pattern-diagonal-stripes-sm{background:repeating-linear-gradient(45deg,transparent,transparent 10px,currentColor 10px,currentColor 20px)}.pattern-dots-lg{background-image:radial-gradient(currentColor 1.5px,transparent 1.5px);background-size:15px 15px}.pattern-dots-md{background-image:radial-gradient(currentColor 1px,transparent 1px);background-size:8px 8px}.pattern-dots-medium-dense{background-image:radial-gradient(currentColor .5px,transparent .5px);background-size:3px 3px}.pattern-dots-sm{background-image:radial-gradient(currentColor .5px,transparent .5px);background-size:5px 5px}.pattern-cross-dots-md,.imagelist-background{background-image:radial-gradient(currentColor .7px,transparent 1px),radial-gradient(currentColor .7px,transparent 1px);background-size:6.5px 6.5px;background-position:0 0,3.5px 3.5px}.imagelist-background{background-color:#fff9;background-blend-mode:overlay}p,div{padding:0;margin:0;border:0px;user-select:text;-webkit-user-select:text}select{user-select:none;-webkit-user-select:none}:host{display:block}div,p{font-family:var(--standard-text-font);-webkit-user-select:none;user-select:none}.date-selector{width:100%;background-color:var(--col-bg-1);display:flex;flex-direction:row;align-items:center;justify-content:center}.date-selector-date{padding:0 .5em 6px;cursor:pointer;color:var(--col-primary-bg-1);--lumo-body-text-color: $col-accent-bg-1}.date-selector-date-inactive{margin:0 .2em;cursor:pointer;color:var(--col-primary-bg-1);height:2em;line-height:2em;vertical-align:middle;--lumo-body-text-color: $col-accent-bg-1}.date-selector-date-inactive span{display:inline-block;width:2em;text-align:center}.selected-date{background-color:var(--col-bg-2);color:var(--col-accent-bg-1);font-weight:700;font-size:1.2em}vaadin-date-picker::part(clear-button){display:none}.date-navigation{display:flex;flex-direction:row;flex-wrap:wrap;margin:0 1em}.date-navigation:first-child{margin:0 1em 0 3.5em}.date-navigation i{font-size:15px}.date-navigation button{background-color:var(--col-bg-2);color:var(--col-primary-bg-2);height:35px;width:35px}.date-navigation button:hover,.date-navigation button:focus{background-color:var(--col-bg-ack-lighter);color:var(--col-primary-bg-ack);border:solid 2px var(--col-bg-ack-lighter)}.active-day{color:var(--col-accent-bg-2);border:1px solid var(--col-accent-bg-2);border-radius:25px;padding-left:0;padding-right:0}.active-day:hover,.active-day:focus{background-color:var(--col-bg-2-lighter)}";
  var gO = Object.defineProperty, mO = (r, e, t, i) => {
    for (var o = void 0, a = r.length - 1, l; a >= 0; a--)
      (l = r[a]) && (o = l(e, t, o) || o);
    return o && gO(e, t, o), o;
  };
  const Fu = class Fu extends Nm(je)(so) {
    constructor() {
      super(), this.kiosk_base_url = "/", this.showProgress = !1, this.apiContext = void 0;
    }
    updated(e) {
      e.has("apiContext") && (this.showProgress = !1);
    }
    render() {
      let e;
      return this.apiContext && this.apiContext.status === Mm ? e = this.apiRender() : this.apiContext && this.apiContext.status === ed ? e = this.renderApiError() : e = this.renderNoContextYet(), S`
            <link rel="stylesheet" href="${this.kiosk_base_url}static/styles.css" />
            ${e}
        `;
    }
    renderNoContextYet() {
      return S` <link rel="stylesheet" href="${this.kiosk_base_url}static/styles.css" /> `;
    }
    renderApiError() {
    }
    renderProgress(e = !1) {
      if (e || this.showProgress)
        return S` <div class="loading">
                <div class="loading-progress"></div>
            </div>`;
    }
  };
  Fu.properties = {
    /**
     * The Api Context
     */
    apiContext: { type: Object }
  };
  let Re = Fu;
  mO([
    Jd()
  ], Re.prototype, "showProgress");
  class Pi extends Error {
  }
  class bO extends Pi {
    constructor(e) {
      super(`Invalid DateTime: ${e.toMessage()}`);
    }
  }
  class _O extends Pi {
    constructor(e) {
      super(`Invalid Interval: ${e.toMessage()}`);
    }
  }
  class vO extends Pi {
    constructor(e) {
      super(`Invalid Duration: ${e.toMessage()}`);
    }
  }
  class oo extends Pi {
  }
  class p_ extends Pi {
    constructor(e) {
      super(`Invalid unit ${e}`);
    }
  }
  class qe extends Pi {
  }
  class Ur extends Pi {
    constructor() {
      super("Zone is an abstract class");
    }
  }
  const N = "numeric", jt = "short", xt = "long", Ta = {
    year: N,
    month: N,
    day: N
  }, g_ = {
    year: N,
    month: jt,
    day: N
  }, yO = {
    year: N,
    month: jt,
    day: N,
    weekday: jt
  }, m_ = {
    year: N,
    month: xt,
    day: N
  }, b_ = {
    year: N,
    month: xt,
    day: N,
    weekday: xt
  }, __ = {
    hour: N,
    minute: N
  }, v_ = {
    hour: N,
    minute: N,
    second: N
  }, y_ = {
    hour: N,
    minute: N,
    second: N,
    timeZoneName: jt
  }, w_ = {
    hour: N,
    minute: N,
    second: N,
    timeZoneName: xt
  }, k_ = {
    hour: N,
    minute: N,
    hourCycle: "h23"
  }, x_ = {
    hour: N,
    minute: N,
    second: N,
    hourCycle: "h23"
  }, C_ = {
    hour: N,
    minute: N,
    second: N,
    hourCycle: "h23",
    timeZoneName: jt
  }, S_ = {
    hour: N,
    minute: N,
    second: N,
    hourCycle: "h23",
    timeZoneName: xt
  }, A_ = {
    year: N,
    month: N,
    day: N,
    hour: N,
    minute: N
  }, E_ = {
    year: N,
    month: N,
    day: N,
    hour: N,
    minute: N,
    second: N
  }, $_ = {
    year: N,
    month: jt,
    day: N,
    hour: N,
    minute: N
  }, T_ = {
    year: N,
    month: jt,
    day: N,
    hour: N,
    minute: N,
    second: N
  }, wO = {
    year: N,
    month: jt,
    day: N,
    weekday: jt,
    hour: N,
    minute: N
  }, O_ = {
    year: N,
    month: xt,
    day: N,
    hour: N,
    minute: N,
    timeZoneName: jt
  }, D_ = {
    year: N,
    month: xt,
    day: N,
    hour: N,
    minute: N,
    second: N,
    timeZoneName: jt
  }, P_ = {
    year: N,
    month: xt,
    day: N,
    weekday: xt,
    hour: N,
    minute: N,
    timeZoneName: xt
  }, I_ = {
    year: N,
    month: xt,
    day: N,
    weekday: xt,
    hour: N,
    minute: N,
    second: N,
    timeZoneName: xt
  };
  class Xn {
    /**
     * The type of zone
     * @abstract
     * @type {string}
     */
    get type() {
      throw new Ur();
    }
    /**
     * The name of this zone.
     * @abstract
     * @type {string}
     */
    get name() {
      throw new Ur();
    }
    /**
     * The IANA name of this zone.
     * Defaults to `name` if not overwritten by a subclass.
     * @abstract
     * @type {string}
     */
    get ianaName() {
      return this.name;
    }
    /**
     * Returns whether the offset is known to be fixed for the whole year.
     * @abstract
     * @type {boolean}
     */
    get isUniversal() {
      throw new Ur();
    }
    /**
     * Returns the offset's common name (such as EST) at the specified timestamp
     * @abstract
     * @param {number} ts - Epoch milliseconds for which to get the name
     * @param {Object} opts - Options to affect the format
     * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
     * @param {string} opts.locale - What locale to return the offset name in.
     * @return {string}
     */
    offsetName(e, t) {
      throw new Ur();
    }
    /**
     * Returns the offset's value as a string
     * @abstract
     * @param {number} ts - Epoch milliseconds for which to get the offset
     * @param {string} format - What style of offset to return.
     *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
     * @return {string}
     */
    formatOffset(e, t) {
      throw new Ur();
    }
    /**
     * Return the offset in minutes for this zone at the specified timestamp.
     * @abstract
     * @param {number} ts - Epoch milliseconds for which to compute the offset
     * @return {number}
     */
    offset(e) {
      throw new Ur();
    }
    /**
     * Return whether this Zone is equal to another zone
     * @abstract
     * @param {Zone} otherZone - the zone to compare
     * @return {boolean}
     */
    equals(e) {
      throw new Ur();
    }
    /**
     * Return whether this Zone is valid.
     * @abstract
     * @type {boolean}
     */
    get isValid() {
      throw new Ur();
    }
  }
  let Vc = null;
  class Ba extends Xn {
    /**
     * Get a singleton instance of the local zone
     * @return {SystemZone}
     */
    static get instance() {
      return Vc === null && (Vc = new Ba()), Vc;
    }
    /** @override **/
    get type() {
      return "system";
    }
    /** @override **/
    get name() {
      return new Intl.DateTimeFormat().resolvedOptions().timeZone;
    }
    /** @override **/
    get isUniversal() {
      return !1;
    }
    /** @override **/
    offsetName(e, { format: t, locale: i }) {
      return V_(e, t, i);
    }
    /** @override **/
    formatOffset(e, t) {
      return $n(this.offset(e), t);
    }
    /** @override **/
    offset(e) {
      return -new Date(e).getTimezoneOffset();
    }
    /** @override **/
    equals(e) {
      return e.type === "system";
    }
    /** @override **/
    get isValid() {
      return !0;
    }
  }
  const Td = /* @__PURE__ */ new Map();
  function kO(r) {
    let e = Td.get(r);
    return e === void 0 && (e = new Intl.DateTimeFormat("en-US", {
      hour12: !1,
      timeZone: r,
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      era: "short"
    }), Td.set(r, e)), e;
  }
  const xO = {
    year: 0,
    month: 1,
    day: 2,
    era: 3,
    hour: 4,
    minute: 5,
    second: 6
  };
  function CO(r, e) {
    const t = r.format(e).replace(/\u200E/g, ""), i = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(t), [, o, a, l, d, u, f, g] = i;
    return [l, o, a, d, u, f, g];
  }
  function SO(r, e) {
    const t = r.formatToParts(e), i = [];
    for (let o = 0; o < t.length; o++) {
      const { type: a, value: l } = t[o], d = xO[a];
      a === "era" ? i[d] = l : q(d) || (i[d] = parseInt(l, 10));
    }
    return i;
  }
  const qc = /* @__PURE__ */ new Map();
  class Cr extends Xn {
    /**
     * @param {string} name - Zone name
     * @return {IANAZone}
     */
    static create(e) {
      let t = qc.get(e);
      return t === void 0 && qc.set(e, t = new Cr(e)), t;
    }
    /**
     * Reset local caches. Should only be necessary in testing scenarios.
     * @return {void}
     */
    static resetCache() {
      qc.clear(), Td.clear();
    }
    /**
     * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.
     * @param {string} s - The string to check validity on
     * @example IANAZone.isValidSpecifier("America/New_York") //=> true
     * @example IANAZone.isValidSpecifier("Sport~~blorp") //=> false
     * @deprecated For backward compatibility, this forwards to isValidZone, better use `isValidZone()` directly instead.
     * @return {boolean}
     */
    static isValidSpecifier(e) {
      return this.isValidZone(e);
    }
    /**
     * Returns whether the provided string identifies a real zone
     * @param {string} zone - The string to check
     * @example IANAZone.isValidZone("America/New_York") //=> true
     * @example IANAZone.isValidZone("Fantasia/Castle") //=> false
     * @example IANAZone.isValidZone("Sport~~blorp") //=> false
     * @return {boolean}
     */
    static isValidZone(e) {
      if (!e)
        return !1;
      try {
        return new Intl.DateTimeFormat("en-US", { timeZone: e }).format(), !0;
      } catch {
        return !1;
      }
    }
    constructor(e) {
      super(), this.zoneName = e, this.valid = Cr.isValidZone(e);
    }
    /**
     * The type of zone. `iana` for all instances of `IANAZone`.
     * @override
     * @type {string}
     */
    get type() {
      return "iana";
    }
    /**
     * The name of this zone (i.e. the IANA zone name).
     * @override
     * @type {string}
     */
    get name() {
      return this.zoneName;
    }
    /**
     * Returns whether the offset is known to be fixed for the whole year:
     * Always returns false for all IANA zones.
     * @override
     * @type {boolean}
     */
    get isUniversal() {
      return !1;
    }
    /**
     * Returns the offset's common name (such as EST) at the specified timestamp
     * @override
     * @param {number} ts - Epoch milliseconds for which to get the name
     * @param {Object} opts - Options to affect the format
     * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
     * @param {string} opts.locale - What locale to return the offset name in.
     * @return {string}
     */
    offsetName(e, { format: t, locale: i }) {
      return V_(e, t, i, this.name);
    }
    /**
     * Returns the offset's value as a string
     * @override
     * @param {number} ts - Epoch milliseconds for which to get the offset
     * @param {string} format - What style of offset to return.
     *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
     * @return {string}
     */
    formatOffset(e, t) {
      return $n(this.offset(e), t);
    }
    /**
     * Return the offset in minutes for this zone at the specified timestamp.
     * @override
     * @param {number} ts - Epoch milliseconds for which to compute the offset
     * @return {number}
     */
    offset(e) {
      if (!this.valid) return NaN;
      const t = new Date(e);
      if (isNaN(t)) return NaN;
      const i = kO(this.name);
      let [o, a, l, d, u, f, g] = i.formatToParts ? SO(i, t) : CO(i, t);
      d === "BC" && (o = -Math.abs(o) + 1);
      const C = qa({
        year: o,
        month: a,
        day: l,
        hour: u === 24 ? 0 : u,
        minute: f,
        second: g,
        millisecond: 0
      });
      let x = +t;
      const D = x % 1e3;
      return x -= D >= 0 ? D : 1e3 + D, (C - x) / (60 * 1e3);
    }
    /**
     * Return whether this Zone is equal to another zone
     * @override
     * @param {Zone} otherZone - the zone to compare
     * @return {boolean}
     */
    equals(e) {
      return e.type === "iana" && e.name === this.name;
    }
    /**
     * Return whether this Zone is valid.
     * @override
     * @type {boolean}
     */
    get isValid() {
      return this.valid;
    }
  }
  let Rg = {};
  function AO(r, e = {}) {
    const t = JSON.stringify([r, e]);
    let i = Rg[t];
    return i || (i = new Intl.ListFormat(r, e), Rg[t] = i), i;
  }
  const Od = /* @__PURE__ */ new Map();
  function Dd(r, e = {}) {
    const t = JSON.stringify([r, e]);
    let i = Od.get(t);
    return i === void 0 && (i = new Intl.DateTimeFormat(r, e), Od.set(t, i)), i;
  }
  const Pd = /* @__PURE__ */ new Map();
  function EO(r, e = {}) {
    const t = JSON.stringify([r, e]);
    let i = Pd.get(t);
    return i === void 0 && (i = new Intl.NumberFormat(r, e), Pd.set(t, i)), i;
  }
  const Id = /* @__PURE__ */ new Map();
  function $O(r, e = {}) {
    const { base: t, ...i } = e, o = JSON.stringify([r, i]);
    let a = Id.get(o);
    return a === void 0 && (a = new Intl.RelativeTimeFormat(r, e), Id.set(o, a)), a;
  }
  let wn = null;
  function TO() {
    return wn || (wn = new Intl.DateTimeFormat().resolvedOptions().locale, wn);
  }
  const Md = /* @__PURE__ */ new Map();
  function M_(r) {
    let e = Md.get(r);
    return e === void 0 && (e = new Intl.DateTimeFormat(r).resolvedOptions(), Md.set(r, e)), e;
  }
  const Nd = /* @__PURE__ */ new Map();
  function OO(r) {
    let e = Nd.get(r);
    if (!e) {
      const t = new Intl.Locale(r);
      e = "getWeekInfo" in t ? t.getWeekInfo() : t.weekInfo, "minimalDays" in e || (e = { ...N_, ...e }), Nd.set(r, e);
    }
    return e;
  }
  function DO(r) {
    const e = r.indexOf("-x-");
    e !== -1 && (r = r.substring(0, e));
    const t = r.indexOf("-u-");
    if (t === -1)
      return [r];
    {
      let i, o;
      try {
        i = Dd(r).resolvedOptions(), o = r;
      } catch {
        const u = r.substring(0, t);
        i = Dd(u).resolvedOptions(), o = u;
      }
      const { numberingSystem: a, calendar: l } = i;
      return [o, a, l];
    }
  }
  function PO(r, e, t) {
    return (t || e) && (r.includes("-u-") || (r += "-u"), t && (r += `-ca-${t}`), e && (r += `-nu-${e}`)), r;
  }
  function IO(r) {
    const e = [];
    for (let t = 1; t <= 12; t++) {
      const i = z.utc(2009, t, 1);
      e.push(r(i));
    }
    return e;
  }
  function MO(r) {
    const e = [];
    for (let t = 1; t <= 7; t++) {
      const i = z.utc(2016, 11, 13 + t);
      e.push(r(i));
    }
    return e;
  }
  function Qs(r, e, t, i) {
    const o = r.listingMode();
    return o === "error" ? null : o === "en" ? t(e) : i(e);
  }
  function NO(r) {
    return r.numberingSystem && r.numberingSystem !== "latn" ? !1 : r.numberingSystem === "latn" || !r.locale || r.locale.startsWith("en") || M_(r.locale).numberingSystem === "latn";
  }
  class LO {
    constructor(e, t, i) {
      this.padTo = i.padTo || 0, this.floor = i.floor || !1;
      const { padTo: o, floor: a, ...l } = i;
      if (!t || Object.keys(l).length > 0) {
        const d = { useGrouping: !1, ...i };
        i.padTo > 0 && (d.minimumIntegerDigits = i.padTo), this.inf = EO(e, d);
      }
    }
    format(e) {
      if (this.inf) {
        const t = this.floor ? Math.floor(e) : e;
        return this.inf.format(t);
      } else {
        const t = this.floor ? Math.floor(e) : Au(e, 3);
        return $e(t, this.padTo);
      }
    }
  }
  class RO {
    constructor(e, t, i) {
      this.opts = i, this.originalZone = void 0;
      let o;
      if (this.opts.timeZone)
        this.dt = e;
      else if (e.zone.type === "fixed") {
        const l = -1 * (e.offset / 60), d = l >= 0 ? `Etc/GMT+${l}` : `Etc/GMT${l}`;
        e.offset !== 0 && Cr.create(d).valid ? (o = d, this.dt = e) : (o = "UTC", this.dt = e.offset === 0 ? e : e.setZone("UTC").plus({ minutes: e.offset }), this.originalZone = e.zone);
      } else e.zone.type === "system" ? this.dt = e : e.zone.type === "iana" ? (this.dt = e, o = e.zone.name) : (o = "UTC", this.dt = e.setZone("UTC").plus({ minutes: e.offset }), this.originalZone = e.zone);
      const a = { ...this.opts };
      a.timeZone = a.timeZone || o, this.dtf = Dd(t, a);
    }
    format() {
      return this.originalZone ? this.formatToParts().map(({ value: e }) => e).join("") : this.dtf.format(this.dt.toJSDate());
    }
    formatToParts() {
      const e = this.dtf.formatToParts(this.dt.toJSDate());
      return this.originalZone ? e.map((t) => {
        if (t.type === "timeZoneName") {
          const i = this.originalZone.offsetName(this.dt.ts, {
            locale: this.dt.locale,
            format: this.opts.timeZoneName
          });
          return {
            ...t,
            value: i
          };
        } else
          return t;
      }) : e;
    }
    resolvedOptions() {
      return this.dtf.resolvedOptions();
    }
  }
  class FO {
    constructor(e, t, i) {
      this.opts = { style: "long", ...i }, !t && W_() && (this.rtf = $O(e, i));
    }
    format(e, t) {
      return this.rtf ? this.rtf.format(e, t) : sD(t, e, this.opts.numeric, this.opts.style !== "long");
    }
    formatToParts(e, t) {
      return this.rtf ? this.rtf.formatToParts(e, t) : [];
    }
  }
  const N_ = {
    firstDay: 1,
    minimalDays: 4,
    weekend: [6, 7]
  };
  class ce {
    static fromOpts(e) {
      return ce.create(
        e.locale,
        e.numberingSystem,
        e.outputCalendar,
        e.weekSettings,
        e.defaultToEN
      );
    }
    static create(e, t, i, o, a = !1) {
      const l = e || Ce.defaultLocale, d = l || (a ? "en-US" : TO()), u = t || Ce.defaultNumberingSystem, f = i || Ce.defaultOutputCalendar, g = Rd(o) || Ce.defaultWeekSettings;
      return new ce(d, u, f, g, l);
    }
    static resetCache() {
      wn = null, Od.clear(), Pd.clear(), Id.clear(), Md.clear(), Nd.clear();
    }
    static fromObject({ locale: e, numberingSystem: t, outputCalendar: i, weekSettings: o } = {}) {
      return ce.create(e, t, i, o);
    }
    constructor(e, t, i, o, a) {
      const [l, d, u] = DO(e);
      this.locale = l, this.numberingSystem = t || d || null, this.outputCalendar = i || u || null, this.weekSettings = o, this.intl = PO(this.locale, this.numberingSystem, this.outputCalendar), this.weekdaysCache = { format: {}, standalone: {} }, this.monthsCache = { format: {}, standalone: {} }, this.meridiemCache = null, this.eraCache = {}, this.specifiedLocale = a, this.fastNumbersCached = null;
    }
    get fastNumbers() {
      return this.fastNumbersCached == null && (this.fastNumbersCached = NO(this)), this.fastNumbersCached;
    }
    listingMode() {
      const e = this.isEnglish(), t = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
      return e && t ? "en" : "intl";
    }
    clone(e) {
      return !e || Object.getOwnPropertyNames(e).length === 0 ? this : ce.create(
        e.locale || this.specifiedLocale,
        e.numberingSystem || this.numberingSystem,
        e.outputCalendar || this.outputCalendar,
        Rd(e.weekSettings) || this.weekSettings,
        e.defaultToEN || !1
      );
    }
    redefaultToEN(e = {}) {
      return this.clone({ ...e, defaultToEN: !0 });
    }
    redefaultToSystem(e = {}) {
      return this.clone({ ...e, defaultToEN: !1 });
    }
    months(e, t = !1) {
      return Qs(this, e, G_, () => {
        const i = this.intl === "ja" || this.intl.startsWith("ja-");
        t &= !i;
        const o = t ? { month: e, day: "numeric" } : { month: e }, a = t ? "format" : "standalone";
        if (!this.monthsCache[a][e]) {
          const l = i ? (d) => this.dtFormatter(d, o).format() : (d) => this.extract(d, o, "month");
          this.monthsCache[a][e] = IO(l);
        }
        return this.monthsCache[a][e];
      });
    }
    weekdays(e, t = !1) {
      return Qs(this, e, K_, () => {
        const i = t ? { weekday: e, year: "numeric", month: "long", day: "numeric" } : { weekday: e }, o = t ? "format" : "standalone";
        return this.weekdaysCache[o][e] || (this.weekdaysCache[o][e] = MO(
          (a) => this.extract(a, i, "weekday")
        )), this.weekdaysCache[o][e];
      });
    }
    meridiems() {
      return Qs(
        this,
        void 0,
        () => J_,
        () => {
          if (!this.meridiemCache) {
            const e = { hour: "numeric", hourCycle: "h12" };
            this.meridiemCache = [z.utc(2016, 11, 13, 9), z.utc(2016, 11, 13, 19)].map(
              (t) => this.extract(t, e, "dayperiod")
            );
          }
          return this.meridiemCache;
        }
      );
    }
    eras(e) {
      return Qs(this, e, X_, () => {
        const t = { era: e };
        return this.eraCache[e] || (this.eraCache[e] = [z.utc(-40, 1, 1), z.utc(2017, 1, 1)].map(
          (i) => this.extract(i, t, "era")
        )), this.eraCache[e];
      });
    }
    extract(e, t, i) {
      const o = this.dtFormatter(e, t), a = o.formatToParts(), l = a.find((d) => d.type.toLowerCase() === i);
      return l ? l.value : null;
    }
    numberFormatter(e = {}) {
      return new LO(this.intl, e.forceSimple || this.fastNumbers, e);
    }
    dtFormatter(e, t = {}) {
      return new RO(e, this.intl, t);
    }
    relFormatter(e = {}) {
      return new FO(this.intl, this.isEnglish(), e);
    }
    listFormatter(e = {}) {
      return AO(this.intl, e);
    }
    isEnglish() {
      return this.locale === "en" || this.locale.toLowerCase() === "en-us" || M_(this.intl).locale.startsWith("en-us");
    }
    getWeekSettings() {
      return this.weekSettings ? this.weekSettings : B_() ? OO(this.locale) : N_;
    }
    getStartOfWeek() {
      return this.getWeekSettings().firstDay;
    }
    getMinDaysInFirstWeek() {
      return this.getWeekSettings().minimalDays;
    }
    getWeekendDays() {
      return this.getWeekSettings().weekend;
    }
    equals(e) {
      return this.locale === e.locale && this.numberingSystem === e.numberingSystem && this.outputCalendar === e.outputCalendar;
    }
    toString() {
      return `Locale(${this.locale}, ${this.numberingSystem}, ${this.outputCalendar})`;
    }
  }
  let Yc = null;
  class et extends Xn {
    /**
     * Get a singleton instance of UTC
     * @return {FixedOffsetZone}
     */
    static get utcInstance() {
      return Yc === null && (Yc = new et(0)), Yc;
    }
    /**
     * Get an instance with a specified offset
     * @param {number} offset - The offset in minutes
     * @return {FixedOffsetZone}
     */
    static instance(e) {
      return e === 0 ? et.utcInstance : new et(e);
    }
    /**
     * Get an instance of FixedOffsetZone from a UTC offset string, like "UTC+6"
     * @param {string} s - The offset string to parse
     * @example FixedOffsetZone.parseSpecifier("UTC+6")
     * @example FixedOffsetZone.parseSpecifier("UTC+06")
     * @example FixedOffsetZone.parseSpecifier("UTC-6:00")
     * @return {FixedOffsetZone}
     */
    static parseSpecifier(e) {
      if (e) {
        const t = e.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
        if (t)
          return new et(Ya(t[1], t[2]));
      }
      return null;
    }
    constructor(e) {
      super(), this.fixed = e;
    }
    /**
     * The type of zone. `fixed` for all instances of `FixedOffsetZone`.
     * @override
     * @type {string}
     */
    get type() {
      return "fixed";
    }
    /**
     * The name of this zone.
     * All fixed zones' names always start with "UTC" (plus optional offset)
     * @override
     * @type {string}
     */
    get name() {
      return this.fixed === 0 ? "UTC" : `UTC${$n(this.fixed, "narrow")}`;
    }
    /**
     * The IANA name of this zone, i.e. `Etc/UTC` or `Etc/GMT+/-nn`
     *
     * @override
     * @type {string}
     */
    get ianaName() {
      return this.fixed === 0 ? "Etc/UTC" : `Etc/GMT${$n(-this.fixed, "narrow")}`;
    }
    /**
     * Returns the offset's common name at the specified timestamp.
     *
     * For fixed offset zones this equals to the zone name.
     * @override
     */
    offsetName() {
      return this.name;
    }
    /**
     * Returns the offset's value as a string
     * @override
     * @param {number} ts - Epoch milliseconds for which to get the offset
     * @param {string} format - What style of offset to return.
     *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
     * @return {string}
     */
    formatOffset(e, t) {
      return $n(this.fixed, t);
    }
    /**
     * Returns whether the offset is known to be fixed for the whole year:
     * Always returns true for all fixed offset zones.
     * @override
     * @type {boolean}
     */
    get isUniversal() {
      return !0;
    }
    /**
     * Return the offset in minutes for this zone at the specified timestamp.
     *
     * For fixed offset zones, this is constant and does not depend on a timestamp.
     * @override
     * @return {number}
     */
    offset() {
      return this.fixed;
    }
    /**
     * Return whether this Zone is equal to another zone (i.e. also fixed and same offset)
     * @override
     * @param {Zone} otherZone - the zone to compare
     * @return {boolean}
     */
    equals(e) {
      return e.type === "fixed" && e.fixed === this.fixed;
    }
    /**
     * Return whether this Zone is valid:
     * All fixed offset zones are valid.
     * @override
     * @type {boolean}
     */
    get isValid() {
      return !0;
    }
  }
  class zO extends Xn {
    constructor(e) {
      super(), this.zoneName = e;
    }
    /** @override **/
    get type() {
      return "invalid";
    }
    /** @override **/
    get name() {
      return this.zoneName;
    }
    /** @override **/
    get isUniversal() {
      return !1;
    }
    /** @override **/
    offsetName() {
      return null;
    }
    /** @override **/
    formatOffset() {
      return "";
    }
    /** @override **/
    offset() {
      return NaN;
    }
    /** @override **/
    equals() {
      return !1;
    }
    /** @override **/
    get isValid() {
      return !1;
    }
  }
  function Yr(r, e) {
    if (q(r) || r === null)
      return e;
    if (r instanceof Xn)
      return r;
    if (qO(r)) {
      const t = r.toLowerCase();
      return t === "default" ? e : t === "local" || t === "system" ? Ba.instance : t === "utc" || t === "gmt" ? et.utcInstance : et.parseSpecifier(t) || Cr.create(r);
    } else return jr(r) ? et.instance(r) : typeof r == "object" && "offset" in r && typeof r.offset == "function" ? r : new zO(r);
  }
  const ku = {
    arab: "[٠-٩]",
    arabext: "[۰-۹]",
    bali: "[᭐-᭙]",
    beng: "[০-৯]",
    deva: "[०-९]",
    fullwide: "[０-９]",
    gujr: "[૦-૯]",
    hanidec: "[〇|一|二|三|四|五|六|七|八|九]",
    khmr: "[០-៩]",
    knda: "[೦-೯]",
    laoo: "[໐-໙]",
    limb: "[᥆-᥏]",
    mlym: "[൦-൯]",
    mong: "[᠐-᠙]",
    mymr: "[၀-၉]",
    orya: "[୦-୯]",
    tamldec: "[௦-௯]",
    telu: "[౦-౯]",
    thai: "[๐-๙]",
    tibt: "[༠-༩]",
    latn: "\\d"
  }, Fg = {
    arab: [1632, 1641],
    arabext: [1776, 1785],
    bali: [6992, 7001],
    beng: [2534, 2543],
    deva: [2406, 2415],
    fullwide: [65296, 65303],
    gujr: [2790, 2799],
    khmr: [6112, 6121],
    knda: [3302, 3311],
    laoo: [3792, 3801],
    limb: [6470, 6479],
    mlym: [3430, 3439],
    mong: [6160, 6169],
    mymr: [4160, 4169],
    orya: [2918, 2927],
    tamldec: [3046, 3055],
    telu: [3174, 3183],
    thai: [3664, 3673],
    tibt: [3872, 3881]
  }, HO = ku.hanidec.replace(/[\[|\]]/g, "").split("");
  function UO(r) {
    let e = parseInt(r, 10);
    if (isNaN(e)) {
      e = "";
      for (let t = 0; t < r.length; t++) {
        const i = r.charCodeAt(t);
        if (r[t].search(ku.hanidec) !== -1)
          e += HO.indexOf(r[t]);
        else
          for (const o in Fg) {
            const [a, l] = Fg[o];
            i >= a && i <= l && (e += i - a);
          }
      }
      return parseInt(e, 10);
    } else
      return e;
  }
  const Ld = /* @__PURE__ */ new Map();
  function WO() {
    Ld.clear();
  }
  function Vt({ numberingSystem: r }, e = "") {
    const t = r || "latn";
    let i = Ld.get(t);
    i === void 0 && (i = /* @__PURE__ */ new Map(), Ld.set(t, i));
    let o = i.get(e);
    return o === void 0 && (o = new RegExp(`${ku[t]}${e}`), i.set(e, o)), o;
  }
  let zg = () => Date.now(), Hg = "system", Ug = null, Wg = null, Bg = null, Vg = 60, qg, Yg = null;
  class Ce {
    /**
     * Get the callback for returning the current timestamp.
     * @type {function}
     */
    static get now() {
      return zg;
    }
    /**
     * Set the callback for returning the current timestamp.
     * The function should return a number, which will be interpreted as an Epoch millisecond count
     * @type {function}
     * @example Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future
     * @example Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time
     */
    static set now(e) {
      zg = e;
    }
    /**
     * Set the default time zone to create DateTimes in. Does not affect existing instances.
     * Use the value "system" to reset this value to the system's time zone.
     * @type {string}
     */
    static set defaultZone(e) {
      Hg = e;
    }
    /**
     * Get the default time zone object currently used to create DateTimes. Does not affect existing instances.
     * The default value is the system's time zone (the one set on the machine that runs this code).
     * @type {Zone}
     */
    static get defaultZone() {
      return Yr(Hg, Ba.instance);
    }
    /**
     * Get the default locale to create DateTimes with. Does not affect existing instances.
     * @type {string}
     */
    static get defaultLocale() {
      return Ug;
    }
    /**
     * Set the default locale to create DateTimes with. Does not affect existing instances.
     * @type {string}
     */
    static set defaultLocale(e) {
      Ug = e;
    }
    /**
     * Get the default numbering system to create DateTimes with. Does not affect existing instances.
     * @type {string}
     */
    static get defaultNumberingSystem() {
      return Wg;
    }
    /**
     * Set the default numbering system to create DateTimes with. Does not affect existing instances.
     * @type {string}
     */
    static set defaultNumberingSystem(e) {
      Wg = e;
    }
    /**
     * Get the default output calendar to create DateTimes with. Does not affect existing instances.
     * @type {string}
     */
    static get defaultOutputCalendar() {
      return Bg;
    }
    /**
     * Set the default output calendar to create DateTimes with. Does not affect existing instances.
     * @type {string}
     */
    static set defaultOutputCalendar(e) {
      Bg = e;
    }
    /**
     * @typedef {Object} WeekSettings
     * @property {number} firstDay
     * @property {number} minimalDays
     * @property {number[]} weekend
     */
    /**
     * @return {WeekSettings|null}
     */
    static get defaultWeekSettings() {
      return Yg;
    }
    /**
     * Allows overriding the default locale week settings, i.e. the start of the week, the weekend and
     * how many days are required in the first week of a year.
     * Does not affect existing instances.
     *
     * @param {WeekSettings|null} weekSettings
     */
    static set defaultWeekSettings(e) {
      Yg = Rd(e);
    }
    /**
     * Get the cutoff year for whether a 2-digit year string is interpreted in the current or previous century. Numbers higher than the cutoff will be considered to mean 19xx and numbers lower or equal to the cutoff will be considered 20xx.
     * @type {number}
     */
    static get twoDigitCutoffYear() {
      return Vg;
    }
    /**
     * Set the cutoff year for whether a 2-digit year string is interpreted in the current or previous century. Numbers higher than the cutoff will be considered to mean 19xx and numbers lower or equal to the cutoff will be considered 20xx.
     * @type {number}
     * @example Settings.twoDigitCutoffYear = 0 // all 'yy' are interpreted as 20th century
     * @example Settings.twoDigitCutoffYear = 99 // all 'yy' are interpreted as 21st century
     * @example Settings.twoDigitCutoffYear = 50 // '49' -> 2049; '50' -> 1950
     * @example Settings.twoDigitCutoffYear = 1950 // interpreted as 50
     * @example Settings.twoDigitCutoffYear = 2050 // ALSO interpreted as 50
     */
    static set twoDigitCutoffYear(e) {
      Vg = e % 100;
    }
    /**
     * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
     * @type {boolean}
     */
    static get throwOnInvalid() {
      return qg;
    }
    /**
     * Set whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
     * @type {boolean}
     */
    static set throwOnInvalid(e) {
      qg = e;
    }
    /**
     * Reset Luxon's global caches. Should only be necessary in testing scenarios.
     * @return {void}
     */
    static resetCaches() {
      ce.resetCache(), Cr.resetCache(), z.resetCache(), WO();
    }
  }
  class Yt {
    constructor(e, t) {
      this.reason = e, this.explanation = t;
    }
    toMessage() {
      return this.explanation ? `${this.reason}: ${this.explanation}` : this.reason;
    }
  }
  const L_ = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334], R_ = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
  function Nt(r, e) {
    return new Yt(
      "unit out of range",
      `you specified ${e} (of type ${typeof e}) as a ${r}, which is invalid`
    );
  }
  function xu(r, e, t) {
    const i = new Date(Date.UTC(r, e - 1, t));
    r < 100 && r >= 0 && i.setUTCFullYear(i.getUTCFullYear() - 1900);
    const o = i.getUTCDay();
    return o === 0 ? 7 : o;
  }
  function F_(r, e, t) {
    return t + (Qn(r) ? R_ : L_)[e - 1];
  }
  function z_(r, e) {
    const t = Qn(r) ? R_ : L_, i = t.findIndex((a) => a < e), o = e - t[i];
    return { month: i + 1, day: o };
  }
  function Cu(r, e) {
    return (r - e + 7) % 7 + 1;
  }
  function Oa(r, e = 4, t = 1) {
    const { year: i, month: o, day: a } = r, l = F_(i, o, a), d = Cu(xu(i, o, a), t);
    let u = Math.floor((l - d + 14 - e) / 7), f;
    return u < 1 ? (f = i - 1, u = Gn(f, e, t)) : u > Gn(i, e, t) ? (f = i + 1, u = 1) : f = i, { weekYear: f, weekNumber: u, weekday: d, ...Ga(r) };
  }
  function Gg(r, e = 4, t = 1) {
    const { weekYear: i, weekNumber: o, weekday: a } = r, l = Cu(xu(i, 1, e), t), d = ho(i);
    let u = o * 7 + a - l - 7 + e, f;
    u < 1 ? (f = i - 1, u += ho(f)) : u > d ? (f = i + 1, u -= ho(i)) : f = i;
    const { month: g, day: _ } = z_(f, u);
    return { year: f, month: g, day: _, ...Ga(r) };
  }
  function Gc(r) {
    const { year: e, month: t, day: i } = r, o = F_(e, t, i);
    return { year: e, ordinal: o, ...Ga(r) };
  }
  function jg(r) {
    const { year: e, ordinal: t } = r, { month: i, day: o } = z_(e, t);
    return { year: e, month: i, day: o, ...Ga(r) };
  }
  function Zg(r, e) {
    if (!q(r.localWeekday) || !q(r.localWeekNumber) || !q(r.localWeekYear)) {
      if (!q(r.weekday) || !q(r.weekNumber) || !q(r.weekYear))
        throw new oo(
          "Cannot mix locale-based week fields with ISO-based week fields"
        );
      return q(r.localWeekday) || (r.weekday = r.localWeekday), q(r.localWeekNumber) || (r.weekNumber = r.localWeekNumber), q(r.localWeekYear) || (r.weekYear = r.localWeekYear), delete r.localWeekday, delete r.localWeekNumber, delete r.localWeekYear, {
        minDaysInFirstWeek: e.getMinDaysInFirstWeek(),
        startOfWeek: e.getStartOfWeek()
      };
    } else
      return { minDaysInFirstWeek: 4, startOfWeek: 1 };
  }
  function BO(r, e = 4, t = 1) {
    const i = Va(r.weekYear), o = Lt(
      r.weekNumber,
      1,
      Gn(r.weekYear, e, t)
    ), a = Lt(r.weekday, 1, 7);
    return i ? o ? a ? !1 : Nt("weekday", r.weekday) : Nt("week", r.weekNumber) : Nt("weekYear", r.weekYear);
  }
  function VO(r) {
    const e = Va(r.year), t = Lt(r.ordinal, 1, ho(r.year));
    return e ? t ? !1 : Nt("ordinal", r.ordinal) : Nt("year", r.year);
  }
  function H_(r) {
    const e = Va(r.year), t = Lt(r.month, 1, 12), i = Lt(r.day, 1, Da(r.year, r.month));
    return e ? t ? i ? !1 : Nt("day", r.day) : Nt("month", r.month) : Nt("year", r.year);
  }
  function U_(r) {
    const { hour: e, minute: t, second: i, millisecond: o } = r, a = Lt(e, 0, 23) || e === 24 && t === 0 && i === 0 && o === 0, l = Lt(t, 0, 59), d = Lt(i, 0, 59), u = Lt(o, 0, 999);
    return a ? l ? d ? u ? !1 : Nt("millisecond", o) : Nt("second", i) : Nt("minute", t) : Nt("hour", e);
  }
  function q(r) {
    return typeof r > "u";
  }
  function jr(r) {
    return typeof r == "number";
  }
  function Va(r) {
    return typeof r == "number" && r % 1 === 0;
  }
  function qO(r) {
    return typeof r == "string";
  }
  function YO(r) {
    return Object.prototype.toString.call(r) === "[object Date]";
  }
  function W_() {
    try {
      return typeof Intl < "u" && !!Intl.RelativeTimeFormat;
    } catch {
      return !1;
    }
  }
  function B_() {
    try {
      return typeof Intl < "u" && !!Intl.Locale && ("weekInfo" in Intl.Locale.prototype || "getWeekInfo" in Intl.Locale.prototype);
    } catch {
      return !1;
    }
  }
  function GO(r) {
    return Array.isArray(r) ? r : [r];
  }
  function Kg(r, e, t) {
    if (r.length !== 0)
      return r.reduce((i, o) => {
        const a = [e(o), o];
        return i && t(i[0], a[0]) === i[0] ? i : a;
      }, null)[1];
  }
  function jO(r, e) {
    return e.reduce((t, i) => (t[i] = r[i], t), {});
  }
  function No(r, e) {
    return Object.prototype.hasOwnProperty.call(r, e);
  }
  function Rd(r) {
    if (r == null)
      return null;
    if (typeof r != "object")
      throw new qe("Week settings must be an object");
    if (!Lt(r.firstDay, 1, 7) || !Lt(r.minimalDays, 1, 7) || !Array.isArray(r.weekend) || r.weekend.some((e) => !Lt(e, 1, 7)))
      throw new qe("Invalid week settings");
    return {
      firstDay: r.firstDay,
      minimalDays: r.minimalDays,
      weekend: Array.from(r.weekend)
    };
  }
  function Lt(r, e, t) {
    return Va(r) && r >= e && r <= t;
  }
  function ZO(r, e) {
    return r - e * Math.floor(r / e);
  }
  function $e(r, e = 2) {
    const t = r < 0;
    let i;
    return t ? i = "-" + ("" + -r).padStart(e, "0") : i = ("" + r).padStart(e, "0"), i;
  }
  function Wr(r) {
    if (!(q(r) || r === null || r === ""))
      return parseInt(r, 10);
  }
  function pi(r) {
    if (!(q(r) || r === null || r === ""))
      return parseFloat(r);
  }
  function Su(r) {
    if (!(q(r) || r === null || r === "")) {
      const e = parseFloat("0." + r) * 1e3;
      return Math.floor(e);
    }
  }
  function Au(r, e, t = "round") {
    const i = 10 ** e;
    switch (t) {
      case "expand":
        return r > 0 ? Math.ceil(r * i) / i : Math.floor(r * i) / i;
      case "trunc":
        return Math.trunc(r * i) / i;
      case "round":
        return Math.round(r * i) / i;
      case "floor":
        return Math.floor(r * i) / i;
      case "ceil":
        return Math.ceil(r * i) / i;
      default:
        throw new RangeError(`Value rounding ${t} is out of range`);
    }
  }
  function Qn(r) {
    return r % 4 === 0 && (r % 100 !== 0 || r % 400 === 0);
  }
  function ho(r) {
    return Qn(r) ? 366 : 365;
  }
  function Da(r, e) {
    const t = ZO(e - 1, 12) + 1, i = r + (e - t) / 12;
    return t === 2 ? Qn(i) ? 29 : 28 : [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][t - 1];
  }
  function qa(r) {
    let e = Date.UTC(
      r.year,
      r.month - 1,
      r.day,
      r.hour,
      r.minute,
      r.second,
      r.millisecond
    );
    return r.year < 100 && r.year >= 0 && (e = new Date(e), e.setUTCFullYear(r.year, r.month - 1, r.day)), +e;
  }
  function Jg(r, e, t) {
    return -Cu(xu(r, 1, e), t) + e - 1;
  }
  function Gn(r, e = 4, t = 1) {
    const i = Jg(r, e, t), o = Jg(r + 1, e, t);
    return (ho(r) - i + o) / 7;
  }
  function Fd(r) {
    return r > 99 ? r : r > Ce.twoDigitCutoffYear ? 1900 + r : 2e3 + r;
  }
  function V_(r, e, t, i = null) {
    const o = new Date(r), a = {
      hourCycle: "h23",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit"
    };
    i && (a.timeZone = i);
    const l = { timeZoneName: e, ...a }, d = new Intl.DateTimeFormat(t, l).formatToParts(o).find((u) => u.type.toLowerCase() === "timezonename");
    return d ? d.value : null;
  }
  function Ya(r, e) {
    let t = parseInt(r, 10);
    Number.isNaN(t) && (t = 0);
    const i = parseInt(e, 10) || 0, o = t < 0 || Object.is(t, -0) ? -i : i;
    return t * 60 + o;
  }
  function q_(r) {
    const e = Number(r);
    if (typeof r == "boolean" || r === "" || !Number.isFinite(e))
      throw new qe(`Invalid unit value ${r}`);
    return e;
  }
  function Pa(r, e) {
    const t = {};
    for (const i in r)
      if (No(r, i)) {
        const o = r[i];
        if (o == null) continue;
        t[e(i)] = q_(o);
      }
    return t;
  }
  function $n(r, e) {
    const t = Math.trunc(Math.abs(r / 60)), i = Math.trunc(Math.abs(r % 60)), o = r >= 0 ? "+" : "-";
    switch (e) {
      case "short":
        return `${o}${$e(t, 2)}:${$e(i, 2)}`;
      case "narrow":
        return `${o}${t}${i > 0 ? `:${i}` : ""}`;
      case "techie":
        return `${o}${$e(t, 2)}${$e(i, 2)}`;
      default:
        throw new RangeError(`Value format ${e} is out of range for property format`);
    }
  }
  function Ga(r) {
    return jO(r, ["hour", "minute", "second", "millisecond"]);
  }
  const KO = [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ], Y_ = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ], JO = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
  function G_(r) {
    switch (r) {
      case "narrow":
        return [...JO];
      case "short":
        return [...Y_];
      case "long":
        return [...KO];
      case "numeric":
        return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
      case "2-digit":
        return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
      default:
        return null;
    }
  }
  const j_ = [
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday",
    "Sunday"
  ], Z_ = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"], XO = ["M", "T", "W", "T", "F", "S", "S"];
  function K_(r) {
    switch (r) {
      case "narrow":
        return [...XO];
      case "short":
        return [...Z_];
      case "long":
        return [...j_];
      case "numeric":
        return ["1", "2", "3", "4", "5", "6", "7"];
      default:
        return null;
    }
  }
  const J_ = ["AM", "PM"], QO = ["Before Christ", "Anno Domini"], eD = ["BC", "AD"], tD = ["B", "A"];
  function X_(r) {
    switch (r) {
      case "narrow":
        return [...tD];
      case "short":
        return [...eD];
      case "long":
        return [...QO];
      default:
        return null;
    }
  }
  function rD(r) {
    return J_[r.hour < 12 ? 0 : 1];
  }
  function iD(r, e) {
    return K_(e)[r.weekday - 1];
  }
  function oD(r, e) {
    return G_(e)[r.month - 1];
  }
  function nD(r, e) {
    return X_(e)[r.year < 0 ? 0 : 1];
  }
  function sD(r, e, t = "always", i = !1) {
    const o = {
      years: ["year", "yr."],
      quarters: ["quarter", "qtr."],
      months: ["month", "mo."],
      weeks: ["week", "wk."],
      days: ["day", "day", "days"],
      hours: ["hour", "hr."],
      minutes: ["minute", "min."],
      seconds: ["second", "sec."]
    }, a = ["hours", "minutes", "seconds"].indexOf(r) === -1;
    if (t === "auto" && a) {
      const _ = r === "days";
      switch (e) {
        case 1:
          return _ ? "tomorrow" : `next ${o[r][0]}`;
        case -1:
          return _ ? "yesterday" : `last ${o[r][0]}`;
        case 0:
          return _ ? "today" : `this ${o[r][0]}`;
      }
    }
    const l = Object.is(e, -0) || e < 0, d = Math.abs(e), u = d === 1, f = o[r], g = i ? u ? f[1] : f[2] || f[1] : u ? o[r][0] : r;
    return l ? `${d} ${g} ago` : `in ${d} ${g}`;
  }
  function Xg(r, e) {
    let t = "";
    for (const i of r)
      i.literal ? t += i.val : t += e(i.val);
    return t;
  }
  const aD = {
    D: Ta,
    DD: g_,
    DDD: m_,
    DDDD: b_,
    t: __,
    tt: v_,
    ttt: y_,
    tttt: w_,
    T: k_,
    TT: x_,
    TTT: C_,
    TTTT: S_,
    f: A_,
    ff: $_,
    fff: O_,
    ffff: P_,
    F: E_,
    FF: T_,
    FFF: D_,
    FFFF: I_
  };
  class Ge {
    static create(e, t = {}) {
      return new Ge(e, t);
    }
    static parseFormat(e) {
      let t = null, i = "", o = !1;
      const a = [];
      for (let l = 0; l < e.length; l++) {
        const d = e.charAt(l);
        d === "'" ? ((i.length > 0 || o) && a.push({
          literal: o || /^\s+$/.test(i),
          val: i === "" ? "'" : i
        }), t = null, i = "", o = !o) : o || d === t ? i += d : (i.length > 0 && a.push({ literal: /^\s+$/.test(i), val: i }), i = d, t = d);
      }
      return i.length > 0 && a.push({ literal: o || /^\s+$/.test(i), val: i }), a;
    }
    static macroTokenToFormatOpts(e) {
      return aD[e];
    }
    constructor(e, t) {
      this.opts = t, this.loc = e, this.systemLoc = null;
    }
    formatWithSystemDefault(e, t) {
      return this.systemLoc === null && (this.systemLoc = this.loc.redefaultToSystem()), this.systemLoc.dtFormatter(e, { ...this.opts, ...t }).format();
    }
    dtFormatter(e, t = {}) {
      return this.loc.dtFormatter(e, { ...this.opts, ...t });
    }
    formatDateTime(e, t) {
      return this.dtFormatter(e, t).format();
    }
    formatDateTimeParts(e, t) {
      return this.dtFormatter(e, t).formatToParts();
    }
    formatInterval(e, t) {
      return this.dtFormatter(e.start, t).dtf.formatRange(e.start.toJSDate(), e.end.toJSDate());
    }
    resolvedOptions(e, t) {
      return this.dtFormatter(e, t).resolvedOptions();
    }
    num(e, t = 0, i = void 0) {
      if (this.opts.forceSimple)
        return $e(e, t);
      const o = { ...this.opts };
      return t > 0 && (o.padTo = t), i && (o.signDisplay = i), this.loc.numberFormatter(o).format(e);
    }
    formatDateTimeFromString(e, t) {
      const i = this.loc.listingMode() === "en", o = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", a = (x, D) => this.loc.extract(e, x, D), l = (x) => e.isOffsetFixed && e.offset === 0 && x.allowZ ? "Z" : e.isValid ? e.zone.formatOffset(e.ts, x.format) : "", d = () => i ? rD(e) : a({ hour: "numeric", hourCycle: "h12" }, "dayperiod"), u = (x, D) => i ? oD(e, x) : a(D ? { month: x } : { month: x, day: "numeric" }, "month"), f = (x, D) => i ? iD(e, x) : a(
        D ? { weekday: x } : { weekday: x, month: "long", day: "numeric" },
        "weekday"
      ), g = (x) => {
        const D = Ge.macroTokenToFormatOpts(x);
        return D ? this.formatWithSystemDefault(e, D) : x;
      }, _ = (x) => i ? nD(e, x) : a({ era: x }, "era"), C = (x) => {
        switch (x) {
          // ms
          case "S":
            return this.num(e.millisecond);
          case "u":
          // falls through
          case "SSS":
            return this.num(e.millisecond, 3);
          // seconds
          case "s":
            return this.num(e.second);
          case "ss":
            return this.num(e.second, 2);
          // fractional seconds
          case "uu":
            return this.num(Math.floor(e.millisecond / 10), 2);
          case "uuu":
            return this.num(Math.floor(e.millisecond / 100));
          // minutes
          case "m":
            return this.num(e.minute);
          case "mm":
            return this.num(e.minute, 2);
          // hours
          case "h":
            return this.num(e.hour % 12 === 0 ? 12 : e.hour % 12);
          case "hh":
            return this.num(e.hour % 12 === 0 ? 12 : e.hour % 12, 2);
          case "H":
            return this.num(e.hour);
          case "HH":
            return this.num(e.hour, 2);
          // offset
          case "Z":
            return l({ format: "narrow", allowZ: this.opts.allowZ });
          case "ZZ":
            return l({ format: "short", allowZ: this.opts.allowZ });
          case "ZZZ":
            return l({ format: "techie", allowZ: this.opts.allowZ });
          case "ZZZZ":
            return e.zone.offsetName(e.ts, { format: "short", locale: this.loc.locale });
          case "ZZZZZ":
            return e.zone.offsetName(e.ts, { format: "long", locale: this.loc.locale });
          // zone
          case "z":
            return e.zoneName;
          // meridiems
          case "a":
            return d();
          // dates
          case "d":
            return o ? a({ day: "numeric" }, "day") : this.num(e.day);
          case "dd":
            return o ? a({ day: "2-digit" }, "day") : this.num(e.day, 2);
          // weekdays - standalone
          case "c":
            return this.num(e.weekday);
          case "ccc":
            return f("short", !0);
          case "cccc":
            return f("long", !0);
          case "ccccc":
            return f("narrow", !0);
          // weekdays - format
          case "E":
            return this.num(e.weekday);
          case "EEE":
            return f("short", !1);
          case "EEEE":
            return f("long", !1);
          case "EEEEE":
            return f("narrow", !1);
          // months - standalone
          case "L":
            return o ? a({ month: "numeric", day: "numeric" }, "month") : this.num(e.month);
          case "LL":
            return o ? a({ month: "2-digit", day: "numeric" }, "month") : this.num(e.month, 2);
          case "LLL":
            return u("short", !0);
          case "LLLL":
            return u("long", !0);
          case "LLLLL":
            return u("narrow", !0);
          // months - format
          case "M":
            return o ? a({ month: "numeric" }, "month") : this.num(e.month);
          case "MM":
            return o ? a({ month: "2-digit" }, "month") : this.num(e.month, 2);
          case "MMM":
            return u("short", !1);
          case "MMMM":
            return u("long", !1);
          case "MMMMM":
            return u("narrow", !1);
          // years
          case "y":
            return o ? a({ year: "numeric" }, "year") : this.num(e.year);
          case "yy":
            return o ? a({ year: "2-digit" }, "year") : this.num(e.year.toString().slice(-2), 2);
          case "yyyy":
            return o ? a({ year: "numeric" }, "year") : this.num(e.year, 4);
          case "yyyyyy":
            return o ? a({ year: "numeric" }, "year") : this.num(e.year, 6);
          // eras
          case "G":
            return _("short");
          case "GG":
            return _("long");
          case "GGGGG":
            return _("narrow");
          case "kk":
            return this.num(e.weekYear.toString().slice(-2), 2);
          case "kkkk":
            return this.num(e.weekYear, 4);
          case "W":
            return this.num(e.weekNumber);
          case "WW":
            return this.num(e.weekNumber, 2);
          case "n":
            return this.num(e.localWeekNumber);
          case "nn":
            return this.num(e.localWeekNumber, 2);
          case "ii":
            return this.num(e.localWeekYear.toString().slice(-2), 2);
          case "iiii":
            return this.num(e.localWeekYear, 4);
          case "o":
            return this.num(e.ordinal);
          case "ooo":
            return this.num(e.ordinal, 3);
          case "q":
            return this.num(e.quarter);
          case "qq":
            return this.num(e.quarter, 2);
          case "X":
            return this.num(Math.floor(e.ts / 1e3));
          case "x":
            return this.num(e.ts);
          default:
            return g(x);
        }
      };
      return Xg(Ge.parseFormat(t), C);
    }
    formatDurationFromString(e, t) {
      const i = this.opts.signMode === "negativeLargestOnly" ? -1 : 1, o = (g) => {
        switch (g[0]) {
          case "S":
            return "milliseconds";
          case "s":
            return "seconds";
          case "m":
            return "minutes";
          case "h":
            return "hours";
          case "d":
            return "days";
          case "w":
            return "weeks";
          case "M":
            return "months";
          case "y":
            return "years";
          default:
            return null;
        }
      }, a = (g, _) => (C) => {
        const x = o(C);
        if (x) {
          const D = _.isNegativeDuration && x !== _.largestUnit ? i : 1;
          let P;
          return this.opts.signMode === "negativeLargestOnly" && x !== _.largestUnit ? P = "never" : this.opts.signMode === "all" ? P = "always" : P = "auto", this.num(g.get(x) * D, C.length, P);
        } else
          return C;
      }, l = Ge.parseFormat(t), d = l.reduce(
        (g, { literal: _, val: C }) => _ ? g : g.concat(C),
        []
      ), u = e.shiftTo(...d.map(o).filter((g) => g)), f = {
        isNegativeDuration: u < 0,
        // this relies on "collapsed" being based on "shiftTo", which builds up the object
        // in order
        largestUnit: Object.keys(u.values)[0]
      };
      return Xg(l, a(u, f));
    }
  }
  const Q_ = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;
  function Ho(...r) {
    const e = r.reduce((t, i) => t + i.source, "");
    return RegExp(`^${e}$`);
  }
  function Uo(...r) {
    return (e) => r.reduce(
      ([t, i, o], a) => {
        const [l, d, u] = a(e, o);
        return [{ ...t, ...l }, d || i, u];
      },
      [{}, null, 1]
    ).slice(0, 2);
  }
  function Wo(r, ...e) {
    if (r == null)
      return [null, null];
    for (const [t, i] of e) {
      const o = t.exec(r);
      if (o)
        return i(o);
    }
    return [null, null];
  }
  function ev(...r) {
    return (e, t) => {
      const i = {};
      let o;
      for (o = 0; o < r.length; o++)
        i[r[o]] = Wr(e[t + o]);
      return [i, null, t + o];
    };
  }
  const tv = /(?:([Zz])|([+-]\d\d)(?::?(\d\d))?)/, lD = `(?:${tv.source}?(?:\\[(${Q_.source})\\])?)?`, Eu = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/, rv = RegExp(`${Eu.source}${lD}`), $u = RegExp(`(?:[Tt]${rv.source})?`), cD = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/, dD = /(\d{4})-?W(\d\d)(?:-?(\d))?/, uD = /(\d{4})-?(\d{3})/, hD = ev("weekYear", "weekNumber", "weekDay"), fD = ev("year", "ordinal"), pD = /(\d{4})-(\d\d)-(\d\d)/, iv = RegExp(
    `${Eu.source} ?(?:${tv.source}|(${Q_.source}))?`
  ), gD = RegExp(`(?: ${iv.source})?`);
  function fo(r, e, t) {
    const i = r[e];
    return q(i) ? t : Wr(i);
  }
  function mD(r, e) {
    return [{
      year: fo(r, e),
      month: fo(r, e + 1, 1),
      day: fo(r, e + 2, 1)
    }, null, e + 3];
  }
  function Bo(r, e) {
    return [{
      hours: fo(r, e, 0),
      minutes: fo(r, e + 1, 0),
      seconds: fo(r, e + 2, 0),
      milliseconds: Su(r[e + 3])
    }, null, e + 4];
  }
  function es(r, e) {
    const t = !r[e] && !r[e + 1], i = Ya(r[e + 1], r[e + 2]), o = t ? null : et.instance(i);
    return [{}, o, e + 3];
  }
  function ts(r, e) {
    const t = r[e] ? Cr.create(r[e]) : null;
    return [{}, t, e + 1];
  }
  const bD = RegExp(`^T?${Eu.source}$`), _D = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
  function vD(r) {
    const [e, t, i, o, a, l, d, u, f] = r, g = e[0] === "-", _ = u && u[0] === "-", C = (x, D = !1) => x !== void 0 && (D || x && g) ? -x : x;
    return [
      {
        years: C(pi(t)),
        months: C(pi(i)),
        weeks: C(pi(o)),
        days: C(pi(a)),
        hours: C(pi(l)),
        minutes: C(pi(d)),
        seconds: C(pi(u), u === "-0"),
        milliseconds: C(Su(f), _)
      }
    ];
  }
  const yD = {
    GMT: 0,
    EDT: -240,
    EST: -300,
    CDT: -300,
    CST: -360,
    MDT: -360,
    MST: -420,
    PDT: -420,
    PST: -480
  };
  function Tu(r, e, t, i, o, a, l) {
    const d = {
      year: e.length === 2 ? Fd(Wr(e)) : Wr(e),
      month: Y_.indexOf(t) + 1,
      day: Wr(i),
      hour: Wr(o),
      minute: Wr(a)
    };
    return l && (d.second = Wr(l)), r && (d.weekday = r.length > 3 ? j_.indexOf(r) + 1 : Z_.indexOf(r) + 1), d;
  }
  const wD = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
  function kD(r) {
    const [
      ,
      e,
      t,
      i,
      o,
      a,
      l,
      d,
      u,
      f,
      g,
      _
    ] = r, C = Tu(e, o, i, t, a, l, d);
    let x;
    return u ? x = yD[u] : f ? x = 0 : x = Ya(g, _), [C, new et(x)];
  }
  function xD(r) {
    return r.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
  }
  const CD = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/, SD = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/, AD = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
  function Qg(r) {
    const [, e, t, i, o, a, l, d] = r;
    return [Tu(e, o, i, t, a, l, d), et.utcInstance];
  }
  function ED(r) {
    const [, e, t, i, o, a, l, d] = r;
    return [Tu(e, d, t, i, o, a, l), et.utcInstance];
  }
  const $D = Ho(cD, $u), TD = Ho(dD, $u), OD = Ho(uD, $u), DD = Ho(rv), ov = Uo(
    mD,
    Bo,
    es,
    ts
  ), PD = Uo(
    hD,
    Bo,
    es,
    ts
  ), ID = Uo(
    fD,
    Bo,
    es,
    ts
  ), MD = Uo(
    Bo,
    es,
    ts
  );
  function ND(r) {
    return Wo(
      r,
      [$D, ov],
      [TD, PD],
      [OD, ID],
      [DD, MD]
    );
  }
  function LD(r) {
    return Wo(xD(r), [wD, kD]);
  }
  function RD(r) {
    return Wo(
      r,
      [CD, Qg],
      [SD, Qg],
      [AD, ED]
    );
  }
  function FD(r) {
    return Wo(r, [_D, vD]);
  }
  const zD = Uo(Bo);
  function HD(r) {
    return Wo(r, [bD, zD]);
  }
  const UD = Ho(pD, gD), WD = Ho(iv), BD = Uo(
    Bo,
    es,
    ts
  );
  function VD(r) {
    return Wo(
      r,
      [UD, ov],
      [WD, BD]
    );
  }
  const em = "Invalid Duration", nv = {
    weeks: {
      days: 7,
      hours: 168,
      minutes: 10080,
      seconds: 10080 * 60,
      milliseconds: 10080 * 60 * 1e3
    },
    days: {
      hours: 24,
      minutes: 1440,
      seconds: 1440 * 60,
      milliseconds: 1440 * 60 * 1e3
    },
    hours: { minutes: 60, seconds: 3600, milliseconds: 3600 * 1e3 },
    minutes: { seconds: 60, milliseconds: 60 * 1e3 },
    seconds: { milliseconds: 1e3 }
  }, qD = {
    years: {
      quarters: 4,
      months: 12,
      weeks: 52,
      days: 365,
      hours: 365 * 24,
      minutes: 365 * 24 * 60,
      seconds: 365 * 24 * 60 * 60,
      milliseconds: 365 * 24 * 60 * 60 * 1e3
    },
    quarters: {
      months: 3,
      weeks: 13,
      days: 91,
      hours: 2184,
      minutes: 2184 * 60,
      seconds: 2184 * 60 * 60,
      milliseconds: 2184 * 60 * 60 * 1e3
    },
    months: {
      weeks: 4,
      days: 30,
      hours: 720,
      minutes: 720 * 60,
      seconds: 720 * 60 * 60,
      milliseconds: 720 * 60 * 60 * 1e3
    },
    ...nv
  }, Mt = 146097 / 400, Ji = 146097 / 4800, YD = {
    years: {
      quarters: 4,
      months: 12,
      weeks: Mt / 7,
      days: Mt,
      hours: Mt * 24,
      minutes: Mt * 24 * 60,
      seconds: Mt * 24 * 60 * 60,
      milliseconds: Mt * 24 * 60 * 60 * 1e3
    },
    quarters: {
      months: 3,
      weeks: Mt / 28,
      days: Mt / 4,
      hours: Mt * 24 / 4,
      minutes: Mt * 24 * 60 / 4,
      seconds: Mt * 24 * 60 * 60 / 4,
      milliseconds: Mt * 24 * 60 * 60 * 1e3 / 4
    },
    months: {
      weeks: Ji / 7,
      days: Ji,
      hours: Ji * 24,
      minutes: Ji * 24 * 60,
      seconds: Ji * 24 * 60 * 60,
      milliseconds: Ji * 24 * 60 * 60 * 1e3
    },
    ...nv
  }, yi = [
    "years",
    "quarters",
    "months",
    "weeks",
    "days",
    "hours",
    "minutes",
    "seconds",
    "milliseconds"
  ], GD = yi.slice(0).reverse();
  function _r(r, e, t = !1) {
    const i = {
      values: t ? e.values : { ...r.values, ...e.values || {} },
      loc: r.loc.clone(e.loc),
      conversionAccuracy: e.conversionAccuracy || r.conversionAccuracy,
      matrix: e.matrix || r.matrix
    };
    return new oe(i);
  }
  function sv(r, e) {
    let t = e.milliseconds ?? 0;
    for (const i of GD.slice(1))
      e[i] && (t += e[i] * r[i].milliseconds);
    return t;
  }
  function tm(r, e) {
    const t = sv(r, e) < 0 ? -1 : 1;
    yi.reduceRight((i, o) => {
      if (q(e[o]))
        return i;
      if (i) {
        const a = e[i] * t, l = r[o][i], d = Math.floor(a / l);
        e[o] += d * t, e[i] -= d * l * t;
      }
      return o;
    }, null), yi.reduce((i, o) => {
      if (q(e[o]))
        return i;
      if (i) {
        const a = e[i] % 1;
        e[i] -= a, e[o] += a * r[i][o];
      }
      return o;
    }, null);
  }
  function rm(r) {
    const e = {};
    for (const [t, i] of Object.entries(r))
      i !== 0 && (e[t] = i);
    return e;
  }
  class oe {
    /**
     * @private
     */
    constructor(e) {
      const t = e.conversionAccuracy === "longterm" || !1;
      let i = t ? YD : qD;
      e.matrix && (i = e.matrix), this.values = e.values, this.loc = e.loc || ce.create(), this.conversionAccuracy = t ? "longterm" : "casual", this.invalid = e.invalid || null, this.matrix = i, this.isLuxonDuration = !0;
    }
    /**
     * Create Duration from a number of milliseconds.
     * @param {number} count of milliseconds
     * @param {Object} opts - options for parsing
     * @param {string} [opts.locale='en-US'] - the locale to use
     * @param {string} opts.numberingSystem - the numbering system to use
     * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
     * @return {Duration}
     */
    static fromMillis(e, t) {
      return oe.fromObject({ milliseconds: e }, t);
    }
    /**
     * Create a Duration from a JavaScript object with keys like 'years' and 'hours'.
     * If this object is empty then a zero milliseconds duration is returned.
     * @param {Object} obj - the object to create the DateTime from
     * @param {number} obj.years
     * @param {number} obj.quarters
     * @param {number} obj.months
     * @param {number} obj.weeks
     * @param {number} obj.days
     * @param {number} obj.hours
     * @param {number} obj.minutes
     * @param {number} obj.seconds
     * @param {number} obj.milliseconds
     * @param {Object} [opts=[]] - options for creating this Duration
     * @param {string} [opts.locale='en-US'] - the locale to use
     * @param {string} opts.numberingSystem - the numbering system to use
     * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
     * @param {string} [opts.matrix=Object] - the custom conversion system to use
     * @return {Duration}
     */
    static fromObject(e, t = {}) {
      if (e == null || typeof e != "object")
        throw new qe(
          `Duration.fromObject: argument expected to be an object, got ${e === null ? "null" : typeof e}`
        );
      return new oe({
        values: Pa(e, oe.normalizeUnit),
        loc: ce.fromObject(t),
        conversionAccuracy: t.conversionAccuracy,
        matrix: t.matrix
      });
    }
    /**
     * Create a Duration from DurationLike.
     *
     * @param {Object | number | Duration} durationLike
     * One of:
     * - object with keys like 'years' and 'hours'.
     * - number representing milliseconds
     * - Duration instance
     * @return {Duration}
     */
    static fromDurationLike(e) {
      if (jr(e))
        return oe.fromMillis(e);
      if (oe.isDuration(e))
        return e;
      if (typeof e == "object")
        return oe.fromObject(e);
      throw new qe(
        `Unknown duration argument ${e} of type ${typeof e}`
      );
    }
    /**
     * Create a Duration from an ISO 8601 duration string.
     * @param {string} text - text to parse
     * @param {Object} opts - options for parsing
     * @param {string} [opts.locale='en-US'] - the locale to use
     * @param {string} opts.numberingSystem - the numbering system to use
     * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
     * @param {string} [opts.matrix=Object] - the preset conversion system to use
     * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
     * @example Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }
     * @example Duration.fromISO('PT23H').toObject() //=> { hours: 23 }
     * @example Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }
     * @return {Duration}
     */
    static fromISO(e, t) {
      const [i] = FD(e);
      return i ? oe.fromObject(i, t) : oe.invalid("unparsable", `the input "${e}" can't be parsed as ISO 8601`);
    }
    /**
     * Create a Duration from an ISO 8601 time string.
     * @param {string} text - text to parse
     * @param {Object} opts - options for parsing
     * @param {string} [opts.locale='en-US'] - the locale to use
     * @param {string} opts.numberingSystem - the numbering system to use
     * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
     * @param {string} [opts.matrix=Object] - the conversion system to use
     * @see https://en.wikipedia.org/wiki/ISO_8601#Times
     * @example Duration.fromISOTime('11:22:33.444').toObject() //=> { hours: 11, minutes: 22, seconds: 33, milliseconds: 444 }
     * @example Duration.fromISOTime('11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
     * @example Duration.fromISOTime('T11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
     * @example Duration.fromISOTime('1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
     * @example Duration.fromISOTime('T1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
     * @return {Duration}
     */
    static fromISOTime(e, t) {
      const [i] = HD(e);
      return i ? oe.fromObject(i, t) : oe.invalid("unparsable", `the input "${e}" can't be parsed as ISO 8601`);
    }
    /**
     * Create an invalid Duration.
     * @param {string} reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent
     * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
     * @return {Duration}
     */
    static invalid(e, t = null) {
      if (!e)
        throw new qe("need to specify a reason the Duration is invalid");
      const i = e instanceof Yt ? e : new Yt(e, t);
      if (Ce.throwOnInvalid)
        throw new vO(i);
      return new oe({ invalid: i });
    }
    /**
     * @private
     */
    static normalizeUnit(e) {
      const t = {
        year: "years",
        years: "years",
        quarter: "quarters",
        quarters: "quarters",
        month: "months",
        months: "months",
        week: "weeks",
        weeks: "weeks",
        day: "days",
        days: "days",
        hour: "hours",
        hours: "hours",
        minute: "minutes",
        minutes: "minutes",
        second: "seconds",
        seconds: "seconds",
        millisecond: "milliseconds",
        milliseconds: "milliseconds"
      }[e && e.toLowerCase()];
      if (!t) throw new p_(e);
      return t;
    }
    /**
     * Check if an object is a Duration. Works across context boundaries
     * @param {object} o
     * @return {boolean}
     */
    static isDuration(e) {
      return e && e.isLuxonDuration || !1;
    }
    /**
     * Get  the locale of a Duration, such 'en-GB'
     * @type {string}
     */
    get locale() {
      return this.isValid ? this.loc.locale : null;
    }
    /**
     * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration
     *
     * @type {string}
     */
    get numberingSystem() {
      return this.isValid ? this.loc.numberingSystem : null;
    }
    /**
     * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:
     * * `S` for milliseconds
     * * `s` for seconds
     * * `m` for minutes
     * * `h` for hours
     * * `d` for days
     * * `w` for weeks
     * * `M` for months
     * * `y` for years
     * Notes:
     * * Add padding by repeating the token, e.g. "yy" pads the years to two digits, "hhhh" pads the hours out to four digits
     * * Tokens can be escaped by wrapping with single quotes.
     * * The duration will be converted to the set of units in the format string using {@link Duration#shiftTo} and the Durations's conversion accuracy setting.
     * @param {string} fmt - the format string
     * @param {Object} opts - options
     * @param {boolean} [opts.floor=true] - floor numerical values
     * @param {'negative'|'all'|'negativeLargestOnly'} [opts.signMode=negative] - How to handle signs
     * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("y d s") //=> "1 6 2"
     * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("yy dd sss") //=> "01 06 002"
     * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("M S") //=> "12 518402000"
     * @example Duration.fromObject({ days: 6, seconds: 2 }).toFormat("d s", { signMode: "all" }) //=> "+6 +2"
     * @example Duration.fromObject({ days: -6, seconds: -2 }).toFormat("d s", { signMode: "all" }) //=> "-6 -2"
     * @example Duration.fromObject({ days: -6, seconds: -2 }).toFormat("d s", { signMode: "negativeLargestOnly" }) //=> "-6 2"
     * @return {string}
     */
    toFormat(e, t = {}) {
      const i = {
        ...t,
        floor: t.round !== !1 && t.floor !== !1
      };
      return this.isValid ? Ge.create(this.loc, i).formatDurationFromString(this, e) : em;
    }
    /**
     * Returns a string representation of a Duration with all units included.
     * To modify its behavior, use `listStyle` and any Intl.NumberFormat option, though `unitDisplay` is especially relevant.
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/NumberFormat#options
     * @param {Object} opts - Formatting options. Accepts the same keys as the options parameter of the native `Intl.NumberFormat` constructor, as well as `listStyle`.
     * @param {string} [opts.listStyle='narrow'] - How to format the merged list. Corresponds to the `style` property of the options parameter of the native `Intl.ListFormat` constructor.
     * @param {boolean} [opts.showZeros=true] - Show all units previously used by the duration even if they are zero
     * @example
     * ```js
     * var dur = Duration.fromObject({ months: 1, weeks: 0, hours: 5, minutes: 6 })
     * dur.toHuman() //=> '1 month, 0 weeks, 5 hours, 6 minutes'
     * dur.toHuman({ listStyle: "long" }) //=> '1 month, 0 weeks, 5 hours, and 6 minutes'
     * dur.toHuman({ unitDisplay: "short" }) //=> '1 mth, 0 wks, 5 hr, 6 min'
     * dur.toHuman({ showZeros: false }) //=> '1 month, 5 hours, 6 minutes'
     * ```
     */
    toHuman(e = {}) {
      if (!this.isValid) return em;
      const t = e.showZeros !== !1, i = yi.map((o) => {
        const a = this.values[o];
        return q(a) || a === 0 && !t ? null : this.loc.numberFormatter({ style: "unit", unitDisplay: "long", ...e, unit: o.slice(0, -1) }).format(a);
      }).filter((o) => o);
      return this.loc.listFormatter({ type: "conjunction", style: e.listStyle || "narrow", ...e }).format(i);
    }
    /**
     * Returns a JavaScript object with this Duration's values.
     * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }
     * @return {Object}
     */
    toObject() {
      return this.isValid ? { ...this.values } : {};
    }
    /**
     * Returns an ISO 8601-compliant string representation of this Duration.
     * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
     * @example Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'
     * @example Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'
     * @example Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'
     * @example Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'
     * @example Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'
     * @return {string}
     */
    toISO() {
      if (!this.isValid) return null;
      let e = "P";
      return this.years !== 0 && (e += this.years + "Y"), (this.months !== 0 || this.quarters !== 0) && (e += this.months + this.quarters * 3 + "M"), this.weeks !== 0 && (e += this.weeks + "W"), this.days !== 0 && (e += this.days + "D"), (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0) && (e += "T"), this.hours !== 0 && (e += this.hours + "H"), this.minutes !== 0 && (e += this.minutes + "M"), (this.seconds !== 0 || this.milliseconds !== 0) && (e += Au(this.seconds + this.milliseconds / 1e3, 3) + "S"), e === "P" && (e += "T0S"), e;
    }
    /**
     * Returns an ISO 8601-compliant string representation of this Duration, formatted as a time of day.
     * Note that this will return null if the duration is invalid, negative, or equal to or greater than 24 hours.
     * @see https://en.wikipedia.org/wiki/ISO_8601#Times
     * @param {Object} opts - options
     * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
     * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
     * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
     * @param {string} [opts.format='extended'] - choose between the basic and extended format
     * @example Duration.fromObject({ hours: 11 }).toISOTime() //=> '11:00:00.000'
     * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressMilliseconds: true }) //=> '11:00:00'
     * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressSeconds: true }) //=> '11:00'
     * @example Duration.fromObject({ hours: 11 }).toISOTime({ includePrefix: true }) //=> 'T11:00:00.000'
     * @example Duration.fromObject({ hours: 11 }).toISOTime({ format: 'basic' }) //=> '110000.000'
     * @return {string}
     */
    toISOTime(e = {}) {
      if (!this.isValid) return null;
      const t = this.toMillis();
      return t < 0 || t >= 864e5 ? null : (e = {
        suppressMilliseconds: !1,
        suppressSeconds: !1,
        includePrefix: !1,
        format: "extended",
        ...e,
        includeOffset: !1
      }, z.fromMillis(t, { zone: "UTC" }).toISOTime(e));
    }
    /**
     * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.
     * @return {string}
     */
    toJSON() {
      return this.toISO();
    }
    /**
     * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.
     * @return {string}
     */
    toString() {
      return this.toISO();
    }
    /**
     * Returns a string representation of this Duration appropriate for the REPL.
     * @return {string}
     */
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return this.isValid ? `Duration { values: ${JSON.stringify(this.values)} }` : `Duration { Invalid, reason: ${this.invalidReason} }`;
    }
    /**
     * Returns an milliseconds value of this Duration.
     * @return {number}
     */
    toMillis() {
      return this.isValid ? sv(this.matrix, this.values) : NaN;
    }
    /**
     * Returns an milliseconds value of this Duration. Alias of {@link toMillis}
     * @return {number}
     */
    valueOf() {
      return this.toMillis();
    }
    /**
     * Make this Duration longer by the specified amount. Return a newly-constructed Duration.
     * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
     * @return {Duration}
     */
    plus(e) {
      if (!this.isValid) return this;
      const t = oe.fromDurationLike(e), i = {};
      for (const o of yi)
        (No(t.values, o) || No(this.values, o)) && (i[o] = t.get(o) + this.get(o));
      return _r(this, { values: i }, !0);
    }
    /**
     * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.
     * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
     * @return {Duration}
     */
    minus(e) {
      if (!this.isValid) return this;
      const t = oe.fromDurationLike(e);
      return this.plus(t.negate());
    }
    /**
     * Scale this Duration by the specified amount. Return a newly-constructed Duration.
     * @param {function} fn - The function to apply to each unit. Arity is 1 or 2: the value of the unit and, optionally, the unit name. Must return a number.
     * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits(x => x * 2) //=> { hours: 2, minutes: 60 }
     * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits((x, u) => u === "hours" ? x * 2 : x) //=> { hours: 2, minutes: 30 }
     * @return {Duration}
     */
    mapUnits(e) {
      if (!this.isValid) return this;
      const t = {};
      for (const i of Object.keys(this.values))
        t[i] = q_(e(this.values[i], i));
      return _r(this, { values: t }, !0);
    }
    /**
     * Get the value of unit.
     * @param {string} unit - a unit such as 'minute' or 'day'
     * @example Duration.fromObject({years: 2, days: 3}).get('years') //=> 2
     * @example Duration.fromObject({years: 2, days: 3}).get('months') //=> 0
     * @example Duration.fromObject({years: 2, days: 3}).get('days') //=> 3
     * @return {number}
     */
    get(e) {
      return this[oe.normalizeUnit(e)];
    }
    /**
     * "Set" the values of specified units. Return a newly-constructed Duration.
     * @param {Object} values - a mapping of units to numbers
     * @example dur.set({ years: 2017 })
     * @example dur.set({ hours: 8, minutes: 30 })
     * @return {Duration}
     */
    set(e) {
      if (!this.isValid) return this;
      const t = { ...this.values, ...Pa(e, oe.normalizeUnit) };
      return _r(this, { values: t });
    }
    /**
     * "Set" the locale and/or numberingSystem.  Returns a newly-constructed Duration.
     * @example dur.reconfigure({ locale: 'en-GB' })
     * @return {Duration}
     */
    reconfigure({ locale: e, numberingSystem: t, conversionAccuracy: i, matrix: o } = {}) {
      const l = { loc: this.loc.clone({ locale: e, numberingSystem: t }), matrix: o, conversionAccuracy: i };
      return _r(this, l);
    }
    /**
     * Return the length of the duration in the specified unit.
     * @param {string} unit - a unit such as 'minutes' or 'days'
     * @example Duration.fromObject({years: 1}).as('days') //=> 365
     * @example Duration.fromObject({years: 1}).as('months') //=> 12
     * @example Duration.fromObject({hours: 60}).as('days') //=> 2.5
     * @return {number}
     */
    as(e) {
      return this.isValid ? this.shiftTo(e).get(e) : NaN;
    }
    /**
     * Reduce this Duration to its canonical representation in its current units.
     * Assuming the overall value of the Duration is positive, this means:
     * - excessive values for lower-order units are converted to higher-order units (if possible, see first and second example)
     * - negative lower-order units are converted to higher order units (there must be such a higher order unit, otherwise
     *   the overall value would be negative, see third example)
     * - fractional values for higher-order units are converted to lower-order units (if possible, see fourth example)
     *
     * If the overall value is negative, the result of this method is equivalent to `this.negate().normalize().negate()`.
     * @example Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }
     * @example Duration.fromObject({ days: 5000 }).normalize().toObject() //=> { days: 5000 }
     * @example Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }
     * @example Duration.fromObject({ years: 2.5, days: 0, hours: 0 }).normalize().toObject() //=> { years: 2, days: 182, hours: 12 }
     * @return {Duration}
     */
    normalize() {
      if (!this.isValid) return this;
      const e = this.toObject();
      return tm(this.matrix, e), _r(this, { values: e }, !0);
    }
    /**
     * Rescale units to its largest representation
     * @example Duration.fromObject({ milliseconds: 90000 }).rescale().toObject() //=> { minutes: 1, seconds: 30 }
     * @return {Duration}
     */
    rescale() {
      if (!this.isValid) return this;
      const e = rm(this.normalize().shiftToAll().toObject());
      return _r(this, { values: e }, !0);
    }
    /**
     * Convert this Duration into its representation in a different set of units.
     * @example Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }
     * @return {Duration}
     */
    shiftTo(...e) {
      if (!this.isValid) return this;
      if (e.length === 0)
        return this;
      e = e.map((l) => oe.normalizeUnit(l));
      const t = {}, i = {}, o = this.toObject();
      let a;
      for (const l of yi)
        if (e.indexOf(l) >= 0) {
          a = l;
          let d = 0;
          for (const f in i)
            d += this.matrix[f][l] * i[f], i[f] = 0;
          jr(o[l]) && (d += o[l]);
          const u = Math.trunc(d);
          t[l] = u, i[l] = (d * 1e3 - u * 1e3) / 1e3;
        } else jr(o[l]) && (i[l] = o[l]);
      for (const l in i)
        i[l] !== 0 && (t[a] += l === a ? i[l] : i[l] / this.matrix[a][l]);
      return tm(this.matrix, t), _r(this, { values: t }, !0);
    }
    /**
     * Shift this Duration to all available units.
     * Same as shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds")
     * @return {Duration}
     */
    shiftToAll() {
      return this.isValid ? this.shiftTo(
        "years",
        "months",
        "weeks",
        "days",
        "hours",
        "minutes",
        "seconds",
        "milliseconds"
      ) : this;
    }
    /**
     * Return the negative of this Duration.
     * @example Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }
     * @return {Duration}
     */
    negate() {
      if (!this.isValid) return this;
      const e = {};
      for (const t of Object.keys(this.values))
        e[t] = this.values[t] === 0 ? 0 : -this.values[t];
      return _r(this, { values: e }, !0);
    }
    /**
     * Removes all units with values equal to 0 from this Duration.
     * @example Duration.fromObject({ years: 2, days: 0, hours: 0, minutes: 0 }).removeZeros().toObject() //=> { years: 2 }
     * @return {Duration}
     */
    removeZeros() {
      if (!this.isValid) return this;
      const e = rm(this.values);
      return _r(this, { values: e }, !0);
    }
    /**
     * Get the years.
     * @type {number}
     */
    get years() {
      return this.isValid ? this.values.years || 0 : NaN;
    }
    /**
     * Get the quarters.
     * @type {number}
     */
    get quarters() {
      return this.isValid ? this.values.quarters || 0 : NaN;
    }
    /**
     * Get the months.
     * @type {number}
     */
    get months() {
      return this.isValid ? this.values.months || 0 : NaN;
    }
    /**
     * Get the weeks
     * @type {number}
     */
    get weeks() {
      return this.isValid ? this.values.weeks || 0 : NaN;
    }
    /**
     * Get the days.
     * @type {number}
     */
    get days() {
      return this.isValid ? this.values.days || 0 : NaN;
    }
    /**
     * Get the hours.
     * @type {number}
     */
    get hours() {
      return this.isValid ? this.values.hours || 0 : NaN;
    }
    /**
     * Get the minutes.
     * @type {number}
     */
    get minutes() {
      return this.isValid ? this.values.minutes || 0 : NaN;
    }
    /**
     * Get the seconds.
     * @return {number}
     */
    get seconds() {
      return this.isValid ? this.values.seconds || 0 : NaN;
    }
    /**
     * Get the milliseconds.
     * @return {number}
     */
    get milliseconds() {
      return this.isValid ? this.values.milliseconds || 0 : NaN;
    }
    /**
     * Returns whether the Duration is invalid. Invalid durations are returned by diff operations
     * on invalid DateTimes or Intervals.
     * @return {boolean}
     */
    get isValid() {
      return this.invalid === null;
    }
    /**
     * Returns an error code if this Duration became invalid, or null if the Duration is valid
     * @return {string}
     */
    get invalidReason() {
      return this.invalid ? this.invalid.reason : null;
    }
    /**
     * Returns an explanation of why this Duration became invalid, or null if the Duration is valid
     * @type {string}
     */
    get invalidExplanation() {
      return this.invalid ? this.invalid.explanation : null;
    }
    /**
     * Equality check
     * Two Durations are equal iff they have the same units and the same values for each unit.
     * @param {Duration} other
     * @return {boolean}
     */
    equals(e) {
      if (!this.isValid || !e.isValid || !this.loc.equals(e.loc))
        return !1;
      function t(i, o) {
        return i === void 0 || i === 0 ? o === void 0 || o === 0 : i === o;
      }
      for (const i of yi)
        if (!t(this.values[i], e.values[i]))
          return !1;
      return !0;
    }
  }
  const Xi = "Invalid Interval";
  function jD(r, e) {
    return !r || !r.isValid ? xe.invalid("missing or invalid start") : !e || !e.isValid ? xe.invalid("missing or invalid end") : e < r ? xe.invalid(
      "end before start",
      `The end of an interval must be after its start, but you had start=${r.toISO()} and end=${e.toISO()}`
    ) : null;
  }
  class xe {
    /**
     * @private
     */
    constructor(e) {
      this.s = e.start, this.e = e.end, this.invalid = e.invalid || null, this.isLuxonInterval = !0;
    }
    /**
     * Create an invalid Interval.
     * @param {string} reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent
     * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
     * @return {Interval}
     */
    static invalid(e, t = null) {
      if (!e)
        throw new qe("need to specify a reason the Interval is invalid");
      const i = e instanceof Yt ? e : new Yt(e, t);
      if (Ce.throwOnInvalid)
        throw new _O(i);
      return new xe({ invalid: i });
    }
    /**
     * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.
     * @param {DateTime|Date|Object} start
     * @param {DateTime|Date|Object} end
     * @return {Interval}
     */
    static fromDateTimes(e, t) {
      const i = bn(e), o = bn(t), a = jD(i, o);
      return a ?? new xe({
        start: i,
        end: o
      });
    }
    /**
     * Create an Interval from a start DateTime and a Duration to extend to.
     * @param {DateTime|Date|Object} start
     * @param {Duration|Object|number} duration - the length of the Interval.
     * @return {Interval}
     */
    static after(e, t) {
      const i = oe.fromDurationLike(t), o = bn(e);
      return xe.fromDateTimes(o, o.plus(i));
    }
    /**
     * Create an Interval from an end DateTime and a Duration to extend backwards to.
     * @param {DateTime|Date|Object} end
     * @param {Duration|Object|number} duration - the length of the Interval.
     * @return {Interval}
     */
    static before(e, t) {
      const i = oe.fromDurationLike(t), o = bn(e);
      return xe.fromDateTimes(o.minus(i), o);
    }
    /**
     * Create an Interval from an ISO 8601 string.
     * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.
     * @param {string} text - the ISO string to parse
     * @param {Object} [opts] - options to pass {@link DateTime#fromISO} and optionally {@link Duration#fromISO}
     * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
     * @return {Interval}
     */
    static fromISO(e, t) {
      const [i, o] = (e || "").split("/", 2);
      if (i && o) {
        let a, l;
        try {
          a = z.fromISO(i, t), l = a.isValid;
        } catch {
          l = !1;
        }
        let d, u;
        try {
          d = z.fromISO(o, t), u = d.isValid;
        } catch {
          u = !1;
        }
        if (l && u)
          return xe.fromDateTimes(a, d);
        if (l) {
          const f = oe.fromISO(o, t);
          if (f.isValid)
            return xe.after(a, f);
        } else if (u) {
          const f = oe.fromISO(i, t);
          if (f.isValid)
            return xe.before(d, f);
        }
      }
      return xe.invalid("unparsable", `the input "${e}" can't be parsed as ISO 8601`);
    }
    /**
     * Check if an object is an Interval. Works across context boundaries
     * @param {object} o
     * @return {boolean}
     */
    static isInterval(e) {
      return e && e.isLuxonInterval || !1;
    }
    /**
     * Returns the start of the Interval
     * @type {DateTime}
     */
    get start() {
      return this.isValid ? this.s : null;
    }
    /**
     * Returns the end of the Interval. This is the first instant which is not part of the interval
     * (Interval is half-open).
     * @type {DateTime}
     */
    get end() {
      return this.isValid ? this.e : null;
    }
    /**
     * Returns the last DateTime included in the interval (since end is not part of the interval)
     * @type {DateTime}
     */
    get lastDateTime() {
      return this.isValid && this.e ? this.e.minus(1) : null;
    }
    /**
     * Returns whether this Interval's end is at least its start, meaning that the Interval isn't 'backwards'.
     * @type {boolean}
     */
    get isValid() {
      return this.invalidReason === null;
    }
    /**
     * Returns an error code if this Interval is invalid, or null if the Interval is valid
     * @type {string}
     */
    get invalidReason() {
      return this.invalid ? this.invalid.reason : null;
    }
    /**
     * Returns an explanation of why this Interval became invalid, or null if the Interval is valid
     * @type {string}
     */
    get invalidExplanation() {
      return this.invalid ? this.invalid.explanation : null;
    }
    /**
     * Returns the length of the Interval in the specified unit.
     * @param {string} unit - the unit (such as 'hours' or 'days') to return the length in.
     * @return {number}
     */
    length(e = "milliseconds") {
      return this.isValid ? this.toDuration(e).get(e) : NaN;
    }
    /**
     * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.
     * Unlike {@link Interval#length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'
     * asks 'what dates are included in this interval?', not 'how many days long is this interval?'
     * @param {string} [unit='milliseconds'] - the unit of time to count.
     * @param {Object} opts - options
     * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week; this operation will always use the locale of the start DateTime
     * @return {number}
     */
    count(e = "milliseconds", t) {
      if (!this.isValid) return NaN;
      const i = this.start.startOf(e, t);
      let o;
      return t?.useLocaleWeeks ? o = this.end.reconfigure({ locale: i.locale }) : o = this.end, o = o.startOf(e, t), Math.floor(o.diff(i, e).get(e)) + (o.valueOf() !== this.end.valueOf());
    }
    /**
     * Returns whether this Interval's start and end are both in the same unit of time
     * @param {string} unit - the unit of time to check sameness on
     * @return {boolean}
     */
    hasSame(e) {
      return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, e) : !1;
    }
    /**
     * Return whether this Interval has the same start and end DateTimes.
     * @return {boolean}
     */
    isEmpty() {
      return this.s.valueOf() === this.e.valueOf();
    }
    /**
     * Return whether this Interval's start is after the specified DateTime.
     * @param {DateTime} dateTime
     * @return {boolean}
     */
    isAfter(e) {
      return this.isValid ? this.s > e : !1;
    }
    /**
     * Return whether this Interval's end is before the specified DateTime.
     * @param {DateTime} dateTime
     * @return {boolean}
     */
    isBefore(e) {
      return this.isValid ? this.e <= e : !1;
    }
    /**
     * Return whether this Interval contains the specified DateTime.
     * @param {DateTime} dateTime
     * @return {boolean}
     */
    contains(e) {
      return this.isValid ? this.s <= e && this.e > e : !1;
    }
    /**
     * "Sets" the start and/or end dates. Returns a newly-constructed Interval.
     * @param {Object} values - the values to set
     * @param {DateTime} values.start - the starting DateTime
     * @param {DateTime} values.end - the ending DateTime
     * @return {Interval}
     */
    set({ start: e, end: t } = {}) {
      return this.isValid ? xe.fromDateTimes(e || this.s, t || this.e) : this;
    }
    /**
     * Split this Interval at each of the specified DateTimes
     * @param {...DateTime} dateTimes - the unit of time to count.
     * @return {Array}
     */
    splitAt(...e) {
      if (!this.isValid) return [];
      const t = e.map(bn).filter((l) => this.contains(l)).sort((l, d) => l.toMillis() - d.toMillis()), i = [];
      let { s: o } = this, a = 0;
      for (; o < this.e; ) {
        const l = t[a] || this.e, d = +l > +this.e ? this.e : l;
        i.push(xe.fromDateTimes(o, d)), o = d, a += 1;
      }
      return i;
    }
    /**
     * Split this Interval into smaller Intervals, each of the specified length.
     * Left over time is grouped into a smaller interval
     * @param {Duration|Object|number} duration - The length of each resulting interval.
     * @return {Array}
     */
    splitBy(e) {
      const t = oe.fromDurationLike(e);
      if (!this.isValid || !t.isValid || t.as("milliseconds") === 0)
        return [];
      let { s: i } = this, o = 1, a;
      const l = [];
      for (; i < this.e; ) {
        const d = this.start.plus(t.mapUnits((u) => u * o));
        a = +d > +this.e ? this.e : d, l.push(xe.fromDateTimes(i, a)), i = a, o += 1;
      }
      return l;
    }
    /**
     * Split this Interval into the specified number of smaller intervals.
     * @param {number} numberOfParts - The number of Intervals to divide the Interval into.
     * @return {Array}
     */
    divideEqually(e) {
      return this.isValid ? this.splitBy(this.length() / e).slice(0, e) : [];
    }
    /**
     * Return whether this Interval overlaps with the specified Interval
     * @param {Interval} other
     * @return {boolean}
     */
    overlaps(e) {
      return this.e > e.s && this.s < e.e;
    }
    /**
     * Return whether this Interval's end is adjacent to the specified Interval's start.
     * @param {Interval} other
     * @return {boolean}
     */
    abutsStart(e) {
      return this.isValid ? +this.e == +e.s : !1;
    }
    /**
     * Return whether this Interval's start is adjacent to the specified Interval's end.
     * @param {Interval} other
     * @return {boolean}
     */
    abutsEnd(e) {
      return this.isValid ? +e.e == +this.s : !1;
    }
    /**
     * Returns true if this Interval fully contains the specified Interval, specifically if the intersect (of this Interval and the other Interval) is equal to the other Interval; false otherwise.
     * @param {Interval} other
     * @return {boolean}
     */
    engulfs(e) {
      return this.isValid ? this.s <= e.s && this.e >= e.e : !1;
    }
    /**
     * Return whether this Interval has the same start and end as the specified Interval.
     * @param {Interval} other
     * @return {boolean}
     */
    equals(e) {
      return !this.isValid || !e.isValid ? !1 : this.s.equals(e.s) && this.e.equals(e.e);
    }
    /**
     * Return an Interval representing the intersection of this Interval and the specified Interval.
     * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.
     * Returns null if the intersection is empty, meaning, the intervals don't intersect.
     * @param {Interval} other
     * @return {Interval}
     */
    intersection(e) {
      if (!this.isValid) return this;
      const t = this.s > e.s ? this.s : e.s, i = this.e < e.e ? this.e : e.e;
      return t >= i ? null : xe.fromDateTimes(t, i);
    }
    /**
     * Return an Interval representing the union of this Interval and the specified Interval.
     * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.
     * @param {Interval} other
     * @return {Interval}
     */
    union(e) {
      if (!this.isValid) return this;
      const t = this.s < e.s ? this.s : e.s, i = this.e > e.e ? this.e : e.e;
      return xe.fromDateTimes(t, i);
    }
    /**
     * Merge an array of Intervals into an equivalent minimal set of Intervals.
     * Combines overlapping and adjacent Intervals.
     * The resulting array will contain the Intervals in ascending order, that is, starting with the earliest Interval
     * and ending with the latest.
     *
     * @param {Array} intervals
     * @return {Array}
     */
    static merge(e) {
      const [t, i] = e.sort((o, a) => o.s - a.s).reduce(
        ([o, a], l) => a ? a.overlaps(l) || a.abutsStart(l) ? [o, a.union(l)] : [o.concat([a]), l] : [o, l],
        [[], null]
      );
      return i && t.push(i), t;
    }
    /**
     * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.
     * @param {Array} intervals
     * @return {Array}
     */
    static xor(e) {
      let t = null, i = 0;
      const o = [], a = e.map((u) => [
        { time: u.s, type: "s" },
        { time: u.e, type: "e" }
      ]), l = Array.prototype.concat(...a), d = l.sort((u, f) => u.time - f.time);
      for (const u of d)
        i += u.type === "s" ? 1 : -1, i === 1 ? t = u.time : (t && +t != +u.time && o.push(xe.fromDateTimes(t, u.time)), t = null);
      return xe.merge(o);
    }
    /**
     * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.
     * @param {...Interval} intervals
     * @return {Array}
     */
    difference(...e) {
      return xe.xor([this].concat(e)).map((t) => this.intersection(t)).filter((t) => t && !t.isEmpty());
    }
    /**
     * Returns a string representation of this Interval appropriate for debugging.
     * @return {string}
     */
    toString() {
      return this.isValid ? `[${this.s.toISO()} – ${this.e.toISO()})` : Xi;
    }
    /**
     * Returns a string representation of this Interval appropriate for the REPL.
     * @return {string}
     */
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return this.isValid ? `Interval { start: ${this.s.toISO()}, end: ${this.e.toISO()} }` : `Interval { Invalid, reason: ${this.invalidReason} }`;
    }
    /**
     * Returns a localized string representing this Interval. Accepts the same options as the
     * Intl.DateTimeFormat constructor and any presets defined by Luxon, such as
     * {@link DateTime.DATE_FULL} or {@link DateTime.TIME_SIMPLE}. The exact behavior of this method
     * is browser-specific, but in general it will return an appropriate representation of the
     * Interval in the assigned locale. Defaults to the system's locale if no locale has been
     * specified.
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
     * @param {Object} [formatOpts=DateTime.DATE_SHORT] - Either a DateTime preset or
     * Intl.DateTimeFormat constructor options.
     * @param {Object} opts - Options to override the configuration of the start DateTime.
     * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(); //=> 11/7/2022 – 11/8/2022
     * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL); //=> November 7 – 8, 2022
     * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL, { locale: 'fr-FR' }); //=> 7–8 novembre 2022
     * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString(DateTime.TIME_SIMPLE); //=> 6:00 – 8:00 PM
     * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> Mon, Nov 07, 6:00 – 8:00 p
     * @return {string}
     */
    toLocaleString(e = Ta, t = {}) {
      return this.isValid ? Ge.create(this.s.loc.clone(t), e).formatInterval(this) : Xi;
    }
    /**
     * Returns an ISO 8601-compliant string representation of this Interval.
     * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
     * @param {Object} opts - The same options as {@link DateTime#toISO}
     * @return {string}
     */
    toISO(e) {
      return this.isValid ? `${this.s.toISO(e)}/${this.e.toISO(e)}` : Xi;
    }
    /**
     * Returns an ISO 8601-compliant string representation of date of this Interval.
     * The time components are ignored.
     * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
     * @return {string}
     */
    toISODate() {
      return this.isValid ? `${this.s.toISODate()}/${this.e.toISODate()}` : Xi;
    }
    /**
     * Returns an ISO 8601-compliant string representation of time of this Interval.
     * The date components are ignored.
     * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
     * @param {Object} opts - The same options as {@link DateTime#toISO}
     * @return {string}
     */
    toISOTime(e) {
      return this.isValid ? `${this.s.toISOTime(e)}/${this.e.toISOTime(e)}` : Xi;
    }
    /**
     * Returns a string representation of this Interval formatted according to the specified format
     * string. **You may not want this.** See {@link Interval#toLocaleString} for a more flexible
     * formatting tool.
     * @param {string} dateFormat - The format string. This string formats the start and end time.
     * See {@link DateTime#toFormat} for details.
     * @param {Object} opts - Options.
     * @param {string} [opts.separator =  ' – '] - A separator to place between the start and end
     * representations.
     * @return {string}
     */
    toFormat(e, { separator: t = " – " } = {}) {
      return this.isValid ? `${this.s.toFormat(e)}${t}${this.e.toFormat(e)}` : Xi;
    }
    /**
     * Return a Duration representing the time spanned by this interval.
     * @param {string|string[]} [unit=['milliseconds']] - the unit or units (such as 'hours' or 'days') to include in the duration.
     * @param {Object} opts - options that affect the creation of the Duration
     * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
     * @example Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }
     * @example Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }
     * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }
     * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }
     * @example Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }
     * @return {Duration}
     */
    toDuration(e, t) {
      return this.isValid ? this.e.diff(this.s, e, t) : oe.invalid(this.invalidReason);
    }
    /**
     * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes
     * @param {function} mapFn
     * @return {Interval}
     * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())
     * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))
     */
    mapEndpoints(e) {
      return xe.fromDateTimes(e(this.s), e(this.e));
    }
  }
  class ea {
    /**
     * Return whether the specified zone contains a DST.
     * @param {string|Zone} [zone='local'] - Zone to check. Defaults to the environment's local zone.
     * @return {boolean}
     */
    static hasDST(e = Ce.defaultZone) {
      const t = z.now().setZone(e).set({ month: 12 });
      return !e.isUniversal && t.offset !== t.set({ month: 6 }).offset;
    }
    /**
     * Return whether the specified zone is a valid IANA specifier.
     * @param {string} zone - Zone to check
     * @return {boolean}
     */
    static isValidIANAZone(e) {
      return Cr.isValidZone(e);
    }
    /**
     * Converts the input into a {@link Zone} instance.
     *
     * * If `input` is already a Zone instance, it is returned unchanged.
     * * If `input` is a string containing a valid time zone name, a Zone instance
     *   with that name is returned.
     * * If `input` is a string that doesn't refer to a known time zone, a Zone
     *   instance with {@link Zone#isValid} == false is returned.
     * * If `input is a number, a Zone instance with the specified fixed offset
     *   in minutes is returned.
     * * If `input` is `null` or `undefined`, the default zone is returned.
     * @param {string|Zone|number} [input] - the value to be converted
     * @return {Zone}
     */
    static normalizeZone(e) {
      return Yr(e, Ce.defaultZone);
    }
    /**
     * Get the weekday on which the week starts according to the given locale.
     * @param {Object} opts - options
     * @param {string} [opts.locale] - the locale code
     * @param {string} [opts.locObj=null] - an existing locale object to use
     * @returns {number} the start of the week, 1 for Monday through 7 for Sunday
     */
    static getStartOfWeek({ locale: e = null, locObj: t = null } = {}) {
      return (t || ce.create(e)).getStartOfWeek();
    }
    /**
     * Get the minimum number of days necessary in a week before it is considered part of the next year according
     * to the given locale.
     * @param {Object} opts - options
     * @param {string} [opts.locale] - the locale code
     * @param {string} [opts.locObj=null] - an existing locale object to use
     * @returns {number}
     */
    static getMinimumDaysInFirstWeek({ locale: e = null, locObj: t = null } = {}) {
      return (t || ce.create(e)).getMinDaysInFirstWeek();
    }
    /**
     * Get the weekdays, which are considered the weekend according to the given locale
     * @param {Object} opts - options
     * @param {string} [opts.locale] - the locale code
     * @param {string} [opts.locObj=null] - an existing locale object to use
     * @returns {number[]} an array of weekdays, 1 for Monday through 7 for Sunday
     */
    static getWeekendWeekdays({ locale: e = null, locObj: t = null } = {}) {
      return (t || ce.create(e)).getWeekendDays().slice();
    }
    /**
     * Return an array of standalone month names.
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
     * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
     * @param {Object} opts - options
     * @param {string} [opts.locale] - the locale code
     * @param {string} [opts.numberingSystem=null] - the numbering system
     * @param {string} [opts.locObj=null] - an existing locale object to use
     * @param {string} [opts.outputCalendar='gregory'] - the calendar
     * @example Info.months()[0] //=> 'January'
     * @example Info.months('short')[0] //=> 'Jan'
     * @example Info.months('numeric')[0] //=> '1'
     * @example Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'
     * @example Info.months('numeric', { locale: 'ar' })[0] //=> '١'
     * @example Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabiʻ I'
     * @return {Array}
     */
    static months(e = "long", { locale: t = null, numberingSystem: i = null, locObj: o = null, outputCalendar: a = "gregory" } = {}) {
      return (o || ce.create(t, i, a)).months(e);
    }
    /**
     * Return an array of format month names.
     * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that
     * changes the string.
     * See {@link Info#months}
     * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
     * @param {Object} opts - options
     * @param {string} [opts.locale] - the locale code
     * @param {string} [opts.numberingSystem=null] - the numbering system
     * @param {string} [opts.locObj=null] - an existing locale object to use
     * @param {string} [opts.outputCalendar='gregory'] - the calendar
     * @return {Array}
     */
    static monthsFormat(e = "long", { locale: t = null, numberingSystem: i = null, locObj: o = null, outputCalendar: a = "gregory" } = {}) {
      return (o || ce.create(t, i, a)).months(e, !0);
    }
    /**
     * Return an array of standalone week names.
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
     * @param {string} [length='long'] - the length of the weekday representation, such as "narrow", "short", "long".
     * @param {Object} opts - options
     * @param {string} [opts.locale] - the locale code
     * @param {string} [opts.numberingSystem=null] - the numbering system
     * @param {string} [opts.locObj=null] - an existing locale object to use
     * @example Info.weekdays()[0] //=> 'Monday'
     * @example Info.weekdays('short')[0] //=> 'Mon'
     * @example Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'
     * @example Info.weekdays('short', { locale: 'ar' })[0] //=> 'الاثنين'
     * @return {Array}
     */
    static weekdays(e = "long", { locale: t = null, numberingSystem: i = null, locObj: o = null } = {}) {
      return (o || ce.create(t, i, null)).weekdays(e);
    }
    /**
     * Return an array of format week names.
     * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that
     * changes the string.
     * See {@link Info#weekdays}
     * @param {string} [length='long'] - the length of the month representation, such as "narrow", "short", "long".
     * @param {Object} opts - options
     * @param {string} [opts.locale=null] - the locale code
     * @param {string} [opts.numberingSystem=null] - the numbering system
     * @param {string} [opts.locObj=null] - an existing locale object to use
     * @return {Array}
     */
    static weekdaysFormat(e = "long", { locale: t = null, numberingSystem: i = null, locObj: o = null } = {}) {
      return (o || ce.create(t, i, null)).weekdays(e, !0);
    }
    /**
     * Return an array of meridiems.
     * @param {Object} opts - options
     * @param {string} [opts.locale] - the locale code
     * @example Info.meridiems() //=> [ 'AM', 'PM' ]
     * @example Info.meridiems({ locale: 'my' }) //=> [ 'နံနက်', 'ညနေ' ]
     * @return {Array}
     */
    static meridiems({ locale: e = null } = {}) {
      return ce.create(e).meridiems();
    }
    /**
     * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.
     * @param {string} [length='short'] - the length of the era representation, such as "short" or "long".
     * @param {Object} opts - options
     * @param {string} [opts.locale] - the locale code
     * @example Info.eras() //=> [ 'BC', 'AD' ]
     * @example Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]
     * @example Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jésus-Christ', 'après Jésus-Christ' ]
     * @return {Array}
     */
    static eras(e = "short", { locale: t = null } = {}) {
      return ce.create(t, null, "gregory").eras(e);
    }
    /**
     * Return the set of available features in this environment.
     * Some features of Luxon are not available in all environments. For example, on older browsers, relative time formatting support is not available. Use this function to figure out if that's the case.
     * Keys:
     * * `relative`: whether this environment supports relative time formatting
     * * `localeWeek`: whether this environment supports different weekdays for the start of the week based on the locale
     * @example Info.features() //=> { relative: false, localeWeek: true }
     * @return {Object}
     */
    static features() {
      return { relative: W_(), localeWeek: B_() };
    }
  }
  function im(r, e) {
    const t = (o) => o.toUTC(0, { keepLocalTime: !0 }).startOf("day").valueOf(), i = t(e) - t(r);
    return Math.floor(oe.fromMillis(i).as("days"));
  }
  function ZD(r, e, t) {
    const i = [
      ["years", (u, f) => f.year - u.year],
      ["quarters", (u, f) => f.quarter - u.quarter + (f.year - u.year) * 4],
      ["months", (u, f) => f.month - u.month + (f.year - u.year) * 12],
      [
        "weeks",
        (u, f) => {
          const g = im(u, f);
          return (g - g % 7) / 7;
        }
      ],
      ["days", im]
    ], o = {}, a = r;
    let l, d;
    for (const [u, f] of i)
      t.indexOf(u) >= 0 && (l = u, o[u] = f(r, e), d = a.plus(o), d > e ? (o[u]--, r = a.plus(o), r > e && (d = r, o[u]--, r = a.plus(o))) : r = d);
    return [r, o, d, l];
  }
  function KD(r, e, t, i) {
    let [o, a, l, d] = ZD(r, e, t);
    const u = e - o, f = t.filter(
      (_) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(_) >= 0
    );
    f.length === 0 && (l < e && (l = o.plus({ [d]: 1 })), l !== o && (a[d] = (a[d] || 0) + u / (l - o)));
    const g = oe.fromObject(a, i);
    return f.length > 0 ? oe.fromMillis(u, i).shiftTo(...f).plus(g) : g;
  }
  const JD = "missing Intl.DateTimeFormat.formatToParts support";
  function ae(r, e = (t) => t) {
    return { regex: r, deser: ([t]) => e(UO(t)) };
  }
  const XD = " ", av = `[ ${XD}]`, lv = new RegExp(av, "g");
  function QD(r) {
    return r.replace(/\./g, "\\.?").replace(lv, av);
  }
  function om(r) {
    return r.replace(/\./g, "").replace(lv, " ").toLowerCase();
  }
  function qt(r, e) {
    return r === null ? null : {
      regex: RegExp(r.map(QD).join("|")),
      deser: ([t]) => r.findIndex((i) => om(t) === om(i)) + e
    };
  }
  function nm(r, e) {
    return { regex: r, deser: ([, t, i]) => Ya(t, i), groups: e };
  }
  function ta(r) {
    return { regex: r, deser: ([e]) => e };
  }
  function e2(r) {
    return r.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
  }
  function t2(r, e) {
    const t = Vt(e), i = Vt(e, "{2}"), o = Vt(e, "{3}"), a = Vt(e, "{4}"), l = Vt(e, "{6}"), d = Vt(e, "{1,2}"), u = Vt(e, "{1,3}"), f = Vt(e, "{1,6}"), g = Vt(e, "{1,9}"), _ = Vt(e, "{2,4}"), C = Vt(e, "{4,6}"), x = (I) => ({ regex: RegExp(e2(I.val)), deser: ([F]) => F, literal: !0 }), P = ((I) => {
      if (r.literal)
        return x(I);
      switch (I.val) {
        // era
        case "G":
          return qt(e.eras("short"), 0);
        case "GG":
          return qt(e.eras("long"), 0);
        // years
        case "y":
          return ae(f);
        case "yy":
          return ae(_, Fd);
        case "yyyy":
          return ae(a);
        case "yyyyy":
          return ae(C);
        case "yyyyyy":
          return ae(l);
        // months
        case "M":
          return ae(d);
        case "MM":
          return ae(i);
        case "MMM":
          return qt(e.months("short", !0), 1);
        case "MMMM":
          return qt(e.months("long", !0), 1);
        case "L":
          return ae(d);
        case "LL":
          return ae(i);
        case "LLL":
          return qt(e.months("short", !1), 1);
        case "LLLL":
          return qt(e.months("long", !1), 1);
        // dates
        case "d":
          return ae(d);
        case "dd":
          return ae(i);
        // ordinals
        case "o":
          return ae(u);
        case "ooo":
          return ae(o);
        // time
        case "HH":
          return ae(i);
        case "H":
          return ae(d);
        case "hh":
          return ae(i);
        case "h":
          return ae(d);
        case "mm":
          return ae(i);
        case "m":
          return ae(d);
        case "q":
          return ae(d);
        case "qq":
          return ae(i);
        case "s":
          return ae(d);
        case "ss":
          return ae(i);
        case "S":
          return ae(u);
        case "SSS":
          return ae(o);
        case "u":
          return ta(g);
        case "uu":
          return ta(d);
        case "uuu":
          return ae(t);
        // meridiem
        case "a":
          return qt(e.meridiems(), 0);
        // weekYear (k)
        case "kkkk":
          return ae(a);
        case "kk":
          return ae(_, Fd);
        // weekNumber (W)
        case "W":
          return ae(d);
        case "WW":
          return ae(i);
        // weekdays
        case "E":
        case "c":
          return ae(t);
        case "EEE":
          return qt(e.weekdays("short", !1), 1);
        case "EEEE":
          return qt(e.weekdays("long", !1), 1);
        case "ccc":
          return qt(e.weekdays("short", !0), 1);
        case "cccc":
          return qt(e.weekdays("long", !0), 1);
        // offset/zone
        case "Z":
        case "ZZ":
          return nm(new RegExp(`([+-]${d.source})(?::(${i.source}))?`), 2);
        case "ZZZ":
          return nm(new RegExp(`([+-]${d.source})(${i.source})?`), 2);
        // we don't support ZZZZ (PST) or ZZZZZ (Pacific Standard Time) in parsing
        // because we don't have any way to figure out what they are
        case "z":
          return ta(/[a-z_+-/]{1,256}?/i);
        // this special-case "token" represents a place where a macro-token expanded into a white-space literal
        // in this case we accept any non-newline white-space
        case " ":
          return ta(/[^\S\n\r]/);
        default:
          return x(I);
      }
    })(r) || {
      invalidReason: JD
    };
    return P.token = r, P;
  }
  const r2 = {
    year: {
      "2-digit": "yy",
      numeric: "yyyyy"
    },
    month: {
      numeric: "M",
      "2-digit": "MM",
      short: "MMM",
      long: "MMMM"
    },
    day: {
      numeric: "d",
      "2-digit": "dd"
    },
    weekday: {
      short: "EEE",
      long: "EEEE"
    },
    dayperiod: "a",
    dayPeriod: "a",
    hour12: {
      numeric: "h",
      "2-digit": "hh"
    },
    hour24: {
      numeric: "H",
      "2-digit": "HH"
    },
    minute: {
      numeric: "m",
      "2-digit": "mm"
    },
    second: {
      numeric: "s",
      "2-digit": "ss"
    },
    timeZoneName: {
      long: "ZZZZZ",
      short: "ZZZ"
    }
  };
  function i2(r, e, t) {
    const { type: i, value: o } = r;
    if (i === "literal") {
      const u = /^\s+$/.test(o);
      return {
        literal: !u,
        val: u ? " " : o
      };
    }
    const a = e[i];
    let l = i;
    i === "hour" && (e.hour12 != null ? l = e.hour12 ? "hour12" : "hour24" : e.hourCycle != null ? e.hourCycle === "h11" || e.hourCycle === "h12" ? l = "hour12" : l = "hour24" : l = t.hour12 ? "hour12" : "hour24");
    let d = r2[l];
    if (typeof d == "object" && (d = d[a]), d)
      return {
        literal: !1,
        val: d
      };
  }
  function o2(r) {
    return [`^${r.map((t) => t.regex).reduce((t, i) => `${t}(${i.source})`, "")}$`, r];
  }
  function n2(r, e, t) {
    const i = r.match(e);
    if (i) {
      const o = {};
      let a = 1;
      for (const l in t)
        if (No(t, l)) {
          const d = t[l], u = d.groups ? d.groups + 1 : 1;
          !d.literal && d.token && (o[d.token.val[0]] = d.deser(i.slice(a, a + u))), a += u;
        }
      return [i, o];
    } else
      return [i, {}];
  }
  function s2(r) {
    const e = (a) => {
      switch (a) {
        case "S":
          return "millisecond";
        case "s":
          return "second";
        case "m":
          return "minute";
        case "h":
        case "H":
          return "hour";
        case "d":
          return "day";
        case "o":
          return "ordinal";
        case "L":
        case "M":
          return "month";
        case "y":
          return "year";
        case "E":
        case "c":
          return "weekday";
        case "W":
          return "weekNumber";
        case "k":
          return "weekYear";
        case "q":
          return "quarter";
        default:
          return null;
      }
    };
    let t = null, i;
    return q(r.z) || (t = Cr.create(r.z)), q(r.Z) || (t || (t = new et(r.Z)), i = r.Z), q(r.q) || (r.M = (r.q - 1) * 3 + 1), q(r.h) || (r.h < 12 && r.a === 1 ? r.h += 12 : r.h === 12 && r.a === 0 && (r.h = 0)), r.G === 0 && r.y && (r.y = -r.y), q(r.u) || (r.S = Su(r.u)), [Object.keys(r).reduce((a, l) => {
      const d = e(l);
      return d && (a[d] = r[l]), a;
    }, {}), t, i];
  }
  let jc = null;
  function a2() {
    return jc || (jc = z.fromMillis(1555555555555)), jc;
  }
  function l2(r, e) {
    if (r.literal)
      return r;
    const t = Ge.macroTokenToFormatOpts(r.val), i = hv(t, e);
    return i == null || i.includes(void 0) ? r : i;
  }
  function cv(r, e) {
    return Array.prototype.concat(...r.map((t) => l2(t, e)));
  }
  class dv {
    constructor(e, t) {
      if (this.locale = e, this.format = t, this.tokens = cv(Ge.parseFormat(t), e), this.units = this.tokens.map((i) => t2(i, e)), this.disqualifyingUnit = this.units.find((i) => i.invalidReason), !this.disqualifyingUnit) {
        const [i, o] = o2(this.units);
        this.regex = RegExp(i, "i"), this.handlers = o;
      }
    }
    explainFromTokens(e) {
      if (this.isValid) {
        const [t, i] = n2(e, this.regex, this.handlers), [o, a, l] = i ? s2(i) : [null, null, void 0];
        if (No(i, "a") && No(i, "H"))
          throw new oo(
            "Can't include meridiem when specifying 24-hour format"
          );
        return {
          input: e,
          tokens: this.tokens,
          regex: this.regex,
          rawMatches: t,
          matches: i,
          result: o,
          zone: a,
          specificOffset: l
        };
      } else
        return { input: e, tokens: this.tokens, invalidReason: this.invalidReason };
    }
    get isValid() {
      return !this.disqualifyingUnit;
    }
    get invalidReason() {
      return this.disqualifyingUnit ? this.disqualifyingUnit.invalidReason : null;
    }
  }
  function uv(r, e, t) {
    return new dv(r, t).explainFromTokens(e);
  }
  function c2(r, e, t) {
    const { result: i, zone: o, specificOffset: a, invalidReason: l } = uv(r, e, t);
    return [i, o, a, l];
  }
  function hv(r, e) {
    if (!r)
      return null;
    const i = Ge.create(e, r).dtFormatter(a2()), o = i.formatToParts(), a = i.resolvedOptions();
    return o.map((l) => i2(l, r, a));
  }
  const Zc = "Invalid DateTime", sm = 864e13;
  function kn(r) {
    return new Yt("unsupported zone", `the zone "${r.name}" is not supported`);
  }
  function Kc(r) {
    return r.weekData === null && (r.weekData = Oa(r.c)), r.weekData;
  }
  function Jc(r) {
    return r.localWeekData === null && (r.localWeekData = Oa(
      r.c,
      r.loc.getMinDaysInFirstWeek(),
      r.loc.getStartOfWeek()
    )), r.localWeekData;
  }
  function gi(r, e) {
    const t = {
      ts: r.ts,
      zone: r.zone,
      c: r.c,
      o: r.o,
      loc: r.loc,
      invalid: r.invalid
    };
    return new z({ ...t, ...e, old: t });
  }
  function fv(r, e, t) {
    let i = r - e * 60 * 1e3;
    const o = t.offset(i);
    if (e === o)
      return [i, e];
    i -= (o - e) * 60 * 1e3;
    const a = t.offset(i);
    return o === a ? [i, o] : [r - Math.min(o, a) * 60 * 1e3, Math.max(o, a)];
  }
  function ra(r, e) {
    r += e * 60 * 1e3;
    const t = new Date(r);
    return {
      year: t.getUTCFullYear(),
      month: t.getUTCMonth() + 1,
      day: t.getUTCDate(),
      hour: t.getUTCHours(),
      minute: t.getUTCMinutes(),
      second: t.getUTCSeconds(),
      millisecond: t.getUTCMilliseconds()
    };
  }
  function ha(r, e, t) {
    return fv(qa(r), e, t);
  }
  function am(r, e) {
    const t = r.o, i = r.c.year + Math.trunc(e.years), o = r.c.month + Math.trunc(e.months) + Math.trunc(e.quarters) * 3, a = {
      ...r.c,
      year: i,
      month: o,
      day: Math.min(r.c.day, Da(i, o)) + Math.trunc(e.days) + Math.trunc(e.weeks) * 7
    }, l = oe.fromObject({
      years: e.years - Math.trunc(e.years),
      quarters: e.quarters - Math.trunc(e.quarters),
      months: e.months - Math.trunc(e.months),
      weeks: e.weeks - Math.trunc(e.weeks),
      days: e.days - Math.trunc(e.days),
      hours: e.hours,
      minutes: e.minutes,
      seconds: e.seconds,
      milliseconds: e.milliseconds
    }).as("milliseconds"), d = qa(a);
    let [u, f] = fv(d, t, r.zone);
    return l !== 0 && (u += l, f = r.zone.offset(u)), { ts: u, o: f };
  }
  function Qi(r, e, t, i, o, a) {
    const { setZone: l, zone: d } = t;
    if (r && Object.keys(r).length !== 0 || e) {
      const u = e || d, f = z.fromObject(r, {
        ...t,
        zone: u,
        specificOffset: a
      });
      return l ? f : f.setZone(d);
    } else
      return z.invalid(
        new Yt("unparsable", `the input "${o}" can't be parsed as ${i}`)
      );
  }
  function ia(r, e, t = !0) {
    return r.isValid ? Ge.create(ce.create("en-US"), {
      allowZ: t,
      forceSimple: !0
    }).formatDateTimeFromString(r, e) : null;
  }
  function Xc(r, e, t) {
    const i = r.c.year > 9999 || r.c.year < 0;
    let o = "";
    if (i && r.c.year >= 0 && (o += "+"), o += $e(r.c.year, i ? 6 : 4), t === "year") return o;
    if (e) {
      if (o += "-", o += $e(r.c.month), t === "month") return o;
      o += "-";
    } else if (o += $e(r.c.month), t === "month") return o;
    return o += $e(r.c.day), o;
  }
  function lm(r, e, t, i, o, a, l) {
    let d = !t || r.c.millisecond !== 0 || r.c.second !== 0, u = "";
    switch (l) {
      case "day":
      case "month":
      case "year":
        break;
      default:
        if (u += $e(r.c.hour), l === "hour") break;
        if (e) {
          if (u += ":", u += $e(r.c.minute), l === "minute") break;
          d && (u += ":", u += $e(r.c.second));
        } else {
          if (u += $e(r.c.minute), l === "minute") break;
          d && (u += $e(r.c.second));
        }
        if (l === "second") break;
        d && (!i || r.c.millisecond !== 0) && (u += ".", u += $e(r.c.millisecond, 3));
    }
    return o && (r.isOffsetFixed && r.offset === 0 && !a ? u += "Z" : r.o < 0 ? (u += "-", u += $e(Math.trunc(-r.o / 60)), u += ":", u += $e(Math.trunc(-r.o % 60))) : (u += "+", u += $e(Math.trunc(r.o / 60)), u += ":", u += $e(Math.trunc(r.o % 60)))), a && (u += "[" + r.zone.ianaName + "]"), u;
  }
  const pv = {
    month: 1,
    day: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0
  }, d2 = {
    weekNumber: 1,
    weekday: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0
  }, u2 = {
    ordinal: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0
  }, fa = ["year", "month", "day", "hour", "minute", "second", "millisecond"], h2 = [
    "weekYear",
    "weekNumber",
    "weekday",
    "hour",
    "minute",
    "second",
    "millisecond"
  ], f2 = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
  function pa(r) {
    const e = {
      year: "year",
      years: "year",
      month: "month",
      months: "month",
      day: "day",
      days: "day",
      hour: "hour",
      hours: "hour",
      minute: "minute",
      minutes: "minute",
      quarter: "quarter",
      quarters: "quarter",
      second: "second",
      seconds: "second",
      millisecond: "millisecond",
      milliseconds: "millisecond",
      weekday: "weekday",
      weekdays: "weekday",
      weeknumber: "weekNumber",
      weeksnumber: "weekNumber",
      weeknumbers: "weekNumber",
      weekyear: "weekYear",
      weekyears: "weekYear",
      ordinal: "ordinal"
    }[r.toLowerCase()];
    if (!e) throw new p_(r);
    return e;
  }
  function cm(r) {
    switch (r.toLowerCase()) {
      case "localweekday":
      case "localweekdays":
        return "localWeekday";
      case "localweeknumber":
      case "localweeknumbers":
        return "localWeekNumber";
      case "localweekyear":
      case "localweekyears":
        return "localWeekYear";
      default:
        return pa(r);
    }
  }
  function p2(r) {
    if (xn === void 0 && (xn = Ce.now()), r.type !== "iana")
      return r.offset(xn);
    const e = r.name;
    let t = zd.get(e);
    return t === void 0 && (t = r.offset(xn), zd.set(e, t)), t;
  }
  function dm(r, e) {
    const t = Yr(e.zone, Ce.defaultZone);
    if (!t.isValid)
      return z.invalid(kn(t));
    const i = ce.fromObject(e);
    let o, a;
    if (q(r.year))
      o = Ce.now();
    else {
      for (const u of fa)
        q(r[u]) && (r[u] = pv[u]);
      const l = H_(r) || U_(r);
      if (l)
        return z.invalid(l);
      const d = p2(t);
      [o, a] = ha(r, d, t);
    }
    return new z({ ts: o, zone: t, loc: i, o: a });
  }
  function um(r, e, t) {
    const i = q(t.round) ? !0 : t.round, o = q(t.rounding) ? "trunc" : t.rounding, a = (d, u) => (d = Au(d, i || t.calendary ? 0 : 2, t.calendary ? "round" : o), e.loc.clone(t).relFormatter(t).format(d, u)), l = (d) => t.calendary ? e.hasSame(r, d) ? 0 : e.startOf(d).diff(r.startOf(d), d).get(d) : e.diff(r, d).get(d);
    if (t.unit)
      return a(l(t.unit), t.unit);
    for (const d of t.units) {
      const u = l(d);
      if (Math.abs(u) >= 1)
        return a(u, d);
    }
    return a(r > e ? -0 : 0, t.units[t.units.length - 1]);
  }
  function hm(r) {
    let e = {}, t;
    return r.length > 0 && typeof r[r.length - 1] == "object" ? (e = r[r.length - 1], t = Array.from(r).slice(0, r.length - 1)) : t = Array.from(r), [e, t];
  }
  let xn;
  const zd = /* @__PURE__ */ new Map();
  class z {
    /**
     * @access private
     */
    constructor(e) {
      const t = e.zone || Ce.defaultZone;
      let i = e.invalid || (Number.isNaN(e.ts) ? new Yt("invalid input") : null) || (t.isValid ? null : kn(t));
      this.ts = q(e.ts) ? Ce.now() : e.ts;
      let o = null, a = null;
      if (!i)
        if (e.old && e.old.ts === this.ts && e.old.zone.equals(t))
          [o, a] = [e.old.c, e.old.o];
        else {
          const d = jr(e.o) && !e.old ? e.o : t.offset(this.ts);
          o = ra(this.ts, d), i = Number.isNaN(o.year) ? new Yt("invalid input") : null, o = i ? null : o, a = i ? null : d;
        }
      this._zone = t, this.loc = e.loc || ce.create(), this.invalid = i, this.weekData = null, this.localWeekData = null, this.c = o, this.o = a, this.isLuxonDateTime = !0;
    }
    // CONSTRUCT
    /**
     * Create a DateTime for the current instant, in the system's time zone.
     *
     * Use Settings to override these default values if needed.
     * @example DateTime.now().toISO() //~> now in the ISO format
     * @return {DateTime}
     */
    static now() {
      return new z({});
    }
    /**
     * Create a local DateTime
     * @param {number} [year] - The calendar year. If omitted (as in, call `local()` with no arguments), the current time will be used
     * @param {number} [month=1] - The month, 1-indexed
     * @param {number} [day=1] - The day of the month, 1-indexed
     * @param {number} [hour=0] - The hour of the day, in 24-hour time
     * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
     * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
     * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
     * @example DateTime.local()                                  //~> now
     * @example DateTime.local({ zone: "America/New_York" })      //~> now, in US east coast time
     * @example DateTime.local(2017)                              //~> 2017-01-01T00:00:00
     * @example DateTime.local(2017, 3)                           //~> 2017-03-01T00:00:00
     * @example DateTime.local(2017, 3, 12, { locale: "fr" })     //~> 2017-03-12T00:00:00, with a French locale
     * @example DateTime.local(2017, 3, 12, 5)                    //~> 2017-03-12T05:00:00
     * @example DateTime.local(2017, 3, 12, 5, { zone: "utc" })   //~> 2017-03-12T05:00:00, in UTC
     * @example DateTime.local(2017, 3, 12, 5, 45)                //~> 2017-03-12T05:45:00
     * @example DateTime.local(2017, 3, 12, 5, 45, 10)            //~> 2017-03-12T05:45:10
     * @example DateTime.local(2017, 3, 12, 5, 45, 10, 765)       //~> 2017-03-12T05:45:10.765
     * @return {DateTime}
     */
    static local() {
      const [e, t] = hm(arguments), [i, o, a, l, d, u, f] = t;
      return dm({ year: i, month: o, day: a, hour: l, minute: d, second: u, millisecond: f }, e);
    }
    /**
     * Create a DateTime in UTC
     * @param {number} [year] - The calendar year. If omitted (as in, call `utc()` with no arguments), the current time will be used
     * @param {number} [month=1] - The month, 1-indexed
     * @param {number} [day=1] - The day of the month
     * @param {number} [hour=0] - The hour of the day, in 24-hour time
     * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
     * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
     * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
     * @param {Object} options - configuration options for the DateTime
     * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
     * @param {string} [options.outputCalendar] - the output calendar to set on the resulting DateTime instance
     * @param {string} [options.numberingSystem] - the numbering system to set on the resulting DateTime instance
     * @param {string} [options.weekSettings] - the week settings to set on the resulting DateTime instance
     * @example DateTime.utc()                                              //~> now
     * @example DateTime.utc(2017)                                          //~> 2017-01-01T00:00:00Z
     * @example DateTime.utc(2017, 3)                                       //~> 2017-03-01T00:00:00Z
     * @example DateTime.utc(2017, 3, 12)                                   //~> 2017-03-12T00:00:00Z
     * @example DateTime.utc(2017, 3, 12, 5)                                //~> 2017-03-12T05:00:00Z
     * @example DateTime.utc(2017, 3, 12, 5, 45)                            //~> 2017-03-12T05:45:00Z
     * @example DateTime.utc(2017, 3, 12, 5, 45, { locale: "fr" })          //~> 2017-03-12T05:45:00Z with a French locale
     * @example DateTime.utc(2017, 3, 12, 5, 45, 10)                        //~> 2017-03-12T05:45:10Z
     * @example DateTime.utc(2017, 3, 12, 5, 45, 10, 765, { locale: "fr" }) //~> 2017-03-12T05:45:10.765Z with a French locale
     * @return {DateTime}
     */
    static utc() {
      const [e, t] = hm(arguments), [i, o, a, l, d, u, f] = t;
      return e.zone = et.utcInstance, dm({ year: i, month: o, day: a, hour: l, minute: d, second: u, millisecond: f }, e);
    }
    /**
     * Create a DateTime from a JavaScript Date object. Uses the default zone.
     * @param {Date} date - a JavaScript Date object
     * @param {Object} options - configuration options for the DateTime
     * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
     * @return {DateTime}
     */
    static fromJSDate(e, t = {}) {
      const i = YO(e) ? e.valueOf() : NaN;
      if (Number.isNaN(i))
        return z.invalid("invalid input");
      const o = Yr(t.zone, Ce.defaultZone);
      return o.isValid ? new z({
        ts: i,
        zone: o,
        loc: ce.fromObject(t)
      }) : z.invalid(kn(o));
    }
    /**
     * Create a DateTime from a number of milliseconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
     * @param {number} milliseconds - a number of milliseconds since 1970 UTC
     * @param {Object} options - configuration options for the DateTime
     * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
     * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
     * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
     * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
     * @param {string} options.weekSettings - the week settings to set on the resulting DateTime instance
     * @return {DateTime}
     */
    static fromMillis(e, t = {}) {
      if (jr(e))
        return e < -sm || e > sm ? z.invalid("Timestamp out of range") : new z({
          ts: e,
          zone: Yr(t.zone, Ce.defaultZone),
          loc: ce.fromObject(t)
        });
      throw new qe(
        `fromMillis requires a numerical input, but received a ${typeof e} with value ${e}`
      );
    }
    /**
     * Create a DateTime from a number of seconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
     * @param {number} seconds - a number of seconds since 1970 UTC
     * @param {Object} options - configuration options for the DateTime
     * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
     * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
     * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
     * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
     * @param {string} options.weekSettings - the week settings to set on the resulting DateTime instance
     * @return {DateTime}
     */
    static fromSeconds(e, t = {}) {
      if (jr(e))
        return new z({
          ts: e * 1e3,
          zone: Yr(t.zone, Ce.defaultZone),
          loc: ce.fromObject(t)
        });
      throw new qe("fromSeconds requires a numerical input");
    }
    /**
     * Create a DateTime from a JavaScript object with keys like 'year' and 'hour' with reasonable defaults.
     * @param {Object} obj - the object to create the DateTime from
     * @param {number} obj.year - a year, such as 1987
     * @param {number} obj.month - a month, 1-12
     * @param {number} obj.day - a day of the month, 1-31, depending on the month
     * @param {number} obj.ordinal - day of the year, 1-365 or 366
     * @param {number} obj.weekYear - an ISO week year
     * @param {number} obj.weekNumber - an ISO week number, between 1 and 52 or 53, depending on the year
     * @param {number} obj.weekday - an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday
     * @param {number} obj.localWeekYear - a week year, according to the locale
     * @param {number} obj.localWeekNumber - a week number, between 1 and 52 or 53, depending on the year, according to the locale
     * @param {number} obj.localWeekday - a weekday, 1-7, where 1 is the first and 7 is the last day of the week, according to the locale
     * @param {number} obj.hour - hour of the day, 0-23
     * @param {number} obj.minute - minute of the hour, 0-59
     * @param {number} obj.second - second of the minute, 0-59
     * @param {number} obj.millisecond - millisecond of the second, 0-999
     * @param {Object} opts - options for creating this DateTime
     * @param {string|Zone} [opts.zone='local'] - interpret the numbers in the context of a particular zone. Can take any value taken as the first argument to setZone()
     * @param {string} [opts.locale='system\'s locale'] - a locale to set on the resulting DateTime instance
     * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
     * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
     * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
     * @example DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'
     * @example DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'
     * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06
     * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'utc' }),
     * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'local' })
     * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'America/New_York' })
     * @example DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'
     * @example DateTime.fromObject({ localWeekYear: 2022, localWeekNumber: 1, localWeekday: 1 }, { locale: "en-US" }).toISODate() //=> '2021-12-26'
     * @return {DateTime}
     */
    static fromObject(e, t = {}) {
      e = e || {};
      const i = Yr(t.zone, Ce.defaultZone);
      if (!i.isValid)
        return z.invalid(kn(i));
      const o = ce.fromObject(t), a = Pa(e, cm), { minDaysInFirstWeek: l, startOfWeek: d } = Zg(a, o), u = Ce.now(), f = q(t.specificOffset) ? i.offset(u) : t.specificOffset, g = !q(a.ordinal), _ = !q(a.year), C = !q(a.month) || !q(a.day), x = _ || C, D = a.weekYear || a.weekNumber;
      if ((x || g) && D)
        throw new oo(
          "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
        );
      if (C && g)
        throw new oo("Can't mix ordinal dates with month/day");
      const P = D || a.weekday && !x;
      let I, F, H = ra(u, f);
      P ? (I = h2, F = d2, H = Oa(H, l, d)) : g ? (I = f2, F = u2, H = Gc(H)) : (I = fa, F = pv);
      let Y = !1;
      for (const he of I) {
        const Ee = a[he];
        q(Ee) ? Y ? a[he] = F[he] : a[he] = H[he] : Y = !0;
      }
      const W = P ? BO(a, l, d) : g ? VO(a) : H_(a), G = W || U_(a);
      if (G)
        return z.invalid(G);
      const ee = P ? Gg(a, l, d) : g ? jg(a) : a, [ie, be] = ha(ee, f, i), ue = new z({
        ts: ie,
        zone: i,
        o: be,
        loc: o
      });
      return a.weekday && x && e.weekday !== ue.weekday ? z.invalid(
        "mismatched weekday",
        `you can't specify both a weekday of ${a.weekday} and a date of ${ue.toISO()}`
      ) : ue.isValid ? ue : z.invalid(ue.invalid);
    }
    /**
     * Create a DateTime from an ISO 8601 string
     * @param {string} text - the ISO string
     * @param {Object} opts - options to affect the creation
     * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the time to this zone
     * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
     * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
     * @param {string} [opts.outputCalendar] - the output calendar to set on the resulting DateTime instance
     * @param {string} [opts.numberingSystem] - the numbering system to set on the resulting DateTime instance
     * @param {string} [opts.weekSettings] - the week settings to set on the resulting DateTime instance
     * @example DateTime.fromISO('2016-05-25T09:08:34.123')
     * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00')
     * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})
     * @example DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})
     * @example DateTime.fromISO('2016-W05-4')
     * @return {DateTime}
     */
    static fromISO(e, t = {}) {
      const [i, o] = ND(e);
      return Qi(i, o, t, "ISO 8601", e);
    }
    /**
     * Create a DateTime from an RFC 2822 string
     * @param {string} text - the RFC 2822 string
     * @param {Object} opts - options to affect the creation
     * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since the offset is always specified in the string itself, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
     * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
     * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
     * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
     * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
     * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
     * @example DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')
     * @example DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')
     * @example DateTime.fromRFC2822('25 Nov 2016 13:23 Z')
     * @return {DateTime}
     */
    static fromRFC2822(e, t = {}) {
      const [i, o] = LD(e);
      return Qi(i, o, t, "RFC 2822", e);
    }
    /**
     * Create a DateTime from an HTTP header date
     * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
     * @param {string} text - the HTTP header date
     * @param {Object} opts - options to affect the creation
     * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since HTTP dates are always in UTC, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
     * @param {boolean} [opts.setZone=false] - override the zone with the fixed-offset zone specified in the string. For HTTP dates, this is always UTC, so this option is equivalent to setting the `zone` option to 'utc', but this option is included for consistency with similar methods.
     * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
     * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
     * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
     * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
     * @example DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')
     * @example DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')
     * @example DateTime.fromHTTP('Sun Nov  6 08:49:37 1994')
     * @return {DateTime}
     */
    static fromHTTP(e, t = {}) {
      const [i, o] = RD(e);
      return Qi(i, o, t, "HTTP", t);
    }
    /**
     * Create a DateTime from an input string and format string.
     * Defaults to en-US if no locale has been specified, regardless of the system's locale. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/parsing?id=table-of-tokens).
     * @param {string} text - the string to parse
     * @param {string} fmt - the format the string is expected to be in (see the link below for the formats)
     * @param {Object} opts - options to affect the creation
     * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
     * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
     * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
     * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
     * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
     * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
     * @return {DateTime}
     */
    static fromFormat(e, t, i = {}) {
      if (q(e) || q(t))
        throw new qe("fromFormat requires an input string and a format");
      const { locale: o = null, numberingSystem: a = null } = i, l = ce.fromOpts({
        locale: o,
        numberingSystem: a,
        defaultToEN: !0
      }), [d, u, f, g] = c2(l, e, t);
      return g ? z.invalid(g) : Qi(d, u, i, `format ${t}`, e, f);
    }
    /**
     * @deprecated use fromFormat instead
     */
    static fromString(e, t, i = {}) {
      return z.fromFormat(e, t, i);
    }
    /**
     * Create a DateTime from a SQL date, time, or datetime
     * Defaults to en-US if no locale has been specified, regardless of the system's locale
     * @param {string} text - the string to parse
     * @param {Object} opts - options to affect the creation
     * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
     * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
     * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
     * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
     * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
     * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
     * @example DateTime.fromSQL('2017-05-15')
     * @example DateTime.fromSQL('2017-05-15 09:12:34')
     * @example DateTime.fromSQL('2017-05-15 09:12:34.342')
     * @example DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')
     * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')
     * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })
     * @example DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })
     * @example DateTime.fromSQL('09:12:34.342')
     * @return {DateTime}
     */
    static fromSQL(e, t = {}) {
      const [i, o] = VD(e);
      return Qi(i, o, t, "SQL", e);
    }
    /**
     * Create an invalid DateTime.
     * @param {string} reason - simple string of why this DateTime is invalid. Should not contain parameters or anything else data-dependent.
     * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
     * @return {DateTime}
     */
    static invalid(e, t = null) {
      if (!e)
        throw new qe("need to specify a reason the DateTime is invalid");
      const i = e instanceof Yt ? e : new Yt(e, t);
      if (Ce.throwOnInvalid)
        throw new bO(i);
      return new z({ invalid: i });
    }
    /**
     * Check if an object is an instance of DateTime. Works across context boundaries
     * @param {object} o
     * @return {boolean}
     */
    static isDateTime(e) {
      return e && e.isLuxonDateTime || !1;
    }
    /**
     * Produce the format string for a set of options
     * @param formatOpts
     * @param localeOpts
     * @returns {string}
     */
    static parseFormatForOpts(e, t = {}) {
      const i = hv(e, ce.fromObject(t));
      return i ? i.map((o) => o ? o.val : null).join("") : null;
    }
    /**
     * Produce the the fully expanded format token for the locale
     * Does NOT quote characters, so quoted tokens will not round trip correctly
     * @param fmt
     * @param localeOpts
     * @returns {string}
     */
    static expandFormat(e, t = {}) {
      return cv(Ge.parseFormat(e), ce.fromObject(t)).map((o) => o.val).join("");
    }
    static resetCache() {
      xn = void 0, zd.clear();
    }
    // INFO
    /**
     * Get the value of unit.
     * @param {string} unit - a unit such as 'minute' or 'day'
     * @example DateTime.local(2017, 7, 4).get('month'); //=> 7
     * @example DateTime.local(2017, 7, 4).get('day'); //=> 4
     * @return {number}
     */
    get(e) {
      return this[e];
    }
    /**
     * Returns whether the DateTime is valid. Invalid DateTimes occur when:
     * * The DateTime was created from invalid calendar information, such as the 13th month or February 30
     * * The DateTime was created by an operation on another invalid date
     * @type {boolean}
     */
    get isValid() {
      return this.invalid === null;
    }
    /**
     * Returns an error code if this DateTime is invalid, or null if the DateTime is valid
     * @type {string}
     */
    get invalidReason() {
      return this.invalid ? this.invalid.reason : null;
    }
    /**
     * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid
     * @type {string}
     */
    get invalidExplanation() {
      return this.invalid ? this.invalid.explanation : null;
    }
    /**
     * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime
     *
     * @type {string}
     */
    get locale() {
      return this.isValid ? this.loc.locale : null;
    }
    /**
     * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime
     *
     * @type {string}
     */
    get numberingSystem() {
      return this.isValid ? this.loc.numberingSystem : null;
    }
    /**
     * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime
     *
     * @type {string}
     */
    get outputCalendar() {
      return this.isValid ? this.loc.outputCalendar : null;
    }
    /**
     * Get the time zone associated with this DateTime.
     * @type {Zone}
     */
    get zone() {
      return this._zone;
    }
    /**
     * Get the name of the time zone.
     * @type {string}
     */
    get zoneName() {
      return this.isValid ? this.zone.name : null;
    }
    /**
     * Get the year
     * @example DateTime.local(2017, 5, 25).year //=> 2017
     * @type {number}
     */
    get year() {
      return this.isValid ? this.c.year : NaN;
    }
    /**
     * Get the quarter
     * @example DateTime.local(2017, 5, 25).quarter //=> 2
     * @type {number}
     */
    get quarter() {
      return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
    }
    /**
     * Get the month (1-12).
     * @example DateTime.local(2017, 5, 25).month //=> 5
     * @type {number}
     */
    get month() {
      return this.isValid ? this.c.month : NaN;
    }
    /**
     * Get the day of the month (1-30ish).
     * @example DateTime.local(2017, 5, 25).day //=> 25
     * @type {number}
     */
    get day() {
      return this.isValid ? this.c.day : NaN;
    }
    /**
     * Get the hour of the day (0-23).
     * @example DateTime.local(2017, 5, 25, 9).hour //=> 9
     * @type {number}
     */
    get hour() {
      return this.isValid ? this.c.hour : NaN;
    }
    /**
     * Get the minute of the hour (0-59).
     * @example DateTime.local(2017, 5, 25, 9, 30).minute //=> 30
     * @type {number}
     */
    get minute() {
      return this.isValid ? this.c.minute : NaN;
    }
    /**
     * Get the second of the minute (0-59).
     * @example DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52
     * @type {number}
     */
    get second() {
      return this.isValid ? this.c.second : NaN;
    }
    /**
     * Get the millisecond of the second (0-999).
     * @example DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654
     * @type {number}
     */
    get millisecond() {
      return this.isValid ? this.c.millisecond : NaN;
    }
    /**
     * Get the week year
     * @see https://en.wikipedia.org/wiki/ISO_week_date
     * @example DateTime.local(2014, 12, 31).weekYear //=> 2015
     * @type {number}
     */
    get weekYear() {
      return this.isValid ? Kc(this).weekYear : NaN;
    }
    /**
     * Get the week number of the week year (1-52ish).
     * @see https://en.wikipedia.org/wiki/ISO_week_date
     * @example DateTime.local(2017, 5, 25).weekNumber //=> 21
     * @type {number}
     */
    get weekNumber() {
      return this.isValid ? Kc(this).weekNumber : NaN;
    }
    /**
     * Get the day of the week.
     * 1 is Monday and 7 is Sunday
     * @see https://en.wikipedia.org/wiki/ISO_week_date
     * @example DateTime.local(2014, 11, 31).weekday //=> 4
     * @type {number}
     */
    get weekday() {
      return this.isValid ? Kc(this).weekday : NaN;
    }
    /**
     * Returns true if this date is on a weekend according to the locale, false otherwise
     * @returns {boolean}
     */
    get isWeekend() {
      return this.isValid && this.loc.getWeekendDays().includes(this.weekday);
    }
    /**
     * Get the day of the week according to the locale.
     * 1 is the first day of the week and 7 is the last day of the week.
     * If the locale assigns Sunday as the first day of the week, then a date which is a Sunday will return 1,
     * @returns {number}
     */
    get localWeekday() {
      return this.isValid ? Jc(this).weekday : NaN;
    }
    /**
     * Get the week number of the week year according to the locale. Different locales assign week numbers differently,
     * because the week can start on different days of the week (see localWeekday) and because a different number of days
     * is required for a week to count as the first week of a year.
     * @returns {number}
     */
    get localWeekNumber() {
      return this.isValid ? Jc(this).weekNumber : NaN;
    }
    /**
     * Get the week year according to the locale. Different locales assign week numbers (and therefor week years)
     * differently, see localWeekNumber.
     * @returns {number}
     */
    get localWeekYear() {
      return this.isValid ? Jc(this).weekYear : NaN;
    }
    /**
     * Get the ordinal (meaning the day of the year)
     * @example DateTime.local(2017, 5, 25).ordinal //=> 145
     * @type {number|DateTime}
     */
    get ordinal() {
      return this.isValid ? Gc(this.c).ordinal : NaN;
    }
    /**
     * Get the human readable short month name, such as 'Oct'.
     * Defaults to the system's locale if no locale has been specified
     * @example DateTime.local(2017, 10, 30).monthShort //=> Oct
     * @type {string}
     */
    get monthShort() {
      return this.isValid ? ea.months("short", { locObj: this.loc })[this.month - 1] : null;
    }
    /**
     * Get the human readable long month name, such as 'October'.
     * Defaults to the system's locale if no locale has been specified
     * @example DateTime.local(2017, 10, 30).monthLong //=> October
     * @type {string}
     */
    get monthLong() {
      return this.isValid ? ea.months("long", { locObj: this.loc })[this.month - 1] : null;
    }
    /**
     * Get the human readable short weekday, such as 'Mon'.
     * Defaults to the system's locale if no locale has been specified
     * @example DateTime.local(2017, 10, 30).weekdayShort //=> Mon
     * @type {string}
     */
    get weekdayShort() {
      return this.isValid ? ea.weekdays("short", { locObj: this.loc })[this.weekday - 1] : null;
    }
    /**
     * Get the human readable long weekday, such as 'Monday'.
     * Defaults to the system's locale if no locale has been specified
     * @example DateTime.local(2017, 10, 30).weekdayLong //=> Monday
     * @type {string}
     */
    get weekdayLong() {
      return this.isValid ? ea.weekdays("long", { locObj: this.loc })[this.weekday - 1] : null;
    }
    /**
     * Get the UTC offset of this DateTime in minutes
     * @example DateTime.now().offset //=> -240
     * @example DateTime.utc().offset //=> 0
     * @type {number}
     */
    get offset() {
      return this.isValid ? +this.o : NaN;
    }
    /**
     * Get the short human name for the zone's current offset, for example "EST" or "EDT".
     * Defaults to the system's locale if no locale has been specified
     * @type {string}
     */
    get offsetNameShort() {
      return this.isValid ? this.zone.offsetName(this.ts, {
        format: "short",
        locale: this.locale
      }) : null;
    }
    /**
     * Get the long human name for the zone's current offset, for example "Eastern Standard Time" or "Eastern Daylight Time".
     * Defaults to the system's locale if no locale has been specified
     * @type {string}
     */
    get offsetNameLong() {
      return this.isValid ? this.zone.offsetName(this.ts, {
        format: "long",
        locale: this.locale
      }) : null;
    }
    /**
     * Get whether this zone's offset ever changes, as in a DST.
     * @type {boolean}
     */
    get isOffsetFixed() {
      return this.isValid ? this.zone.isUniversal : null;
    }
    /**
     * Get whether the DateTime is in a DST.
     * @type {boolean}
     */
    get isInDST() {
      return this.isOffsetFixed ? !1 : this.offset > this.set({ month: 1, day: 1 }).offset || this.offset > this.set({ month: 5 }).offset;
    }
    /**
     * Get those DateTimes which have the same local time as this DateTime, but a different offset from UTC
     * in this DateTime's zone. During DST changes local time can be ambiguous, for example
     * `2023-10-29T02:30:00` in `Europe/Berlin` can have offset `+01:00` or `+02:00`.
     * This method will return both possible DateTimes if this DateTime's local time is ambiguous.
     * @returns {DateTime[]}
     */
    getPossibleOffsets() {
      if (!this.isValid || this.isOffsetFixed)
        return [this];
      const e = 864e5, t = 6e4, i = qa(this.c), o = this.zone.offset(i - e), a = this.zone.offset(i + e), l = this.zone.offset(i - o * t), d = this.zone.offset(i - a * t);
      if (l === d)
        return [this];
      const u = i - l * t, f = i - d * t, g = ra(u, l), _ = ra(f, d);
      return g.hour === _.hour && g.minute === _.minute && g.second === _.second && g.millisecond === _.millisecond ? [gi(this, { ts: u }), gi(this, { ts: f })] : [this];
    }
    /**
     * Returns true if this DateTime is in a leap year, false otherwise
     * @example DateTime.local(2016).isInLeapYear //=> true
     * @example DateTime.local(2013).isInLeapYear //=> false
     * @type {boolean}
     */
    get isInLeapYear() {
      return Qn(this.year);
    }
    /**
     * Returns the number of days in this DateTime's month
     * @example DateTime.local(2016, 2).daysInMonth //=> 29
     * @example DateTime.local(2016, 3).daysInMonth //=> 31
     * @type {number}
     */
    get daysInMonth() {
      return Da(this.year, this.month);
    }
    /**
     * Returns the number of days in this DateTime's year
     * @example DateTime.local(2016).daysInYear //=> 366
     * @example DateTime.local(2013).daysInYear //=> 365
     * @type {number}
     */
    get daysInYear() {
      return this.isValid ? ho(this.year) : NaN;
    }
    /**
     * Returns the number of weeks in this DateTime's year
     * @see https://en.wikipedia.org/wiki/ISO_week_date
     * @example DateTime.local(2004).weeksInWeekYear //=> 53
     * @example DateTime.local(2013).weeksInWeekYear //=> 52
     * @type {number}
     */
    get weeksInWeekYear() {
      return this.isValid ? Gn(this.weekYear) : NaN;
    }
    /**
     * Returns the number of weeks in this DateTime's local week year
     * @example DateTime.local(2020, 6, {locale: 'en-US'}).weeksInLocalWeekYear //=> 52
     * @example DateTime.local(2020, 6, {locale: 'de-DE'}).weeksInLocalWeekYear //=> 53
     * @type {number}
     */
    get weeksInLocalWeekYear() {
      return this.isValid ? Gn(
        this.localWeekYear,
        this.loc.getMinDaysInFirstWeek(),
        this.loc.getStartOfWeek()
      ) : NaN;
    }
    /**
     * Returns the resolved Intl options for this DateTime.
     * This is useful in understanding the behavior of formatting methods
     * @param {Object} opts - the same options as toLocaleString
     * @return {Object}
     */
    resolvedLocaleOptions(e = {}) {
      const { locale: t, numberingSystem: i, calendar: o } = Ge.create(
        this.loc.clone(e),
        e
      ).resolvedOptions(this);
      return { locale: t, numberingSystem: i, outputCalendar: o };
    }
    // TRANSFORM
    /**
     * "Set" the DateTime's zone to UTC. Returns a newly-constructed DateTime.
     *
     * Equivalent to {@link DateTime#setZone}('utc')
     * @param {number} [offset=0] - optionally, an offset from UTC in minutes
     * @param {Object} [opts={}] - options to pass to `setZone()`
     * @return {DateTime}
     */
    toUTC(e = 0, t = {}) {
      return this.setZone(et.instance(e), t);
    }
    /**
     * "Set" the DateTime's zone to the host's local zone. Returns a newly-constructed DateTime.
     *
     * Equivalent to `setZone('local')`
     * @return {DateTime}
     */
    toLocal() {
      return this.setZone(Ce.defaultZone);
    }
    /**
     * "Set" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.
     *
     * By default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will report different local times and consider DSTs when making computations, as with {@link DateTime#plus}. You may wish to use {@link DateTime#toLocal} and {@link DateTime#toUTC} which provide simple convenience wrappers for commonly used zones.
     * @param {string|Zone} [zone='local'] - a zone identifier. As a string, that can be any IANA zone supported by the host environment, or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'. You may also supply an instance of a {@link DateTime#Zone} class.
     * @param {Object} opts - options
     * @param {boolean} [opts.keepLocalTime=false] - If true, adjust the underlying time so that the local time stays the same, but in the target zone. You should rarely need this.
     * @return {DateTime}
     */
    setZone(e, { keepLocalTime: t = !1, keepCalendarTime: i = !1 } = {}) {
      if (e = Yr(e, Ce.defaultZone), e.equals(this.zone))
        return this;
      if (e.isValid) {
        let o = this.ts;
        if (t || i) {
          const a = e.offset(this.ts), l = this.toObject();
          [o] = ha(l, a, e);
        }
        return gi(this, { ts: o, zone: e });
      } else
        return z.invalid(kn(e));
    }
    /**
     * "Set" the locale, numberingSystem, or outputCalendar. Returns a newly-constructed DateTime.
     * @param {Object} properties - the properties to set
     * @example DateTime.local(2017, 5, 25).reconfigure({ locale: 'en-GB' })
     * @return {DateTime}
     */
    reconfigure({ locale: e, numberingSystem: t, outputCalendar: i } = {}) {
      const o = this.loc.clone({ locale: e, numberingSystem: t, outputCalendar: i });
      return gi(this, { loc: o });
    }
    /**
     * "Set" the locale. Returns a newly-constructed DateTime.
     * Just a convenient alias for reconfigure({ locale })
     * @example DateTime.local(2017, 5, 25).setLocale('en-GB')
     * @return {DateTime}
     */
    setLocale(e) {
      return this.reconfigure({ locale: e });
    }
    /**
     * "Set" the values of specified units. Returns a newly-constructed DateTime.
     * You can only set units with this method; for "setting" metadata, see {@link DateTime#reconfigure} and {@link DateTime#setZone}.
     *
     * This method also supports setting locale-based week units, i.e. `localWeekday`, `localWeekNumber` and `localWeekYear`.
     * They cannot be mixed with ISO-week units like `weekday`.
     * @param {Object} values - a mapping of units to numbers
     * @example dt.set({ year: 2017 })
     * @example dt.set({ hour: 8, minute: 30 })
     * @example dt.set({ weekday: 5 })
     * @example dt.set({ year: 2005, ordinal: 234 })
     * @return {DateTime}
     */
    set(e) {
      if (!this.isValid) return this;
      const t = Pa(e, cm), { minDaysInFirstWeek: i, startOfWeek: o } = Zg(t, this.loc), a = !q(t.weekYear) || !q(t.weekNumber) || !q(t.weekday), l = !q(t.ordinal), d = !q(t.year), u = !q(t.month) || !q(t.day), f = d || u, g = t.weekYear || t.weekNumber;
      if ((f || l) && g)
        throw new oo(
          "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
        );
      if (u && l)
        throw new oo("Can't mix ordinal dates with month/day");
      let _;
      a ? _ = Gg(
        { ...Oa(this.c, i, o), ...t },
        i,
        o
      ) : q(t.ordinal) ? (_ = { ...this.toObject(), ...t }, q(t.day) && (_.day = Math.min(Da(_.year, _.month), _.day))) : _ = jg({ ...Gc(this.c), ...t });
      const [C, x] = ha(_, this.o, this.zone);
      return gi(this, { ts: C, o: x });
    }
    /**
     * Add a period of time to this DateTime and return the resulting DateTime
     *
     * Adding hours, minutes, seconds, or milliseconds increases the timestamp by the right number of milliseconds. Adding days, months, or years shifts the calendar, accounting for DSTs and leap years along the way. Thus, `dt.plus({ hours: 24 })` may result in a different time than `dt.plus({ days: 1 })` if there's a DST shift in between.
     * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
     * @example DateTime.now().plus(123) //~> in 123 milliseconds
     * @example DateTime.now().plus({ minutes: 15 }) //~> in 15 minutes
     * @example DateTime.now().plus({ days: 1 }) //~> this time tomorrow
     * @example DateTime.now().plus({ days: -1 }) //~> this time yesterday
     * @example DateTime.now().plus({ hours: 3, minutes: 13 }) //~> in 3 hr, 13 min
     * @example DateTime.now().plus(Duration.fromObject({ hours: 3, minutes: 13 })) //~> in 3 hr, 13 min
     * @return {DateTime}
     */
    plus(e) {
      if (!this.isValid) return this;
      const t = oe.fromDurationLike(e);
      return gi(this, am(this, t));
    }
    /**
     * Subtract a period of time to this DateTime and return the resulting DateTime
     * See {@link DateTime#plus}
     * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
     @return {DateTime}
     */
    minus(e) {
      if (!this.isValid) return this;
      const t = oe.fromDurationLike(e).negate();
      return gi(this, am(this, t));
    }
    /**
     * "Set" this DateTime to the beginning of a unit of time.
     * @param {string} unit - The unit to go to the beginning of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
     * @param {Object} opts - options
     * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week
     * @example DateTime.local(2014, 3, 3).startOf('month').toISODate(); //=> '2014-03-01'
     * @example DateTime.local(2014, 3, 3).startOf('year').toISODate(); //=> '2014-01-01'
     * @example DateTime.local(2014, 3, 3).startOf('week').toISODate(); //=> '2014-03-03', weeks always start on Mondays
     * @example DateTime.local(2014, 3, 3, 5, 30).startOf('day').toISOTime(); //=> '00:00.000-05:00'
     * @example DateTime.local(2014, 3, 3, 5, 30).startOf('hour').toISOTime(); //=> '05:00:00.000-05:00'
     * @return {DateTime}
     */
    startOf(e, { useLocaleWeeks: t = !1 } = {}) {
      if (!this.isValid) return this;
      const i = {}, o = oe.normalizeUnit(e);
      switch (o) {
        case "years":
          i.month = 1;
        // falls through
        case "quarters":
        case "months":
          i.day = 1;
        // falls through
        case "weeks":
        case "days":
          i.hour = 0;
        // falls through
        case "hours":
          i.minute = 0;
        // falls through
        case "minutes":
          i.second = 0;
        // falls through
        case "seconds":
          i.millisecond = 0;
          break;
      }
      if (o === "weeks")
        if (t) {
          const a = this.loc.getStartOfWeek(), { weekday: l } = this;
          l < a && (i.weekNumber = this.weekNumber - 1), i.weekday = a;
        } else
          i.weekday = 1;
      if (o === "quarters") {
        const a = Math.ceil(this.month / 3);
        i.month = (a - 1) * 3 + 1;
      }
      return this.set(i);
    }
    /**
     * "Set" this DateTime to the end (meaning the last millisecond) of a unit of time
     * @param {string} unit - The unit to go to the end of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
     * @param {Object} opts - options
     * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week
     * @example DateTime.local(2014, 3, 3).endOf('month').toISO(); //=> '2014-03-31T23:59:59.999-05:00'
     * @example DateTime.local(2014, 3, 3).endOf('year').toISO(); //=> '2014-12-31T23:59:59.999-05:00'
     * @example DateTime.local(2014, 3, 3).endOf('week').toISO(); // => '2014-03-09T23:59:59.999-05:00', weeks start on Mondays
     * @example DateTime.local(2014, 3, 3, 5, 30).endOf('day').toISO(); //=> '2014-03-03T23:59:59.999-05:00'
     * @example DateTime.local(2014, 3, 3, 5, 30).endOf('hour').toISO(); //=> '2014-03-03T05:59:59.999-05:00'
     * @return {DateTime}
     */
    endOf(e, t) {
      return this.isValid ? this.plus({ [e]: 1 }).startOf(e, t).minus(1) : this;
    }
    // OUTPUT
    /**
     * Returns a string representation of this DateTime formatted according to the specified format string.
     * **You may not want this.** See {@link DateTime#toLocaleString} for a more flexible formatting tool. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/formatting?id=table-of-tokens).
     * Defaults to en-US if no locale has been specified, regardless of the system's locale.
     * @param {string} fmt - the format string
     * @param {Object} opts - opts to override the configuration options on this DateTime
     * @example DateTime.now().toFormat('yyyy LLL dd') //=> '2017 Apr 22'
     * @example DateTime.now().setLocale('fr').toFormat('yyyy LLL dd') //=> '2017 avr. 22'
     * @example DateTime.now().toFormat('yyyy LLL dd', { locale: "fr" }) //=> '2017 avr. 22'
     * @example DateTime.now().toFormat("HH 'hours and' mm 'minutes'") //=> '20 hours and 55 minutes'
     * @return {string}
     */
    toFormat(e, t = {}) {
      return this.isValid ? Ge.create(this.loc.redefaultToEN(t)).formatDateTimeFromString(this, e) : Zc;
    }
    /**
     * Returns a localized string representing this date. Accepts the same options as the Intl.DateTimeFormat constructor and any presets defined by Luxon, such as `DateTime.DATE_FULL` or `DateTime.TIME_SIMPLE`.
     * The exact behavior of this method is browser-specific, but in general it will return an appropriate representation
     * of the DateTime in the assigned locale.
     * Defaults to the system's locale if no locale has been specified
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
     * @param formatOpts {Object} - Intl.DateTimeFormat constructor options and configuration options
     * @param {Object} opts - opts to override the configuration options on this DateTime
     * @example DateTime.now().toLocaleString(); //=> 4/20/2017
     * @example DateTime.now().setLocale('en-gb').toLocaleString(); //=> '20/04/2017'
     * @example DateTime.now().toLocaleString(DateTime.DATE_FULL); //=> 'April 20, 2017'
     * @example DateTime.now().toLocaleString(DateTime.DATE_FULL, { locale: 'fr' }); //=> '28 août 2022'
     * @example DateTime.now().toLocaleString(DateTime.TIME_SIMPLE); //=> '11:32 AM'
     * @example DateTime.now().toLocaleString(DateTime.DATETIME_SHORT); //=> '4/20/2017, 11:32 AM'
     * @example DateTime.now().toLocaleString({ weekday: 'long', month: 'long', day: '2-digit' }); //=> 'Thursday, April 20'
     * @example DateTime.now().toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> 'Thu, Apr 20, 11:27 AM'
     * @example DateTime.now().toLocaleString({ hour: '2-digit', minute: '2-digit', hourCycle: 'h23' }); //=> '11:32'
     * @return {string}
     */
    toLocaleString(e = Ta, t = {}) {
      return this.isValid ? Ge.create(this.loc.clone(t), e).formatDateTime(this) : Zc;
    }
    /**
     * Returns an array of format "parts", meaning individual tokens along with metadata. This is allows callers to post-process individual sections of the formatted output.
     * Defaults to the system's locale if no locale has been specified
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts
     * @param opts {Object} - Intl.DateTimeFormat constructor options, same as `toLocaleString`.
     * @example DateTime.now().toLocaleParts(); //=> [
     *                                   //=>   { type: 'day', value: '25' },
     *                                   //=>   { type: 'literal', value: '/' },
     *                                   //=>   { type: 'month', value: '05' },
     *                                   //=>   { type: 'literal', value: '/' },
     *                                   //=>   { type: 'year', value: '1982' }
     *                                   //=> ]
     */
    toLocaleParts(e = {}) {
      return this.isValid ? Ge.create(this.loc.clone(e), e).formatDateTimeParts(this) : [];
    }
    /**
     * Returns an ISO 8601-compliant string representation of this DateTime
     * @param {Object} opts - options
     * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
     * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
     * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
     * @param {boolean} [opts.extendedZone=false] - add the time zone format extension
     * @param {string} [opts.format='extended'] - choose between the basic and extended format
     * @param {string} [opts.precision='milliseconds'] - truncate output to desired presicion: 'years', 'months', 'days', 'hours', 'minutes', 'seconds' or 'milliseconds'. When precision and suppressSeconds or suppressMilliseconds are used together, precision sets the maximum unit shown in the output, however seconds or milliseconds will still be suppressed if they are 0.
     * @example DateTime.utc(1983, 5, 25).toISO() //=> '1982-05-25T00:00:00.000Z'
     * @example DateTime.now().toISO() //=> '2017-04-22T20:47:05.335-04:00'
     * @example DateTime.now().toISO({ includeOffset: false }) //=> '2017-04-22T20:47:05.335'
     * @example DateTime.now().toISO({ format: 'basic' }) //=> '20170422T204705.335-0400'
     * @example DateTime.now().toISO({ precision: 'day' }) //=> '2017-04-22Z'
     * @example DateTime.now().toISO({ precision: 'minute' }) //=> '2017-04-22T20:47Z'
     * @return {string|null}
     */
    toISO({
      format: e = "extended",
      suppressSeconds: t = !1,
      suppressMilliseconds: i = !1,
      includeOffset: o = !0,
      extendedZone: a = !1,
      precision: l = "milliseconds"
    } = {}) {
      if (!this.isValid)
        return null;
      l = pa(l);
      const d = e === "extended";
      let u = Xc(this, d, l);
      return fa.indexOf(l) >= 3 && (u += "T"), u += lm(
        this,
        d,
        t,
        i,
        o,
        a,
        l
      ), u;
    }
    /**
     * Returns an ISO 8601-compliant string representation of this DateTime's date component
     * @param {Object} opts - options
     * @param {string} [opts.format='extended'] - choose between the basic and extended format
     * @param {string} [opts.precision='day'] - truncate output to desired precision: 'years', 'months', or 'days'.
     * @example DateTime.utc(1982, 5, 25).toISODate() //=> '1982-05-25'
     * @example DateTime.utc(1982, 5, 25).toISODate({ format: 'basic' }) //=> '19820525'
     * @example DateTime.utc(1982, 5, 25).toISODate({ precision: 'month' }) //=> '1982-05'
     * @return {string|null}
     */
    toISODate({ format: e = "extended", precision: t = "day" } = {}) {
      return this.isValid ? Xc(this, e === "extended", pa(t)) : null;
    }
    /**
     * Returns an ISO 8601-compliant string representation of this DateTime's week date
     * @example DateTime.utc(1982, 5, 25).toISOWeekDate() //=> '1982-W21-2'
     * @return {string}
     */
    toISOWeekDate() {
      return ia(this, "kkkk-'W'WW-c");
    }
    /**
     * Returns an ISO 8601-compliant string representation of this DateTime's time component
     * @param {Object} opts - options
     * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
     * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
     * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
     * @param {boolean} [opts.extendedZone=true] - add the time zone format extension
     * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
     * @param {string} [opts.format='extended'] - choose between the basic and extended format
     * @param {string} [opts.precision='milliseconds'] - truncate output to desired presicion: 'hours', 'minutes', 'seconds' or 'milliseconds'. When precision and suppressSeconds or suppressMilliseconds are used together, precision sets the maximum unit shown in the output, however seconds or milliseconds will still be suppressed if they are 0.
     * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime() //=> '07:34:19.361Z'
     * @example DateTime.utc().set({ hour: 7, minute: 34, seconds: 0, milliseconds: 0 }).toISOTime({ suppressSeconds: true }) //=> '07:34Z'
     * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ format: 'basic' }) //=> '073419.361Z'
     * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ includePrefix: true }) //=> 'T07:34:19.361Z'
     * @example DateTime.utc().set({ hour: 7, minute: 34, second: 56 }).toISOTime({ precision: 'minute' }) //=> '07:34Z'
     * @return {string}
     */
    toISOTime({
      suppressMilliseconds: e = !1,
      suppressSeconds: t = !1,
      includeOffset: i = !0,
      includePrefix: o = !1,
      extendedZone: a = !1,
      format: l = "extended",
      precision: d = "milliseconds"
    } = {}) {
      return this.isValid ? (d = pa(d), (o && fa.indexOf(d) >= 3 ? "T" : "") + lm(
        this,
        l === "extended",
        t,
        e,
        i,
        a,
        d
      )) : null;
    }
    /**
     * Returns an RFC 2822-compatible string representation of this DateTime
     * @example DateTime.utc(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 +0000'
     * @example DateTime.local(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 -0400'
     * @return {string}
     */
    toRFC2822() {
      return ia(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", !1);
    }
    /**
     * Returns a string representation of this DateTime appropriate for use in HTTP headers. The output is always expressed in GMT.
     * Specifically, the string conforms to RFC 1123.
     * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
     * @example DateTime.utc(2014, 7, 13).toHTTP() //=> 'Sun, 13 Jul 2014 00:00:00 GMT'
     * @example DateTime.utc(2014, 7, 13, 19).toHTTP() //=> 'Sun, 13 Jul 2014 19:00:00 GMT'
     * @return {string}
     */
    toHTTP() {
      return ia(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
    }
    /**
     * Returns a string representation of this DateTime appropriate for use in SQL Date
     * @example DateTime.utc(2014, 7, 13).toSQLDate() //=> '2014-07-13'
     * @return {string|null}
     */
    toSQLDate() {
      return this.isValid ? Xc(this, !0) : null;
    }
    /**
     * Returns a string representation of this DateTime appropriate for use in SQL Time
     * @param {Object} opts - options
     * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
     * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
     * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
     * @example DateTime.utc().toSQL() //=> '05:15:16.345'
     * @example DateTime.now().toSQL() //=> '05:15:16.345 -04:00'
     * @example DateTime.now().toSQL({ includeOffset: false }) //=> '05:15:16.345'
     * @example DateTime.now().toSQL({ includeZone: false }) //=> '05:15:16.345 America/New_York'
     * @return {string}
     */
    toSQLTime({ includeOffset: e = !0, includeZone: t = !1, includeOffsetSpace: i = !0 } = {}) {
      let o = "HH:mm:ss.SSS";
      return (t || e) && (i && (o += " "), t ? o += "z" : e && (o += "ZZ")), ia(this, o, !0);
    }
    /**
     * Returns a string representation of this DateTime appropriate for use in SQL DateTime
     * @param {Object} opts - options
     * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
     * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
     * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
     * @example DateTime.utc(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 Z'
     * @example DateTime.local(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 -04:00'
     * @example DateTime.local(2014, 7, 13).toSQL({ includeOffset: false }) //=> '2014-07-13 00:00:00.000'
     * @example DateTime.local(2014, 7, 13).toSQL({ includeZone: true }) //=> '2014-07-13 00:00:00.000 America/New_York'
     * @return {string}
     */
    toSQL(e = {}) {
      return this.isValid ? `${this.toSQLDate()} ${this.toSQLTime(e)}` : null;
    }
    /**
     * Returns a string representation of this DateTime appropriate for debugging
     * @return {string}
     */
    toString() {
      return this.isValid ? this.toISO() : Zc;
    }
    /**
     * Returns a string representation of this DateTime appropriate for the REPL.
     * @return {string}
     */
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return this.isValid ? `DateTime { ts: ${this.toISO()}, zone: ${this.zone.name}, locale: ${this.locale} }` : `DateTime { Invalid, reason: ${this.invalidReason} }`;
    }
    /**
     * Returns the epoch milliseconds of this DateTime. Alias of {@link DateTime#toMillis}
     * @return {number}
     */
    valueOf() {
      return this.toMillis();
    }
    /**
     * Returns the epoch milliseconds of this DateTime.
     * @return {number}
     */
    toMillis() {
      return this.isValid ? this.ts : NaN;
    }
    /**
     * Returns the epoch seconds (including milliseconds in the fractional part) of this DateTime.
     * @return {number}
     */
    toSeconds() {
      return this.isValid ? this.ts / 1e3 : NaN;
    }
    /**
     * Returns the epoch seconds (as a whole number) of this DateTime.
     * @return {number}
     */
    toUnixInteger() {
      return this.isValid ? Math.floor(this.ts / 1e3) : NaN;
    }
    /**
     * Returns an ISO 8601 representation of this DateTime appropriate for use in JSON.
     * @return {string}
     */
    toJSON() {
      return this.toISO();
    }
    /**
     * Returns a BSON serializable equivalent to this DateTime.
     * @return {Date}
     */
    toBSON() {
      return this.toJSDate();
    }
    /**
     * Returns a JavaScript object with this DateTime's year, month, day, and so on.
     * @param opts - options for generating the object
     * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output
     * @example DateTime.now().toObject() //=> { year: 2017, month: 4, day: 22, hour: 20, minute: 49, second: 42, millisecond: 268 }
     * @return {Object}
     */
    toObject(e = {}) {
      if (!this.isValid) return {};
      const t = { ...this.c };
      return e.includeConfig && (t.outputCalendar = this.outputCalendar, t.numberingSystem = this.loc.numberingSystem, t.locale = this.loc.locale), t;
    }
    /**
     * Returns a JavaScript Date equivalent to this DateTime.
     * @return {Date}
     */
    toJSDate() {
      return new Date(this.isValid ? this.ts : NaN);
    }
    // COMPARE
    /**
     * Return the difference between two DateTimes as a Duration.
     * @param {DateTime} otherDateTime - the DateTime to compare this one to
     * @param {string|string[]} [unit=['milliseconds']] - the unit or array of units (such as 'hours' or 'days') to include in the duration.
     * @param {Object} opts - options that affect the creation of the Duration
     * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
     * @example
     * var i1 = DateTime.fromISO('1982-05-25T09:45'),
     *     i2 = DateTime.fromISO('1983-10-14T10:30');
     * i2.diff(i1).toObject() //=> { milliseconds: 43807500000 }
     * i2.diff(i1, 'hours').toObject() //=> { hours: 12168.75 }
     * i2.diff(i1, ['months', 'days']).toObject() //=> { months: 16, days: 19.03125 }
     * i2.diff(i1, ['months', 'days', 'hours']).toObject() //=> { months: 16, days: 19, hours: 0.75 }
     * @return {Duration}
     */
    diff(e, t = "milliseconds", i = {}) {
      if (!this.isValid || !e.isValid)
        return oe.invalid("created by diffing an invalid DateTime");
      const o = { locale: this.locale, numberingSystem: this.numberingSystem, ...i }, a = GO(t).map(oe.normalizeUnit), l = e.valueOf() > this.valueOf(), d = l ? this : e, u = l ? e : this, f = KD(d, u, a, o);
      return l ? f.negate() : f;
    }
    /**
     * Return the difference between this DateTime and right now.
     * See {@link DateTime#diff}
     * @param {string|string[]} [unit=['milliseconds']] - the unit or units units (such as 'hours' or 'days') to include in the duration
     * @param {Object} opts - options that affect the creation of the Duration
     * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
     * @return {Duration}
     */
    diffNow(e = "milliseconds", t = {}) {
      return this.diff(z.now(), e, t);
    }
    /**
     * Return an Interval spanning between this DateTime and another DateTime
     * @param {DateTime} otherDateTime - the other end point of the Interval
     * @return {Interval|DateTime}
     */
    until(e) {
      return this.isValid ? xe.fromDateTimes(this, e) : this;
    }
    /**
     * Return whether this DateTime is in the same unit of time as another DateTime.
     * Higher-order units must also be identical for this function to return `true`.
     * Note that time zones are **ignored** in this comparison, which compares the **local** calendar time. Use {@link DateTime#setZone} to convert one of the dates if needed.
     * @param {DateTime} otherDateTime - the other DateTime
     * @param {string} unit - the unit of time to check sameness on
     * @param {Object} opts - options
     * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week; only the locale of this DateTime is used
     * @example DateTime.now().hasSame(otherDT, 'day'); //~> true if otherDT is in the same current calendar day
     * @return {boolean}
     */
    hasSame(e, t, i) {
      if (!this.isValid) return !1;
      const o = e.valueOf(), a = this.setZone(e.zone, { keepLocalTime: !0 });
      return a.startOf(t, i) <= o && o <= a.endOf(t, i);
    }
    /**
     * Equality check
     * Two DateTimes are equal if and only if they represent the same millisecond, have the same zone and location, and are both valid.
     * To compare just the millisecond values, use `+dt1 === +dt2`.
     * @param {DateTime} other - the other DateTime
     * @return {boolean}
     */
    equals(e) {
      return this.isValid && e.isValid && this.valueOf() === e.valueOf() && this.zone.equals(e.zone) && this.loc.equals(e.loc);
    }
    /**
     * Returns a string representation of a this time relative to now, such as "in two days". Can only internationalize if your
     * platform supports Intl.RelativeTimeFormat. Rounds towards zero by default.
     * @param {Object} options - options that affect the output
     * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
     * @param {string} [options.style="long"] - the style of units, must be "long", "short", or "narrow"
     * @param {string|string[]} options.unit - use a specific unit or array of units; if omitted, or an array, the method will pick the best unit. Use an array or one of "years", "quarters", "months", "weeks", "days", "hours", "minutes", or "seconds"
     * @param {boolean} [options.round=true] - whether to round the numbers in the output.
     * @param {string} [options.rounding="trunc"] - rounding method to use when rounding the numbers in the output. Can be "trunc" (toward zero), "expand" (away from zero), "round", "floor", or "ceil".
     * @param {number} [options.padding=0] - padding in milliseconds. This allows you to round up the result if it fits inside the threshold. Don't use in combination with {round: false} because the decimal output will include the padding.
     * @param {string} options.locale - override the locale of this DateTime
     * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
     * @example DateTime.now().plus({ days: 1 }).toRelative() //=> "in 1 day"
     * @example DateTime.now().setLocale("es").toRelative({ days: 1 }) //=> "dentro de 1 día"
     * @example DateTime.now().plus({ days: 1 }).toRelative({ locale: "fr" }) //=> "dans 23 heures"
     * @example DateTime.now().minus({ days: 2 }).toRelative() //=> "2 days ago"
     * @example DateTime.now().minus({ days: 2 }).toRelative({ unit: "hours" }) //=> "48 hours ago"
     * @example DateTime.now().minus({ hours: 36 }).toRelative({ round: false }) //=> "1.5 days ago"
     */
    toRelative(e = {}) {
      if (!this.isValid) return null;
      const t = e.base || z.fromObject({}, { zone: this.zone }), i = e.padding ? this < t ? -e.padding : e.padding : 0;
      let o = ["years", "months", "days", "hours", "minutes", "seconds"], a = e.unit;
      return Array.isArray(e.unit) && (o = e.unit, a = void 0), um(t, this.plus(i), {
        ...e,
        numeric: "always",
        units: o,
        unit: a
      });
    }
    /**
     * Returns a string representation of this date relative to today, such as "yesterday" or "next month".
     * Only internationalizes on platforms that supports Intl.RelativeTimeFormat.
     * @param {Object} options - options that affect the output
     * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
     * @param {string} options.locale - override the locale of this DateTime
     * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of "years", "quarters", "months", "weeks", or "days"
     * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
     * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar() //=> "tomorrow"
     * @example DateTime.now().setLocale("es").plus({ days: 1 }).toRelative() //=> ""mañana"
     * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar({ locale: "fr" }) //=> "demain"
     * @example DateTime.now().minus({ days: 2 }).toRelativeCalendar() //=> "2 days ago"
     */
    toRelativeCalendar(e = {}) {
      return this.isValid ? um(e.base || z.fromObject({}, { zone: this.zone }), this, {
        ...e,
        numeric: "auto",
        units: ["years", "months", "days"],
        calendary: !0
      }) : null;
    }
    /**
     * Return the min of several date times
     * @param {...DateTime} dateTimes - the DateTimes from which to choose the minimum
     * @return {DateTime} the min DateTime, or undefined if called with no argument
     */
    static min(...e) {
      if (!e.every(z.isDateTime))
        throw new qe("min requires all arguments be DateTimes");
      return Kg(e, (t) => t.valueOf(), Math.min);
    }
    /**
     * Return the max of several date times
     * @param {...DateTime} dateTimes - the DateTimes from which to choose the maximum
     * @return {DateTime} the max DateTime, or undefined if called with no argument
     */
    static max(...e) {
      if (!e.every(z.isDateTime))
        throw new qe("max requires all arguments be DateTimes");
      return Kg(e, (t) => t.valueOf(), Math.max);
    }
    // MISC
    /**
     * Explain how a string would be parsed by fromFormat()
     * @param {string} text - the string to parse
     * @param {string} fmt - the format the string is expected to be in (see description)
     * @param {Object} options - options taken by fromFormat()
     * @return {Object}
     */
    static fromFormatExplain(e, t, i = {}) {
      const { locale: o = null, numberingSystem: a = null } = i, l = ce.fromOpts({
        locale: o,
        numberingSystem: a,
        defaultToEN: !0
      });
      return uv(l, e, t);
    }
    /**
     * @deprecated use fromFormatExplain instead
     */
    static fromStringExplain(e, t, i = {}) {
      return z.fromFormatExplain(e, t, i);
    }
    /**
     * Build a parser for `fmt` using the given locale. This parser can be passed
     * to {@link DateTime.fromFormatParser} to a parse a date in this format. This
     * can be used to optimize cases where many dates need to be parsed in a
     * specific format.
     *
     * @param {String} fmt - the format the string is expected to be in (see
     * description)
     * @param {Object} options - options used to set locale and numberingSystem
     * for parser
     * @returns {TokenParser} - opaque object to be used
     */
    static buildFormatParser(e, t = {}) {
      const { locale: i = null, numberingSystem: o = null } = t, a = ce.fromOpts({
        locale: i,
        numberingSystem: o,
        defaultToEN: !0
      });
      return new dv(a, e);
    }
    /**
     * Create a DateTime from an input string and format parser.
     *
     * The format parser must have been created with the same locale as this call.
     *
     * @param {String} text - the string to parse
     * @param {TokenParser} formatParser - parser from {@link DateTime.buildFormatParser}
     * @param {Object} opts - options taken by fromFormat()
     * @returns {DateTime}
     */
    static fromFormatParser(e, t, i = {}) {
      if (q(e) || q(t))
        throw new qe(
          "fromFormatParser requires an input string and a format parser"
        );
      const { locale: o = null, numberingSystem: a = null } = i, l = ce.fromOpts({
        locale: o,
        numberingSystem: a,
        defaultToEN: !0
      });
      if (!l.equals(t.locale))
        throw new qe(
          `fromFormatParser called with a locale of ${l}, but the format parser was created for ${t.locale}`
        );
      const { result: d, zone: u, specificOffset: f, invalidReason: g } = t.explainFromTokens(e);
      return g ? z.invalid(g) : Qi(
        d,
        u,
        i,
        `format ${t.format}`,
        e,
        f
      );
    }
    // FORMAT PRESETS
    /**
     * {@link DateTime#toLocaleString} format like 10/14/1983
     * @type {Object}
     */
    static get DATE_SHORT() {
      return Ta;
    }
    /**
     * {@link DateTime#toLocaleString} format like 'Oct 14, 1983'
     * @type {Object}
     */
    static get DATE_MED() {
      return g_;
    }
    /**
     * {@link DateTime#toLocaleString} format like 'Fri, Oct 14, 1983'
     * @type {Object}
     */
    static get DATE_MED_WITH_WEEKDAY() {
      return yO;
    }
    /**
     * {@link DateTime#toLocaleString} format like 'October 14, 1983'
     * @type {Object}
     */
    static get DATE_FULL() {
      return m_;
    }
    /**
     * {@link DateTime#toLocaleString} format like 'Tuesday, October 14, 1983'
     * @type {Object}
     */
    static get DATE_HUGE() {
      return b_;
    }
    /**
     * {@link DateTime#toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get TIME_SIMPLE() {
      return __;
    }
    /**
     * {@link DateTime#toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get TIME_WITH_SECONDS() {
      return v_;
    }
    /**
     * {@link DateTime#toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get TIME_WITH_SHORT_OFFSET() {
      return y_;
    }
    /**
     * {@link DateTime#toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get TIME_WITH_LONG_OFFSET() {
      return w_;
    }
    /**
     * {@link DateTime#toLocaleString} format like '09:30', always 24-hour.
     * @type {Object}
     */
    static get TIME_24_SIMPLE() {
      return k_;
    }
    /**
     * {@link DateTime#toLocaleString} format like '09:30:23', always 24-hour.
     * @type {Object}
     */
    static get TIME_24_WITH_SECONDS() {
      return x_;
    }
    /**
     * {@link DateTime#toLocaleString} format like '09:30:23 EDT', always 24-hour.
     * @type {Object}
     */
    static get TIME_24_WITH_SHORT_OFFSET() {
      return C_;
    }
    /**
     * {@link DateTime#toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.
     * @type {Object}
     */
    static get TIME_24_WITH_LONG_OFFSET() {
      return S_;
    }
    /**
     * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get DATETIME_SHORT() {
      return A_;
    }
    /**
     * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get DATETIME_SHORT_WITH_SECONDS() {
      return E_;
    }
    /**
     * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get DATETIME_MED() {
      return $_;
    }
    /**
     * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get DATETIME_MED_WITH_SECONDS() {
      return T_;
    }
    /**
     * {@link DateTime#toLocaleString} format like 'Fri, 14 Oct 1983, 9:30 AM'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get DATETIME_MED_WITH_WEEKDAY() {
      return wO;
    }
    /**
     * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get DATETIME_FULL() {
      return O_;
    }
    /**
     * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get DATETIME_FULL_WITH_SECONDS() {
      return D_;
    }
    /**
     * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get DATETIME_HUGE() {
      return P_;
    }
    /**
     * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get DATETIME_HUGE_WITH_SECONDS() {
      return I_;
    }
  }
  function bn(r) {
    if (z.isDateTime(r))
      return r;
    if (r && r.valueOf && jr(r.valueOf()))
      return z.fromJSDate(r);
    if (r && typeof r == "object")
      return z.fromObject(r);
    throw new qe(
      `Unknown datetime argument: ${r}, of type ${typeof r}`
    );
  }
  var oa = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
  function g2(r) {
    return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
  }
  var Cn = { exports: {} };
  /**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   */
  var m2 = Cn.exports, fm;
  function b2() {
    return fm || (fm = 1, (function(r, e) {
      (function() {
        var t, i = "4.17.21", o = 200, a = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", l = "Expected a function", d = "Invalid `variable` option passed into `_.template`", u = "__lodash_hash_undefined__", f = 500, g = "__lodash_placeholder__", _ = 1, C = 2, x = 4, D = 1, P = 2, I = 1, F = 2, H = 4, Y = 8, W = 16, G = 32, ee = 64, ie = 128, be = 256, ue = 512, he = 30, Ee = "...", ut = 800, Fe = 16, Zt = 1, or = 2, Ze = 3, De = 1 / 0, ht = 9007199254740991, nr = 17976931348623157e292, sr = NaN, rt = 4294967295, Qr = rt - 1, Ii = rt >>> 1, Er = [
          ["ary", ie],
          ["bind", I],
          ["bindKey", F],
          ["curry", Y],
          ["curryRight", W],
          ["flip", ue],
          ["partial", G],
          ["partialRight", ee],
          ["rearg", be]
        ], Ke = "[object Arguments]", Kt = "[object Array]", Mi = "[object AsyncFunction]", ft = "[object Boolean]", ar = "[object Date]", Za = "[object DOMException]", $r = "[object Error]", Ni = "[object Function]", Vo = "[object GeneratorFunction]", pt = "[object Map]", ei = "[object Number]", os = "[object Null]", St = "[object Object]", ns = "[object Promise]", Ka = "[object Proxy]", gt = "[object RegExp]", We = "[object Set]", Tr = "[object String]", ti = "[object Symbol]", qo = "[object Undefined]", Or = "[object WeakMap]", ss = "[object WeakSet]", Dr = "[object ArrayBuffer]", lr = "[object DataView]", Ja = "[object Float32Array]", Xa = "[object Float64Array]", Qa = "[object Int8Array]", el = "[object Int16Array]", tl = "[object Int32Array]", rl = "[object Uint8Array]", il = "[object Uint8ClampedArray]", ol = "[object Uint16Array]", nl = "[object Uint32Array]", Av = /\b__p \+= '';/g, Ev = /\b(__p \+=) '' \+/g, $v = /(__e\(.*?\)|\b__t\)) \+\n'';/g, zu = /&(?:amp|lt|gt|quot|#39);/g, Hu = /[&<>"']/g, Tv = RegExp(zu.source), Ov = RegExp(Hu.source), Dv = /<%-([\s\S]+?)%>/g, Pv = /<%([\s\S]+?)%>/g, Uu = /<%=([\s\S]+?)%>/g, Iv = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, Mv = /^\w*$/, Nv = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, sl = /[\\^$.*+?()[\]{}|]/g, Lv = RegExp(sl.source), al = /^\s+/, Rv = /\s/, Fv = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, zv = /\{\n\/\* \[wrapped with (.+)\] \*/, Hv = /,? & /, Uv = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, Wv = /[()=,{}\[\]\/\s]/, Bv = /\\(\\)?/g, Vv = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, Wu = /\w*$/, qv = /^[-+]0x[0-9a-f]+$/i, Yv = /^0b[01]+$/i, Gv = /^\[object .+?Constructor\]$/, jv = /^0o[0-7]+$/i, Zv = /^(?:0|[1-9]\d*)$/, Kv = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, as = /($^)/, Jv = /['\n\r\u2028\u2029\\]/g, ls = "\\ud800-\\udfff", Xv = "\\u0300-\\u036f", Qv = "\\ufe20-\\ufe2f", ey = "\\u20d0-\\u20ff", Bu = Xv + Qv + ey, Vu = "\\u2700-\\u27bf", qu = "a-z\\xdf-\\xf6\\xf8-\\xff", ty = "\\xac\\xb1\\xd7\\xf7", ry = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", iy = "\\u2000-\\u206f", oy = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", Yu = "A-Z\\xc0-\\xd6\\xd8-\\xde", Gu = "\\ufe0e\\ufe0f", ju = ty + ry + iy + oy, ll = "['’]", ny = "[" + ls + "]", Zu = "[" + ju + "]", cs = "[" + Bu + "]", Ku = "\\d+", sy = "[" + Vu + "]", Ju = "[" + qu + "]", Xu = "[^" + ls + ju + Ku + Vu + qu + Yu + "]", cl = "\\ud83c[\\udffb-\\udfff]", ay = "(?:" + cs + "|" + cl + ")", Qu = "[^" + ls + "]", dl = "(?:\\ud83c[\\udde6-\\uddff]){2}", ul = "[\\ud800-\\udbff][\\udc00-\\udfff]", Li = "[" + Yu + "]", eh = "\\u200d", th = "(?:" + Ju + "|" + Xu + ")", ly = "(?:" + Li + "|" + Xu + ")", rh = "(?:" + ll + "(?:d|ll|m|re|s|t|ve))?", ih = "(?:" + ll + "(?:D|LL|M|RE|S|T|VE))?", oh = ay + "?", nh = "[" + Gu + "]?", cy = "(?:" + eh + "(?:" + [Qu, dl, ul].join("|") + ")" + nh + oh + ")*", dy = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", uy = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", sh = nh + oh + cy, hy = "(?:" + [sy, dl, ul].join("|") + ")" + sh, fy = "(?:" + [Qu + cs + "?", cs, dl, ul, ny].join("|") + ")", py = RegExp(ll, "g"), gy = RegExp(cs, "g"), hl = RegExp(cl + "(?=" + cl + ")|" + fy + sh, "g"), my = RegExp([
          Li + "?" + Ju + "+" + rh + "(?=" + [Zu, Li, "$"].join("|") + ")",
          ly + "+" + ih + "(?=" + [Zu, Li + th, "$"].join("|") + ")",
          Li + "?" + th + "+" + rh,
          Li + "+" + ih,
          uy,
          dy,
          Ku,
          hy
        ].join("|"), "g"), by = RegExp("[" + eh + ls + Bu + Gu + "]"), _y = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, vy = [
          "Array",
          "Buffer",
          "DataView",
          "Date",
          "Error",
          "Float32Array",
          "Float64Array",
          "Function",
          "Int8Array",
          "Int16Array",
          "Int32Array",
          "Map",
          "Math",
          "Object",
          "Promise",
          "RegExp",
          "Set",
          "String",
          "Symbol",
          "TypeError",
          "Uint8Array",
          "Uint8ClampedArray",
          "Uint16Array",
          "Uint32Array",
          "WeakMap",
          "_",
          "clearTimeout",
          "isFinite",
          "parseInt",
          "setTimeout"
        ], yy = -1, _e = {};
        _e[Ja] = _e[Xa] = _e[Qa] = _e[el] = _e[tl] = _e[rl] = _e[il] = _e[ol] = _e[nl] = !0, _e[Ke] = _e[Kt] = _e[Dr] = _e[ft] = _e[lr] = _e[ar] = _e[$r] = _e[Ni] = _e[pt] = _e[ei] = _e[St] = _e[gt] = _e[We] = _e[Tr] = _e[Or] = !1;
        var ge = {};
        ge[Ke] = ge[Kt] = ge[Dr] = ge[lr] = ge[ft] = ge[ar] = ge[Ja] = ge[Xa] = ge[Qa] = ge[el] = ge[tl] = ge[pt] = ge[ei] = ge[St] = ge[gt] = ge[We] = ge[Tr] = ge[ti] = ge[rl] = ge[il] = ge[ol] = ge[nl] = !0, ge[$r] = ge[Ni] = ge[Or] = !1;
        var wy = {
          // Latin-1 Supplement block.
          À: "A",
          Á: "A",
          Â: "A",
          Ã: "A",
          Ä: "A",
          Å: "A",
          à: "a",
          á: "a",
          â: "a",
          ã: "a",
          ä: "a",
          å: "a",
          Ç: "C",
          ç: "c",
          Ð: "D",
          ð: "d",
          È: "E",
          É: "E",
          Ê: "E",
          Ë: "E",
          è: "e",
          é: "e",
          ê: "e",
          ë: "e",
          Ì: "I",
          Í: "I",
          Î: "I",
          Ï: "I",
          ì: "i",
          í: "i",
          î: "i",
          ï: "i",
          Ñ: "N",
          ñ: "n",
          Ò: "O",
          Ó: "O",
          Ô: "O",
          Õ: "O",
          Ö: "O",
          Ø: "O",
          ò: "o",
          ó: "o",
          ô: "o",
          õ: "o",
          ö: "o",
          ø: "o",
          Ù: "U",
          Ú: "U",
          Û: "U",
          Ü: "U",
          ù: "u",
          ú: "u",
          û: "u",
          ü: "u",
          Ý: "Y",
          ý: "y",
          ÿ: "y",
          Æ: "Ae",
          æ: "ae",
          Þ: "Th",
          þ: "th",
          ß: "ss",
          // Latin Extended-A block.
          Ā: "A",
          Ă: "A",
          Ą: "A",
          ā: "a",
          ă: "a",
          ą: "a",
          Ć: "C",
          Ĉ: "C",
          Ċ: "C",
          Č: "C",
          ć: "c",
          ĉ: "c",
          ċ: "c",
          č: "c",
          Ď: "D",
          Đ: "D",
          ď: "d",
          đ: "d",
          Ē: "E",
          Ĕ: "E",
          Ė: "E",
          Ę: "E",
          Ě: "E",
          ē: "e",
          ĕ: "e",
          ė: "e",
          ę: "e",
          ě: "e",
          Ĝ: "G",
          Ğ: "G",
          Ġ: "G",
          Ģ: "G",
          ĝ: "g",
          ğ: "g",
          ġ: "g",
          ģ: "g",
          Ĥ: "H",
          Ħ: "H",
          ĥ: "h",
          ħ: "h",
          Ĩ: "I",
          Ī: "I",
          Ĭ: "I",
          Į: "I",
          İ: "I",
          ĩ: "i",
          ī: "i",
          ĭ: "i",
          į: "i",
          ı: "i",
          Ĵ: "J",
          ĵ: "j",
          Ķ: "K",
          ķ: "k",
          ĸ: "k",
          Ĺ: "L",
          Ļ: "L",
          Ľ: "L",
          Ŀ: "L",
          Ł: "L",
          ĺ: "l",
          ļ: "l",
          ľ: "l",
          ŀ: "l",
          ł: "l",
          Ń: "N",
          Ņ: "N",
          Ň: "N",
          Ŋ: "N",
          ń: "n",
          ņ: "n",
          ň: "n",
          ŋ: "n",
          Ō: "O",
          Ŏ: "O",
          Ő: "O",
          ō: "o",
          ŏ: "o",
          ő: "o",
          Ŕ: "R",
          Ŗ: "R",
          Ř: "R",
          ŕ: "r",
          ŗ: "r",
          ř: "r",
          Ś: "S",
          Ŝ: "S",
          Ş: "S",
          Š: "S",
          ś: "s",
          ŝ: "s",
          ş: "s",
          š: "s",
          Ţ: "T",
          Ť: "T",
          Ŧ: "T",
          ţ: "t",
          ť: "t",
          ŧ: "t",
          Ũ: "U",
          Ū: "U",
          Ŭ: "U",
          Ů: "U",
          Ű: "U",
          Ų: "U",
          ũ: "u",
          ū: "u",
          ŭ: "u",
          ů: "u",
          ű: "u",
          ų: "u",
          Ŵ: "W",
          ŵ: "w",
          Ŷ: "Y",
          ŷ: "y",
          Ÿ: "Y",
          Ź: "Z",
          Ż: "Z",
          Ž: "Z",
          ź: "z",
          ż: "z",
          ž: "z",
          Ĳ: "IJ",
          ĳ: "ij",
          Œ: "Oe",
          œ: "oe",
          ŉ: "'n",
          ſ: "s"
        }, ky = {
          "&": "&amp;",
          "<": "&lt;",
          ">": "&gt;",
          '"': "&quot;",
          "'": "&#39;"
        }, xy = {
          "&amp;": "&",
          "&lt;": "<",
          "&gt;": ">",
          "&quot;": '"',
          "&#39;": "'"
        }, Cy = {
          "\\": "\\",
          "'": "'",
          "\n": "n",
          "\r": "r",
          "\u2028": "u2028",
          "\u2029": "u2029"
        }, Sy = parseFloat, Ay = parseInt, ah = typeof oa == "object" && oa && oa.Object === Object && oa, Ey = typeof self == "object" && self && self.Object === Object && self, ze = ah || Ey || Function("return this")(), fl = e && !e.nodeType && e, ri = fl && !0 && r && !r.nodeType && r, lh = ri && ri.exports === fl, pl = lh && ah.process, At = (function() {
          try {
            var w = ri && ri.require && ri.require("util").types;
            return w || pl && pl.binding && pl.binding("util");
          } catch {
          }
        })(), ch = At && At.isArrayBuffer, dh = At && At.isDate, uh = At && At.isMap, hh = At && At.isRegExp, fh = At && At.isSet, ph = At && At.isTypedArray;
        function mt(w, E, A) {
          switch (A.length) {
            case 0:
              return w.call(E);
            case 1:
              return w.call(E, A[0]);
            case 2:
              return w.call(E, A[0], A[1]);
            case 3:
              return w.call(E, A[0], A[1], A[2]);
          }
          return w.apply(E, A);
        }
        function $y(w, E, A, L) {
          for (var j = -1, se = w == null ? 0 : w.length; ++j < se; ) {
            var Pe = w[j];
            E(L, Pe, A(Pe), w);
          }
          return L;
        }
        function Et(w, E) {
          for (var A = -1, L = w == null ? 0 : w.length; ++A < L && E(w[A], A, w) !== !1; )
            ;
          return w;
        }
        function Ty(w, E) {
          for (var A = w == null ? 0 : w.length; A-- && E(w[A], A, w) !== !1; )
            ;
          return w;
        }
        function gh(w, E) {
          for (var A = -1, L = w == null ? 0 : w.length; ++A < L; )
            if (!E(w[A], A, w))
              return !1;
          return !0;
        }
        function Pr(w, E) {
          for (var A = -1, L = w == null ? 0 : w.length, j = 0, se = []; ++A < L; ) {
            var Pe = w[A];
            E(Pe, A, w) && (se[j++] = Pe);
          }
          return se;
        }
        function ds(w, E) {
          var A = w == null ? 0 : w.length;
          return !!A && Ri(w, E, 0) > -1;
        }
        function gl(w, E, A) {
          for (var L = -1, j = w == null ? 0 : w.length; ++L < j; )
            if (A(E, w[L]))
              return !0;
          return !1;
        }
        function ve(w, E) {
          for (var A = -1, L = w == null ? 0 : w.length, j = Array(L); ++A < L; )
            j[A] = E(w[A], A, w);
          return j;
        }
        function Ir(w, E) {
          for (var A = -1, L = E.length, j = w.length; ++A < L; )
            w[j + A] = E[A];
          return w;
        }
        function ml(w, E, A, L) {
          var j = -1, se = w == null ? 0 : w.length;
          for (L && se && (A = w[++j]); ++j < se; )
            A = E(A, w[j], j, w);
          return A;
        }
        function Oy(w, E, A, L) {
          var j = w == null ? 0 : w.length;
          for (L && j && (A = w[--j]); j--; )
            A = E(A, w[j], j, w);
          return A;
        }
        function bl(w, E) {
          for (var A = -1, L = w == null ? 0 : w.length; ++A < L; )
            if (E(w[A], A, w))
              return !0;
          return !1;
        }
        var Dy = _l("length");
        function Py(w) {
          return w.split("");
        }
        function Iy(w) {
          return w.match(Uv) || [];
        }
        function mh(w, E, A) {
          var L;
          return A(w, function(j, se, Pe) {
            if (E(j, se, Pe))
              return L = se, !1;
          }), L;
        }
        function us(w, E, A, L) {
          for (var j = w.length, se = A + (L ? 1 : -1); L ? se-- : ++se < j; )
            if (E(w[se], se, w))
              return se;
          return -1;
        }
        function Ri(w, E, A) {
          return E === E ? qy(w, E, A) : us(w, bh, A);
        }
        function My(w, E, A, L) {
          for (var j = A - 1, se = w.length; ++j < se; )
            if (L(w[j], E))
              return j;
          return -1;
        }
        function bh(w) {
          return w !== w;
        }
        function _h(w, E) {
          var A = w == null ? 0 : w.length;
          return A ? yl(w, E) / A : sr;
        }
        function _l(w) {
          return function(E) {
            return E == null ? t : E[w];
          };
        }
        function vl(w) {
          return function(E) {
            return w == null ? t : w[E];
          };
        }
        function vh(w, E, A, L, j) {
          return j(w, function(se, Pe, fe) {
            A = L ? (L = !1, se) : E(A, se, Pe, fe);
          }), A;
        }
        function Ny(w, E) {
          var A = w.length;
          for (w.sort(E); A--; )
            w[A] = w[A].value;
          return w;
        }
        function yl(w, E) {
          for (var A, L = -1, j = w.length; ++L < j; ) {
            var se = E(w[L]);
            se !== t && (A = A === t ? se : A + se);
          }
          return A;
        }
        function wl(w, E) {
          for (var A = -1, L = Array(w); ++A < w; )
            L[A] = E(A);
          return L;
        }
        function Ly(w, E) {
          return ve(E, function(A) {
            return [A, w[A]];
          });
        }
        function yh(w) {
          return w && w.slice(0, Ch(w) + 1).replace(al, "");
        }
        function bt(w) {
          return function(E) {
            return w(E);
          };
        }
        function kl(w, E) {
          return ve(E, function(A) {
            return w[A];
          });
        }
        function Yo(w, E) {
          return w.has(E);
        }
        function wh(w, E) {
          for (var A = -1, L = w.length; ++A < L && Ri(E, w[A], 0) > -1; )
            ;
          return A;
        }
        function kh(w, E) {
          for (var A = w.length; A-- && Ri(E, w[A], 0) > -1; )
            ;
          return A;
        }
        function Ry(w, E) {
          for (var A = w.length, L = 0; A--; )
            w[A] === E && ++L;
          return L;
        }
        var Fy = vl(wy), zy = vl(ky);
        function Hy(w) {
          return "\\" + Cy[w];
        }
        function Uy(w, E) {
          return w == null ? t : w[E];
        }
        function Fi(w) {
          return by.test(w);
        }
        function Wy(w) {
          return _y.test(w);
        }
        function By(w) {
          for (var E, A = []; !(E = w.next()).done; )
            A.push(E.value);
          return A;
        }
        function xl(w) {
          var E = -1, A = Array(w.size);
          return w.forEach(function(L, j) {
            A[++E] = [j, L];
          }), A;
        }
        function xh(w, E) {
          return function(A) {
            return w(E(A));
          };
        }
        function Mr(w, E) {
          for (var A = -1, L = w.length, j = 0, se = []; ++A < L; ) {
            var Pe = w[A];
            (Pe === E || Pe === g) && (w[A] = g, se[j++] = A);
          }
          return se;
        }
        function hs(w) {
          var E = -1, A = Array(w.size);
          return w.forEach(function(L) {
            A[++E] = L;
          }), A;
        }
        function Vy(w) {
          var E = -1, A = Array(w.size);
          return w.forEach(function(L) {
            A[++E] = [L, L];
          }), A;
        }
        function qy(w, E, A) {
          for (var L = A - 1, j = w.length; ++L < j; )
            if (w[L] === E)
              return L;
          return -1;
        }
        function Yy(w, E, A) {
          for (var L = A + 1; L--; )
            if (w[L] === E)
              return L;
          return L;
        }
        function zi(w) {
          return Fi(w) ? jy(w) : Dy(w);
        }
        function Ht(w) {
          return Fi(w) ? Zy(w) : Py(w);
        }
        function Ch(w) {
          for (var E = w.length; E-- && Rv.test(w.charAt(E)); )
            ;
          return E;
        }
        var Gy = vl(xy);
        function jy(w) {
          for (var E = hl.lastIndex = 0; hl.test(w); )
            ++E;
          return E;
        }
        function Zy(w) {
          return w.match(hl) || [];
        }
        function Ky(w) {
          return w.match(my) || [];
        }
        var Jy = (function w(E) {
          E = E == null ? ze : Hi.defaults(ze.Object(), E, Hi.pick(ze, vy));
          var A = E.Array, L = E.Date, j = E.Error, se = E.Function, Pe = E.Math, fe = E.Object, Cl = E.RegExp, Xy = E.String, $t = E.TypeError, fs = A.prototype, Qy = se.prototype, Ui = fe.prototype, ps = E["__core-js_shared__"], gs = Qy.toString, de = Ui.hasOwnProperty, e0 = 0, Sh = (function() {
            var n = /[^.]+$/.exec(ps && ps.keys && ps.keys.IE_PROTO || "");
            return n ? "Symbol(src)_1." + n : "";
          })(), ms = Ui.toString, t0 = gs.call(fe), r0 = ze._, i0 = Cl(
            "^" + gs.call(de).replace(sl, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
          ), bs = lh ? E.Buffer : t, Nr = E.Symbol, _s = E.Uint8Array, Ah = bs ? bs.allocUnsafe : t, vs = xh(fe.getPrototypeOf, fe), Eh = fe.create, $h = Ui.propertyIsEnumerable, ys = fs.splice, Th = Nr ? Nr.isConcatSpreadable : t, Go = Nr ? Nr.iterator : t, ii = Nr ? Nr.toStringTag : t, ws = (function() {
            try {
              var n = li(fe, "defineProperty");
              return n({}, "", {}), n;
            } catch {
            }
          })(), o0 = E.clearTimeout !== ze.clearTimeout && E.clearTimeout, n0 = L && L.now !== ze.Date.now && L.now, s0 = E.setTimeout !== ze.setTimeout && E.setTimeout, ks = Pe.ceil, xs = Pe.floor, Sl = fe.getOwnPropertySymbols, a0 = bs ? bs.isBuffer : t, Oh = E.isFinite, l0 = fs.join, c0 = xh(fe.keys, fe), Ie = Pe.max, Be = Pe.min, d0 = L.now, u0 = E.parseInt, Dh = Pe.random, h0 = fs.reverse, Al = li(E, "DataView"), jo = li(E, "Map"), El = li(E, "Promise"), Wi = li(E, "Set"), Zo = li(E, "WeakMap"), Ko = li(fe, "create"), Cs = Zo && new Zo(), Bi = {}, f0 = ci(Al), p0 = ci(jo), g0 = ci(El), m0 = ci(Wi), b0 = ci(Zo), Ss = Nr ? Nr.prototype : t, Jo = Ss ? Ss.valueOf : t, Ph = Ss ? Ss.toString : t;
          function m(n) {
            if (ke(n) && !Z(n) && !(n instanceof te)) {
              if (n instanceof Tt)
                return n;
              if (de.call(n, "__wrapped__"))
                return Mf(n);
            }
            return new Tt(n);
          }
          var Vi = /* @__PURE__ */ (function() {
            function n() {
            }
            return function(s) {
              if (!we(s))
                return {};
              if (Eh)
                return Eh(s);
              n.prototype = s;
              var c = new n();
              return n.prototype = t, c;
            };
          })();
          function As() {
          }
          function Tt(n, s) {
            this.__wrapped__ = n, this.__actions__ = [], this.__chain__ = !!s, this.__index__ = 0, this.__values__ = t;
          }
          m.templateSettings = {
            /**
             * Used to detect `data` property values to be HTML-escaped.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            escape: Dv,
            /**
             * Used to detect code to be evaluated.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            evaluate: Pv,
            /**
             * Used to detect `data` property values to inject.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            interpolate: Uu,
            /**
             * Used to reference the data object in the template text.
             *
             * @memberOf _.templateSettings
             * @type {string}
             */
            variable: "",
            /**
             * Used to import variables into the compiled template.
             *
             * @memberOf _.templateSettings
             * @type {Object}
             */
            imports: {
              /**
               * A reference to the `lodash` function.
               *
               * @memberOf _.templateSettings.imports
               * @type {Function}
               */
              _: m
            }
          }, m.prototype = As.prototype, m.prototype.constructor = m, Tt.prototype = Vi(As.prototype), Tt.prototype.constructor = Tt;
          function te(n) {
            this.__wrapped__ = n, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = rt, this.__views__ = [];
          }
          function _0() {
            var n = new te(this.__wrapped__);
            return n.__actions__ = it(this.__actions__), n.__dir__ = this.__dir__, n.__filtered__ = this.__filtered__, n.__iteratees__ = it(this.__iteratees__), n.__takeCount__ = this.__takeCount__, n.__views__ = it(this.__views__), n;
          }
          function v0() {
            if (this.__filtered__) {
              var n = new te(this);
              n.__dir__ = -1, n.__filtered__ = !0;
            } else
              n = this.clone(), n.__dir__ *= -1;
            return n;
          }
          function y0() {
            var n = this.__wrapped__.value(), s = this.__dir__, c = Z(n), h = s < 0, p = c ? n.length : 0, b = Pw(0, p, this.__views__), v = b.start, y = b.end, k = y - v, $ = h ? y : v - 1, T = this.__iteratees__, O = T.length, M = 0, R = Be(k, this.__takeCount__);
            if (!c || !h && p == k && R == k)
              return rf(n, this.__actions__);
            var B = [];
            e:
              for (; k-- && M < R; ) {
                $ += s;
                for (var J = -1, V = n[$]; ++J < O; ) {
                  var Q = T[J], re = Q.iteratee, yt = Q.type, Qe = re(V);
                  if (yt == or)
                    V = Qe;
                  else if (!Qe) {
                    if (yt == Zt)
                      continue e;
                    break e;
                  }
                }
                B[M++] = V;
              }
            return B;
          }
          te.prototype = Vi(As.prototype), te.prototype.constructor = te;
          function oi(n) {
            var s = -1, c = n == null ? 0 : n.length;
            for (this.clear(); ++s < c; ) {
              var h = n[s];
              this.set(h[0], h[1]);
            }
          }
          function w0() {
            this.__data__ = Ko ? Ko(null) : {}, this.size = 0;
          }
          function k0(n) {
            var s = this.has(n) && delete this.__data__[n];
            return this.size -= s ? 1 : 0, s;
          }
          function x0(n) {
            var s = this.__data__;
            if (Ko) {
              var c = s[n];
              return c === u ? t : c;
            }
            return de.call(s, n) ? s[n] : t;
          }
          function C0(n) {
            var s = this.__data__;
            return Ko ? s[n] !== t : de.call(s, n);
          }
          function S0(n, s) {
            var c = this.__data__;
            return this.size += this.has(n) ? 0 : 1, c[n] = Ko && s === t ? u : s, this;
          }
          oi.prototype.clear = w0, oi.prototype.delete = k0, oi.prototype.get = x0, oi.prototype.has = C0, oi.prototype.set = S0;
          function cr(n) {
            var s = -1, c = n == null ? 0 : n.length;
            for (this.clear(); ++s < c; ) {
              var h = n[s];
              this.set(h[0], h[1]);
            }
          }
          function A0() {
            this.__data__ = [], this.size = 0;
          }
          function E0(n) {
            var s = this.__data__, c = Es(s, n);
            if (c < 0)
              return !1;
            var h = s.length - 1;
            return c == h ? s.pop() : ys.call(s, c, 1), --this.size, !0;
          }
          function $0(n) {
            var s = this.__data__, c = Es(s, n);
            return c < 0 ? t : s[c][1];
          }
          function T0(n) {
            return Es(this.__data__, n) > -1;
          }
          function O0(n, s) {
            var c = this.__data__, h = Es(c, n);
            return h < 0 ? (++this.size, c.push([n, s])) : c[h][1] = s, this;
          }
          cr.prototype.clear = A0, cr.prototype.delete = E0, cr.prototype.get = $0, cr.prototype.has = T0, cr.prototype.set = O0;
          function dr(n) {
            var s = -1, c = n == null ? 0 : n.length;
            for (this.clear(); ++s < c; ) {
              var h = n[s];
              this.set(h[0], h[1]);
            }
          }
          function D0() {
            this.size = 0, this.__data__ = {
              hash: new oi(),
              map: new (jo || cr)(),
              string: new oi()
            };
          }
          function P0(n) {
            var s = zs(this, n).delete(n);
            return this.size -= s ? 1 : 0, s;
          }
          function I0(n) {
            return zs(this, n).get(n);
          }
          function M0(n) {
            return zs(this, n).has(n);
          }
          function N0(n, s) {
            var c = zs(this, n), h = c.size;
            return c.set(n, s), this.size += c.size == h ? 0 : 1, this;
          }
          dr.prototype.clear = D0, dr.prototype.delete = P0, dr.prototype.get = I0, dr.prototype.has = M0, dr.prototype.set = N0;
          function ni(n) {
            var s = -1, c = n == null ? 0 : n.length;
            for (this.__data__ = new dr(); ++s < c; )
              this.add(n[s]);
          }
          function L0(n) {
            return this.__data__.set(n, u), this;
          }
          function R0(n) {
            return this.__data__.has(n);
          }
          ni.prototype.add = ni.prototype.push = L0, ni.prototype.has = R0;
          function Ut(n) {
            var s = this.__data__ = new cr(n);
            this.size = s.size;
          }
          function F0() {
            this.__data__ = new cr(), this.size = 0;
          }
          function z0(n) {
            var s = this.__data__, c = s.delete(n);
            return this.size = s.size, c;
          }
          function H0(n) {
            return this.__data__.get(n);
          }
          function U0(n) {
            return this.__data__.has(n);
          }
          function W0(n, s) {
            var c = this.__data__;
            if (c instanceof cr) {
              var h = c.__data__;
              if (!jo || h.length < o - 1)
                return h.push([n, s]), this.size = ++c.size, this;
              c = this.__data__ = new dr(h);
            }
            return c.set(n, s), this.size = c.size, this;
          }
          Ut.prototype.clear = F0, Ut.prototype.delete = z0, Ut.prototype.get = H0, Ut.prototype.has = U0, Ut.prototype.set = W0;
          function Ih(n, s) {
            var c = Z(n), h = !c && di(n), p = !c && !h && Hr(n), b = !c && !h && !p && ji(n), v = c || h || p || b, y = v ? wl(n.length, Xy) : [], k = y.length;
            for (var $ in n)
              (s || de.call(n, $)) && !(v && // Safari 9 has enumerable `arguments.length` in strict mode.
              ($ == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
              p && ($ == "offset" || $ == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
              b && ($ == "buffer" || $ == "byteLength" || $ == "byteOffset") || // Skip index properties.
              pr($, k))) && y.push($);
            return y;
          }
          function Mh(n) {
            var s = n.length;
            return s ? n[Fl(0, s - 1)] : t;
          }
          function B0(n, s) {
            return Hs(it(n), si(s, 0, n.length));
          }
          function V0(n) {
            return Hs(it(n));
          }
          function $l(n, s, c) {
            (c !== t && !Wt(n[s], c) || c === t && !(s in n)) && ur(n, s, c);
          }
          function Xo(n, s, c) {
            var h = n[s];
            (!(de.call(n, s) && Wt(h, c)) || c === t && !(s in n)) && ur(n, s, c);
          }
          function Es(n, s) {
            for (var c = n.length; c--; )
              if (Wt(n[c][0], s))
                return c;
            return -1;
          }
          function q0(n, s, c, h) {
            return Lr(n, function(p, b, v) {
              s(h, p, c(p), v);
            }), h;
          }
          function Nh(n, s) {
            return n && Xt(s, Me(s), n);
          }
          function Y0(n, s) {
            return n && Xt(s, nt(s), n);
          }
          function ur(n, s, c) {
            s == "__proto__" && ws ? ws(n, s, {
              configurable: !0,
              enumerable: !0,
              value: c,
              writable: !0
            }) : n[s] = c;
          }
          function Tl(n, s) {
            for (var c = -1, h = s.length, p = A(h), b = n == null; ++c < h; )
              p[c] = b ? t : cc(n, s[c]);
            return p;
          }
          function si(n, s, c) {
            return n === n && (c !== t && (n = n <= c ? n : c), s !== t && (n = n >= s ? n : s)), n;
          }
          function Ot(n, s, c, h, p, b) {
            var v, y = s & _, k = s & C, $ = s & x;
            if (c && (v = p ? c(n, h, p, b) : c(n)), v !== t)
              return v;
            if (!we(n))
              return n;
            var T = Z(n);
            if (T) {
              if (v = Mw(n), !y)
                return it(n, v);
            } else {
              var O = Ve(n), M = O == Ni || O == Vo;
              if (Hr(n))
                return sf(n, y);
              if (O == St || O == Ke || M && !p) {
                if (v = k || M ? {} : Sf(n), !y)
                  return k ? xw(n, Y0(v, n)) : kw(n, Nh(v, n));
              } else {
                if (!ge[O])
                  return p ? n : {};
                v = Nw(n, O, y);
              }
            }
            b || (b = new Ut());
            var R = b.get(n);
            if (R)
              return R;
            b.set(n, v), ep(n) ? n.forEach(function(V) {
              v.add(Ot(V, s, c, V, n, b));
            }) : Xf(n) && n.forEach(function(V, Q) {
              v.set(Q, Ot(V, s, c, Q, n, b));
            });
            var B = $ ? k ? Zl : jl : k ? nt : Me, J = T ? t : B(n);
            return Et(J || n, function(V, Q) {
              J && (Q = V, V = n[Q]), Xo(v, Q, Ot(V, s, c, Q, n, b));
            }), v;
          }
          function G0(n) {
            var s = Me(n);
            return function(c) {
              return Lh(c, n, s);
            };
          }
          function Lh(n, s, c) {
            var h = c.length;
            if (n == null)
              return !h;
            for (n = fe(n); h--; ) {
              var p = c[h], b = s[p], v = n[p];
              if (v === t && !(p in n) || !b(v))
                return !1;
            }
            return !0;
          }
          function Rh(n, s, c) {
            if (typeof n != "function")
              throw new $t(l);
            return sn(function() {
              n.apply(t, c);
            }, s);
          }
          function Qo(n, s, c, h) {
            var p = -1, b = ds, v = !0, y = n.length, k = [], $ = s.length;
            if (!y)
              return k;
            c && (s = ve(s, bt(c))), h ? (b = gl, v = !1) : s.length >= o && (b = Yo, v = !1, s = new ni(s));
            e:
              for (; ++p < y; ) {
                var T = n[p], O = c == null ? T : c(T);
                if (T = h || T !== 0 ? T : 0, v && O === O) {
                  for (var M = $; M--; )
                    if (s[M] === O)
                      continue e;
                  k.push(T);
                } else b(s, O, h) || k.push(T);
              }
            return k;
          }
          var Lr = uf(Jt), Fh = uf(Dl, !0);
          function j0(n, s) {
            var c = !0;
            return Lr(n, function(h, p, b) {
              return c = !!s(h, p, b), c;
            }), c;
          }
          function $s(n, s, c) {
            for (var h = -1, p = n.length; ++h < p; ) {
              var b = n[h], v = s(b);
              if (v != null && (y === t ? v === v && !vt(v) : c(v, y)))
                var y = v, k = b;
            }
            return k;
          }
          function Z0(n, s, c, h) {
            var p = n.length;
            for (c = K(c), c < 0 && (c = -c > p ? 0 : p + c), h = h === t || h > p ? p : K(h), h < 0 && (h += p), h = c > h ? 0 : rp(h); c < h; )
              n[c++] = s;
            return n;
          }
          function zh(n, s) {
            var c = [];
            return Lr(n, function(h, p, b) {
              s(h, p, b) && c.push(h);
            }), c;
          }
          function He(n, s, c, h, p) {
            var b = -1, v = n.length;
            for (c || (c = Rw), p || (p = []); ++b < v; ) {
              var y = n[b];
              s > 0 && c(y) ? s > 1 ? He(y, s - 1, c, h, p) : Ir(p, y) : h || (p[p.length] = y);
            }
            return p;
          }
          var Ol = hf(), Hh = hf(!0);
          function Jt(n, s) {
            return n && Ol(n, s, Me);
          }
          function Dl(n, s) {
            return n && Hh(n, s, Me);
          }
          function Ts(n, s) {
            return Pr(s, function(c) {
              return gr(n[c]);
            });
          }
          function ai(n, s) {
            s = Fr(s, n);
            for (var c = 0, h = s.length; n != null && c < h; )
              n = n[Qt(s[c++])];
            return c && c == h ? n : t;
          }
          function Uh(n, s, c) {
            var h = s(n);
            return Z(n) ? h : Ir(h, c(n));
          }
          function Je(n) {
            return n == null ? n === t ? qo : os : ii && ii in fe(n) ? Dw(n) : Vw(n);
          }
          function Pl(n, s) {
            return n > s;
          }
          function K0(n, s) {
            return n != null && de.call(n, s);
          }
          function J0(n, s) {
            return n != null && s in fe(n);
          }
          function X0(n, s, c) {
            return n >= Be(s, c) && n < Ie(s, c);
          }
          function Il(n, s, c) {
            for (var h = c ? gl : ds, p = n[0].length, b = n.length, v = b, y = A(b), k = 1 / 0, $ = []; v--; ) {
              var T = n[v];
              v && s && (T = ve(T, bt(s))), k = Be(T.length, k), y[v] = !c && (s || p >= 120 && T.length >= 120) ? new ni(v && T) : t;
            }
            T = n[0];
            var O = -1, M = y[0];
            e:
              for (; ++O < p && $.length < k; ) {
                var R = T[O], B = s ? s(R) : R;
                if (R = c || R !== 0 ? R : 0, !(M ? Yo(M, B) : h($, B, c))) {
                  for (v = b; --v; ) {
                    var J = y[v];
                    if (!(J ? Yo(J, B) : h(n[v], B, c)))
                      continue e;
                  }
                  M && M.push(B), $.push(R);
                }
              }
            return $;
          }
          function Q0(n, s, c, h) {
            return Jt(n, function(p, b, v) {
              s(h, c(p), b, v);
            }), h;
          }
          function en(n, s, c) {
            s = Fr(s, n), n = Tf(n, s);
            var h = n == null ? n : n[Qt(Pt(s))];
            return h == null ? t : mt(h, n, c);
          }
          function Wh(n) {
            return ke(n) && Je(n) == Ke;
          }
          function ew(n) {
            return ke(n) && Je(n) == Dr;
          }
          function tw(n) {
            return ke(n) && Je(n) == ar;
          }
          function tn(n, s, c, h, p) {
            return n === s ? !0 : n == null || s == null || !ke(n) && !ke(s) ? n !== n && s !== s : rw(n, s, c, h, tn, p);
          }
          function rw(n, s, c, h, p, b) {
            var v = Z(n), y = Z(s), k = v ? Kt : Ve(n), $ = y ? Kt : Ve(s);
            k = k == Ke ? St : k, $ = $ == Ke ? St : $;
            var T = k == St, O = $ == St, M = k == $;
            if (M && Hr(n)) {
              if (!Hr(s))
                return !1;
              v = !0, T = !1;
            }
            if (M && !T)
              return b || (b = new Ut()), v || ji(n) ? kf(n, s, c, h, p, b) : Tw(n, s, k, c, h, p, b);
            if (!(c & D)) {
              var R = T && de.call(n, "__wrapped__"), B = O && de.call(s, "__wrapped__");
              if (R || B) {
                var J = R ? n.value() : n, V = B ? s.value() : s;
                return b || (b = new Ut()), p(J, V, c, h, b);
              }
            }
            return M ? (b || (b = new Ut()), Ow(n, s, c, h, p, b)) : !1;
          }
          function iw(n) {
            return ke(n) && Ve(n) == pt;
          }
          function Ml(n, s, c, h) {
            var p = c.length, b = p, v = !h;
            if (n == null)
              return !b;
            for (n = fe(n); p--; ) {
              var y = c[p];
              if (v && y[2] ? y[1] !== n[y[0]] : !(y[0] in n))
                return !1;
            }
            for (; ++p < b; ) {
              y = c[p];
              var k = y[0], $ = n[k], T = y[1];
              if (v && y[2]) {
                if ($ === t && !(k in n))
                  return !1;
              } else {
                var O = new Ut();
                if (h)
                  var M = h($, T, k, n, s, O);
                if (!(M === t ? tn(T, $, D | P, h, O) : M))
                  return !1;
              }
            }
            return !0;
          }
          function Bh(n) {
            if (!we(n) || zw(n))
              return !1;
            var s = gr(n) ? i0 : Gv;
            return s.test(ci(n));
          }
          function ow(n) {
            return ke(n) && Je(n) == gt;
          }
          function nw(n) {
            return ke(n) && Ve(n) == We;
          }
          function sw(n) {
            return ke(n) && Ys(n.length) && !!_e[Je(n)];
          }
          function Vh(n) {
            return typeof n == "function" ? n : n == null ? st : typeof n == "object" ? Z(n) ? Gh(n[0], n[1]) : Yh(n) : fp(n);
          }
          function Nl(n) {
            if (!nn(n))
              return c0(n);
            var s = [];
            for (var c in fe(n))
              de.call(n, c) && c != "constructor" && s.push(c);
            return s;
          }
          function aw(n) {
            if (!we(n))
              return Bw(n);
            var s = nn(n), c = [];
            for (var h in n)
              h == "constructor" && (s || !de.call(n, h)) || c.push(h);
            return c;
          }
          function Ll(n, s) {
            return n < s;
          }
          function qh(n, s) {
            var c = -1, h = ot(n) ? A(n.length) : [];
            return Lr(n, function(p, b, v) {
              h[++c] = s(p, b, v);
            }), h;
          }
          function Yh(n) {
            var s = Jl(n);
            return s.length == 1 && s[0][2] ? Ef(s[0][0], s[0][1]) : function(c) {
              return c === n || Ml(c, n, s);
            };
          }
          function Gh(n, s) {
            return Ql(n) && Af(s) ? Ef(Qt(n), s) : function(c) {
              var h = cc(c, n);
              return h === t && h === s ? dc(c, n) : tn(s, h, D | P);
            };
          }
          function Os(n, s, c, h, p) {
            n !== s && Ol(s, function(b, v) {
              if (p || (p = new Ut()), we(b))
                lw(n, s, v, c, Os, h, p);
              else {
                var y = h ? h(tc(n, v), b, v + "", n, s, p) : t;
                y === t && (y = b), $l(n, v, y);
              }
            }, nt);
          }
          function lw(n, s, c, h, p, b, v) {
            var y = tc(n, c), k = tc(s, c), $ = v.get(k);
            if ($) {
              $l(n, c, $);
              return;
            }
            var T = b ? b(y, k, c + "", n, s, v) : t, O = T === t;
            if (O) {
              var M = Z(k), R = !M && Hr(k), B = !M && !R && ji(k);
              T = k, M || R || B ? Z(y) ? T = y : Se(y) ? T = it(y) : R ? (O = !1, T = sf(k, !0)) : B ? (O = !1, T = af(k, !0)) : T = [] : an(k) || di(k) ? (T = y, di(y) ? T = ip(y) : (!we(y) || gr(y)) && (T = Sf(k))) : O = !1;
            }
            O && (v.set(k, T), p(T, k, h, b, v), v.delete(k)), $l(n, c, T);
          }
          function jh(n, s) {
            var c = n.length;
            if (c)
              return s += s < 0 ? c : 0, pr(s, c) ? n[s] : t;
          }
          function Zh(n, s, c) {
            s.length ? s = ve(s, function(b) {
              return Z(b) ? function(v) {
                return ai(v, b.length === 1 ? b[0] : b);
              } : b;
            }) : s = [st];
            var h = -1;
            s = ve(s, bt(U()));
            var p = qh(n, function(b, v, y) {
              var k = ve(s, function($) {
                return $(b);
              });
              return { criteria: k, index: ++h, value: b };
            });
            return Ny(p, function(b, v) {
              return ww(b, v, c);
            });
          }
          function cw(n, s) {
            return Kh(n, s, function(c, h) {
              return dc(n, h);
            });
          }
          function Kh(n, s, c) {
            for (var h = -1, p = s.length, b = {}; ++h < p; ) {
              var v = s[h], y = ai(n, v);
              c(y, v) && rn(b, Fr(v, n), y);
            }
            return b;
          }
          function dw(n) {
            return function(s) {
              return ai(s, n);
            };
          }
          function Rl(n, s, c, h) {
            var p = h ? My : Ri, b = -1, v = s.length, y = n;
            for (n === s && (s = it(s)), c && (y = ve(n, bt(c))); ++b < v; )
              for (var k = 0, $ = s[b], T = c ? c($) : $; (k = p(y, T, k, h)) > -1; )
                y !== n && ys.call(y, k, 1), ys.call(n, k, 1);
            return n;
          }
          function Jh(n, s) {
            for (var c = n ? s.length : 0, h = c - 1; c--; ) {
              var p = s[c];
              if (c == h || p !== b) {
                var b = p;
                pr(p) ? ys.call(n, p, 1) : Ul(n, p);
              }
            }
            return n;
          }
          function Fl(n, s) {
            return n + xs(Dh() * (s - n + 1));
          }
          function uw(n, s, c, h) {
            for (var p = -1, b = Ie(ks((s - n) / (c || 1)), 0), v = A(b); b--; )
              v[h ? b : ++p] = n, n += c;
            return v;
          }
          function zl(n, s) {
            var c = "";
            if (!n || s < 1 || s > ht)
              return c;
            do
              s % 2 && (c += n), s = xs(s / 2), s && (n += n);
            while (s);
            return c;
          }
          function X(n, s) {
            return rc($f(n, s, st), n + "");
          }
          function hw(n) {
            return Mh(Zi(n));
          }
          function fw(n, s) {
            var c = Zi(n);
            return Hs(c, si(s, 0, c.length));
          }
          function rn(n, s, c, h) {
            if (!we(n))
              return n;
            s = Fr(s, n);
            for (var p = -1, b = s.length, v = b - 1, y = n; y != null && ++p < b; ) {
              var k = Qt(s[p]), $ = c;
              if (k === "__proto__" || k === "constructor" || k === "prototype")
                return n;
              if (p != v) {
                var T = y[k];
                $ = h ? h(T, k, y) : t, $ === t && ($ = we(T) ? T : pr(s[p + 1]) ? [] : {});
              }
              Xo(y, k, $), y = y[k];
            }
            return n;
          }
          var Xh = Cs ? function(n, s) {
            return Cs.set(n, s), n;
          } : st, pw = ws ? function(n, s) {
            return ws(n, "toString", {
              configurable: !0,
              enumerable: !1,
              value: hc(s),
              writable: !0
            });
          } : st;
          function gw(n) {
            return Hs(Zi(n));
          }
          function Dt(n, s, c) {
            var h = -1, p = n.length;
            s < 0 && (s = -s > p ? 0 : p + s), c = c > p ? p : c, c < 0 && (c += p), p = s > c ? 0 : c - s >>> 0, s >>>= 0;
            for (var b = A(p); ++h < p; )
              b[h] = n[h + s];
            return b;
          }
          function mw(n, s) {
            var c;
            return Lr(n, function(h, p, b) {
              return c = s(h, p, b), !c;
            }), !!c;
          }
          function Ds(n, s, c) {
            var h = 0, p = n == null ? h : n.length;
            if (typeof s == "number" && s === s && p <= Ii) {
              for (; h < p; ) {
                var b = h + p >>> 1, v = n[b];
                v !== null && !vt(v) && (c ? v <= s : v < s) ? h = b + 1 : p = b;
              }
              return p;
            }
            return Hl(n, s, st, c);
          }
          function Hl(n, s, c, h) {
            var p = 0, b = n == null ? 0 : n.length;
            if (b === 0)
              return 0;
            s = c(s);
            for (var v = s !== s, y = s === null, k = vt(s), $ = s === t; p < b; ) {
              var T = xs((p + b) / 2), O = c(n[T]), M = O !== t, R = O === null, B = O === O, J = vt(O);
              if (v)
                var V = h || B;
              else $ ? V = B && (h || M) : y ? V = B && M && (h || !R) : k ? V = B && M && !R && (h || !J) : R || J ? V = !1 : V = h ? O <= s : O < s;
              V ? p = T + 1 : b = T;
            }
            return Be(b, Qr);
          }
          function Qh(n, s) {
            for (var c = -1, h = n.length, p = 0, b = []; ++c < h; ) {
              var v = n[c], y = s ? s(v) : v;
              if (!c || !Wt(y, k)) {
                var k = y;
                b[p++] = v === 0 ? 0 : v;
              }
            }
            return b;
          }
          function ef(n) {
            return typeof n == "number" ? n : vt(n) ? sr : +n;
          }
          function _t(n) {
            if (typeof n == "string")
              return n;
            if (Z(n))
              return ve(n, _t) + "";
            if (vt(n))
              return Ph ? Ph.call(n) : "";
            var s = n + "";
            return s == "0" && 1 / n == -De ? "-0" : s;
          }
          function Rr(n, s, c) {
            var h = -1, p = ds, b = n.length, v = !0, y = [], k = y;
            if (c)
              v = !1, p = gl;
            else if (b >= o) {
              var $ = s ? null : Ew(n);
              if ($)
                return hs($);
              v = !1, p = Yo, k = new ni();
            } else
              k = s ? [] : y;
            e:
              for (; ++h < b; ) {
                var T = n[h], O = s ? s(T) : T;
                if (T = c || T !== 0 ? T : 0, v && O === O) {
                  for (var M = k.length; M--; )
                    if (k[M] === O)
                      continue e;
                  s && k.push(O), y.push(T);
                } else p(k, O, c) || (k !== y && k.push(O), y.push(T));
              }
            return y;
          }
          function Ul(n, s) {
            return s = Fr(s, n), n = Tf(n, s), n == null || delete n[Qt(Pt(s))];
          }
          function tf(n, s, c, h) {
            return rn(n, s, c(ai(n, s)), h);
          }
          function Ps(n, s, c, h) {
            for (var p = n.length, b = h ? p : -1; (h ? b-- : ++b < p) && s(n[b], b, n); )
              ;
            return c ? Dt(n, h ? 0 : b, h ? b + 1 : p) : Dt(n, h ? b + 1 : 0, h ? p : b);
          }
          function rf(n, s) {
            var c = n;
            return c instanceof te && (c = c.value()), ml(s, function(h, p) {
              return p.func.apply(p.thisArg, Ir([h], p.args));
            }, c);
          }
          function Wl(n, s, c) {
            var h = n.length;
            if (h < 2)
              return h ? Rr(n[0]) : [];
            for (var p = -1, b = A(h); ++p < h; )
              for (var v = n[p], y = -1; ++y < h; )
                y != p && (b[p] = Qo(b[p] || v, n[y], s, c));
            return Rr(He(b, 1), s, c);
          }
          function of(n, s, c) {
            for (var h = -1, p = n.length, b = s.length, v = {}; ++h < p; ) {
              var y = h < b ? s[h] : t;
              c(v, n[h], y);
            }
            return v;
          }
          function Bl(n) {
            return Se(n) ? n : [];
          }
          function Vl(n) {
            return typeof n == "function" ? n : st;
          }
          function Fr(n, s) {
            return Z(n) ? n : Ql(n, s) ? [n] : If(le(n));
          }
          var bw = X;
          function zr(n, s, c) {
            var h = n.length;
            return c = c === t ? h : c, !s && c >= h ? n : Dt(n, s, c);
          }
          var nf = o0 || function(n) {
            return ze.clearTimeout(n);
          };
          function sf(n, s) {
            if (s)
              return n.slice();
            var c = n.length, h = Ah ? Ah(c) : new n.constructor(c);
            return n.copy(h), h;
          }
          function ql(n) {
            var s = new n.constructor(n.byteLength);
            return new _s(s).set(new _s(n)), s;
          }
          function _w(n, s) {
            var c = s ? ql(n.buffer) : n.buffer;
            return new n.constructor(c, n.byteOffset, n.byteLength);
          }
          function vw(n) {
            var s = new n.constructor(n.source, Wu.exec(n));
            return s.lastIndex = n.lastIndex, s;
          }
          function yw(n) {
            return Jo ? fe(Jo.call(n)) : {};
          }
          function af(n, s) {
            var c = s ? ql(n.buffer) : n.buffer;
            return new n.constructor(c, n.byteOffset, n.length);
          }
          function lf(n, s) {
            if (n !== s) {
              var c = n !== t, h = n === null, p = n === n, b = vt(n), v = s !== t, y = s === null, k = s === s, $ = vt(s);
              if (!y && !$ && !b && n > s || b && v && k && !y && !$ || h && v && k || !c && k || !p)
                return 1;
              if (!h && !b && !$ && n < s || $ && c && p && !h && !b || y && c && p || !v && p || !k)
                return -1;
            }
            return 0;
          }
          function ww(n, s, c) {
            for (var h = -1, p = n.criteria, b = s.criteria, v = p.length, y = c.length; ++h < v; ) {
              var k = lf(p[h], b[h]);
              if (k) {
                if (h >= y)
                  return k;
                var $ = c[h];
                return k * ($ == "desc" ? -1 : 1);
              }
            }
            return n.index - s.index;
          }
          function cf(n, s, c, h) {
            for (var p = -1, b = n.length, v = c.length, y = -1, k = s.length, $ = Ie(b - v, 0), T = A(k + $), O = !h; ++y < k; )
              T[y] = s[y];
            for (; ++p < v; )
              (O || p < b) && (T[c[p]] = n[p]);
            for (; $--; )
              T[y++] = n[p++];
            return T;
          }
          function df(n, s, c, h) {
            for (var p = -1, b = n.length, v = -1, y = c.length, k = -1, $ = s.length, T = Ie(b - y, 0), O = A(T + $), M = !h; ++p < T; )
              O[p] = n[p];
            for (var R = p; ++k < $; )
              O[R + k] = s[k];
            for (; ++v < y; )
              (M || p < b) && (O[R + c[v]] = n[p++]);
            return O;
          }
          function it(n, s) {
            var c = -1, h = n.length;
            for (s || (s = A(h)); ++c < h; )
              s[c] = n[c];
            return s;
          }
          function Xt(n, s, c, h) {
            var p = !c;
            c || (c = {});
            for (var b = -1, v = s.length; ++b < v; ) {
              var y = s[b], k = h ? h(c[y], n[y], y, c, n) : t;
              k === t && (k = n[y]), p ? ur(c, y, k) : Xo(c, y, k);
            }
            return c;
          }
          function kw(n, s) {
            return Xt(n, Xl(n), s);
          }
          function xw(n, s) {
            return Xt(n, xf(n), s);
          }
          function Is(n, s) {
            return function(c, h) {
              var p = Z(c) ? $y : q0, b = s ? s() : {};
              return p(c, n, U(h, 2), b);
            };
          }
          function qi(n) {
            return X(function(s, c) {
              var h = -1, p = c.length, b = p > 1 ? c[p - 1] : t, v = p > 2 ? c[2] : t;
              for (b = n.length > 3 && typeof b == "function" ? (p--, b) : t, v && Xe(c[0], c[1], v) && (b = p < 3 ? t : b, p = 1), s = fe(s); ++h < p; ) {
                var y = c[h];
                y && n(s, y, h, b);
              }
              return s;
            });
          }
          function uf(n, s) {
            return function(c, h) {
              if (c == null)
                return c;
              if (!ot(c))
                return n(c, h);
              for (var p = c.length, b = s ? p : -1, v = fe(c); (s ? b-- : ++b < p) && h(v[b], b, v) !== !1; )
                ;
              return c;
            };
          }
          function hf(n) {
            return function(s, c, h) {
              for (var p = -1, b = fe(s), v = h(s), y = v.length; y--; ) {
                var k = v[n ? y : ++p];
                if (c(b[k], k, b) === !1)
                  break;
              }
              return s;
            };
          }
          function Cw(n, s, c) {
            var h = s & I, p = on(n);
            function b() {
              var v = this && this !== ze && this instanceof b ? p : n;
              return v.apply(h ? c : this, arguments);
            }
            return b;
          }
          function ff(n) {
            return function(s) {
              s = le(s);
              var c = Fi(s) ? Ht(s) : t, h = c ? c[0] : s.charAt(0), p = c ? zr(c, 1).join("") : s.slice(1);
              return h[n]() + p;
            };
          }
          function Yi(n) {
            return function(s) {
              return ml(up(dp(s).replace(py, "")), n, "");
            };
          }
          function on(n) {
            return function() {
              var s = arguments;
              switch (s.length) {
                case 0:
                  return new n();
                case 1:
                  return new n(s[0]);
                case 2:
                  return new n(s[0], s[1]);
                case 3:
                  return new n(s[0], s[1], s[2]);
                case 4:
                  return new n(s[0], s[1], s[2], s[3]);
                case 5:
                  return new n(s[0], s[1], s[2], s[3], s[4]);
                case 6:
                  return new n(s[0], s[1], s[2], s[3], s[4], s[5]);
                case 7:
                  return new n(s[0], s[1], s[2], s[3], s[4], s[5], s[6]);
              }
              var c = Vi(n.prototype), h = n.apply(c, s);
              return we(h) ? h : c;
            };
          }
          function Sw(n, s, c) {
            var h = on(n);
            function p() {
              for (var b = arguments.length, v = A(b), y = b, k = Gi(p); y--; )
                v[y] = arguments[y];
              var $ = b < 3 && v[0] !== k && v[b - 1] !== k ? [] : Mr(v, k);
              if (b -= $.length, b < c)
                return _f(
                  n,
                  s,
                  Ms,
                  p.placeholder,
                  t,
                  v,
                  $,
                  t,
                  t,
                  c - b
                );
              var T = this && this !== ze && this instanceof p ? h : n;
              return mt(T, this, v);
            }
            return p;
          }
          function pf(n) {
            return function(s, c, h) {
              var p = fe(s);
              if (!ot(s)) {
                var b = U(c, 3);
                s = Me(s), c = function(y) {
                  return b(p[y], y, p);
                };
              }
              var v = n(s, c, h);
              return v > -1 ? p[b ? s[v] : v] : t;
            };
          }
          function gf(n) {
            return fr(function(s) {
              var c = s.length, h = c, p = Tt.prototype.thru;
              for (n && s.reverse(); h--; ) {
                var b = s[h];
                if (typeof b != "function")
                  throw new $t(l);
                if (p && !v && Fs(b) == "wrapper")
                  var v = new Tt([], !0);
              }
              for (h = v ? h : c; ++h < c; ) {
                b = s[h];
                var y = Fs(b), k = y == "wrapper" ? Kl(b) : t;
                k && ec(k[0]) && k[1] == (ie | Y | G | be) && !k[4].length && k[9] == 1 ? v = v[Fs(k[0])].apply(v, k[3]) : v = b.length == 1 && ec(b) ? v[y]() : v.thru(b);
              }
              return function() {
                var $ = arguments, T = $[0];
                if (v && $.length == 1 && Z(T))
                  return v.plant(T).value();
                for (var O = 0, M = c ? s[O].apply(this, $) : T; ++O < c; )
                  M = s[O].call(this, M);
                return M;
              };
            });
          }
          function Ms(n, s, c, h, p, b, v, y, k, $) {
            var T = s & ie, O = s & I, M = s & F, R = s & (Y | W), B = s & ue, J = M ? t : on(n);
            function V() {
              for (var Q = arguments.length, re = A(Q), yt = Q; yt--; )
                re[yt] = arguments[yt];
              if (R)
                var Qe = Gi(V), wt = Ry(re, Qe);
              if (h && (re = cf(re, h, p, R)), b && (re = df(re, b, v, R)), Q -= wt, R && Q < $) {
                var Ae = Mr(re, Qe);
                return _f(
                  n,
                  s,
                  Ms,
                  V.placeholder,
                  c,
                  re,
                  Ae,
                  y,
                  k,
                  $ - Q
                );
              }
              var Bt = O ? c : this, br = M ? Bt[n] : n;
              return Q = re.length, y ? re = qw(re, y) : B && Q > 1 && re.reverse(), T && k < Q && (re.length = k), this && this !== ze && this instanceof V && (br = J || on(br)), br.apply(Bt, re);
            }
            return V;
          }
          function mf(n, s) {
            return function(c, h) {
              return Q0(c, n, s(h), {});
            };
          }
          function Ns(n, s) {
            return function(c, h) {
              var p;
              if (c === t && h === t)
                return s;
              if (c !== t && (p = c), h !== t) {
                if (p === t)
                  return h;
                typeof c == "string" || typeof h == "string" ? (c = _t(c), h = _t(h)) : (c = ef(c), h = ef(h)), p = n(c, h);
              }
              return p;
            };
          }
          function Yl(n) {
            return fr(function(s) {
              return s = ve(s, bt(U())), X(function(c) {
                var h = this;
                return n(s, function(p) {
                  return mt(p, h, c);
                });
              });
            });
          }
          function Ls(n, s) {
            s = s === t ? " " : _t(s);
            var c = s.length;
            if (c < 2)
              return c ? zl(s, n) : s;
            var h = zl(s, ks(n / zi(s)));
            return Fi(s) ? zr(Ht(h), 0, n).join("") : h.slice(0, n);
          }
          function Aw(n, s, c, h) {
            var p = s & I, b = on(n);
            function v() {
              for (var y = -1, k = arguments.length, $ = -1, T = h.length, O = A(T + k), M = this && this !== ze && this instanceof v ? b : n; ++$ < T; )
                O[$] = h[$];
              for (; k--; )
                O[$++] = arguments[++y];
              return mt(M, p ? c : this, O);
            }
            return v;
          }
          function bf(n) {
            return function(s, c, h) {
              return h && typeof h != "number" && Xe(s, c, h) && (c = h = t), s = mr(s), c === t ? (c = s, s = 0) : c = mr(c), h = h === t ? s < c ? 1 : -1 : mr(h), uw(s, c, h, n);
            };
          }
          function Rs(n) {
            return function(s, c) {
              return typeof s == "string" && typeof c == "string" || (s = It(s), c = It(c)), n(s, c);
            };
          }
          function _f(n, s, c, h, p, b, v, y, k, $) {
            var T = s & Y, O = T ? v : t, M = T ? t : v, R = T ? b : t, B = T ? t : b;
            s |= T ? G : ee, s &= ~(T ? ee : G), s & H || (s &= -4);
            var J = [
              n,
              s,
              p,
              R,
              O,
              B,
              M,
              y,
              k,
              $
            ], V = c.apply(t, J);
            return ec(n) && Of(V, J), V.placeholder = h, Df(V, n, s);
          }
          function Gl(n) {
            var s = Pe[n];
            return function(c, h) {
              if (c = It(c), h = h == null ? 0 : Be(K(h), 292), h && Oh(c)) {
                var p = (le(c) + "e").split("e"), b = s(p[0] + "e" + (+p[1] + h));
                return p = (le(b) + "e").split("e"), +(p[0] + "e" + (+p[1] - h));
              }
              return s(c);
            };
          }
          var Ew = Wi && 1 / hs(new Wi([, -0]))[1] == De ? function(n) {
            return new Wi(n);
          } : gc;
          function vf(n) {
            return function(s) {
              var c = Ve(s);
              return c == pt ? xl(s) : c == We ? Vy(s) : Ly(s, n(s));
            };
          }
          function hr(n, s, c, h, p, b, v, y) {
            var k = s & F;
            if (!k && typeof n != "function")
              throw new $t(l);
            var $ = h ? h.length : 0;
            if ($ || (s &= -97, h = p = t), v = v === t ? v : Ie(K(v), 0), y = y === t ? y : K(y), $ -= p ? p.length : 0, s & ee) {
              var T = h, O = p;
              h = p = t;
            }
            var M = k ? t : Kl(n), R = [
              n,
              s,
              c,
              h,
              p,
              T,
              O,
              b,
              v,
              y
            ];
            if (M && Ww(R, M), n = R[0], s = R[1], c = R[2], h = R[3], p = R[4], y = R[9] = R[9] === t ? k ? 0 : n.length : Ie(R[9] - $, 0), !y && s & (Y | W) && (s &= -25), !s || s == I)
              var B = Cw(n, s, c);
            else s == Y || s == W ? B = Sw(n, s, y) : (s == G || s == (I | G)) && !p.length ? B = Aw(n, s, c, h) : B = Ms.apply(t, R);
            var J = M ? Xh : Of;
            return Df(J(B, R), n, s);
          }
          function yf(n, s, c, h) {
            return n === t || Wt(n, Ui[c]) && !de.call(h, c) ? s : n;
          }
          function wf(n, s, c, h, p, b) {
            return we(n) && we(s) && (b.set(s, n), Os(n, s, t, wf, b), b.delete(s)), n;
          }
          function $w(n) {
            return an(n) ? t : n;
          }
          function kf(n, s, c, h, p, b) {
            var v = c & D, y = n.length, k = s.length;
            if (y != k && !(v && k > y))
              return !1;
            var $ = b.get(n), T = b.get(s);
            if ($ && T)
              return $ == s && T == n;
            var O = -1, M = !0, R = c & P ? new ni() : t;
            for (b.set(n, s), b.set(s, n); ++O < y; ) {
              var B = n[O], J = s[O];
              if (h)
                var V = v ? h(J, B, O, s, n, b) : h(B, J, O, n, s, b);
              if (V !== t) {
                if (V)
                  continue;
                M = !1;
                break;
              }
              if (R) {
                if (!bl(s, function(Q, re) {
                  if (!Yo(R, re) && (B === Q || p(B, Q, c, h, b)))
                    return R.push(re);
                })) {
                  M = !1;
                  break;
                }
              } else if (!(B === J || p(B, J, c, h, b))) {
                M = !1;
                break;
              }
            }
            return b.delete(n), b.delete(s), M;
          }
          function Tw(n, s, c, h, p, b, v) {
            switch (c) {
              case lr:
                if (n.byteLength != s.byteLength || n.byteOffset != s.byteOffset)
                  return !1;
                n = n.buffer, s = s.buffer;
              case Dr:
                return !(n.byteLength != s.byteLength || !b(new _s(n), new _s(s)));
              case ft:
              case ar:
              case ei:
                return Wt(+n, +s);
              case $r:
                return n.name == s.name && n.message == s.message;
              case gt:
              case Tr:
                return n == s + "";
              case pt:
                var y = xl;
              case We:
                var k = h & D;
                if (y || (y = hs), n.size != s.size && !k)
                  return !1;
                var $ = v.get(n);
                if ($)
                  return $ == s;
                h |= P, v.set(n, s);
                var T = kf(y(n), y(s), h, p, b, v);
                return v.delete(n), T;
              case ti:
                if (Jo)
                  return Jo.call(n) == Jo.call(s);
            }
            return !1;
          }
          function Ow(n, s, c, h, p, b) {
            var v = c & D, y = jl(n), k = y.length, $ = jl(s), T = $.length;
            if (k != T && !v)
              return !1;
            for (var O = k; O--; ) {
              var M = y[O];
              if (!(v ? M in s : de.call(s, M)))
                return !1;
            }
            var R = b.get(n), B = b.get(s);
            if (R && B)
              return R == s && B == n;
            var J = !0;
            b.set(n, s), b.set(s, n);
            for (var V = v; ++O < k; ) {
              M = y[O];
              var Q = n[M], re = s[M];
              if (h)
                var yt = v ? h(re, Q, M, s, n, b) : h(Q, re, M, n, s, b);
              if (!(yt === t ? Q === re || p(Q, re, c, h, b) : yt)) {
                J = !1;
                break;
              }
              V || (V = M == "constructor");
            }
            if (J && !V) {
              var Qe = n.constructor, wt = s.constructor;
              Qe != wt && "constructor" in n && "constructor" in s && !(typeof Qe == "function" && Qe instanceof Qe && typeof wt == "function" && wt instanceof wt) && (J = !1);
            }
            return b.delete(n), b.delete(s), J;
          }
          function fr(n) {
            return rc($f(n, t, Rf), n + "");
          }
          function jl(n) {
            return Uh(n, Me, Xl);
          }
          function Zl(n) {
            return Uh(n, nt, xf);
          }
          var Kl = Cs ? function(n) {
            return Cs.get(n);
          } : gc;
          function Fs(n) {
            for (var s = n.name + "", c = Bi[s], h = de.call(Bi, s) ? c.length : 0; h--; ) {
              var p = c[h], b = p.func;
              if (b == null || b == n)
                return p.name;
            }
            return s;
          }
          function Gi(n) {
            var s = de.call(m, "placeholder") ? m : n;
            return s.placeholder;
          }
          function U() {
            var n = m.iteratee || fc;
            return n = n === fc ? Vh : n, arguments.length ? n(arguments[0], arguments[1]) : n;
          }
          function zs(n, s) {
            var c = n.__data__;
            return Fw(s) ? c[typeof s == "string" ? "string" : "hash"] : c.map;
          }
          function Jl(n) {
            for (var s = Me(n), c = s.length; c--; ) {
              var h = s[c], p = n[h];
              s[c] = [h, p, Af(p)];
            }
            return s;
          }
          function li(n, s) {
            var c = Uy(n, s);
            return Bh(c) ? c : t;
          }
          function Dw(n) {
            var s = de.call(n, ii), c = n[ii];
            try {
              n[ii] = t;
              var h = !0;
            } catch {
            }
            var p = ms.call(n);
            return h && (s ? n[ii] = c : delete n[ii]), p;
          }
          var Xl = Sl ? function(n) {
            return n == null ? [] : (n = fe(n), Pr(Sl(n), function(s) {
              return $h.call(n, s);
            }));
          } : mc, xf = Sl ? function(n) {
            for (var s = []; n; )
              Ir(s, Xl(n)), n = vs(n);
            return s;
          } : mc, Ve = Je;
          (Al && Ve(new Al(new ArrayBuffer(1))) != lr || jo && Ve(new jo()) != pt || El && Ve(El.resolve()) != ns || Wi && Ve(new Wi()) != We || Zo && Ve(new Zo()) != Or) && (Ve = function(n) {
            var s = Je(n), c = s == St ? n.constructor : t, h = c ? ci(c) : "";
            if (h)
              switch (h) {
                case f0:
                  return lr;
                case p0:
                  return pt;
                case g0:
                  return ns;
                case m0:
                  return We;
                case b0:
                  return Or;
              }
            return s;
          });
          function Pw(n, s, c) {
            for (var h = -1, p = c.length; ++h < p; ) {
              var b = c[h], v = b.size;
              switch (b.type) {
                case "drop":
                  n += v;
                  break;
                case "dropRight":
                  s -= v;
                  break;
                case "take":
                  s = Be(s, n + v);
                  break;
                case "takeRight":
                  n = Ie(n, s - v);
                  break;
              }
            }
            return { start: n, end: s };
          }
          function Iw(n) {
            var s = n.match(zv);
            return s ? s[1].split(Hv) : [];
          }
          function Cf(n, s, c) {
            s = Fr(s, n);
            for (var h = -1, p = s.length, b = !1; ++h < p; ) {
              var v = Qt(s[h]);
              if (!(b = n != null && c(n, v)))
                break;
              n = n[v];
            }
            return b || ++h != p ? b : (p = n == null ? 0 : n.length, !!p && Ys(p) && pr(v, p) && (Z(n) || di(n)));
          }
          function Mw(n) {
            var s = n.length, c = new n.constructor(s);
            return s && typeof n[0] == "string" && de.call(n, "index") && (c.index = n.index, c.input = n.input), c;
          }
          function Sf(n) {
            return typeof n.constructor == "function" && !nn(n) ? Vi(vs(n)) : {};
          }
          function Nw(n, s, c) {
            var h = n.constructor;
            switch (s) {
              case Dr:
                return ql(n);
              case ft:
              case ar:
                return new h(+n);
              case lr:
                return _w(n, c);
              case Ja:
              case Xa:
              case Qa:
              case el:
              case tl:
              case rl:
              case il:
              case ol:
              case nl:
                return af(n, c);
              case pt:
                return new h();
              case ei:
              case Tr:
                return new h(n);
              case gt:
                return vw(n);
              case We:
                return new h();
              case ti:
                return yw(n);
            }
          }
          function Lw(n, s) {
            var c = s.length;
            if (!c)
              return n;
            var h = c - 1;
            return s[h] = (c > 1 ? "& " : "") + s[h], s = s.join(c > 2 ? ", " : " "), n.replace(Fv, `{
/* [wrapped with ` + s + `] */
`);
          }
          function Rw(n) {
            return Z(n) || di(n) || !!(Th && n && n[Th]);
          }
          function pr(n, s) {
            var c = typeof n;
            return s = s ?? ht, !!s && (c == "number" || c != "symbol" && Zv.test(n)) && n > -1 && n % 1 == 0 && n < s;
          }
          function Xe(n, s, c) {
            if (!we(c))
              return !1;
            var h = typeof s;
            return (h == "number" ? ot(c) && pr(s, c.length) : h == "string" && s in c) ? Wt(c[s], n) : !1;
          }
          function Ql(n, s) {
            if (Z(n))
              return !1;
            var c = typeof n;
            return c == "number" || c == "symbol" || c == "boolean" || n == null || vt(n) ? !0 : Mv.test(n) || !Iv.test(n) || s != null && n in fe(s);
          }
          function Fw(n) {
            var s = typeof n;
            return s == "string" || s == "number" || s == "symbol" || s == "boolean" ? n !== "__proto__" : n === null;
          }
          function ec(n) {
            var s = Fs(n), c = m[s];
            if (typeof c != "function" || !(s in te.prototype))
              return !1;
            if (n === c)
              return !0;
            var h = Kl(c);
            return !!h && n === h[0];
          }
          function zw(n) {
            return !!Sh && Sh in n;
          }
          var Hw = ps ? gr : bc;
          function nn(n) {
            var s = n && n.constructor, c = typeof s == "function" && s.prototype || Ui;
            return n === c;
          }
          function Af(n) {
            return n === n && !we(n);
          }
          function Ef(n, s) {
            return function(c) {
              return c == null ? !1 : c[n] === s && (s !== t || n in fe(c));
            };
          }
          function Uw(n) {
            var s = Vs(n, function(h) {
              return c.size === f && c.clear(), h;
            }), c = s.cache;
            return s;
          }
          function Ww(n, s) {
            var c = n[1], h = s[1], p = c | h, b = p < (I | F | ie), v = h == ie && c == Y || h == ie && c == be && n[7].length <= s[8] || h == (ie | be) && s[7].length <= s[8] && c == Y;
            if (!(b || v))
              return n;
            h & I && (n[2] = s[2], p |= c & I ? 0 : H);
            var y = s[3];
            if (y) {
              var k = n[3];
              n[3] = k ? cf(k, y, s[4]) : y, n[4] = k ? Mr(n[3], g) : s[4];
            }
            return y = s[5], y && (k = n[5], n[5] = k ? df(k, y, s[6]) : y, n[6] = k ? Mr(n[5], g) : s[6]), y = s[7], y && (n[7] = y), h & ie && (n[8] = n[8] == null ? s[8] : Be(n[8], s[8])), n[9] == null && (n[9] = s[9]), n[0] = s[0], n[1] = p, n;
          }
          function Bw(n) {
            var s = [];
            if (n != null)
              for (var c in fe(n))
                s.push(c);
            return s;
          }
          function Vw(n) {
            return ms.call(n);
          }
          function $f(n, s, c) {
            return s = Ie(s === t ? n.length - 1 : s, 0), function() {
              for (var h = arguments, p = -1, b = Ie(h.length - s, 0), v = A(b); ++p < b; )
                v[p] = h[s + p];
              p = -1;
              for (var y = A(s + 1); ++p < s; )
                y[p] = h[p];
              return y[s] = c(v), mt(n, this, y);
            };
          }
          function Tf(n, s) {
            return s.length < 2 ? n : ai(n, Dt(s, 0, -1));
          }
          function qw(n, s) {
            for (var c = n.length, h = Be(s.length, c), p = it(n); h--; ) {
              var b = s[h];
              n[h] = pr(b, c) ? p[b] : t;
            }
            return n;
          }
          function tc(n, s) {
            if (!(s === "constructor" && typeof n[s] == "function") && s != "__proto__")
              return n[s];
          }
          var Of = Pf(Xh), sn = s0 || function(n, s) {
            return ze.setTimeout(n, s);
          }, rc = Pf(pw);
          function Df(n, s, c) {
            var h = s + "";
            return rc(n, Lw(h, Yw(Iw(h), c)));
          }
          function Pf(n) {
            var s = 0, c = 0;
            return function() {
              var h = d0(), p = Fe - (h - c);
              if (c = h, p > 0) {
                if (++s >= ut)
                  return arguments[0];
              } else
                s = 0;
              return n.apply(t, arguments);
            };
          }
          function Hs(n, s) {
            var c = -1, h = n.length, p = h - 1;
            for (s = s === t ? h : s; ++c < s; ) {
              var b = Fl(c, p), v = n[b];
              n[b] = n[c], n[c] = v;
            }
            return n.length = s, n;
          }
          var If = Uw(function(n) {
            var s = [];
            return n.charCodeAt(0) === 46 && s.push(""), n.replace(Nv, function(c, h, p, b) {
              s.push(p ? b.replace(Bv, "$1") : h || c);
            }), s;
          });
          function Qt(n) {
            if (typeof n == "string" || vt(n))
              return n;
            var s = n + "";
            return s == "0" && 1 / n == -De ? "-0" : s;
          }
          function ci(n) {
            if (n != null) {
              try {
                return gs.call(n);
              } catch {
              }
              try {
                return n + "";
              } catch {
              }
            }
            return "";
          }
          function Yw(n, s) {
            return Et(Er, function(c) {
              var h = "_." + c[0];
              s & c[1] && !ds(n, h) && n.push(h);
            }), n.sort();
          }
          function Mf(n) {
            if (n instanceof te)
              return n.clone();
            var s = new Tt(n.__wrapped__, n.__chain__);
            return s.__actions__ = it(n.__actions__), s.__index__ = n.__index__, s.__values__ = n.__values__, s;
          }
          function Gw(n, s, c) {
            (c ? Xe(n, s, c) : s === t) ? s = 1 : s = Ie(K(s), 0);
            var h = n == null ? 0 : n.length;
            if (!h || s < 1)
              return [];
            for (var p = 0, b = 0, v = A(ks(h / s)); p < h; )
              v[b++] = Dt(n, p, p += s);
            return v;
          }
          function jw(n) {
            for (var s = -1, c = n == null ? 0 : n.length, h = 0, p = []; ++s < c; ) {
              var b = n[s];
              b && (p[h++] = b);
            }
            return p;
          }
          function Zw() {
            var n = arguments.length;
            if (!n)
              return [];
            for (var s = A(n - 1), c = arguments[0], h = n; h--; )
              s[h - 1] = arguments[h];
            return Ir(Z(c) ? it(c) : [c], He(s, 1));
          }
          var Kw = X(function(n, s) {
            return Se(n) ? Qo(n, He(s, 1, Se, !0)) : [];
          }), Jw = X(function(n, s) {
            var c = Pt(s);
            return Se(c) && (c = t), Se(n) ? Qo(n, He(s, 1, Se, !0), U(c, 2)) : [];
          }), Xw = X(function(n, s) {
            var c = Pt(s);
            return Se(c) && (c = t), Se(n) ? Qo(n, He(s, 1, Se, !0), t, c) : [];
          });
          function Qw(n, s, c) {
            var h = n == null ? 0 : n.length;
            return h ? (s = c || s === t ? 1 : K(s), Dt(n, s < 0 ? 0 : s, h)) : [];
          }
          function ek(n, s, c) {
            var h = n == null ? 0 : n.length;
            return h ? (s = c || s === t ? 1 : K(s), s = h - s, Dt(n, 0, s < 0 ? 0 : s)) : [];
          }
          function tk(n, s) {
            return n && n.length ? Ps(n, U(s, 3), !0, !0) : [];
          }
          function rk(n, s) {
            return n && n.length ? Ps(n, U(s, 3), !0) : [];
          }
          function ik(n, s, c, h) {
            var p = n == null ? 0 : n.length;
            return p ? (c && typeof c != "number" && Xe(n, s, c) && (c = 0, h = p), Z0(n, s, c, h)) : [];
          }
          function Nf(n, s, c) {
            var h = n == null ? 0 : n.length;
            if (!h)
              return -1;
            var p = c == null ? 0 : K(c);
            return p < 0 && (p = Ie(h + p, 0)), us(n, U(s, 3), p);
          }
          function Lf(n, s, c) {
            var h = n == null ? 0 : n.length;
            if (!h)
              return -1;
            var p = h - 1;
            return c !== t && (p = K(c), p = c < 0 ? Ie(h + p, 0) : Be(p, h - 1)), us(n, U(s, 3), p, !0);
          }
          function Rf(n) {
            var s = n == null ? 0 : n.length;
            return s ? He(n, 1) : [];
          }
          function ok(n) {
            var s = n == null ? 0 : n.length;
            return s ? He(n, De) : [];
          }
          function nk(n, s) {
            var c = n == null ? 0 : n.length;
            return c ? (s = s === t ? 1 : K(s), He(n, s)) : [];
          }
          function sk(n) {
            for (var s = -1, c = n == null ? 0 : n.length, h = {}; ++s < c; ) {
              var p = n[s];
              h[p[0]] = p[1];
            }
            return h;
          }
          function Ff(n) {
            return n && n.length ? n[0] : t;
          }
          function ak(n, s, c) {
            var h = n == null ? 0 : n.length;
            if (!h)
              return -1;
            var p = c == null ? 0 : K(c);
            return p < 0 && (p = Ie(h + p, 0)), Ri(n, s, p);
          }
          function lk(n) {
            var s = n == null ? 0 : n.length;
            return s ? Dt(n, 0, -1) : [];
          }
          var ck = X(function(n) {
            var s = ve(n, Bl);
            return s.length && s[0] === n[0] ? Il(s) : [];
          }), dk = X(function(n) {
            var s = Pt(n), c = ve(n, Bl);
            return s === Pt(c) ? s = t : c.pop(), c.length && c[0] === n[0] ? Il(c, U(s, 2)) : [];
          }), uk = X(function(n) {
            var s = Pt(n), c = ve(n, Bl);
            return s = typeof s == "function" ? s : t, s && c.pop(), c.length && c[0] === n[0] ? Il(c, t, s) : [];
          });
          function hk(n, s) {
            return n == null ? "" : l0.call(n, s);
          }
          function Pt(n) {
            var s = n == null ? 0 : n.length;
            return s ? n[s - 1] : t;
          }
          function fk(n, s, c) {
            var h = n == null ? 0 : n.length;
            if (!h)
              return -1;
            var p = h;
            return c !== t && (p = K(c), p = p < 0 ? Ie(h + p, 0) : Be(p, h - 1)), s === s ? Yy(n, s, p) : us(n, bh, p, !0);
          }
          function pk(n, s) {
            return n && n.length ? jh(n, K(s)) : t;
          }
          var gk = X(zf);
          function zf(n, s) {
            return n && n.length && s && s.length ? Rl(n, s) : n;
          }
          function mk(n, s, c) {
            return n && n.length && s && s.length ? Rl(n, s, U(c, 2)) : n;
          }
          function bk(n, s, c) {
            return n && n.length && s && s.length ? Rl(n, s, t, c) : n;
          }
          var _k = fr(function(n, s) {
            var c = n == null ? 0 : n.length, h = Tl(n, s);
            return Jh(n, ve(s, function(p) {
              return pr(p, c) ? +p : p;
            }).sort(lf)), h;
          });
          function vk(n, s) {
            var c = [];
            if (!(n && n.length))
              return c;
            var h = -1, p = [], b = n.length;
            for (s = U(s, 3); ++h < b; ) {
              var v = n[h];
              s(v, h, n) && (c.push(v), p.push(h));
            }
            return Jh(n, p), c;
          }
          function ic(n) {
            return n == null ? n : h0.call(n);
          }
          function yk(n, s, c) {
            var h = n == null ? 0 : n.length;
            return h ? (c && typeof c != "number" && Xe(n, s, c) ? (s = 0, c = h) : (s = s == null ? 0 : K(s), c = c === t ? h : K(c)), Dt(n, s, c)) : [];
          }
          function wk(n, s) {
            return Ds(n, s);
          }
          function kk(n, s, c) {
            return Hl(n, s, U(c, 2));
          }
          function xk(n, s) {
            var c = n == null ? 0 : n.length;
            if (c) {
              var h = Ds(n, s);
              if (h < c && Wt(n[h], s))
                return h;
            }
            return -1;
          }
          function Ck(n, s) {
            return Ds(n, s, !0);
          }
          function Sk(n, s, c) {
            return Hl(n, s, U(c, 2), !0);
          }
          function Ak(n, s) {
            var c = n == null ? 0 : n.length;
            if (c) {
              var h = Ds(n, s, !0) - 1;
              if (Wt(n[h], s))
                return h;
            }
            return -1;
          }
          function Ek(n) {
            return n && n.length ? Qh(n) : [];
          }
          function $k(n, s) {
            return n && n.length ? Qh(n, U(s, 2)) : [];
          }
          function Tk(n) {
            var s = n == null ? 0 : n.length;
            return s ? Dt(n, 1, s) : [];
          }
          function Ok(n, s, c) {
            return n && n.length ? (s = c || s === t ? 1 : K(s), Dt(n, 0, s < 0 ? 0 : s)) : [];
          }
          function Dk(n, s, c) {
            var h = n == null ? 0 : n.length;
            return h ? (s = c || s === t ? 1 : K(s), s = h - s, Dt(n, s < 0 ? 0 : s, h)) : [];
          }
          function Pk(n, s) {
            return n && n.length ? Ps(n, U(s, 3), !1, !0) : [];
          }
          function Ik(n, s) {
            return n && n.length ? Ps(n, U(s, 3)) : [];
          }
          var Mk = X(function(n) {
            return Rr(He(n, 1, Se, !0));
          }), Nk = X(function(n) {
            var s = Pt(n);
            return Se(s) && (s = t), Rr(He(n, 1, Se, !0), U(s, 2));
          }), Lk = X(function(n) {
            var s = Pt(n);
            return s = typeof s == "function" ? s : t, Rr(He(n, 1, Se, !0), t, s);
          });
          function Rk(n) {
            return n && n.length ? Rr(n) : [];
          }
          function Fk(n, s) {
            return n && n.length ? Rr(n, U(s, 2)) : [];
          }
          function zk(n, s) {
            return s = typeof s == "function" ? s : t, n && n.length ? Rr(n, t, s) : [];
          }
          function oc(n) {
            if (!(n && n.length))
              return [];
            var s = 0;
            return n = Pr(n, function(c) {
              if (Se(c))
                return s = Ie(c.length, s), !0;
            }), wl(s, function(c) {
              return ve(n, _l(c));
            });
          }
          function Hf(n, s) {
            if (!(n && n.length))
              return [];
            var c = oc(n);
            return s == null ? c : ve(c, function(h) {
              return mt(s, t, h);
            });
          }
          var Hk = X(function(n, s) {
            return Se(n) ? Qo(n, s) : [];
          }), Uk = X(function(n) {
            return Wl(Pr(n, Se));
          }), Wk = X(function(n) {
            var s = Pt(n);
            return Se(s) && (s = t), Wl(Pr(n, Se), U(s, 2));
          }), Bk = X(function(n) {
            var s = Pt(n);
            return s = typeof s == "function" ? s : t, Wl(Pr(n, Se), t, s);
          }), Vk = X(oc);
          function qk(n, s) {
            return of(n || [], s || [], Xo);
          }
          function Yk(n, s) {
            return of(n || [], s || [], rn);
          }
          var Gk = X(function(n) {
            var s = n.length, c = s > 1 ? n[s - 1] : t;
            return c = typeof c == "function" ? (n.pop(), c) : t, Hf(n, c);
          });
          function Uf(n) {
            var s = m(n);
            return s.__chain__ = !0, s;
          }
          function jk(n, s) {
            return s(n), n;
          }
          function Us(n, s) {
            return s(n);
          }
          var Zk = fr(function(n) {
            var s = n.length, c = s ? n[0] : 0, h = this.__wrapped__, p = function(b) {
              return Tl(b, n);
            };
            return s > 1 || this.__actions__.length || !(h instanceof te) || !pr(c) ? this.thru(p) : (h = h.slice(c, +c + (s ? 1 : 0)), h.__actions__.push({
              func: Us,
              args: [p],
              thisArg: t
            }), new Tt(h, this.__chain__).thru(function(b) {
              return s && !b.length && b.push(t), b;
            }));
          });
          function Kk() {
            return Uf(this);
          }
          function Jk() {
            return new Tt(this.value(), this.__chain__);
          }
          function Xk() {
            this.__values__ === t && (this.__values__ = tp(this.value()));
            var n = this.__index__ >= this.__values__.length, s = n ? t : this.__values__[this.__index__++];
            return { done: n, value: s };
          }
          function Qk() {
            return this;
          }
          function ex(n) {
            for (var s, c = this; c instanceof As; ) {
              var h = Mf(c);
              h.__index__ = 0, h.__values__ = t, s ? p.__wrapped__ = h : s = h;
              var p = h;
              c = c.__wrapped__;
            }
            return p.__wrapped__ = n, s;
          }
          function tx() {
            var n = this.__wrapped__;
            if (n instanceof te) {
              var s = n;
              return this.__actions__.length && (s = new te(this)), s = s.reverse(), s.__actions__.push({
                func: Us,
                args: [ic],
                thisArg: t
              }), new Tt(s, this.__chain__);
            }
            return this.thru(ic);
          }
          function rx() {
            return rf(this.__wrapped__, this.__actions__);
          }
          var ix = Is(function(n, s, c) {
            de.call(n, c) ? ++n[c] : ur(n, c, 1);
          });
          function ox(n, s, c) {
            var h = Z(n) ? gh : j0;
            return c && Xe(n, s, c) && (s = t), h(n, U(s, 3));
          }
          function nx(n, s) {
            var c = Z(n) ? Pr : zh;
            return c(n, U(s, 3));
          }
          var sx = pf(Nf), ax = pf(Lf);
          function lx(n, s) {
            return He(Ws(n, s), 1);
          }
          function cx(n, s) {
            return He(Ws(n, s), De);
          }
          function dx(n, s, c) {
            return c = c === t ? 1 : K(c), He(Ws(n, s), c);
          }
          function Wf(n, s) {
            var c = Z(n) ? Et : Lr;
            return c(n, U(s, 3));
          }
          function Bf(n, s) {
            var c = Z(n) ? Ty : Fh;
            return c(n, U(s, 3));
          }
          var ux = Is(function(n, s, c) {
            de.call(n, c) ? n[c].push(s) : ur(n, c, [s]);
          });
          function hx(n, s, c, h) {
            n = ot(n) ? n : Zi(n), c = c && !h ? K(c) : 0;
            var p = n.length;
            return c < 0 && (c = Ie(p + c, 0)), Gs(n) ? c <= p && n.indexOf(s, c) > -1 : !!p && Ri(n, s, c) > -1;
          }
          var fx = X(function(n, s, c) {
            var h = -1, p = typeof s == "function", b = ot(n) ? A(n.length) : [];
            return Lr(n, function(v) {
              b[++h] = p ? mt(s, v, c) : en(v, s, c);
            }), b;
          }), px = Is(function(n, s, c) {
            ur(n, c, s);
          });
          function Ws(n, s) {
            var c = Z(n) ? ve : qh;
            return c(n, U(s, 3));
          }
          function gx(n, s, c, h) {
            return n == null ? [] : (Z(s) || (s = s == null ? [] : [s]), c = h ? t : c, Z(c) || (c = c == null ? [] : [c]), Zh(n, s, c));
          }
          var mx = Is(function(n, s, c) {
            n[c ? 0 : 1].push(s);
          }, function() {
            return [[], []];
          });
          function bx(n, s, c) {
            var h = Z(n) ? ml : vh, p = arguments.length < 3;
            return h(n, U(s, 4), c, p, Lr);
          }
          function _x(n, s, c) {
            var h = Z(n) ? Oy : vh, p = arguments.length < 3;
            return h(n, U(s, 4), c, p, Fh);
          }
          function vx(n, s) {
            var c = Z(n) ? Pr : zh;
            return c(n, qs(U(s, 3)));
          }
          function yx(n) {
            var s = Z(n) ? Mh : hw;
            return s(n);
          }
          function wx(n, s, c) {
            (c ? Xe(n, s, c) : s === t) ? s = 1 : s = K(s);
            var h = Z(n) ? B0 : fw;
            return h(n, s);
          }
          function kx(n) {
            var s = Z(n) ? V0 : gw;
            return s(n);
          }
          function xx(n) {
            if (n == null)
              return 0;
            if (ot(n))
              return Gs(n) ? zi(n) : n.length;
            var s = Ve(n);
            return s == pt || s == We ? n.size : Nl(n).length;
          }
          function Cx(n, s, c) {
            var h = Z(n) ? bl : mw;
            return c && Xe(n, s, c) && (s = t), h(n, U(s, 3));
          }
          var Sx = X(function(n, s) {
            if (n == null)
              return [];
            var c = s.length;
            return c > 1 && Xe(n, s[0], s[1]) ? s = [] : c > 2 && Xe(s[0], s[1], s[2]) && (s = [s[0]]), Zh(n, He(s, 1), []);
          }), Bs = n0 || function() {
            return ze.Date.now();
          };
          function Ax(n, s) {
            if (typeof s != "function")
              throw new $t(l);
            return n = K(n), function() {
              if (--n < 1)
                return s.apply(this, arguments);
            };
          }
          function Vf(n, s, c) {
            return s = c ? t : s, s = n && s == null ? n.length : s, hr(n, ie, t, t, t, t, s);
          }
          function qf(n, s) {
            var c;
            if (typeof s != "function")
              throw new $t(l);
            return n = K(n), function() {
              return --n > 0 && (c = s.apply(this, arguments)), n <= 1 && (s = t), c;
            };
          }
          var nc = X(function(n, s, c) {
            var h = I;
            if (c.length) {
              var p = Mr(c, Gi(nc));
              h |= G;
            }
            return hr(n, h, s, c, p);
          }), Yf = X(function(n, s, c) {
            var h = I | F;
            if (c.length) {
              var p = Mr(c, Gi(Yf));
              h |= G;
            }
            return hr(s, h, n, c, p);
          });
          function Gf(n, s, c) {
            s = c ? t : s;
            var h = hr(n, Y, t, t, t, t, t, s);
            return h.placeholder = Gf.placeholder, h;
          }
          function jf(n, s, c) {
            s = c ? t : s;
            var h = hr(n, W, t, t, t, t, t, s);
            return h.placeholder = jf.placeholder, h;
          }
          function Zf(n, s, c) {
            var h, p, b, v, y, k, $ = 0, T = !1, O = !1, M = !0;
            if (typeof n != "function")
              throw new $t(l);
            s = It(s) || 0, we(c) && (T = !!c.leading, O = "maxWait" in c, b = O ? Ie(It(c.maxWait) || 0, s) : b, M = "trailing" in c ? !!c.trailing : M);
            function R(Ae) {
              var Bt = h, br = p;
              return h = p = t, $ = Ae, v = n.apply(br, Bt), v;
            }
            function B(Ae) {
              return $ = Ae, y = sn(Q, s), T ? R(Ae) : v;
            }
            function J(Ae) {
              var Bt = Ae - k, br = Ae - $, pp = s - Bt;
              return O ? Be(pp, b - br) : pp;
            }
            function V(Ae) {
              var Bt = Ae - k, br = Ae - $;
              return k === t || Bt >= s || Bt < 0 || O && br >= b;
            }
            function Q() {
              var Ae = Bs();
              if (V(Ae))
                return re(Ae);
              y = sn(Q, J(Ae));
            }
            function re(Ae) {
              return y = t, M && h ? R(Ae) : (h = p = t, v);
            }
            function yt() {
              y !== t && nf(y), $ = 0, h = k = p = y = t;
            }
            function Qe() {
              return y === t ? v : re(Bs());
            }
            function wt() {
              var Ae = Bs(), Bt = V(Ae);
              if (h = arguments, p = this, k = Ae, Bt) {
                if (y === t)
                  return B(k);
                if (O)
                  return nf(y), y = sn(Q, s), R(k);
              }
              return y === t && (y = sn(Q, s)), v;
            }
            return wt.cancel = yt, wt.flush = Qe, wt;
          }
          var Ex = X(function(n, s) {
            return Rh(n, 1, s);
          }), $x = X(function(n, s, c) {
            return Rh(n, It(s) || 0, c);
          });
          function Tx(n) {
            return hr(n, ue);
          }
          function Vs(n, s) {
            if (typeof n != "function" || s != null && typeof s != "function")
              throw new $t(l);
            var c = function() {
              var h = arguments, p = s ? s.apply(this, h) : h[0], b = c.cache;
              if (b.has(p))
                return b.get(p);
              var v = n.apply(this, h);
              return c.cache = b.set(p, v) || b, v;
            };
            return c.cache = new (Vs.Cache || dr)(), c;
          }
          Vs.Cache = dr;
          function qs(n) {
            if (typeof n != "function")
              throw new $t(l);
            return function() {
              var s = arguments;
              switch (s.length) {
                case 0:
                  return !n.call(this);
                case 1:
                  return !n.call(this, s[0]);
                case 2:
                  return !n.call(this, s[0], s[1]);
                case 3:
                  return !n.call(this, s[0], s[1], s[2]);
              }
              return !n.apply(this, s);
            };
          }
          function Ox(n) {
            return qf(2, n);
          }
          var Dx = bw(function(n, s) {
            s = s.length == 1 && Z(s[0]) ? ve(s[0], bt(U())) : ve(He(s, 1), bt(U()));
            var c = s.length;
            return X(function(h) {
              for (var p = -1, b = Be(h.length, c); ++p < b; )
                h[p] = s[p].call(this, h[p]);
              return mt(n, this, h);
            });
          }), sc = X(function(n, s) {
            var c = Mr(s, Gi(sc));
            return hr(n, G, t, s, c);
          }), Kf = X(function(n, s) {
            var c = Mr(s, Gi(Kf));
            return hr(n, ee, t, s, c);
          }), Px = fr(function(n, s) {
            return hr(n, be, t, t, t, s);
          });
          function Ix(n, s) {
            if (typeof n != "function")
              throw new $t(l);
            return s = s === t ? s : K(s), X(n, s);
          }
          function Mx(n, s) {
            if (typeof n != "function")
              throw new $t(l);
            return s = s == null ? 0 : Ie(K(s), 0), X(function(c) {
              var h = c[s], p = zr(c, 0, s);
              return h && Ir(p, h), mt(n, this, p);
            });
          }
          function Nx(n, s, c) {
            var h = !0, p = !0;
            if (typeof n != "function")
              throw new $t(l);
            return we(c) && (h = "leading" in c ? !!c.leading : h, p = "trailing" in c ? !!c.trailing : p), Zf(n, s, {
              leading: h,
              maxWait: s,
              trailing: p
            });
          }
          function Lx(n) {
            return Vf(n, 1);
          }
          function Rx(n, s) {
            return sc(Vl(s), n);
          }
          function Fx() {
            if (!arguments.length)
              return [];
            var n = arguments[0];
            return Z(n) ? n : [n];
          }
          function zx(n) {
            return Ot(n, x);
          }
          function Hx(n, s) {
            return s = typeof s == "function" ? s : t, Ot(n, x, s);
          }
          function Ux(n) {
            return Ot(n, _ | x);
          }
          function Wx(n, s) {
            return s = typeof s == "function" ? s : t, Ot(n, _ | x, s);
          }
          function Bx(n, s) {
            return s == null || Lh(n, s, Me(s));
          }
          function Wt(n, s) {
            return n === s || n !== n && s !== s;
          }
          var Vx = Rs(Pl), qx = Rs(function(n, s) {
            return n >= s;
          }), di = Wh(/* @__PURE__ */ (function() {
            return arguments;
          })()) ? Wh : function(n) {
            return ke(n) && de.call(n, "callee") && !$h.call(n, "callee");
          }, Z = A.isArray, Yx = ch ? bt(ch) : ew;
          function ot(n) {
            return n != null && Ys(n.length) && !gr(n);
          }
          function Se(n) {
            return ke(n) && ot(n);
          }
          function Gx(n) {
            return n === !0 || n === !1 || ke(n) && Je(n) == ft;
          }
          var Hr = a0 || bc, jx = dh ? bt(dh) : tw;
          function Zx(n) {
            return ke(n) && n.nodeType === 1 && !an(n);
          }
          function Kx(n) {
            if (n == null)
              return !0;
            if (ot(n) && (Z(n) || typeof n == "string" || typeof n.splice == "function" || Hr(n) || ji(n) || di(n)))
              return !n.length;
            var s = Ve(n);
            if (s == pt || s == We)
              return !n.size;
            if (nn(n))
              return !Nl(n).length;
            for (var c in n)
              if (de.call(n, c))
                return !1;
            return !0;
          }
          function Jx(n, s) {
            return tn(n, s);
          }
          function Xx(n, s, c) {
            c = typeof c == "function" ? c : t;
            var h = c ? c(n, s) : t;
            return h === t ? tn(n, s, t, c) : !!h;
          }
          function ac(n) {
            if (!ke(n))
              return !1;
            var s = Je(n);
            return s == $r || s == Za || typeof n.message == "string" && typeof n.name == "string" && !an(n);
          }
          function Qx(n) {
            return typeof n == "number" && Oh(n);
          }
          function gr(n) {
            if (!we(n))
              return !1;
            var s = Je(n);
            return s == Ni || s == Vo || s == Mi || s == Ka;
          }
          function Jf(n) {
            return typeof n == "number" && n == K(n);
          }
          function Ys(n) {
            return typeof n == "number" && n > -1 && n % 1 == 0 && n <= ht;
          }
          function we(n) {
            var s = typeof n;
            return n != null && (s == "object" || s == "function");
          }
          function ke(n) {
            return n != null && typeof n == "object";
          }
          var Xf = uh ? bt(uh) : iw;
          function e1(n, s) {
            return n === s || Ml(n, s, Jl(s));
          }
          function t1(n, s, c) {
            return c = typeof c == "function" ? c : t, Ml(n, s, Jl(s), c);
          }
          function r1(n) {
            return Qf(n) && n != +n;
          }
          function i1(n) {
            if (Hw(n))
              throw new j(a);
            return Bh(n);
          }
          function o1(n) {
            return n === null;
          }
          function n1(n) {
            return n == null;
          }
          function Qf(n) {
            return typeof n == "number" || ke(n) && Je(n) == ei;
          }
          function an(n) {
            if (!ke(n) || Je(n) != St)
              return !1;
            var s = vs(n);
            if (s === null)
              return !0;
            var c = de.call(s, "constructor") && s.constructor;
            return typeof c == "function" && c instanceof c && gs.call(c) == t0;
          }
          var lc = hh ? bt(hh) : ow;
          function s1(n) {
            return Jf(n) && n >= -ht && n <= ht;
          }
          var ep = fh ? bt(fh) : nw;
          function Gs(n) {
            return typeof n == "string" || !Z(n) && ke(n) && Je(n) == Tr;
          }
          function vt(n) {
            return typeof n == "symbol" || ke(n) && Je(n) == ti;
          }
          var ji = ph ? bt(ph) : sw;
          function a1(n) {
            return n === t;
          }
          function l1(n) {
            return ke(n) && Ve(n) == Or;
          }
          function c1(n) {
            return ke(n) && Je(n) == ss;
          }
          var d1 = Rs(Ll), u1 = Rs(function(n, s) {
            return n <= s;
          });
          function tp(n) {
            if (!n)
              return [];
            if (ot(n))
              return Gs(n) ? Ht(n) : it(n);
            if (Go && n[Go])
              return By(n[Go]());
            var s = Ve(n), c = s == pt ? xl : s == We ? hs : Zi;
            return c(n);
          }
          function mr(n) {
            if (!n)
              return n === 0 ? n : 0;
            if (n = It(n), n === De || n === -De) {
              var s = n < 0 ? -1 : 1;
              return s * nr;
            }
            return n === n ? n : 0;
          }
          function K(n) {
            var s = mr(n), c = s % 1;
            return s === s ? c ? s - c : s : 0;
          }
          function rp(n) {
            return n ? si(K(n), 0, rt) : 0;
          }
          function It(n) {
            if (typeof n == "number")
              return n;
            if (vt(n))
              return sr;
            if (we(n)) {
              var s = typeof n.valueOf == "function" ? n.valueOf() : n;
              n = we(s) ? s + "" : s;
            }
            if (typeof n != "string")
              return n === 0 ? n : +n;
            n = yh(n);
            var c = Yv.test(n);
            return c || jv.test(n) ? Ay(n.slice(2), c ? 2 : 8) : qv.test(n) ? sr : +n;
          }
          function ip(n) {
            return Xt(n, nt(n));
          }
          function h1(n) {
            return n ? si(K(n), -ht, ht) : n === 0 ? n : 0;
          }
          function le(n) {
            return n == null ? "" : _t(n);
          }
          var f1 = qi(function(n, s) {
            if (nn(s) || ot(s)) {
              Xt(s, Me(s), n);
              return;
            }
            for (var c in s)
              de.call(s, c) && Xo(n, c, s[c]);
          }), op = qi(function(n, s) {
            Xt(s, nt(s), n);
          }), js = qi(function(n, s, c, h) {
            Xt(s, nt(s), n, h);
          }), p1 = qi(function(n, s, c, h) {
            Xt(s, Me(s), n, h);
          }), g1 = fr(Tl);
          function m1(n, s) {
            var c = Vi(n);
            return s == null ? c : Nh(c, s);
          }
          var b1 = X(function(n, s) {
            n = fe(n);
            var c = -1, h = s.length, p = h > 2 ? s[2] : t;
            for (p && Xe(s[0], s[1], p) && (h = 1); ++c < h; )
              for (var b = s[c], v = nt(b), y = -1, k = v.length; ++y < k; ) {
                var $ = v[y], T = n[$];
                (T === t || Wt(T, Ui[$]) && !de.call(n, $)) && (n[$] = b[$]);
              }
            return n;
          }), _1 = X(function(n) {
            return n.push(t, wf), mt(np, t, n);
          });
          function v1(n, s) {
            return mh(n, U(s, 3), Jt);
          }
          function y1(n, s) {
            return mh(n, U(s, 3), Dl);
          }
          function w1(n, s) {
            return n == null ? n : Ol(n, U(s, 3), nt);
          }
          function k1(n, s) {
            return n == null ? n : Hh(n, U(s, 3), nt);
          }
          function x1(n, s) {
            return n && Jt(n, U(s, 3));
          }
          function C1(n, s) {
            return n && Dl(n, U(s, 3));
          }
          function S1(n) {
            return n == null ? [] : Ts(n, Me(n));
          }
          function A1(n) {
            return n == null ? [] : Ts(n, nt(n));
          }
          function cc(n, s, c) {
            var h = n == null ? t : ai(n, s);
            return h === t ? c : h;
          }
          function E1(n, s) {
            return n != null && Cf(n, s, K0);
          }
          function dc(n, s) {
            return n != null && Cf(n, s, J0);
          }
          var $1 = mf(function(n, s, c) {
            s != null && typeof s.toString != "function" && (s = ms.call(s)), n[s] = c;
          }, hc(st)), T1 = mf(function(n, s, c) {
            s != null && typeof s.toString != "function" && (s = ms.call(s)), de.call(n, s) ? n[s].push(c) : n[s] = [c];
          }, U), O1 = X(en);
          function Me(n) {
            return ot(n) ? Ih(n) : Nl(n);
          }
          function nt(n) {
            return ot(n) ? Ih(n, !0) : aw(n);
          }
          function D1(n, s) {
            var c = {};
            return s = U(s, 3), Jt(n, function(h, p, b) {
              ur(c, s(h, p, b), h);
            }), c;
          }
          function P1(n, s) {
            var c = {};
            return s = U(s, 3), Jt(n, function(h, p, b) {
              ur(c, p, s(h, p, b));
            }), c;
          }
          var I1 = qi(function(n, s, c) {
            Os(n, s, c);
          }), np = qi(function(n, s, c, h) {
            Os(n, s, c, h);
          }), M1 = fr(function(n, s) {
            var c = {};
            if (n == null)
              return c;
            var h = !1;
            s = ve(s, function(b) {
              return b = Fr(b, n), h || (h = b.length > 1), b;
            }), Xt(n, Zl(n), c), h && (c = Ot(c, _ | C | x, $w));
            for (var p = s.length; p--; )
              Ul(c, s[p]);
            return c;
          });
          function N1(n, s) {
            return sp(n, qs(U(s)));
          }
          var L1 = fr(function(n, s) {
            return n == null ? {} : cw(n, s);
          });
          function sp(n, s) {
            if (n == null)
              return {};
            var c = ve(Zl(n), function(h) {
              return [h];
            });
            return s = U(s), Kh(n, c, function(h, p) {
              return s(h, p[0]);
            });
          }
          function R1(n, s, c) {
            s = Fr(s, n);
            var h = -1, p = s.length;
            for (p || (p = 1, n = t); ++h < p; ) {
              var b = n == null ? t : n[Qt(s[h])];
              b === t && (h = p, b = c), n = gr(b) ? b.call(n) : b;
            }
            return n;
          }
          function F1(n, s, c) {
            return n == null ? n : rn(n, s, c);
          }
          function z1(n, s, c, h) {
            return h = typeof h == "function" ? h : t, n == null ? n : rn(n, s, c, h);
          }
          var ap = vf(Me), lp = vf(nt);
          function H1(n, s, c) {
            var h = Z(n), p = h || Hr(n) || ji(n);
            if (s = U(s, 4), c == null) {
              var b = n && n.constructor;
              p ? c = h ? new b() : [] : we(n) ? c = gr(b) ? Vi(vs(n)) : {} : c = {};
            }
            return (p ? Et : Jt)(n, function(v, y, k) {
              return s(c, v, y, k);
            }), c;
          }
          function U1(n, s) {
            return n == null ? !0 : Ul(n, s);
          }
          function W1(n, s, c) {
            return n == null ? n : tf(n, s, Vl(c));
          }
          function B1(n, s, c, h) {
            return h = typeof h == "function" ? h : t, n == null ? n : tf(n, s, Vl(c), h);
          }
          function Zi(n) {
            return n == null ? [] : kl(n, Me(n));
          }
          function V1(n) {
            return n == null ? [] : kl(n, nt(n));
          }
          function q1(n, s, c) {
            return c === t && (c = s, s = t), c !== t && (c = It(c), c = c === c ? c : 0), s !== t && (s = It(s), s = s === s ? s : 0), si(It(n), s, c);
          }
          function Y1(n, s, c) {
            return s = mr(s), c === t ? (c = s, s = 0) : c = mr(c), n = It(n), X0(n, s, c);
          }
          function G1(n, s, c) {
            if (c && typeof c != "boolean" && Xe(n, s, c) && (s = c = t), c === t && (typeof s == "boolean" ? (c = s, s = t) : typeof n == "boolean" && (c = n, n = t)), n === t && s === t ? (n = 0, s = 1) : (n = mr(n), s === t ? (s = n, n = 0) : s = mr(s)), n > s) {
              var h = n;
              n = s, s = h;
            }
            if (c || n % 1 || s % 1) {
              var p = Dh();
              return Be(n + p * (s - n + Sy("1e-" + ((p + "").length - 1))), s);
            }
            return Fl(n, s);
          }
          var j1 = Yi(function(n, s, c) {
            return s = s.toLowerCase(), n + (c ? cp(s) : s);
          });
          function cp(n) {
            return uc(le(n).toLowerCase());
          }
          function dp(n) {
            return n = le(n), n && n.replace(Kv, Fy).replace(gy, "");
          }
          function Z1(n, s, c) {
            n = le(n), s = _t(s);
            var h = n.length;
            c = c === t ? h : si(K(c), 0, h);
            var p = c;
            return c -= s.length, c >= 0 && n.slice(c, p) == s;
          }
          function K1(n) {
            return n = le(n), n && Ov.test(n) ? n.replace(Hu, zy) : n;
          }
          function J1(n) {
            return n = le(n), n && Lv.test(n) ? n.replace(sl, "\\$&") : n;
          }
          var X1 = Yi(function(n, s, c) {
            return n + (c ? "-" : "") + s.toLowerCase();
          }), Q1 = Yi(function(n, s, c) {
            return n + (c ? " " : "") + s.toLowerCase();
          }), eC = ff("toLowerCase");
          function tC(n, s, c) {
            n = le(n), s = K(s);
            var h = s ? zi(n) : 0;
            if (!s || h >= s)
              return n;
            var p = (s - h) / 2;
            return Ls(xs(p), c) + n + Ls(ks(p), c);
          }
          function rC(n, s, c) {
            n = le(n), s = K(s);
            var h = s ? zi(n) : 0;
            return s && h < s ? n + Ls(s - h, c) : n;
          }
          function iC(n, s, c) {
            n = le(n), s = K(s);
            var h = s ? zi(n) : 0;
            return s && h < s ? Ls(s - h, c) + n : n;
          }
          function oC(n, s, c) {
            return c || s == null ? s = 0 : s && (s = +s), u0(le(n).replace(al, ""), s || 0);
          }
          function nC(n, s, c) {
            return (c ? Xe(n, s, c) : s === t) ? s = 1 : s = K(s), zl(le(n), s);
          }
          function sC() {
            var n = arguments, s = le(n[0]);
            return n.length < 3 ? s : s.replace(n[1], n[2]);
          }
          var aC = Yi(function(n, s, c) {
            return n + (c ? "_" : "") + s.toLowerCase();
          });
          function lC(n, s, c) {
            return c && typeof c != "number" && Xe(n, s, c) && (s = c = t), c = c === t ? rt : c >>> 0, c ? (n = le(n), n && (typeof s == "string" || s != null && !lc(s)) && (s = _t(s), !s && Fi(n)) ? zr(Ht(n), 0, c) : n.split(s, c)) : [];
          }
          var cC = Yi(function(n, s, c) {
            return n + (c ? " " : "") + uc(s);
          });
          function dC(n, s, c) {
            return n = le(n), c = c == null ? 0 : si(K(c), 0, n.length), s = _t(s), n.slice(c, c + s.length) == s;
          }
          function uC(n, s, c) {
            var h = m.templateSettings;
            c && Xe(n, s, c) && (s = t), n = le(n), s = js({}, s, h, yf);
            var p = js({}, s.imports, h.imports, yf), b = Me(p), v = kl(p, b), y, k, $ = 0, T = s.interpolate || as, O = "__p += '", M = Cl(
              (s.escape || as).source + "|" + T.source + "|" + (T === Uu ? Vv : as).source + "|" + (s.evaluate || as).source + "|$",
              "g"
            ), R = "//# sourceURL=" + (de.call(s, "sourceURL") ? (s.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++yy + "]") + `
`;
            n.replace(M, function(V, Q, re, yt, Qe, wt) {
              return re || (re = yt), O += n.slice($, wt).replace(Jv, Hy), Q && (y = !0, O += `' +
__e(` + Q + `) +
'`), Qe && (k = !0, O += `';
` + Qe + `;
__p += '`), re && (O += `' +
((__t = (` + re + `)) == null ? '' : __t) +
'`), $ = wt + V.length, V;
            }), O += `';
`;
            var B = de.call(s, "variable") && s.variable;
            if (!B)
              O = `with (obj) {
` + O + `
}
`;
            else if (Wv.test(B))
              throw new j(d);
            O = (k ? O.replace(Av, "") : O).replace(Ev, "$1").replace($v, "$1;"), O = "function(" + (B || "obj") + `) {
` + (B ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (y ? ", __e = _.escape" : "") + (k ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + O + `return __p
}`;
            var J = hp(function() {
              return se(b, R + "return " + O).apply(t, v);
            });
            if (J.source = O, ac(J))
              throw J;
            return J;
          }
          function hC(n) {
            return le(n).toLowerCase();
          }
          function fC(n) {
            return le(n).toUpperCase();
          }
          function pC(n, s, c) {
            if (n = le(n), n && (c || s === t))
              return yh(n);
            if (!n || !(s = _t(s)))
              return n;
            var h = Ht(n), p = Ht(s), b = wh(h, p), v = kh(h, p) + 1;
            return zr(h, b, v).join("");
          }
          function gC(n, s, c) {
            if (n = le(n), n && (c || s === t))
              return n.slice(0, Ch(n) + 1);
            if (!n || !(s = _t(s)))
              return n;
            var h = Ht(n), p = kh(h, Ht(s)) + 1;
            return zr(h, 0, p).join("");
          }
          function mC(n, s, c) {
            if (n = le(n), n && (c || s === t))
              return n.replace(al, "");
            if (!n || !(s = _t(s)))
              return n;
            var h = Ht(n), p = wh(h, Ht(s));
            return zr(h, p).join("");
          }
          function bC(n, s) {
            var c = he, h = Ee;
            if (we(s)) {
              var p = "separator" in s ? s.separator : p;
              c = "length" in s ? K(s.length) : c, h = "omission" in s ? _t(s.omission) : h;
            }
            n = le(n);
            var b = n.length;
            if (Fi(n)) {
              var v = Ht(n);
              b = v.length;
            }
            if (c >= b)
              return n;
            var y = c - zi(h);
            if (y < 1)
              return h;
            var k = v ? zr(v, 0, y).join("") : n.slice(0, y);
            if (p === t)
              return k + h;
            if (v && (y += k.length - y), lc(p)) {
              if (n.slice(y).search(p)) {
                var $, T = k;
                for (p.global || (p = Cl(p.source, le(Wu.exec(p)) + "g")), p.lastIndex = 0; $ = p.exec(T); )
                  var O = $.index;
                k = k.slice(0, O === t ? y : O);
              }
            } else if (n.indexOf(_t(p), y) != y) {
              var M = k.lastIndexOf(p);
              M > -1 && (k = k.slice(0, M));
            }
            return k + h;
          }
          function _C(n) {
            return n = le(n), n && Tv.test(n) ? n.replace(zu, Gy) : n;
          }
          var vC = Yi(function(n, s, c) {
            return n + (c ? " " : "") + s.toUpperCase();
          }), uc = ff("toUpperCase");
          function up(n, s, c) {
            return n = le(n), s = c ? t : s, s === t ? Wy(n) ? Ky(n) : Iy(n) : n.match(s) || [];
          }
          var hp = X(function(n, s) {
            try {
              return mt(n, t, s);
            } catch (c) {
              return ac(c) ? c : new j(c);
            }
          }), yC = fr(function(n, s) {
            return Et(s, function(c) {
              c = Qt(c), ur(n, c, nc(n[c], n));
            }), n;
          });
          function wC(n) {
            var s = n == null ? 0 : n.length, c = U();
            return n = s ? ve(n, function(h) {
              if (typeof h[1] != "function")
                throw new $t(l);
              return [c(h[0]), h[1]];
            }) : [], X(function(h) {
              for (var p = -1; ++p < s; ) {
                var b = n[p];
                if (mt(b[0], this, h))
                  return mt(b[1], this, h);
              }
            });
          }
          function kC(n) {
            return G0(Ot(n, _));
          }
          function hc(n) {
            return function() {
              return n;
            };
          }
          function xC(n, s) {
            return n == null || n !== n ? s : n;
          }
          var CC = gf(), SC = gf(!0);
          function st(n) {
            return n;
          }
          function fc(n) {
            return Vh(typeof n == "function" ? n : Ot(n, _));
          }
          function AC(n) {
            return Yh(Ot(n, _));
          }
          function EC(n, s) {
            return Gh(n, Ot(s, _));
          }
          var $C = X(function(n, s) {
            return function(c) {
              return en(c, n, s);
            };
          }), TC = X(function(n, s) {
            return function(c) {
              return en(n, c, s);
            };
          });
          function pc(n, s, c) {
            var h = Me(s), p = Ts(s, h);
            c == null && !(we(s) && (p.length || !h.length)) && (c = s, s = n, n = this, p = Ts(s, Me(s)));
            var b = !(we(c) && "chain" in c) || !!c.chain, v = gr(n);
            return Et(p, function(y) {
              var k = s[y];
              n[y] = k, v && (n.prototype[y] = function() {
                var $ = this.__chain__;
                if (b || $) {
                  var T = n(this.__wrapped__), O = T.__actions__ = it(this.__actions__);
                  return O.push({ func: k, args: arguments, thisArg: n }), T.__chain__ = $, T;
                }
                return k.apply(n, Ir([this.value()], arguments));
              });
            }), n;
          }
          function OC() {
            return ze._ === this && (ze._ = r0), this;
          }
          function gc() {
          }
          function DC(n) {
            return n = K(n), X(function(s) {
              return jh(s, n);
            });
          }
          var PC = Yl(ve), IC = Yl(gh), MC = Yl(bl);
          function fp(n) {
            return Ql(n) ? _l(Qt(n)) : dw(n);
          }
          function NC(n) {
            return function(s) {
              return n == null ? t : ai(n, s);
            };
          }
          var LC = bf(), RC = bf(!0);
          function mc() {
            return [];
          }
          function bc() {
            return !1;
          }
          function FC() {
            return {};
          }
          function zC() {
            return "";
          }
          function HC() {
            return !0;
          }
          function UC(n, s) {
            if (n = K(n), n < 1 || n > ht)
              return [];
            var c = rt, h = Be(n, rt);
            s = U(s), n -= rt;
            for (var p = wl(h, s); ++c < n; )
              s(c);
            return p;
          }
          function WC(n) {
            return Z(n) ? ve(n, Qt) : vt(n) ? [n] : it(If(le(n)));
          }
          function BC(n) {
            var s = ++e0;
            return le(n) + s;
          }
          var VC = Ns(function(n, s) {
            return n + s;
          }, 0), qC = Gl("ceil"), YC = Ns(function(n, s) {
            return n / s;
          }, 1), GC = Gl("floor");
          function jC(n) {
            return n && n.length ? $s(n, st, Pl) : t;
          }
          function ZC(n, s) {
            return n && n.length ? $s(n, U(s, 2), Pl) : t;
          }
          function KC(n) {
            return _h(n, st);
          }
          function JC(n, s) {
            return _h(n, U(s, 2));
          }
          function XC(n) {
            return n && n.length ? $s(n, st, Ll) : t;
          }
          function QC(n, s) {
            return n && n.length ? $s(n, U(s, 2), Ll) : t;
          }
          var eS = Ns(function(n, s) {
            return n * s;
          }, 1), tS = Gl("round"), rS = Ns(function(n, s) {
            return n - s;
          }, 0);
          function iS(n) {
            return n && n.length ? yl(n, st) : 0;
          }
          function oS(n, s) {
            return n && n.length ? yl(n, U(s, 2)) : 0;
          }
          return m.after = Ax, m.ary = Vf, m.assign = f1, m.assignIn = op, m.assignInWith = js, m.assignWith = p1, m.at = g1, m.before = qf, m.bind = nc, m.bindAll = yC, m.bindKey = Yf, m.castArray = Fx, m.chain = Uf, m.chunk = Gw, m.compact = jw, m.concat = Zw, m.cond = wC, m.conforms = kC, m.constant = hc, m.countBy = ix, m.create = m1, m.curry = Gf, m.curryRight = jf, m.debounce = Zf, m.defaults = b1, m.defaultsDeep = _1, m.defer = Ex, m.delay = $x, m.difference = Kw, m.differenceBy = Jw, m.differenceWith = Xw, m.drop = Qw, m.dropRight = ek, m.dropRightWhile = tk, m.dropWhile = rk, m.fill = ik, m.filter = nx, m.flatMap = lx, m.flatMapDeep = cx, m.flatMapDepth = dx, m.flatten = Rf, m.flattenDeep = ok, m.flattenDepth = nk, m.flip = Tx, m.flow = CC, m.flowRight = SC, m.fromPairs = sk, m.functions = S1, m.functionsIn = A1, m.groupBy = ux, m.initial = lk, m.intersection = ck, m.intersectionBy = dk, m.intersectionWith = uk, m.invert = $1, m.invertBy = T1, m.invokeMap = fx, m.iteratee = fc, m.keyBy = px, m.keys = Me, m.keysIn = nt, m.map = Ws, m.mapKeys = D1, m.mapValues = P1, m.matches = AC, m.matchesProperty = EC, m.memoize = Vs, m.merge = I1, m.mergeWith = np, m.method = $C, m.methodOf = TC, m.mixin = pc, m.negate = qs, m.nthArg = DC, m.omit = M1, m.omitBy = N1, m.once = Ox, m.orderBy = gx, m.over = PC, m.overArgs = Dx, m.overEvery = IC, m.overSome = MC, m.partial = sc, m.partialRight = Kf, m.partition = mx, m.pick = L1, m.pickBy = sp, m.property = fp, m.propertyOf = NC, m.pull = gk, m.pullAll = zf, m.pullAllBy = mk, m.pullAllWith = bk, m.pullAt = _k, m.range = LC, m.rangeRight = RC, m.rearg = Px, m.reject = vx, m.remove = vk, m.rest = Ix, m.reverse = ic, m.sampleSize = wx, m.set = F1, m.setWith = z1, m.shuffle = kx, m.slice = yk, m.sortBy = Sx, m.sortedUniq = Ek, m.sortedUniqBy = $k, m.split = lC, m.spread = Mx, m.tail = Tk, m.take = Ok, m.takeRight = Dk, m.takeRightWhile = Pk, m.takeWhile = Ik, m.tap = jk, m.throttle = Nx, m.thru = Us, m.toArray = tp, m.toPairs = ap, m.toPairsIn = lp, m.toPath = WC, m.toPlainObject = ip, m.transform = H1, m.unary = Lx, m.union = Mk, m.unionBy = Nk, m.unionWith = Lk, m.uniq = Rk, m.uniqBy = Fk, m.uniqWith = zk, m.unset = U1, m.unzip = oc, m.unzipWith = Hf, m.update = W1, m.updateWith = B1, m.values = Zi, m.valuesIn = V1, m.without = Hk, m.words = up, m.wrap = Rx, m.xor = Uk, m.xorBy = Wk, m.xorWith = Bk, m.zip = Vk, m.zipObject = qk, m.zipObjectDeep = Yk, m.zipWith = Gk, m.entries = ap, m.entriesIn = lp, m.extend = op, m.extendWith = js, pc(m, m), m.add = VC, m.attempt = hp, m.camelCase = j1, m.capitalize = cp, m.ceil = qC, m.clamp = q1, m.clone = zx, m.cloneDeep = Ux, m.cloneDeepWith = Wx, m.cloneWith = Hx, m.conformsTo = Bx, m.deburr = dp, m.defaultTo = xC, m.divide = YC, m.endsWith = Z1, m.eq = Wt, m.escape = K1, m.escapeRegExp = J1, m.every = ox, m.find = sx, m.findIndex = Nf, m.findKey = v1, m.findLast = ax, m.findLastIndex = Lf, m.findLastKey = y1, m.floor = GC, m.forEach = Wf, m.forEachRight = Bf, m.forIn = w1, m.forInRight = k1, m.forOwn = x1, m.forOwnRight = C1, m.get = cc, m.gt = Vx, m.gte = qx, m.has = E1, m.hasIn = dc, m.head = Ff, m.identity = st, m.includes = hx, m.indexOf = ak, m.inRange = Y1, m.invoke = O1, m.isArguments = di, m.isArray = Z, m.isArrayBuffer = Yx, m.isArrayLike = ot, m.isArrayLikeObject = Se, m.isBoolean = Gx, m.isBuffer = Hr, m.isDate = jx, m.isElement = Zx, m.isEmpty = Kx, m.isEqual = Jx, m.isEqualWith = Xx, m.isError = ac, m.isFinite = Qx, m.isFunction = gr, m.isInteger = Jf, m.isLength = Ys, m.isMap = Xf, m.isMatch = e1, m.isMatchWith = t1, m.isNaN = r1, m.isNative = i1, m.isNil = n1, m.isNull = o1, m.isNumber = Qf, m.isObject = we, m.isObjectLike = ke, m.isPlainObject = an, m.isRegExp = lc, m.isSafeInteger = s1, m.isSet = ep, m.isString = Gs, m.isSymbol = vt, m.isTypedArray = ji, m.isUndefined = a1, m.isWeakMap = l1, m.isWeakSet = c1, m.join = hk, m.kebabCase = X1, m.last = Pt, m.lastIndexOf = fk, m.lowerCase = Q1, m.lowerFirst = eC, m.lt = d1, m.lte = u1, m.max = jC, m.maxBy = ZC, m.mean = KC, m.meanBy = JC, m.min = XC, m.minBy = QC, m.stubArray = mc, m.stubFalse = bc, m.stubObject = FC, m.stubString = zC, m.stubTrue = HC, m.multiply = eS, m.nth = pk, m.noConflict = OC, m.noop = gc, m.now = Bs, m.pad = tC, m.padEnd = rC, m.padStart = iC, m.parseInt = oC, m.random = G1, m.reduce = bx, m.reduceRight = _x, m.repeat = nC, m.replace = sC, m.result = R1, m.round = tS, m.runInContext = w, m.sample = yx, m.size = xx, m.snakeCase = aC, m.some = Cx, m.sortedIndex = wk, m.sortedIndexBy = kk, m.sortedIndexOf = xk, m.sortedLastIndex = Ck, m.sortedLastIndexBy = Sk, m.sortedLastIndexOf = Ak, m.startCase = cC, m.startsWith = dC, m.subtract = rS, m.sum = iS, m.sumBy = oS, m.template = uC, m.times = UC, m.toFinite = mr, m.toInteger = K, m.toLength = rp, m.toLower = hC, m.toNumber = It, m.toSafeInteger = h1, m.toString = le, m.toUpper = fC, m.trim = pC, m.trimEnd = gC, m.trimStart = mC, m.truncate = bC, m.unescape = _C, m.uniqueId = BC, m.upperCase = vC, m.upperFirst = uc, m.each = Wf, m.eachRight = Bf, m.first = Ff, pc(m, (function() {
            var n = {};
            return Jt(m, function(s, c) {
              de.call(m.prototype, c) || (n[c] = s);
            }), n;
          })(), { chain: !1 }), m.VERSION = i, Et(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(n) {
            m[n].placeholder = m;
          }), Et(["drop", "take"], function(n, s) {
            te.prototype[n] = function(c) {
              c = c === t ? 1 : Ie(K(c), 0);
              var h = this.__filtered__ && !s ? new te(this) : this.clone();
              return h.__filtered__ ? h.__takeCount__ = Be(c, h.__takeCount__) : h.__views__.push({
                size: Be(c, rt),
                type: n + (h.__dir__ < 0 ? "Right" : "")
              }), h;
            }, te.prototype[n + "Right"] = function(c) {
              return this.reverse()[n](c).reverse();
            };
          }), Et(["filter", "map", "takeWhile"], function(n, s) {
            var c = s + 1, h = c == Zt || c == Ze;
            te.prototype[n] = function(p) {
              var b = this.clone();
              return b.__iteratees__.push({
                iteratee: U(p, 3),
                type: c
              }), b.__filtered__ = b.__filtered__ || h, b;
            };
          }), Et(["head", "last"], function(n, s) {
            var c = "take" + (s ? "Right" : "");
            te.prototype[n] = function() {
              return this[c](1).value()[0];
            };
          }), Et(["initial", "tail"], function(n, s) {
            var c = "drop" + (s ? "" : "Right");
            te.prototype[n] = function() {
              return this.__filtered__ ? new te(this) : this[c](1);
            };
          }), te.prototype.compact = function() {
            return this.filter(st);
          }, te.prototype.find = function(n) {
            return this.filter(n).head();
          }, te.prototype.findLast = function(n) {
            return this.reverse().find(n);
          }, te.prototype.invokeMap = X(function(n, s) {
            return typeof n == "function" ? new te(this) : this.map(function(c) {
              return en(c, n, s);
            });
          }), te.prototype.reject = function(n) {
            return this.filter(qs(U(n)));
          }, te.prototype.slice = function(n, s) {
            n = K(n);
            var c = this;
            return c.__filtered__ && (n > 0 || s < 0) ? new te(c) : (n < 0 ? c = c.takeRight(-n) : n && (c = c.drop(n)), s !== t && (s = K(s), c = s < 0 ? c.dropRight(-s) : c.take(s - n)), c);
          }, te.prototype.takeRightWhile = function(n) {
            return this.reverse().takeWhile(n).reverse();
          }, te.prototype.toArray = function() {
            return this.take(rt);
          }, Jt(te.prototype, function(n, s) {
            var c = /^(?:filter|find|map|reject)|While$/.test(s), h = /^(?:head|last)$/.test(s), p = m[h ? "take" + (s == "last" ? "Right" : "") : s], b = h || /^find/.test(s);
            p && (m.prototype[s] = function() {
              var v = this.__wrapped__, y = h ? [1] : arguments, k = v instanceof te, $ = y[0], T = k || Z(v), O = function(Q) {
                var re = p.apply(m, Ir([Q], y));
                return h && M ? re[0] : re;
              };
              T && c && typeof $ == "function" && $.length != 1 && (k = T = !1);
              var M = this.__chain__, R = !!this.__actions__.length, B = b && !M, J = k && !R;
              if (!b && T) {
                v = J ? v : new te(this);
                var V = n.apply(v, y);
                return V.__actions__.push({ func: Us, args: [O], thisArg: t }), new Tt(V, M);
              }
              return B && J ? n.apply(this, y) : (V = this.thru(O), B ? h ? V.value()[0] : V.value() : V);
            });
          }), Et(["pop", "push", "shift", "sort", "splice", "unshift"], function(n) {
            var s = fs[n], c = /^(?:push|sort|unshift)$/.test(n) ? "tap" : "thru", h = /^(?:pop|shift)$/.test(n);
            m.prototype[n] = function() {
              var p = arguments;
              if (h && !this.__chain__) {
                var b = this.value();
                return s.apply(Z(b) ? b : [], p);
              }
              return this[c](function(v) {
                return s.apply(Z(v) ? v : [], p);
              });
            };
          }), Jt(te.prototype, function(n, s) {
            var c = m[s];
            if (c) {
              var h = c.name + "";
              de.call(Bi, h) || (Bi[h] = []), Bi[h].push({ name: s, func: c });
            }
          }), Bi[Ms(t, F).name] = [{
            name: "wrapper",
            func: t
          }], te.prototype.clone = _0, te.prototype.reverse = v0, te.prototype.value = y0, m.prototype.at = Zk, m.prototype.chain = Kk, m.prototype.commit = Jk, m.prototype.next = Xk, m.prototype.plant = ex, m.prototype.reverse = tx, m.prototype.toJSON = m.prototype.valueOf = m.prototype.value = rx, m.prototype.first = m.prototype.head, Go && (m.prototype[Go] = Qk), m;
        }), Hi = Jy();
        ri ? ((ri.exports = Hi)._ = Hi, fl._ = Hi) : ze._ = Hi;
      }).call(m2);
    })(Cn, Cn.exports)), Cn.exports;
  }
  var _2 = b2();
  const pm = /* @__PURE__ */ g2(_2);
  var v2 = Object.getOwnPropertyDescriptor, y2 = Object.getPrototypeOf, w2 = Reflect.get, k2 = (r, e, t, i) => {
    for (var o = i > 1 ? void 0 : i ? v2(e, t) : e, a = r.length - 1, l; a >= 0; a--)
      (l = r[a]) && (o = l(o) || o);
    return o;
  }, x2 = (r, e, t) => w2(y2(r), t, e);
  let po = class extends Re {
    constructor() {
      super(), this.login_token = "", this.api_url = "", this.fetch_error = "", this.selected_date = /* @__PURE__ */ new Date(), this.workDays = void 0, this._init();
    }
    _init() {
      je.dispatch(tr("dateSelector", { selectedDate: this.selected_date }));
    }
    stateChanged(r) {
      if ("dateSelector" in r.selectors) {
        let e = r.selectors.dateSelector.selectedDate;
        e.getTime() !== this.selected_date.getTime() && (this.selected_date = e);
      }
    }
    updated(r) {
      super.updated(r), r.has("apiContext") && this.fetchWorkDays();
    }
    async fetchDeletionDays() {
      let r = new URLSearchParams({});
      return this.apiContext.fetchFromApi(
        "",
        "deletions",
        {
          method: "GET",
          caller: "deletion-info-widget.fetch_data"
        },
        void 0,
        r
      );
    }
    async fetchWorkDays() {
      const r = {
        cql: {
          base: {
            scope: {
              archival_entity: "browse()",
              site: "browse()"
            },
            target: {
              field_or_instruction: "modified_ww()"
            },
            additional_fields: {}
          },
          meta: {
            version: 0.1
          },
          query: {
            type: "DirectSqlQuery",
            sql: "distinct  data::date from {base} "
          }
        }
      };
      let e = new URLSearchParams({
        page_size: "-1"
      });
      try {
        const t = await this.apiContext.fetchFromApi(
          "",
          "cql/query",
          {
            method: "POST",
            caller: "dateselector.fetchWorkDays",
            body: JSON.stringify(r)
          },
          void 0,
          e
        );
        if (t.result_msg !== "ok")
          this.fetch_error = t.result_msg;
        else {
          this.fetch_error = "";
          const i = await this.fetchDeletionDays();
          this.loadWorkDays(t.records, i.records);
        }
      } catch (t) {
        dt(this, t, "dateselector.fetchWorkDays", null);
      }
    }
    loadWorkDays(r, e) {
      const t = new Set(r.map((o) => z.fromISO(o.data).startOf("day").toMillis()));
      e.forEach((o) => {
        try {
          const a = z.fromSQL(o[0]).startOf("day").toMillis();
          t.add(a);
        } catch {
        }
      });
      const i = Array.from(t);
      i.sort(), this.workDays = i;
    }
    jumpToWorkday(r) {
      const e = r.currentTarget, i = z.fromJSDate(this.selected_date).startOf("day").toMillis();
      let o;
      switch (e.id) {
        case "bt-prev-workday":
          o = pm.sortedLastIndex(this.workDays, i) - 1, o > 0 && this.workDays[o] == i && (o -= 1);
          break;
        case "bt-next-workday":
          o = pm.sortedIndex(this.workDays, i), (o !== 0 || this.workDays[0] == i) && (o += 1);
          break;
        case "bt-first-workday":
          o = 0;
          break;
        case "bt-last-workday":
          o = this.workDays.length - 1;
          break;
      }
      if (i && o > -1) {
        const a = z.fromMillis(this.workDays[o]);
        je.dispatch(tr("dateSelector", { selectedDate: a.toJSDate() }));
      }
    }
    dateNavigation(r) {
      return this.workDays ? r === "back" ? S`
                <div class = "date-navigation" >
                    <button id="bt-first-workday" @click="${this.jumpToWorkday}"><i class="fas fa-backward-fast"></i></button>
                    <button id="bt-prev-workday" @click="${this.jumpToWorkday}"><i class="fas fa-backward"></i></button>
                </div>` : S`
                <div class="date-navigation">
                    <button id="bt-next-workday" @click="${this.jumpToWorkday}"><i class="fas fa-forward"></i></button>
                    <button id="bt-last-workday" @click="${this.jumpToWorkday}"><i class="fas fa-forward-fast"></i></button>
                </div>` : pe;
    }
    apiRender() {
      let r = this.selected_date.getDate() - 3, e = this.selected_date.getDate() + 3, t = [];
      const i = z.fromJSDate(this.selected_date).startOf("day");
      for (let o = r; o <= e; o++) {
        let a = new Date(i.toJSDate());
        a.setDate(o);
        const l = z.fromJSDate(a).startOf("day");
        t.push(l);
      }
      return S`
            <div class="date-selector">
                ${this.dateNavigation("back")}
                ${t.map((o) => S`
                    ${o.toMillis() === i.toMillis() ? S`
                            <div date="${o.toMillis()}" class="date-selector-date selected-date">
                                <vaadin-date-picker
                                    id="date-picker"
                                    @change="${this.dateClicked}"
                                    auto-open-disabled
                                    value="${Zr(o.toJSDate())}">
                                </vaadin-date-picker>
                            </div>` : S`
                            <div date="${o.toMillis()}" class="date-selector-date-inactive ${this.workDays && this.workDays.includes(o.toMillis()) ? "active-day" : ""}" @click="${this.dateClicked}">
                                <span >${o.weekdayShort}</span>
                            </div>`}
                `)}
                ${this.dateNavigation("forward")}
                
            </div>`;
    }
    dateClicked(r) {
      if (r.currentTarget.id === "date-picker") {
        const e = xr(r.currentTarget.value);
        je.dispatch(tr("dateSelector", { selectedDate: e }));
      } else {
        const e = /* @__PURE__ */ new Date();
        e.setTime(r.currentTarget.getAttribute("date")), je.dispatch(tr("dateSelector", { selectedDate: e }));
      }
    }
    firstUpdated(r) {
      super.firstUpdated(r);
    }
    // protected updated(_changedProperties: any) {
    //     super.updated(_changedProperties);
    //     // if (this.editing !== "") {
    //     //     this.shadowRoot.getElementById("edit-list").focus();
    //     // }
    // }
    // onAfterEnter(location: any, commands: any, router: any) {
    //     console.log("OnAfterEnter", location, commands, router);
    //     // this._installSyncEvents();
    // }
  };
  po.styles = Ue(pO);
  po.properties = {
    ...x2(po, po, "properties"),
    selected_date: { type: Date },
    workDays: { type: Array }
  };
  po = k2([
    tt("date-selector")
  ], po);
  const C2 = '.col-bg-body-lighter{background-color:var(--col-bg-body-lighter)}.col-bg-body{background-color:var(--col-bg-body)}.col-bg-body-darker{background-color:var(--col-bg-body-darker)}.col-bg-1-lighter{background-color:var(--col-bg-1-lighter)}.col-bg-1{background-color:var(--col-bg-1)}.col-bg-1-darker{background-color:var(--col-bg-1-darker)}.col-bg-1-input{background-color:var(--col-bg-1-input)}.col-primary-bg-1{background-color:var(--col-primary-bg-1)}.col-accent-bg-1{background-color:var(--col-accent-bg-1)}.col-success-bg-1{background-color:var(--col-success-bg-1)}.col-warning-bg-1{background-color:var(--col-warning-bg-1)}.col-error-bg-1{background-color:var(--col-error-bg-1)}.col-bg-2-lighter{background-color:var(--col-bg-2-lighter)}.col-bg-2{background-color:var(--col-bg-2)}.col-bg-2-darker{background-color:var(--col-bg-2-darker)}.col-bg-2-button{background-color:var(--col-bg-2-button)}.col-bg-2-input{background-color:var(--col-bg-2-input)}.col-primary-bg-2{background-color:var(--col-primary-bg-2)}.col-accent-bg-2{background-color:var(--col-accent-bg-2)}.col-success-bg-2{background-color:var(--col-success-bg-2)}.col-warning-bg-2{background-color:var(--col-warning-bg-2)}.col-error-bg-2{background-color:var(--col-error-bg-2)}.col-bg-3-lighter{background-color:var(--col-bg-3-lighter)}.col-bg-3{background-color:var(--col-bg-3)}.col-bg-3-darker{background-color:var(--col-bg-3-darker)}.col-bg-3-button{background-color:var(--col-bg-3-button)}.col-bg-3-input{background-color:var(--col-bg-3-input)}.col-primary-bg-3{background-color:var(--col-primary-bg-3)}.col-accent-bg-3{background-color:var(--col-accent-bg-3)}.col-success-bg-3{background-color:var(--col-success-bg-3)}.col-warning-bg-3{background-color:var(--col-warning-bg-3)}.col-error-bg-3{background-color:var(--col-error-bg-3)}.col-bg-ack-lighter{background-color:var(--col-bg-ack-lighter)}.col-bg-ack{background-color:var(--col-bg-ack)}.col-bg-ack-darker{background-color:var(--col-bg-ack-darker)}.col-primary-bg-ack{background-color:var(--col-primary-bg-ack)}.col-accent-bg-ack{background-color:var(--col-accent-bg-ack)}.col-bg-att-lighter{background-color:var(--col-bg-att-lighter)}.col-bg-att{background-color:var(--col-bg-att)}.col-bg-att-darker{background-color:var(--col-bg-att-darker)}.col-primary-bg-att{background-color:var(--col-primary-bg-att)}.col-accent-bg-att{background-color:var(--col-accent-bg-att)}.col-bg-alert-lighter{background-color:var(--col-bg-alert-lighter)}.col-bg-alert{background-color:var(--col-bg-alert)}.col-bg-alert-darker{background-color:var(--col-bg-alert-darker)}.col-primary-bg-alert{background-color:var(--col-primary-bg-alert)}.col-accent-bg-alert{background-color:var(--col-accent-bg-alert)}.col-bg-btn-lighter{background-color:var(--col-bg-btn-lighter)}.col-bg-btn{background-color:var(--col-bg-btn)}.col-bg-btn-darker{background-color:var(--col-bg-btn-darker)}.col-primary-bg-btn{background-color:var(--col-primary-bg-btn)}.col-accent-bg-btn{background-color:var(--col-accent-bg-btn)}.pattern-diagonal-stripes-sm{background:repeating-linear-gradient(45deg,transparent,transparent 10px,currentColor 10px,currentColor 20px)}.pattern-dots-lg{background-image:radial-gradient(currentColor 1.5px,transparent 1.5px);background-size:15px 15px}.pattern-dots-md{background-image:radial-gradient(currentColor 1px,transparent 1px);background-size:8px 8px}.pattern-dots-medium-dense{background-image:radial-gradient(currentColor .5px,transparent .5px);background-size:3px 3px}.pattern-dots-sm{background-image:radial-gradient(currentColor .5px,transparent .5px);background-size:5px 5px}.pattern-cross-dots-md,.imagelist-background{background-image:radial-gradient(currentColor .7px,transparent 1px),radial-gradient(currentColor .7px,transparent 1px);background-size:6.5px 6.5px;background-position:0 0,3.5px 3.5px}.imagelist-background{background-color:#fff9;background-blend-mode:overlay}.fa,.fas{font-family:"Font Awesome 5 Free";font-weight:900;font-style:normal}.fa-trash:before{content:""}.fa-view-grid:before{content:""}.fa-view-list:before{content:""}.fa-camera:before{content:""}.fa-view-image:before{content:""}.fa-check:before{content:""}.fa-exclamation-circle:before{content:""}.fa-list-check:before{content:""}.fa-backward:before{content:""}.fa-forward:before{content:""}.fa-backward-fast:before{content:""}.fa-forward-fast:before{content:""}p,div{padding:0;margin:0;border:0px;user-select:text;-webkit-user-select:text}select{user-select:none;-webkit-user-select:none}:host{display:block}div,p{font-family:var(--standard-text-font);user-select:none;-webkit-user-select:none}.context-selector{width:100%;background-color:var(--col-bg-2);display:flex;flex-direction:row;align-items:center;justify-content:center;flex-wrap:wrap;cursor:pointer;border-bottom:2px solid var(--col-bg-1-darker)}.selected-context{background-color:var(--col-bg-ack);color:var(--col-accent-bg-ack);font-weight:700;font-size:1.2em;cursor:default}.context{padding:.2em .5em}.context:hover{background-color:#ffffff80}.context:active{background-color:var(--col-bg-ack)}';
  var S2 = Object.getOwnPropertyDescriptor, A2 = Object.getPrototypeOf, E2 = Reflect.get, $2 = (r, e, t, i) => {
    for (var o = i > 1 ? void 0 : i ? S2(e, t) : e, a = r.length - 1, l; a >= 0; a--)
      (l = r[a]) && (o = l(o) || o);
    return o;
  }, T2 = (r, e, t) => E2(A2(r), t, e);
  let go = class extends Re {
    constructor() {
      super(), this.login_token = "", this.api_url = "", this.selected_date = null, this.selected_context = "", this.contexts = [], this.fetching_contexts = !1, this.fetch_error = "", this._init();
    }
    _init() {
    }
    fetch_contexts() {
      this.fetching_contexts = !0;
      const r = (this.selected_date.getMonth() + 1).toString().padStart(2, "0"), e = this.selected_date.getDate().toString().padStart(2, "0"), i = `${this.selected_date.getFullYear()}-${r}-${e}`, o = JSON.stringify(
        {
          cql: {
            meta: {
              version: 0.1
            },
            base: {
              scope: {
                unit: "browse()"
              },
              target: {
                field_or_instruction: "modified_ww()",
                format: "datetime(date)"
              },
              additional_fields: {
                type: {
                  field_or_instruction: "unit.type",
                  default: "",
                  format: "dsd_type(varchar)"
                }
              }
            },
            query: {
              type: "Raw",
              distinct: !0,
              columns: {
                identifier: {
                  source_field: "identifier"
                },
                uid: {
                  source_field: "id_uuid"
                },
                type: {
                  source_field: "type"
                }
              },
              conditions: {
                "?": `equals(data, "${i}")`
              }
            }
          }
        }
      );
      this.apiContext.fetchFromApi(
        "",
        "cql/query",
        {
          method: "POST",
          caller: "contextselector.fetch_contexts",
          body: o
        }
      ).then((a) => {
        a.result_msg !== "ok" ? this.fetch_error = a.result_msg : (this.fetch_error = "", this.load_contexts(a.records)), this.fetching_contexts = !1;
      }).catch((a) => {
        dt(this, a, "contextselector.fetch_data", null);
      });
    }
    load_contexts(r) {
      this.contexts = [], r.forEach((e) => {
        let t = new MS();
        t.selectedContext = e.identifier, t.selectedUid = e.uid, t.selectedContextType = e.type, this.contexts.push(t);
      }), this.contexts.findIndex((e) => e.selectedContext === this.selected_context) == -1 && this.changeContext("");
    }
    stateChanged(r) {
      if ("dateSelector" in r.selectors) {
        let e = r.selectors.dateSelector.selectedDate;
        (!this.selected_date || e.getTime() !== this.selected_date.getTime()) && (this.selected_date = e, this.fetch_contexts());
      }
      if ("contextSelector" in r.selectors) {
        let e = r.selectors.contextSelector.selectedContext;
        (!this.selected_context || e !== this.selected_context) && (this.selected_context = e);
      }
    }
    apiRender() {
      return S`
            <div class="context-selector">
                ${this.selected_date !== null ? this.render_contexts() : S`Please select a date`}
            </div>`;
    }
    changeContext(r) {
      let e = { selectedContext: "", selectedUid: "" };
      r && (e = this.contexts.find((t) => t.selectedContext === r)), je.dispatch(tr("contextSelector", e));
    }
    contextClicked(r) {
      const e = r.currentTarget.getAttribute("context");
      e != this.selected_context && this.changeContext(e);
    }
    render_contexts() {
      return this.fetching_contexts ? S`fetching contexts...` : S`
                <div class="context"
                     context=""
                     @click=${this.contextClicked}>
                    <i class="fa fa-trash"></i>
                </div>

                ${this.contexts.map(
        (r) => S`
                    <div class="context ${r.selectedContext === this.selected_context ? "selected-context" : ""}"
                         context="${r.selectedContext}"
                         @click=${this.contextClicked}>
                        ${r.selectedContext}
                    </div>`
      )}`;
    }
    firstUpdated(r) {
      super.firstUpdated(r);
    }
  };
  go.styles = Ue(C2);
  go.properties = {
    ...T2(go, go, "properties"),
    selected_date: { type: Date },
    selected_context: { type: String },
    fetching_contexts: { type: Boolean }
  };
  go = $2([
    tt("context-selector")
  ], go);
  const O2 = '.col-bg-body-lighter{background-color:var(--col-bg-body-lighter)}.col-bg-body{background-color:var(--col-bg-body)}.col-bg-body-darker{background-color:var(--col-bg-body-darker)}.col-bg-1-lighter{background-color:var(--col-bg-1-lighter)}.col-bg-1{background-color:var(--col-bg-1)}.col-bg-1-darker{background-color:var(--col-bg-1-darker)}.col-bg-1-input{background-color:var(--col-bg-1-input)}.col-primary-bg-1{background-color:var(--col-primary-bg-1)}.col-accent-bg-1{background-color:var(--col-accent-bg-1)}.col-success-bg-1{background-color:var(--col-success-bg-1)}.col-warning-bg-1{background-color:var(--col-warning-bg-1)}.col-error-bg-1{background-color:var(--col-error-bg-1)}.col-bg-2-lighter{background-color:var(--col-bg-2-lighter)}.col-bg-2{background-color:var(--col-bg-2)}.col-bg-2-darker{background-color:var(--col-bg-2-darker)}.col-bg-2-button{background-color:var(--col-bg-2-button)}.col-bg-2-input{background-color:var(--col-bg-2-input)}.col-primary-bg-2{background-color:var(--col-primary-bg-2)}.col-accent-bg-2{background-color:var(--col-accent-bg-2)}.col-success-bg-2{background-color:var(--col-success-bg-2)}.col-warning-bg-2{background-color:var(--col-warning-bg-2)}.col-error-bg-2{background-color:var(--col-error-bg-2)}.col-bg-3-lighter{background-color:var(--col-bg-3-lighter)}.col-bg-3{background-color:var(--col-bg-3)}.col-bg-3-darker{background-color:var(--col-bg-3-darker)}.col-bg-3-button{background-color:var(--col-bg-3-button)}.col-bg-3-input{background-color:var(--col-bg-3-input)}.col-primary-bg-3{background-color:var(--col-primary-bg-3)}.col-accent-bg-3{background-color:var(--col-accent-bg-3)}.col-success-bg-3{background-color:var(--col-success-bg-3)}.col-warning-bg-3{background-color:var(--col-warning-bg-3)}.col-error-bg-3{background-color:var(--col-error-bg-3)}.col-bg-ack-lighter{background-color:var(--col-bg-ack-lighter)}.col-bg-ack{background-color:var(--col-bg-ack)}.col-bg-ack-darker{background-color:var(--col-bg-ack-darker)}.col-primary-bg-ack{background-color:var(--col-primary-bg-ack)}.col-accent-bg-ack{background-color:var(--col-accent-bg-ack)}.col-bg-att-lighter{background-color:var(--col-bg-att-lighter)}.col-bg-att{background-color:var(--col-bg-att)}.col-bg-att-darker{background-color:var(--col-bg-att-darker)}.col-primary-bg-att{background-color:var(--col-primary-bg-att)}.col-accent-bg-att{background-color:var(--col-accent-bg-att)}.col-bg-alert-lighter{background-color:var(--col-bg-alert-lighter)}.col-bg-alert{background-color:var(--col-bg-alert)}.col-bg-alert-darker{background-color:var(--col-bg-alert-darker)}.col-primary-bg-alert{background-color:var(--col-primary-bg-alert)}.col-accent-bg-alert{background-color:var(--col-accent-bg-alert)}.col-bg-btn-lighter{background-color:var(--col-bg-btn-lighter)}.col-bg-btn{background-color:var(--col-bg-btn)}.col-bg-btn-darker{background-color:var(--col-bg-btn-darker)}.col-primary-bg-btn{background-color:var(--col-primary-bg-btn)}.col-accent-bg-btn{background-color:var(--col-accent-bg-btn)}.pattern-diagonal-stripes-sm{background:repeating-linear-gradient(45deg,transparent,transparent 10px,currentColor 10px,currentColor 20px)}.pattern-dots-lg{background-image:radial-gradient(currentColor 1.5px,transparent 1.5px);background-size:15px 15px}.pattern-dots-md{background-image:radial-gradient(currentColor 1px,transparent 1px);background-size:8px 8px}.pattern-dots-medium-dense{background-image:radial-gradient(currentColor .5px,transparent .5px);background-size:3px 3px}.pattern-dots-sm{background-image:radial-gradient(currentColor .5px,transparent .5px);background-size:5px 5px}.pattern-cross-dots-md,.imagelist-background{background-image:radial-gradient(currentColor .7px,transparent 1px),radial-gradient(currentColor .7px,transparent 1px);background-size:6.5px 6.5px;background-position:0 0,3.5px 3.5px}.imagelist-background{background-color:#fff9;background-blend-mode:overlay}.fa,.fas{font-family:"Font Awesome 5 Free";font-weight:900;font-style:normal}.fa-trash:before{content:""}.fa-view-grid:before{content:""}.fa-view-list:before{content:""}.fa-camera:before{content:""}.fa-view-image:before{content:""}.fa-check:before{content:""}.fa-exclamation-circle:before{content:""}.fa-list-check:before{content:""}.fa-backward:before{content:""}.fa-forward:before{content:""}.fa-backward-fast:before{content:""}.fa-forward-fast:before{content:""}p,div{padding:0;margin:0;border:0px;user-select:text;-webkit-user-select:text}select{user-select:none;-webkit-user-select:none}:host{display:block}div,p{font-family:var(--standard-text-font);-webkit-user-select:none;user-select:none}.team-selector{width:100%;background-color:var(--col-bg-2);color:var(--col-primary-bg-2);display:flex;flex-direction:row;align-items:center;justify-content:center;flex-wrap:wrap;cursor:pointer;border-bottom:2px solid var(--col-bg-1-darker)}.selected-member{background:var(--col-bg-ack);color:var(--col-accent-bg-ack);font-weight:700;font-size:1.2em;cursor:default}.team-member{padding:.2em .5em}.team-member:hover{background-color:#ffffff80}.team-member:active{background-color:var(--col-bg-ack)}';
  var D2 = Object.getOwnPropertyDescriptor, P2 = Object.getPrototypeOf, I2 = Reflect.get, M2 = (r, e, t, i) => {
    for (var o = i > 1 ? void 0 : i ? D2(e, t) : e, a = r.length - 1, l; a >= 0; a--)
      (l = r[a]) && (o = l(o) || o);
    return o;
  }, N2 = (r, e, t) => I2(P2(r), t, e);
  let mo = class extends Re {
    constructor() {
      super(), this.login_token = "", this.api_url = "", this.selected_date = null, this.selected_member = "", this.team = [], this.fetching_data = !1, this.fetch_error = "";
    }
    fetch_team() {
      this.fetching_data = !0;
      const r = (this.selected_date.getMonth() + 1).toString().padStart(2, "0"), e = this.selected_date.getDate().toString().padStart(2, "0"), i = `${this.selected_date.getFullYear()}-${r}-${e}`;
      this.apiContext.fetchFromApi(
        "",
        "cql/query",
        {
          method: "POST",
          caller: "teamselector.fetch_team",
          body: JSON.stringify(
            {
              cql: {
                meta: {
                  version: 0.1
                },
                base: {
                  scope: {
                    archival_entity: "browse()",
                    site: "browse()"
                  },
                  target: {
                    field_or_instruction: "modified_ww()",
                    format: "datetime(date)"
                  },
                  additional_fields: {
                    modified_by: {
                      field_or_instruction: "replfield_modified_by()",
                      default: "?"
                    }
                  }
                },
                query: {
                  type: "Raw",
                  distinct: !0,
                  columns: {
                    member: {
                      source_field: "modified_by"
                    }
                  },
                  conditions: {
                    "?": `equals(data, "${i}")`
                  }
                }
              }
            }
          )
        }
      ).then((o) => {
        o.result_msg !== "ok" ? this.fetch_error = o.result_msg : (this.fetch_error = "", this.parse_records(o.records)), this.fetching_data = !1;
      }).catch((o) => {
        dt(this, o, "teamselector.fetch_data", null);
      });
    }
    parse_records(r) {
      this.team = [], r.forEach((e) => {
        this.team.push(e.member);
      }), this.team.indexOf(this.selected_member) == -1 && this.changeSelection("");
    }
    changeSelection(r) {
      je.dispatch(tr("teamSelector", { selectedMember: r }));
    }
    stateChanged(r) {
      if ("dateSelector" in r.selectors) {
        let e = r.selectors.dateSelector.selectedDate;
        (!this.selected_date || e.getTime() !== this.selected_date.getTime()) && (this.selected_date = e, this.fetch_team());
      }
      if ("teamSelector" in r.selectors) {
        let e = r.selectors.teamSelector.selectedMember;
        (!this.selected_member || e !== this.selected_member) && (this.selected_member = e);
      }
    }
    memberClicked(r) {
      const e = r.currentTarget.getAttribute("member");
      e != this.selected_member && this.changeSelection(e);
    }
    apiRender() {
      return S`
                <div class="team-selector">
                ${this.selected_date !== null ? this.render_team() : S`Please select a date`}
                </div>`;
    }
    render_team() {
      return this.fetching_data ? S`fetching data...` : S`
                        <div class="member"
                             member=""
                             @click=${this.memberClicked}>
                            <i class="fa fa-trash"></i>
                        </div>

                        ${this.team.map(
        (r) => S`
                            <div class="team-member ${r == this.selected_member ? "selected-member" : ""}"
                                 member="${r}"
                                  
                                 @click=${this.memberClicked}>
                                ${r}
                            </div>`
      )}`;
    }
    firstUpdated(r) {
      super.firstUpdated(r);
    }
  };
  mo.styles = Ue(O2);
  mo.properties = {
    ...N2(mo, mo, "properties"),
    selected_member: { type: String },
    selected_date: { type: Date },
    fetching_data: { type: Boolean }
  };
  mo = M2([
    tt("team-selector")
  ], mo);
  Te(
    "vaadin-list-box",
    me`
    :host {
      -webkit-tap-highlight-color: transparent;
      --_lumo-item-selected-icon-display: var(--_lumo-list-box-item-selected-icon-display, block);
    }

    /* Dividers */
    [part='items'] ::slotted(hr) {
      height: 1px;
      border: 0;
      padding: 0;
      margin: var(--lumo-space-s) var(--lumo-border-radius-m);
      background-color: var(--lumo-contrast-10pct);
    }
  `,
    { moduleId: "lumo-list-box" }
  );
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  const L2 = (r) => class extends Ha(r) {
    /** @protected */
    focus() {
      const t = this._getItems();
      if (Array.isArray(t)) {
        const i = this._getAvailableIndex(t, 0, null, (o) => !lg(o));
        i >= 0 && t[i].focus();
      }
    }
    /**
     * @return {Element | null}
     * @protected
     */
    get focused() {
      return (this._getItems() || []).find(Lb);
    }
    /**
     * @return {boolean}
     * @protected
     */
    get _vertical() {
      return !0;
    }
    /**
     * Get the list of items participating in keyboard navigation.
     * By default, it treats all the light DOM children as items.
     * Override this method to provide custom list of elements.
     *
     * @return {Element[]}
     * @protected
     */
    _getItems() {
      return Array.from(this.children);
    }
    /**
     * Override an event listener from `KeyboardMixin`.
     *
     * @param {!KeyboardEvent} event
     * @protected
     * @override
     */
    _onKeyDown(t) {
      if (super._onKeyDown(t), t.metaKey || t.ctrlKey)
        return;
      const { key: i } = t, o = this._getItems() || [], a = o.indexOf(this.focused);
      let l, d;
      const f = !this._vertical && this.getAttribute("dir") === "rtl" ? -1 : 1;
      this.__isPrevKey(i) ? (d = -f, l = a - f) : this.__isNextKey(i) ? (d = f, l = a + f) : i === "Home" ? (d = 1, l = 0) : i === "End" && (d = -1, l = o.length - 1), l = this._getAvailableIndex(o, l, d, (g) => !lg(g)), l >= 0 && (t.preventDefault(), this._focus(l, !0));
    }
    /**
     * @param {string} key
     * @return {boolean}
     * @private
     */
    __isPrevKey(t) {
      return this._vertical ? t === "ArrowUp" : t === "ArrowLeft";
    }
    /**
     * @param {string} key
     * @return {boolean}
     * @private
     */
    __isNextKey(t) {
      return this._vertical ? t === "ArrowDown" : t === "ArrowRight";
    }
    /**
     * Focus the item at given index. Override this method to add custom logic.
     *
     * @param {number} index
     * @param {boolean} navigating
     * @protected
     */
    _focus(t, i = !1) {
      const o = this._getItems();
      this._focusItem(o[t], i);
    }
    /**
     * Focus the given item. Override this method to add custom logic.
     *
     * @param {Element} item
     * @param {boolean} navigating
     * @protected
     */
    _focusItem(t) {
      t && (t.focus(), t.setAttribute("focus-ring", ""));
    }
    /**
     * Returns index of the next item that satisfies the given condition,
     * based on the index of the current item and a numeric increment.
     *
     * @param {Element[]} items - array of items to iterate over
     * @param {number} index - index of the current item
     * @param {number} increment - numeric increment, can be either 1 or -1
     * @param {Function} condition - function used to check the item
     * @return {number}
     * @protected
     */
    _getAvailableIndex(t, i, o, a) {
      const l = t.length;
      let d = i;
      for (let u = 0; typeof d == "number" && u < l; u += 1, d += o || 1) {
        d < 0 ? d = l - 1 : d >= l && (d = 0);
        const f = t[d];
        if (!f.hasAttribute("disabled") && this.__isMatchingItem(f, a))
          return d;
      }
      return -1;
    }
    /**
     * Returns true if the item matches condition.
     *
     * @param {Element} item - item to check
     * @param {Function} condition - function used to check the item
     * @return {number}
     * @private
     */
    __isMatchingItem(t, i) {
      return typeof i == "function" ? i(t) : !0;
    }
  };
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  const R2 = (r) => class extends L2(r) {
    static get properties() {
      return {
        /**
         * Used for mixin detection because `instanceof` does not work with mixins.
         * @type {boolean}
         */
        _hasVaadinListMixin: {
          value: !0
        },
        /**
         * The index of the item selected in the items array.
         * Note: Not updated when used in `multiple` selection mode.
         */
        selected: {
          type: Number,
          reflectToAttribute: !0,
          notify: !0
        },
        /**
         * Define how items are disposed in the dom.
         * Possible values are: `horizontal|vertical`.
         * It also changes navigation keys from left/right to up/down.
         * @type {!ListOrientation}
         */
        orientation: {
          type: String,
          reflectToAttribute: !0,
          value: ""
        },
        /**
         * The list of items from which a selection can be made.
         * It is populated from the elements passed to the light DOM,
         * and updated dynamically when adding or removing items.
         *
         * The item elements must implement `Vaadin.ItemMixin`.
         *
         * Note: unlike `<vaadin-combo-box>`, this property is read-only,
         * so if you want to provide items by iterating array of data,
         * you have to use `dom-repeat` and place it to the light DOM.
         * @type {!Array<!Element> | undefined}
         */
        items: {
          type: Array,
          readOnly: !0,
          notify: !0
        },
        /**
         * The search buffer for the keyboard selection feature.
         * @private
         */
        _searchBuf: {
          type: String,
          value: ""
        }
      };
    }
    static get observers() {
      return ["_enhanceItems(items, orientation, selected, disabled)"];
    }
    /** @protected */
    ready() {
      super.ready(), this.addEventListener("click", (t) => this._onClick(t)), this._observer = new Ca(this, () => {
        this._setItems(this._filterItems(Ca.getFlattenedNodes(this)));
      });
    }
    /**
     * Override method inherited from `KeyboardDirectionMixin`
     * to use the stored list of item elements.
     *
     * @return {Element[]}
     * @protected
     * @override
     */
    _getItems() {
      return this.items;
    }
    /** @private */
    _enhanceItems(t, i, o, a) {
      if (!a && t) {
        this.setAttribute("aria-orientation", i || "vertical"), this.items.forEach((d) => {
          i ? d.setAttribute("orientation", i) : d.removeAttribute("orientation");
        }), this._setFocusable(o || 0);
        const l = t[o];
        t.forEach((d) => {
          d.selected = d === l;
        }), l && !l.disabled && this._scrollToItem(o);
      }
    }
    /**
     * @param {!Array<!Element>} array
     * @return {!Array<!Element>}
     * @protected
     */
    _filterItems(t) {
      return t.filter((i) => i._hasVaadinItemMixin);
    }
    /**
     * @param {!MouseEvent} event
     * @protected
     */
    _onClick(t) {
      if (t.metaKey || t.shiftKey || t.ctrlKey || t.defaultPrevented)
        return;
      const i = this._filterItems(t.composedPath())[0];
      let o;
      i && !i.disabled && (o = this.items.indexOf(i)) >= 0 && (this.selected = o);
    }
    /**
     * @param {number} currentIdx
     * @param {string} key
     * @return {number}
     * @protected
     */
    _searchKey(t, i) {
      this._searchReset = Do.debounce(this._searchReset, Un.after(500), () => {
        this._searchBuf = "";
      }), this._searchBuf += i.toLowerCase(), this.items.some((a) => this.__isMatchingKey(a)) || (this._searchBuf = i.toLowerCase());
      const o = this._searchBuf.length === 1 ? t + 1 : t;
      return this._getAvailableIndex(
        this.items,
        o,
        1,
        (a) => this.__isMatchingKey(a) && getComputedStyle(a).display !== "none"
      );
    }
    /** @private */
    __isMatchingKey(t) {
      return t.textContent.replace(/[^\p{L}\p{Nd}]/gu, "").toLowerCase().startsWith(this._searchBuf);
    }
    /**
     * @return {boolean}
     * @protected
     */
    get _isRTL() {
      return !this._vertical && this.getAttribute("dir") === "rtl";
    }
    /**
     * Override an event listener from `KeyboardMixin`
     * to search items by key.
     *
     * @param {!KeyboardEvent} event
     * @protected
     * @override
     */
    _onKeyDown(t) {
      if (t.metaKey || t.ctrlKey)
        return;
      const i = t.key, o = this.items.indexOf(this.focused);
      if (/[\p{L}\p{Nd}]/u.test(i) && i.length === 1) {
        const a = this._searchKey(o, i);
        a >= 0 && this._focus(a);
        return;
      }
      super._onKeyDown(t);
    }
    /**
     * @param {!Element} item
     * @return {boolean}
     * @protected
     */
    _isItemHidden(t) {
      return getComputedStyle(t).display === "none";
    }
    /**
     * @param {number} idx
     * @protected
     */
    _setFocusable(t) {
      t = this._getAvailableIndex(this.items, t, 1);
      const i = this.items[t];
      this.items.forEach((o) => {
        o.tabIndex = o === i ? 0 : -1;
      });
    }
    /**
     * @param {number} idx
     * @protected
     */
    _focus(t) {
      this.items.forEach((i, o) => {
        i.focused = o === t;
      }), this._setFocusable(t), this._scrollToItem(t), super._focus(t);
    }
    focus() {
      this._observer && this._observer.flush();
      const t = this.querySelector('[tabindex="0"]') || (this.items ? this.items[0] : null);
      this._focusItem(t);
    }
    /**
     * @return {!HTMLElement}
     * @protected
     */
    get _scrollerElement() {
      return this;
    }
    /**
     * Scroll the container to have the next item by the edge of the viewport.
     * @param {number} idx
     * @protected
     */
    _scrollToItem(t) {
      const i = this.items[t];
      if (!i)
        return;
      const o = this._vertical ? ["top", "bottom"] : this._isRTL ? ["right", "left"] : ["left", "right"], a = this._scrollerElement.getBoundingClientRect(), l = (this.items[t + 1] || i).getBoundingClientRect(), d = (this.items[t - 1] || i).getBoundingClientRect();
      let u = 0;
      !this._isRTL && l[o[1]] >= a[o[1]] || this._isRTL && l[o[1]] <= a[o[1]] ? u = l[o[1]] - a[o[1]] : (!this._isRTL && d[o[0]] <= a[o[0]] || this._isRTL && d[o[0]] >= a[o[0]]) && (u = d[o[0]] - a[o[0]]), this._scroll(u);
    }
    /**
     * @return {boolean}
     * @protected
     */
    get _vertical() {
      return this.orientation !== "horizontal";
    }
    /**
     * @param {number} pixels
     * @protected
     */
    _scroll(t) {
      if (this._vertical)
        this._scrollerElement.scrollTop += t;
      else {
        const i = this.getAttribute("dir") || "ltr", o = lo.detectScrollType(), a = lo.getNormalizedScrollLeft(o, i, this._scrollerElement) + t;
        lo.setNormalizedScrollLeft(o, i, this._scrollerElement, a);
      }
    }
    /**
     * Fired when the selection is changed.
     * Not fired when used in `multiple` selection mode.
     *
     * @event selected-changed
     * @param {Object} detail
     * @param {Object} detail.value the index of the item selected in the items array.
     */
  };
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  const F2 = (r) => class extends R2(r) {
    static get properties() {
      return {
        /**
         * Specifies that multiple options can be selected at once.
         */
        multiple: {
          type: Boolean,
          value: !1,
          reflectToAttribute: !0,
          observer: "_multipleChanged"
        },
        /**
         * Array of indexes of the items selected in the items array
         * Note: Not updated when used in single selection mode.
         * @type {number[] | null | undefined}
         */
        selectedValues: {
          type: Array,
          notify: !0,
          value: () => []
        }
      };
    }
    static get observers() {
      return ["_enhanceMultipleItems(items, multiple, selected, disabled, selectedValues, selectedValues.*)"];
    }
    /** @protected */
    ready() {
      this.addEventListener("click", (t) => this._onMultipleClick(t)), super.ready();
    }
    /** @private */
    _enhanceMultipleItems(t, i, o, a, l) {
      if (!(!t || !i)) {
        if (l) {
          const d = l.map((u) => t[u]);
          t.forEach((u) => {
            u.selected = d.includes(u);
          });
        }
        this._scrollToLastSelectedItem();
      }
    }
    /** @private */
    _scrollToLastSelectedItem() {
      const t = this.selectedValues.slice(-1)[0];
      t && !t.disabled && this._scrollToItem(t);
    }
    /**
     * @param {!MouseEvent} event
     * @protected
     */
    _onMultipleClick(t) {
      const i = this._filterItems(t.composedPath())[0], o = i && !i.disabled ? this.items.indexOf(i) : -1;
      o < 0 || !this.multiple || (t.preventDefault(), this.selectedValues.includes(o) ? this.selectedValues = this.selectedValues.filter((a) => a !== o) : this.selectedValues = this.selectedValues.concat(o));
    }
    /** @private */
    _multipleChanged(t, i) {
      !t && i && (this.selectedValues = [], this.items.forEach((o) => {
        o.selected = !1;
      }), this.removeAttribute("aria-multiselectable")), t && !i && (this.setAttribute("aria-multiselectable", "true"), this.selected !== void 0 && (this.selectedValues = [...this.selectedValues, this.selected], this.selected = void 0));
    }
    /**
     * Fired when the selection is changed.
     * Not fired in single selection mode.
     *
     * @event selected-values-changed
     * @param {Object} detail
     * @param {Object} detail.value the array of indexes of the items selected in the items array.
     */
  };
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  class gm extends fu(F2(Kr(Oi(Gt)))) {
    static get template() {
      return Ar`
      <style>
        :host {
          display: flex;
        }

        :host([hidden]) {
          display: none !important;
        }

        [part='items'] {
          height: 100%;
          width: 100%;
          overflow-y: auto;
          -webkit-overflow-scrolling: touch;
        }
      </style>
      <div part="items">
        <slot></slot>
      </div>

      <slot name="tooltip"></slot>
    `;
    }
    static get is() {
      return "vaadin-list-box";
    }
    static get properties() {
      return {
        // We don't need to define this property since super default is vertical,
        // but we don't want it to be modified, or be shown in the API docs.
        /** @private */
        orientation: {
          readOnly: !0
        }
      };
    }
    constructor() {
      super(), this.focused;
    }
    /** @protected */
    ready() {
      super.ready(), this.setAttribute("role", "listbox"), setTimeout(this._checkImport.bind(this), 2e3), this._tooltipController = new pu(this), this.addController(this._tooltipController);
    }
    /**
     * @return {!HTMLElement}
     * @protected
     */
    get _scrollerElement() {
      return this.shadowRoot.querySelector('[part="items"]');
    }
    /** @private */
    _checkImport() {
      const e = this.querySelector("vaadin-item");
      e && e instanceof Gt;
    }
  }
  customElements.define(gm.is, gm);
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  const z2 = me`
  :host {
    display: flex;
    align-items: center;
    box-sizing: border-box;
    font-family: var(--lumo-font-family);
    font-size: var(--lumo-font-size-m);
    line-height: var(--lumo-line-height-xs);
    padding: 0.5em calc(var(--lumo-space-l) + var(--lumo-border-radius-m) / 4) 0.5em
      var(--_lumo-list-box-item-padding-left, calc(var(--lumo-border-radius-m) / 4));
    min-height: var(--lumo-size-m);
    outline: none;
    border-radius: var(--lumo-border-radius-m);
    cursor: var(--lumo-clickable-cursor);
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    -webkit-tap-highlight-color: var(--lumo-primary-color-10pct);
  }

  /* Checkmark */
  [part='checkmark']::before {
    display: var(--_lumo-item-selected-icon-display, none);
    content: var(--lumo-icons-checkmark);
    font-family: lumo-icons;
    font-size: var(--lumo-icon-size-m);
    line-height: 1;
    font-weight: normal;
    width: 1em;
    height: 1em;
    margin: calc((1 - var(--lumo-line-height-xs)) * var(--lumo-font-size-m) / 2) 0;
    color: var(--lumo-primary-text-color);
    flex: none;
    opacity: 0;
    transition: transform 0.2s cubic-bezier(0.12, 0.32, 0.54, 2), opacity 0.1s;
  }

  :host([selected]) [part='checkmark']::before {
    opacity: 1;
  }

  :host([active]:not([selected])) [part='checkmark']::before {
    transform: scale(0.8);
    opacity: 0;
    transition-duration: 0s;
  }

  [part='content'] {
    flex: auto;
  }

  /* Disabled */
  :host([disabled]) {
    color: var(--lumo-disabled-text-color);
    cursor: default;
    pointer-events: none;
  }

  /* TODO a workaround until we have "focus-follows-mouse". After that, use the hover style for focus-ring as well */
  @media (any-hover: hover) {
    :host(:hover:not([disabled])) {
      background-color: var(--lumo-primary-color-10pct);
    }

    :host([focus-ring]:not([disabled])) {
      box-shadow: inset 0 0 0 2px var(--lumo-primary-color-50pct);
    }
  }

  /* RTL specific styles */
  :host([dir='rtl']) {
    padding-left: calc(var(--lumo-space-l) + var(--lumo-border-radius-m) / 4);
    padding-right: var(--_lumo-list-box-item-padding-left, calc(var(--lumo-border-radius-m) / 4));
  }

  /* Slotted icons */
  :host ::slotted(vaadin-icon),
  :host ::slotted(iron-icon) {
    width: var(--lumo-icon-size-m);
    height: var(--lumo-icon-size-m);
  }
`;
  Te("vaadin-item", z2, { moduleId: "lumo-item" });
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  const H2 = (r) => class extends Gb(Ua(r)) {
    static get properties() {
      return {
        /**
         * Used for mixin detection because `instanceof` does not work with mixins.
         * e.g. in VaadinListMixin it filters items by using the
         * `element._hasVaadinItemMixin` condition.
         * @type {boolean}
         */
        _hasVaadinItemMixin: {
          value: !0
        },
        /**
         * If true, the item is in selected state.
         * @type {boolean}
         */
        selected: {
          type: Boolean,
          value: !1,
          reflectToAttribute: !0,
          observer: "_selectedChanged"
        },
        /** @private */
        _value: String
      };
    }
    /**
     * By default, `Space` is the only possible activation key for a focusable HTML element.
     * Nonetheless, the item is an exception as it can be also activated by pressing `Enter`.
     * See the "Keyboard Support" section in https://www.w3.org/TR/wai-aria-practices/examples/menubar/menubar-1/menubar-1.html.
     *
     * @protected
     * @override
     */
    get _activeKeys() {
      return ["Enter", " "];
    }
    /**
     * @return {string}
     */
    get value() {
      return this._value !== void 0 ? this._value : this.textContent.trim();
    }
    /**
     * @param {string} value
     */
    set value(t) {
      this._value = t;
    }
    /** @protected */
    ready() {
      super.ready();
      const t = this.getAttribute("value");
      t !== null && (this.value = t);
    }
    /**
     * Override native `focus` to set focused attribute
     * when focusing the item programmatically.
     * @protected
     * @override
     */
    focus() {
      this.disabled || (super.focus(), this._setFocused(!0));
    }
    /**
     * @param {KeyboardEvent | MouseEvent} _event
     * @protected
     * @override
     */
    _shouldSetActive(t) {
      return !this.disabled && !(t.type === "keydown" && t.defaultPrevented);
    }
    /** @private */
    _selectedChanged(t) {
      this.setAttribute("aria-selected", t);
    }
    /**
     * Override an observer from `DisabledMixin`.
     * @protected
     * @override
     */
    _disabledChanged(t) {
      super._disabledChanged(t), t && (this.selected = !1, this.blur());
    }
    /**
     * In order to be fully accessible from the keyboard, the item should
     * manually fire the `click` event once an activation key is pressed.
     *
     * According to the UI Events specifications,
     * the `click` event should be fired exactly on `keydown`:
     * https://www.w3.org/TR/uievents/#event-type-keydown
     *
     * @param {KeyboardEvent} event
     * @protected
     * @override
     */
    _onKeyDown(t) {
      super._onKeyDown(t), this._activeKeys.includes(t.key) && !t.defaultPrevented && (t.preventDefault(), this.click());
    }
  };
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  class mm extends H2(Kr(Kn(Gt))) {
    static get template() {
      return Ar`
      <style>
        :host {
          display: inline-block;
        }

        :host([hidden]) {
          display: none !important;
        }
      </style>
      <span part="checkmark" aria-hidden="true"></span>
      <div part="content">
        <slot></slot>
      </div>
    `;
    }
    static get is() {
      return "vaadin-item";
    }
    constructor() {
      super(), this.value, this.label;
    }
    /** @protected */
    ready() {
      super.ready(), this.setAttribute("role", "option");
    }
  }
  customElements.define(mm.is, mm);
  /**
   * @license
   * Copyright (c) 2000 - 2024 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   */
  const U2 = '.col-bg-body-lighter{background-color:var(--col-bg-body-lighter)}.col-bg-body{background-color:var(--col-bg-body)}.col-bg-body-darker{background-color:var(--col-bg-body-darker)}.col-bg-1-lighter{background-color:var(--col-bg-1-lighter)}.col-bg-1{background-color:var(--col-bg-1)}.col-bg-1-darker{background-color:var(--col-bg-1-darker)}.col-bg-1-input{background-color:var(--col-bg-1-input)}.col-primary-bg-1{background-color:var(--col-primary-bg-1)}.col-accent-bg-1{background-color:var(--col-accent-bg-1)}.col-success-bg-1{background-color:var(--col-success-bg-1)}.col-warning-bg-1{background-color:var(--col-warning-bg-1)}.col-error-bg-1{background-color:var(--col-error-bg-1)}.col-bg-2-lighter{background-color:var(--col-bg-2-lighter)}.col-bg-2{background-color:var(--col-bg-2)}.col-bg-2-darker{background-color:var(--col-bg-2-darker)}.col-bg-2-button{background-color:var(--col-bg-2-button)}.col-bg-2-input{background-color:var(--col-bg-2-input)}.col-primary-bg-2{background-color:var(--col-primary-bg-2)}.col-accent-bg-2{background-color:var(--col-accent-bg-2)}.col-success-bg-2{background-color:var(--col-success-bg-2)}.col-warning-bg-2{background-color:var(--col-warning-bg-2)}.col-error-bg-2{background-color:var(--col-error-bg-2)}.col-bg-3-lighter{background-color:var(--col-bg-3-lighter)}.col-bg-3{background-color:var(--col-bg-3)}.col-bg-3-darker{background-color:var(--col-bg-3-darker)}.col-bg-3-button{background-color:var(--col-bg-3-button)}.col-bg-3-input{background-color:var(--col-bg-3-input)}.col-primary-bg-3{background-color:var(--col-primary-bg-3)}.col-accent-bg-3{background-color:var(--col-accent-bg-3)}.col-success-bg-3{background-color:var(--col-success-bg-3)}.col-warning-bg-3{background-color:var(--col-warning-bg-3)}.col-error-bg-3{background-color:var(--col-error-bg-3)}.col-bg-ack-lighter{background-color:var(--col-bg-ack-lighter)}.col-bg-ack{background-color:var(--col-bg-ack)}.col-bg-ack-darker{background-color:var(--col-bg-ack-darker)}.col-primary-bg-ack{background-color:var(--col-primary-bg-ack)}.col-accent-bg-ack{background-color:var(--col-accent-bg-ack)}.col-bg-att-lighter{background-color:var(--col-bg-att-lighter)}.col-bg-att{background-color:var(--col-bg-att)}.col-bg-att-darker{background-color:var(--col-bg-att-darker)}.col-primary-bg-att{background-color:var(--col-primary-bg-att)}.col-accent-bg-att{background-color:var(--col-accent-bg-att)}.col-bg-alert-lighter{background-color:var(--col-bg-alert-lighter)}.col-bg-alert{background-color:var(--col-bg-alert)}.col-bg-alert-darker{background-color:var(--col-bg-alert-darker)}.col-primary-bg-alert{background-color:var(--col-primary-bg-alert)}.col-accent-bg-alert{background-color:var(--col-accent-bg-alert)}.col-bg-btn-lighter{background-color:var(--col-bg-btn-lighter)}.col-bg-btn{background-color:var(--col-bg-btn)}.col-bg-btn-darker{background-color:var(--col-bg-btn-darker)}.col-primary-bg-btn{background-color:var(--col-primary-bg-btn)}.col-accent-bg-btn{background-color:var(--col-accent-bg-btn)}.pattern-diagonal-stripes-sm{background:repeating-linear-gradient(45deg,transparent,transparent 10px,currentColor 10px,currentColor 20px)}.pattern-dots-lg{background-image:radial-gradient(currentColor 1.5px,transparent 1.5px);background-size:15px 15px}.pattern-dots-md{background-image:radial-gradient(currentColor 1px,transparent 1px);background-size:8px 8px}.pattern-dots-medium-dense{background-image:radial-gradient(currentColor .5px,transparent .5px);background-size:3px 3px}.pattern-dots-sm{background-image:radial-gradient(currentColor .5px,transparent .5px);background-size:5px 5px}.pattern-cross-dots-md,.imagelist-background{background-image:radial-gradient(currentColor .7px,transparent 1px),radial-gradient(currentColor .7px,transparent 1px);background-size:6.5px 6.5px;background-position:0 0,3.5px 3.5px}.imagelist-background{background-color:#fff9;background-blend-mode:overlay}p,div{padding:0;margin:0;border:0px;user-select:text;-webkit-user-select:text}select{user-select:none;-webkit-user-select:none}.fa,.fas{font-family:"Font Awesome 5 Free";font-weight:900;font-style:normal}.fa-trash:before{content:""}.fa-view-grid:before{content:""}.fa-view-list:before{content:""}.fa-camera:before{content:""}.fa-view-image:before{content:""}.fa-check:before{content:""}.fa-exclamation-circle:before{content:""}.fa-list-check:before{content:""}.fa-backward:before{content:""}.fa-forward:before{content:""}.fa-backward-fast:before{content:""}.fa-forward-fast:before{content:""}:host{display:block}div,p{font-family:var(--standard-text-font);-webkit-user-select:none;user-select:none}.widget-selector-button{width:2rem;height:2rem;position:absolute;margin-top:1em;margin-left:1em}.widget-selector-button-closed{background-color:var(--col-bg-2-button);color:var(--col-primary-bg-btn)}.widget-selector-button-closed:hover,.widget-selector-button-closed:focus{background-color:var(--col-bg-2-button);color:var(--col-accent-bg-btn);border:solid 2px var(--col-accent-bg-btn)}.widget-selector-button-open{background-color:var(--col-bg-ack);color:var(--col-primary-bg-ack)}.widget-selector-button-open:hover,.widget-selector-button-open:focus{background-color:var(--col-bg-ack-lighter);color:var(--col-primary-bg-ack);border:solid 2px var(--col-bg-ack-lighter)}.widget-selector-list{position:absolute;background:var(--col-bg-body);padding:.1em 1em .1em .1rem;margin-top:3rem;margin-left:1rem;border:2px solid var(--col-bg-1-darker);z-index:100}.widget-selector-closed{display:none}';
  var W2 = Object.defineProperty, B2 = Object.getOwnPropertyDescriptor, V2 = Object.getPrototypeOf, q2 = Reflect.get, gv = (r, e, t, i) => {
    for (var o = i > 1 ? void 0 : i ? B2(e, t) : e, a = r.length - 1, l; a >= 0; a--)
      (l = r[a]) && (o = (i ? l(e, t, o) : l(o)) || o);
    return i && o && W2(e, t, o), o;
  }, Y2 = (r, e, t) => q2(V2(r), t, e);
  const bm = "kioskDVDefaultWidgetSelectionV2";
  let ki = class extends Re {
    constructor() {
      super(), this.login_token = "", this.api_url = "", this.record_type_names = null, this.selectorIsOpen = !1, this._init();
    }
    _init() {
      je.dispatch(tr("widgetSelector", { selectedWidgets: this.selectedWidgets }));
    }
    stateChanged(r) {
      this.widgets && "widgetSelector" in r.selectors && r.selectors.widgetSelector.selectedWidgets && (this.selectedWidgets = r.selectors.widgetSelector.selectedWidgets), r.constants.length > 0 && !this.widgets && (this.record_type_names = La(r.constants), this.widgets = XS(r), this.selectedWidgets ? this.requestUpdate() : this.getDefaultSelection().then((e) => {
        this.selectedWidgets = e, je.dispatch(tr("widgetSelector", { selectedWidgets: this.selectedWidgets }));
      }).catch((e) => {
      }));
    }
    async getDefaultSelection() {
      const r = await cookieStore.get(bm);
      return r ? JSON.parse(r.value) : rd.slice();
    }
    closeSelector() {
      this.docClicked && document.removeEventListener("click", this.docClicked);
      const r = this.getWidgetSelection();
      this.selectorIsOpen = !1, r.length === this.selectedWidgets?.length && r.every((e, t) => e === this.selectedWidgets[t]) || (je.dispatch(tr("widgetSelector", { selectedWidgets: r })), this.storeSelectionInCookie(r));
    }
    storeSelectionInCookie(r) {
      const e = {
        name: bm,
        value: JSON.stringify(r),
        expires: Date.now() + 2592e6,
        //30 days
        path: "/"
      };
      cookieStore.set(e).catch(() => {
      });
    }
    getWidgetSelection() {
      const r = this.shadowRoot.querySelector("#widget-selector");
      let e = [];
      if (r) {
        const t = r.selectedValues;
        t.sort();
        for (const i of t) {
          const o = this.widgets.find((a) => a.order === i);
          o && e.push(o.id);
        }
      }
      return e.length == 0 && (e = rd.slice()), e;
    }
    getWidgetIndices() {
      return this.widgets.filter((r) => this.selectedWidgets?.includes(r.id)).map((r) => r.order);
    }
    updated(r) {
      if (super.updated(r), r.has("selectedWidgets")) {
        const e = this.shadowRoot.querySelector("#widget-selector");
        if (e) {
          const t = this.getWidgetIndices();
          e.selectedValues = t;
        }
      }
    }
    selectorButtonClicked() {
      const r = this.shadowRoot.querySelector("#widget-selector");
      this.selectorIsOpen ? this.closeSelector() : (this.docClicked = (e) => {
        if (!e.composedPath().includes(r)) {
          const i = this.shadowRoot.querySelector("#widget-selector-button");
          e.composedPath().includes(i) || (this.closeSelector(), document.removeEventListener("click", this.docClicked));
        }
      }, document.addEventListener("click", this.docClicked), this.selectorIsOpen = !0);
    }
    apiRender() {
      return this.widgets?.length ? S`
            <button id="widget-selector-button"
                    class="widget-selector-button ${this.selectorIsOpen ? "widget-selector-button-open" : "widget-selector-button-closed"}"
                    @click="${this.selectorButtonClicked}"><i class="fas fa-list-check"></i></button>
            <vaadin-list-box id="widget-selector"
                             class="widget-selector-list ${this.selectorIsOpen ? "" : "widget-selector-closed"}"
                             multiple ">
            ${this.widgets.map((r) => S`
                <vaadin-item>${r.displayName}</vaadin-item>
            `)}
            </vaadin-list-box>

        ` : S``;
    }
    disconnectedCallback() {
      super.disconnectedCallback(), this.docClicked && document.removeEventListener("click", this.docClicked);
    }
    firstUpdated(r) {
      super.firstUpdated(r);
    }
    // protected updated(_changedProperties: any) {
    //     super.updated(_changedProperties);
    //     // if (this.editing !== "") {
    //     //     this.shadowRoot.getElementById("edit-list").focus();
    //     // }
    // }
    // onAfterEnter(location: any, commands: any, router: any) {
    //     console.log("OnAfterEnter", location, commands, router);
    //     // this._installSyncEvents();
    // }
  };
  ki.styles = Ue(U2);
  ki.properties = {
    ...Y2(ki, ki, "properties"),
    selectedWidgets: { type: Array }
  };
  gv([
    Jd()
  ], ki.prototype, "selectorIsOpen", 2);
  ki = gv([
    tt("widget-selector")
  ], ki);
  var G2 = Object.getOwnPropertyDescriptor, j2 = (r, e, t, i) => {
    for (var o = i > 1 ? void 0 : i ? G2(e, t) : e, a = r.length - 1, l; a >= 0; a--)
      (l = r[a]) && (o = l(o) || o);
    return o;
  };
  let Hd = class extends Re {
    constructor() {
      super();
    }
    firstUpdated(r) {
      super.firstUpdated(r);
    }
    updated(r) {
      super.updated(r), r.has("apiContext") && this.apiContext;
    }
    renderSelectors() {
      return S`
            <widget-selector .apiContext="${this.apiContext}"></widget-selector>
            <date-selector .apiContext="${this.apiContext}"></date-selector>
            <context-selector .apiContext="${this.apiContext}"></context-selector>
            <team-selector .apiContext="${this.apiContext}"></team-selector>
        `;
    }
    apiRender() {
      return this.renderSelectors();
    }
    // onAfterEnter(location: any, commands: any, router: any) {
    //     console.log("OnAfterEnter", location, commands, router);
    //     // this._installSyncEvents();
    // }
  };
  Hd.styles = Ue(iA);
  Hd = j2([
    tt("selection-frame")
  ], Hd);
  const Z2 = ".col-bg-body-lighter{background-color:var(--col-bg-body-lighter)}.col-bg-body{background-color:var(--col-bg-body)}.col-bg-body-darker{background-color:var(--col-bg-body-darker)}.col-bg-1-lighter{background-color:var(--col-bg-1-lighter)}.col-bg-1{background-color:var(--col-bg-1)}.col-bg-1-darker{background-color:var(--col-bg-1-darker)}.col-bg-1-input{background-color:var(--col-bg-1-input)}.col-primary-bg-1{background-color:var(--col-primary-bg-1)}.col-accent-bg-1{background-color:var(--col-accent-bg-1)}.col-success-bg-1{background-color:var(--col-success-bg-1)}.col-warning-bg-1{background-color:var(--col-warning-bg-1)}.col-error-bg-1{background-color:var(--col-error-bg-1)}.col-bg-2-lighter{background-color:var(--col-bg-2-lighter)}.col-bg-2{background-color:var(--col-bg-2)}.col-bg-2-darker{background-color:var(--col-bg-2-darker)}.col-bg-2-button{background-color:var(--col-bg-2-button)}.col-bg-2-input{background-color:var(--col-bg-2-input)}.col-primary-bg-2{background-color:var(--col-primary-bg-2)}.col-accent-bg-2{background-color:var(--col-accent-bg-2)}.col-success-bg-2{background-color:var(--col-success-bg-2)}.col-warning-bg-2{background-color:var(--col-warning-bg-2)}.col-error-bg-2{background-color:var(--col-error-bg-2)}.col-bg-3-lighter{background-color:var(--col-bg-3-lighter)}.col-bg-3{background-color:var(--col-bg-3)}.col-bg-3-darker{background-color:var(--col-bg-3-darker)}.col-bg-3-button{background-color:var(--col-bg-3-button)}.col-bg-3-input{background-color:var(--col-bg-3-input)}.col-primary-bg-3{background-color:var(--col-primary-bg-3)}.col-accent-bg-3{background-color:var(--col-accent-bg-3)}.col-success-bg-3{background-color:var(--col-success-bg-3)}.col-warning-bg-3{background-color:var(--col-warning-bg-3)}.col-error-bg-3{background-color:var(--col-error-bg-3)}.col-bg-ack-lighter{background-color:var(--col-bg-ack-lighter)}.col-bg-ack{background-color:var(--col-bg-ack)}.col-bg-ack-darker{background-color:var(--col-bg-ack-darker)}.col-primary-bg-ack{background-color:var(--col-primary-bg-ack)}.col-accent-bg-ack{background-color:var(--col-accent-bg-ack)}.col-bg-att-lighter{background-color:var(--col-bg-att-lighter)}.col-bg-att{background-color:var(--col-bg-att)}.col-bg-att-darker{background-color:var(--col-bg-att-darker)}.col-primary-bg-att{background-color:var(--col-primary-bg-att)}.col-accent-bg-att{background-color:var(--col-accent-bg-att)}.col-bg-alert-lighter{background-color:var(--col-bg-alert-lighter)}.col-bg-alert{background-color:var(--col-bg-alert)}.col-bg-alert-darker{background-color:var(--col-bg-alert-darker)}.col-primary-bg-alert{background-color:var(--col-primary-bg-alert)}.col-accent-bg-alert{background-color:var(--col-accent-bg-alert)}.col-bg-btn-lighter{background-color:var(--col-bg-btn-lighter)}.col-bg-btn{background-color:var(--col-bg-btn)}.col-bg-btn-darker{background-color:var(--col-bg-btn-darker)}.col-primary-bg-btn{background-color:var(--col-primary-bg-btn)}.col-accent-bg-btn{background-color:var(--col-accent-bg-btn)}.pattern-diagonal-stripes-sm{background:repeating-linear-gradient(45deg,transparent,transparent 10px,currentColor 10px,currentColor 20px)}.pattern-dots-lg{background-image:radial-gradient(currentColor 1.5px,transparent 1.5px);background-size:15px 15px}.pattern-dots-md{background-image:radial-gradient(currentColor 1px,transparent 1px);background-size:8px 8px}.pattern-dots-medium-dense{background-image:radial-gradient(currentColor .5px,transparent .5px);background-size:3px 3px}.pattern-dots-sm{background-image:radial-gradient(currentColor .5px,transparent .5px);background-size:5px 5px}.pattern-cross-dots-md,.imagelist-background{background-image:radial-gradient(currentColor .7px,transparent 1px),radial-gradient(currentColor .7px,transparent 1px);background-size:6.5px 6.5px;background-position:0 0,3.5px 3.5px}.imagelist-background{background-color:#fff9;background-blend-mode:overlay}p,div{padding:0;margin:0;border:0px;user-select:text;-webkit-user-select:text}select{user-select:none;-webkit-user-select:none}div,p{font-family:var(--standard-text-font)}:host{display:flex;flex-direction:row;flex-wrap:wrap;justify-content:space-evenly;align-items:flex-start;padding-top:1em;width:100%;min-height:200px;box-sizing:border-box}@media only screen and (max-width : 800px){:host{justify-content:left}:host>*{margin-right:1em}}locus-widget,file-widget,narrative-widget,cm-widget,feature-widget{margin-bottom:1em}unit-info-widget,deletion-info-widget{width:100%;margin-bottom:1em}", K2 = '.col-bg-body-lighter{background-color:var(--col-bg-body-lighter)}.col-bg-body{background-color:var(--col-bg-body)}.col-bg-body-darker{background-color:var(--col-bg-body-darker)}.col-bg-1-lighter{background-color:var(--col-bg-1-lighter)}.col-bg-1{background-color:var(--col-bg-1)}.col-bg-1-darker{background-color:var(--col-bg-1-darker)}.col-bg-1-input{background-color:var(--col-bg-1-input)}.col-primary-bg-1{background-color:var(--col-primary-bg-1)}.col-accent-bg-1{background-color:var(--col-accent-bg-1)}.col-success-bg-1{background-color:var(--col-success-bg-1)}.col-warning-bg-1{background-color:var(--col-warning-bg-1)}.col-error-bg-1{background-color:var(--col-error-bg-1)}.col-bg-2-lighter{background-color:var(--col-bg-2-lighter)}.col-bg-2{background-color:var(--col-bg-2)}.col-bg-2-darker{background-color:var(--col-bg-2-darker)}.col-bg-2-button{background-color:var(--col-bg-2-button)}.col-bg-2-input{background-color:var(--col-bg-2-input)}.col-primary-bg-2{background-color:var(--col-primary-bg-2)}.col-accent-bg-2{background-color:var(--col-accent-bg-2)}.col-success-bg-2{background-color:var(--col-success-bg-2)}.col-warning-bg-2{background-color:var(--col-warning-bg-2)}.col-error-bg-2{background-color:var(--col-error-bg-2)}.col-bg-3-lighter{background-color:var(--col-bg-3-lighter)}.col-bg-3{background-color:var(--col-bg-3)}.col-bg-3-darker{background-color:var(--col-bg-3-darker)}.col-bg-3-button{background-color:var(--col-bg-3-button)}.col-bg-3-input{background-color:var(--col-bg-3-input)}.col-primary-bg-3{background-color:var(--col-primary-bg-3)}.col-accent-bg-3{background-color:var(--col-accent-bg-3)}.col-success-bg-3{background-color:var(--col-success-bg-3)}.col-warning-bg-3{background-color:var(--col-warning-bg-3)}.col-error-bg-3{background-color:var(--col-error-bg-3)}.col-bg-ack-lighter{background-color:var(--col-bg-ack-lighter)}.col-bg-ack{background-color:var(--col-bg-ack)}.col-bg-ack-darker{background-color:var(--col-bg-ack-darker)}.col-primary-bg-ack{background-color:var(--col-primary-bg-ack)}.col-accent-bg-ack{background-color:var(--col-accent-bg-ack)}.col-bg-att-lighter{background-color:var(--col-bg-att-lighter)}.col-bg-att{background-color:var(--col-bg-att)}.col-bg-att-darker{background-color:var(--col-bg-att-darker)}.col-primary-bg-att{background-color:var(--col-primary-bg-att)}.col-accent-bg-att{background-color:var(--col-accent-bg-att)}.col-bg-alert-lighter{background-color:var(--col-bg-alert-lighter)}.col-bg-alert{background-color:var(--col-bg-alert)}.col-bg-alert-darker{background-color:var(--col-bg-alert-darker)}.col-primary-bg-alert{background-color:var(--col-primary-bg-alert)}.col-accent-bg-alert{background-color:var(--col-accent-bg-alert)}.col-bg-btn-lighter{background-color:var(--col-bg-btn-lighter)}.col-bg-btn{background-color:var(--col-bg-btn)}.col-bg-btn-darker{background-color:var(--col-bg-btn-darker)}.col-primary-bg-btn{background-color:var(--col-primary-bg-btn)}.col-accent-bg-btn{background-color:var(--col-accent-bg-btn)}.pattern-diagonal-stripes-sm{background:repeating-linear-gradient(45deg,transparent,transparent 10px,currentColor 10px,currentColor 20px)}.pattern-dots-lg{background-image:radial-gradient(currentColor 1.5px,transparent 1.5px);background-size:15px 15px}.pattern-dots-md{background-image:radial-gradient(currentColor 1px,transparent 1px);background-size:8px 8px}.pattern-dots-medium-dense{background-image:radial-gradient(currentColor .5px,transparent .5px);background-size:3px 3px}.pattern-dots-sm{background-image:radial-gradient(currentColor .5px,transparent .5px);background-size:5px 5px}.pattern-cross-dots-md,.imagelist-background{background-image:radial-gradient(currentColor .7px,transparent 1px),radial-gradient(currentColor .7px,transparent 1px);background-size:6.5px 6.5px;background-position:0 0,3.5px 3.5px}.imagelist-background{background-color:#fff9;background-blend-mode:overlay}p,div{padding:0;margin:0;border:0px;user-select:text;-webkit-user-select:text}select{user-select:none;-webkit-user-select:none}.fa,.fas{font-family:"Font Awesome 5 Free";font-weight:900;font-style:normal}.fa-trash:before{content:""}.fa-view-grid:before{content:""}.fa-view-list:before{content:""}.fa-camera:before{content:""}.fa-view-image:before{content:""}.fa-check:before{content:""}.fa-exclamation-circle:before{content:""}.fa-list-check:before{content:""}.fa-backward:before{content:""}.fa-forward:before{content:""}.fa-backward-fast:before{content:""}.fa-forward-fast:before{content:""}.list-header{position:sticky;z-index:1;top:0}:host{max-height:45vh;background-color:var(--col-bg-body);display:block;border:solid 2px var(--col-bg-1-darker)}div,p{font-family:var(--standard-text-font)}.unit-list{display:grid;overflow-y:scroll;height:100%;max-height:calc(45vh - 2em);grid-row-gap:5px;grid-template-rows:[header] auto;grid-template-columns:repeat(6,auto);border-top:solid var(--col-bg-1-darker) 2px}.unit-list div{padding-right:1em}.list-header{background-color:var(--col-bg-1-lighter);color:var(--col-primary-bg-1);font-weight:700;padding-top:1em;border-bottom:solid var(--col-bg-1-darker) 1px}.list-identifier{cursor:pointer;text-decoration:underline}.headline{background-color:var(--col-bg-1-lighter);color:var(--col-primary-bg-1);padding:2px;font-weight:700}.controls{display:flex;flex-direction:row;background-color:var(--col-bg-1-lighter);color:var(--col-primary-bg-1);padding:2px;font-weight:700;justify-content:space-between}.no-data{padding:2px}#sort-type-selector{padding-right:1em}.center-col{display:flex;justify-content:center}';
  var J2 = Object.getOwnPropertyDescriptor, X2 = Object.getPrototypeOf, Q2 = Reflect.get, eP = (r, e, t, i) => {
    for (var o = i > 1 ? void 0 : i ? J2(e, t) : e, a = r.length - 1, l; a >= 0; a--)
      (l = r[a]) && (o = l(o) || o);
    return o;
  }, tP = (r, e, t) => Q2(X2(r), t, e);
  class rP {
  }
  let bo = class extends Re {
    constructor() {
      super(), this.selected_date = null, this.selected_context = "", this.selected_context_uid = "", this.units = [], this.fetching = !1, this.fetch_error = "", this.unitCount = 0, this.term_for_unit = "unit", this.term_for_supervisor = "supervisor", this.selected_sort = "identifier", this.sort_by = {
        identifier: ["identifier", "modified"],
        creation: ["created", "identifier"]
      };
    }
    get_conditions(r) {
      return ` identifier = '${r}'`;
    }
    fetch_data() {
      this.fetching = !0;
      const r = `
            primary_identifier, identifier, id_site, id_excavator, purpose, created, unit_creation_date, modified_by, modified_date, type, method 
            from {base} where ${this.get_conditions(this.selected_context)}  
        `, e = {
        cql: {
          base: {
            scope: {
              unit: {}
            },
            target: {
              field_or_instruction: "modified_ww()"
            },
            additional_fields: {
              modified_date: {
                field_or_instruction: "modified_ww()",
                default: "",
                format: "datetime(date)"
              },
              modified_by: {
                field_or_instruction: "replfield_modified_by()",
                default: ""
              },
              modified_timestamp: {
                field_or_instruction: "modified_ww()",
                default: ""
              },
              created: {
                field_or_instruction: "replfield_created()",
                default: "null",
                format: "datetime(date)"
              },
              type: {
                field_or_instruction: "type",
                default: "null"
              },
              method: {
                field_or_instruction: "method",
                default: "null"
              },
              purpose: {
                field_or_instruction: "purpose",
                default: "null"
              },
              unit_creation_date: {
                field_or_instruction: "unit_creation_date",
                default: "null"
              },
              id_site: {
                field_or_instruction: "id_site",
                default: "null"
              },
              id_excavator: {
                field_or_instruction: "id_excavator",
                default: "null"
              }
            }
          },
          meta: {
            version: 0.1
          },
          query: {
            type: "DirectSqlQuery",
            sql: r
          }
        }
      };
      this.apiContext.fetchFromApi(
        "",
        "cql/query",
        {
          method: "POST",
          caller: "unit-info-widget.fetch_data",
          body: JSON.stringify(e)
        }
      ).then((t) => {
        t.result_msg !== "ok" ? this.fetch_error = t.result_msg : (this.fetch_error = "", this.load_records(t.records)), this.fetching = !1;
      }).catch((t) => {
        dt(this, t, "unit-info-widget.fetch_data", null);
      });
    }
    load_records(r) {
      this.units = [];
      let e = {};
      r.forEach((t) => {
        const i = t.primary_identifier;
        let o;
        i in e ? o = e[i] : (o = new rP(), e[i] = o, this.units.push(o), o.id_excavator = "", o.purpose = "", o.id_site = "?", o.method = "?", o.type = "?", o.modified = 0, o.created = 0, o.unit_creation = "?"), o.identifier = t.primary_identifier, t.modified > o.modified && (o.modified = t.modified), t.unit_creation_date && (o.unit_creation = xr(t.unit_creation_date).toLocaleDateString()), t.type && (o.type = t.type), t.method && (o.method = t.method), t.id_site && (o.id_site = t.id_site), t.id_excavator && (o.id_excavator = t.id_excavator), t.purpose && (o.purpose = t.purpose), t.created && (o.created = xr(t.created).getTime());
      }), this.unitCount = Object.keys(this.units).length;
    }
    // sort_records(sort_by: Array<string>) {
    //     function _sort(a: UnitRecord, b: UnitRecord): number {
    //         for (let i = 0; i < sort_by.length; i++) {
    //             let attrib: string = sort_by[i];
    //             let value_a = a[attrib as keyof UnitRecord]
    //             let value_b = b[attrib as keyof UnitRecord]
    //             let result: number = 0
    //
    //             if (typeof (value_a) === "string") {
    //                 result = (<string>value_a).localeCompare((<string>value_b))
    //             } else {
    //                 if (value_a < value_b) result = -1
    //                 if (value_a > value_b) result = 1
    //             }
    //
    //             if (result != 0)
    //                 return result
    //         }
    //         return 0
    //     }
    //     // console.log(`sorting loci by ${this.sort_by[this.selected_sort]}`)
    //     this.units.sort(_sort)
    //     this.requestUpdate();
    // }
    // protected changeContext(context: string) {
    //     store.dispatch(setSelector("contextSelector", {"selectedContext": context}))
    // }
    stateChanged(r) {
      if (this.fetch_error)
        return S`Error fetching: ${this.fetch_error}`;
      if (r.initState == 0)
        return;
      let e = !1;
      if (r.selectors.hasOwnProperty("contextSelector")) {
        let t = r.selectors.contextSelector.selectedContext;
        t !== this.selected_context && (this.selected_context = t, this.selected_context_uid = r.selectors.contextSelector.selectedUid, e = !0);
      }
      e && this.fetch_data(), r.constants.length > 0 && (this.term_for_unit = Ye(
        r.constants,
        "label_for_unit_on_start_page",
        !1,
        this.term_for_unit
      ).replace("\r", " or "), this.term_for_supervisor = Ye(
        r.constants,
        "label_supervisor",
        !1,
        this.term_for_supervisor
      ));
    }
    get_unit_term() {
      return this.term_for_unit;
    }
    apiRender() {
      return S`
            <div class="unit-info-widget">
                <div class="headline">
                    ${this.selected_context ? void 0 : S`<p>Please select a ${this.get_unit_term()} to see its information</p>`}
                    ${this.unitCount == 1 ? S`<p>information for ${this.units[0].identifier}</p>` : void 0}
                </div>            
                ${this.unitCount == 1 ? this.render_widget() : S`<p></p>`}
            </div>`;
    }
    render_widget() {
      return this.fetching ? S`fetching data ...` : this.unitCount == 0 ? S`
                    <div class="no-loci">
                        <p>No data found for your selection</p>
                    </div>` : S`
                <div class="unit-list">
                    <div class="list-header">site</div>
                    <div class="list-header">creation</div>
                    <div class="list-header">type</div>
                    <div class="list-header">method</div>
                    <div class="list-header">${this.term_for_supervisor}</div>
                    <div class="list-header">purpose</div>
                    ${this.units.map(
        (r) => S`
                        <div>${r.id_site}</div>
                        <div>${r.unit_creation}</div>
                        <div>${r.type}</div>
                        <div>${r.method}</div>
                        <div>${r.id_excavator}</div>
                        <div>${r.purpose}</div>`
      )}
                </div>`;
    }
  };
  bo.styles = Ue(K2);
  bo.properties = {
    ...tP(bo, bo, "properties"),
    selected_context: { type: String },
    selected_date: { type: Date },
    fetching: { type: Boolean },
    sort_by: { type: Array },
    term_for_unit: { type: String },
    term_for_supervisor: { type: String }
  };
  bo = eP([
    tt("unit-info-widget")
  ], bo);
  const iP = ".col-bg-body-lighter{background-color:var(--col-bg-body-lighter)}.col-bg-body{background-color:var(--col-bg-body)}.col-bg-body-darker{background-color:var(--col-bg-body-darker)}.col-bg-1-lighter{background-color:var(--col-bg-1-lighter)}.col-bg-1{background-color:var(--col-bg-1)}.col-bg-1-darker{background-color:var(--col-bg-1-darker)}.col-bg-1-input{background-color:var(--col-bg-1-input)}.col-primary-bg-1{background-color:var(--col-primary-bg-1)}.col-accent-bg-1{background-color:var(--col-accent-bg-1)}.col-success-bg-1{background-color:var(--col-success-bg-1)}.col-warning-bg-1{background-color:var(--col-warning-bg-1)}.col-error-bg-1{background-color:var(--col-error-bg-1)}.col-bg-2-lighter{background-color:var(--col-bg-2-lighter)}.col-bg-2{background-color:var(--col-bg-2)}.col-bg-2-darker{background-color:var(--col-bg-2-darker)}.col-bg-2-button{background-color:var(--col-bg-2-button)}.col-bg-2-input{background-color:var(--col-bg-2-input)}.col-primary-bg-2{background-color:var(--col-primary-bg-2)}.col-accent-bg-2{background-color:var(--col-accent-bg-2)}.col-success-bg-2{background-color:var(--col-success-bg-2)}.col-warning-bg-2{background-color:var(--col-warning-bg-2)}.col-error-bg-2{background-color:var(--col-error-bg-2)}.col-bg-3-lighter{background-color:var(--col-bg-3-lighter)}.col-bg-3{background-color:var(--col-bg-3)}.col-bg-3-darker{background-color:var(--col-bg-3-darker)}.col-bg-3-button{background-color:var(--col-bg-3-button)}.col-bg-3-input{background-color:var(--col-bg-3-input)}.col-primary-bg-3{background-color:var(--col-primary-bg-3)}.col-accent-bg-3{background-color:var(--col-accent-bg-3)}.col-success-bg-3{background-color:var(--col-success-bg-3)}.col-warning-bg-3{background-color:var(--col-warning-bg-3)}.col-error-bg-3{background-color:var(--col-error-bg-3)}.col-bg-ack-lighter{background-color:var(--col-bg-ack-lighter)}.col-bg-ack{background-color:var(--col-bg-ack)}.col-bg-ack-darker{background-color:var(--col-bg-ack-darker)}.col-primary-bg-ack{background-color:var(--col-primary-bg-ack)}.col-accent-bg-ack{background-color:var(--col-accent-bg-ack)}.col-bg-att-lighter{background-color:var(--col-bg-att-lighter)}.col-bg-att{background-color:var(--col-bg-att)}.col-bg-att-darker{background-color:var(--col-bg-att-darker)}.col-primary-bg-att{background-color:var(--col-primary-bg-att)}.col-accent-bg-att{background-color:var(--col-accent-bg-att)}.col-bg-alert-lighter{background-color:var(--col-bg-alert-lighter)}.col-bg-alert{background-color:var(--col-bg-alert)}.col-bg-alert-darker{background-color:var(--col-bg-alert-darker)}.col-primary-bg-alert{background-color:var(--col-primary-bg-alert)}.col-accent-bg-alert{background-color:var(--col-accent-bg-alert)}.col-bg-btn-lighter{background-color:var(--col-bg-btn-lighter)}.col-bg-btn{background-color:var(--col-bg-btn)}.col-bg-btn-darker{background-color:var(--col-bg-btn-darker)}.col-primary-bg-btn{background-color:var(--col-primary-bg-btn)}.col-accent-bg-btn{background-color:var(--col-accent-bg-btn)}.pattern-diagonal-stripes-sm{background:repeating-linear-gradient(45deg,transparent,transparent 10px,currentColor 10px,currentColor 20px)}.pattern-dots-lg{background-image:radial-gradient(currentColor 1.5px,transparent 1.5px);background-size:15px 15px}.pattern-dots-md{background-image:radial-gradient(currentColor 1px,transparent 1px);background-size:8px 8px}.pattern-dots-medium-dense{background-image:radial-gradient(currentColor .5px,transparent .5px);background-size:3px 3px}.pattern-dots-sm{background-image:radial-gradient(currentColor .5px,transparent .5px);background-size:5px 5px}.pattern-cross-dots-md,.imagelist-background{background-image:radial-gradient(currentColor .7px,transparent 1px),radial-gradient(currentColor .7px,transparent 1px);background-size:6.5px 6.5px;background-position:0 0,3.5px 3.5px}.imagelist-background{background-color:#fff9;background-blend-mode:overlay}p,div{padding:0;margin:0;border:0px;user-select:text;-webkit-user-select:text}select{user-select:none;-webkit-user-select:none}:host{max-width:45vw;background-color:var(--col-bg-body);display:block;border:solid 2px var(--col-bg-1-darker);overflow-y:hidden;padding-bottom:.5em}div,p{font-family:var(--standard-text-font)}.narrative-list{overflow-y:scroll;height:100%;width:100%;max-height:35vh}.headline{background-color:var(--col-bg-1-lighter);color:var(--col-primary-bg-1);padding:2px;font-weight:700}.controls{display:flex;flex-direction:row;background-color:var(--col-bg-1-lighter);color:var(--col-primary-bg-1);padding:2px;font-weight:700;justify-content:space-between}.no-narratives{padding:2px}.narrative{font-family:var(--standard-text-font);padding:.2em;border-bottom:var(--col-bg-1-darker) 2px solid}.narrative-headline{display:flex;flex-direction:row;justify-content:space-between;font-weight:700}";
  var oP = Object.getOwnPropertyDescriptor, nP = Object.getPrototypeOf, sP = Reflect.get, aP = (r, e, t, i) => {
    for (var o = i > 1 ? void 0 : i ? oP(e, t) : e, a = r.length - 1, l; a >= 0; a--)
      (l = r[a]) && (o = l(o) || o);
    return o;
  }, lP = (r, e, t) => sP(nP(r), t, e);
  class cP {
  }
  let _o = class extends Re {
    constructor() {
      super(), this.selected_date = null, this.selected_context = "", this.selected_member = "", this.narratives = [], this.fetching = !1, this.fetch_error = "", this.record_types = /* @__PURE__ */ new Set(), this.show_record_types = "", this.record_type_names = null, this.sort_by = ["domain_identifier", "identifier", "modified"], this.record_count = 0, this.page_size = 0;
    }
    get_conditions(r, e, t) {
      if (e || t) {
        let i = [`equals(modified_date, ${r})`];
        return e && i.push(`equals(domain_identifier, '${e}')`), t && i.push(`equals(modified_by, '${t}')`), {
          AND: i
        };
      } else
        return {
          "?": `equals(modified_date, ${r})`
        };
    }
    fetch_data() {
      this.fetching = !0;
      const r = Zr(this.selected_date);
      this.apiContext.fetchFromApi(
        "",
        "cql/query",
        {
          method: "POST",
          caller: "narrativewidget.fetch_data",
          body: JSON.stringify(
            {
              cql: {
                base: {
                  scope: {
                    site: {
                      site_notes: {
                        join: "inner(uid, uid_site)"
                      }
                    },
                    unit: {
                      unit_narrative: {
                        join: "inner(uid, uid_unit)"
                      },
                      locus: {
                        collected_material: {}
                      }
                    }
                  },
                  target: {
                    field_or_instruction: "record_description()"
                  },
                  additional_fields: {
                    modified_date: {
                      field_or_instruction: "modified_ww()",
                      default: "",
                      format: "datetime(date)"
                    },
                    modified_by: {
                      field_or_instruction: "replfield_modified_by()",
                      default: ""
                    },
                    modified_timestamp: {
                      field_or_instruction: "modified_ww",
                      default: ""
                    },
                    id_excavator: {
                      field_or_instruction: "replfield_modified_by()",
                      default: ""
                    }
                  }
                },
                meta: {
                  version: 0.1
                },
                query: {
                  columns: {
                    domain_identifier: {
                      source_field: "identifier"
                    },
                    identifier: {
                      source_field: "primary_identifier"
                    },
                    modified_date: {
                      source_field: "modified_date"
                    },
                    modified_timestamp: {
                      source_field: "modified_timestamp"
                    },
                    modified_by: {
                      source_field: "id_excavator"
                    },
                    record_type: {
                      source_field: "record_type"
                    },
                    narrative: {
                      source_field: "data"
                    }
                  },
                  conditions: this.get_conditions(r, this.selected_context, this.selected_member),
                  distinct: "True",
                  type: "Raw"
                }
              }
            }
          )
        },
        "v1"
      ).then((e) => {
        e.result_msg !== "ok" ? this.fetch_error = e.result_msg : (this.fetch_error = "", this.record_count = e.overall_record_count, this.page_size = e.page_size, this.load_narratives(e.records)), this.fetching = !1;
      }).catch((e) => {
        dt(this, e, "narrativeWidget.fetch_data", null);
      });
    }
    load_narratives(r) {
      this.narratives = [], r.forEach((e) => {
        let t = new cP();
        t.identifier = e.identifier, t.domain_identifier = e.domain_identifier, t.modified_by = e.modified_by ? e.modified_by : "?", t.modified = z.fromISO(e.modified_timestamp).toJSDate(), t.narrative = e.narrative, t.record_type = e.record_type, this.record_types.add(t.record_type), this.narratives.push(t);
      }), this.sort_records(this.sort_by);
    }
    sort_records(r) {
      function e(t, i) {
        for (let o = 0; o < r.length; o++) {
          let a = r[o], l = t[a], d = i[a], u = 0;
          if (typeof l == "string" ? u = l.localeCompare(d) : (l < d && (u = -1), l > d && (u = 1)), u != 0)
            return u;
        }
        return 0;
      }
      this.narratives.sort(e), this.requestUpdate();
    }
    // protected changeContext(context: string) {
    //     store.dispatch(setSelector("contextSelector", {"selectedContext": context}))
    // }
    stateChanged(r) {
      if (this.fetch_error)
        return S`Error fetching: ${this.fetch_error}`;
      if (r.initState == 0)
        return;
      let e = !1;
      if ("dateSelector" in r.selectors) {
        let t = r.selectors.dateSelector.selectedDate;
        if ((!this.selected_date || t.getTime() !== this.selected_date.getTime()) && (this.selected_date = t, e = !0), "contextSelector" in r.selectors) {
          let i = r.selectors.contextSelector.selectedContext;
          i !== this.selected_context && (this.selected_context = i, e = !0);
        }
        if ("teamSelector" in r.selectors) {
          let i = r.selectors.teamSelector.selectedMember;
          i !== this.selected_member && (this.selected_member = i, e = !0);
        }
        e && this.fetch_data();
      }
      r.constants.length > 0 && !this.record_type_names && (this.record_type_names = La(r.constants), e || this.requestUpdate());
    }
    apiRender() {
      const r = this.narratives.filter((e) => this.show_record_types === "" || e.record_type === this.show_record_types).length;
      return S`
                    <div class="narrative-widget">
                        <div class="headline">
                            <p>${r} ${this.record_count ? " of " + this.record_count : void 0} Narrative(s)</p>
                        </div>
                        <div class="controls">
                            <div class="controls-left">
                                ${this.renderRecordTypeSelector()}
                            </div>
                        </div>
                        ${this.selected_date !== null ? this.render_widget() : S`Please select a date`}
                    </div>`;
    }
    renderRecordTypeSelector() {
      if (!this.selected_date)
        return S``;
      let r = Array.from(this.record_types);
      r.push(" all"), r.sort();
      let e = this.show_record_types == "" ? " all" : this.show_record_types;
      return S`
            <label for="record-type-selector">record type</label>
            <select name="record-type-selector" id="record-type-selector" @change="${this.recordTypeChanged}">
                ${r.map(
        (t) => S`
                            <option value="${t}"
                                    ?selected="${e === t}">
                                ${_a(this.record_type_names, t)}
                            </option>
                        `
      )}
            </select>
        `;
    }
    recordTypeChanged(r) {
      const e = r.currentTarget.value;
      e === " all" ? this.show_record_types = "" : this.show_record_types = e;
    }
    render_widget() {
      return this.selected_date ? this.fetching ? S`fetching data ...` : this.narratives.length == 0 ? S`
                    <div class="no-narratives">
                        <p>No narratives found for your selection</p>
                    </div>` : S`
                <div class="narrative-list">
                    ${this.narratives.map(
        (r) => S`${this.show_record_types === "" || r.record_type === this.show_record_types ? S`
                                        <div class="narrative">
                                            ${this.show_record_types === "" ? S`
                                                        <div class="narrative-headline">
                                                            <p>
                                                                ${_a(this.record_type_names, r.record_type)}</p>
                                                        </div>` : void 0}
                                            <div class="narrative-headline">
                                                <p>
                                                    ${this.selected_context ? void 0 : S`${r.domain_identifier}/`}
                                                    ${r.identifier}</p>
                                                <p>by: ${r.modified_by}
                                                        (${r.modified.toLocaleTimeString(
          [],
          { hour: "2-digit", minute: "2-digit" }
        )})</p>
                                            </div>
                                            <div class="narrative-body">
                                                ${r.narrative}
                                            </div>
                                        </div>` : void 0}`
      )}
                </div>` : S`please select a date`;
    }
  };
  _o.styles = Ue(iP);
  _o.properties = {
    ...lP(_o, _o, "properties"),
    selected_context: { type: String },
    selected_date: { type: Date },
    selected_member: { type: String },
    fetching: { type: Boolean },
    sort_by: { type: Array },
    show_record_types: { type: String }
  };
  _o = aP([
    tt("narrative-widget")
  ], _o);
  var lt = "top", Ft = "bottom", zt = "right", ct = "left", Ou = "auto", rs = [lt, Ft, zt, ct], Lo = "start", jn = "end", dP = "clippingParents", mv = "viewport", _n = "popper", uP = "reference", _m = /* @__PURE__ */ rs.reduce(function(r, e) {
    return r.concat([e + "-" + Lo, e + "-" + jn]);
  }, []), bv = /* @__PURE__ */ [].concat(rs, [Ou]).reduce(function(r, e) {
    return r.concat([e, e + "-" + Lo, e + "-" + jn]);
  }, []), hP = "beforeRead", fP = "read", pP = "afterRead", gP = "beforeMain", mP = "main", bP = "afterMain", _P = "beforeWrite", vP = "write", yP = "afterWrite", wP = [hP, fP, pP, gP, mP, bP, _P, vP, yP];
  function ir(r) {
    return r ? (r.nodeName || "").toLowerCase() : null;
  }
  function Ct(r) {
    if (r == null)
      return window;
    if (r.toString() !== "[object Window]") {
      var e = r.ownerDocument;
      return e && e.defaultView || window;
    }
    return r;
  }
  function $i(r) {
    var e = Ct(r).Element;
    return r instanceof e || r instanceof Element;
  }
  function Rt(r) {
    var e = Ct(r).HTMLElement;
    return r instanceof e || r instanceof HTMLElement;
  }
  function Du(r) {
    if (typeof ShadowRoot > "u")
      return !1;
    var e = Ct(r).ShadowRoot;
    return r instanceof e || r instanceof ShadowRoot;
  }
  function kP(r) {
    var e = r.state;
    Object.keys(e.elements).forEach(function(t) {
      var i = e.styles[t] || {}, o = e.attributes[t] || {}, a = e.elements[t];
      !Rt(a) || !ir(a) || (Object.assign(a.style, i), Object.keys(o).forEach(function(l) {
        var d = o[l];
        d === !1 ? a.removeAttribute(l) : a.setAttribute(l, d === !0 ? "" : d);
      }));
    });
  }
  function xP(r) {
    var e = r.state, t = {
      popper: {
        position: e.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    return Object.assign(e.elements.popper.style, t.popper), e.styles = t, e.elements.arrow && Object.assign(e.elements.arrow.style, t.arrow), function() {
      Object.keys(e.elements).forEach(function(i) {
        var o = e.elements[i], a = e.attributes[i] || {}, l = Object.keys(e.styles.hasOwnProperty(i) ? e.styles[i] : t[i]), d = l.reduce(function(u, f) {
          return u[f] = "", u;
        }, {});
        !Rt(o) || !ir(o) || (Object.assign(o.style, d), Object.keys(a).forEach(function(u) {
          o.removeAttribute(u);
        }));
      });
    };
  }
  const CP = {
    name: "applyStyles",
    enabled: !0,
    phase: "write",
    fn: kP,
    effect: xP,
    requires: ["computeStyles"]
  };
  function rr(r) {
    return r.split("-")[0];
  }
  var xi = Math.max, Ia = Math.min, Ro = Math.round;
  function Ud() {
    var r = navigator.userAgentData;
    return r != null && r.brands && Array.isArray(r.brands) ? r.brands.map(function(e) {
      return e.brand + "/" + e.version;
    }).join(" ") : navigator.userAgent;
  }
  function _v() {
    return !/^((?!chrome|android).)*safari/i.test(Ud());
  }
  function Fo(r, e, t) {
    e === void 0 && (e = !1), t === void 0 && (t = !1);
    var i = r.getBoundingClientRect(), o = 1, a = 1;
    e && Rt(r) && (o = r.offsetWidth > 0 && Ro(i.width) / r.offsetWidth || 1, a = r.offsetHeight > 0 && Ro(i.height) / r.offsetHeight || 1);
    var l = $i(r) ? Ct(r) : window, d = l.visualViewport, u = !_v() && t, f = (i.left + (u && d ? d.offsetLeft : 0)) / o, g = (i.top + (u && d ? d.offsetTop : 0)) / a, _ = i.width / o, C = i.height / a;
    return {
      width: _,
      height: C,
      top: g,
      right: f + _,
      bottom: g + C,
      left: f,
      x: f,
      y: g
    };
  }
  function Pu(r) {
    var e = Fo(r), t = r.offsetWidth, i = r.offsetHeight;
    return Math.abs(e.width - t) <= 1 && (t = e.width), Math.abs(e.height - i) <= 1 && (i = e.height), {
      x: r.offsetLeft,
      y: r.offsetTop,
      width: t,
      height: i
    };
  }
  function vv(r, e) {
    var t = e.getRootNode && e.getRootNode();
    if (r.contains(e))
      return !0;
    if (t && Du(t)) {
      var i = e;
      do {
        if (i && r.isSameNode(i))
          return !0;
        i = i.parentNode || i.host;
      } while (i);
    }
    return !1;
  }
  function Sr(r) {
    return Ct(r).getComputedStyle(r);
  }
  function SP(r) {
    return ["table", "td", "th"].indexOf(ir(r)) >= 0;
  }
  function Xr(r) {
    return (($i(r) ? r.ownerDocument : (
      // $FlowFixMe[prop-missing]
      r.document
    )) || window.document).documentElement;
  }
  function ja(r) {
    return ir(r) === "html" ? r : (
      // this is a quicker (but less type safe) way to save quite some bytes from the bundle
      // $FlowFixMe[incompatible-return]
      // $FlowFixMe[prop-missing]
      r.assignedSlot || // step into the shadow DOM of the parent of a slotted node
      r.parentNode || // DOM Element detected
      (Du(r) ? r.host : null) || // ShadowRoot detected
      // $FlowFixMe[incompatible-call]: HTMLElement is a Node
      Xr(r)
    );
  }
  function vm(r) {
    return !Rt(r) || // https://github.com/popperjs/popper-core/issues/837
    Sr(r).position === "fixed" ? null : r.offsetParent;
  }
  function AP(r) {
    var e = /firefox/i.test(Ud()), t = /Trident/i.test(Ud());
    if (t && Rt(r)) {
      var i = Sr(r);
      if (i.position === "fixed")
        return null;
    }
    var o = ja(r);
    for (Du(o) && (o = o.host); Rt(o) && ["html", "body"].indexOf(ir(o)) < 0; ) {
      var a = Sr(o);
      if (a.transform !== "none" || a.perspective !== "none" || a.contain === "paint" || ["transform", "perspective"].indexOf(a.willChange) !== -1 || e && a.willChange === "filter" || e && a.filter && a.filter !== "none")
        return o;
      o = o.parentNode;
    }
    return null;
  }
  function is(r) {
    for (var e = Ct(r), t = vm(r); t && SP(t) && Sr(t).position === "static"; )
      t = vm(t);
    return t && (ir(t) === "html" || ir(t) === "body" && Sr(t).position === "static") ? e : t || AP(r) || e;
  }
  function Iu(r) {
    return ["top", "bottom"].indexOf(r) >= 0 ? "x" : "y";
  }
  function Tn(r, e, t) {
    return xi(r, Ia(e, t));
  }
  function EP(r, e, t) {
    var i = Tn(r, e, t);
    return i > t ? t : i;
  }
  function yv() {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    };
  }
  function wv(r) {
    return Object.assign({}, yv(), r);
  }
  function kv(r, e) {
    return e.reduce(function(t, i) {
      return t[i] = r, t;
    }, {});
  }
  var $P = function(e, t) {
    return e = typeof e == "function" ? e(Object.assign({}, t.rects, {
      placement: t.placement
    })) : e, wv(typeof e != "number" ? e : kv(e, rs));
  };
  function TP(r) {
    var e, t = r.state, i = r.name, o = r.options, a = t.elements.arrow, l = t.modifiersData.popperOffsets, d = rr(t.placement), u = Iu(d), f = [ct, zt].indexOf(d) >= 0, g = f ? "height" : "width";
    if (!(!a || !l)) {
      var _ = $P(o.padding, t), C = Pu(a), x = u === "y" ? lt : ct, D = u === "y" ? Ft : zt, P = t.rects.reference[g] + t.rects.reference[u] - l[u] - t.rects.popper[g], I = l[u] - t.rects.reference[u], F = is(a), H = F ? u === "y" ? F.clientHeight || 0 : F.clientWidth || 0 : 0, Y = P / 2 - I / 2, W = _[x], G = H - C[g] - _[D], ee = H / 2 - C[g] / 2 + Y, ie = Tn(W, ee, G), be = u;
      t.modifiersData[i] = (e = {}, e[be] = ie, e.centerOffset = ie - ee, e);
    }
  }
  function OP(r) {
    var e = r.state, t = r.options, i = t.element, o = i === void 0 ? "[data-popper-arrow]" : i;
    o != null && (typeof o == "string" && (o = e.elements.popper.querySelector(o), !o) || vv(e.elements.popper, o) && (e.elements.arrow = o));
  }
  const DP = {
    name: "arrow",
    enabled: !0,
    phase: "main",
    fn: TP,
    effect: OP,
    requires: ["popperOffsets"],
    requiresIfExists: ["preventOverflow"]
  };
  function zo(r) {
    return r.split("-")[1];
  }
  var PP = {
    top: "auto",
    right: "auto",
    bottom: "auto",
    left: "auto"
  };
  function IP(r, e) {
    var t = r.x, i = r.y, o = e.devicePixelRatio || 1;
    return {
      x: Ro(t * o) / o || 0,
      y: Ro(i * o) / o || 0
    };
  }
  function ym(r) {
    var e, t = r.popper, i = r.popperRect, o = r.placement, a = r.variation, l = r.offsets, d = r.position, u = r.gpuAcceleration, f = r.adaptive, g = r.roundOffsets, _ = r.isFixed, C = l.x, x = C === void 0 ? 0 : C, D = l.y, P = D === void 0 ? 0 : D, I = typeof g == "function" ? g({
      x,
      y: P
    }) : {
      x,
      y: P
    };
    x = I.x, P = I.y;
    var F = l.hasOwnProperty("x"), H = l.hasOwnProperty("y"), Y = ct, W = lt, G = window;
    if (f) {
      var ee = is(t), ie = "clientHeight", be = "clientWidth";
      if (ee === Ct(t) && (ee = Xr(t), Sr(ee).position !== "static" && d === "absolute" && (ie = "scrollHeight", be = "scrollWidth")), ee = ee, o === lt || (o === ct || o === zt) && a === jn) {
        W = Ft;
        var ue = _ && ee === G && G.visualViewport ? G.visualViewport.height : (
          // $FlowFixMe[prop-missing]
          ee[ie]
        );
        P -= ue - i.height, P *= u ? 1 : -1;
      }
      if (o === ct || (o === lt || o === Ft) && a === jn) {
        Y = zt;
        var he = _ && ee === G && G.visualViewport ? G.visualViewport.width : (
          // $FlowFixMe[prop-missing]
          ee[be]
        );
        x -= he - i.width, x *= u ? 1 : -1;
      }
    }
    var Ee = Object.assign({
      position: d
    }, f && PP), ut = g === !0 ? IP({
      x,
      y: P
    }, Ct(t)) : {
      x,
      y: P
    };
    if (x = ut.x, P = ut.y, u) {
      var Fe;
      return Object.assign({}, Ee, (Fe = {}, Fe[W] = H ? "0" : "", Fe[Y] = F ? "0" : "", Fe.transform = (G.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + P + "px)" : "translate3d(" + x + "px, " + P + "px, 0)", Fe));
    }
    return Object.assign({}, Ee, (e = {}, e[W] = H ? P + "px" : "", e[Y] = F ? x + "px" : "", e.transform = "", e));
  }
  function MP(r) {
    var e = r.state, t = r.options, i = t.gpuAcceleration, o = i === void 0 ? !0 : i, a = t.adaptive, l = a === void 0 ? !0 : a, d = t.roundOffsets, u = d === void 0 ? !0 : d, f = {
      placement: rr(e.placement),
      variation: zo(e.placement),
      popper: e.elements.popper,
      popperRect: e.rects.popper,
      gpuAcceleration: o,
      isFixed: e.options.strategy === "fixed"
    };
    e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, ym(Object.assign({}, f, {
      offsets: e.modifiersData.popperOffsets,
      position: e.options.strategy,
      adaptive: l,
      roundOffsets: u
    })))), e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, ym(Object.assign({}, f, {
      offsets: e.modifiersData.arrow,
      position: "absolute",
      adaptive: !1,
      roundOffsets: u
    })))), e.attributes.popper = Object.assign({}, e.attributes.popper, {
      "data-popper-placement": e.placement
    });
  }
  const NP = {
    name: "computeStyles",
    enabled: !0,
    phase: "beforeWrite",
    fn: MP,
    data: {}
  };
  var na = {
    passive: !0
  };
  function LP(r) {
    var e = r.state, t = r.instance, i = r.options, o = i.scroll, a = o === void 0 ? !0 : o, l = i.resize, d = l === void 0 ? !0 : l, u = Ct(e.elements.popper), f = [].concat(e.scrollParents.reference, e.scrollParents.popper);
    return a && f.forEach(function(g) {
      g.addEventListener("scroll", t.update, na);
    }), d && u.addEventListener("resize", t.update, na), function() {
      a && f.forEach(function(g) {
        g.removeEventListener("scroll", t.update, na);
      }), d && u.removeEventListener("resize", t.update, na);
    };
  }
  const RP = {
    name: "eventListeners",
    enabled: !0,
    phase: "write",
    fn: function() {
    },
    effect: LP,
    data: {}
  };
  var FP = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
  };
  function ga(r) {
    return r.replace(/left|right|bottom|top/g, function(e) {
      return FP[e];
    });
  }
  var zP = {
    start: "end",
    end: "start"
  };
  function wm(r) {
    return r.replace(/start|end/g, function(e) {
      return zP[e];
    });
  }
  function Mu(r) {
    var e = Ct(r), t = e.pageXOffset, i = e.pageYOffset;
    return {
      scrollLeft: t,
      scrollTop: i
    };
  }
  function Nu(r) {
    return Fo(Xr(r)).left + Mu(r).scrollLeft;
  }
  function HP(r, e) {
    var t = Ct(r), i = Xr(r), o = t.visualViewport, a = i.clientWidth, l = i.clientHeight, d = 0, u = 0;
    if (o) {
      a = o.width, l = o.height;
      var f = _v();
      (f || !f && e === "fixed") && (d = o.offsetLeft, u = o.offsetTop);
    }
    return {
      width: a,
      height: l,
      x: d + Nu(r),
      y: u
    };
  }
  function UP(r) {
    var e, t = Xr(r), i = Mu(r), o = (e = r.ownerDocument) == null ? void 0 : e.body, a = xi(t.scrollWidth, t.clientWidth, o ? o.scrollWidth : 0, o ? o.clientWidth : 0), l = xi(t.scrollHeight, t.clientHeight, o ? o.scrollHeight : 0, o ? o.clientHeight : 0), d = -i.scrollLeft + Nu(r), u = -i.scrollTop;
    return Sr(o || t).direction === "rtl" && (d += xi(t.clientWidth, o ? o.clientWidth : 0) - a), {
      width: a,
      height: l,
      x: d,
      y: u
    };
  }
  function Lu(r) {
    var e = Sr(r), t = e.overflow, i = e.overflowX, o = e.overflowY;
    return /auto|scroll|overlay|hidden/.test(t + o + i);
  }
  function xv(r) {
    return ["html", "body", "#document"].indexOf(ir(r)) >= 0 ? r.ownerDocument.body : Rt(r) && Lu(r) ? r : xv(ja(r));
  }
  function On(r, e) {
    var t;
    e === void 0 && (e = []);
    var i = xv(r), o = i === ((t = r.ownerDocument) == null ? void 0 : t.body), a = Ct(i), l = o ? [a].concat(a.visualViewport || [], Lu(i) ? i : []) : i, d = e.concat(l);
    return o ? d : (
      // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
      d.concat(On(ja(l)))
    );
  }
  function Wd(r) {
    return Object.assign({}, r, {
      left: r.x,
      top: r.y,
      right: r.x + r.width,
      bottom: r.y + r.height
    });
  }
  function WP(r, e) {
    var t = Fo(r, !1, e === "fixed");
    return t.top = t.top + r.clientTop, t.left = t.left + r.clientLeft, t.bottom = t.top + r.clientHeight, t.right = t.left + r.clientWidth, t.width = r.clientWidth, t.height = r.clientHeight, t.x = t.left, t.y = t.top, t;
  }
  function km(r, e, t) {
    return e === mv ? Wd(HP(r, t)) : $i(e) ? WP(e, t) : Wd(UP(Xr(r)));
  }
  function BP(r) {
    var e = On(ja(r)), t = ["absolute", "fixed"].indexOf(Sr(r).position) >= 0, i = t && Rt(r) ? is(r) : r;
    return $i(i) ? e.filter(function(o) {
      return $i(o) && vv(o, i) && ir(o) !== "body";
    }) : [];
  }
  function VP(r, e, t, i) {
    var o = e === "clippingParents" ? BP(r) : [].concat(e), a = [].concat(o, [t]), l = a[0], d = a.reduce(function(u, f) {
      var g = km(r, f, i);
      return u.top = xi(g.top, u.top), u.right = Ia(g.right, u.right), u.bottom = Ia(g.bottom, u.bottom), u.left = xi(g.left, u.left), u;
    }, km(r, l, i));
    return d.width = d.right - d.left, d.height = d.bottom - d.top, d.x = d.left, d.y = d.top, d;
  }
  function Cv(r) {
    var e = r.reference, t = r.element, i = r.placement, o = i ? rr(i) : null, a = i ? zo(i) : null, l = e.x + e.width / 2 - t.width / 2, d = e.y + e.height / 2 - t.height / 2, u;
    switch (o) {
      case lt:
        u = {
          x: l,
          y: e.y - t.height
        };
        break;
      case Ft:
        u = {
          x: l,
          y: e.y + e.height
        };
        break;
      case zt:
        u = {
          x: e.x + e.width,
          y: d
        };
        break;
      case ct:
        u = {
          x: e.x - t.width,
          y: d
        };
        break;
      default:
        u = {
          x: e.x,
          y: e.y
        };
    }
    var f = o ? Iu(o) : null;
    if (f != null) {
      var g = f === "y" ? "height" : "width";
      switch (a) {
        case Lo:
          u[f] = u[f] - (e[g] / 2 - t[g] / 2);
          break;
        case jn:
          u[f] = u[f] + (e[g] / 2 - t[g] / 2);
          break;
      }
    }
    return u;
  }
  function Zn(r, e) {
    e === void 0 && (e = {});
    var t = e, i = t.placement, o = i === void 0 ? r.placement : i, a = t.strategy, l = a === void 0 ? r.strategy : a, d = t.boundary, u = d === void 0 ? dP : d, f = t.rootBoundary, g = f === void 0 ? mv : f, _ = t.elementContext, C = _ === void 0 ? _n : _, x = t.altBoundary, D = x === void 0 ? !1 : x, P = t.padding, I = P === void 0 ? 0 : P, F = wv(typeof I != "number" ? I : kv(I, rs)), H = C === _n ? uP : _n, Y = r.rects.popper, W = r.elements[D ? H : C], G = VP($i(W) ? W : W.contextElement || Xr(r.elements.popper), u, g, l), ee = Fo(r.elements.reference), ie = Cv({
      reference: ee,
      element: Y,
      placement: o
    }), be = Wd(Object.assign({}, Y, ie)), ue = C === _n ? be : ee, he = {
      top: G.top - ue.top + F.top,
      bottom: ue.bottom - G.bottom + F.bottom,
      left: G.left - ue.left + F.left,
      right: ue.right - G.right + F.right
    }, Ee = r.modifiersData.offset;
    if (C === _n && Ee) {
      var ut = Ee[o];
      Object.keys(he).forEach(function(Fe) {
        var Zt = [zt, Ft].indexOf(Fe) >= 0 ? 1 : -1, or = [lt, Ft].indexOf(Fe) >= 0 ? "y" : "x";
        he[Fe] += ut[or] * Zt;
      });
    }
    return he;
  }
  function qP(r, e) {
    e === void 0 && (e = {});
    var t = e, i = t.placement, o = t.boundary, a = t.rootBoundary, l = t.padding, d = t.flipVariations, u = t.allowedAutoPlacements, f = u === void 0 ? bv : u, g = zo(i), _ = g ? d ? _m : _m.filter(function(D) {
      return zo(D) === g;
    }) : rs, C = _.filter(function(D) {
      return f.indexOf(D) >= 0;
    });
    C.length === 0 && (C = _);
    var x = C.reduce(function(D, P) {
      return D[P] = Zn(r, {
        placement: P,
        boundary: o,
        rootBoundary: a,
        padding: l
      })[rr(P)], D;
    }, {});
    return Object.keys(x).sort(function(D, P) {
      return x[D] - x[P];
    });
  }
  function YP(r) {
    if (rr(r) === Ou)
      return [];
    var e = ga(r);
    return [wm(r), e, wm(e)];
  }
  function GP(r) {
    var e = r.state, t = r.options, i = r.name;
    if (!e.modifiersData[i]._skip) {
      for (var o = t.mainAxis, a = o === void 0 ? !0 : o, l = t.altAxis, d = l === void 0 ? !0 : l, u = t.fallbackPlacements, f = t.padding, g = t.boundary, _ = t.rootBoundary, C = t.altBoundary, x = t.flipVariations, D = x === void 0 ? !0 : x, P = t.allowedAutoPlacements, I = e.options.placement, F = rr(I), H = F === I, Y = u || (H || !D ? [ga(I)] : YP(I)), W = [I].concat(Y).reduce(function(Er, Ke) {
        return Er.concat(rr(Ke) === Ou ? qP(e, {
          placement: Ke,
          boundary: g,
          rootBoundary: _,
          padding: f,
          flipVariations: D,
          allowedAutoPlacements: P
        }) : Ke);
      }, []), G = e.rects.reference, ee = e.rects.popper, ie = /* @__PURE__ */ new Map(), be = !0, ue = W[0], he = 0; he < W.length; he++) {
        var Ee = W[he], ut = rr(Ee), Fe = zo(Ee) === Lo, Zt = [lt, Ft].indexOf(ut) >= 0, or = Zt ? "width" : "height", Ze = Zn(e, {
          placement: Ee,
          boundary: g,
          rootBoundary: _,
          altBoundary: C,
          padding: f
        }), De = Zt ? Fe ? zt : ct : Fe ? Ft : lt;
        G[or] > ee[or] && (De = ga(De));
        var ht = ga(De), nr = [];
        if (a && nr.push(Ze[ut] <= 0), d && nr.push(Ze[De] <= 0, Ze[ht] <= 0), nr.every(function(Er) {
          return Er;
        })) {
          ue = Ee, be = !1;
          break;
        }
        ie.set(Ee, nr);
      }
      if (be)
        for (var sr = D ? 3 : 1, rt = function(Ke) {
          var Kt = W.find(function(Mi) {
            var ft = ie.get(Mi);
            if (ft)
              return ft.slice(0, Ke).every(function(ar) {
                return ar;
              });
          });
          if (Kt)
            return ue = Kt, "break";
        }, Qr = sr; Qr > 0; Qr--) {
          var Ii = rt(Qr);
          if (Ii === "break") break;
        }
      e.placement !== ue && (e.modifiersData[i]._skip = !0, e.placement = ue, e.reset = !0);
    }
  }
  const jP = {
    name: "flip",
    enabled: !0,
    phase: "main",
    fn: GP,
    requiresIfExists: ["offset"],
    data: {
      _skip: !1
    }
  };
  function xm(r, e, t) {
    return t === void 0 && (t = {
      x: 0,
      y: 0
    }), {
      top: r.top - e.height - t.y,
      right: r.right - e.width + t.x,
      bottom: r.bottom - e.height + t.y,
      left: r.left - e.width - t.x
    };
  }
  function Cm(r) {
    return [lt, zt, Ft, ct].some(function(e) {
      return r[e] >= 0;
    });
  }
  function ZP(r) {
    var e = r.state, t = r.name, i = e.rects.reference, o = e.rects.popper, a = e.modifiersData.preventOverflow, l = Zn(e, {
      elementContext: "reference"
    }), d = Zn(e, {
      altBoundary: !0
    }), u = xm(l, i), f = xm(d, o, a), g = Cm(u), _ = Cm(f);
    e.modifiersData[t] = {
      referenceClippingOffsets: u,
      popperEscapeOffsets: f,
      isReferenceHidden: g,
      hasPopperEscaped: _
    }, e.attributes.popper = Object.assign({}, e.attributes.popper, {
      "data-popper-reference-hidden": g,
      "data-popper-escaped": _
    });
  }
  const KP = {
    name: "hide",
    enabled: !0,
    phase: "main",
    requiresIfExists: ["preventOverflow"],
    fn: ZP
  };
  function JP(r, e, t) {
    var i = rr(r), o = [ct, lt].indexOf(i) >= 0 ? -1 : 1, a = typeof t == "function" ? t(Object.assign({}, e, {
      placement: r
    })) : t, l = a[0], d = a[1];
    return l = l || 0, d = (d || 0) * o, [ct, zt].indexOf(i) >= 0 ? {
      x: d,
      y: l
    } : {
      x: l,
      y: d
    };
  }
  function XP(r) {
    var e = r.state, t = r.options, i = r.name, o = t.offset, a = o === void 0 ? [0, 0] : o, l = bv.reduce(function(g, _) {
      return g[_] = JP(_, e.rects, a), g;
    }, {}), d = l[e.placement], u = d.x, f = d.y;
    e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += u, e.modifiersData.popperOffsets.y += f), e.modifiersData[i] = l;
  }
  const QP = {
    name: "offset",
    enabled: !0,
    phase: "main",
    requires: ["popperOffsets"],
    fn: XP
  };
  function eI(r) {
    var e = r.state, t = r.name;
    e.modifiersData[t] = Cv({
      reference: e.rects.reference,
      element: e.rects.popper,
      placement: e.placement
    });
  }
  const tI = {
    name: "popperOffsets",
    enabled: !0,
    phase: "read",
    fn: eI,
    data: {}
  };
  function rI(r) {
    return r === "x" ? "y" : "x";
  }
  function iI(r) {
    var e = r.state, t = r.options, i = r.name, o = t.mainAxis, a = o === void 0 ? !0 : o, l = t.altAxis, d = l === void 0 ? !1 : l, u = t.boundary, f = t.rootBoundary, g = t.altBoundary, _ = t.padding, C = t.tether, x = C === void 0 ? !0 : C, D = t.tetherOffset, P = D === void 0 ? 0 : D, I = Zn(e, {
      boundary: u,
      rootBoundary: f,
      padding: _,
      altBoundary: g
    }), F = rr(e.placement), H = zo(e.placement), Y = !H, W = Iu(F), G = rI(W), ee = e.modifiersData.popperOffsets, ie = e.rects.reference, be = e.rects.popper, ue = typeof P == "function" ? P(Object.assign({}, e.rects, {
      placement: e.placement
    })) : P, he = typeof ue == "number" ? {
      mainAxis: ue,
      altAxis: ue
    } : Object.assign({
      mainAxis: 0,
      altAxis: 0
    }, ue), Ee = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null, ut = {
      x: 0,
      y: 0
    };
    if (ee) {
      if (a) {
        var Fe, Zt = W === "y" ? lt : ct, or = W === "y" ? Ft : zt, Ze = W === "y" ? "height" : "width", De = ee[W], ht = De + I[Zt], nr = De - I[or], sr = x ? -be[Ze] / 2 : 0, rt = H === Lo ? ie[Ze] : be[Ze], Qr = H === Lo ? -be[Ze] : -ie[Ze], Ii = e.elements.arrow, Er = x && Ii ? Pu(Ii) : {
          width: 0,
          height: 0
        }, Ke = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : yv(), Kt = Ke[Zt], Mi = Ke[or], ft = Tn(0, ie[Ze], Er[Ze]), ar = Y ? ie[Ze] / 2 - sr - ft - Kt - he.mainAxis : rt - ft - Kt - he.mainAxis, Za = Y ? -ie[Ze] / 2 + sr + ft + Mi + he.mainAxis : Qr + ft + Mi + he.mainAxis, $r = e.elements.arrow && is(e.elements.arrow), Ni = $r ? W === "y" ? $r.clientTop || 0 : $r.clientLeft || 0 : 0, Vo = (Fe = Ee?.[W]) != null ? Fe : 0, pt = De + ar - Vo - Ni, ei = De + Za - Vo, os = Tn(x ? Ia(ht, pt) : ht, De, x ? xi(nr, ei) : nr);
        ee[W] = os, ut[W] = os - De;
      }
      if (d) {
        var St, ns = W === "x" ? lt : ct, Ka = W === "x" ? Ft : zt, gt = ee[G], We = G === "y" ? "height" : "width", Tr = gt + I[ns], ti = gt - I[Ka], qo = [lt, ct].indexOf(F) !== -1, Or = (St = Ee?.[G]) != null ? St : 0, ss = qo ? Tr : gt - ie[We] - be[We] - Or + he.altAxis, Dr = qo ? gt + ie[We] + be[We] - Or - he.altAxis : ti, lr = x && qo ? EP(ss, gt, Dr) : Tn(x ? ss : Tr, gt, x ? Dr : ti);
        ee[G] = lr, ut[G] = lr - gt;
      }
      e.modifiersData[i] = ut;
    }
  }
  const oI = {
    name: "preventOverflow",
    enabled: !0,
    phase: "main",
    fn: iI,
    requiresIfExists: ["offset"]
  };
  function nI(r) {
    return {
      scrollLeft: r.scrollLeft,
      scrollTop: r.scrollTop
    };
  }
  function sI(r) {
    return r === Ct(r) || !Rt(r) ? Mu(r) : nI(r);
  }
  function aI(r) {
    var e = r.getBoundingClientRect(), t = Ro(e.width) / r.offsetWidth || 1, i = Ro(e.height) / r.offsetHeight || 1;
    return t !== 1 || i !== 1;
  }
  function lI(r, e, t) {
    t === void 0 && (t = !1);
    var i = Rt(e), o = Rt(e) && aI(e), a = Xr(e), l = Fo(r, o, t), d = {
      scrollLeft: 0,
      scrollTop: 0
    }, u = {
      x: 0,
      y: 0
    };
    return (i || !i && !t) && ((ir(e) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    Lu(a)) && (d = sI(e)), Rt(e) ? (u = Fo(e, !0), u.x += e.clientLeft, u.y += e.clientTop) : a && (u.x = Nu(a))), {
      x: l.left + d.scrollLeft - u.x,
      y: l.top + d.scrollTop - u.y,
      width: l.width,
      height: l.height
    };
  }
  function cI(r) {
    var e = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Set(), i = [];
    r.forEach(function(a) {
      e.set(a.name, a);
    });
    function o(a) {
      t.add(a.name);
      var l = [].concat(a.requires || [], a.requiresIfExists || []);
      l.forEach(function(d) {
        if (!t.has(d)) {
          var u = e.get(d);
          u && o(u);
        }
      }), i.push(a);
    }
    return r.forEach(function(a) {
      t.has(a.name) || o(a);
    }), i;
  }
  function dI(r) {
    var e = cI(r);
    return wP.reduce(function(t, i) {
      return t.concat(e.filter(function(o) {
        return o.phase === i;
      }));
    }, []);
  }
  function uI(r) {
    var e;
    return function() {
      return e || (e = new Promise(function(t) {
        Promise.resolve().then(function() {
          e = void 0, t(r());
        });
      })), e;
    };
  }
  function hI(r) {
    var e = r.reduce(function(t, i) {
      var o = t[i.name];
      return t[i.name] = o ? Object.assign({}, o, i, {
        options: Object.assign({}, o.options, i.options),
        data: Object.assign({}, o.data, i.data)
      }) : i, t;
    }, {});
    return Object.keys(e).map(function(t) {
      return e[t];
    });
  }
  var Sm = {
    placement: "bottom",
    modifiers: [],
    strategy: "absolute"
  };
  function Am() {
    for (var r = arguments.length, e = new Array(r), t = 0; t < r; t++)
      e[t] = arguments[t];
    return !e.some(function(i) {
      return !(i && typeof i.getBoundingClientRect == "function");
    });
  }
  function fI(r) {
    r === void 0 && (r = {});
    var e = r, t = e.defaultModifiers, i = t === void 0 ? [] : t, o = e.defaultOptions, a = o === void 0 ? Sm : o;
    return function(d, u, f) {
      f === void 0 && (f = a);
      var g = {
        placement: "bottom",
        orderedModifiers: [],
        options: Object.assign({}, Sm, a),
        modifiersData: {},
        elements: {
          reference: d,
          popper: u
        },
        attributes: {},
        styles: {}
      }, _ = [], C = !1, x = {
        state: g,
        setOptions: function(F) {
          var H = typeof F == "function" ? F(g.options) : F;
          P(), g.options = Object.assign({}, a, g.options, H), g.scrollParents = {
            reference: $i(d) ? On(d) : d.contextElement ? On(d.contextElement) : [],
            popper: On(u)
          };
          var Y = dI(hI([].concat(i, g.options.modifiers)));
          return g.orderedModifiers = Y.filter(function(W) {
            return W.enabled;
          }), D(), x.update();
        },
        // Sync update – it will always be executed, even if not necessary. This
        // is useful for low frequency updates where sync behavior simplifies the
        // logic.
        // For high frequency updates (e.g. `resize` and `scroll` events), always
        // prefer the async Popper#update method
        forceUpdate: function() {
          if (!C) {
            var F = g.elements, H = F.reference, Y = F.popper;
            if (Am(H, Y)) {
              g.rects = {
                reference: lI(H, is(Y), g.options.strategy === "fixed"),
                popper: Pu(Y)
              }, g.reset = !1, g.placement = g.options.placement, g.orderedModifiers.forEach(function(he) {
                return g.modifiersData[he.name] = Object.assign({}, he.data);
              });
              for (var W = 0; W < g.orderedModifiers.length; W++) {
                if (g.reset === !0) {
                  g.reset = !1, W = -1;
                  continue;
                }
                var G = g.orderedModifiers[W], ee = G.fn, ie = G.options, be = ie === void 0 ? {} : ie, ue = G.name;
                typeof ee == "function" && (g = ee({
                  state: g,
                  options: be,
                  name: ue,
                  instance: x
                }) || g);
              }
            }
          }
        },
        // Async and optimistically optimized update – it will not be executed if
        // not necessary (debounced to run at most once-per-tick)
        update: uI(function() {
          return new Promise(function(I) {
            x.forceUpdate(), I(g);
          });
        }),
        destroy: function() {
          P(), C = !0;
        }
      };
      if (!Am(d, u))
        return x;
      x.setOptions(f).then(function(I) {
        !C && f.onFirstUpdate && f.onFirstUpdate(I);
      });
      function D() {
        g.orderedModifiers.forEach(function(I) {
          var F = I.name, H = I.options, Y = H === void 0 ? {} : H, W = I.effect;
          if (typeof W == "function") {
            var G = W({
              state: g,
              name: F,
              instance: x,
              options: Y
            }), ee = function() {
            };
            _.push(G || ee);
          }
        });
      }
      function P() {
        _.forEach(function(I) {
          return I();
        }), _ = [];
      }
      return x;
    };
  }
  var pI = [RP, tI, NP, CP, QP, jP, oI, DP, KP], gI = /* @__PURE__ */ fI({
    defaultModifiers: pI
  });
  const mI = '.col-bg-body-lighter{background-color:var(--col-bg-body-lighter)}.col-bg-body{background-color:var(--col-bg-body)}.col-bg-body-darker{background-color:var(--col-bg-body-darker)}.col-bg-1-lighter{background-color:var(--col-bg-1-lighter)}.col-bg-1{background-color:var(--col-bg-1)}.col-bg-1-darker{background-color:var(--col-bg-1-darker)}.col-bg-1-input{background-color:var(--col-bg-1-input)}.col-primary-bg-1{background-color:var(--col-primary-bg-1)}.col-accent-bg-1{background-color:var(--col-accent-bg-1)}.col-success-bg-1{background-color:var(--col-success-bg-1)}.col-warning-bg-1{background-color:var(--col-warning-bg-1)}.col-error-bg-1{background-color:var(--col-error-bg-1)}.col-bg-2-lighter{background-color:var(--col-bg-2-lighter)}.col-bg-2{background-color:var(--col-bg-2)}.col-bg-2-darker{background-color:var(--col-bg-2-darker)}.col-bg-2-button{background-color:var(--col-bg-2-button)}.col-bg-2-input{background-color:var(--col-bg-2-input)}.col-primary-bg-2{background-color:var(--col-primary-bg-2)}.col-accent-bg-2{background-color:var(--col-accent-bg-2)}.col-success-bg-2{background-color:var(--col-success-bg-2)}.col-warning-bg-2{background-color:var(--col-warning-bg-2)}.col-error-bg-2{background-color:var(--col-error-bg-2)}.col-bg-3-lighter{background-color:var(--col-bg-3-lighter)}.col-bg-3{background-color:var(--col-bg-3)}.col-bg-3-darker{background-color:var(--col-bg-3-darker)}.col-bg-3-button{background-color:var(--col-bg-3-button)}.col-bg-3-input{background-color:var(--col-bg-3-input)}.col-primary-bg-3{background-color:var(--col-primary-bg-3)}.col-accent-bg-3{background-color:var(--col-accent-bg-3)}.col-success-bg-3{background-color:var(--col-success-bg-3)}.col-warning-bg-3{background-color:var(--col-warning-bg-3)}.col-error-bg-3{background-color:var(--col-error-bg-3)}.col-bg-ack-lighter{background-color:var(--col-bg-ack-lighter)}.col-bg-ack{background-color:var(--col-bg-ack)}.col-bg-ack-darker{background-color:var(--col-bg-ack-darker)}.col-primary-bg-ack{background-color:var(--col-primary-bg-ack)}.col-accent-bg-ack{background-color:var(--col-accent-bg-ack)}.col-bg-att-lighter{background-color:var(--col-bg-att-lighter)}.col-bg-att{background-color:var(--col-bg-att)}.col-bg-att-darker{background-color:var(--col-bg-att-darker)}.col-primary-bg-att{background-color:var(--col-primary-bg-att)}.col-accent-bg-att{background-color:var(--col-accent-bg-att)}.col-bg-alert-lighter{background-color:var(--col-bg-alert-lighter)}.col-bg-alert{background-color:var(--col-bg-alert)}.col-bg-alert-darker{background-color:var(--col-bg-alert-darker)}.col-primary-bg-alert{background-color:var(--col-primary-bg-alert)}.col-accent-bg-alert{background-color:var(--col-accent-bg-alert)}.col-bg-btn-lighter{background-color:var(--col-bg-btn-lighter)}.col-bg-btn{background-color:var(--col-bg-btn)}.col-bg-btn-darker{background-color:var(--col-bg-btn-darker)}.col-primary-bg-btn{background-color:var(--col-primary-bg-btn)}.col-accent-bg-btn{background-color:var(--col-accent-bg-btn)}.pattern-diagonal-stripes-sm{background:repeating-linear-gradient(45deg,transparent,transparent 10px,currentColor 10px,currentColor 20px)}.pattern-dots-lg{background-image:radial-gradient(currentColor 1.5px,transparent 1.5px);background-size:15px 15px}.pattern-dots-md{background-image:radial-gradient(currentColor 1px,transparent 1px);background-size:8px 8px}.pattern-dots-medium-dense{background-image:radial-gradient(currentColor .5px,transparent .5px);background-size:3px 3px}.pattern-dots-sm{background-image:radial-gradient(currentColor .5px,transparent .5px);background-size:5px 5px}.pattern-cross-dots-md,.imagelist-background{background-image:radial-gradient(currentColor .7px,transparent 1px),radial-gradient(currentColor .7px,transparent 1px);background-size:6.5px 6.5px;background-position:0 0,3.5px 3.5px}.imagelist-background{background-color:#fff9;background-blend-mode:overlay}p,div{padding:0;margin:0;border:0px;user-select:text;-webkit-user-select:text}select{user-select:none;-webkit-user-select:none}.fa,.fas{font-family:"Font Awesome 5 Free";font-weight:900;font-style:normal}.fa-trash:before{content:""}.fa-view-grid:before{content:""}.fa-view-list:before{content:""}.fa-camera:before{content:""}.fa-view-image:before{content:""}.fa-check:before{content:""}.fa-exclamation-circle:before{content:""}.fa-list-check:before{content:""}.fa-backward:before{content:""}.fa-forward:before{content:""}.fa-backward-fast:before{content:""}.fa-forward-fast:before{content:""}.list-header{position:sticky;z-index:1;top:0}:host{background-color:var(--col-bg-body);display:block;border:solid 2px var(--col-bg-1-darker);overflow-y:hidden;padding-bottom:.5em}div,p{font-family:var(--standard-text-font)}.locus-list{display:grid;overflow-y:scroll;height:100%;width:100%;max-height:35vh;grid-row-gap:5px;grid-template-rows:[header] auto;grid-template-columns:repeat(8,auto);border-top:solid var(--col-bg-1-darker) 2px}.locus-list div{padding-right:.5em}.locus-list.locus-list-with-member{grid-template-columns:repeat(9,auto)}.list-header{background:var(--col-bg-1-lighter);color:var(--col-primary-bg-1);font-weight:700;padding-top:5px;word-wrap:break-word;border-bottom:solid var(--col-bg-1-darker) 1px}.list-header.tighter{max-width:5em}.headline{background-color:var(--col-bg-1-lighter);color:var(--col-primary-bg-1);padding:2px;font-weight:700}.controls{display:flex;flex-direction:row;background-color:var(--col-bg-1-lighter);color:var(--col-primary-bg-1);padding:2px;font-weight:700;justify-content:space-between}.no-loci{padding:2px}.locus{font-family:var(--standard-text-font);padding:.2em;border-bottom:var(--col-bg-1-darker) 2px solid}.locus-headline{display:flex;flex-direction:row;justify-content:space-between;font-size:1.2em;font-weight:700}.locus-body{display:flex;flex-direction:row}.locus-body div{padding:0 .5em}#sort-type-selector{padding-right:1em}.center-col{display:flex;justify-content:center}.identifier-col{display:flex;justify-content:space-between;flex-direction:row}.identifier-col i{margin-left:.2em}.fa-exclamation-circle.warning,.fa-exclamation-circle.warn{color:var(--col-bg-att)}.fa-exclamation-circle.error{color:var(--col-bg-alert)}.fa-exclamation-circle.hint{color:var(--col-bg-ack)}.tooltip{display:none;background-color:var(--col-bg-1);color:var(--col-primary-bg-1);border:solid 2px var(--col-bg-1-darker);box-shadow:2px 2px 5px var(--col-bg-1-darker)}.tooltip *{-webkit-user-select:none;user-select:none}.tooltip[data-show]{display:block}.qc-message{background-color:var(--col-bg-1)}.tooltip{z-index:1}.qc-message-view{padding:.5em}.qc-message-view p:first-child{margin-bottom:.5em;font-weight:700;color:var(--col-accent-bg-1)}.qc-message-view p{margin-bottom:.2em}.qc-message-view i{margin-right:.5em}';
  var bI = Object.getOwnPropertyDescriptor, _I = Object.getPrototypeOf, vI = Reflect.get, yI = (r, e, t, i) => {
    for (var o = i > 1 ? void 0 : i ? bI(e, t) : e, a = r.length - 1, l; a >= 0; a--)
      (l = r[a]) && (o = l(o) || o);
    return o;
  }, wI = (r, e, t) => vI(_I(r), t, e);
  class kI {
  }
  let vo = class extends Re {
    constructor() {
      super(), this.selected_date = null, this.selected_context = "", this.selected_context_uid = "", this.selected_member = "", this.loci = {}, this.lociList = [], this.fetching = !1, this.fetch_error = "", this.locusCount = 0, this.selected_sort = "identifier", this.term_for_locus = "locus", this.term_for_loci = "loci", this.poppers = null, this.sort_by = {
        identifier: ["identifier", "modified"],
        creation: ["created", "identifier"]
      };
    }
    get_conditions(r, e, t) {
      let i = `modified_date = '${r}' and coalesce(type,'') <> 'su'`;
      return (e || t) && (e && (i = i + ` and identifier = '${e}'`), t && (i = i + ` and modified_by ='${t}'`)), i;
    }
    fetch_data() {
      this.fetching = !0;
      const r = Zr(this.selected_date), e = `
            primary_identifier, identifier, nointerpretation, nodescription, created, modified_by, modified_date,
            date_defined, record_type, type, primary_identifier_uuid qc_data_context, count(data_uuid) c 
            from {base} where ${this.get_conditions(r, this.selected_context, this.selected_member)}  
            group by primary_identifier, identifier, nointerpretation, nodescription, created, modified_by, 
            modified_date, date_defined, record_type, type, primary_identifier_uuid         
        `, t = {
        cql: {
          base: {
            scope: {
              unit: {
                locus: {
                  locus_relations: {},
                  lot: {},
                  locus_photo: {}
                  // "collected_material": {}
                }
              }
            },
            target: {
              field_or_instruction: "modified_ww()"
            },
            additional_fields: {
              modified_date: {
                field_or_instruction: "modified_ww()",
                default: "",
                format: "datetime(date)"
              },
              modified_by: {
                field_or_instruction: "replfield_modified_by()",
                default: ""
              },
              modified_timestamp: {
                field_or_instruction: "modified_ww()",
                default: ""
              },
              created: {
                field_or_instruction: "locus.replfield_created()",
                default: "null",
                format: "datetime(date)"
              },
              date_defined: {
                field_or_instruction: "locus.date_defined",
                default: "null",
                format: "datetime(date)"
              },
              type: {
                field_or_instruction: "locus.type",
                default: "null"
              },
              nointerpretation: {
                field_or_instruction: "locus.interpretation",
                default: "true",
                format: "isempty()"
              },
              nodescription: {
                field_or_instruction: "locus.description",
                default: "true",
                format: "isempty()"
              }
            }
          },
          meta: {
            version: 0.1
          },
          query: {
            type: "DirectSqlQuery",
            sql: e
          }
        }
      };
      let i = new URLSearchParams({
        page_size: "-1",
        qc_data_context: "qc_data_context"
      });
      this.apiContext.fetchFromApi(
        "",
        "cql/query",
        {
          method: "POST",
          caller: "locuswidget.fetch_data",
          body: JSON.stringify(t)
        },
        "v1",
        i
      ).then((o) => {
        o.result_msg !== "ok" ? this.fetch_error = o.result_msg : (this.fetch_error = "", this.load_records(o.records, o.qc_messages)), this.fetching = !1;
      }).catch((o) => {
        dt(this, o, "locusWidget.fetch_data", null);
      });
    }
    get_locus_qc_messages(r, e) {
      let t = [];
      for (const i of r)
        i.data_context == e && t.push(i);
      return t;
    }
    get_max_qc_severity(r) {
      let e = "";
      for (const t of r) {
        const i = t.severity;
        if (i.startsWith("err"))
          return "error";
        i.startsWith("warn") ? e = "warning" : i == "hint" && e != "warning" && (e = "hint");
      }
      return e;
    }
    load_records(r, e) {
      this.loci = {}, this.lociList = [], r.forEach((t) => {
        const i = t.primary_identifier;
        let o;
        t.record_type != "unit" && (i in this.loci ? o = this.loci[i] : (o = new kI(), this.loci[i] = o, this.lociList.push(o), o.photoCount = 0, o.lotCount = 0, o.type = "?", o.hasDescription = !1, o.hasInterpretation = !1, o.relationsCount = 0, o.record_type = "", o.modified = 0, o.locus_creation = "?", o.max_severity = "", o.qc_messages = []), o.identifier = t.primary_identifier, o.unitId = t.identifier, o.record_type = t.record_type, t.modified > o.modified && (o.modified = t.modified, o.modified_by = t.modified_by), t.type && (o.type = t.type), t.date_defined && (o.locus_creation = xr(t.date_defined).toLocaleDateString()), t.created && (o.created = xr(t.created).getTime()), t.nodescription || (o.hasDescription = !0), t.nointerpretation || (o.hasInterpretation = !0), e.length > 0 && o.qc_messages.length == 0 && (o.qc_messages = this.get_locus_qc_messages(e, t.qc_data_context), o.max_severity = "", o.qc_messages.length > 0 && (o.max_severity = this.get_max_qc_severity(o.qc_messages))), t.record_type == "locus_photo" && (o.photoCount = t.c), t.record_type == "locus_relations" && (o.relationsCount = t.c), t.record_type == "lot" && (o.lotCount = t.c));
      }), this.locusCount = Object.keys(this.loci).length, this.sort_records(this.sort_by[this.selected_sort]);
    }
    sort_records(r) {
      function e(t, i) {
        for (let o = 0; o < r.length; o++) {
          let a = r[o], l = t[a], d = i[a], u = 0;
          if (typeof l == "string" ? u = l.localeCompare(d) : (l < d && (u = -1), l > d && (u = 1)), u != 0)
            return u;
        }
        return 0;
      }
      this.lociList.sort(e), this.requestUpdate();
    }
    stateChanged(r) {
      if (this.fetch_error)
        return S`Error fetching: ${this.fetch_error}`;
      if (r.initState == 0)
        return;
      let e = !1;
      if ("dateSelector" in r.selectors) {
        let t = r.selectors.dateSelector.selectedDate;
        if ((!this.selected_date || t.getTime() !== this.selected_date.getTime()) && (this.selected_date = t, e = !0), "contextSelector" in r.selectors) {
          let i = r.selectors.contextSelector.selectedContext;
          i !== this.selected_context && (this.selected_context = i, this.selected_context_uid = r.selectors.contextSelector.selectedUid, e = !0);
        }
        if ("teamSelector" in r.selectors) {
          let i = r.selectors.teamSelector.selectedMember;
          i !== this.selected_member && (this.selected_member = i, e = !0);
        }
        e && this.fetch_data();
      }
      r.constants.length > 0 && (this.term_for_locus = Ye(
        r.constants,
        "standard_term_for_loci",
        !1,
        this.term_for_locus
      ), this.term_for_loci = Ye(
        r.constants,
        "standard_term_for_loci",
        !0,
        this.term_for_loci
      ));
    }
    showQcMessages(r) {
      const e = r.target, t = e.nextElementSibling, i = e.getAttribute("tip-id");
      this.poppers.get(i).update(), t.setAttribute("data-show", ""), t.addEventListener("blur", () => {
        t.removeAttribute("data-show");
      }), t.addEventListener("mouseleave", () => {
        t.removeAttribute("data-show");
      }), t.addEventListener("click", () => {
        t.removeAttribute("data-show");
      });
    }
    apiRender() {
      return S`
                    <div class="locus-widget">
                        <div class="headline">
                            <p>${this.locusCount} ${this.locusCount == 1 ? this.term_for_locus : this.term_for_loci}</p>
                        </div>
                        <div class="controls">
                            <div class="controls-left">
                                ${this.renderSortSelector()}
                            </div>
                        </div>
                        ${this.selected_date !== null ? this.render_widget() : S`Please select a date`}
                    </div>`;
    }
    sortTypeChanged(r) {
      this.selected_sort = r.currentTarget.value, this.sort_records(this.sort_by[this.selected_sort]);
    }
    renderSortSelector() {
      return S`
            <label for="sort-type-selector">sort by</label>
            <select name="sort-type-selector" id="sort-type-selector" @change="${this.sortTypeChanged}">
                ${Object.keys(this.sort_by).map(
        (r) => S`
                            <option value="${r}"
                                    ?selected="${this.selected_sort === r}">
                                ${r}
                            </option>
                        `
      )}
            </select>
        `;
    }
    renderQCMessages(r) {
      return S`
            <div class="qc-message-view">
                <p>recording quality for ${r.identifier}</p>
                ${r.qc_messages.map((e) => S`
                    <p class="qc-message ${e.severity}">
                        <i class="fa fa-exclamation-circle ${e.severity}"></i>${e.message}
                    </p>
                `)}
            </div>    
                
        `;
    }
    render_widget() {
      return this.selected_date ? this.fetching ? S`fetching data ...` : this.locusCount == 0 ? S`
                    <div class="no-loci">
                        <p>No data found for your selection</p>
                    </div>` : S`
                <div class="locus-list ${this.selected_member ? void 0 : "locus-list-with-member"}">
                    <div class="list-header">identifier</div>
                    <div class="list-header">type</div>
                    <div class="list-header">lots</div>
                    <div class="list-header">creation</div>
                    <div class="list-header">description?</div>
                    <div class="list-header tighter">interpre-tation?</div>
                    <div class="list-header">relations</div>
                    <div class="list-header">photos</div>
                    ${this.selected_member ? void 0 : S`<div class="list-header">by</div>`}
                    ${this.lociList.map(
        (r) => S`
                        <div class="identifier-col">
                            ${this.selected_context ? void 0 : S`${r.unitId}/`}${r.identifier}
                            ${r.max_severity != "" ? S`                                
                                    <i class="fa fa-exclamation-circle ${r.max_severity} tooltip-button" 
                                       tip-id="${r.identifier}" 
                                       @click="${this.showQcMessages}">
                                    </i>
                                    <div class="tooltip">
                                        ${this.renderQCMessages(r)}
                                    </div>
                                ` : void 0} 
                        </div>
                        <div>${r.type}</div>
                        <div class="center-col">${r.lotCount}</div>
                        <div>${r.locus_creation}</div>
                        <div class="center-col">${r.hasDescription ? S`                                
                                    <i class="fa fa-check"></i>
                                ` : void 0}</div>
                        <div class="center-col">${r.hasInterpretation ? S`                                
                                    <i class="fa fa-check"></i>
                                ` : void 0}</div>
                        <div class="center-col">${r.relationsCount}</div>
                        <div class="center-col">${r.photoCount}</div>
                        ${this.selected_member ? void 0 : S`<div class="center-col">${r.modified_by}</div>`}
                    `
      )}
                </div>
                ` : S`please select a date`;
    }
    updated(r) {
      super.updated(r);
      const e = this.shadowRoot.querySelectorAll(".tooltip-button");
      this.poppers = /* @__PURE__ */ new Map();
      for (const t of e) {
        const i = gI(t, t.nextElementSibling, {
          placement: "right",
          modifiers: [
            {
              name: "offset",
              options: {
                offset: [0, 8]
              }
            }
          ]
        });
        this.poppers.set(t.getAttribute("tip-id"), i);
      }
    }
  };
  vo.styles = Ue(mI);
  vo.properties = {
    ...wI(vo, vo, "properties"),
    selected_context: { type: String },
    selected_date: { type: Date },
    selected_member: { type: String },
    fetching: { type: Boolean },
    sort_by: { type: Array },
    term_for_locus: { type: String }
  };
  vo = yI([
    tt("locus-widget")
  ], vo);
  const xI = '.col-bg-body-lighter{background-color:var(--col-bg-body-lighter)}.col-bg-body{background-color:var(--col-bg-body)}.col-bg-body-darker{background-color:var(--col-bg-body-darker)}.col-bg-1-lighter{background-color:var(--col-bg-1-lighter)}.col-bg-1{background-color:var(--col-bg-1)}.col-bg-1-darker{background-color:var(--col-bg-1-darker)}.col-bg-1-input{background-color:var(--col-bg-1-input)}.col-primary-bg-1{background-color:var(--col-primary-bg-1)}.col-accent-bg-1{background-color:var(--col-accent-bg-1)}.col-success-bg-1{background-color:var(--col-success-bg-1)}.col-warning-bg-1{background-color:var(--col-warning-bg-1)}.col-error-bg-1{background-color:var(--col-error-bg-1)}.col-bg-2-lighter{background-color:var(--col-bg-2-lighter)}.col-bg-2{background-color:var(--col-bg-2)}.col-bg-2-darker{background-color:var(--col-bg-2-darker)}.col-bg-2-button{background-color:var(--col-bg-2-button)}.col-bg-2-input{background-color:var(--col-bg-2-input)}.col-primary-bg-2{background-color:var(--col-primary-bg-2)}.col-accent-bg-2{background-color:var(--col-accent-bg-2)}.col-success-bg-2{background-color:var(--col-success-bg-2)}.col-warning-bg-2{background-color:var(--col-warning-bg-2)}.col-error-bg-2{background-color:var(--col-error-bg-2)}.col-bg-3-lighter{background-color:var(--col-bg-3-lighter)}.col-bg-3{background-color:var(--col-bg-3)}.col-bg-3-darker{background-color:var(--col-bg-3-darker)}.col-bg-3-button{background-color:var(--col-bg-3-button)}.col-bg-3-input{background-color:var(--col-bg-3-input)}.col-primary-bg-3{background-color:var(--col-primary-bg-3)}.col-accent-bg-3{background-color:var(--col-accent-bg-3)}.col-success-bg-3{background-color:var(--col-success-bg-3)}.col-warning-bg-3{background-color:var(--col-warning-bg-3)}.col-error-bg-3{background-color:var(--col-error-bg-3)}.col-bg-ack-lighter{background-color:var(--col-bg-ack-lighter)}.col-bg-ack{background-color:var(--col-bg-ack)}.col-bg-ack-darker{background-color:var(--col-bg-ack-darker)}.col-primary-bg-ack{background-color:var(--col-primary-bg-ack)}.col-accent-bg-ack{background-color:var(--col-accent-bg-ack)}.col-bg-att-lighter{background-color:var(--col-bg-att-lighter)}.col-bg-att{background-color:var(--col-bg-att)}.col-bg-att-darker{background-color:var(--col-bg-att-darker)}.col-primary-bg-att{background-color:var(--col-primary-bg-att)}.col-accent-bg-att{background-color:var(--col-accent-bg-att)}.col-bg-alert-lighter{background-color:var(--col-bg-alert-lighter)}.col-bg-alert{background-color:var(--col-bg-alert)}.col-bg-alert-darker{background-color:var(--col-bg-alert-darker)}.col-primary-bg-alert{background-color:var(--col-primary-bg-alert)}.col-accent-bg-alert{background-color:var(--col-accent-bg-alert)}.col-bg-btn-lighter{background-color:var(--col-bg-btn-lighter)}.col-bg-btn{background-color:var(--col-bg-btn)}.col-bg-btn-darker{background-color:var(--col-bg-btn-darker)}.col-primary-bg-btn{background-color:var(--col-primary-bg-btn)}.col-accent-bg-btn{background-color:var(--col-accent-bg-btn)}.pattern-diagonal-stripes-sm{background:repeating-linear-gradient(45deg,transparent,transparent 10px,currentColor 10px,currentColor 20px)}.pattern-dots-lg{background-image:radial-gradient(currentColor 1.5px,transparent 1.5px);background-size:15px 15px}.pattern-dots-md{background-image:radial-gradient(currentColor 1px,transparent 1px);background-size:8px 8px}.pattern-dots-medium-dense{background-image:radial-gradient(currentColor .5px,transparent .5px);background-size:3px 3px}.pattern-dots-sm{background-image:radial-gradient(currentColor .5px,transparent .5px);background-size:5px 5px}.pattern-cross-dots-md,.imagelist-background{background-image:radial-gradient(currentColor .7px,transparent 1px),radial-gradient(currentColor .7px,transparent 1px);background-size:6.5px 6.5px;background-position:0 0,3.5px 3.5px}.imagelist-background{background-color:#fff9;background-blend-mode:overlay}p,div{padding:0;margin:0;border:0px;user-select:text;-webkit-user-select:text}select{user-select:none;-webkit-user-select:none}.fa,.fas{font-family:"Font Awesome 5 Free";font-weight:900;font-style:normal}.fa-trash:before{content:""}.fa-view-grid:before{content:""}.fa-view-list:before{content:""}.fa-camera:before{content:""}.fa-view-image:before{content:""}.fa-check:before{content:""}.fa-exclamation-circle:before{content:""}.fa-list-check:before{content:""}.fa-backward:before{content:""}.fa-forward:before{content:""}.fa-backward-fast:before{content:""}.fa-forward-fast:before{content:""}.list-header{position:sticky;z-index:1;top:0}:host{display:block;background-color:var(--col-bg-body);border:solid 2px var(--col-bg-1-darker);overflow-y:hidden;padding-bottom:.5em}div,p{font-family:var(--standard-text-font)}.cm-list{display:grid;overflow-y:scroll;height:100%;width:100%;max-height:35vh;grid-row-gap:5px;grid-template-rows:[header] auto;grid-template-columns:repeat(7,auto);border-top:solid var(--col-bg-1-darker) 2px}.cm-list div{padding-right:1em}.cm-list.cm-list-with-member{grid-template-columns:repeat(8,auto)}.list-header{background:var(--col-bg-1-lighter);font-weight:700;padding-top:1em;border-bottom:solid 1px var(--col-bg-1-darker)}.headline{background-color:var(--col-bg-1-lighter);color:var(--col-primary-bg-1);padding:2px;font-weight:700}.controls{display:flex;flex-direction:row;background-color:var(--col-bg-1-lighter);color:var(--col-primary-bg-1);padding:2px;font-weight:700;justify-content:space-between}.no-data{padding:2px}#sort-type-selector{padding-right:1em}.center-col{display:flex;justify-content:center}';
  var CI = Object.getOwnPropertyDescriptor, SI = Object.getPrototypeOf, AI = Reflect.get, EI = (r, e, t, i) => {
    for (var o = i > 1 ? void 0 : i ? CI(e, t) : e, a = r.length - 1, l; a >= 0; a--)
      (l = r[a]) && (o = l(o) || o);
    return o;
  }, $I = (r, e, t) => AI(SI(r), t, e);
  class TI {
  }
  let yo = class extends Re {
    constructor() {
      super(), this.selected_date = null, this.selected_context = "", this.selected_context_uid = "", this.selected_member = "", this.cm = [], this.fetching = !1, this.fetch_error = "", this.cmCount = 0, this.selected_sort = "identifier", this.term_for_cm = "collected material", this.plural_for_cm = "collected materials", this.cm_types = {}, this.sort_by = {
        identifier: ["identifier", "modified"],
        creation: ["created", "identifier"],
        type: ["cm_type", "created", "identifier"],
        material: ["type", "created", "identifier"]
      };
    }
    get_conditions(r, e, t) {
      let i = `record_type in ('collected_material', 'collected_material_photo') and modified_date = '${r}'`;
      return (e || t) && (e && (i = i + ` and identifier = '${e}'`), t && (i = i + ` and modified_by ='${t}'`)), i;
    }
    fetch_data() {
      this.fetching = !0;
      const r = Zr(this.selected_date), e = `
            primary_identifier, identifier, cm_type, nolot, nodescription, date, created, modified_by, modified_date, 
            record_type, type, count(data_uuid) c 
            from {base} 
            where ${this.get_conditions(r, this.selected_context, this.selected_member)}
            group by primary_identifier, identifier, cm_type, nolot, nodescription, date, created, modified_by, modified_date, 
            record_type, type         
        `, t = {
        cql: {
          base: {
            scope: {
              unit: {
                locus: {
                  collected_material: {
                    collected_material_photo: {}
                  }
                }
              }
            },
            target: {
              field_or_instruction: "modified_ww()"
            },
            additional_fields: {
              modified_date: {
                field_or_instruction: "modified_ww()",
                default: "",
                format: "datetime(date)"
              },
              modified_by: {
                field_or_instruction: "replfield_modified_by()",
                default: ""
              },
              modified_timestamp: {
                field_or_instruction: "modified_ww()",
                default: ""
              },
              created: {
                field_or_instruction: "collected_material.replfield_created()",
                default: "null",
                format: "datetime(date)"
              },
              date: {
                field_or_instruction: "collected_material.date",
                default: "null",
                format: "datetime(date)"
              },
              type: {
                field_or_instruction: "collected_material.type",
                default: "",
                format: "dsd_type(varchar)"
              },
              nolot: {
                field_or_instruction: "collected_material.uid_lot",
                default: "false",
                format: "isempty()"
              },
              nodescription: {
                field_or_instruction: "collected_material.description",
                default: "true",
                format: "isempty()"
              },
              cm_type: {
                field_or_instruction: "collected_material.cm_type",
                default: "-",
                format: "dsd_type(varchar)"
              }
            }
          },
          meta: {
            version: 0.1
            // "comment": "cmwidget"
          },
          query: {
            type: "DirectSqlQuery",
            sql: e
          }
        }
      };
      let i = new URLSearchParams({
        page_size: "-1"
      });
      this.apiContext.fetchFromApi(
        "",
        "cql/query",
        {
          method: "POST",
          caller: "cmwidget.fetch_data",
          body: JSON.stringify(t)
        },
        "v1",
        i
      ).then((o) => {
        o.result_msg !== "ok" ? this.fetch_error = o.result_msg : (this.fetch_error = "", this.load_records(o.records)), this.fetching = !1;
      }).catch((o) => {
        dt(this, o, "cmwidget.fetch_data", null);
      });
    }
    load_records(r) {
      this.cm = [];
      let e = {};
      r.forEach((t) => {
        const i = t.primary_identifier;
        let o;
        i in e ? o = e[i] : (o = new TI(), e[i] = o, this.cm.push(o), o.photoCount = 0, o.lot = !1, o.type = "?", o.hasDescription = !1, o.cm_type = "bulk", o.record_type = "", o.modified = 0, o.cm_creation = "?"), o.identifier = t.primary_identifier, o.unitId = t.identifier, o.record_type = t.record_type, t.modified > o.modified && (o.modified = t.modified), o.modified_by = t.modified_by, t.type && (o.type = t.type), t.cm_type && (o.cm_type = this.cm_types[t.cm_type]), t.date && (o.cm_creation = xr(t.date).toLocaleDateString()), t.created && (o.created = xr(t.created).getTime()), t.nodescription || (o.hasDescription = !0), t.nolot || (o.lot = !0), t.record_type == "collected_material_photo" && (o.photoCount = t.c);
      }), this.cmCount = Object.keys(this.cm).length, this.sort_records(this.sort_by[this.selected_sort]);
    }
    sort_records(r) {
      function e(t, i) {
        for (let o = 0; o < r.length; o++) {
          let a = r[o], l = t[a], d = i[a], u = 0;
          if (typeof l == "string" ? u = l.localeCompare(d) : typeof l == "boolean" ? (l && !d && (u = -1), !l && d && (u = 1)) : (l < d && (u = -1), l > d && (u = 1)), u != 0)
            return u;
        }
        return 0;
      }
      this.cm.sort(e), this.requestUpdate();
    }
    stateChanged(r) {
      if (this.fetch_error || r.initState == 0)
        return;
      let e = !1;
      if ("dateSelector" in r.selectors) {
        let t = r.selectors.dateSelector.selectedDate;
        if ((!this.selected_date || t.getTime() !== this.selected_date.getTime()) && (this.selected_date = t, e = !0), "contextSelector" in r.selectors) {
          let i = r.selectors.contextSelector.selectedContext;
          i !== this.selected_context && (this.selected_context = i, this.selected_context_uid = r.selectors.contextSelector.selectedUid, e = !0);
        }
        if ("teamSelector" in r.selectors) {
          let i = r.selectors.teamSelector.selectedMember;
          i !== this.selected_member && (this.selected_member = i, e = !0);
        }
        e && this.fetch_data();
      }
      if (r.constants.length > 0) {
        this.term_for_cm = Ye(
          r.constants,
          "standard_term_for_cm",
          !1,
          this.term_for_cm
        ), this.plural_for_cm = Ye(
          r.constants,
          "standard_term_for_cm",
          !0,
          this.term_for_cm
        );
        for (let t = 0; t < r.constants.length; t++) {
          let i = r.constants[t];
          i.path === "constants/collected_material_types" && (this.cm_types[i.key] = i.value);
        }
      }
    }
    apiRender() {
      return S`
                    <div class="cm-widget">
                        <div class="headline">
                            <p>${this.cmCount} ${this.cmCount == 1 ? this.term_for_cm : this.plural_for_cm}</p>
                        </div>
                        <div class="controls">
                            <div class="controls-left">
                                ${this.renderSortSelector()}
                            </div>
                        </div>
                        ${this.selected_date !== null ? this.render_widget() : S`Please select a date`}
                    </div>`;
    }
    sortTypeChanged(r) {
      this.selected_sort = r.currentTarget.value, this.sort_records(this.sort_by[this.selected_sort]);
    }
    renderSortSelector() {
      return S`
            <label for="sort-type-selector">sort by</label>
            <select name="sort-type-selector" id="sort-type-selector" @change="${this.sortTypeChanged}">
                ${Object.keys(this.sort_by).map(
        (r) => S`
                            <option value="${r}"
                                    ?selected="${this.selected_sort === r}">
                                ${r}
                            </option>
                        `
      )}
            </select>
        `;
    }
    render_widget() {
      return this.selected_date ? this.fetching ? S`fetching data ...` : this.cmCount == 0 ? S`
                    <div class="no-data">
                        <p>No data found for your selection</p>
                    </div>` : S`
                <div class="cm-list ${this.selected_member ? void 0 : "cm-list-with-member"}">
                    <div class="list-header">identifier</div>
                    <div class="list-header">material</div>
                    <div class="list-header">creation</div>
                    <div class="list-header">description?</div>
                    <div class="list-header">type</div>
                    <div class="list-header">lot?</div>
                    <div class="list-header">photos</div>
                    ${this.selected_member ? void 0 : S`<div class="list-header">by</div>`}
                    ${this.cm.map(
        (r) => S`
                        <div>
                            ${this.selected_context ? void 0 : S`${r.unitId}/`}${r.identifier}
                        </div>
                        <div>${r.type}</div>
                        <div>${r.cm_creation}</div>
                        <div class="center-col">${r.hasDescription ? S`                                
                                    <i class="fa fa-check"></i>
                                ` : void 0}</div>
                        <div>${r.cm_type}</div>
                        <div class="center-col">${r.lot ? S`                                
                                    <i class="fa fa-check"></i>
                                ` : void 0}</div>
                        <div class="center-col">${r.photoCount}</div>
                        ${this.selected_member ? void 0 : S`<div class="center-col">${r.modified_by}</div>`}
                                `
      )}
                </div>` : S`please select a date`;
    }
  };
  yo.styles = Ue(xI);
  yo.properties = {
    ...$I(yo, yo, "properties"),
    selected_context: { type: String },
    selected_date: { type: Date },
    selected_member: { type: String },
    fetching: { type: Boolean },
    sort_by: { type: Array },
    term_for_cm: { type: String }
  };
  yo = EI([
    tt("cm-widget")
  ], yo);
  const OI = '.col-bg-body-lighter{background-color:var(--col-bg-body-lighter)}.col-bg-body{background-color:var(--col-bg-body)}.col-bg-body-darker{background-color:var(--col-bg-body-darker)}.col-bg-1-lighter{background-color:var(--col-bg-1-lighter)}.col-bg-1{background-color:var(--col-bg-1)}.col-bg-1-darker{background-color:var(--col-bg-1-darker)}.col-bg-1-input{background-color:var(--col-bg-1-input)}.col-primary-bg-1{background-color:var(--col-primary-bg-1)}.col-accent-bg-1{background-color:var(--col-accent-bg-1)}.col-success-bg-1{background-color:var(--col-success-bg-1)}.col-warning-bg-1{background-color:var(--col-warning-bg-1)}.col-error-bg-1{background-color:var(--col-error-bg-1)}.col-bg-2-lighter{background-color:var(--col-bg-2-lighter)}.col-bg-2{background-color:var(--col-bg-2)}.col-bg-2-darker{background-color:var(--col-bg-2-darker)}.col-bg-2-button{background-color:var(--col-bg-2-button)}.col-bg-2-input{background-color:var(--col-bg-2-input)}.col-primary-bg-2{background-color:var(--col-primary-bg-2)}.col-accent-bg-2{background-color:var(--col-accent-bg-2)}.col-success-bg-2{background-color:var(--col-success-bg-2)}.col-warning-bg-2{background-color:var(--col-warning-bg-2)}.col-error-bg-2{background-color:var(--col-error-bg-2)}.col-bg-3-lighter{background-color:var(--col-bg-3-lighter)}.col-bg-3{background-color:var(--col-bg-3)}.col-bg-3-darker{background-color:var(--col-bg-3-darker)}.col-bg-3-button{background-color:var(--col-bg-3-button)}.col-bg-3-input{background-color:var(--col-bg-3-input)}.col-primary-bg-3{background-color:var(--col-primary-bg-3)}.col-accent-bg-3{background-color:var(--col-accent-bg-3)}.col-success-bg-3{background-color:var(--col-success-bg-3)}.col-warning-bg-3{background-color:var(--col-warning-bg-3)}.col-error-bg-3{background-color:var(--col-error-bg-3)}.col-bg-ack-lighter{background-color:var(--col-bg-ack-lighter)}.col-bg-ack{background-color:var(--col-bg-ack)}.col-bg-ack-darker{background-color:var(--col-bg-ack-darker)}.col-primary-bg-ack{background-color:var(--col-primary-bg-ack)}.col-accent-bg-ack{background-color:var(--col-accent-bg-ack)}.col-bg-att-lighter{background-color:var(--col-bg-att-lighter)}.col-bg-att{background-color:var(--col-bg-att)}.col-bg-att-darker{background-color:var(--col-bg-att-darker)}.col-primary-bg-att{background-color:var(--col-primary-bg-att)}.col-accent-bg-att{background-color:var(--col-accent-bg-att)}.col-bg-alert-lighter{background-color:var(--col-bg-alert-lighter)}.col-bg-alert{background-color:var(--col-bg-alert)}.col-bg-alert-darker{background-color:var(--col-bg-alert-darker)}.col-primary-bg-alert{background-color:var(--col-primary-bg-alert)}.col-accent-bg-alert{background-color:var(--col-accent-bg-alert)}.col-bg-btn-lighter{background-color:var(--col-bg-btn-lighter)}.col-bg-btn{background-color:var(--col-bg-btn)}.col-bg-btn-darker{background-color:var(--col-bg-btn-darker)}.col-primary-bg-btn{background-color:var(--col-primary-bg-btn)}.col-accent-bg-btn{background-color:var(--col-accent-bg-btn)}.pattern-diagonal-stripes-sm{background:repeating-linear-gradient(45deg,transparent,transparent 10px,currentColor 10px,currentColor 20px)}.pattern-dots-lg{background-image:radial-gradient(currentColor 1.5px,transparent 1.5px);background-size:15px 15px}.pattern-dots-md{background-image:radial-gradient(currentColor 1px,transparent 1px);background-size:8px 8px}.pattern-dots-medium-dense{background-image:radial-gradient(currentColor .5px,transparent .5px);background-size:3px 3px}.pattern-dots-sm{background-image:radial-gradient(currentColor .5px,transparent .5px);background-size:5px 5px}.pattern-cross-dots-md,.imagelist-background{background-image:radial-gradient(currentColor .7px,transparent 1px),radial-gradient(currentColor .7px,transparent 1px);background-size:6.5px 6.5px;background-position:0 0,3.5px 3.5px}.imagelist-background{background-color:#fff9;background-blend-mode:overlay}.fa,.fas{font-family:"Font Awesome 5 Free";font-weight:900;font-style:normal}.fa-trash:before{content:""}.fa-view-grid:before{content:""}.fa-view-list:before{content:""}.fa-camera:before{content:""}.fa-view-image:before{content:""}.fa-check:before{content:""}.fa-exclamation-circle:before{content:""}.fa-list-check:before{content:""}.fa-backward:before{content:""}.fa-forward:before{content:""}.fa-backward-fast:before{content:""}.fa-forward-fast:before{content:""}p,div{padding:0;margin:0;border:0px;user-select:text;-webkit-user-select:text}select{user-select:none;-webkit-user-select:none}.list-header{position:sticky;z-index:1;top:0}:host{background-color:var(--col-bg-body);display:block;border:solid 2px var(--col-bg-1-darker);overflow-y:hidden;padding-bottom:.5em}div,p{font-family:var(--standard-text-font)}.feature-list{display:grid;overflow-y:scroll;height:100%;width:100%;max-height:35vh;grid-row-gap:5px;grid-template-rows:[header] auto;grid-template-columns:repeat(4,auto);border-top:solid var(--col-bg-1-darker) 2px}.feature-list div{padding-right:1em}.feature-list.feature-list-with-member{grid-template-columns:repeat(5,auto)}.list-header{background:var(--col-bg-1-lighter);font-weight:700;padding-top:1em;border-bottom:solid var(--col-bg-1-darker) 1px}.list-identifier{cursor:pointer;text-decoration:underline}.headline{background-color:var(--col-bg-1-lighter);color:var(--col-primary-bg-1);padding:2px;font-weight:700}.controls{display:flex;flex-direction:row;background-color:var(--col-bg-1-lighter);color:var(--col-primary-bg-1);padding:2px;font-weight:700;justify-content:space-between}.no-data{padding:2px}#sort-type-selector{padding-right:1em}.center-col{display:flex;justify-content:center}';
  var DI = Object.getOwnPropertyDescriptor, PI = Object.getPrototypeOf, II = Reflect.get, MI = (r, e, t, i) => {
    for (var o = i > 1 ? void 0 : i ? DI(e, t) : e, a = r.length - 1, l; a >= 0; a--)
      (l = r[a]) && (o = l(o) || o);
    return o;
  }, NI = (r, e, t) => II(PI(r), t, e);
  class LI {
  }
  let wo = class extends Re {
    constructor() {
      super(), this.login_token = "", this.api_url = "", this.selected_date = null, this.selected_context = "", this.selected_context_uid = "", this.selected_member = "", this.features = [], this.fetching = !1, this.fetch_error = "", this.featureCount = 0, this.selected_sort = "identifier", this.selected_context_type = "", this.term_for_feature = "feature", this.plural_for_feature = "features", this.sort_by = {
        identifier: ["identifier", "modified"],
        creation: ["created", "identifier"]
      };
    }
    get_conditions(r) {
      let e = this.selected_context, t = `unit_type = 'feature' and record_type in ('unit', 'dayplan') and modified_date = '${r}'`;
      return e && (this.selected_context_type === "feature" ? t = t + ` and identifier = '${e}'` : t = t + ` and "id_uuid" in (select "uid_dst_unit" from unit_unit_relation where "uid_src_unit"='${this.selected_context_uid}')`), this.selected_member && (t = t + ` and modified_by ='${this.selected_member}'`), t;
    }
    fetch_data() {
      this.fetching = !0;
      const r = Zr(this.selected_date), e = `
            id_uuid, primary_identifier, identifier, recorder, created, modified_by, modified_date, 
            record_type, type, unit_type, count(data_uuid) c 
            from {base} 
            where ${this.get_conditions(r)}
            group by id_uuid, primary_identifier, identifier, recorder, created, modified_by, modified_date, 
            record_type, type, unit_type         
        `, t = {
        cql: {
          base: {
            scope: {
              unit: {
                feature_unit: {
                  dayplan: {
                    join: "inner(uid_unit, uid_unit)"
                  },
                  locus: {
                    join: "inner(uid_unit, uid_unit)",
                    relates_to: {
                      collected_material: {}
                    }
                  }
                }
              }
            },
            target: {
              field_or_instruction: "modified_ww()"
            },
            additional_fields: {
              // "id_uuid": {
              //     "field_or_instruction": "id_uuid",
              //     "default": "",
              // },
              modified_date: {
                field_or_instruction: "modified_ww()",
                default: "",
                format: "datetime(date)"
              },
              modified_by: {
                field_or_instruction: "replfield_modified_by()",
                default: "",
                format: "dsd_type(varchar)"
              },
              modified_timestamp: {
                field_or_instruction: "modified_ww()",
                default: ""
              },
              created: {
                field_or_instruction: "feature_unit.replfield_created()",
                default: "null",
                format: "datetime(date)"
              },
              type: {
                field_or_instruction: "feature_unit.feature_type",
                default: "",
                format: "dsd_type(varchar)"
              },
              unit_type: {
                field_or_instruction: "unit.type",
                default: "",
                format: "dsd_type(varchar)"
              },
              recorder: {
                field_or_instruction: "unit.id_excavator",
                default: "",
                format: "dsd_type(varchar)"
              }
            }
          },
          meta: {
            version: 0.1
          },
          query: {
            type: "DirectSqlQuery",
            sql: e
          }
        }
      };
      this.apiContext.fetchFromApi(
        "",
        "cql/query",
        {
          method: "POST",
          body: JSON.stringify(t),
          caller: "featurewidget.fetch_data"
        }
      ).then((i) => {
        i.result_msg !== "ok" ? this.fetch_error = i.result_msg : (this.fetch_error = "", this.load_records(i.records)), this.fetching = !1;
      }).catch((i) => {
        dt(this, i, "featureWidget.fetch_data", null);
      });
    }
    load_records(r) {
      this.features = [];
      let e = {};
      r.forEach((t) => {
        const i = t.identifier;
        let o;
        i in e ? o = e[i] : (o = new LI(), e[i] = o, this.features.push(o), o.photoCount = 0, o.type = "?", o.modified = 0, o.feature_creation = "?", o.modified_by = ""), o.identifier = t.identifier, o.uid = t.id_uuid, t.modified > o.modified && (o.modified = t.modified), o.modified_by = t.modified_by, t.type && (o.type = t.type), t.created && (o.feature_creation = xr(t.created).toLocaleDateString(), o.created = xr(t.created).getTime()), t.record_type == "dayplan" && (o.photoCount = t.c);
      }), this.featureCount = Object.keys(this.features).length, this.sort_records(this.sort_by[this.selected_sort]);
    }
    sort_records(r) {
      function e(t, i) {
        for (let o = 0; o < r.length; o++) {
          let a = r[o], l = t[a], d = i[a], u = 0;
          if (typeof l == "string" ? u = l.localeCompare(d) : typeof l == "boolean" ? (l && !d && (u = -1), !l && d && (u = 1)) : (l < d && (u = -1), l > d && (u = 1)), u != 0)
            return u;
        }
        return 0;
      }
      this.features.sort(e), this.requestUpdate();
    }
    stateChanged(r) {
      if (this.fetch_error)
        return S`Error fetching: ${this.fetch_error}`;
      if (r.initState == 0)
        return;
      let e = !1;
      if ("dateSelector" in r.selectors) {
        let t = r.selectors.dateSelector.selectedDate;
        if ((!this.selected_date || t.getTime() !== this.selected_date.getTime()) && (this.selected_date = t, e = !0), "contextSelector" in r.selectors) {
          let i = r.selectors.contextSelector.selectedContext;
          i !== this.selected_context && (this.selected_context = i, this.selected_context_uid = r.selectors.contextSelector.selectedUid, this.selected_context_type = r.selectors.contextSelector.selectedContextType, e = !0);
        }
        if ("teamSelector" in r.selectors) {
          let i = r.selectors.teamSelector.selectedMember;
          i !== this.selected_member && (this.selected_member = i, e = !0);
        }
        e && this.fetch_data();
      }
      r.constants.length > 0 && (this.term_for_feature = Ye(
        r.constants,
        "standard_term_for_feature_unit",
        !1,
        this.term_for_feature
      ), this.plural_for_feature = Ye(
        r.constants,
        "standard_term_for_feature_unit",
        !0,
        this.plural_for_feature
      ));
    }
    apiRender() {
      return S`
                    <div class="feature-widget">
                        <div class="headline">
                            <p>${this.featureCount} ${this.featureCount == 1 ? this.term_for_feature : this.plural_for_feature}</p>
                        </div>
                        <div class="controls">
                            <div class="controls-left">
                                ${this.renderSortSelector()}
                            </div>
                        </div>
                        ${this.selected_date !== null ? this.render_widget() : S`Please select a date`}
                    </div>`;
    }
    sortTypeChanged(r) {
      this.selected_sort = r.currentTarget.value, this.sort_records(this.sort_by[this.selected_sort]);
    }
    renderSortSelector() {
      return S`
            <label for="sort-type-selector">sort by</label>
            <select name="sort-type-selector" id="sort-type-selector" @change="${this.sortTypeChanged}">
                ${Object.keys(this.sort_by).map(
        (r) => S`
                            <option value="${r}"
                                    ?selected="${this.selected_sort === r}">
                                ${r}
                            </option>
                        `
      )}
            </select>
        `;
    }
    changeContext(r) {
      let e = { selectedContext: "", selectedUid: "", selectedContextType: "" };
      if (r) {
        let t = this.features.find((i) => i.identifier === r);
        e.selectedContext = t.identifier, e.selectedUid = t.uid, e.selectedContextType = "feature", je.dispatch(tr("contextSelector", e));
      }
    }
    gotoIdentifier(r) {
      const e = r.currentTarget.getAttribute("context");
      e != this.selected_context && this.changeContext(e);
    }
    render_widget() {
      return this.selected_date ? this.fetching ? S`fetching data ...` : this.featureCount == 0 ? S`
                    <div class="no-data">
                        <p>No data found for your selection</p>
                    </div>` : S`
                    <div class="feature-list ${this.selected_member ? void 0 : "feature-list-with-member"}">
                        <div class="list-header">identifier</div>
                        <div class="list-header">type</div>
                        <div class="list-header">creation</div>
                        <div class="list-header">photos</div>
                        ${this.selected_member ? void 0 : S`<div class="list-header">by</div>`}
                        ${this.features.map(
        (r) => S`
                                    <div class="list-identifier" context=${r.identifier} @click=${this.gotoIdentifier}>${r.identifier}</div>
                                    <div>${r.type}</div>
                                    <div>${r.feature_creation}</div>
                                    <div class="center-col">${r.photoCount}</div>
                                    ${this.selected_member ? void 0 : S`<div class="center-col">${r.modified_by}</div>`}
                                `
      )}
                        
                    </div>` : S`please select a date`;
    }
  };
  wo.styles = Ue(OI);
  wo.properties = {
    ...NI(wo, wo, "properties"),
    selected_context: { type: String },
    selected_date: { type: Date },
    selected_member: { type: String },
    fetching: { type: Boolean },
    sort_by: { type: Array },
    term_for_feature: { type: String }
  };
  wo = MI([
    tt("feature-widget")
  ], wo);
  const RI = '.col-bg-body-lighter{background-color:var(--col-bg-body-lighter)}.col-bg-body{background-color:var(--col-bg-body)}.col-bg-body-darker{background-color:var(--col-bg-body-darker)}.col-bg-1-lighter{background-color:var(--col-bg-1-lighter)}.col-bg-1{background-color:var(--col-bg-1)}.col-bg-1-darker{background-color:var(--col-bg-1-darker)}.col-bg-1-input{background-color:var(--col-bg-1-input)}.col-primary-bg-1{background-color:var(--col-primary-bg-1)}.col-accent-bg-1{background-color:var(--col-accent-bg-1)}.col-success-bg-1{background-color:var(--col-success-bg-1)}.col-warning-bg-1{background-color:var(--col-warning-bg-1)}.col-error-bg-1{background-color:var(--col-error-bg-1)}.col-bg-2-lighter{background-color:var(--col-bg-2-lighter)}.col-bg-2{background-color:var(--col-bg-2)}.col-bg-2-darker{background-color:var(--col-bg-2-darker)}.col-bg-2-button{background-color:var(--col-bg-2-button)}.col-bg-2-input{background-color:var(--col-bg-2-input)}.col-primary-bg-2{background-color:var(--col-primary-bg-2)}.col-accent-bg-2{background-color:var(--col-accent-bg-2)}.col-success-bg-2{background-color:var(--col-success-bg-2)}.col-warning-bg-2{background-color:var(--col-warning-bg-2)}.col-error-bg-2{background-color:var(--col-error-bg-2)}.col-bg-3-lighter{background-color:var(--col-bg-3-lighter)}.col-bg-3{background-color:var(--col-bg-3)}.col-bg-3-darker{background-color:var(--col-bg-3-darker)}.col-bg-3-button{background-color:var(--col-bg-3-button)}.col-bg-3-input{background-color:var(--col-bg-3-input)}.col-primary-bg-3{background-color:var(--col-primary-bg-3)}.col-accent-bg-3{background-color:var(--col-accent-bg-3)}.col-success-bg-3{background-color:var(--col-success-bg-3)}.col-warning-bg-3{background-color:var(--col-warning-bg-3)}.col-error-bg-3{background-color:var(--col-error-bg-3)}.col-bg-ack-lighter{background-color:var(--col-bg-ack-lighter)}.col-bg-ack{background-color:var(--col-bg-ack)}.col-bg-ack-darker{background-color:var(--col-bg-ack-darker)}.col-primary-bg-ack{background-color:var(--col-primary-bg-ack)}.col-accent-bg-ack{background-color:var(--col-accent-bg-ack)}.col-bg-att-lighter{background-color:var(--col-bg-att-lighter)}.col-bg-att{background-color:var(--col-bg-att)}.col-bg-att-darker{background-color:var(--col-bg-att-darker)}.col-primary-bg-att{background-color:var(--col-primary-bg-att)}.col-accent-bg-att{background-color:var(--col-accent-bg-att)}.col-bg-alert-lighter{background-color:var(--col-bg-alert-lighter)}.col-bg-alert{background-color:var(--col-bg-alert)}.col-bg-alert-darker{background-color:var(--col-bg-alert-darker)}.col-primary-bg-alert{background-color:var(--col-primary-bg-alert)}.col-accent-bg-alert{background-color:var(--col-accent-bg-alert)}.col-bg-btn-lighter{background-color:var(--col-bg-btn-lighter)}.col-bg-btn{background-color:var(--col-bg-btn)}.col-bg-btn-darker{background-color:var(--col-bg-btn-darker)}.col-primary-bg-btn{background-color:var(--col-primary-bg-btn)}.col-accent-bg-btn{background-color:var(--col-accent-bg-btn)}.pattern-diagonal-stripes-sm{background:repeating-linear-gradient(45deg,transparent,transparent 10px,currentColor 10px,currentColor 20px)}.pattern-dots-lg{background-image:radial-gradient(currentColor 1.5px,transparent 1.5px);background-size:15px 15px}.pattern-dots-md{background-image:radial-gradient(currentColor 1px,transparent 1px);background-size:8px 8px}.pattern-dots-medium-dense{background-image:radial-gradient(currentColor .5px,transparent .5px);background-size:3px 3px}.pattern-dots-sm{background-image:radial-gradient(currentColor .5px,transparent .5px);background-size:5px 5px}.pattern-cross-dots-md,.imagelist-background{background-image:radial-gradient(currentColor .7px,transparent 1px),radial-gradient(currentColor .7px,transparent 1px);background-size:6.5px 6.5px;background-position:0 0,3.5px 3.5px}.imagelist-background{background-color:#fff9;background-blend-mode:overlay}p,div{padding:0;margin:0;border:0px;user-select:text;-webkit-user-select:text}select{user-select:none;-webkit-user-select:none}.fa,.fas{font-family:"Font Awesome 5 Free";font-weight:900;font-style:normal}.fa-trash:before{content:""}.fa-view-grid:before{content:""}.fa-view-list:before{content:""}.fa-camera:before{content:""}.fa-view-image:before{content:""}.fa-check:before{content:""}.fa-exclamation-circle:before{content:""}.fa-list-check:before{content:""}.fa-backward:before{content:""}.fa-forward:before{content:""}.fa-backward-fast:before{content:""}.fa-forward-fast:before{content:""}:host{width:45vw;max-width:45vw;background-color:var(--col-bg-body);display:block;border:solid 2px var(--col-bg-1-darker);box-sizing:border-box;overflow-y:hidden;height:100%}div,p{font-family:var(--standard-text-font);padding:0;box-sizing:border-box}.file-list{overflow-y:scroll;height:100%;width:100%;max-height:35vh}.headline{background-color:var(--col-bg-1-lighter);color:var(--col-primary-bg-1);padding:2px;font-weight:700}.controls{display:flex;flex-direction:row;background-color:var(--col-bg-1-lighter);color:var(--col-primary-bg-1);padding:2px;font-weight:700;justify-content:space-between}.controls i{margin:0 5px;border:1px solid rgba(0,0,0,0);padding:2px;width:1em;height:1em}.controls-left{display:flex;flex-basis:auto;flex-wrap:wrap}.controls-right{min-width:100px;flex-basis:min-content;display:flex}.controls-right i{line-height:1em;text-align:center}.selected-view-mode{background-color:var(--col-bg-ack);color:var(--col-accent-bg-ack);border:1px solid var(--col-bg-1-darker)}.control-container{display:flex;margin-right:1em}label{padding-right:.5em;text-wrap:none;white-space:nowrap}.no-files{padding:2px}.file{font-family:var(--standard-text-font);padding:.2em;border-bottom:var(--col-bg-1-darker) 2px solid;display:flex;flex-direction:row}.file-headline{display:flex;flex-direction:column;margin-left:.5em;width:calc(100% - 1em)}.main-headline{font-weight:700;display:flex;flex-direction:row;justify-content:space-between}.file-grid{display:flex;flex-direction:row;flex-wrap:wrap;overflow-y:scroll;height:100%;width:100%;max-height:35vh;justify-content:space-between}.file-view{display:flex;flex-direction:column;height:100%;padding:0;width:calc(100% - 5px);max-height:35vh;margin:2px;overflow:auto}.grid-cell{display:flex;flex-direction:column;justify-content:space-between}.grid-cell p{margin-bottom:1em}.selected-image{border:2px solid var(--col-bg-1-lighter);box-shadow:2px 2px 10px var(--col-bg-1-lighter);padding:1px}', FI = '.col-bg-body-lighter{background-color:var(--col-bg-body-lighter)}.col-bg-body{background-color:var(--col-bg-body)}.col-bg-body-darker{background-color:var(--col-bg-body-darker)}.col-bg-1-lighter{background-color:var(--col-bg-1-lighter)}.col-bg-1{background-color:var(--col-bg-1)}.col-bg-1-darker{background-color:var(--col-bg-1-darker)}.col-bg-1-input{background-color:var(--col-bg-1-input)}.col-primary-bg-1{background-color:var(--col-primary-bg-1)}.col-accent-bg-1{background-color:var(--col-accent-bg-1)}.col-success-bg-1{background-color:var(--col-success-bg-1)}.col-warning-bg-1{background-color:var(--col-warning-bg-1)}.col-error-bg-1{background-color:var(--col-error-bg-1)}.col-bg-2-lighter{background-color:var(--col-bg-2-lighter)}.col-bg-2{background-color:var(--col-bg-2)}.col-bg-2-darker{background-color:var(--col-bg-2-darker)}.col-bg-2-button{background-color:var(--col-bg-2-button)}.col-bg-2-input{background-color:var(--col-bg-2-input)}.col-primary-bg-2{background-color:var(--col-primary-bg-2)}.col-accent-bg-2{background-color:var(--col-accent-bg-2)}.col-success-bg-2{background-color:var(--col-success-bg-2)}.col-warning-bg-2{background-color:var(--col-warning-bg-2)}.col-error-bg-2{background-color:var(--col-error-bg-2)}.col-bg-3-lighter{background-color:var(--col-bg-3-lighter)}.col-bg-3{background-color:var(--col-bg-3)}.col-bg-3-darker{background-color:var(--col-bg-3-darker)}.col-bg-3-button{background-color:var(--col-bg-3-button)}.col-bg-3-input{background-color:var(--col-bg-3-input)}.col-primary-bg-3{background-color:var(--col-primary-bg-3)}.col-accent-bg-3{background-color:var(--col-accent-bg-3)}.col-success-bg-3{background-color:var(--col-success-bg-3)}.col-warning-bg-3{background-color:var(--col-warning-bg-3)}.col-error-bg-3{background-color:var(--col-error-bg-3)}.col-bg-ack-lighter{background-color:var(--col-bg-ack-lighter)}.col-bg-ack{background-color:var(--col-bg-ack)}.col-bg-ack-darker{background-color:var(--col-bg-ack-darker)}.col-primary-bg-ack{background-color:var(--col-primary-bg-ack)}.col-accent-bg-ack{background-color:var(--col-accent-bg-ack)}.col-bg-att-lighter{background-color:var(--col-bg-att-lighter)}.col-bg-att{background-color:var(--col-bg-att)}.col-bg-att-darker{background-color:var(--col-bg-att-darker)}.col-primary-bg-att{background-color:var(--col-primary-bg-att)}.col-accent-bg-att{background-color:var(--col-accent-bg-att)}.col-bg-alert-lighter{background-color:var(--col-bg-alert-lighter)}.col-bg-alert{background-color:var(--col-bg-alert)}.col-bg-alert-darker{background-color:var(--col-bg-alert-darker)}.col-primary-bg-alert{background-color:var(--col-primary-bg-alert)}.col-accent-bg-alert{background-color:var(--col-accent-bg-alert)}.col-bg-btn-lighter{background-color:var(--col-bg-btn-lighter)}.col-bg-btn{background-color:var(--col-bg-btn)}.col-bg-btn-darker{background-color:var(--col-bg-btn-darker)}.col-primary-bg-btn{background-color:var(--col-primary-bg-btn)}.col-accent-bg-btn{background-color:var(--col-accent-bg-btn)}.pattern-diagonal-stripes-sm{background:repeating-linear-gradient(45deg,transparent,transparent 10px,currentColor 10px,currentColor 20px)}.pattern-dots-lg{background-image:radial-gradient(currentColor 1.5px,transparent 1.5px);background-size:15px 15px}.pattern-dots-md{background-image:radial-gradient(currentColor 1px,transparent 1px);background-size:8px 8px}.pattern-dots-medium-dense{background-image:radial-gradient(currentColor .5px,transparent .5px);background-size:3px 3px}.pattern-dots-sm{background-image:radial-gradient(currentColor .5px,transparent .5px);background-size:5px 5px}.pattern-cross-dots-md,.imagelist-background{background-image:radial-gradient(currentColor .7px,transparent 1px),radial-gradient(currentColor .7px,transparent 1px);background-size:6.5px 6.5px;background-position:0 0,3.5px 3.5px}.imagelist-background{background-color:#fff9;background-blend-mode:overlay}p,div{padding:0;margin:0;border:0px;user-select:text;-webkit-user-select:text}select{user-select:none;-webkit-user-select:none}.fa,.fas{font-family:"Font Awesome 5 Free";font-weight:900;font-style:normal}.fa-trash:before{content:""}.fa-view-grid:before{content:""}.fa-view-list:before{content:""}.fa-camera:before{content:""}.fa-view-image:before{content:""}.fa-check:before{content:""}.fa-exclamation-circle:before{content:""}.fa-list-check:before{content:""}.fa-backward:before{content:""}.fa-forward:before{content:""}.fa-backward-fast:before{content:""}.fa-forward-fast:before{content:""}:host{display:block;padding:2px;box-sizing:border-box}div,p{font-family:var(--standard-text-font);box-sizing:border-box}.placeholder{width:128px;height:128px;display:flex;justify-content:center;align-items:center}.placeholder i{font-size:2em}img{object-fit:contain;width:100%;height:100%}';
  var zI = Object.getOwnPropertyDescriptor, HI = Object.getPrototypeOf, UI = Reflect.get, WI = (r, e, t, i) => {
    for (var o = i > 1 ? void 0 : i ? zI(e, t) : e, a = r.length - 1, l; a >= 0; a--)
      (l = r[a]) && (o = l(o) || o);
    return o;
  }, BI = (r, e, t) => UI(HI(r), t, e);
  let ko = class extends Re {
    constructor() {
      super(), this._resolution = "", this.description = "", this._visible = !1, this.loaded = !1, this.imageUrl = "", this.observer = null, this._uuid_file = "", this.observerCallback = this.observerCallback.bind(this), this._init();
    }
    get uuid_file() {
      return this._uuid_file;
    }
    set uuid_file(e) {
      e !== this._uuid_file && (this._uuid_file = e, this.load_image());
    }
    get resolution() {
      return this._resolution;
    }
    set resolution(e) {
      e !== this._resolution && (this._resolution = e, this.load_image());
    }
    get visible() {
      return this._visible;
    }
    set visible(e) {
      e !== this._visible && (this._visible = e, this.load_image());
    }
    _init() {
      this._visible = !1, this.loaded = !1;
    }
    connectedCallback() {
      super.connectedCallback(), this.setAttribute("role", "presentation"), this.initIntersectionObserver();
    }
    disconnectedCallback() {
      super.disconnectedCallback(), this.disconnectObserver();
    }
    /**
     * Sets the `intersecting` property when the element is on screen.
     * @param  {[IntersectionObserverEntry]} entries
     * @protected
     */
    observerCallback(e) {
      const t = ({ isIntersecting: i }) => i;
      e.some(t) && (this.visible = !0);
    }
    /**
     * Initializes the IntersectionObserver when the element instantiates.
     * @protected
     */
    initIntersectionObserver() {
      if (!("IntersectionObserver" in window)) return this.visible = !0;
      if (this.observer) return;
      const e = "10px";
      this.observer = new IntersectionObserver(this.observerCallback, { rootMargin: e }), this.observer.observe(this);
    }
    /**
     * Disconnects and unloads the IntersectionObserver.
     * @protected
     */
    disconnectObserver() {
      this.observer.disconnect(), this.observer = null, delete this.observer;
    }
    clicked() {
      this.dispatchEvent(new CustomEvent(
        "select-image",
        {
          bubbles: !0,
          composed: !0,
          detail: {
            uuid: this.uuid_file,
            width: this.width ?? "0",
            height: this.height ?? "0"
          }
        }
      ));
    }
    fetch_image() {
      this.loaded = !1;
      const e = {};
      let t = new URLSearchParams({
        uuid: this._uuid_file,
        resolution: this._resolution
      });
      this.apiContext.fetchBlobFromApi(
        "",
        "files/file",
        {
          method: "GET",
          caller: "directorsview.fileview"
        },
        "v1",
        t,
        void 0,
        e
      ).then((i) => {
        this.imageUrl = URL.createObjectURL(i), this.loaded = !0, e.hasOwnProperty("width") && e.hasOwnProperty("height") && (this.width = e.width, this.height = e.height);
      }).catch((i) => {
        i.response.status != 404 && dt(this, i, "fileview.fetch_image", null);
      });
    }
    load_image() {
      this._resolution && this._uuid_file && this._visible && this.fetch_image();
    }
    render_image() {
      return S`<img @click="${this.clicked}" src="${this.imageUrl}" alt="${this.description}"/>`;
    }
    render_placeholder() {
      return S`
            <div class="placeholder"><i class="fa fa-camera"></i></div>`;
    }
    apiRender() {
      return S`
                    ${this.loaded ? this.render_image() : this.render_placeholder()}
                    </div>`;
    }
  };
  ko.styles = Ue(FI);
  ko.properties = {
    ...BI(ko, ko, "properties"),
    uuid_file: { type: String },
    resolution: { type: String },
    loaded: { type: Boolean },
    imageUrl: { type: String },
    visible: { type: Boolean },
    description: { type: String }
  };
  ko = WI([
    tt("file-view")
  ], ko);
  var VI = Object.getOwnPropertyDescriptor, qI = Object.getPrototypeOf, YI = Reflect.get, GI = (r, e, t, i) => {
    for (var o = i > 1 ? void 0 : i ? VI(e, t) : e, a = r.length - 1, l; a >= 0; a--)
      (l = r[a]) && (o = l(o) || o);
    return o;
  }, jI = (r, e, t) => YI(qI(r), t, e);
  class ZI {
  }
  let xo = class extends Re {
    constructor() {
      super(), this.selected_date = null, this.selected_context = "", this.selected_member = "", this.selected_image = "", this.selected_sort = "modified", this.selected_resolution = "", this.files = [], this.fetching = !1, this.fetch_error = "", this.viewMode = "list", this.sort_by = {
        modified: ["modified", "identifier"],
        identifier: ["primary_identifier", "identifier", "created"]
      }, this.record_types = /* @__PURE__ */ new Set(), this.show_record_types = "", this.record_type_names = null, this.record_count = 0, this.page_size = 0;
    }
    connectedCallback() {
      super.connectedCallback(), this.fetchResolutions();
    }
    fetchResolutions() {
      this.selected_resolution || this.apiContext && this.apiContext.fetchFromApi(
        "",
        "files/resolutions",
        {
          method: "GET",
          caller: "filewidget.fetch_resolutions"
        }
      ).then((r) => {
        je.dispatch(LS("filewidget", "resolutions", r));
      }).catch((r) => {
        dt(this, r, "fileWidget.fetchResolutions", null);
      });
    }
    get_conditions(r, e, t) {
      if (e || t) {
        let i = [`equals(modified_date, ${r})`];
        return e && i.push(`equals(base_identifier, '${e}')`), t && i.push(`equals(modified_by, '${t}')`), {
          AND: i
        };
      } else
        return {
          "?": `equals(modified_date, ${r})`
        };
    }
    fetch_data() {
      this.fetching = !0;
      const r = Zr(this.selected_date), e = this.get_conditions(r, this.selected_context, this.selected_member);
      this.apiContext.fetchFromApi(
        "",
        "cql/query",
        {
          method: "POST",
          caller: "filewidget.fetch_data",
          body: JSON.stringify(
            {
              cql: {
                base: {
                  scope: {
                    site: {
                      site_notes: {
                        site_note_photo: {
                          join: "inner(uid, uid_site_note)"
                        }
                      }
                    },
                    unit: "browse()"
                  },
                  target: {
                    field_or_instruction: "uid_file()"
                  },
                  additional_fields: {
                    modified_date: {
                      field_or_instruction: "modified_ww()",
                      default: "",
                      format: "datetime(date)"
                    },
                    modified_timestamp: {
                      field_or_instruction: "modified_ww",
                      default: ""
                    },
                    modified_by: {
                      field_or_instruction: "modified_by",
                      default: ""
                    },
                    description: {
                      field_or_instruction: "describes_file()",
                      default: "null"
                    },
                    image_description: {
                      field_or_instruction: "uid_file()",
                      default: "",
                      substitute: "lookup('images','uid','description')"
                    },
                    filename: {
                      field_or_instruction: "uid_file()",
                      default: "",
                      substitute: "lookup('images','uid','export_filename')"
                    }
                  }
                },
                meta: {
                  version: 0.1
                },
                query: {
                  columns: {
                    base_identifier: {
                      source_field: "identifier"
                    },
                    identifier: {
                      source_field: "primary_identifier"
                    },
                    modified_date: {
                      source_field: "modified_date"
                    },
                    modified_timestamp: {
                      source_field: "modified_timestamp"
                    },
                    modified_by: {
                      source_field: "modified_by"
                    },
                    description: {
                      source_field: "description"
                    },
                    image_description: {
                      source_field: "image_description"
                    },
                    filename: {
                      source_field: "filename"
                    },
                    record_type: {
                      source_field: "record_type"
                    },
                    uid_file: {
                      source_field: "data"
                    }
                  },
                  conditions: e,
                  distinct: "True",
                  type: "Raw"
                }
              }
            }
          )
        }
      ).then((t) => {
        t.result_msg !== "ok" ? (this.record_count = 0, this.fetch_error = t.result_msg) : (this.fetch_error = "", this.record_count = t.overall_record_count, this.page_size = t.page_size, this.load_files(t.records)), this.fetching = !1;
      }).catch((t) => {
        dt(this, t, "filewidget.fetch_data", null);
      });
    }
    load_files(r) {
      this.files = [], this.record_types = /* @__PURE__ */ new Set(), r.forEach((e) => {
        let t = new ZI();
        t.identifier = e.identifier, t.modified_by = e.modified_by ? e.modified_by : "?", t.modified = z.fromISO(e.modified_timestamp).toJSDate(), t.uid_file = e.uid_file, t.description = e.description, t.image_description = e.image_description, t.filename = e.filename, t.record_type = e.record_type, this.record_types.add(e.record_type), this.files.push(t);
      }), this.sort_records(this.sort_by[this.selected_sort]);
    }
    sort_records(r) {
      function e(i, o) {
        for (let a = 0; a < r.length; a++) {
          let l = r[a], d = i[l], u = o[l], f = 0;
          if (typeof d == "string" ? f = d.localeCompare(u) : (d < u && (f = -1), d > u && (f = 1)), f != 0)
            return f;
        }
        return 0;
      }
      this.files.sort(e);
      let t = "";
      this.files.forEach((i) => {
        (i.uid_file === this.selected_image || !t) && (t = i.uid_file);
      }), this.selected_image = t, this.requestUpdate();
    }
    // protected changeContext(context: string) {
    //     store.dispatch(setSelector("contextSelector", {"selectedContext": context}))
    // }
    setSmallestResolution(r) {
      let e = -1, t = "";
      for (let i = 0; i < r.length; i++) {
        let o = r[i].height * r[i].width;
        (e > o || e == -1) && (e = o, t = r[i].id);
      }
      return this.selected_resolution === t ? !1 : (this.selected_resolution = t, !0);
    }
    stateChanged(r) {
      let e = !1;
      if (r.initState != 0 && "dateSelector" in r.selectors && "filewidget" in r.dataviews) {
        let t = r.dataviews.filewidget;
        if ("resolutions" in t) {
          e = this.setSmallestResolution(t.resolutions);
          let i = r.selectors.dateSelector.selectedDate;
          if ((!this.selected_date || i.getTime() !== this.selected_date.getTime()) && (this.selected_date = i, e = !0), "contextSelector" in r.selectors) {
            let o = r.selectors.contextSelector.selectedContext;
            o !== this.selected_context && (this.selected_context = o, e = !0);
          }
          if ("teamSelector" in r.selectors) {
            let o = r.selectors.teamSelector.selectedMember;
            o !== this.selected_member && (this.selected_member = o, e = !0);
          }
          e && this.fetch_data();
        }
        r.constants.length > 0 && !this.record_type_names && (this.record_type_names = La(r.constants), e || this.requestUpdate());
      }
    }
    recordTypeChanged(r) {
      const e = r.currentTarget.value;
      e === " all" ? this.show_record_types = "" : this.show_record_types = e;
    }
    gridView(r) {
      this.viewMode = "grid";
    }
    listView(r) {
      this.viewMode = "list";
    }
    imageView(r) {
      this.viewMode = "image";
    }
    selectImage(r) {
      const e = r.detail.uuid;
      this.selected_image = e, r.detail.fileList = [
        { uuid: r.detail.uuid, width: r.detail.width, height: r.detail.height }
      ];
    }
    // This approach is not possible because many files have not been loaded as thumbnails and hence width and height are not there
    // To make this work width and height would have to be transported with the CQL query.
    //
    // getCurrentFileList() {
    //     return this.files.filter(file => (this.show_record_types === "" || file.record_type === this.show_record_types))
    //         .map((file) => {
    //
    //             return {
    //                 uuid: e.detail.uuid, width: e.detail.width, height: e.detail.height
    //             }
    //     } )
    //     ${this.files.map(file => html`
    //                 ${(this.show_record_types === "" || file.record_type === this.show_record_types)
    //         return [
    //
    //     ]
    // }
    apiRender() {
      const r = this.files.filter((e) => this.show_record_types === "" || e.record_type === this.show_record_types).length;
      return S`
                    <div class="file-widget">
                        <div class="headline">
                            <p>${r > this.page_size ? S`${this.page_size} of ${r}` : S`${r}`} Files</p>
                        </div>
                        <div class="controls">
                            <div class="controls-left">
                                ${this.renderRecordTypeSelector()}
                                ${this.renderSortSelector()}
                            </div>
                            <div class="controls-right">
                                <i @click=${this.listView}
                                   class="fa fa-view-list ${this.viewMode === "list" ? "selected-view-mode" : ""}"></i>
                                <i @click=${this.gridView}
                                   class="fa fa-view-grid ${this.viewMode === "grid" ? "selected-view-mode" : ""}"></i>
                            </div>
                        </div>
                        ${this.selected_date !== null && this.selected_resolution ? this.render_widget() : S`waiting for selection or server information...`}
                    </div>`;
    }
    renderRecordTypeSelector() {
      if (!this.selected_date)
        return S``;
      let r = Array.from(this.record_types);
      r.push(" all"), r.sort();
      let e = this.show_record_types == "" ? " all" : this.show_record_types;
      return S`
            <div class="control-container">
            <label for="record-type-selector">record type</label>
            <select name="record-type-selector" id="record-type-selector" @change="${this.recordTypeChanged}">
                ${r.map(
        (t) => S`
                            <option value="${t}"
                                    ?selected="${e === t}">
                                ${_a(this.record_type_names, t)}
                            </option>
                        `
      )}
            </select></div>
        `;
    }
    render_widget() {
      if (!this.selected_date)
        return S`please select a date`;
      if (this.fetching)
        return S`fetching data ...`;
      if (this.files.length == 0)
        return S`
                    <div class="no-files">
                        <p>No files modified on that date / for that context</p>
                    </div>`;
      if (this.viewMode == "list")
        return this.renderListView();
      if (this.viewMode == "grid")
        return this.renderGridView();
    }
    renderListView() {
      return S`
            <div id="file-list" class="file-list">
                ${this.files.map(
        (r) => S`
                    ${this.show_record_types === "" || r.record_type === this.show_record_types ? S`
                                <div class="file">
                                    <div class="file-body">
                                        <file-view id="${r.uid_file}"
                                                   .apiContext="${this.apiContext}"
                                                   .uuid_file="${r.uid_file}"
                                                   .resolution="${this.selected_resolution}"
                                                   .description="${r.description}"
                                                   class="${this.selected_image === r.uid_file ? "selected-image" : void 0}"
                                                   @select-image="${this.selectImage}"
                                        >
                                        </file-view>
                                    </div>
                                    <div class="file-headline">
                                        <div class="main-headline">
                                            <p>${r.identifier}</p>
                                            <p>by: ${r.modified_by}
                                                    (${r.modified.toLocaleTimeString(
          [],
          { hour: "2-digit", minute: "2-digit" }
        )})
                                            </p>
                                        </div>
                                        <p>${_a(this.record_type_names, r.record_type)}</p>
                                        <p>${r.description}</p>
                                        <p>${r.image_description}</p>
                                        ${r.filename ? S`<p>filename: ${r.filename}</p>` : void 0}
                                    </div>
                                </div>` : void 0}`
      )}
            </div>`;
    }
    renderGridView() {
      return S`
            <div class="file-grid">
                ${this.files.map(
        (r) => S`
                    ${this.show_record_types === "" || r.record_type === this.show_record_types ? S`
                                <div class="grid-cell" id="${r.uid_file}">
                                    <file-view @select-image="${this.selectImage}"
                                               .apiContext="${this.apiContext}"
                                               .uuid_file="${r.uid_file}"
                                               .resolution="${this.selected_resolution}"
                                               class="${this.selected_image === r.uid_file ? "selected-image" : void 0}"
                                    >
                                    </file-view>
                                    <p>${r.identifier}</p>
                                </div>` : void 0}`
      )}
            </div>`;
    }
    sortTypeChanged(r) {
      this.selected_sort = r.currentTarget.value, this.sort_records(this.sort_by[this.selected_sort]);
    }
    renderSortSelector() {
      return S`
            <div class="control-container"><label for="sort-type-selector">sort by</label>
            <select name="sort-type-selector" id="sort-type-selector" @change="${this.sortTypeChanged}">
                ${Object.keys(this.sort_by).map(
        (r) => S`
                            <option value="${r}"
                                    ?selected="${this.selected_sort === r}">
                                ${r}
                            </option>
                        `
      )}
            </select></div>
        `;
    }
    updated(r) {
      if (super.updated(r), this.selected_image) {
        let e = this.shadowRoot.getElementById(this.selected_image);
        e && setTimeout(() => {
          e.scrollIntoView({ block: "center", inline: "center" });
        }, 500);
      }
    }
  };
  xo.styles = Ue(RI);
  xo.properties = {
    ...jI(xo, xo, "properties"),
    selected_context: { type: String },
    selected_member: { type: String },
    selected_date: { type: Date },
    selected_resolution: { type: String },
    selected_image: { type: String },
    selected_sort: { type: String },
    fetching: { type: Boolean },
    sort_by: { type: Array },
    viewMode: { type: String },
    show_record_types: { type: String }
  };
  xo = GI([
    tt("file-widget")
  ], xo);
  const KI = '.col-bg-body-lighter{background-color:var(--col-bg-body-lighter)}.col-bg-body{background-color:var(--col-bg-body)}.col-bg-body-darker{background-color:var(--col-bg-body-darker)}.col-bg-1-lighter{background-color:var(--col-bg-1-lighter)}.col-bg-1{background-color:var(--col-bg-1)}.col-bg-1-darker{background-color:var(--col-bg-1-darker)}.col-bg-1-input{background-color:var(--col-bg-1-input)}.col-primary-bg-1{background-color:var(--col-primary-bg-1)}.col-accent-bg-1{background-color:var(--col-accent-bg-1)}.col-success-bg-1{background-color:var(--col-success-bg-1)}.col-warning-bg-1{background-color:var(--col-warning-bg-1)}.col-error-bg-1{background-color:var(--col-error-bg-1)}.col-bg-2-lighter{background-color:var(--col-bg-2-lighter)}.col-bg-2{background-color:var(--col-bg-2)}.col-bg-2-darker{background-color:var(--col-bg-2-darker)}.col-bg-2-button{background-color:var(--col-bg-2-button)}.col-bg-2-input{background-color:var(--col-bg-2-input)}.col-primary-bg-2{background-color:var(--col-primary-bg-2)}.col-accent-bg-2{background-color:var(--col-accent-bg-2)}.col-success-bg-2{background-color:var(--col-success-bg-2)}.col-warning-bg-2{background-color:var(--col-warning-bg-2)}.col-error-bg-2{background-color:var(--col-error-bg-2)}.col-bg-3-lighter{background-color:var(--col-bg-3-lighter)}.col-bg-3{background-color:var(--col-bg-3)}.col-bg-3-darker{background-color:var(--col-bg-3-darker)}.col-bg-3-button{background-color:var(--col-bg-3-button)}.col-bg-3-input{background-color:var(--col-bg-3-input)}.col-primary-bg-3{background-color:var(--col-primary-bg-3)}.col-accent-bg-3{background-color:var(--col-accent-bg-3)}.col-success-bg-3{background-color:var(--col-success-bg-3)}.col-warning-bg-3{background-color:var(--col-warning-bg-3)}.col-error-bg-3{background-color:var(--col-error-bg-3)}.col-bg-ack-lighter{background-color:var(--col-bg-ack-lighter)}.col-bg-ack{background-color:var(--col-bg-ack)}.col-bg-ack-darker{background-color:var(--col-bg-ack-darker)}.col-primary-bg-ack{background-color:var(--col-primary-bg-ack)}.col-accent-bg-ack{background-color:var(--col-accent-bg-ack)}.col-bg-att-lighter{background-color:var(--col-bg-att-lighter)}.col-bg-att{background-color:var(--col-bg-att)}.col-bg-att-darker{background-color:var(--col-bg-att-darker)}.col-primary-bg-att{background-color:var(--col-primary-bg-att)}.col-accent-bg-att{background-color:var(--col-accent-bg-att)}.col-bg-alert-lighter{background-color:var(--col-bg-alert-lighter)}.col-bg-alert{background-color:var(--col-bg-alert)}.col-bg-alert-darker{background-color:var(--col-bg-alert-darker)}.col-primary-bg-alert{background-color:var(--col-primary-bg-alert)}.col-accent-bg-alert{background-color:var(--col-accent-bg-alert)}.col-bg-btn-lighter{background-color:var(--col-bg-btn-lighter)}.col-bg-btn{background-color:var(--col-bg-btn)}.col-bg-btn-darker{background-color:var(--col-bg-btn-darker)}.col-primary-bg-btn{background-color:var(--col-primary-bg-btn)}.col-accent-bg-btn{background-color:var(--col-accent-bg-btn)}.pattern-diagonal-stripes-sm{background:repeating-linear-gradient(45deg,transparent,transparent 10px,currentColor 10px,currentColor 20px)}.pattern-dots-lg{background-image:radial-gradient(currentColor 1.5px,transparent 1.5px);background-size:15px 15px}.pattern-dots-md{background-image:radial-gradient(currentColor 1px,transparent 1px);background-size:8px 8px}.pattern-dots-medium-dense{background-image:radial-gradient(currentColor .5px,transparent .5px);background-size:3px 3px}.pattern-dots-sm{background-image:radial-gradient(currentColor .5px,transparent .5px);background-size:5px 5px}.pattern-cross-dots-md,.imagelist-background{background-image:radial-gradient(currentColor .7px,transparent 1px),radial-gradient(currentColor .7px,transparent 1px);background-size:6.5px 6.5px;background-position:0 0,3.5px 3.5px}.imagelist-background{background-color:#fff9;background-blend-mode:overlay}p,div{padding:0;margin:0;border:0px;user-select:text;-webkit-user-select:text}select{user-select:none;-webkit-user-select:none}.fa,.fas{font-family:"Font Awesome 5 Free";font-weight:900;font-style:normal}.fa-trash:before{content:""}.fa-view-grid:before{content:""}.fa-view-list:before{content:""}.fa-camera:before{content:""}.fa-view-image:before{content:""}.fa-check:before{content:""}.fa-exclamation-circle:before{content:""}.fa-list-check:before{content:""}.fa-backward:before{content:""}.fa-forward:before{content:""}.fa-backward-fast:before{content:""}.fa-forward-fast:before{content:""}.list-header{position:sticky;z-index:1;top:0}:host{max-height:45vh;background-color:var(--col-bg-body);display:block;border:solid 2px var(--col-bg-1-darker)}div,p{font-family:var(--standard-text-font)}.deletion-list{display:grid;overflow-y:scroll;max-height:calc(25vh - 2em);grid-row-gap:5px;grid-template-rows:[header] auto;grid-template-columns:max-content max-content max-content max-content auto;border-top:solid var(--col-bg-1-darker) 2px}.deletion-list div{padding-right:1em}.list-header{background-color:var(--col-bg-1-lighter);color:var(--col-primary-bg-1);font-weight:700;padding-top:1em;border-bottom:solid var(--col-bg-1-darker) 1px}.list-identifier{cursor:pointer;text-decoration:underline}.headline{padding:2px;font-weight:700}.green{background-color:var(--col-bg-ack);color:var(--col-primary-bg-ack)}.red{background-color:var(--col-bg-att);color:var(--col-primary-bg-att)}.controls{display:flex;flex-direction:row;padding:2px;font-weight:700;justify-content:space-between}.no-data{padding:2px}#sort-type-selector{padding-right:1em}.center-col{display:flex;justify-content:center}';
  var JI = Object.getOwnPropertyDescriptor, XI = Object.getPrototypeOf, QI = Reflect.get, eM = (r, e, t, i) => {
    for (var o = i > 1 ? void 0 : i ? JI(e, t) : e, a = r.length - 1, l; a >= 0; a--)
      (l = r[a]) && (o = l(o) || o);
    return o;
  }, tM = (r, e, t) => QI(XI(r), t, e);
  class rM {
  }
  let Co = class extends Re {
    constructor() {
      super(), this.selected_date = null, this.selected_context = "", this.selected_context_uid = "", this.deletions = [], this.fetching = !1, this.fetch_error = "", this.unitCount = 0, this.selected_sort = "identifier", this.record_type_names = null, this.sort_by = {
        dock: ["dock", "modified"],
        "record type": ["record_type", "modified"],
        "sync time": ["modified", "dock"]
      };
    }
    get_conditions(r) {
      return `date(modified) = date('${r}')`;
    }
    fetch_data() {
      this.fetching = !0;
      const r = Zr(this.selected_date);
      let e = new URLSearchParams({ from_date: r, to_date: r });
      this.apiContext.fetchFromApi(
        "",
        "deletions",
        {
          method: "GET",
          caller: "deletion-info-widget.fetch_data"
        },
        void 0,
        e
      ).then((t) => {
        t.result_msg !== "ok" ? this.fetch_error = t.result_msg : (this.fetch_error = "", this.load_records(t.records)), this.fetching = !1;
      }).catch((t) => {
        dt(this, t, "deletion-info-widget.fetch_data", null);
      });
    }
    load_records(r) {
      this.deletions = [], r.forEach((e) => {
        e.primary_identifier;
        const t = e[1] in this.record_type_names ? this.record_type_names[e[1]] : Ye(je.getState().constants, e[1], !1, e[1]), i = new rM();
        i.modified = z.fromSQL(e[0], { zone: "utc" }).toLocaleString({
          // dateStyle: "full",
          timeStyle: "short"
          // timeZone: "Australia/Sydney",
        }), i.record_type = t, i.dock = e[2], i.deleted_records = e[3], this.deletions.push(i);
      }), this.selected_sort = "dock", this.sort_records(this.sort_by[this.selected_sort]);
    }
    sort_records(r) {
      function e(t, i) {
        for (let o = 0; o < r.length; o++) {
          let a = r[o], l = t[a], d = i[a], u = 0;
          if (typeof l == "string" && typeof d == "string" ? u = l.localeCompare(d) : (l < d && (u = -1), l > d && (u = 1)), u != 0)
            return u;
        }
        return 0;
      }
      this.deletions.sort(e), this.requestUpdate();
    }
    stateChanged(r) {
      if (this.fetch_error)
        return S`Error fetching: ${this.fetch_error}`;
      if (r.initState == 0)
        return;
      let e = !1;
      if ("dateSelector" in r.selectors) {
        let t = r.selectors.dateSelector.selectedDate;
        (!this.selected_date || t.getTime() !== this.selected_date.getTime()) && (this.selected_date = t, e = !0);
      }
      r.constants.length > 0 && !this.record_type_names && (this.record_type_names = La(r.constants)), e && this.record_type_names && this.fetch_data();
    }
    sortTypeChanged(r) {
      this.selected_sort = r.currentTarget.value, this.sort_records(this.sort_by[this.selected_sort]);
    }
    renderSortSelector() {
      return S`
            <label for="sort-type-selector">sort by</label>
            <select name="sort-type-selector" id="sort-type-selector" @change="${this.sortTypeChanged}">
                ${Object.keys(this.sort_by).map(
        (r) => S`
                            <option value="${r}"
                                    ?selected="${this.selected_sort === r}">
                                ${r}
                            </option>
                        `
      )}
            </select>
        `;
    }
    apiRender() {
      return S`
            <div class="deletion-info-widget">
                ${this.deletions.length == 0 ? S`
                        <div class="headline green">
                            <p>Nothing was deleted on this day</p>
                        </div>
                    ` : S`
                        <div class="headline red">
                            <p>deletions on this day</p>
                        </div>
                        <div class="controls red">
                            <div class="controls-left">
                                ${this.renderSortSelector()}
                            </div>
                        </div>
                        ${this.render_widget()}
                    `}
            </div>`;
    }
    render_widget() {
      return this.fetching ? S`fetching data ...` : this.deletions.length == 0 ? S`
                    <div class="no-loci">
                        <p>There were no deletions on this day</p>
                    </div>` : S`
                <div class="deletion-list">
                    <div class="list-header red">dock</div>
                    <div class="list-header red">record type</div>
                    <div class="list-header red" style="text-align: end">sync time</div>
                    <div class="list-header red" style="text-align: end">number of deletions</div>
                    <div class="list-header red">&nbsp;</div>
                    ${this.deletions.map(
        (r) => S`
                        <div>${r.dock}</div>
                        <div>${r.record_type.replace("_", " ")}</div>
                        <div style="text-align: end">${r.modified}</div>
                        <div style="text-align: end">${r.deleted_records}</div>
                        <div>&nbsp;</div>
                    `
      )}
                </div>`;
    }
  };
  Co.styles = Ue(KI);
  Co.properties = {
    ...tM(Co, Co, "properties"),
    selected_date: { type: Date },
    fetching: { type: Boolean },
    sort_by: { type: Array }
  };
  Co = eM([
    tt("deletion-info-widget")
  ], Co);
  const iM = '.col-bg-body-lighter{background-color:var(--col-bg-body-lighter)}.col-bg-body{background-color:var(--col-bg-body)}.col-bg-body-darker{background-color:var(--col-bg-body-darker)}.col-bg-1-lighter{background-color:var(--col-bg-1-lighter)}.col-bg-1{background-color:var(--col-bg-1)}.col-bg-1-darker{background-color:var(--col-bg-1-darker)}.col-bg-1-input{background-color:var(--col-bg-1-input)}.col-primary-bg-1{background-color:var(--col-primary-bg-1)}.col-accent-bg-1{background-color:var(--col-accent-bg-1)}.col-success-bg-1{background-color:var(--col-success-bg-1)}.col-warning-bg-1{background-color:var(--col-warning-bg-1)}.col-error-bg-1{background-color:var(--col-error-bg-1)}.col-bg-2-lighter{background-color:var(--col-bg-2-lighter)}.col-bg-2{background-color:var(--col-bg-2)}.col-bg-2-darker{background-color:var(--col-bg-2-darker)}.col-bg-2-button{background-color:var(--col-bg-2-button)}.col-bg-2-input{background-color:var(--col-bg-2-input)}.col-primary-bg-2{background-color:var(--col-primary-bg-2)}.col-accent-bg-2{background-color:var(--col-accent-bg-2)}.col-success-bg-2{background-color:var(--col-success-bg-2)}.col-warning-bg-2{background-color:var(--col-warning-bg-2)}.col-error-bg-2{background-color:var(--col-error-bg-2)}.col-bg-3-lighter{background-color:var(--col-bg-3-lighter)}.col-bg-3{background-color:var(--col-bg-3)}.col-bg-3-darker{background-color:var(--col-bg-3-darker)}.col-bg-3-button{background-color:var(--col-bg-3-button)}.col-bg-3-input{background-color:var(--col-bg-3-input)}.col-primary-bg-3{background-color:var(--col-primary-bg-3)}.col-accent-bg-3{background-color:var(--col-accent-bg-3)}.col-success-bg-3{background-color:var(--col-success-bg-3)}.col-warning-bg-3{background-color:var(--col-warning-bg-3)}.col-error-bg-3{background-color:var(--col-error-bg-3)}.col-bg-ack-lighter{background-color:var(--col-bg-ack-lighter)}.col-bg-ack{background-color:var(--col-bg-ack)}.col-bg-ack-darker{background-color:var(--col-bg-ack-darker)}.col-primary-bg-ack{background-color:var(--col-primary-bg-ack)}.col-accent-bg-ack{background-color:var(--col-accent-bg-ack)}.col-bg-att-lighter{background-color:var(--col-bg-att-lighter)}.col-bg-att{background-color:var(--col-bg-att)}.col-bg-att-darker{background-color:var(--col-bg-att-darker)}.col-primary-bg-att{background-color:var(--col-primary-bg-att)}.col-accent-bg-att{background-color:var(--col-accent-bg-att)}.col-bg-alert-lighter{background-color:var(--col-bg-alert-lighter)}.col-bg-alert{background-color:var(--col-bg-alert)}.col-bg-alert-darker{background-color:var(--col-bg-alert-darker)}.col-primary-bg-alert{background-color:var(--col-primary-bg-alert)}.col-accent-bg-alert{background-color:var(--col-accent-bg-alert)}.col-bg-btn-lighter{background-color:var(--col-bg-btn-lighter)}.col-bg-btn{background-color:var(--col-bg-btn)}.col-bg-btn-darker{background-color:var(--col-bg-btn-darker)}.col-primary-bg-btn{background-color:var(--col-primary-bg-btn)}.col-accent-bg-btn{background-color:var(--col-accent-bg-btn)}.pattern-diagonal-stripes-sm{background:repeating-linear-gradient(45deg,transparent,transparent 10px,currentColor 10px,currentColor 20px)}.pattern-dots-lg{background-image:radial-gradient(currentColor 1.5px,transparent 1.5px);background-size:15px 15px}.pattern-dots-md{background-image:radial-gradient(currentColor 1px,transparent 1px);background-size:8px 8px}.pattern-dots-medium-dense{background-image:radial-gradient(currentColor .5px,transparent .5px);background-size:3px 3px}.pattern-dots-sm{background-image:radial-gradient(currentColor .5px,transparent .5px);background-size:5px 5px}.pattern-cross-dots-md,.imagelist-background{background-image:radial-gradient(currentColor .7px,transparent 1px),radial-gradient(currentColor .7px,transparent 1px);background-size:6.5px 6.5px;background-position:0 0,3.5px 3.5px}.imagelist-background{background-color:#fff9;background-blend-mode:overlay}p,div{padding:0;margin:0;border:0px;user-select:text;-webkit-user-select:text}select{user-select:none;-webkit-user-select:none}.fa,.fas{font-family:"Font Awesome 5 Free";font-weight:900;font-style:normal}.fa-trash:before{content:""}.fa-view-grid:before{content:""}.fa-view-list:before{content:""}.fa-camera:before{content:""}.fa-view-image:before{content:""}.fa-check:before{content:""}.fa-exclamation-circle:before{content:""}.fa-list-check:before{content:""}.fa-backward:before{content:""}.fa-forward:before{content:""}.fa-backward-fast:before{content:""}.fa-forward-fast:before{content:""}.list-header{position:sticky;z-index:1;top:0}:host{background-color:var(--col-bg-body);display:block;border:solid 2px var(--col-bg-1-darker);overflow-y:hidden;padding-bottom:.5em}div,p{font-family:var(--standard-text-font)}.ae-list{display:grid;overflow-y:scroll;height:100%;width:100%;max-height:35vh;grid-row-gap:5px;grid-template-rows:[header] auto;grid-template-columns:repeat(7,auto);border-top:solid var(--col-bg-1-darker) 2px}.ae-list div{padding-right:.5em}.list-header{background:var(--col-bg-1-lighter);color:var(--col-primary-bg-1);font-weight:700;padding-top:5px;word-wrap:break-word;border-bottom:solid var(--col-bg-1-darker) 1px}.list-header.tighter{max-width:5em}.headline{background-color:var(--col-bg-1-lighter);color:var(--col-primary-bg-1);padding:2px;font-weight:700}.controls{display:flex;flex-direction:row;background-color:var(--col-bg-1-lighter);color:var(--col-primary-bg-1);padding:2px;font-weight:700;justify-content:space-between}.no-loci{padding:2px}.ae{font-family:var(--standard-text-font);padding:.2em;border-bottom:var(--col-bg-1-darker) 2px solid}.ae-headline{display:flex;flex-direction:row;justify-content:space-between;font-size:1.2em;font-weight:700}.ae-body{display:flex;flex-direction:row}.ae-body div{padding:0 .5em}#sort-type-selector{padding-right:1em}.center-col{display:flex;justify-content:center}.identifier-col{display:flex;justify-content:space-between;flex-direction:row}.identifier-col i{margin-left:.2em}';
  var oM = Object.getOwnPropertyDescriptor, nM = Object.getPrototypeOf, sM = Reflect.get, aM = (r, e, t, i) => {
    for (var o = i > 1 ? void 0 : i ? oM(e, t) : e, a = r.length - 1, l; a >= 0; a--)
      (l = r[a]) && (o = l(o) || o);
    return o;
  }, lM = (r, e, t) => sM(nM(r), t, e);
  class cM {
  }
  let So = class extends Re {
    constructor() {
      super(), this.selected_date = null, this.selected_member = "", this.archivalEntities = {}, this.archivalEntityList = [], this.fetching = !1, this.fetch_error = "", this.archivalEntityCount = 0, this.selected_sort = "identifier", this.termForArchivalEntity = "archival entity", this.termForArchivalEntityPlural = "archival entities", this.sort_by = {
        identifier: ["identifier", "modified"],
        creation: ["created", "identifier"]
      };
    }
    get_conditions(r, e) {
      let t = `modified_date = '${r}' and coalesce(type,'') <> 'su'`;
      return e && e && (t = t + ` and modified_by ='${e}'`), t;
    }
    fetch_data() {
      this.fetching = !0;
      const r = Zr(this.selected_date), e = `
            primary_identifier, identifier, nodescription, created, modified_by, modified_date, modified_timestamp,
            record_type, type, count(data_uuid) c 
            from {base} where ${this.get_conditions(r, this.selected_member)}  
            group by primary_identifier, identifier, nodescription, created, modified_by, 
            modified_date, modified_timestamp, record_type, type         
        `, t = {
        cql: {
          base: {
            scope: {
              archival_entity: "browse()"
            },
            target: {
              field_or_instruction: "modified_ww()"
            },
            additional_fields: {
              modified_date: {
                field_or_instruction: "modified_ww()",
                default: "",
                format: "datetime(date)"
              },
              modified_by: {
                field_or_instruction: "replfield_modified_by()",
                default: ""
              },
              modified_timestamp: {
                field_or_instruction: "modified_ww()",
                default: ""
              },
              created: {
                field_or_instruction: "archival_entity.replfield_created()",
                default: "null",
                format: "datetime(date)"
              },
              date_defined: {
                field_or_instruction: "archival_entity.date_defined",
                default: "null",
                format: "datetime(date)"
              },
              type: {
                field_or_instruction: "archival_entity.type",
                default: "null"
              },
              nodescription: {
                field_or_instruction: "archival_entity.description",
                default: "true",
                format: "isempty()"
              }
            }
          },
          meta: {
            version: 0.1
          },
          query: {
            type: "DirectSqlQuery",
            sql: e
          }
        }
      };
      let i = new URLSearchParams({
        page_size: "-1",
        qc_data_context: "qc_data_context"
      });
      this.apiContext.fetchFromApi(
        "",
        "cql/query",
        {
          method: "POST",
          caller: "archivalentitywidget.fetch_data",
          body: JSON.stringify(t)
        },
        "v1",
        i
      ).then((o) => {
        o.result_msg !== "ok" ? this.fetch_error = o.result_msg : (this.fetch_error = "", this.load_records(o.records, o.qc_messages)), this.fetching = !1;
      }).catch((o) => {
        dt(this, o, "archivalEntityWidget.fetch_data", null);
      });
    }
    load_records(r, e) {
      this.archivalEntities = {}, this.archivalEntityList = [], r.forEach((t) => {
        const i = t.primary_identifier;
        let o;
        if (t.record_type != "unit") {
          this.archivalEntities.hasOwnProperty(i) ? o = this.archivalEntities[i] : (o = new cM(), this.archivalEntities[i] = o, this.archivalEntityList.push(o), o.fileCount = 0, o.type = "?", o.hasDescription = !1, o.activityCount = 0, o.record_type = "", o.modified = 0), o.identifier = t.primary_identifier, o.record_type = t.record_type;
          const a = z.fromISO(t.modified_timestamp).toMillis();
          a > o.modified && (o.modified = a, o.modified_by = t.modified_by), t.type && (o.type = t.type), t.created && (o.created = z.fromSQL(t.created).toMillis()), t.nodescription || (o.hasDescription = !0), t.record_type == "archival_entity_file" && (o.fileCount = t.c), t.record_type == "archival_entity_activity" && (o.activityCount = t.c);
        }
      }), this.archivalEntityCount = Object.keys(this.archivalEntities).length, this.sort_records(this.sort_by[this.selected_sort]);
    }
    sort_records(r) {
      function e(t, i) {
        for (let o = 0; o < r.length; o++) {
          let a = r[o], l = t[a], d = i[a], u = 0;
          if (typeof l == "string" ? u = l.localeCompare(d) : (l < d && (u = -1), l > d && (u = 1)), u != 0)
            return u;
        }
        return 0;
      }
      this.archivalEntityList.sort(e), this.requestUpdate();
    }
    stateChanged(r) {
      if (this.fetch_error)
        return S`Error fetching: ${this.fetch_error}`;
      if (r.initState == 0)
        return;
      let e = !1;
      if ("dateSelector" in r.selectors) {
        let t = r.selectors.dateSelector.selectedDate;
        if ((!this.selected_date || t.getTime() !== this.selected_date.getTime()) && (this.selected_date = t, e = !0), "teamSelector" in r.selectors) {
          let i = r.selectors.teamSelector.selectedMember;
          i !== this.selected_member && (this.selected_member = i, e = !0);
        }
        e && this.fetch_data();
      }
      r.constants.length > 0 && (this.termForArchivalEntity = Ye(
        r.constants,
        "standard_term_for_archival_entity",
        !1,
        this.termForArchivalEntity
      ), this.termForArchivalEntityPlural = Ye(
        r.constants,
        "standard_term_for_archival_entity",
        !0,
        this.termForArchivalEntityPlural
      ));
    }
    apiRender() {
      return S`
                    <div class="ae-widget">
                        <div class="headline">
                            <p>${this.archivalEntityCount} ${this.archivalEntityCount == 1 ? this.termForArchivalEntity : this.termForArchivalEntityPlural}</p>
                        </div>
                        <div class="controls">
                            <div class="controls-left">
                                ${this.renderSortSelector()}
                            </div>
                        </div>
                        ${this.selected_date !== null ? this.render_widget() : S`Please select a date`}
                    </div>`;
    }
    sortTypeChanged(r) {
      this.selected_sort = r.currentTarget.value, this.sort_records(this.sort_by[this.selected_sort]);
    }
    renderSortSelector() {
      return S`
            <label for="sort-type-selector">sort by</label>
            <select name="sort-type-selector" id="sort-type-selector" @change="${this.sortTypeChanged}">
                ${Object.keys(this.sort_by).map(
        (r) => S`
                            <option value="${r}"
                                    ?selected="${this.selected_sort === r}">
                                ${r}
                            </option>
                        `
      )}
            </select>
        `;
    }
    render_widget() {
      return this.selected_date ? this.fetching ? S`fetching data ...` : this.archivalEntityCount == 0 ? S`
                    <div class="no-loci">
                        <p>No data found for your selection</p>
                    </div>` : S`
                <div class="ae-list ae-list-with-member'}">
                    <div class="list-header">identifier</div>
                    <div class="list-header">type</div>
                    <div class="list-header">creation</div>
                    <div class="list-header">description?</div>
                    <div class="list-header">activities</div>
                    <div class="list-header">photos</div>
                    ${this.selected_member ? S`<div class="list-header">at</div>` : S`<div class="list-header">by</div>`}
                    ${this.archivalEntityList.map(
        (r) => S`
                        <div class="identifier-col">
                            ${r.identifier}
                        </div>
                        <div>${r.type}</div>
                        <div>${z.fromMillis(r.created).toLocaleString()}</div>
                        <div class="center-col">${r.hasDescription ? S`                                
                                    <i class="fa fa-check"></i>
                                ` : void 0}</div>
                        <div class="center-col">${r.activityCount}</div>
                        <div class="center-col">${r.fileCount}</div>
                        ${this.selected_member ? S`<div class="center-col">${z.fromMillis(r.modified).toLocaleString({ timeStyle: "short" })}</div>` : S`<div class="center-col">${r.modified_by} (${z.fromMillis(r.modified).toLocaleString({ timeStyle: "short" })})</div>`}
                    `
      )}
                </div>
                ` : S`please select a date`;
    }
    // public updated(_changedProperties: any) {
    //     super.updated(_changedProperties);
    //     const elements = this.shadowRoot.querySelectorAll(".tooltip-button")
    //     // if (this.editing !== "") {
    //     //     this.shadowRoot.getElementById("edit-list").focus();
    //     // }
    // }
  };
  So.styles = Ue(iM);
  So.properties = {
    ...lM(So, So, "properties"),
    selected_context: { type: String },
    selected_date: { type: Date },
    selected_member: { type: String },
    fetching: { type: Boolean },
    sort_by: { type: Array },
    termForArchivalEntity: { type: String }
  };
  So = aM([
    tt("archival-entity-widget")
  ], So);
  var dM = Object.defineProperty, uM = Object.getOwnPropertyDescriptor, hM = Object.getPrototypeOf, fM = Reflect.get, Sv = (r, e, t, i) => {
    for (var o = i > 1 ? void 0 : i ? uM(e, t) : e, a = r.length - 1, l; a >= 0; a--)
      (l = r[a]) && (o = (i ? l(e, t, o) : l(o)) || o);
    return i && o && dM(e, t, o), o;
  }, pM = (r, e, t) => fM(hM(r), t, e);
  let Ci = class extends Re {
    constructor() {
      super();
    }
    stateChanged(r) {
      "widgetSelector" in r.selectors && (this.selectedWidgets = r.selectors.widgetSelector.selectedWidgets, this.requestUpdate());
    }
    firstUpdated(r) {
      super.firstUpdated(r);
    }
    renderDataWidgets() {
      return this.selectedWidgets ? S`
            <unit-info-widget .apiContext="${this.apiContext}" style="${this.selectedWidgets.includes("unit-info-widget") ? pe : "display:none"}"></unit-info-widget>
            <deletion-info-widget .apiContext="${this.apiContext}" style="${this.selectedWidgets.includes("deletion-info-widget") ? pe : "display:none"}"></deletion-info-widget>
            <narrative-widget .apiContext="${this.apiContext}" style="${this.selectedWidgets.includes("narrative-widget") ? pe : "display:none"}"></narrative-widget>
            <file-widget .apiContext="${this.apiContext}" style="${this.selectedWidgets.includes("file-widget") ? pe : "display:none"}"></file-widget>
            <locus-widget .apiContext="${this.apiContext}" style="${this.selectedWidgets.includes("locus-widget") ? pe : "display:none"}"></locus-widget>
            <cm-widget .apiContext="${this.apiContext}" style="${this.selectedWidgets.includes("cm-widget") ? pe : "display:none"}"></cm-widget>
            <feature-widget .apiContext="${this.apiContext}" style="${this.selectedWidgets.includes("feature-widget") ? pe : "display:none"}"></feature-widget>
            <archival-entity-widget .apiContext="${this.apiContext}" style="${this.selectedWidgets.includes("archival-entity-widget") ? pe : "display:none"}"></archival-entity-widget>
        ` : S``;
    }
    apiRender() {
      return this.renderDataWidgets();
    }
  };
  Ci.styles = Ue(Z2);
  Ci.properties = {
    ...pM(Ci, Ci, "properties")
  };
  Sv([
    Jd()
  ], Ci.prototype, "selectedWidgets", 2);
  Ci = Sv([
    tt("dataview-frame")
  ], Ci);
  const no = class no extends td {
    constructor() {
      super(), this.login_token = "", this._messages = {};
    }
    _show_message(e) {
      let t = e.detail;
      ZS(this._messages, t, null, !0);
    }
    firstUpdated(e) {
      super.firstUpdated(e);
    }
    apiConnected() {
      this.fetchConstants();
    }
    fetchConstants() {
      je.getState().constants.length === 0 && this.apiContext && this.apiContext.fetchFromApi(
        "",
        "constants",
        {
          method: "GET",
          caller: "app.fetchConstants"
        }
      ).then((t) => {
        this.loadConstants(t);
      }).catch((t) => {
        dt(this, t, "loadConstants", null);
      });
    }
    loadConstants(e) {
      je.dispatch(NS(e));
    }
    render_app() {
      let e = cn``, t = cn`
            <div class='directors-view-frame'>
                 <selection-frame .apiContext="${this.apiContext}"></selection-frame>
                 <dataview-frame .apiContext="${this.apiContext}""></dataview-frame>
             </div>`;
      return cn`${e}${t}`;
    }
    // apiRender is only called once the api is connected.
    apiRender() {
      let e = cn``;
      const t = this.render_app();
      return cn`${e}${t}`;
    }
  };
  no.styles = Ue(QS), no.properties = {
    ...gp(no, no, "properties"),
    login_token: { type: String }
  };
  let Bd = no;
  window.customElements.define("directorsview-app", Bd);
});
export default gM();
