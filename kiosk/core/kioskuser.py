import logging

from flask_login import UserMixin
from werkzeug.security import generate_password_hash, check_password_hash

from generalstore.generalstorekeys import kiosk_core_security_tokens, kiosk_core_security_user_tokens
from kioskconfig import KioskConfig
from kioskglobals import get_general_store, get_config, get_jws
from messaging.systemmessagecatalog import *
from kiosksqldb import KioskSQLDb


class KioskUser(UserMixin):
    def __init__(self, user_uuid, check_token=True):
        self._privileges = []
        self._groups = []
        self.id = None
        self.user_id = None
        self.user_name = None
        self.must_change_pwd = False
        self.repl_user_id = ""
        self._token = ""
        self._group_threshold = MSG_SEVERITY_INFO
        self._user_threshold = MSG_SEVERITY_INFO

        if not self.load_user(user_uuid, check_token):
            raise Exception('kiosk user not found or an exception occurred. Please consult the logs')

    @property
    def message_threshold(self) -> (int, int):
        """
        returns the system message thresholds for the user. Only messages with a severity >= a threshold are
        relevant to this user. The group threshold is the threshold for messages addressed to a group or anybody,
        the user-threshold is used only for messages addressed to the user only.

        :return: a tuple consisting of (group-threshold, user-threshold)
        """
        return self._group_threshold, self._user_threshold

    @classmethod
    def check_token(cls, token) -> str:
        """
        checks if a _token exists in the general store
        and returns the connected id (the uuid) of the user.
        By checking the token its timeout gets reset.

        :param token: a token formerly generated by get_token
        :returns: the id (uuid) of the user or an empty string

        """
        # noinspection PyBroadException
        b_token = ""
        try:
            # b_token = token.encode("utf-8")
            data = get_jws().check(token)
            key = "_".join([kiosk_core_security_tokens, token])
            general_store = get_general_store()
            general_store.set_timeout(key, get_config().security_token_timeout_seconds)
            _id = general_store.get_string(key)
            if data["uuid"] == _id:
                key = "_".join([kiosk_core_security_user_tokens, _id])
                general_store.set_timeout(key, get_config().security_token_timeout_seconds)
                return _id
            else:
                raise Exception(f"check_token: token {token} does not match the user uuid {_id}.")

        except BaseException as e:
            logging.error(f"kioskuser.check_token: Token could not be validated - Exception {repr(e)}")
            logging.error(f"kioskuser.check_token: token {token}, b_token {b_token}")
            return ""

    @property
    def groups(self):
        return list(self._groups)

    def create_token(self):
        """
        returns the user's token from the general store
        or creates one if there is none. Use only on login! Otherwise use get_token.

        :returns: a string: the currently valid token
        """

        if not self.get_token(reload=True):

            token = get_jws().encode({"uuid": self.id})

            # data = jws.loads(b_token)
            # token = b_token.decode("utf-8")

            key = "_".join([kiosk_core_security_user_tokens, self.id])
            general_store = get_general_store()
            general_store.put_string(key, token)
            # general_store.set_timeout(key, get_config().security_token_timeout_seconds + 5)

            key = "_".join([kiosk_core_security_tokens, token])
            general_store.put_string(key, self.id)

            if self.check_token(token):
                self._token = token

        return self._token

    def get_token(self, reload=False):
        """
        returns the user's token from the general store and extends it by the way.
        if there is no valid token for the user in the general store,
        the method returns an emtpy string
        :param reload: even if a token has been fetched earlier, reload it from the store.
        :returns: a string: the currently valid token or an empty string if there is none
        """
        if not self._token or reload:
            key = "_".join([kiosk_core_security_user_tokens, self.id])
            general_store = get_general_store()
            try:
                token = general_store.get_string(key)
                if self.check_token(token):
                    self._token = token
                else:
                    try:
                        general_store.delete_key(key)
                        key = "_".join([kiosk_core_security_tokens, token])
                        general_store.delete_key(key)
                        logging.debug(f"{self.__class__.__name__}.get_token: "
                                      f"Token for user {self.user_id} did not check out, keys are deleted.")
                    except KeyError as e:
                        logging.error(f"{self.__class__.__name__}.get_token: "
                                      f"Exception when deleting keys from general store: {repr(e)}")

            except KeyError:
                pass

        return self._token

    def load_user(self, user_uuid, check_token=True):
        try:
            r = KioskSQLDb.get_first_record("kiosk_user", "uid", user_uuid)
            if r:
                self.id = r["uid"]
                self.user_id = r["user_id"]
                self.user_name = r["user_name"]
                self.must_change_pwd = r["must_change_pwd"]
                if "groups" in r and r["groups"]:
                    self._groups = [x.strip() for x in r["groups"].split(",")]
                self.repl_user_id = r["repl_user_id"]
                if check_token and not self.get_token():
                    logging.error(f"{self.__class__.__name__}.load_user: User {self.user_id} "
                                  f"cannot be loaded because of missing api token.")
                else:
                    self._load_group_thresholds()
                    return self._load_privileges()
        except Exception as e:
            logging.error("Exception in load_user: " + repr(e))
        self.id = None
        self.user_id = None
        self.user_name = None
        self._group_threshold = 0
        self._user_threshold = 0
        self._privileges = []
        self.must_change_pwd = False
        return False

    def _load_privileges(self):
        rc = False
        try:
            addressees = ",".join([f"'{self.user_id}'"] + [f"'{x}'" for x in self._groups])

            logging.debug(f"loading privileges for addressees {addressees}")
            privileges = KioskSQLDb.get_records(
                f"select distinct privilege from kiosk_privilege where addressee in ({addressees})",
                [addressees])

            self._privileges = [x["privilege"] for x in privileges]
            rc = True

        except Exception as e:
            logging.error(f"Exception in modelkioskauthentication._load_privileges for user {self.user_id}: {repr(e)}")

        return rc

    def fulfills_requirement(self, requirement: str):
        if requirement.lower().startswith("explicit_"):
            requirement = requirement.lower().replace("explicit_", "")
        else:
            if "*" in self._privileges:
                return True

        return requirement in self._privileges

    def save(self):
        try:
            r = KioskSQLDb.get_first_record("kiosk_user", "uid", self.id)
            if r:
                sql = "update kiosk_user set "
                sql += "\"user_id\"=%s"
                sql += ", \"user_name\"=%s"
                sql += "where \"uid\"=%s"

                KioskSQLDb.execute(sql, [self.user_id, self.user_name, self.id])
                return True
            else:
                logging.error("KioskUser.save: user {} does not exist.".format(self.id))
        except Exception as e:
            logging.error("Exception in KioskUser.save({}): ".format(self.id) + repr(e))
        return False

    @classmethod
    def authenticate(cls, userid, password):
        try:
            r = KioskSQLDb.get_first_record("kiosk_user", "user_id", userid)
            if r:
                if r["pwd_hash"]:
                    if check_password_hash(r["pwd_hash"], password):
                        user = KioskUser(r["uid"], check_token=False)
                        if user.create_token():
                            logging.info("user with user-id '{}' authenticated".format(userid))
                            return user
                        else:
                            logging.warning(f"kioskuser.authenticate: "
                                            f"could not create token for user with uuid {user.id}")
                    else:
                        logging.warning("attempt to login as user-id {} with wrong password.".format(userid))
                else:
                    if password:
                        logging.warning("!attempt to login as user-id {} with wrong password.".format(userid))
                    else:
                        user = KioskUser(r["uid"], check_token=False)
                        logging.info("user user-id {} authenticated because user has no password.".format(userid))
                        if user.create_token():
                            logging.info("user with user-id '{}' authenticated".format(userid))
                            return user
                        else:
                            logging.warning(f"kioskuser.authenticate: "
                                            f"could not create token for user with uuid {user.id}")
            else:
                logging.warning("access to unkown user-id {} does not exist".format(userid))
        except Exception as e:
            logging.error(f"kioskuser.authenticate: Exception logging in user {userid}: " + repr(e))
        return None

    def set_password(self, password, commit=False, temporary=False):
        try:
            pwd_hash = generate_password_hash(password)
            rc = KioskSQLDb.execute("update" + "\"kiosk_user\" set pwd_hash=%s, "
                                              "\"must_change_pwd\"=%s where \"uid\"=%s;",
                                    [pwd_hash, temporary, self.id])
            if commit:
                KioskSQLDb.commit()
        except BaseException as e:
            logging.error(f"Exception in KioskUser.set_password: {repr(e)}")
            rc = False

        return rc

    @classmethod
    def get(cls, uuid):
        try:
            print("trying to get user by uuid " + uuid)
            return KioskUser(uuid)
        except Exception as e:
            logging.error("Exception in KioskUser.get({}): ".format(uuid) + repr(e))
        return None

    def _load_group_thresholds(self):
        try:

            config: KioskConfig = get_config()
            thresholds = config.kiosk["system_messages"]["thresholds"]
            threshold = MSG_SEVERITY_HIGHEST + 1

            for g in self._groups:
                try:
                    if g in thresholds.keys():
                        new_threshold = int(thresholds[g])
                        if g == "~":
                            #  this is the threshold for messages addressed to the user directly
                            self._user_threshold = new_threshold
                        else:
                            if new_threshold < threshold:
                                threshold = new_threshold
                except BaseException as e:
                    logging.error(f"{self.__class__.__name__}._load_message_thresholds: "
                                  f"Error in configuration of system_messages/thresholds for group {g}: {repr(e)}")

            if threshold > MSG_SEVERITY_HIGHEST:
                # no threshold found, let's try the default
                if "*" in thresholds:
                    threshold = int(thresholds["*"])

            if threshold < MSG_SEVERITY_HIGHEST + 1:
                # if no thresholds at all are configured or they are all faulty, let's not set the threshold.
                self._group_threshold = threshold
        except KeyError as e:
            # logging.debug(f"{self.__class__.__name__}._load_message_thresholds: "
            #               f"kiosk/system_messages/thresholds not configured.")
            pass
        except BaseException as e:
            logging.error(f"{self.__class__.__name__}._load_message_thresholds: Outer Exception {repr(e)}")
