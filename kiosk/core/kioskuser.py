import logging
import datetime
from typing import Union

from dateutil.tz import tzstr
from flask_login import UserMixin
from flask import request
from werkzeug.security import generate_password_hash, check_password_hash

import kioskglobals
import kioskstdlib
from generalstore.generalstorekeys import kiosk_core_security_tokens, kiosk_core_security_user_tokens
from kioskconfig import KioskConfig
from kioskglobals import get_general_store, get_config, get_jws
from messaging.systemmessagecatalog import *
from kiosksqldb import KioskSQLDb
from tz.kiosktimezones import KioskTimeZones
import kioskdatetimelib

# time zone relevance
class KioskUser(UserMixin):
    def __init__(self, user_uuid, check_token=True, init_dict=None):
        self._privileges = []
        self._groups = []
        self.id = None
        self.user_id = None
        self.user_name = None
        self.must_change_pwd = False
        self.repl_user_id = ""
        self._token = ""
        self.force_tz_index = 0
        self._group_threshold = MSG_SEVERITY_INFO
        self._user_threshold = MSG_SEVERITY_INFO
        self._active_tz_index: Union[int, None] = None
        self._active_tz_name = ""
        self._active_iana_tz_name = ""

        if not self.load_user(user_uuid, check_token):
            raise Exception('kiosk user not found or an exception occurred. Please consult the logs')

        if isinstance(init_dict, dict):
            self.init_from_dict(init_dict)

    @property
    def message_threshold(self) -> (int, int):
        """
        returns the system message thresholds for the user. Only messages with a severity >= a threshold are
        relevant to this user. The group threshold is the threshold for messages addressed to a group or anybody,
        the user-threshold is used only for messages addressed to the user only.

        :return: a tuple consisting of (group-threshold, user-threshold)
        """
        return self._group_threshold, self._user_threshold

    @classmethod
    def check_token(cls, token) -> str:
        """
        checks if a _token exists in the general store
        and returns the connected id (the uuid) of the user.
        By checking the token its timeout gets reset.

        :param token: a token formerly generated by get_token
        :returns: the id (uuid) of the user or an empty string

        """
        # noinspection PyBroadException
        b_token = ""
        try:
            # b_token = token.encode("utf-8")
            data = get_jws().check(token)
            key = "_".join([kiosk_core_security_tokens, token])
            general_store = get_general_store()
            general_store.set_timeout(key, get_config().security_token_timeout_seconds)
            _id = general_store.get_string(key)
            if data["uuid"] == _id:
                key = "_".join([kiosk_core_security_user_tokens, _id])
                general_store.set_timeout(key, get_config().security_token_timeout_seconds)
                return _id
            else:
                raise Exception(f"check_token: token {token} does not match the user uuid {_id}.")

        except BaseException as e:
            logging.error(f"kioskuser.check_token: Token could not be validated - Exception {repr(e)}")
            logging.error(f"kioskuser.check_token: token {token}, b_token {b_token}")
            return ""

    @property
    def groups(self):
        return list(self._groups)

    def create_token(self):
        """
        returns the user's token from the general store
        or creates one if there is none. Use only on login! Otherwise use get_token.

        :returns: a string: the currently valid token
        """

        if not self.get_token(reload=True):

            token = get_jws().encode({"uuid": self.id})

            # data = jws.loads(b_token)
            # token = b_token.decode("utf-8")

            key = "_".join([kiosk_core_security_user_tokens, self.id])
            general_store = get_general_store()
            general_store.put_string(key, token)
            # general_store.set_timeout(key, get_config().security_token_timeout_seconds + 5)

            key = "_".join([kiosk_core_security_tokens, token])
            general_store.put_string(key, self.id)

            if self.check_token(token):
                self._token = token

        return self._token

    def get_token(self, reload=False):
        """
        returns the user's token from the general store and extends it by the way.
        if there is no valid token for the user in the general store,
        the method returns an emtpy string
        :param reload: even if a token has been fetched earlier, reload it from the store.
        :returns: a string: the currently valid token or an empty string if there is none
        """
        if not self._token or reload:
            key = "_".join([kiosk_core_security_user_tokens, self.id])
            general_store = get_general_store()
            try:
                token = general_store.get_string(key)
                if self.check_token(token):
                    self._token = token
                else:
                    try:
                        general_store.delete_key(key)
                        key = "_".join([kiosk_core_security_tokens, token])
                        general_store.delete_key(key)
                        logging.debug(f"{self.__class__.__name__}.get_token: "
                                      f"Token for user {self.user_id} did not check out, keys are deleted.")
                    except KeyError as e:
                        logging.error(f"{self.__class__.__name__}.get_token: "
                                      f"Exception when deleting keys from general store: {repr(e)}")

            except KeyError:
                pass

        return self._token

    def load_user(self, user_uuid, check_token=True):
        try:
            r = KioskSQLDb.get_first_record("kiosk_user", "uid", user_uuid)
            if r:
                self.id = r["uid"]
                self.user_id = r["user_id"]
                self.user_name = r["user_name"]
                self.must_change_pwd = r["must_change_pwd"]
                self.force_tz_index = r["force_tz_index"]
                if "groups" in r and r["groups"]:
                    self._groups = [x.strip() for x in r["groups"].split(",")]
                self.repl_user_id = r["repl_user_id"]
                if check_token and not self.get_token():
                    logging.error(f"{self.__class__.__name__}.load_user: User {self.user_id} "
                                  f"cannot be loaded because of missing api token.")
                else:
                    self._load_group_thresholds()
                    return self._load_privileges()
        except Exception as e:
            logging.error("Exception in load_user: " + repr(e))
        self.id = None
        self.user_id = None
        self.user_name = None
        self._group_threshold = 0
        self._user_threshold = 0
        self._privileges = []
        self.must_change_pwd = False
        return False

    def _load_privileges(self):
        rc = False
        try:
            addressees = ",".join([f"'{self.user_id}'"] + [f"'{x}'" for x in self._groups])

            logging.debug(f"loading privileges for addressees {addressees}")
            privileges = KioskSQLDb.get_records(
                f"select distinct privilege from kiosk_privilege where addressee in ({addressees})",
                [addressees])

            self._privileges = [x["privilege"] for x in privileges]
            rc = True

        except Exception as e:
            logging.error(f"Exception in modelkioskauthentication._load_privileges for user {self.user_id}: {repr(e)}")

        return rc

    def fulfills_requirement(self, requirement: str):
        if requirement.lower().startswith("explicit_"):
            requirement = requirement.lower().replace("explicit_", "")
        else:
            if "*" in self._privileges:
                return True

        return requirement in self._privileges

    def save(self):
        try:
            r = KioskSQLDb.get_first_record("kiosk_user", "uid", self.id)
            if r:
                sql = "update kiosk_user set "
                sql += "\"user_id\"=%s"
                sql += ", \"user_name\"=%s"
                sql += ", \"force_tz_index\"=%s"
                sql += " where \"uid\"=%s"

                KioskSQLDb.execute(sql, [self.user_id, self.user_name,
                                         self.force_tz_index,
                                         self.id])
                return True
            else:
                logging.error("KioskUser.save: user {} does not exist.".format(self.id))
        except Exception as e:
            logging.error("Exception in KioskUser.save({}): ".format(self.id) + repr(e))
        return False

    @classmethod
    def authenticate(cls, userid, password):
        try:
            r = KioskSQLDb.get_first_record("kiosk_user", "user_id", userid)
            if r:
                if r["pwd_hash"]:
                    if check_password_hash(r["pwd_hash"], password):
                        user = KioskUser(r["uid"], check_token=False)
                        if user.create_token():
                            logging.info("user with user-id '{}' authenticated".format(userid))
                            return user
                        else:
                            logging.warning(f"kioskuser.authenticate: "
                                            f"could not create token for user with uuid {user.id}")
                    else:
                        logging.warning("attempt to login as user-id {} with wrong password.".format(userid))
                else:
                    if password:
                        logging.warning("!attempt to login as user-id {} with wrong password.".format(userid))
                    else:
                        user = KioskUser(r["uid"], check_token=False)
                        logging.info("user user-id {} authenticated because user has no password.".format(userid))
                        if user.create_token():
                            logging.info("user with user-id '{}' authenticated".format(userid))
                            return user
                        else:
                            logging.warning(f"kioskuser.authenticate: "
                                            f"could not create token for user with uuid {user.id}")
            else:
                logging.warning("access to unkown user-id {} does not exist".format(userid))
        except Exception as e:
            logging.error(f"kioskuser.authenticate: Exception logging in user {userid}: " + repr(e))
        return None

    def set_password(self, password, commit=False, temporary=False):
        try:
            pwd_hash = generate_password_hash(password)
            rc = KioskSQLDb.execute("update" + "\"kiosk_user\" set pwd_hash=%s, "
                                               "\"must_change_pwd\"=%s where \"uid\"=%s;",
                                    [pwd_hash, temporary, self.id])
            if commit:
                KioskSQLDb.commit()
        except BaseException as e:
            logging.error(f"Exception in KioskUser.set_password: {repr(e)}")
            rc = False

        return rc

    @classmethod
    def get(cls, uuid):
        try:
            print("trying to get user by uuid " + uuid)
            return KioskUser(uuid)
        except Exception as e:
            logging.error("Exception in KioskUser.get({}): ".format(uuid) + repr(e))
        return None

    def _load_group_thresholds(self):
        try:

            config: KioskConfig = get_config()
            thresholds = config.kiosk["system_messages"]["thresholds"]
            threshold = MSG_SEVERITY_HIGHEST + 1

            for g in self._groups:
                try:
                    if g in thresholds.keys():
                        new_threshold = int(thresholds[g])
                        if g == "~":
                            #  this is the threshold for messages addressed to the user directly
                            self._user_threshold = new_threshold
                        else:
                            if new_threshold < threshold:
                                threshold = new_threshold
                except BaseException as e:
                    logging.error(f"{self.__class__.__name__}._load_message_thresholds: "
                                  f"Error in configuration of system_messages/thresholds for group {g}: {repr(e)}")

            if threshold > MSG_SEVERITY_HIGHEST:
                # no threshold found, let's try the default
                if "*" in thresholds:
                    threshold = int(thresholds["*"])

            if threshold < MSG_SEVERITY_HIGHEST + 1:
                # if no thresholds at all are configured or they are all faulty, let's not set the threshold.
                self._group_threshold = threshold
        except KeyError as e:
            # logging.debug(f"{self.__class__.__name__}._load_message_thresholds: "
            #               f"kiosk/system_messages/thresholds not configured.")
            pass
        except BaseException as e:
            logging.error(f"{self.__class__.__name__}._load_message_thresholds: Outer Exception {repr(e)}")

    def get_force_tz_index(self):
        """
        returns the value of the force_tz_index field
        :return: the value or 0 (which is simply the default)
        """
        return self.force_tz_index

    def get_active_time_zone_name(self, iana=False):
        """
        returns the user's currently active time zone in Kiosk.

        note: This needs an active request object in Flask unless the _active_tz_index or the _active_tz_name
              was set externally

        :param iana: set to True of you want the IANA time zone name instead of the long name
        :return: the time zone's name or ""
        :raises nothing: catches all Exceptions
        """
        try:
            if not self._active_tz_name:
                kiosk_tz = kioskglobals.kiosk_time_zones if kioskglobals else KioskTimeZones()
                kiosk_tz_index = self.get_active_tz_index()
                if kiosk_tz_index is not None:
                    kiosk_tz_info = kiosk_tz.get_time_zone_info(kiosk_tz_index)
                    self._active_tz_name = kiosk_tz_info[1]
                    self._active_iana_tz_name = kiosk_tz_info[2]

            return self._active_iana_tz_name if iana else self._active_tz_name

        except BaseException as e:
            logging.error(f"{self.__class__.__name__}.get_active_time_zone_name: Error resolving "
                          f"active kiosk timezone: {repr(e)}")

        return ""


    def get_active_tz_index(self):
        """
        returns the user's currently active time zone index in Kiosk.

        note: Unless the _active_tz_index was set externally this needs an active request object in Flask

        :return: the time zone index
        """
        if self._active_tz_index is None:
            if request:
                if "kiosk_tz_index" in request.cookies:
                    self._active_tz_index = int(request.cookies.get("kiosk_tz_index"))
            else:
                raise Exception("get_active_tz_index called without a flask context")

        return self._active_tz_index

    def is_time_zone_forced(self):
        """
        checks if the active time zone differs from the Browser's time zone.

        note: This needs access to a current flask request!

        :return: boolean.
        :raises: nothing. Returns True if any exception occurs.
        """
        try:
            return int(request.cookies.get("kiosk_tz_index")) != int(request.cookies.get("client_tz_index"))
        except BaseException as e:
            logging.error(f"{self.__class__.__name__}.is_time_zone_forced: {repr(e)}")
            return True

    def to_dict(self) -> dict:
        """
        returns an initializer dictionary that can be used with init_from_dict. It contains only data that is NOT
        stored in the database. This is particularly to have time zone settings being transferred to parts of the
        system where cookies are not available. Mostly MCP processes.
        :return: a dictionary that can be used with init_from_dict
        """
        return {
            "uuid": self.get_id(),
            "active_tz_index": self.get_active_tz_index(),
            "active_iana_tz_name": self.get_active_time_zone_name(iana=True),
            "active_tz_name": self.get_active_time_zone_name()
        }

    def init_from_dict(self, user_data: dict):
        """
        initializes parts of a Kiosk instance with data from a dict that has been created by init_from_dict.
        This is particularly to have time zone settings being transferred to parts of the
        system where cookies are not available. Mostly MCP processes.

        :param user_data: a dict that was returned by to_dict
        """
        if user_data["uuid"] != self.id:
            raise Exception("init data and current id must match when using initFromDict")

        self._active_tz_index = kioskstdlib.try_get_dict_entry(user_data, "active_tz_index", self._active_tz_index)
        self._active_iana_tz_name = kioskstdlib.try_get_dict_entry(user_data, "active_iana_tz_name",
                                                                   self._active_iana_tz_name)
        self._active_tz_name = kioskstdlib.try_get_dict_entry(user_data, "active_tz_name", self._active_tz_name)

    def get_user_now(self, replace_ms=True):
        """
        returns a current time stamp on the basis of the user's active time zone

        :param replace_ms: set to False if you want to keep microseconds
        :return: a timestamp with the time zone information dropped
        """
        return self.get_utc_as_user_timestamp(kioskdatetimelib.get_utc_now(no_tz_info=True), replace_ms=replace_ms)

    def get_utc_as_user_timestamp(self, ts:datetime.datetime, replace_ms=True):
        """
        returns a time stamp on the basis of the user's active time zone

        :param ts: the utc time stamp to convert into the user's time zone
        :param replace_ms: set to False if you want to keep microseconds
        :return: a timestamp with the time zone information dropped
        """
        return kioskdatetimelib.utc_ts_to_timezone_ts(
            ts,
            self.get_active_time_zone_name(iana=True),
            replace_ms=replace_ms)
