import json
import logging
import os
import zoneinfo
import time
from pprint import pprint
from typing import Tuple, List, Set
from babel import dates
import re
import hashlib

from kiosksqldb import KioskSQLDb
from sync_config import SyncConfig


class KioskTimeZones:
    def __init__(self, iana_backward_file: str = ""):
        self.iana_backward_file = iana_backward_file
        self.deprecated_aliases: Set = set()

    def read_deprecated_aliases(self) -> Set[str]:
        """
        Reads and extracts deprecated aliases from the 'backward' IANA file given in the constructor.
        The backward file is part of the IANA's database at https://www.iana.org/time-zones. Just download
        the data only distribution and fish the backward file out of the archive.
        Usually Kiosk keeps that file under tools\tz

        :return: A set of deprecated aliases extracted from the file.
        """
        if not self.deprecated_aliases:
            if not self.iana_backward_file:
                raise Exception(f"read_deprecated_aliases needs path and filename of the 'backward' IANA file.")
            if not os.path.isfile(self.iana_backward_file):
                raise Exception(f"the file {self.iana_backward_file} does not exist")
            with open(self.iana_backward_file, "r") as fp:
                for line_full in fp:
                    line = line_full.strip()
                    if not line.startswith("Link\t"):
                        continue
                    result = re.split("\t+", line, maxsplit=3)
                    _link, _dest, source, *_ = result
                    self.deprecated_aliases.add(source)

        return self.deprecated_aliases

    def generate_time_zones(self) -> List[Tuple[int, str, str, bool]]:
        """
        Generate and list all available time zones with their human-readable names and full names.

        :return: A list of tuples containing a stable integer hash (not random), human-readable name,
                  IANA time zone name and a deprecation flag for each time zone.

                  Note that the hash is not necessarily, but most likely unique,
                  show the human-readable name but use the IANA time zone name

        :raises all kinds of exceptions
        """

        tz_array: List[Tuple[int, str, str, bool]] = []
        self.read_deprecated_aliases()

        for tz in zoneinfo.available_timezones():
            deprecated = tz not in self.deprecated_aliases
            try:
                tz_human = dates.get_timezone_name(dt_or_tzinfo=dates.get_timezone(tz), locale="en_US")
                if tz_human.find("Unknown Region") == -1:
                    tz_full = f"{tz_human} ({tz.replace('_', ' ')})"
                    hash = int(hashlib.md5(tz_full.encode("utf-8"), usedforsecurity=False).hexdigest(), 16) % (10 ** 8)
                    tz_array.append(
                        (hash,
                         tz_full,
                         tz,
                         deprecated))
                    # # just for testing duplicate hashes
                    # if tz_full.find("New York") > -1:
                    #     print("!TEST: Generating an entry for Providence")
                    #     tz_array.append(
                    #         (hash,   # same hash as New York
                    #          "Providence",
                    #          "Providence",
                    #          True))

            except BaseException as e:
                tz_array.append(
                    (int(hashlib.md5(tz.encode("utf-8"), usedforsecurity=False).hexdigest(), 16) % (10 ** 8),
                     tz,
                     tz,
                     deprecated))

        return tz_array

    def generate_kiosk_time_zone_dist(self, target_json_file: str, console_output=True):
        """
        creates a json file and writes all available time zone information as returned by generate_time_zones
        into that file. Per time zone it adds a version integer that indicates
        with which run of generate_kiosk_time_zone_dist a time zone was added.

        This is meant to work on the same file forever as only that way stable unique hash values
        can be avoided properly. Kiosk uses tools/kiosk_tz.json for that. And it is generated by the developer so
        that ALL projects use the same hashes.

        :param target_json_file: usually tools/kiosk_tz.json
        :param console_output: set to False if you don't want any printouts to the console
        """

        def get_tz_index(lst: List[Tuple[int, str, str, bool,int]], tz_hash):
            for i, tz_found in enumerate(lst):
                if tz_found[0] == tz_hash:
                    return i
            return -1

        time_zones = self.generate_time_zones()
        if not time_zones:
            raise Exception("KioskTimeZones.generate_kiosk_time_zone_info: "
                            "Generating time zones failed. The result was empty.")

        json_tz_info: List[Tuple[int, str, str, bool, int]] = []

        if os.path.isfile(target_json_file):
            with open(target_json_file, 'r') as f:
                json_tz_info: List[Tuple[int, str, str, bool, int]] = json.load(f)

        for idx, json_tz in enumerate(json_tz_info):
            json_tz_info[idx] = (json_tz[0], "", json_tz[2], json_tz[3], json_tz[4])

        version = int(time.time())
        tz_updated = 0
        for tz in time_zones:
            while True:
                idx = get_tz_index(json_tz_info, tz[0])
                if idx > -1:  # hash already exists
                    json_tz = json_tz_info[idx]
                    if tz[2] == json_tz[2]:  # is it the same IANA time zone?
                        json_tz_info[idx] = (tz[0], tz[1], tz[2], tz[3], json_tz[4])  # update tz information, but keep version
                        tz_updated += 1
                    else:  # duplicate hash: make a new hash and try again
                        if console_output:
                            print("Time zone " + tz[1] + " duplicate!")
                        tz = (tz[0] + 1, tz[1], tz[2], tz[3], version)
                        continue
                else:  # new tz entry
                    if console_output:
                        print("Time zone " + tz[1] + " is new")
                    tz_updated += 1
                    json_tz_info.append((tz[0], tz[1], tz[2], tz[3], version))

                break

        #  eliminate time zone entries that don't exist anymore
        json_tz_info = [json_tz for json_tz in json_tz_info if json_tz[1] != ""]

        with open(target_json_file, 'w') as f:
            json.dump(json_tz_info, f)

        if console_output:
            print(f"generate_kiosk_time_zone_dist updated {tz_updated} time zones")

    def update_local_kiosk_time_zones(self, source_json_file: str, commit=True) -> None:
        """
        Loads the time zones from a json file into the local database's time_zones table.
        Note that the target able "kiosk_time_zones" must be created and migrated to the current version.

        :param source_json_file: path and filename (usually kiosk.json) of the time zone file that was generated
                                  with generate_kiosk_time_zone_dist
        :param commit: set to False if this runs withing an external transaction.

        :return: none. throws exceptions on failure.
        """
        if not KioskSQLDb.does_table_exist("kiosk_time_zones"):
            raise Exception(f"{self.__class__.__name__}.update_local_kiosk_time_zones: "
                            f"Table kiosk_time_zones does not exists")

        if not os.path.isfile(source_json_file):
            raise Exception(f"{self.__class__.__name__}.update_local_kiosk_time_zones: "
                            f"File {source_json_file} does not exists")
        with open(source_json_file, 'r') as f:
            json_tz_info: List[Tuple[int, str, str, bool]] = json.load(f)

        if not json_tz_info:
            raise Exception(f"{self.__class__.__name__}.update_local_kiosk_time_zones: "
                            f"File {source_json_file} does not contain time zones")

        KioskSQLDb.truncate_table("kiosk_time_zones")
        sql_insert = "insert into kiosk_time_zones VALUES(%s,%s,%s,%s,%s)"
        for c, tz in enumerate(json_tz_info):
            KioskSQLDb.execute(sql_insert, tz)
        if commit:
            KioskSQLDb.commit()
        logging.info(f"{self.__class__.__name__}.update_local_kiosk_time_zones: {c} time zones inserted.")


# if __name__ == '__main__':
#     # kiosk_tz = KioskTimeZones("backward")
#     # kiosk_tz.generate_kiosk_time_zone_dist("kiosk_tz.json")
#     cfg = SyncConfig.get_config({'config_file': r'C:\notebook_source\kiosk\server\kiosk\kiosk\config\kiosk_config.yml'})
#     kiosk_tz = KioskTimeZones()
#     kiosk_tz.update_local_kiosk_time_zones("kiosk_tz.json")
