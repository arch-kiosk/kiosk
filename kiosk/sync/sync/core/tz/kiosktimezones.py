import datetime
import hashlib
import json
import logging
import os
import re
import time
import zoneinfo
import tzlocal
from typing import Tuple, List, Set, Union

from babel import dates

import kioskstdlib
from kioskdatetimelib import utc_ts_to_timezone_ts, extend_local_timezone, get_utc_now, utc_ts_to_timezone_ts
from kiosksqldb import KioskSQLDb


class KioskTimeZones:
    """
    Class representing a utility for managing and retrieving time zones in Kiosk.

    """

    def __init__(self, iana_backward_file: str = "", cache_time_zones=False):
        self.iana_backward_file = iana_backward_file
        self.deprecated_aliases: Set = set()
        self._time_zone_cache = {}
        self._iana_2_index = {}
        self._cache_time_zones = cache_time_zones

    def read_deprecated_aliases(self) -> Set[str]:
        """
        Reads and extracts deprecated aliases from the 'backward' IANA file given in the constructor.
        The backward file is part of the IANA's database at https://www.iana.org/time-zones. Just download
        the data only distribution and fish the backward file out of the archive.
        Usually Kiosk keeps that file under tools\tz

        :return: A set of deprecated aliases extracted from the file.
        """
        if not self.deprecated_aliases:
            if not self.iana_backward_file:
                raise Exception(f"read_deprecated_aliases needs path and filename of the 'backward' IANA file.")
            if not os.path.isfile(self.iana_backward_file):
                raise Exception(f"the file {self.iana_backward_file} does not exist")
            with open(self.iana_backward_file, "r") as fp:
                for line_full in fp:
                    line = line_full.strip()
                    if not line.startswith("Link\t"):
                        continue
                    result = re.split("\t+", line, maxsplit=3)
                    _link, _dest, source, *_ = result
                    self.deprecated_aliases.add(source)

        return self.deprecated_aliases

    def generate_time_zones(self) -> List[Tuple[int, str, str, bool]]:
        """
        Generate and list all available time zones with their human-readable names and full names.

        :return: A list of tuples containing a stable integer hash (not random), human-readable name,
                  IANA time zone name and a deprecation flag for each time zone.

                  Note that the hash is not necessarily, but most likely unique,
                  show the human-readable name but use the IANA time zone name

        :raises all kinds of exceptions
        """

        tz_array: List[Tuple[int, str, str, bool]] = []
        self.read_deprecated_aliases()

        for tz in zoneinfo.available_timezones():
            deprecated = tz not in self.deprecated_aliases
            try:
                tz_human = dates.get_timezone_name(dt_or_tzinfo=dates.get_timezone(tz), locale="en_US")
                if tz_human.find("Unknown Region") == -1:
                    tz_full = f"{tz_human} ({tz.replace('_', ' ')})"
                    hash = int(hashlib.md5(tz_full.encode("utf-8"), usedforsecurity=False).hexdigest(), 16) % (10 ** 8)
                    tz_array.append(
                        (hash,
                         tz_full,
                         tz,
                         deprecated))
                    # # just for testing duplicate hashes
                    # if tz_full.find("New York") > -1:
                    #     print("!TEST: Generating an entry for Providence")
                    #     tz_array.append(
                    #         (hash,   # same hash as New York
                    #          "Providence",
                    #          "Providence",
                    #          True))

            except BaseException as e:
                tz_array.append(
                    (int(hashlib.md5(tz.encode("utf-8"), usedforsecurity=False).hexdigest(), 16) % (10 ** 8),
                     tz,
                     tz,
                     deprecated))

        return tz_array

    def generate_kiosk_time_zone_dist(self, target_json_file: str, console_output=True):
        """
        creates a json file and writes all available time zone information as returned by generate_time_zones
        into that file. Per time zone it adds a version integer that indicates
        with which run of generate_kiosk_time_zone_dist a time zone was added.

        This is meant to work on the same file forever as only that way stable unique hash values
        can be avoided properly. Kiosk uses tools/kiosk_tz.json for that. And it is generated by the developer so
        that ALL projects use the same hashes.

        :param target_json_file: usually tools/kiosk_tz.json
        :param console_output: set to False if you don't want any printouts to the console
        """

        def get_tz_index(lst: List[Tuple[int, str, str, bool, int]], tz_hash):
            for i, tz_found in enumerate(lst):
                if tz_found[0] == tz_hash:
                    return i
            return -1

        time_zones = self.generate_time_zones()
        if not time_zones:
            raise Exception("KioskTimeZones.generate_kiosk_time_zone_info: "
                            "Generating time zones failed. The result was empty.")

        json_tz_info: List[Tuple[int, str, str, bool, int]] = []

        if os.path.isfile(target_json_file):
            with open(target_json_file, 'r') as f:
                json_tz_info: List[Tuple[int, str, str, bool, int]] = json.load(f)

        for idx, json_tz in enumerate(json_tz_info):
            json_tz_info[idx] = (json_tz[0], "", json_tz[2], json_tz[3], json_tz[4])

        version = int(time.time())
        tz_updated = 0
        for tz in time_zones:
            while True:
                idx = get_tz_index(json_tz_info, tz[0])
                if idx > -1:  # hash already exists
                    json_tz = json_tz_info[idx]
                    if tz[2] == json_tz[2]:  # is it the same IANA time zone?
                        json_tz_info[idx] = (
                            tz[0], tz[1], tz[2], tz[3], json_tz[4])  # update tz information, but keep version
                        tz_updated += 1
                    else:  # duplicate hash: make a new hash and try again
                        if console_output:
                            print("Time zone " + tz[1] + " duplicate!")
                        tz = (tz[0] + 1, tz[1], tz[2], tz[3], version)
                        continue
                else:  # new tz entry
                    if console_output:
                        print("Time zone " + tz[1] + " is new")
                    tz_updated += 1
                    json_tz_info.append((tz[0], tz[1], tz[2], tz[3], version))

                break

        #  eliminate time zone entries that don't exist anymore
        json_tz_info = [json_tz for json_tz in json_tz_info if json_tz[1] != ""]

        with open(target_json_file, 'w') as f:
            json.dump(json_tz_info, f)

        if console_output:
            print(f"generate_kiosk_time_zone_dist updated {tz_updated} time zones")

    def update_local_kiosk_time_zones(self, source_json_file: str, commit=True) -> int:
        """
        Loads the time zones from a json file into the local database's time_zones table.
        Note that the target able "kiosk_time_zones" must be created and migrated to the current version.

        :param source_json_file: path and filename (usually kiosk.json) of the time zone file that was generated
                                  with generate_kiosk_time_zone_dist
        :param commit: set to False if this runs withing an external transaction.

        :return: number of imported time zones. throws exceptions on failure.
        """
        if not KioskSQLDb.does_table_exist("kiosk_time_zones"):
            raise Exception(f"{self.__class__.__name__}.update_local_kiosk_time_zones: "
                            f"Table kiosk_time_zones does not exists")

        if not os.path.isfile(source_json_file):
            raise Exception(f"{self.__class__.__name__}.update_local_kiosk_time_zones: "
                            f"File {source_json_file} does not exists")
        with open(source_json_file, 'r') as f:
            json_tz_info: List[Tuple[int, str, str, bool]] = json.load(f)

        if not json_tz_info:
            raise Exception(f"{self.__class__.__name__}.update_local_kiosk_time_zones: "
                            f"File {source_json_file} does not contain time zones")

        KioskSQLDb.truncate_table("kiosk_time_zones")
        sql_insert = "insert" + " into kiosk_time_zones VALUES(%s,%s,%s,%s,%s)"
        c = 0
        for c, tz in enumerate(json_tz_info):
            KioskSQLDb.execute(sql_insert, tz)
        if commit:
            KioskSQLDb.commit()
        logging.info(f"{self.__class__.__name__}.update_local_kiosk_time_zones: {c} time zones inserted.")
        return c

    def update_cache(self, time_zone_records: list):
        if not self._cache_time_zones:
            return

        if not time_zone_records:
            return

        r = time_zone_records if isinstance(time_zone_records[0], list) else [time_zone_records, ]
        for tz_info in r:
            logging.debug(f"{self.__class__.__name__}.update_cache: caching time zone {tz_info[0]}")
            self._time_zone_cache[tz_info[0]] = tz_info
            self._iana_2_index[tz_info[2]] = tz_info[0]

    def list_time_zones(self, after_version=0, include_deprecated=False, filter_text=""):
        """
        Retrieve a list of time zones from the 'kiosk_time_zones' table based on certain criteria.

        :param after_version: An integer representing the version after which time zones should be listed.
        :param include_deprecated: A boolean indicating whether deprecated time zones should be included in the list.
        :param filter_text: an optional string to filter by tz_long

        :return: A list of time zone records retrieved from the 'kiosk_time_zones' table
                  based on the specified criteria.

        :raises: Any exception that occurs.
        """
        try:
            sql = "select " + "* from kiosk_time_zones"
            sql_where = ""
            sql_parameter = []
            if not include_deprecated:
                sql_where += " WHERE not deprecated"
            if after_version > 0:
                sql_where += (" AND " if sql_where else " WHERE ") + f"version > %s"
                sql_parameter.append(after_version)
            if filter_text:
                sql_where += (" AND " if sql_where else " WHERE ") + f"tz_long ILIKE %s"
                sql_parameter.append(f'%{filter_text}%')
            # print(sql + sql_where)
            time_zone_records = KioskSQLDb.get_records(sql + sql_where, params=sql_parameter)
            self.update_cache(time_zone_records)
            return time_zone_records
        except BaseException as e:
            logging.error(f"{self.__class__.__name__}.list_time_zones: {repr(e)}")
            raise e

    def get_time_zone_info(self, tz_index):
        """
        return the time zone information for a tz index (the id of a kiosk_time_zone record).
        :param tz_index: if None -> [None, "-", "-", False, 1], if 0 -> info for UTC,
                otherwise info for the time zone
        :return: a list that corresponds with the structure of the kiosk_time_zone table:
                 [id, tz_long, tz_IANA, deprecated, version] or None in terms of an error
         :raises no exceptions. They all get caught and logged.
        """
        try:
            if tz_index is None:
                return [None, "-", "-", False, 1]

            if tz_index == 0:
                return [0, "UTC", "UTC", False, 1]

            r = self._time_zone_cache.get(tz_index, None)
            if r:
                # logging.debug(f"{self.__class__.__name__}.get_time_zone_info: "
                #               f"got time zone info for {tz_index} from cache")
                return r
            # else:
            #     logging.debug(f"{self.__class__.__name__}.get_time_zone_info: "
            #                   f"{tz_index} not in cache")

            r = KioskSQLDb.get_records("select" + " * from kiosk_time_zones where \"id\"=%s", params=[tz_index])
            if len(r) == 1:
                self.update_cache(r)
                return r[0]
            return None
        except BaseException as e:
            logging.error(f"{self.__class__.__name__}. : {repr(e)}")
            return None

    def get_iana_time_zone(self, tz_index) -> str:
        """
        returns the iana time zone name for a kiosk time zone index.
        If the index does not exist, the result will be an empty string.
        :param tz_index: Kiosk Time Zone Index
        :return: str
        """
        tz_info = self.get_time_zone_info(tz_index)
        return tz_info[2] if tz_info else "-"

    def get_long_time_zone(self, tz_index) -> str:
        """
        returns the long time zone name for a kiosk time zone index.
        If the index does not exist, the result will be an empty string.
        :param tz_index: Kiosk Time Zone Index
        :return: str
        """
        tz_info = self.get_time_zone_info(tz_index)
        return tz_info[1] if tz_info else "-"

    def get_time_zone_index(self, iana_name: str) -> Union[int, None]:
        """
        returns the tz_index for a IANA time zone
        :param iana_name: the name of a IANA time zone (case sensitive)
        :return: the kiosk time zone index for the iana_name or None (explicitly as 0 is UTC) if unknown
        """
        if iana_name.lower() == "utc":
            return 0
        try:
            tz_index = self._iana_2_index.get(iana_name, None)
            if tz_index is not None:
                # logging.debug(f"{self.__class__.__name__}.get_time_zone_index: "
                #               f"got time zone index for {iana_name} from cache")
                return tz_index

            r = KioskSQLDb.get_records("select " + "* from kiosk_time_zones where \"tz_IANA\"=%s", [iana_name, ])
            if len(r) == 1:
                return r[0][0]
            if len(r) > 1:
                logging.warning(f"{self.__class__.__name__}.get_time_zone_index: iana name {iana_name} "
                                f"exists more than once!")
                return r[0][0]
            return None
        except BaseException as e:
            logging.error(f"{self.__class__.__name__}.get_time_zone_index: {repr(e)}")
        return None

    def kiosk_timestamp_to_display_timestamp(self, utc_timestamp: Union[datetime.datetime, str],
                                             tz_field: Union[int, None],
                                             target_tz: Union[int, str] = None) -> (datetime.datetime, int):
        """
        returns the correct display value for a time stamp according to the timestamp's _tz-field
        and the expected target time zone
        :param utc_timestamp: utc date and time either as datetime or iso8601 string
        :param tz_field: the assigned _tz field
        :param target_tz: optional. Can be tz index or IANA time zone.
                If not given the tz_field defines the target time zone.
        :returns: a tuple consisting of the resulting timestamp and an integer that determines the time zone:
                    0: legacy time stamp, unknown time zone
                    1: time zone according to source (_tz field)
                    2: target time zone
        """

        if not utc_timestamp:
            raise ValueError("empty parameter in kiosk_timestamp_to_display_timestamp")

        if isinstance(utc_timestamp, str):
            dt = kioskstdlib.str_to_iso8601(utc_timestamp)
        else:
            dt = utc_timestamp

        if tz_field is None:
            # time stamp is a legacy date
            # in this case the utc date time stays what it is, independent of the target time zone
            return dt.astimezone(zoneinfo.ZoneInfo("UTC")).replace(tzinfo=None), 0

        if target_tz:
            if isinstance(target_tz, str):
                target_time_zone = target_tz
            else:
                tz_info = self.get_time_zone_info(target_tz)
                if not tz_info:
                    raise ValueError(f"target time zone {target_tz} unknown")

                target_time_zone = tz_info[2]

            return utc_ts_to_timezone_ts(dt, target_time_zone), 2
        else:
            if tz_field == 0:
                source_time_zone = "UTC"
            else:
                tz_info = self.get_time_zone_info(tz_field)
                if not tz_info:
                    raise ValueError(f"source time zone {tz_field} unknown")
                source_time_zone = tz_info[2]

            return utc_ts_to_timezone_ts(dt, source_time_zone), 1


    @classmethod
    def get_modified_components_from_now(cls, tz_index: int=None):
        """
        create a current time stamp and return all components neede for a modified field
        :param tz_index: the tz_index of the time zone within which the _ww part of the modified is expected.
                          if None a tz_index is created from the current system settings.
                          Whatever that'll be, so avoid it!
        :return: a triplet: utc time stamp, tz index, wristwatch time stamp
        :throws an exception if the tz_index or the iana_time_zone name cannot be determined
        """
        iana_time_zone = ""
        time_zones = KioskTimeZones()
        if tz_index:
            iana_time_zone = time_zones.get_iana_time_zone(tz_index)

        if not iana_time_zone:
            iana_time_zone = cls.get_local_scripts_time_zone_name()
            tz_index = time_zones.get_time_zone_index(iana_time_zone)
            if tz_index is None or not iana_time_zone:
                raise Exception(f"Cannot create time zone information. "
                                f"IANA time {iana_time_zone} does not have a time zone index.")

        utc_ts = get_utc_now()
        return utc_ts, tz_index, utc_ts_to_timezone_ts(utc_ts,iana_time_zone,replace_ms=True)

# if __name__ == '__main__':
#     # cfg = SyncConfig.get_config({'config_file': r'C:\notebook_source\kiosk\server\kiosk\kiosk\config\kiosk_config.yml'})
#     # kiosk_tz = KioskTimeZones()
#     # pprint(kiosk_tz.list_time_zones())
#     #
# #     # kiosk_tz = KioskTimeZones("backward")
# #     # kiosk_tz.generate_kiosk_time_zone_dist("kiosk_tz.json")
#     cfg = SyncConfig.get_config({'config_file': r'C:\notebook_source\kiosk\server\kiosk\kiosk\config\kiosk_config.yml'})
#     kiosk_tz = KioskTimeZones()
#     kiosk_tz.update_local_kiosk_time_zones(r"C:\notebook_source\kiosk\server\kiosk\kiosk\tools\tz\kiosk_tz.json")

    @classmethod
    def get_local_scripts_time_zone_name(cls):
        """
        returns the iana name of the loca system (the one on which this python script runs!).
        So this is usually not want you want!
        :return:
        """
        return tzlocal.get_localzone_name()
