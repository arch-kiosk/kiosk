/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function Zt(s, n = "24.5.5") {
  Object.defineProperty(s, "version", {
    get() {
      return n;
    }
  });
  const e = customElements.get(s.is);
  if (!e)
    customElements.define(s.is, s);
  else {
    const t = e.version;
    t && s.version && t === s.version ? console.warn(`The component ${s.is} has been loaded twice`) : console.error(
      `Tried to define ${s.is} version ${s.version} when version ${e.version} is already in use. Something will probably break.`
    );
  }
}
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class Xc extends HTMLElement {
  static get is() {
    return "vaadin-lumo-styles";
  }
}
Zt(Xc);
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const on = globalThis, Qo = on.ShadowRoot && (on.ShadyCSS === void 0 || on.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, Jo = Symbol(), oa = /* @__PURE__ */ new WeakMap();
let $o = class {
  constructor(n, e, t) {
    if (this._$cssResult$ = !0, t !== Jo) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = n, this.t = e;
  }
  get styleSheet() {
    let n = this.o;
    const e = this.t;
    if (Qo && n === void 0) {
      const t = e !== void 0 && e.length === 1;
      t && (n = oa.get(e)), n === void 0 && ((this.o = n = new CSSStyleSheet()).replaceSync(this.cssText), t && oa.set(e, n));
    }
    return n;
  }
  toString() {
    return this.cssText;
  }
};
const yr = (s) => new $o(typeof s == "string" ? s : s + "", void 0, Jo), ke = (s, ...n) => {
  const e = s.length === 1 ? s[0] : n.reduce(((t, i, r) => t + ((o) => {
    if (o._$cssResult$ === !0) return o.cssText;
    if (typeof o == "number") return o;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + o + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(i) + s[r + 1]), s[0]);
  return new $o(e, s, Jo);
}, rl = (s, n) => {
  if (Qo) s.adoptedStyleSheets = n.map(((e) => e instanceof CSSStyleSheet ? e : e.styleSheet));
  else for (const e of n) {
    const t = document.createElement("style"), i = on.litNonce;
    i !== void 0 && t.setAttribute("nonce", i), t.textContent = e.cssText, s.appendChild(t);
  }
}, sa = Qo ? (s) => s : (s) => s instanceof CSSStyleSheet ? ((n) => {
  let e = "";
  for (const t of n.cssRules) e += t.cssText;
  return yr(e);
})(s) : s;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const { is: Qc, defineProperty: Jc, getOwnPropertyDescriptor: $c, getOwnPropertyNames: eu, getOwnPropertySymbols: tu, getPrototypeOf: iu } = Object, Sn = globalThis, aa = Sn.trustedTypes, ru = aa ? aa.emptyScript : "", nu = Sn.reactiveElementPolyfillSupport, cr = (s, n) => s, pn = { toAttribute(s, n) {
  switch (n) {
    case Boolean:
      s = s ? ru : null;
      break;
    case Object:
    case Array:
      s = s == null ? s : JSON.stringify(s);
  }
  return s;
}, fromAttribute(s, n) {
  let e = s;
  switch (n) {
    case Boolean:
      e = s !== null;
      break;
    case Number:
      e = s === null ? null : Number(s);
      break;
    case Object:
    case Array:
      try {
        e = JSON.parse(s);
      } catch {
        e = null;
      }
  }
  return e;
} }, es = (s, n) => !Qc(s, n), la = { attribute: !0, type: String, converter: pn, reflect: !1, useDefault: !1, hasChanged: es };
Symbol.metadata ??= Symbol("metadata"), Sn.litPropertyMetadata ??= /* @__PURE__ */ new WeakMap();
let Ri = class extends HTMLElement {
  static addInitializer(n) {
    this._$Ei(), (this.l ??= []).push(n);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(n, e = la) {
    if (e.state && (e.attribute = !1), this._$Ei(), this.prototype.hasOwnProperty(n) && ((e = Object.create(e)).wrapped = !0), this.elementProperties.set(n, e), !e.noAccessor) {
      const t = Symbol(), i = this.getPropertyDescriptor(n, t, e);
      i !== void 0 && Jc(this.prototype, n, i);
    }
  }
  static getPropertyDescriptor(n, e, t) {
    const { get: i, set: r } = $c(this.prototype, n) ?? { get() {
      return this[e];
    }, set(o) {
      this[e] = o;
    } };
    return { get: i, set(o) {
      const a = i?.call(this);
      r?.call(this, o), this.requestUpdate(n, a, t);
    }, configurable: !0, enumerable: !0 };
  }
  static getPropertyOptions(n) {
    return this.elementProperties.get(n) ?? la;
  }
  static _$Ei() {
    if (this.hasOwnProperty(cr("elementProperties"))) return;
    const n = iu(this);
    n.finalize(), n.l !== void 0 && (this.l = [...n.l]), this.elementProperties = new Map(n.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(cr("finalized"))) return;
    if (this.finalized = !0, this._$Ei(), this.hasOwnProperty(cr("properties"))) {
      const e = this.properties, t = [...eu(e), ...tu(e)];
      for (const i of t) this.createProperty(i, e[i]);
    }
    const n = this[Symbol.metadata];
    if (n !== null) {
      const e = litPropertyMetadata.get(n);
      if (e !== void 0) for (const [t, i] of e) this.elementProperties.set(t, i);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [e, t] of this.elementProperties) {
      const i = this._$Eu(e, t);
      i !== void 0 && this._$Eh.set(i, e);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(n) {
    const e = [];
    if (Array.isArray(n)) {
      const t = new Set(n.flat(1 / 0).reverse());
      for (const i of t) e.unshift(sa(i));
    } else n !== void 0 && e.push(sa(n));
    return e;
  }
  static _$Eu(n, e) {
    const t = e.attribute;
    return t === !1 ? void 0 : typeof t == "string" ? t : typeof n == "string" ? n.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = !1, this.hasUpdated = !1, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    this._$ES = new Promise(((n) => this.enableUpdating = n)), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), this.constructor.l?.forEach(((n) => n(this)));
  }
  addController(n) {
    (this._$EO ??= /* @__PURE__ */ new Set()).add(n), this.renderRoot !== void 0 && this.isConnected && n.hostConnected?.();
  }
  removeController(n) {
    this._$EO?.delete(n);
  }
  _$E_() {
    const n = /* @__PURE__ */ new Map(), e = this.constructor.elementProperties;
    for (const t of e.keys()) this.hasOwnProperty(t) && (n.set(t, this[t]), delete this[t]);
    n.size > 0 && (this._$Ep = n);
  }
  createRenderRoot() {
    const n = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return rl(n, this.constructor.elementStyles), n;
  }
  connectedCallback() {
    this.renderRoot ??= this.createRenderRoot(), this.enableUpdating(!0), this._$EO?.forEach(((n) => n.hostConnected?.()));
  }
  enableUpdating(n) {
  }
  disconnectedCallback() {
    this._$EO?.forEach(((n) => n.hostDisconnected?.()));
  }
  attributeChangedCallback(n, e, t) {
    this._$AK(n, t);
  }
  _$ET(n, e) {
    const t = this.constructor.elementProperties.get(n), i = this.constructor._$Eu(n, t);
    if (i !== void 0 && t.reflect === !0) {
      const r = (t.converter?.toAttribute !== void 0 ? t.converter : pn).toAttribute(e, t.type);
      this._$Em = n, r == null ? this.removeAttribute(i) : this.setAttribute(i, r), this._$Em = null;
    }
  }
  _$AK(n, e) {
    const t = this.constructor, i = t._$Eh.get(n);
    if (i !== void 0 && this._$Em !== i) {
      const r = t.getPropertyOptions(i), o = typeof r.converter == "function" ? { fromAttribute: r.converter } : r.converter?.fromAttribute !== void 0 ? r.converter : pn;
      this._$Em = i;
      const a = o.fromAttribute(e, r.type);
      this[i] = a ?? this._$Ej?.get(i) ?? a, this._$Em = null;
    }
  }
  requestUpdate(n, e, t) {
    if (n !== void 0) {
      const i = this.constructor, r = this[n];
      if (t ??= i.getPropertyOptions(n), !((t.hasChanged ?? es)(r, e) || t.useDefault && t.reflect && r === this._$Ej?.get(n) && !this.hasAttribute(i._$Eu(n, t)))) return;
      this.C(n, e, t);
    }
    this.isUpdatePending === !1 && (this._$ES = this._$EP());
  }
  C(n, e, { useDefault: t, reflect: i, wrapped: r }, o) {
    t && !(this._$Ej ??= /* @__PURE__ */ new Map()).has(n) && (this._$Ej.set(n, o ?? e ?? this[n]), r !== !0 || o !== void 0) || (this._$AL.has(n) || (this.hasUpdated || t || (e = void 0), this._$AL.set(n, e)), i === !0 && this._$Em !== n && (this._$Eq ??= /* @__PURE__ */ new Set()).add(n));
  }
  async _$EP() {
    this.isUpdatePending = !0;
    try {
      await this._$ES;
    } catch (e) {
      Promise.reject(e);
    }
    const n = this.scheduleUpdate();
    return n != null && await n, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    if (!this.isUpdatePending) return;
    if (!this.hasUpdated) {
      if (this.renderRoot ??= this.createRenderRoot(), this._$Ep) {
        for (const [i, r] of this._$Ep) this[i] = r;
        this._$Ep = void 0;
      }
      const t = this.constructor.elementProperties;
      if (t.size > 0) for (const [i, r] of t) {
        const { wrapped: o } = r, a = this[i];
        o !== !0 || this._$AL.has(i) || a === void 0 || this.C(i, void 0, r, a);
      }
    }
    let n = !1;
    const e = this._$AL;
    try {
      n = this.shouldUpdate(e), n ? (this.willUpdate(e), this._$EO?.forEach(((t) => t.hostUpdate?.())), this.update(e)) : this._$EM();
    } catch (t) {
      throw n = !1, this._$EM(), t;
    }
    n && this._$AE(e);
  }
  willUpdate(n) {
  }
  _$AE(n) {
    this._$EO?.forEach(((e) => e.hostUpdated?.())), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(n)), this.updated(n);
  }
  _$EM() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = !1;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(n) {
    return !0;
  }
  update(n) {
    this._$Eq &&= this._$Eq.forEach(((e) => this._$ET(e, this[e]))), this._$EM();
  }
  updated(n) {
  }
  firstUpdated(n) {
  }
};
Ri.elementStyles = [], Ri.shadowRootOptions = { mode: "open" }, Ri[cr("elementProperties")] = /* @__PURE__ */ new Map(), Ri[cr("finalized")] = /* @__PURE__ */ new Map(), nu?.({ ReactiveElement: Ri }), (Sn.reactiveElementVersions ??= []).push("2.1.1");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const ts = globalThis, gn = ts.trustedTypes, ca = gn ? gn.createPolicy("lit-html", { createHTML: (s) => s }) : void 0, nl = "$lit$", Wt = `lit$${Math.random().toFixed(9).slice(2)}$`, ol = "?" + Wt, ou = `<${ol}>`, hi = document, hr = () => hi.createComment(""), fr = (s) => s === null || typeof s != "object" && typeof s != "function", is = Array.isArray, su = (s) => is(s) || typeof s?.[Symbol.iterator] == "function", po = `[ 	
\f\r]`, tr = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, ua = /-->/g, da = />/g, ni = RegExp(`>|${po}(?:([^\\s"'>=/]+)(${po}*=${po}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), ha = /'/g, fa = /"/g, sl = /^(?:script|style|textarea|title)$/i, au = (s) => (n, ...e) => ({ _$litType$: s, strings: n, values: e }), We = au(1), fi = Symbol.for("lit-noChange"), ze = Symbol.for("lit-nothing"), pa = /* @__PURE__ */ new WeakMap(), ai = hi.createTreeWalker(hi, 129);
function al(s, n) {
  if (!is(s) || !s.hasOwnProperty("raw")) throw Error("invalid template strings array");
  return ca !== void 0 ? ca.createHTML(n) : n;
}
const lu = (s, n) => {
  const e = s.length - 1, t = [];
  let i, r = n === 2 ? "<svg>" : n === 3 ? "<math>" : "", o = tr;
  for (let a = 0; a < e; a++) {
    const c = s[a];
    let u, h, f = -1, g = 0;
    for (; g < c.length && (o.lastIndex = g, h = o.exec(c), h !== null); ) g = o.lastIndex, o === tr ? h[1] === "!--" ? o = ua : h[1] !== void 0 ? o = da : h[2] !== void 0 ? (sl.test(h[2]) && (i = RegExp("</" + h[2], "g")), o = ni) : h[3] !== void 0 && (o = ni) : o === ni ? h[0] === ">" ? (o = i ?? tr, f = -1) : h[1] === void 0 ? f = -2 : (f = o.lastIndex - h[2].length, u = h[1], o = h[3] === void 0 ? ni : h[3] === '"' ? fa : ha) : o === fa || o === ha ? o = ni : o === ua || o === da ? o = tr : (o = ni, i = void 0);
    const x = o === ni && s[a + 1].startsWith("/>") ? " " : "";
    r += o === tr ? c + ou : f >= 0 ? (t.push(u), c.slice(0, f) + nl + c.slice(f) + Wt + x) : c + Wt + (f === -2 ? a : x);
  }
  return [al(s, r + (s[e] || "<?>") + (n === 2 ? "</svg>" : n === 3 ? "</math>" : "")), t];
};
class pr {
  constructor({ strings: n, _$litType$: e }, t) {
    let i;
    this.parts = [];
    let r = 0, o = 0;
    const a = n.length - 1, c = this.parts, [u, h] = lu(n, e);
    if (this.el = pr.createElement(u, t), ai.currentNode = this.el.content, e === 2 || e === 3) {
      const f = this.el.content.firstChild;
      f.replaceWith(...f.childNodes);
    }
    for (; (i = ai.nextNode()) !== null && c.length < a; ) {
      if (i.nodeType === 1) {
        if (i.hasAttributes()) for (const f of i.getAttributeNames()) if (f.endsWith(nl)) {
          const g = h[o++], x = i.getAttribute(f).split(Wt), C = /([.?@])?(.*)/.exec(g);
          c.push({ type: 1, index: r, name: C[2], strings: x, ctor: C[1] === "." ? uu : C[1] === "?" ? du : C[1] === "@" ? hu : kn }), i.removeAttribute(f);
        } else f.startsWith(Wt) && (c.push({ type: 6, index: r }), i.removeAttribute(f));
        if (sl.test(i.tagName)) {
          const f = i.textContent.split(Wt), g = f.length - 1;
          if (g > 0) {
            i.textContent = gn ? gn.emptyScript : "";
            for (let x = 0; x < g; x++) i.append(f[x], hr()), ai.nextNode(), c.push({ type: 2, index: ++r });
            i.append(f[g], hr());
          }
        }
      } else if (i.nodeType === 8) if (i.data === ol) c.push({ type: 2, index: r });
      else {
        let f = -1;
        for (; (f = i.data.indexOf(Wt, f + 1)) !== -1; ) c.push({ type: 7, index: r }), f += Wt.length - 1;
      }
      r++;
    }
  }
  static createElement(n, e) {
    const t = hi.createElement("template");
    return t.innerHTML = n, t;
  }
}
function Mi(s, n, e = s, t) {
  if (n === fi) return n;
  let i = t !== void 0 ? e._$Co?.[t] : e._$Cl;
  const r = fr(n) ? void 0 : n._$litDirective$;
  return i?.constructor !== r && (i?._$AO?.(!1), r === void 0 ? i = void 0 : (i = new r(s), i._$AT(s, e, t)), t !== void 0 ? (e._$Co ??= [])[t] = i : e._$Cl = i), i !== void 0 && (n = Mi(s, i._$AS(s, n.values), i, t)), n;
}
class cu {
  constructor(n, e) {
    this._$AV = [], this._$AN = void 0, this._$AD = n, this._$AM = e;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(n) {
    const { el: { content: e }, parts: t } = this._$AD, i = (n?.creationScope ?? hi).importNode(e, !0);
    ai.currentNode = i;
    let r = ai.nextNode(), o = 0, a = 0, c = t[0];
    for (; c !== void 0; ) {
      if (o === c.index) {
        let u;
        c.type === 2 ? u = new wr(r, r.nextSibling, this, n) : c.type === 1 ? u = new c.ctor(r, c.name, c.strings, this, n) : c.type === 6 && (u = new fu(r, this, n)), this._$AV.push(u), c = t[++a];
      }
      o !== c?.index && (r = ai.nextNode(), o++);
    }
    return ai.currentNode = hi, i;
  }
  p(n) {
    let e = 0;
    for (const t of this._$AV) t !== void 0 && (t.strings !== void 0 ? (t._$AI(n, t, e), e += t.strings.length - 2) : t._$AI(n[e])), e++;
  }
}
class wr {
  get _$AU() {
    return this._$AM?._$AU ?? this._$Cv;
  }
  constructor(n, e, t, i) {
    this.type = 2, this._$AH = ze, this._$AN = void 0, this._$AA = n, this._$AB = e, this._$AM = t, this.options = i, this._$Cv = i?.isConnected ?? !0;
  }
  get parentNode() {
    let n = this._$AA.parentNode;
    const e = this._$AM;
    return e !== void 0 && n?.nodeType === 11 && (n = e.parentNode), n;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(n, e = this) {
    n = Mi(this, n, e), fr(n) ? n === ze || n == null || n === "" ? (this._$AH !== ze && this._$AR(), this._$AH = ze) : n !== this._$AH && n !== fi && this._(n) : n._$litType$ !== void 0 ? this.$(n) : n.nodeType !== void 0 ? this.T(n) : su(n) ? this.k(n) : this._(n);
  }
  O(n) {
    return this._$AA.parentNode.insertBefore(n, this._$AB);
  }
  T(n) {
    this._$AH !== n && (this._$AR(), this._$AH = this.O(n));
  }
  _(n) {
    this._$AH !== ze && fr(this._$AH) ? this._$AA.nextSibling.data = n : this.T(hi.createTextNode(n)), this._$AH = n;
  }
  $(n) {
    const { values: e, _$litType$: t } = n, i = typeof t == "number" ? this._$AC(n) : (t.el === void 0 && (t.el = pr.createElement(al(t.h, t.h[0]), this.options)), t);
    if (this._$AH?._$AD === i) this._$AH.p(e);
    else {
      const r = new cu(i, this), o = r.u(this.options);
      r.p(e), this.T(o), this._$AH = r;
    }
  }
  _$AC(n) {
    let e = pa.get(n.strings);
    return e === void 0 && pa.set(n.strings, e = new pr(n)), e;
  }
  k(n) {
    is(this._$AH) || (this._$AH = [], this._$AR());
    const e = this._$AH;
    let t, i = 0;
    for (const r of n) i === e.length ? e.push(t = new wr(this.O(hr()), this.O(hr()), this, this.options)) : t = e[i], t._$AI(r), i++;
    i < e.length && (this._$AR(t && t._$AB.nextSibling, i), e.length = i);
  }
  _$AR(n = this._$AA.nextSibling, e) {
    for (this._$AP?.(!1, !0, e); n !== this._$AB; ) {
      const t = n.nextSibling;
      n.remove(), n = t;
    }
  }
  setConnected(n) {
    this._$AM === void 0 && (this._$Cv = n, this._$AP?.(n));
  }
}
let kn = class {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(n, e, t, i, r) {
    this.type = 1, this._$AH = ze, this._$AN = void 0, this.element = n, this.name = e, this._$AM = i, this.options = r, t.length > 2 || t[0] !== "" || t[1] !== "" ? (this._$AH = Array(t.length - 1).fill(new String()), this.strings = t) : this._$AH = ze;
  }
  _$AI(n, e = this, t, i) {
    const r = this.strings;
    let o = !1;
    if (r === void 0) n = Mi(this, n, e, 0), o = !fr(n) || n !== this._$AH && n !== fi, o && (this._$AH = n);
    else {
      const a = n;
      let c, u;
      for (n = r[0], c = 0; c < r.length - 1; c++) u = Mi(this, a[t + c], e, c), u === fi && (u = this._$AH[c]), o ||= !fr(u) || u !== this._$AH[c], u === ze ? n = ze : n !== ze && (n += (u ?? "") + r[c + 1]), this._$AH[c] = u;
    }
    o && !i && this.j(n);
  }
  j(n) {
    n === ze ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, n ?? "");
  }
};
class uu extends kn {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(n) {
    this.element[this.name] = n === ze ? void 0 : n;
  }
}
class du extends kn {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(n) {
    this.element.toggleAttribute(this.name, !!n && n !== ze);
  }
}
class hu extends kn {
  constructor(n, e, t, i, r) {
    super(n, e, t, i, r), this.type = 5;
  }
  _$AI(n, e = this) {
    if ((n = Mi(this, n, e, 0) ?? ze) === fi) return;
    const t = this._$AH, i = n === ze && t !== ze || n.capture !== t.capture || n.once !== t.once || n.passive !== t.passive, r = n !== ze && (t === ze || i);
    i && this.element.removeEventListener(this.name, this, t), r && this.element.addEventListener(this.name, this, n), this._$AH = n;
  }
  handleEvent(n) {
    typeof this._$AH == "function" ? this._$AH.call(this.options?.host ?? this.element, n) : this._$AH.handleEvent(n);
  }
}
class fu {
  constructor(n, e, t) {
    this.element = n, this.type = 6, this._$AN = void 0, this._$AM = e, this.options = t;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(n) {
    Mi(this, n);
  }
}
const pu = ts.litHtmlPolyfillSupport;
pu?.(pr, wr), (ts.litHtmlVersions ??= []).push("3.3.1");
const ll = (s, n, e) => {
  const t = e?.renderBefore ?? n;
  let i = t._$litPart$;
  if (i === void 0) {
    const r = e?.renderBefore ?? null;
    t._$litPart$ = i = new wr(n.insertBefore(hr(), r), r, void 0, e ?? {});
  }
  return i._$AI(s), i;
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const rs = globalThis;
let Ot = class extends Ri {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    const n = super.createRenderRoot();
    return this.renderOptions.renderBefore ??= n.firstChild, n;
  }
  update(n) {
    const e = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(n), this._$Do = ll(e, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    super.connectedCallback(), this._$Do?.setConnected(!0);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this._$Do?.setConnected(!1);
  }
  render() {
    return fi;
  }
};
Ot._$litElement$ = !0, Ot.finalized = !0, rs.litElementHydrateSupport?.({ LitElement: Ot });
const gu = rs.litElementPolyfillSupport;
gu?.({ LitElement: Ot });
(rs.litElementVersions ??= []).push("4.2.1");
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const mu = (s) => class extends s {
  static get properties() {
    return {
      /**
       * Helper property with theme attribute value facilitating propagation
       * in shadow DOM.
       *
       * Enables the component implementation to propagate the `theme`
       * attribute value to the sub-components in Shadow DOM by binding
       * the sub-component's "theme" attribute to the `theme` property of
       * the host.
       *
       * **NOTE:** Extending the mixin only provides the property for binding,
       * and does not make the propagation alone.
       *
       * See [Styling Components: Sub-components](https://vaadin.com/docs/latest/styling/styling-components/#sub-components).
       * page for more information.
       *
       * @protected
       */
      _theme: {
        type: String,
        readOnly: !0
      }
    };
  }
  static get observedAttributes() {
    return [...super.observedAttributes, "theme"];
  }
  /** @protected */
  attributeChangedCallback(e, t, i) {
    super.attributeChangedCallback(e, t, i), e === "theme" && this._set_theme(i);
  }
};
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const cl = [], Do = /* @__PURE__ */ new Set(), ns = /* @__PURE__ */ new Set();
function ul(s) {
  return s && Object.prototype.hasOwnProperty.call(s, "__themes");
}
function vu(s) {
  return ul(customElements.get(s));
}
function _u(s = []) {
  return [s].flat(1 / 0).filter((n) => n instanceof $o ? !0 : (console.warn("An item in styles is not of type CSSResult. Use `unsafeCSS` or `css`."), !1));
}
function dl(s, n) {
  return (s || "").split(" ").some((e) => new RegExp(`^${e.split("*").join(".*")}$`, "u").test(n));
}
function hl(s) {
  return s.map((n) => n.cssText).join(`
`);
}
const mn = "vaadin-themable-mixin-style";
function bu(s, n) {
  const e = document.createElement("style");
  e.id = mn, e.textContent = hl(s), n.content.appendChild(e);
}
function yu(s) {
  if (!s.shadowRoot)
    return;
  const n = s.constructor;
  if (s instanceof Ot)
    [...s.shadowRoot.querySelectorAll("style")].forEach((e) => e.remove()), rl(s.shadowRoot, n.elementStyles);
  else {
    const e = s.shadowRoot.getElementById(mn), t = n.prototype._template;
    e.textContent = t.content.getElementById(mn).textContent;
  }
}
function wu(s) {
  Do.forEach((n) => {
    const e = n.deref();
    e instanceof s ? yu(e) : e || Do.delete(n);
  });
}
function fl(s) {
  if (s.prototype instanceof Ot)
    s.elementStyles = s.finalizeStyles(s.styles);
  else {
    const n = s.prototype._template;
    n.content.getElementById(mn).textContent = hl(s.getStylesForThis());
  }
  ns.forEach((n) => {
    const e = customElements.get(n);
    e !== s && e.prototype instanceof s && fl(e);
  });
}
function xu(s, n) {
  const e = s.__themes;
  return !e || !n ? !1 : e.some(
    (t) => t.styles.some((i) => n.some((r) => r.cssText === i.cssText))
  );
}
function Qe(s, n, e = {}) {
  n = _u(n), window.Vaadin && window.Vaadin.styleModules ? window.Vaadin.styleModules.registerStyles(s, n, e) : cl.push({
    themeFor: s,
    styles: n,
    include: e.include,
    moduleId: e.moduleId
  }), s && ns.forEach((t) => {
    if (dl(s, t) && vu(t)) {
      const i = customElements.get(t);
      xu(i, n) ? console.warn(`Registering styles that already exist for ${t}`) : (!window.Vaadin || !window.Vaadin.suppressPostFinalizeStylesWarning) && console.warn(
        `The custom element definition for "${t}" was finalized before a style module was registered. Ideally, import component specific style modules before importing the corresponding custom element. This warning can be suppressed by setting "window.Vaadin.suppressPostFinalizeStylesWarning = true".`
      ), fl(i), wu(i);
    }
  });
}
function Oo() {
  return window.Vaadin && window.Vaadin.styleModules ? window.Vaadin.styleModules.getAllThemes() : cl;
}
function Cu(s = "") {
  let n = 0;
  return s.startsWith("lumo-") || s.startsWith("material-") ? n = 1 : s.startsWith("vaadin-") && (n = 2), n;
}
function pl(s) {
  const n = [];
  return s.include && [].concat(s.include).forEach((e) => {
    const t = Oo().find((i) => i.moduleId === e);
    t ? n.push(...pl(t), ...t.styles) : console.warn(`Included moduleId ${e} not found in style registry`);
  }, s.styles), n;
}
function Tu(s) {
  const n = `${s}-default-theme`, e = Oo().filter((t) => t.moduleId !== n && dl(t.themeFor, s)).map((t) => ({
    ...t,
    // Prepend styles from included themes
    styles: [...pl(t), ...t.styles],
    // Map moduleId to includePriority
    includePriority: Cu(t.moduleId)
  })).sort((t, i) => i.includePriority - t.includePriority);
  return e.length > 0 ? e : Oo().filter((t) => t.moduleId === n);
}
const xr = (s) => class extends mu(s) {
  constructor() {
    super(), Do.add(new WeakRef(this));
  }
  /**
   * Covers PolymerElement based component styling
   * @protected
   */
  static finalize() {
    if (super.finalize(), this.is && ns.add(this.is), this.elementStyles)
      return;
    const e = this.prototype._template;
    !e || ul(this) || bu(this.getStylesForThis(), e);
  }
  /**
   * Covers LitElement based component styling
   *
   * @protected
   */
  static finalizeStyles(e) {
    const t = this.getStylesForThis();
    return e ? [...[e].flat(1 / 0), ...t] : t;
  }
  /**
   * Get styles for the component type
   *
   * @private
   */
  static getStylesForThis() {
    const e = s.__themes || [], t = Object.getPrototypeOf(this.prototype), i = (t ? t.constructor.__themes : []) || [];
    this.__themes = [...e, ...i, ...Tu(this.is)];
    const r = this.__themes.flatMap((o) => o.styles);
    return r.filter((o, a) => a === r.lastIndexOf(o));
  }
};
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Eu = (s, ...n) => {
  const e = document.createElement("style");
  e.id = s, e.textContent = n.map((t) => t.toString()).join(`
`).replace(":host", "html"), document.head.insertAdjacentElement("afterbegin", e);
}, Hi = (s, ...n) => {
  Eu(`lumo-${s}`, n);
};
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Pu = ke`
  :host {
    /* Base (background) */
    --lumo-base-color: #fff;

    /* Tint */
    --lumo-tint-5pct: hsla(0, 0%, 100%, 0.3);
    --lumo-tint-10pct: hsla(0, 0%, 100%, 0.37);
    --lumo-tint-20pct: hsla(0, 0%, 100%, 0.44);
    --lumo-tint-30pct: hsla(0, 0%, 100%, 0.5);
    --lumo-tint-40pct: hsla(0, 0%, 100%, 0.57);
    --lumo-tint-50pct: hsla(0, 0%, 100%, 0.64);
    --lumo-tint-60pct: hsla(0, 0%, 100%, 0.7);
    --lumo-tint-70pct: hsla(0, 0%, 100%, 0.77);
    --lumo-tint-80pct: hsla(0, 0%, 100%, 0.84);
    --lumo-tint-90pct: hsla(0, 0%, 100%, 0.9);
    --lumo-tint: #fff;

    /* Shade */
    --lumo-shade-5pct: hsla(214, 61%, 25%, 0.05);
    --lumo-shade-10pct: hsla(214, 57%, 24%, 0.1);
    --lumo-shade-20pct: hsla(214, 53%, 23%, 0.16);
    --lumo-shade-30pct: hsla(214, 50%, 22%, 0.26);
    --lumo-shade-40pct: hsla(214, 47%, 21%, 0.38);
    --lumo-shade-50pct: hsla(214, 45%, 20%, 0.52);
    --lumo-shade-60pct: hsla(214, 43%, 19%, 0.6);
    --lumo-shade-70pct: hsla(214, 42%, 18%, 0.69);
    --lumo-shade-80pct: hsla(214, 41%, 17%, 0.83);
    --lumo-shade-90pct: hsla(214, 40%, 16%, 0.94);
    --lumo-shade: hsl(214, 35%, 15%);

    /* Contrast */
    --lumo-contrast-5pct: var(--lumo-shade-5pct);
    --lumo-contrast-10pct: var(--lumo-shade-10pct);
    --lumo-contrast-20pct: var(--lumo-shade-20pct);
    --lumo-contrast-30pct: var(--lumo-shade-30pct);
    --lumo-contrast-40pct: var(--lumo-shade-40pct);
    --lumo-contrast-50pct: var(--lumo-shade-50pct);
    --lumo-contrast-60pct: var(--lumo-shade-60pct);
    --lumo-contrast-70pct: var(--lumo-shade-70pct);
    --lumo-contrast-80pct: var(--lumo-shade-80pct);
    --lumo-contrast-90pct: var(--lumo-shade-90pct);
    --lumo-contrast: var(--lumo-shade);

    /* Text */
    --lumo-header-text-color: var(--lumo-contrast);
    --lumo-body-text-color: var(--lumo-contrast-90pct);
    --lumo-secondary-text-color: var(--lumo-contrast-70pct);
    --lumo-tertiary-text-color: var(--lumo-contrast-50pct);
    --lumo-disabled-text-color: var(--lumo-contrast-30pct);

    /* Primary */
    --lumo-primary-color: hsl(214, 100%, 48%);
    --lumo-primary-color-50pct: hsla(214, 100%, 49%, 0.76);
    --lumo-primary-color-10pct: hsla(214, 100%, 60%, 0.13);
    --lumo-primary-text-color: hsl(214, 100%, 43%);
    --lumo-primary-contrast-color: #fff;

    /* Error */
    --lumo-error-color: hsl(3, 85%, 48%);
    --lumo-error-color-50pct: hsla(3, 85%, 49%, 0.5);
    --lumo-error-color-10pct: hsla(3, 85%, 49%, 0.1);
    --lumo-error-text-color: hsl(3, 89%, 42%);
    --lumo-error-contrast-color: #fff;

    /* Success */
    --lumo-success-color: hsl(145, 72%, 30%);
    --lumo-success-color-50pct: hsla(145, 72%, 31%, 0.5);
    --lumo-success-color-10pct: hsla(145, 72%, 31%, 0.1);
    --lumo-success-text-color: hsl(145, 85%, 25%);
    --lumo-success-contrast-color: #fff;

    /* Warning */
    --lumo-warning-color: hsl(48, 100%, 50%);
    --lumo-warning-color-10pct: hsla(48, 100%, 50%, 0.25);
    --lumo-warning-text-color: hsl(32, 100%, 30%);
    --lumo-warning-contrast-color: var(--lumo-shade-90pct);
  }

  /* forced-colors mode adjustments */
  @media (forced-colors: active) {
    html {
      --lumo-disabled-text-color: GrayText;
    }
  }
`;
Hi("color-props", Pu);
const Su = ke`
  [theme~='dark'] {
    /* Base (background) */
    --lumo-base-color: hsl(214, 35%, 21%);

    /* Tint */
    --lumo-tint-5pct: hsla(214, 65%, 85%, 0.06);
    --lumo-tint-10pct: hsla(214, 60%, 80%, 0.14);
    --lumo-tint-20pct: hsla(214, 64%, 82%, 0.23);
    --lumo-tint-30pct: hsla(214, 69%, 84%, 0.32);
    --lumo-tint-40pct: hsla(214, 73%, 86%, 0.41);
    --lumo-tint-50pct: hsla(214, 78%, 88%, 0.5);
    --lumo-tint-60pct: hsla(214, 82%, 90%, 0.58);
    --lumo-tint-70pct: hsla(214, 87%, 92%, 0.69);
    --lumo-tint-80pct: hsla(214, 91%, 94%, 0.8);
    --lumo-tint-90pct: hsla(214, 96%, 96%, 0.9);
    --lumo-tint: hsl(214, 100%, 98%);

    /* Shade */
    --lumo-shade-5pct: hsla(214, 0%, 0%, 0.07);
    --lumo-shade-10pct: hsla(214, 4%, 2%, 0.15);
    --lumo-shade-20pct: hsla(214, 8%, 4%, 0.23);
    --lumo-shade-30pct: hsla(214, 12%, 6%, 0.32);
    --lumo-shade-40pct: hsla(214, 16%, 8%, 0.41);
    --lumo-shade-50pct: hsla(214, 20%, 10%, 0.5);
    --lumo-shade-60pct: hsla(214, 24%, 12%, 0.6);
    --lumo-shade-70pct: hsla(214, 28%, 13%, 0.7);
    --lumo-shade-80pct: hsla(214, 32%, 13%, 0.8);
    --lumo-shade-90pct: hsla(214, 33%, 13%, 0.9);
    --lumo-shade: hsl(214, 33%, 13%);

    /* Contrast */
    --lumo-contrast-5pct: var(--lumo-tint-5pct);
    --lumo-contrast-10pct: var(--lumo-tint-10pct);
    --lumo-contrast-20pct: var(--lumo-tint-20pct);
    --lumo-contrast-30pct: var(--lumo-tint-30pct);
    --lumo-contrast-40pct: var(--lumo-tint-40pct);
    --lumo-contrast-50pct: var(--lumo-tint-50pct);
    --lumo-contrast-60pct: var(--lumo-tint-60pct);
    --lumo-contrast-70pct: var(--lumo-tint-70pct);
    --lumo-contrast-80pct: var(--lumo-tint-80pct);
    --lumo-contrast-90pct: var(--lumo-tint-90pct);
    --lumo-contrast: var(--lumo-tint);

    /* Text */
    --lumo-header-text-color: var(--lumo-contrast);
    --lumo-body-text-color: var(--lumo-contrast-90pct);
    --lumo-secondary-text-color: var(--lumo-contrast-70pct);
    --lumo-tertiary-text-color: var(--lumo-contrast-50pct);
    --lumo-disabled-text-color: var(--lumo-contrast-30pct);

    /* Primary */
    --lumo-primary-color: hsl(214, 90%, 48%);
    --lumo-primary-color-50pct: hsla(214, 90%, 70%, 0.69);
    --lumo-primary-color-10pct: hsla(214, 90%, 55%, 0.13);
    --lumo-primary-text-color: hsl(214, 90%, 77%);
    --lumo-primary-contrast-color: #fff;

    /* Error */
    --lumo-error-color: hsl(3, 79%, 49%);
    --lumo-error-color-50pct: hsla(3, 75%, 62%, 0.5);
    --lumo-error-color-10pct: hsla(3, 75%, 62%, 0.14);
    --lumo-error-text-color: hsl(3, 100%, 80%);

    /* Success */
    --lumo-success-color: hsl(145, 72%, 30%);
    --lumo-success-color-50pct: hsla(145, 92%, 51%, 0.5);
    --lumo-success-color-10pct: hsla(145, 92%, 51%, 0.1);
    --lumo-success-text-color: hsl(145, 85%, 46%);

    /* Warning */
    --lumo-warning-color: hsl(43, 100%, 48%);
    --lumo-warning-color-10pct: hsla(40, 100%, 50%, 0.2);
    --lumo-warning-text-color: hsl(45, 100%, 60%);
    --lumo-warning-contrast-color: var(--lumo-shade-90pct);
  }

  html {
    color: var(--lumo-body-text-color);
    background-color: var(--lumo-base-color);
    color-scheme: light;
  }

  [theme~='dark'] {
    color: var(--lumo-body-text-color);
    background-color: var(--lumo-base-color);
    color-scheme: dark;
  }

  h1,
  h2,
  h3,
  h4,
  h5,
  h6 {
    color: var(--lumo-header-text-color);
  }

  a:where(:any-link) {
    color: var(--lumo-primary-text-color);
  }

  a:not(:any-link) {
    color: var(--lumo-disabled-text-color);
  }

  blockquote {
    color: var(--lumo-secondary-text-color);
  }

  code,
  pre {
    background-color: var(--lumo-contrast-10pct);
    border-radius: var(--lumo-border-radius-m);
  }
  pre code {
    background: transparent;
  }
`;
Qe("", Su, { moduleId: "lumo-color" });
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const ku = ke`
  @font-face {
    font-family: 'lumo-icons';
    src: url(data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAABEgAAsAAAAAIjQAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABCAAAADsAAABUIIslek9TLzIAAAFEAAAAQwAAAFZAIUuKY21hcAAAAYgAAAD4AAADrsCU8d5nbHlmAAACgAAAC2cAABeAWri7U2hlYWQAAA3oAAAAMAAAADZa/6SsaGhlYQAADhgAAAAdAAAAJAbpA35obXR4AAAOOAAAABAAAACspBAAAGxvY2EAAA5IAAAAWAAAAFh57oA4bWF4cAAADqAAAAAfAAAAIAFKAXBuYW1lAAAOwAAAATEAAAIuUUJZCHBvc3QAAA/0AAABKwAAAelm8SzVeJxjYGRgYOBiMGCwY2BycfMJYeDLSSzJY5BiYGGAAJA8MpsxJzM9kYEDxgPKsYBpDiBmg4gCACY7BUgAeJxjYGS+yDiBgZWBgamKaQ8DA0MPhGZ8wGDIyAQUZWBlZsAKAtJcUxgcXjG+0mIO+p/FEMUcxDANKMwIkgMABn8MLQB4nO3SWW6DMABF0UtwCEnIPM/zhLK8LqhfXRybSP14XUYtHV9hGYQwQBNIo3cUIPkhQeM7rib1ekqnXg981XuC1qvy84lzojleh3puxL0hPjGjRU473teloEefAUNGjJkwZcacBUtWrNmwZceeA0dOnLlw5cadB09elPGhGf+j0NTI/65KfXerT6JhqKnpRKtgOpuqaTrtKjPUlqHmhto21I7pL6i6hlqY3q7qGWrfUAeGOjTUkaGODXViqFNDnRnq3FAXhro01JWhrg11Y6hbQ90Z6t5QD4Z6NNSToZ4N9WKoV0O9GerdUB+G+jTUl6GWRvkL24BkEXictVh9bFvVFb/nxvbz+7Rf/N6zHcd2bCfP+Wic1Z9N0jpNHCD9SNqqoVBgbQoMjY+pjA4hNnWa2pV1rHSIif0DGkyT2k10Kmu1Cag6huj4ZpqYBHSqJsTEJgZCG3TaVBFv595nO3ZIv4RIrPPuvefe884599zzO/cRF8G/tgn6CFFImNgkR0ggX8wlspbhSSWSdrC5ozd30s2dw5afzvgtyz9/zG9t1hV4RtF1pXolowvtzc2z6L2aYUQM45jKH9WDTvd1LRDoDASYWhfTzTyvboXz6uZX4ARX5wrF39y+HM2+CJ8d0pkyqBIqoze3D12ez4DrFoYzxI8dWwMrDlZ2DMqQAR9AROsJU+2smlTPaTTco52BVxXa2a2+I8vvqd2dVHm1LoPeTn/AZPRYGthDYOeZjBjKoFsVGulR3lGU95SeCK44oHU7MhWUGUKZDT3oSUcG2GWuh+EDDfUYA/jhIhl0TOsJNYSEu7mQmi3UzfXwZKA4BsVsHLXQYGgJW95qEtpJ1VcW9HiTriZBlFEqxsDjA09yCNUoQxxwd7KWSTt2y3GTKifkqHRCoWZc3m11Wa/dKdFgXD4kSYfkeJBKd8KMz7J8dZn/cGRCcLGDnA2Ge3bKzcvlnTDNthFWLH7Xt80ua5FMjA4WKelWv5Xo16vHuYzpRbJhhdVlftuRK0VlR27D9lu5TF0DPBi60OrHNO0AfP/uRWvhn/U3LXICE+nh+3IHPUJ8JE6GyBjZQLbjGchlrSgYngF8zyrIF4NJD3atUcgWsWunGN/UHX5B5/yg7uF87Nqp4Gf52F3gH73DjEZNRoqCKAr9giQJp5rGJABpiVE2htNhW9R8nw0jqYjCYcY4LIjwYNScf4WN06IZnZCEqsI4cFaQbo4Z1TsZBx40YhXkHOecaYE5oY37IIQ+iJJ+UsDYSun5MuRSBRZRUUhlY2DqOGajOR6zrSU/5My6l2DnusH1GQgnw5BZP7iuYM/ahcfQ7Z8y51ddfutvuwNqWQ0cBYr8fj0U0vsHpwerVaB2sWhXT2NExi2r1KUE2tUuVMnkepVQrxTmpQrZTG4iu8he8iPyM3KcPE/+RP5KPoE2CEAKclCBzXATxkYOtUY/o961PWRqsj0chRrHFBbtrjP9/P0ven5pcbRdpL94vfsy33e5+izuwz3nFLFPVNayPZx/jdG1fOChflFRvYzsW6L18efgLrSWIgvcqnGJYi4skO4xREURjbDuxKke5v0T3Mrzkt2fi31uyZlLLrqIpEuXXsMlgw442Jb0GAxjS1DM20kBoCzHLXm/jEm0IltdcvU0fEW24jgiwwRjVd9u4NJHcIyoHJcwvyVqgqj5hqBJ1ZWSJryh9p56UWhX1XbhRbW2ZopuZWsQd5y8mEQ8M+C6xjRYxZbDKWf5AgY+Qq/l6wSPk16zDFjowYuu+wjx13mfkxbyDDxadYT/LijZyI0THB+6yfLaWsRcO82zo9mWTNtpO18qlorZoIVMwSN40tky5DOQ1MCIAe24mvlsuwIIxPb10+uXDQ4uWz/9m3rj+ql7p6bufZARuPVq5tXtsn6KwfP8Jy0TeWOyNhUJN6mhX5rkUTtUppQWEMNTqEdaCGKFYKJaQrCE4JtDLYOlNEKmO5kBTPGY2A0N2sY3+dVlo1N9ycBsIGtOjQ2p/tlZvzo0ur4v6cOh8NTospB7U/X40KahoU3bGIH97dnwmtHlYffVG3R1YOwKM2vNhrPhCT5zk64sG53oS4b31aYjqe/B7+kQiXBN+b6h21hNUPMq29B8CU4elINdygMPKF1B+WBTG7Z9ZshpN/xwEuuDQZR+nuoo4CDaAiiwXmLpmukMQyPf/JMclqgL1ixZQ/nnP2VbdUODFGt2fgBvL123rlLYu/6A9ckb7F3K0/CyBMEu6aQoPscroCcacVehvyQyCZAsizsWWBkoLC+WAiWnOksLKaeuQDzGuqSk42aiYTiJ4zf9afl17SrqaTO1f+XlZAfIuYcq7/IqYMaMrksOJ6vHkOCPDq943xcCnHqVD9pHFRpMqSPXrIua1WNs+tOz1U+ciTCDpPk+c4QYJIHnYhxP/kVPAq+ahFpVhPcHp8qyarhiF+HsBU9Hrl+UZa876fbKipL0KqB6OdUveErgtOI97fZ63ae9SvWU6k2w1JfwqnUbHsYcFCJFrC/W12zIMMirWYEHxMPs6LGYSdkSZ5TsNP9PCpwnWC3HKZ1lydNjWHC2Mn3l6vL0dHn1ldP3LTSrX+vKrBqv7KmMr8p0SR6P1NqF63or6XRlIyO90f7+kf7+myOhvt4tq7f09oUiTc2/dycGgqFQcCDRLYmi1NL7fk0CknVMxEg/cdfs/TnpJMNkgqwj17B8beVazSrVbU4lG67IZYOCnWrYy3yBR9cyWcChywos3LJBEdhhFoAdYjiw0rLGm0xU5OzoGm5/ZfmHjVZpNNg6SznzGKDdwv2cCtVn6Eaxo12cfxLprpVtTcZ6hVx6dow7Yq7e8LXO8PY9Jgjoze9yCtU5FNbegcKkQMdCbt9au/te4Ebe0jkc0ukUL32eYnTpNs20h0KpUOhZPYwVcfhZnfdqeCvDfXiuCbAoYWcXERPc/mDQD3/hdF+wK4i/xv3kYfprIpAuMkk2kW3kdtS0kBIKpZwp8KxmsCyfM1MFzAss9LBkDxRyThiaqTLwKYKJVTwmWTudMyz+yks09346MDh4m72yOxCKrt1XMlQ1qPVlTEVVQ1ofdK/sCWjtZu9qGwZ8YZ9PPWlo1IV3eW3+U0aXblP39zrt+JPf6UhEQ1rUjNBULN+utyuaDNW34kpAVuSOeMTyWbSNWnooFu+QFNWQ4d/Ox4IPWx41fP/fB/Rjeoz08ezPA9TysMtmnOXfGN7Ui3xIYLDALrlDLOP09qtJuY2OeL0+QZXdRnR1nxRVBF/SOyKKPpcrn9mWzH4rH9IidE+PTNU2182+hOgSItrE1slByS24vaLvJpxOqe4Pduf3HJkZ+jLqUz9rRzB7p8gKcgWZwV1L8JtUS5Z2JxZSOCuBoMTQihMzLbCPA0KqGMAljRQjONklW/wjnXKy8vxT/Elvm3/KiMUMOoV0/vnDYlhec0SMKtt3/kKMyOt33tj2bqxQLsTjSGLl+EAsNhCnTyRGktW55EgCn/A4PlnWn+Mg8bgZrWqHxTbPwMuyy1u5YeZF2SUM7JRhddwRgiRuxpmgJmxn9ZW7XpcF3ViX/ar6ptRpGJ0S9Adg4qhb9sI3vbL7qNJV/y4i07t5TZBiho1imFoMz3gED+CtjYUxvP4SOxov4bFoNPg5aR1e+G4UgDPoedJTpogyCJ7oYvRqoVS0MQAy+CoNEdTDUjok5ZHZL/WtjV7rFj3PKQE3iKp7ou+rIxN3b9LB1dGjeT4cvKo3FrnWpYpuaFd/h3dtV8UeKN1Y9hpR3dt4p0H/zKuPQq0kZQUIIpuDfoiETsnIk+gCWMJZUXHtE8V9LkUc2TE8vOMbO4ax/MACabzyaGXc7u3FBr11ThBdB8SIeMAlCntG2KThHSPsaj2Dc9KNyY2a0KZ7ODaTHoRiFkeYz+shZBpCS4X6471KKKnuHd84edfk5F37d1XO5bbkcltu2ZLNbvnPXiUVAnVvprJrP+NObryjxrllS65md6Tm6wzFHRR4dY3QUUjb7MgxaIixU8hspi98fl/Xc+IB4iU66eCVL9YfAfahiSUt4TONS8x0D8W7u8vd3fGWx6OXlM/U1IoU/s61PGhpyXRFa3eReq2qG56lvmYtXavCC1iN7lbiBpWxXHU+cSlztVLVz0tVN600fVsLxaVDknhYioeoXP3t4lqV1r79MAw0GCI1FTL1YIGzPL1MMlJ9ZsN9P7lvA2yr9ZFUzwzPrVgxN/x/SS+chwB4nGNgZGBgAOLPrYdY4vltvjJwM78AijDUqG5oRND/XzNPZboF5HIwMIFEAU/lC+J4nGNgZGBgDvqfBSRfMAAB81QGRgZUoA0AVvYDbwAAAHicY2BgYGB+MTQwAM8EJo8AAAAAAE4AmgDoAQoBLAFOAXABmgHEAe4CGgKcAugEmgS8BNYE8gUOBSoFegXQBf4GRAZmBrYHGAeQCBgIUghqCP4JRgm+CdoKBAo+CoQKugr0C1QLmgvAeJxjYGRgYNBmTGEQZQABJiDmAkIGhv9gPgMAGJQBvAB4nG2RPU7DMBiG3/QP0UoIBGJh8QILavozdmRo9w7d09RpUzlx5LgVvQMn4BAcgoEzcAgOwVvzSZVQbcnf48fvFysJgGt8IcJxROiG9TgauODuj5ukG+EW+UG4jR4ehTv0Q+EunjER7uEWmk+IWpc0d3gVbuAKb8JN+nfhFvlDuI17fAp36L+Fu1jgR7iHp+jF7Arbz1Nb1nO93pnEncSJFtrVuS3VKB6e5EyX2iVer9TyoOr9eux9pjJnCzW1pdfGWFU5u9WpjzfeV5PBIBMfp7aAwQ4FLPrIkbKWqDHn+67pDRK4s4lzbsEux5qHvcIIMb/nueSMyTKkE3jWFdNLHLjW2PPmMa1Hxn3GjGW/wjT0HtOG09JU4WxLk9LH2ISuiv9twJn9y8fh9uIXI+BknAAAAHicbY7ZboMwEEW5CVBCSLrv+76kfJRjTwHFsdGAG+Xvy5JUfehIHp0rnxmNN/D6ir3/a4YBhvARIMQOIowQY4wEE0yxiz3s4wCHOMIxTnCKM5zjApe4wjVucIs73OMBj3jCM17wije84wMzfHqJ0EVmUkmmJo77oOmrHvfIRZbXsTCZplTZldlgb3TYGVHProwFs11t1A57tcON2rErR3PBqcwF1/6ctI6k0GSU4JHMSS6WghdJQ99sTbfuN7QLJ9vQ37dNrgyktnIxlDYLJNuqitpRbYWKFNuyDT6pog6oOYKHtKakeakqKjHXpPwlGRcsC+OqxLIiJpXqoqqDMreG2l5bv9Ri3TRX+c23DZna9WFFgmXuO6Ps1Jm/w6ErW8N3FbHn/QC444j0AA==)
      format('woff');
    font-weight: normal;
    font-style: normal;
  }

  html {
    --lumo-icons-align-center: '\\ea01';
    --lumo-icons-align-left: '\\ea02';
    --lumo-icons-align-right: '\\ea03';
    --lumo-icons-angle-down: '\\ea04';
    --lumo-icons-angle-left: '\\ea05';
    --lumo-icons-angle-right: '\\ea06';
    --lumo-icons-angle-up: '\\ea07';
    --lumo-icons-arrow-down: '\\ea08';
    --lumo-icons-arrow-left: '\\ea09';
    --lumo-icons-arrow-right: '\\ea0a';
    --lumo-icons-arrow-up: '\\ea0b';
    --lumo-icons-bar-chart: '\\ea0c';
    --lumo-icons-bell: '\\ea0d';
    --lumo-icons-calendar: '\\ea0e';
    --lumo-icons-checkmark: '\\ea0f';
    --lumo-icons-chevron-down: '\\ea10';
    --lumo-icons-chevron-left: '\\ea11';
    --lumo-icons-chevron-right: '\\ea12';
    --lumo-icons-chevron-up: '\\ea13';
    --lumo-icons-clock: '\\ea14';
    --lumo-icons-cog: '\\ea15';
    --lumo-icons-cross: '\\ea16';
    --lumo-icons-download: '\\ea17';
    --lumo-icons-dropdown: '\\ea18';
    --lumo-icons-edit: '\\ea19';
    --lumo-icons-error: '\\ea1a';
    --lumo-icons-eye: '\\ea1b';
    --lumo-icons-eye-disabled: '\\ea1c';
    --lumo-icons-menu: '\\ea1d';
    --lumo-icons-minus: '\\ea1e';
    --lumo-icons-ordered-list: '\\ea1f';
    --lumo-icons-phone: '\\ea20';
    --lumo-icons-photo: '\\ea21';
    --lumo-icons-play: '\\ea22';
    --lumo-icons-plus: '\\ea23';
    --lumo-icons-redo: '\\ea24';
    --lumo-icons-reload: '\\ea25';
    --lumo-icons-search: '\\ea26';
    --lumo-icons-undo: '\\ea27';
    --lumo-icons-unordered-list: '\\ea28';
    --lumo-icons-upload: '\\ea29';
    --lumo-icons-user: '\\ea2a';
  }
`;
Hi("font-icons", ku);
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Ru = ke`
  :host {
    --lumo-size-xs: 1.625rem;
    --lumo-size-s: 1.875rem;
    --lumo-size-m: 2.25rem;
    --lumo-size-l: 2.75rem;
    --lumo-size-xl: 3.5rem;

    /* Icons */
    --lumo-icon-size-s: 1.25em;
    --lumo-icon-size-m: 1.5em;
    --lumo-icon-size-l: 2.25em;
    /* For backwards compatibility */
    --lumo-icon-size: var(--lumo-icon-size-m);
  }
`;
Hi("sizing-props", Ru);
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Au = ke`
  :host {
    /* Square */
    --lumo-space-xs: 0.25rem;
    --lumo-space-s: 0.5rem;
    --lumo-space-m: 1rem;
    --lumo-space-l: 1.5rem;
    --lumo-space-xl: 2.5rem;

    /* Wide */
    --lumo-space-wide-xs: calc(var(--lumo-space-xs) / 2) var(--lumo-space-xs);
    --lumo-space-wide-s: calc(var(--lumo-space-s) / 2) var(--lumo-space-s);
    --lumo-space-wide-m: calc(var(--lumo-space-m) / 2) var(--lumo-space-m);
    --lumo-space-wide-l: calc(var(--lumo-space-l) / 2) var(--lumo-space-l);
    --lumo-space-wide-xl: calc(var(--lumo-space-xl) / 2) var(--lumo-space-xl);

    /* Tall */
    --lumo-space-tall-xs: var(--lumo-space-xs) calc(var(--lumo-space-xs) / 2);
    --lumo-space-tall-s: var(--lumo-space-s) calc(var(--lumo-space-s) / 2);
    --lumo-space-tall-m: var(--lumo-space-m) calc(var(--lumo-space-m) / 2);
    --lumo-space-tall-l: var(--lumo-space-l) calc(var(--lumo-space-l) / 2);
    --lumo-space-tall-xl: var(--lumo-space-xl) calc(var(--lumo-space-xl) / 2);
  }
`;
Hi("spacing-props", Au);
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Iu = ke`
  :host {
    /* Border radius */
    --lumo-border-radius-s: 0.25em; /* Checkbox, badge, date-picker year indicator, etc */
    --lumo-border-radius-m: var(--lumo-border-radius, 0.25em); /* Button, text field, menu overlay, etc */
    --lumo-border-radius-l: 0.5em; /* Dialog, notification, etc */

    /* Shadow */
    --lumo-box-shadow-xs: 0 1px 4px -1px var(--lumo-shade-50pct);
    --lumo-box-shadow-s: 0 2px 4px -1px var(--lumo-shade-20pct), 0 3px 12px -1px var(--lumo-shade-30pct);
    --lumo-box-shadow-m: 0 2px 6px -1px var(--lumo-shade-20pct), 0 8px 24px -4px var(--lumo-shade-40pct);
    --lumo-box-shadow-l: 0 3px 18px -2px var(--lumo-shade-20pct), 0 12px 48px -6px var(--lumo-shade-40pct);
    --lumo-box-shadow-xl: 0 4px 24px -3px var(--lumo-shade-20pct), 0 18px 64px -8px var(--lumo-shade-40pct);

    /* Clickable element cursor */
    --lumo-clickable-cursor: default;
  }
`;
ke`
  html {
    /* Button */
    --vaadin-button-background: var(--lumo-contrast-5pct);
    --vaadin-button-border: none;
    --vaadin-button-border-radius: var(--lumo-border-radius-m);
    --vaadin-button-font-size: var(--lumo-font-size-m);
    --vaadin-button-font-weight: 500;
    --vaadin-button-height: var(--lumo-size-m);
    --vaadin-button-margin: var(--lumo-space-xs) 0;
    --vaadin-button-min-width: calc(var(--vaadin-button-height) * 2);
    --vaadin-button-padding: 0 calc(var(--vaadin-button-height) / 3 + var(--lumo-border-radius-m) / 2);
    --vaadin-button-text-color: var(--lumo-primary-text-color);
    --vaadin-button-primary-background: var(--lumo-primary-color);
    --vaadin-button-primary-border: none;
    --vaadin-button-primary-font-weight: 600;
    --vaadin-button-primary-text-color: var(--lumo-primary-contrast-color);
    --vaadin-button-tertiary-background: transparent !important;
    --vaadin-button-tertiary-text-color: var(--lumo-primary-text-color);
    --vaadin-button-tertiary-font-weight: 500;
    --vaadin-button-tertiary-padding: 0 calc(var(--vaadin-button-height) / 6);
    /* Checkbox */
    --vaadin-checkbox-background: var(--lumo-contrast-20pct);
    --vaadin-checkbox-background-hover: var(--lumo-contrast-30pct);
    --vaadin-checkbox-border-radius: var(--lumo-border-radius-s);
    --vaadin-checkbox-checkmark-char: var(--lumo-icons-checkmark);
    --vaadin-checkbox-checkmark-char-indeterminate: '';
    --vaadin-checkbox-checkmark-color: var(--lumo-primary-contrast-color);
    --vaadin-checkbox-checkmark-size: calc(var(--vaadin-checkbox-size) + 2px);
    --vaadin-checkbox-label-color: var(--lumo-body-text-color);
    --vaadin-checkbox-label-font-size: var(--lumo-font-size-m);
    --vaadin-checkbox-label-padding: var(--lumo-space-xs) var(--lumo-space-s) var(--lumo-space-xs) var(--lumo-space-xs);
    --vaadin-checkbox-size: calc(var(--lumo-size-m) / 2);
    --vaadin-checkbox-disabled-checkmark-color: var(--lumo-contrast-30pct);
    --vaadin-checkbox-disabled-background: var(--lumo-contrast-10pct);
    /* Radio button */
    --vaadin-radio-button-background: var(--lumo-contrast-20pct);
    --vaadin-radio-button-background-hover: var(--lumo-contrast-30pct);
    --vaadin-radio-button-dot-color: var(--lumo-primary-contrast-color);
    --vaadin-radio-button-dot-size: 3px;
    --vaadin-radio-button-label-color: var(--lumo-body-text-color);
    --vaadin-radio-button-label-font-size: var(--lumo-font-size-m);
    --vaadin-radio-button-label-padding: var(--lumo-space-xs) var(--lumo-space-s) var(--lumo-space-xs)
      var(--lumo-space-xs);
    --vaadin-radio-button-size: calc(var(--lumo-size-m) / 2);
    --vaadin-radio-button-disabled-background: var(--lumo-contrast-10pct);
    --vaadin-radio-button-disabled-dot-color: var(--lumo-contrast-30pct);
    --vaadin-selection-color: var(--lumo-primary-color);
    --vaadin-selection-color-text: var(--lumo-primary-text-color);
    --vaadin-input-field-border-radius: var(--lumo-border-radius-m);
    --vaadin-focus-ring-color: var(--lumo-primary-color-50pct);
    --vaadin-focus-ring-width: 2px;
    /* Label */
    --vaadin-input-field-label-color: var(--lumo-secondary-text-color);
    --vaadin-input-field-focused-label-color: var(--lumo-primary-text-color);
    --vaadin-input-field-hovered-label-color: var(--lumo-body-text-color);
    --vaadin-input-field-label-font-size: var(--lumo-font-size-s);
    --vaadin-input-field-label-font-weight: 500;
    /* Helper */
    --vaadin-input-field-helper-color: var(--lumo-secondary-text-color);
    --vaadin-input-field-helper-font-size: var(--lumo-font-size-xs);
    --vaadin-input-field-helper-font-weight: 400;
    --vaadin-input-field-helper-spacing: 0.4em;
    /* Error message */
    --vaadin-input-field-error-color: var(--lumo-error-text-color);
    --vaadin-input-field-error-font-size: var(--lumo-font-size-xs);
    --vaadin-input-field-error-font-weight: 400;
    /* Input field */
    --vaadin-input-field-background: var(--lumo-contrast-10pct);
    --vaadin-input-field-icon-color: var(--lumo-contrast-60pct);
    --vaadin-input-field-icon-size: var(--lumo-icon-size-m);
    --vaadin-input-field-invalid-background: var(--lumo-error-color-10pct);
    --vaadin-input-field-invalid-hover-highlight: var(--lumo-error-color-50pct);
    --vaadin-input-field-disabled-background: var(--lumo-contrast-5pct);
    --vaadin-input-field-disabled-value-color: var(--lumo-disabled-text-color);
    --vaadin-input-field-height: var(--lumo-size-m);
    --vaadin-input-field-hover-highlight: var(--lumo-contrast-50pct);
    --vaadin-input-field-placeholder-color: var(--lumo-secondary-text-color);
    --vaadin-input-field-readonly-border: 1px dashed var(--lumo-contrast-30pct);
    --vaadin-input-field-value-color: var(--lumo-body-text-color);
    --vaadin-input-field-value-font-size: var(--lumo-font-size-m);
    --vaadin-input-field-value-font-weight: 500;
  }
`;
Hi("style-props", Iu);
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Du = ke`
  :host {
    /* prettier-ignore */
    --lumo-font-family: -apple-system, BlinkMacSystemFont, 'Roboto', 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';

    /* Font sizes */
    --lumo-font-size-xxs: 0.75rem;
    --lumo-font-size-xs: 0.8125rem;
    --lumo-font-size-s: 0.875rem;
    --lumo-font-size-m: 1rem;
    --lumo-font-size-l: 1.125rem;
    --lumo-font-size-xl: 1.375rem;
    --lumo-font-size-xxl: 1.75rem;
    --lumo-font-size-xxxl: 2.5rem;

    /* Line heights */
    --lumo-line-height-xs: 1.25;
    --lumo-line-height-s: 1.375;
    --lumo-line-height-m: 1.625;
  }
`, Ou = ke`
  body,
  :host {
    font-family: var(--lumo-font-family);
    font-size: var(--lumo-font-size-m);
    line-height: var(--lumo-line-height-m);
    -webkit-text-size-adjust: 100%;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }

  small,
  [theme~='font-size-s'] {
    font-size: var(--lumo-font-size-s);
    line-height: var(--lumo-line-height-s);
  }

  [theme~='font-size-xs'] {
    font-size: var(--lumo-font-size-xs);
    line-height: var(--lumo-line-height-xs);
  }

  :where(h1, h2, h3, h4, h5, h6) {
    font-weight: 600;
    line-height: var(--lumo-line-height-xs);
    margin-block: 0;
  }

  :where(h1) {
    font-size: var(--lumo-font-size-xxxl);
  }

  :where(h2) {
    font-size: var(--lumo-font-size-xxl);
  }

  :where(h3) {
    font-size: var(--lumo-font-size-xl);
  }

  :where(h4) {
    font-size: var(--lumo-font-size-l);
  }

  :where(h5) {
    font-size: var(--lumo-font-size-m);
  }

  :where(h6) {
    font-size: var(--lumo-font-size-xs);
    text-transform: uppercase;
    letter-spacing: 0.03em;
  }

  p,
  blockquote {
    margin-top: 0.5em;
    margin-bottom: 0.75em;
  }

  a {
    text-decoration: none;
  }

  a:where(:any-link):hover {
    text-decoration: underline;
  }

  hr {
    display: block;
    align-self: stretch;
    height: 1px;
    border: 0;
    padding: 0;
    margin: var(--lumo-space-s) calc(var(--lumo-border-radius-m) / 2);
    background-color: var(--lumo-contrast-10pct);
  }

  blockquote {
    border-left: 2px solid var(--lumo-contrast-30pct);
  }

  b,
  strong {
    font-weight: 600;
  }

  /* RTL specific styles */
  blockquote[dir='rtl'] {
    border-left: none;
    border-right: 2px solid var(--lumo-contrast-30pct);
  }
`;
Qe("", Ou, { moduleId: "lumo-typography" });
Hi("typography-props", Du);
Qe(
  "vaadin-grid",
  ke`
    :host {
      font-family: var(--lumo-font-family);
      font-size: var(--lumo-font-size-m);
      line-height: var(--lumo-line-height-s);
      color: var(--lumo-body-text-color);
      background-color: var(--lumo-base-color);
      box-sizing: border-box;
      -webkit-text-size-adjust: 100%;
      -webkit-tap-highlight-color: transparent;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      --_focus-ring-color: var(--vaadin-focus-ring-color, var(--lumo-primary-color-50pct));
      --_focus-ring-width: var(--vaadin-focus-ring-width, 2px);
      /* For internal use only */
      --_lumo-grid-border-color: var(--lumo-contrast-20pct);
      --_lumo-grid-secondary-border-color: var(--lumo-contrast-10pct);
      --_lumo-grid-border-width: 1px;
      --_lumo-grid-selected-row-color: var(--lumo-primary-color-10pct);
    }

    /* No (outer) border */

    :host(:not([theme~='no-border'])) {
      border: var(--_lumo-grid-border-width) solid var(--_lumo-grid-border-color);
    }

    :host([disabled]) {
      opacity: 0.7;
    }

    /* Cell styles */

    [part~='cell'] {
      min-height: var(--lumo-size-m);
      background-color: var(--vaadin-grid-cell-background, var(--lumo-base-color));
      cursor: default;
      --_cell-padding: var(--vaadin-grid-cell-padding, var(--_cell-default-padding));
      --_cell-default-padding: var(--lumo-space-xs) var(--lumo-space-m);
    }

    [part~='cell'] ::slotted(vaadin-grid-cell-content) {
      cursor: inherit;
      padding: var(--_cell-padding);
    }

    /* Apply row borders by default and introduce the "no-row-borders" variant */
    :host(:not([theme~='no-row-borders'])) [part~='cell']:not([part~='details-cell']) {
      border-top: var(--_lumo-grid-border-width) solid var(--_lumo-grid-secondary-border-color);
    }

    /* Hide first body row top border */
    :host(:not([theme~='no-row-borders'])) [part~='first-row'] [part~='cell']:not([part~='details-cell']) {
      border-top: 0;
      min-height: calc(var(--lumo-size-m) - var(--_lumo-grid-border-width));
    }

    /* Focus-ring */

    [part~='row'] {
      position: relative;
    }

    [part~='row']:focus,
    [part~='focused-cell']:focus {
      outline: none;
    }

    :host([navigating]) [part~='row']:focus::before,
    :host([navigating]) [part~='focused-cell']:focus::before {
      content: '';
      position: absolute;
      inset: 0;
      pointer-events: none;
      box-shadow: inset 0 0 0 var(--_focus-ring-width) var(--_focus-ring-color);
    }

    :host([navigating]) [part~='row']:focus::before {
      transform: translateX(calc(-1 * var(--_grid-horizontal-scroll-position)));
      z-index: 3;
    }

    /* Empty state */
    [part~='empty-state'] {
      padding: var(--lumo-space-m);
      color: var(--lumo-secondary-text-color);
    }

    /* Drag and Drop styles */
    :host([dragover])::after {
      content: '';
      position: absolute;
      z-index: 100;
      inset: 0;
      pointer-events: none;
      box-shadow: inset 0 0 0 var(--_focus-ring-width) var(--_focus-ring-color);
    }

    [part~='row'][dragover] {
      z-index: 100 !important;
    }

    [part~='row'][dragover] [part~='cell'] {
      overflow: visible;
    }

    [part~='row'][dragover] [part~='cell']::after {
      content: '';
      position: absolute;
      inset: 0;
      height: calc(var(--_lumo-grid-border-width) + 2px);
      pointer-events: none;
      background: var(--lumo-primary-color-50pct);
    }

    [part~='row'][dragover] [part~='cell'][last-frozen]::after {
      right: -1px;
    }

    :host([theme~='no-row-borders']) [dragover] [part~='cell']::after {
      height: 2px;
    }

    [part~='row'][dragover='below'] [part~='cell']::after {
      top: 100%;
      bottom: auto;
      margin-top: -1px;
    }

    :host([all-rows-visible]) [part~='last-row'][dragover='below'] [part~='cell']::after {
      height: 1px;
    }

    [part~='row'][dragover='above'] [part~='cell']::after {
      top: auto;
      bottom: 100%;
      margin-bottom: -1px;
    }

    [part~='row'][details-opened][dragover='below'] [part~='cell']:not([part~='details-cell'])::after,
    [part~='row'][details-opened][dragover='above'] [part~='details-cell']::after {
      display: none;
    }

    [part~='row'][dragover][dragover='on-top'] [part~='cell']::after {
      height: 100%;
      opacity: 0.5;
    }

    [part~='row'][dragstart] [part~='cell'] {
      border: none !important;
      box-shadow: none !important;
    }

    [part~='row'][dragstart] [part~='cell'][last-column] {
      border-radius: 0 var(--lumo-border-radius-s) var(--lumo-border-radius-s) 0;
    }

    [part~='row'][dragstart] [part~='cell'][first-column] {
      border-radius: var(--lumo-border-radius-s) 0 0 var(--lumo-border-radius-s);
    }

    #scroller [part~='row'][dragstart]:not([dragstart=''])::after {
      display: block;
      position: absolute;
      left: var(--_grid-drag-start-x);
      top: var(--_grid-drag-start-y);
      z-index: 100;
      content: attr(dragstart);
      align-items: center;
      justify-content: center;
      box-sizing: border-box;
      padding: calc(var(--lumo-space-xs) * 0.8);
      color: var(--lumo-error-contrast-color);
      background-color: var(--lumo-error-color);
      border-radius: var(--lumo-border-radius-m);
      font-family: var(--lumo-font-family);
      font-size: var(--lumo-font-size-xxs);
      line-height: 1;
      font-weight: 500;
      text-transform: initial;
      letter-spacing: initial;
      min-width: calc(var(--lumo-size-s) * 0.7);
      text-align: center;
    }

    /* Headers and footers */

    [part~='header-cell'],
    [part~='footer-cell'],
    [part~='reorder-ghost'] {
      font-size: var(--lumo-font-size-s);
      font-weight: 500;
    }

    [part~='footer-cell'] {
      font-weight: 400;
    }

    [part~='row']:only-child [part~='header-cell'] {
      min-height: var(--lumo-size-xl);
    }

    /* Header borders */

    /* Hide first header row top border */
    :host(:not([theme~='no-row-borders'])) [part~='row']:first-child [part~='header-cell'] {
      border-top: 0;
    }

    /* Hide header row top border if previous row is hidden */
    [part~='row'][hidden] + [part~='row'] [part~='header-cell'] {
      border-top: 0;
    }

    [part~='row']:last-child [part~='header-cell'] {
      border-bottom: var(--_lumo-grid-border-width) solid transparent;
    }

    :host(:not([theme~='no-row-borders'])) [part~='row']:last-child [part~='header-cell'] {
      border-bottom-color: var(--_lumo-grid-secondary-border-color);
    }

    /* Overflow uses a stronger border color */
    :host([overflow~='top']) [part~='row']:last-child [part~='header-cell'] {
      border-bottom-color: var(--_lumo-grid-border-color);
    }

    /* Footer borders */

    [part~='row']:first-child [part~='footer-cell'] {
      border-top: var(--_lumo-grid-border-width) solid transparent;
    }

    :host(:not([theme~='no-row-borders'])) [part~='row']:first-child [part~='footer-cell'] {
      border-top-color: var(--_lumo-grid-secondary-border-color);
    }

    /* Overflow uses a stronger border color */
    :host([overflow~='bottom']) [part~='row']:first-child [part~='footer-cell'] {
      border-top-color: var(--_lumo-grid-border-color);
    }

    /* Column reordering */

    :host([reordering]) [part~='cell'] {
      background: linear-gradient(var(--lumo-shade-20pct), var(--lumo-shade-20pct)) var(--lumo-base-color);
    }

    :host([reordering]) [part~='cell'][reorder-status='allowed'] {
      background: var(--lumo-base-color);
    }

    :host([reordering]) [part~='cell'][reorder-status='dragging'] {
      background: linear-gradient(var(--lumo-contrast-5pct), var(--lumo-contrast-5pct)) var(--lumo-base-color);
    }

    [part~='reorder-ghost'] {
      opacity: 0.85;
      box-shadow: var(--lumo-box-shadow-s);
      /* TODO Use the same styles as for the cell element (reorder-ghost copies styles from the cell element) */
      padding: var(--lumo-space-s) var(--lumo-space-m) !important;
    }

    /* Column resizing */

    [part='resize-handle'] {
      --_resize-handle-width: 3px;
      width: var(--_resize-handle-width);
      background-color: var(--lumo-primary-color-50pct);
      opacity: 0;
      transition: opacity 0.2s;
    }

    [part='resize-handle']::before {
      transform: translateX(calc(-50% + var(--_resize-handle-width) / 2));
      width: var(--lumo-size-s);
    }

    :host(:not([reordering])) *:not([column-resizing]) [part~='cell']:hover [part='resize-handle'],
    [part='resize-handle']:active {
      opacity: 1;
      transition-delay: 0.15s;
    }

    /* Column borders */

    :host([theme~='column-borders']) [part~='cell']:not([last-column]):not([part~='details-cell']) {
      border-right: var(--_lumo-grid-border-width) solid var(--_lumo-grid-secondary-border-color);
    }

    /* Frozen columns */

    [last-frozen] {
      border-right: var(--_lumo-grid-border-width) solid transparent;
      overflow: hidden;
    }

    :host([overflow~='start']) [part~='cell'][last-frozen]:not([part~='details-cell']) {
      border-right-color: var(--_lumo-grid-border-color);
    }

    [first-frozen-to-end] {
      border-left: var(--_lumo-grid-border-width) solid transparent;
    }

    :host([overflow~='end']) [part~='cell'][first-frozen-to-end]:not([part~='details-cell']) {
      border-left-color: var(--_lumo-grid-border-color);
    }

    /* Row stripes */

    :host([theme~='row-stripes']) [part~='even-row'] [part~='body-cell'],
    :host([theme~='row-stripes']) [part~='even-row'] [part~='details-cell'] {
      background-image: linear-gradient(var(--lumo-contrast-5pct), var(--lumo-contrast-5pct));
      background-repeat: repeat-x;
    }

    /* Selected row */

    /* Raise the selected rows above unselected rows (so that box-shadow can cover unselected rows) */
    :host(:not([reordering])) [part~='row'][selected] {
      z-index: 1;
    }

    :host(:not([reordering])) [part~='row'][selected] [part~='body-cell']:not([part~='details-cell']) {
      background-image: linear-gradient(var(--_lumo-grid-selected-row-color), var(--_lumo-grid-selected-row-color));
      background-repeat: repeat;
    }

    /* Cover the border of an unselected row */
    :host(:not([theme~='no-row-borders'])) [part~='row'][selected] [part~='cell']:not([part~='details-cell']) {
      box-shadow: 0 var(--_lumo-grid-border-width) 0 0 var(--_lumo-grid-selected-row-color);
    }

    /* Compact */

    :host([theme~='compact']) [part~='row']:only-child [part~='header-cell'] {
      min-height: var(--lumo-size-m);
    }

    :host([theme~='compact']) [part~='cell'] {
      min-height: var(--lumo-size-s);
      --_cell-default-padding: var(--lumo-space-xs) var(--lumo-space-s);
    }

    :host([theme~='compact']) [part~='first-row'] [part~='cell']:not([part~='details-cell']) {
      min-height: calc(var(--lumo-size-s) - var(--_lumo-grid-border-width));
    }

    :host([theme~='compact']) [part~='empty-state'] {
      padding: var(--lumo-space-s);
    }

    /* Wrap cell contents */

    :host([theme~='wrap-cell-content']) [part~='cell'] ::slotted(vaadin-grid-cell-content) {
      white-space: normal;
    }

    /* RTL specific styles */

    :host([dir='rtl']) [part~='row'][dragstart] [part~='cell'][last-column] {
      border-radius: var(--lumo-border-radius-s) 0 0 var(--lumo-border-radius-s);
    }

    :host([dir='rtl']) [part~='row'][dragstart] [part~='cell'][first-column] {
      border-radius: 0 var(--lumo-border-radius-s) var(--lumo-border-radius-s) 0;
    }

    :host([dir='rtl'][theme~='column-borders']) [part~='cell']:not([last-column]):not([part~='details-cell']) {
      border-right: none;
      border-left: var(--_lumo-grid-border-width) solid var(--_lumo-grid-secondary-border-color);
    }

    :host([dir='rtl']) [last-frozen] {
      border-right: none;
      border-left: var(--_lumo-grid-border-width) solid transparent;
    }

    :host([dir='rtl']) [first-frozen-to-end] {
      border-left: none;
      border-right: var(--_lumo-grid-border-width) solid transparent;
    }

    :host([dir='rtl'][overflow~='start']) [part~='cell'][last-frozen]:not([part~='details-cell']) {
      border-left-color: var(--_lumo-grid-border-color);
    }

    :host([dir='rtl'][overflow~='end']) [part~='cell'][first-frozen-to-end]:not([part~='details-cell']) {
      border-right-color: var(--_lumo-grid-border-color);
    }
  `,
  { moduleId: "lumo-grid" }
);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
window.JSCompiler_renameProperty = function(s, n) {
  return s;
};
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
let zu = /(url\()([^)]*)(\))/g, Fu = /(^\/[^\/])|(^#)|(^[\w-\d]*:)/, Zr, gt;
function ur(s, n) {
  if (s && Fu.test(s) || s === "//")
    return s;
  if (Zr === void 0) {
    Zr = !1;
    try {
      const e = new URL("b", "http://a");
      e.pathname = "c%20d", Zr = e.href === "http://a/c%20d";
    } catch {
    }
  }
  if (n || (n = document.baseURI || window.location.href), Zr)
    try {
      return new URL(s, n).href;
    } catch {
      return s;
    }
  return gt || (gt = document.implementation.createHTMLDocument("temp"), gt.base = gt.createElement("base"), gt.head.appendChild(gt.base), gt.anchor = gt.createElement("a"), gt.body.appendChild(gt.anchor)), gt.base.href = n, gt.anchor.href = s, gt.anchor.href || s;
}
function os(s, n) {
  return s.replace(zu, function(e, t, i, r) {
    return t + "'" + ur(i.replace(/["']/g, ""), n) + "'" + r;
  });
}
function ss(s) {
  return s.substring(0, s.lastIndexOf("/") + 1);
}
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const Mu = !window.ShadyDOM || !window.ShadyDOM.inUse;
!window.ShadyCSS || window.ShadyCSS.nativeCss;
const Lu = Mu && "adoptedStyleSheets" in Document.prototype && "replaceSync" in CSSStyleSheet.prototype && // Since spec may change, feature detect exact API we need
(() => {
  try {
    const s = new CSSStyleSheet();
    s.replaceSync("");
    const n = document.createElement("div");
    return n.attachShadow({ mode: "open" }), n.shadowRoot.adoptedStyleSheets = [s], n.shadowRoot.adoptedStyleSheets[0] === s;
  } catch {
    return !1;
  }
})();
let Bu = window.Polymer && window.Polymer.rootPath || ss(document.baseURI || window.location.href), vn = window.Polymer && window.Polymer.sanitizeDOMValue || void 0;
window.Polymer && window.Polymer.setPassiveTouchGestures;
let zo = window.Polymer && window.Polymer.strictTemplatePolicy || !1, Nu = window.Polymer && window.Polymer.allowTemplateFromDomModule || !1, Hu = window.Polymer && window.Polymer.legacyOptimizations || !1, Vu = window.Polymer && window.Polymer.legacyWarnings || !1, Uu = window.Polymer && window.Polymer.syncInitialRender || !1, Fo = window.Polymer && window.Polymer.legacyUndefined || !1, Wu = window.Polymer && window.Polymer.orderedComputed || !1, ga = window.Polymer && window.Polymer.removeNestedTemplates || !1, ju = window.Polymer && window.Polymer.fastDomIf || !1;
window.Polymer && window.Polymer.suppressTemplateNotifications;
window.Polymer && window.Polymer.legacyNoObservedAttributes;
let Gu = window.Polymer && window.Polymer.useAdoptedStyleSheetsWithBuiltCSS || !1;
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
let qu = 0;
const rt = function(s) {
  let n = (
    /** @type {!MixinFunction} */
    s.__mixinApplications
  );
  n || (n = /* @__PURE__ */ new WeakMap(), s.__mixinApplications = n);
  let e = qu++;
  function t(i) {
    let r = (
      /** @type {!MixinFunction} */
      i.__mixinSet
    );
    if (r && r[e])
      return i;
    let o = n, a = o.get(i);
    if (!a) {
      a = /** @type {!Function} */
      s(i), o.set(i, a);
      let c = Object.create(
        /** @type {!MixinFunction} */
        a.__mixinSet || r || null
      );
      c[e] = !0, a.__mixinSet = c;
    }
    return a;
  }
  return t;
};
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
let as = {}, gl = {};
function ma(s, n) {
  as[s] = gl[s.toLowerCase()] = n;
}
function va(s) {
  return as[s] || gl[s.toLowerCase()];
}
function Ku(s) {
  s.querySelector("style") && console.warn("dom-module %s has style outside template", s.id);
}
class gr extends HTMLElement {
  /** @override */
  static get observedAttributes() {
    return ["id"];
  }
  /**
   * Retrieves the element specified by the css `selector` in the module
   * registered by `id`. For example, this.import('foo', 'img');
   * @param {string} id The id of the dom-module in which to search.
   * @param {string=} selector The css selector by which to find the element.
   * @return {Element} Returns the element which matches `selector` in the
   * module registered at the specified `id`.
   *
   * @export
   * @nocollapse Referred to indirectly in style-gather.js
   */
  static import(n, e) {
    if (n) {
      let t = va(n);
      return t && e ? t.querySelector(e) : t;
    }
    return null;
  }
  /* eslint-disable no-unused-vars */
  /**
   * @param {string} name Name of attribute.
   * @param {?string} old Old value of attribute.
   * @param {?string} value Current value of attribute.
   * @param {?string} namespace Attribute namespace.
   * @return {void}
   * @override
   */
  attributeChangedCallback(n, e, t, i) {
    e !== t && this.register();
  }
  /* eslint-enable no-unused-args */
  /**
   * The absolute URL of the original location of this `dom-module`.
   *
   * This value will differ from this element's `ownerDocument` in the
   * following ways:
   * - Takes into account any `assetpath` attribute added during bundling
   *   to indicate the original location relative to the bundled location
   * - Uses the HTMLImports polyfill's `importForElement` API to ensure
   *   the path is relative to the import document's location since
   *   `ownerDocument` is not currently polyfilled
   */
  get assetpath() {
    if (!this.__assetpath) {
      const n = window.HTMLImports && HTMLImports.importForElement ? HTMLImports.importForElement(this) || document : this.ownerDocument, e = ur(
        this.getAttribute("assetpath") || "",
        n.baseURI
      );
      this.__assetpath = ss(e);
    }
    return this.__assetpath;
  }
  /**
   * Registers the dom-module at a given id. This method should only be called
   * when a dom-module is imperatively created. For
   * example, `document.createElement('dom-module').register('foo')`.
   * @param {string=} id The id at which to register the dom-module.
   * @return {void}
   */
  register(n) {
    if (n = n || this.id, n) {
      if (zo && va(n) !== void 0)
        throw ma(n, null), new Error(`strictTemplatePolicy: dom-module ${n} re-registered`);
      this.id = n, ma(n, this), Ku(this);
    }
  }
}
gr.prototype.modules = as;
customElements.define("dom-module", gr);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const Zu = "link[rel=import][type~=css]", Yu = "include", _a = "shady-unscoped";
function ml(s) {
  return (
    /** @type {?DomModule} */
    gr.import(s)
  );
}
function ba(s) {
  let n = s.body ? s.body : s;
  const e = os(
    n.textContent,
    s.baseURI
  ), t = document.createElement("style");
  return t.textContent = e, t;
}
function Xu(s) {
  const n = s.trim().split(/\s+/), e = [];
  for (let t = 0; t < n.length; t++)
    e.push(...Qu(n[t]));
  return e;
}
function Qu(s) {
  const n = ml(s);
  if (!n)
    return console.warn("Could not find style data in module named", s), [];
  if (n._styles === void 0) {
    const e = [];
    e.push(..._l(n));
    const t = (
      /** @type {?HTMLTemplateElement} */
      n.querySelector("template")
    );
    t && e.push(...vl(
      t,
      /** @type {templateWithAssetPath} */
      n.assetpath
    )), n._styles = e;
  }
  return n._styles;
}
function vl(s, n) {
  if (!s._styles) {
    const e = [], t = s.content.querySelectorAll("style");
    for (let i = 0; i < t.length; i++) {
      let r = t[i], o = r.getAttribute(Yu);
      o && e.push(...Xu(o).filter(function(a, c, u) {
        return u.indexOf(a) === c;
      })), n && (r.textContent = os(
        r.textContent,
        /** @type {string} */
        n
      )), e.push(r);
    }
    s._styles = e;
  }
  return s._styles;
}
function Ju(s) {
  let n = ml(s);
  return n ? _l(n) : [];
}
function _l(s) {
  const n = [], e = s.querySelectorAll(Zu);
  for (let t = 0; t < e.length; t++) {
    let i = e[t];
    if (i.import) {
      const r = i.import, o = i.hasAttribute(_a);
      if (o && !r._unscopedStyle) {
        const a = ba(r);
        a.setAttribute(_a, ""), r._unscopedStyle = a;
      } else r._style || (r._style = ba(r));
      n.push(o ? r._unscopedStyle : r._style);
    }
  }
  return n;
}
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const ci = window.ShadyDOM && window.ShadyDOM.noPatch && window.ShadyDOM.wrap ? window.ShadyDOM.wrap : window.ShadyDOM ? (s) => ShadyDOM.patch(s) : (s) => s;
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
function Mo(s) {
  return s.indexOf(".") >= 0;
}
function gi(s) {
  let n = s.indexOf(".");
  return n === -1 ? s : s.slice(0, n);
}
function $u(s, n) {
  return s.indexOf(n + ".") === 0;
}
function _n(s, n) {
  return n.indexOf(s + ".") === 0;
}
function bn(s, n, e) {
  return n + e.slice(s.length);
}
function sr(s) {
  if (Array.isArray(s)) {
    let n = [];
    for (let e = 0; e < s.length; e++) {
      let t = s[e].toString().split(".");
      for (let i = 0; i < t.length; i++)
        n.push(t[i]);
    }
    return n.join(".");
  } else
    return s;
}
function bl(s) {
  return Array.isArray(s) ? sr(s).split(".") : s.toString().split(".");
}
function dt(s, n, e) {
  let t = s, i = bl(n);
  for (let r = 0; r < i.length; r++) {
    if (!t)
      return;
    let o = i[r];
    t = t[o];
  }
  return e && (e.path = i.join(".")), t;
}
function ya(s, n, e) {
  let t = s, i = bl(n), r = i[i.length - 1];
  if (i.length > 1) {
    for (let o = 0; o < i.length - 1; o++) {
      let a = i[o];
      if (t = t[a], !t)
        return;
    }
    t[r] = e;
  } else
    t[n] = e;
  return i.join(".");
}
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const yn = {}, ed = /-[a-z]/g, td = /([A-Z])/g;
function yl(s) {
  return yn[s] || (yn[s] = s.indexOf("-") < 0 ? s : s.replace(
    ed,
    (n) => n[1].toUpperCase()
  ));
}
function Rn(s) {
  return yn[s] || (yn[s] = s.replace(td, "-$1").toLowerCase());
}
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
let id = 0, wl = 0, Di = [], rd = 0, Lo = !1, xl = document.createTextNode("");
new window.MutationObserver(nd).observe(xl, { characterData: !0 });
function nd() {
  Lo = !1;
  const s = Di.length;
  for (let n = 0; n < s; n++) {
    let e = Di[n];
    if (e)
      try {
        e();
      } catch (t) {
        setTimeout(() => {
          throw t;
        });
      }
  }
  Di.splice(0, s), wl += s;
}
const od = {
  /**
   * Enqueues a function called at microtask timing.
   *
   * @memberof microTask
   * @param {!Function=} callback Callback to run
   * @return {number} Handle used for canceling task
   */
  run(s) {
    return Lo || (Lo = !0, xl.textContent = rd++), Di.push(s), id++;
  },
  /**
   * Cancels a previously enqueued `microTask` callback.
   *
   * @memberof microTask
   * @param {number} handle Handle returned from `run` of callback to cancel
   * @return {void}
   */
  cancel(s) {
    const n = s - wl;
    if (n >= 0) {
      if (!Di[n])
        throw new Error("invalid async handle: " + s);
      Di[n] = null;
    }
  }
};
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const sd = od, Cl = rt(
  /**
   * @template T
   * @param {function(new:T)} superClass Class to apply mixin to.
   * @return {function(new:T)} superClass with mixin applied.
   */
  (s) => {
    class n extends s {
      /**
       * Creates property accessors for the given property names.
       * @param {!Object} props Object whose keys are names of accessors.
       * @return {void}
       * @protected
       * @nocollapse
       */
      static createProperties(t) {
        const i = this.prototype;
        for (let r in t)
          r in i || i._createPropertyAccessor(r);
      }
      /**
       * Returns an attribute name that corresponds to the given property.
       * The attribute name is the lowercased property name. Override to
       * customize this mapping.
       * @param {string} property Property to convert
       * @return {string} Attribute name corresponding to the given property.
       *
       * @protected
       * @nocollapse
       */
      static attributeNameForProperty(t) {
        return t.toLowerCase();
      }
      /**
       * Override point to provide a type to which to deserialize a value to
       * a given property.
       * @param {string} name Name of property
       *
       * @protected
       * @nocollapse
       */
      static typeForProperty(t) {
      }
      //eslint-disable-line no-unused-vars
      /**
       * Creates a setter/getter pair for the named property with its own
       * local storage.  The getter returns the value in the local storage,
       * and the setter calls `_setProperty`, which updates the local storage
       * for the property and enqueues a `_propertiesChanged` callback.
       *
       * This method may be called on a prototype or an instance.  Calling
       * this method may overwrite a property value that already exists on
       * the prototype/instance by creating the accessor.
       *
       * @param {string} property Name of the property
       * @param {boolean=} readOnly When true, no setter is created; the
       *   protected `_setProperty` function must be used to set the property
       * @return {void}
       * @protected
       * @override
       */
      _createPropertyAccessor(t, i) {
        this._addPropertyToAttributeMap(t), this.hasOwnProperty(JSCompiler_renameProperty("__dataHasAccessor", this)) || (this.__dataHasAccessor = Object.assign({}, this.__dataHasAccessor)), this.__dataHasAccessor[t] || (this.__dataHasAccessor[t] = !0, this._definePropertyAccessor(t, i));
      }
      /**
       * Adds the given `property` to a map matching attribute names
       * to property names, using `attributeNameForProperty`. This map is
       * used when deserializing attribute values to properties.
       *
       * @param {string} property Name of the property
       * @override
       */
      _addPropertyToAttributeMap(t) {
        this.hasOwnProperty(JSCompiler_renameProperty("__dataAttributes", this)) || (this.__dataAttributes = Object.assign({}, this.__dataAttributes));
        let i = this.__dataAttributes[t];
        return i || (i = this.constructor.attributeNameForProperty(t), this.__dataAttributes[i] = t), i;
      }
      /**
       * Defines a property accessor for the given property.
       * @param {string} property Name of the property
       * @param {boolean=} readOnly When true, no setter is created
       * @return {void}
       * @override
       */
      _definePropertyAccessor(t, i) {
        Object.defineProperty(this, t, {
          /* eslint-disable valid-jsdoc */
          /** @this {PropertiesChanged} */
          get() {
            return this.__data[t];
          },
          /** @this {PropertiesChanged} */
          set: i ? function() {
          } : function(r) {
            this._setPendingProperty(t, r, !0) && this._invalidateProperties();
          }
          /* eslint-enable */
        });
      }
      constructor() {
        super(), this.__dataEnabled = !1, this.__dataReady = !1, this.__dataInvalid = !1, this.__data = {}, this.__dataPending = null, this.__dataOld = null, this.__dataInstanceProps = null, this.__dataCounter = 0, this.__serializing = !1, this._initializeProperties();
      }
      /**
       * Lifecycle callback called when properties are enabled via
       * `_enableProperties`.
       *
       * Users may override this function to implement behavior that is
       * dependent on the element having its property data initialized, e.g.
       * from defaults (initialized from `constructor`, `_initializeProperties`),
       * `attributeChangedCallback`, or values propagated from host e.g. via
       * bindings.  `super.ready()` must be called to ensure the data system
       * becomes enabled.
       *
       * @return {void}
       * @public
       * @override
       */
      ready() {
        this.__dataReady = !0, this._flushProperties();
      }
      /**
       * Initializes the local storage for property accessors.
       *
       * Provided as an override point for performing any setup work prior
       * to initializing the property accessor system.
       *
       * @return {void}
       * @protected
       * @override
       */
      _initializeProperties() {
        for (let t in this.__dataHasAccessor)
          this.hasOwnProperty(t) && (this.__dataInstanceProps = this.__dataInstanceProps || {}, this.__dataInstanceProps[t] = this[t], delete this[t]);
      }
      /**
       * Called at ready time with bag of instance properties that overwrote
       * accessors when the element upgraded.
       *
       * The default implementation sets these properties back into the
       * setter at ready time.  This method is provided as an override
       * point for customizing or providing more efficient initialization.
       *
       * @param {Object} props Bag of property values that were overwritten
       *   when creating property accessors.
       * @return {void}
       * @protected
       * @override
       */
      _initializeInstanceProperties(t) {
        Object.assign(this, t);
      }
      /**
       * Updates the local storage for a property (via `_setPendingProperty`)
       * and enqueues a `_proeprtiesChanged` callback.
       *
       * @param {string} property Name of the property
       * @param {*} value Value to set
       * @return {void}
       * @protected
       * @override
       */
      _setProperty(t, i) {
        this._setPendingProperty(t, i) && this._invalidateProperties();
      }
      /**
       * Returns the value for the given property.
       * @param {string} property Name of property
       * @return {*} Value for the given property
       * @protected
       * @override
       */
      _getProperty(t) {
        return this.__data[t];
      }
      /* eslint-disable no-unused-vars */
      /**
       * Updates the local storage for a property, records the previous value,
       * and adds it to the set of "pending changes" that will be passed to the
       * `_propertiesChanged` callback.  This method does not enqueue the
       * `_propertiesChanged` callback.
       *
       * @param {string} property Name of the property
       * @param {*} value Value to set
       * @param {boolean=} ext Not used here; affordance for closure
       * @return {boolean} Returns true if the property changed
       * @protected
       * @override
       */
      _setPendingProperty(t, i, r) {
        let o = this.__data[t], a = this._shouldPropertyChange(t, i, o);
        return a && (this.__dataPending || (this.__dataPending = {}, this.__dataOld = {}), this.__dataOld && !(t in this.__dataOld) && (this.__dataOld[t] = o), this.__data[t] = i, this.__dataPending[t] = i), a;
      }
      /* eslint-enable */
      /**
       * @param {string} property Name of the property
       * @return {boolean} Returns true if the property is pending.
       */
      _isPropertyPending(t) {
        return !!(this.__dataPending && this.__dataPending.hasOwnProperty(t));
      }
      /**
       * Marks the properties as invalid, and enqueues an async
       * `_propertiesChanged` callback.
       *
       * @return {void}
       * @protected
       * @override
       */
      _invalidateProperties() {
        !this.__dataInvalid && this.__dataReady && (this.__dataInvalid = !0, sd.run(() => {
          this.__dataInvalid && (this.__dataInvalid = !1, this._flushProperties());
        }));
      }
      /**
       * Call to enable property accessor processing. Before this method is
       * called accessor values will be set but side effects are
       * queued. When called, any pending side effects occur immediately.
       * For elements, generally `connectedCallback` is a normal spot to do so.
       * It is safe to call this method multiple times as it only turns on
       * property accessors once.
       *
       * @return {void}
       * @protected
       * @override
       */
      _enableProperties() {
        this.__dataEnabled || (this.__dataEnabled = !0, this.__dataInstanceProps && (this._initializeInstanceProperties(this.__dataInstanceProps), this.__dataInstanceProps = null), this.ready());
      }
      /**
       * Calls the `_propertiesChanged` callback with the current set of
       * pending changes (and old values recorded when pending changes were
       * set), and resets the pending set of changes. Generally, this method
       * should not be called in user code.
       *
       * @return {void}
       * @protected
       * @override
       */
      _flushProperties() {
        this.__dataCounter++;
        const t = this.__data, i = this.__dataPending, r = this.__dataOld;
        this._shouldPropertiesChange(t, i, r) && (this.__dataPending = null, this.__dataOld = null, this._propertiesChanged(t, i, r)), this.__dataCounter--;
      }
      /**
       * Called in `_flushProperties` to determine if `_propertiesChanged`
       * should be called. The default implementation returns true if
       * properties are pending. Override to customize when
       * `_propertiesChanged` is called.
       * @param {!Object} currentProps Bag of all current accessor values
       * @param {?Object} changedProps Bag of properties changed since the last
       *   call to `_propertiesChanged`
       * @param {?Object} oldProps Bag of previous values for each property
       *   in `changedProps`
       * @return {boolean} true if changedProps is truthy
       * @override
       */
      _shouldPropertiesChange(t, i, r) {
        return !!i;
      }
      /**
       * Callback called when any properties with accessors created via
       * `_createPropertyAccessor` have been set.
       *
       * @param {!Object} currentProps Bag of all current accessor values
       * @param {?Object} changedProps Bag of properties changed since the last
       *   call to `_propertiesChanged`
       * @param {?Object} oldProps Bag of previous values for each property
       *   in `changedProps`
       * @return {void}
       * @protected
       * @override
       */
      _propertiesChanged(t, i, r) {
      }
      /**
       * Method called to determine whether a property value should be
       * considered as a change and cause the `_propertiesChanged` callback
       * to be enqueued.
       *
       * The default implementation returns `true` if a strict equality
       * check fails. The method always returns false for `NaN`.
       *
       * Override this method to e.g. provide stricter checking for
       * Objects/Arrays when using immutable patterns.
       *
       * @param {string} property Property name
       * @param {*} value New property value
       * @param {*} old Previous property value
       * @return {boolean} Whether the property should be considered a change
       *   and enqueue a `_proeprtiesChanged` callback
       * @protected
       * @override
       */
      _shouldPropertyChange(t, i, r) {
        return (
          // Strict equality check
          r !== i && // This ensures (old==NaN, value==NaN) always returns false
          (r === r || i === i)
        );
      }
      /**
       * Implements native Custom Elements `attributeChangedCallback` to
       * set an attribute value to a property via `_attributeToProperty`.
       *
       * @param {string} name Name of attribute that changed
       * @param {?string} old Old attribute value
       * @param {?string} value New attribute value
       * @param {?string} namespace Attribute namespace.
       * @return {void}
       * @suppress {missingProperties} Super may or may not implement the callback
       * @override
       */
      attributeChangedCallback(t, i, r, o) {
        i !== r && this._attributeToProperty(t, r), super.attributeChangedCallback && super.attributeChangedCallback(t, i, r, o);
      }
      /**
       * Deserializes an attribute to its associated property.
       *
       * This method calls the `_deserializeValue` method to convert the string to
       * a typed value.
       *
       * @param {string} attribute Name of attribute to deserialize.
       * @param {?string} value of the attribute.
       * @param {*=} type type to deserialize to, defaults to the value
       * returned from `typeForProperty`
       * @return {void}
       * @override
       */
      _attributeToProperty(t, i, r) {
        if (!this.__serializing) {
          const o = this.__dataAttributes, a = o && o[t] || t;
          this[a] = this._deserializeValue(i, r || this.constructor.typeForProperty(a));
        }
      }
      /**
       * Serializes a property to its associated attribute.
       *
       * @suppress {invalidCasts} Closure can't figure out `this` is an element.
       *
       * @param {string} property Property name to reflect.
       * @param {string=} attribute Attribute name to reflect to.
       * @param {*=} value Property value to refect.
       * @return {void}
       * @override
       */
      _propertyToAttribute(t, i, r) {
        this.__serializing = !0, r = arguments.length < 3 ? this[t] : r, this._valueToNodeAttribute(
          /** @type {!HTMLElement} */
          this,
          r,
          i || this.constructor.attributeNameForProperty(t)
        ), this.__serializing = !1;
      }
      /**
       * Sets a typed value to an HTML attribute on a node.
       *
       * This method calls the `_serializeValue` method to convert the typed
       * value to a string.  If the `_serializeValue` method returns `undefined`,
       * the attribute will be removed (this is the default for boolean
       * type `false`).
       *
       * @param {Element} node Element to set attribute to.
       * @param {*} value Value to serialize.
       * @param {string} attribute Attribute name to serialize to.
       * @return {void}
       * @override
       */
      _valueToNodeAttribute(t, i, r) {
        const o = this._serializeValue(i);
        (r === "class" || r === "name" || r === "slot") && (t = /** @type {?Element} */
        ci(t)), o === void 0 ? t.removeAttribute(r) : t.setAttribute(
          r,
          // Closure's type for `setAttribute`'s second parameter incorrectly
          // excludes `TrustedScript`.
          o === "" && window.trustedTypes ? (
            /** @type {?} */
            window.trustedTypes.emptyScript
          ) : o
        );
      }
      /**
       * Converts a typed JavaScript value to a string.
       *
       * This method is called when setting JS property values to
       * HTML attributes.  Users may override this method to provide
       * serialization for custom types.
       *
       * @param {*} value Property value to serialize.
       * @return {string | undefined} String serialized from the provided
       * property  value.
       * @override
       */
      _serializeValue(t) {
        switch (typeof t) {
          case "boolean":
            return t ? "" : void 0;
          default:
            return t?.toString();
        }
      }
      /**
       * Converts a string to a typed JavaScript value.
       *
       * This method is called when reading HTML attribute values to
       * JS properties.  Users may override this method to provide
       * deserialization for custom `type`s. Types for `Boolean`, `String`,
       * and `Number` convert attributes to the expected types.
       *
       * @param {?string} value Value to deserialize.
       * @param {*=} type Type to deserialize the string to.
       * @return {*} Typed value deserialized from the provided string.
       * @override
       */
      _deserializeValue(t, i) {
        switch (i) {
          case Boolean:
            return t !== null;
          case Number:
            return Number(t);
          default:
            return t;
        }
      }
    }
    return n;
  }
);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const Tl = {};
let Yr = HTMLElement.prototype;
for (; Yr; ) {
  let s = Object.getOwnPropertyNames(Yr);
  for (let n = 0; n < s.length; n++)
    Tl[s[n]] = !0;
  Yr = Object.getPrototypeOf(Yr);
}
const ad = window.trustedTypes ? (s) => trustedTypes.isHTML(s) || trustedTypes.isScript(s) || trustedTypes.isScriptURL(s) : () => !1;
function ld(s, n) {
  if (!Tl[n]) {
    let e = s[n];
    e !== void 0 && (s.__data ? s._setPendingProperty(n, e) : (s.__dataProto ? s.hasOwnProperty(JSCompiler_renameProperty("__dataProto", s)) || (s.__dataProto = Object.create(s.__dataProto)) : s.__dataProto = {}, s.__dataProto[n] = e));
  }
}
const cd = rt((s) => {
  const n = Cl(s);
  class e extends n {
    /**
     * Generates property accessors for all attributes in the standard
     * static `observedAttributes` array.
     *
     * Attribute names are mapped to property names using the `dash-case` to
     * `camelCase` convention
     *
     * @return {void}
     * @nocollapse
     */
    static createPropertiesForAttributes() {
      let i = (
        /** @type {?} */
        this.observedAttributes
      );
      for (let r = 0; r < i.length; r++)
        this.prototype._createPropertyAccessor(yl(i[r]));
    }
    /**
     * Returns an attribute name that corresponds to the given property.
     * By default, converts camel to dash case, e.g. `fooBar` to `foo-bar`.
     * @param {string} property Property to convert
     * @return {string} Attribute name corresponding to the given property.
     *
     * @protected
     * @nocollapse
     */
    static attributeNameForProperty(i) {
      return Rn(i);
    }
    /**
     * Overrides PropertiesChanged implementation to initialize values for
     * accessors created for values that already existed on the element
     * prototype.
     *
     * @return {void}
     * @protected
     * @override
     */
    _initializeProperties() {
      this.__dataProto && (this._initializeProtoProperties(this.__dataProto), this.__dataProto = null), super._initializeProperties();
    }
    /**
     * Called at instance time with bag of properties that were overwritten
     * by accessors on the prototype when accessors were created.
     *
     * The default implementation sets these properties back into the
     * setter at instance time.  This method is provided as an override
     * point for customizing or providing more efficient initialization.
     *
     * @param {Object} props Bag of property values that were overwritten
     *   when creating property accessors.
     * @return {void}
     * @protected
     * @override
     */
    _initializeProtoProperties(i) {
      for (let r in i)
        this._setProperty(r, i[r]);
    }
    /**
     * Ensures the element has the given attribute. If it does not,
     * assigns the given value to the attribute.
     *
     * @suppress {invalidCasts} Closure can't figure out `this` is infact an
     *     element
     *
     * @param {string} attribute Name of attribute to ensure is set.
     * @param {string} value of the attribute.
     * @return {void}
     * @override
     */
    _ensureAttribute(i, r) {
      const o = (
        /** @type {!HTMLElement} */
        this
      );
      o.hasAttribute(i) || this._valueToNodeAttribute(o, r, i);
    }
    /**
     * Overrides PropertiesChanged implemention to serialize objects as JSON.
     *
     * @param {*} value Property value to serialize.
     * @return {string | undefined} String serialized from the provided property
     *     value.
     * @override
     */
    _serializeValue(i) {
      switch (typeof i) {
        case "object":
          if (i instanceof Date)
            return i.toString();
          if (i) {
            if (ad(i))
              return (
                /** @type {?} */
                i
              );
            try {
              return JSON.stringify(i);
            } catch {
              return "";
            }
          }
        default:
          return super._serializeValue(i);
      }
    }
    /**
     * Converts a string to a typed JavaScript value.
     *
     * This method is called by Polymer when reading HTML attribute values to
     * JS properties.  Users may override this method on Polymer element
     * prototypes to provide deserialization for custom `type`s.  Note,
     * the `type` argument is the value of the `type` field provided in the
     * `properties` configuration object for a given property, and is
     * by convention the constructor for the type to deserialize.
     *
     *
     * @param {?string} value Attribute value to deserialize.
     * @param {*=} type Type to deserialize the string to.
     * @return {*} Typed value deserialized from the provided string.
     * @override
     */
    _deserializeValue(i, r) {
      let o;
      switch (r) {
        case Object:
          try {
            o = JSON.parse(
              /** @type {string} */
              i
            );
          } catch {
            o = i;
          }
          break;
        case Array:
          try {
            o = JSON.parse(
              /** @type {string} */
              i
            );
          } catch {
            o = null, console.warn(`Polymer::Attributes: couldn't decode Array as JSON: ${i}`);
          }
          break;
        case Date:
          o = isNaN(i) ? String(i) : Number(i), o = new Date(o);
          break;
        default:
          o = super._deserializeValue(i, r);
          break;
      }
      return o;
    }
    /* eslint-enable no-fallthrough */
    /**
     * Overrides PropertiesChanged implementation to save existing prototype
     * property value so that it can be reset.
     * @param {string} property Name of the property
     * @param {boolean=} readOnly When true, no setter is created
     *
     * When calling on a prototype, any overwritten values are saved in
     * `__dataProto`, and it is up to the subclasser to decide how/when
     * to set those properties back into the accessor.  When calling on an
     * instance, the overwritten value is set via `_setPendingProperty`,
     * and the user should call `_invalidateProperties` or `_flushProperties`
     * for the values to take effect.
     * @protected
     * @return {void}
     * @override
     */
    _definePropertyAccessor(i, r) {
      ld(this, i), super._definePropertyAccessor(i, r);
    }
    /**
     * Returns true if this library created an accessor for the given property.
     *
     * @param {string} property Property name
     * @return {boolean} True if an accessor was created
     * @override
     */
    _hasAccessor(i) {
      return this.__dataHasAccessor && this.__dataHasAccessor[i];
    }
    /**
     * Returns true if the specified property has a pending change.
     *
     * @param {string} prop Property name
     * @return {boolean} True if property has a pending change
     * @protected
     * @override
     */
    _isPropertyPending(i) {
      return !!(this.__dataPending && i in this.__dataPending);
    }
  }
  return e;
});
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const ud = {
  "dom-if": !0,
  "dom-repeat": !0
};
let wa = !1, xa = !1;
function dd() {
  if (!wa) {
    wa = !0;
    const s = document.createElement("textarea");
    s.placeholder = "a", xa = s.placeholder === s.textContent;
  }
  return xa;
}
function hd(s) {
  dd() && s.localName === "textarea" && s.placeholder && s.placeholder === s.textContent && (s.textContent = null);
}
const fd = (() => {
  const s = window.trustedTypes && window.trustedTypes.createPolicy(
    "polymer-template-event-attribute-policy",
    {
      createScript: (n) => n
    }
  );
  return (n, e, t) => {
    const i = e.getAttribute(t);
    if (s && t.startsWith("on-")) {
      n.setAttribute(
        t,
        s.createScript(i, t)
      );
      return;
    }
    n.setAttribute(t, i);
  };
})();
function pd(s) {
  let n = s.getAttribute("is");
  if (n && ud[n]) {
    let e = s;
    for (e.removeAttribute("is"), s = e.ownerDocument.createElement(n), e.parentNode.replaceChild(s, e), s.appendChild(e); e.attributes.length; ) {
      const { name: t } = e.attributes[0];
      fd(s, e, t), e.removeAttribute(t);
    }
  }
  return s;
}
function El(s, n) {
  let e = n.parentInfo && El(s, n.parentInfo);
  if (e) {
    for (let t = e.firstChild, i = 0; t; t = t.nextSibling)
      if (n.parentIndex === i++)
        return t;
  } else
    return s;
}
function gd(s, n, e, t) {
  t.id && (n[t.id] = e);
}
function md(s, n, e) {
  if (e.events && e.events.length)
    for (let t = 0, i = e.events, r; t < i.length && (r = i[t]); t++)
      s._addMethodEventListenerToNode(n, r.name, r.value, s);
}
function vd(s, n, e, t) {
  e.templateInfo && (n._templateInfo = e.templateInfo, n._parentTemplateInfo = t);
}
function _d(s, n, e) {
  return s = s._methodHost || s, function(i) {
    s[e] ? s[e](i, i.detail) : console.warn("listener method `" + e + "` not defined");
  };
}
const bd = rt(
  /**
   * @template T
   * @param {function(new:T)} superClass Class to apply mixin to.
   * @return {function(new:T)} superClass with mixin applied.
   */
  (s) => {
    class n extends s {
      /**
       * Scans a template to produce template metadata.
       *
       * Template-specific metadata are stored in the object returned, and node-
       * specific metadata are stored in objects in its flattened `nodeInfoList`
       * array.  Only nodes in the template that were parsed as nodes of
       * interest contain an object in `nodeInfoList`.  Each `nodeInfo` object
       * contains an `index` (`childNodes` index in parent) and optionally
       * `parent`, which points to node info of its parent (including its index).
       *
       * The template metadata object returned from this method has the following
       * structure (many fields optional):
       *
       * ```js
       *   {
       *     // Flattened list of node metadata (for nodes that generated metadata)
       *     nodeInfoList: [
       *       {
       *         // `id` attribute for any nodes with id's for generating `$` map
       *         id: {string},
       *         // `on-event="handler"` metadata
       *         events: [
       *           {
       *             name: {string},   // event name
       *             value: {string},  // handler method name
       *           }, ...
       *         ],
       *         // Notes when the template contained a `<slot>` for shady DOM
       *         // optimization purposes
       *         hasInsertionPoint: {boolean},
       *         // For nested `<template>`` nodes, nested template metadata
       *         templateInfo: {object}, // nested template metadata
       *         // Metadata to allow efficient retrieval of instanced node
       *         // corresponding to this metadata
       *         parentInfo: {number},   // reference to parent nodeInfo>
       *         parentIndex: {number},  // index in parent's `childNodes` collection
       *         infoIndex: {number},    // index of this `nodeInfo` in `templateInfo.nodeInfoList`
       *       },
       *       ...
       *     ],
       *     // When true, the template had the `strip-whitespace` attribute
       *     // or was nested in a template with that setting
       *     stripWhitespace: {boolean},
       *     // For nested templates, nested template content is moved into
       *     // a document fragment stored here; this is an optimization to
       *     // avoid the cost of nested template cloning
       *     content: {DocumentFragment}
       *   }
       * ```
       *
       * This method kicks off a recursive treewalk as follows:
       *
       * ```
       *    _parseTemplate <---------------------+
       *      _parseTemplateContent              |
       *        _parseTemplateNode  <------------|--+
       *          _parseTemplateNestedTemplate --+  |
       *          _parseTemplateChildNodes ---------+
       *          _parseTemplateNodeAttributes
       *            _parseTemplateNodeAttribute
       *
       * ```
       *
       * These methods may be overridden to add custom metadata about templates
       * to either `templateInfo` or `nodeInfo`.
       *
       * Note that this method may be destructive to the template, in that
       * e.g. event annotations may be removed after being noted in the
       * template metadata.
       *
       * @param {!HTMLTemplateElement} template Template to parse
       * @param {TemplateInfo=} outerTemplateInfo Template metadata from the outer
       *   template, for parsing nested templates
       * @return {!TemplateInfo} Parsed template metadata
       * @nocollapse
       */
      static _parseTemplate(t, i) {
        if (!t._templateInfo) {
          let r = t._templateInfo = {};
          r.nodeInfoList = [], r.nestedTemplate = !!i, r.stripWhiteSpace = i && i.stripWhiteSpace || t.hasAttribute && t.hasAttribute("strip-whitespace"), this._parseTemplateContent(
            t,
            r,
            /** @type {?} */
            { parent: null }
          );
        }
        return t._templateInfo;
      }
      /**
       * See docs for _parseTemplateNode.
       *
       * @param {!HTMLTemplateElement} template .
       * @param {!TemplateInfo} templateInfo .
       * @param {!NodeInfo} nodeInfo .
       * @return {boolean} .
       * @nocollapse
       */
      static _parseTemplateContent(t, i, r) {
        return this._parseTemplateNode(t.content, i, r);
      }
      /**
       * Parses template node and adds template and node metadata based on
       * the current node, and its `childNodes` and `attributes`.
       *
       * This method may be overridden to add custom node or template specific
       * metadata based on this node.
       *
       * @param {Node} node Node to parse
       * @param {!TemplateInfo} templateInfo Template metadata for current template
       * @param {!NodeInfo} nodeInfo Node metadata for current template.
       * @return {boolean} `true` if the visited node added node-specific
       *   metadata to `nodeInfo`
       * @nocollapse
       */
      static _parseTemplateNode(t, i, r) {
        let o = !1, a = (
          /** @type {!HTMLTemplateElement} */
          t
        );
        return a.localName == "template" && !a.hasAttribute("preserve-content") ? o = this._parseTemplateNestedTemplate(a, i, r) || o : a.localName === "slot" && (i.hasInsertionPoint = !0), hd(a), a.firstChild && this._parseTemplateChildNodes(a, i, r), a.hasAttributes && a.hasAttributes() && (o = this._parseTemplateNodeAttributes(a, i, r) || o), o || r.noted;
      }
      /**
       * Parses template child nodes for the given root node.
       *
       * This method also wraps whitelisted legacy template extensions
       * (`is="dom-if"` and `is="dom-repeat"`) with their equivalent element
       * wrappers, collapses text nodes, and strips whitespace from the template
       * if the `templateInfo.stripWhitespace` setting was provided.
       *
       * @param {Node} root Root node whose `childNodes` will be parsed
       * @param {!TemplateInfo} templateInfo Template metadata for current template
       * @param {!NodeInfo} nodeInfo Node metadata for current template.
       * @return {void}
       */
      static _parseTemplateChildNodes(t, i, r) {
        if (!(t.localName === "script" || t.localName === "style"))
          for (let o = t.firstChild, a = 0, c; o; o = c) {
            if (o.localName == "template" && (o = pd(o)), c = o.nextSibling, o.nodeType === Node.TEXT_NODE) {
              let h = c;
              for (; h && h.nodeType === Node.TEXT_NODE; )
                o.textContent += h.textContent, c = h.nextSibling, t.removeChild(h), h = c;
              if (i.stripWhiteSpace && !o.textContent.trim()) {
                t.removeChild(o);
                continue;
              }
            }
            let u = (
              /** @type {!NodeInfo} */
              { parentIndex: a, parentInfo: r }
            );
            this._parseTemplateNode(o, i, u) && (u.infoIndex = i.nodeInfoList.push(u) - 1), o.parentNode && a++;
          }
      }
      /**
       * Parses template content for the given nested `<template>`.
       *
       * Nested template info is stored as `templateInfo` in the current node's
       * `nodeInfo`. `template.content` is removed and stored in `templateInfo`.
       * It will then be the responsibility of the host to set it back to the
       * template and for users stamping nested templates to use the
       * `_contentForTemplate` method to retrieve the content for this template
       * (an optimization to avoid the cost of cloning nested template content).
       *
       * @param {HTMLTemplateElement} node Node to parse (a <template>)
       * @param {TemplateInfo} outerTemplateInfo Template metadata for current template
       *   that includes the template `node`
       * @param {!NodeInfo} nodeInfo Node metadata for current template.
       * @return {boolean} `true` if the visited node added node-specific
       *   metadata to `nodeInfo`
       * @nocollapse
       */
      static _parseTemplateNestedTemplate(t, i, r) {
        let o = (
          /** @type {!HTMLTemplateElement} */
          t
        ), a = this._parseTemplate(o, i);
        return (a.content = o.content.ownerDocument.createDocumentFragment()).appendChild(o.content), r.templateInfo = a, !0;
      }
      /**
       * Parses template node attributes and adds node metadata to `nodeInfo`
       * for nodes of interest.
       *
       * @param {Element} node Node to parse
       * @param {!TemplateInfo} templateInfo Template metadata for current
       *     template
       * @param {!NodeInfo} nodeInfo Node metadata for current template.
       * @return {boolean} `true` if the visited node added node-specific
       *   metadata to `nodeInfo`
       * @nocollapse
       */
      static _parseTemplateNodeAttributes(t, i, r) {
        let o = !1, a = Array.from(t.attributes);
        for (let c = a.length - 1, u; u = a[c]; c--)
          o = this._parseTemplateNodeAttribute(t, i, r, u.name, u.value) || o;
        return o;
      }
      /**
       * Parses a single template node attribute and adds node metadata to
       * `nodeInfo` for attributes of interest.
       *
       * This implementation adds metadata for `on-event="handler"` attributes
       * and `id` attributes.
       *
       * @param {Element} node Node to parse
       * @param {!TemplateInfo} templateInfo Template metadata for current template
       * @param {!NodeInfo} nodeInfo Node metadata for current template.
       * @param {string} name Attribute name
       * @param {string} value Attribute value
       * @return {boolean} `true` if the visited node added node-specific
       *   metadata to `nodeInfo`
       * @nocollapse
       */
      static _parseTemplateNodeAttribute(t, i, r, o, a) {
        return o.slice(0, 3) === "on-" ? (t.removeAttribute(o), r.events = r.events || [], r.events.push({
          name: o.slice(3),
          value: a
        }), !0) : o === "id" ? (r.id = a, !0) : !1;
      }
      /**
       * Returns the `content` document fragment for a given template.
       *
       * For nested templates, Polymer performs an optimization to cache nested
       * template content to avoid the cost of cloning deeply nested templates.
       * This method retrieves the cached content for a given template.
       *
       * @param {HTMLTemplateElement} template Template to retrieve `content` for
       * @return {DocumentFragment} Content fragment
       * @nocollapse
       */
      static _contentForTemplate(t) {
        let i = (
          /** @type {HTMLTemplateElementWithInfo} */
          t._templateInfo
        );
        return i && i.content || t.content;
      }
      /**
       * Clones the provided template content and returns a document fragment
       * containing the cloned dom.
       *
       * The template is parsed (once and memoized) using this library's
       * template parsing features, and provides the following value-added
       * features:
       * * Adds declarative event listeners for `on-event="handler"` attributes
       * * Generates an "id map" for all nodes with id's under `$` on returned
       *   document fragment
       * * Passes template info including `content` back to templates as
       *   `_templateInfo` (a performance optimization to avoid deep template
       *   cloning)
       *
       * Note that the memoized template parsing process is destructive to the
       * template: attributes for bindings and declarative event listeners are
       * removed after being noted in notes, and any nested `<template>.content`
       * is removed and stored in notes as well.
       *
       * @param {!HTMLTemplateElement} template Template to stamp
       * @param {TemplateInfo=} templateInfo Optional template info associated
       *   with the template to be stamped; if omitted the template will be
       *   automatically parsed.
       * @return {!StampedTemplate} Cloned template content
       * @override
       */
      _stampTemplate(t, i) {
        t && !t.content && window.HTMLTemplateElement && HTMLTemplateElement.decorate && HTMLTemplateElement.decorate(t), i = i || this.constructor._parseTemplate(t);
        let r = i.nodeInfoList, o = i.content || t.content, a = (
          /** @type {DocumentFragment} */
          document.importNode(o, !0)
        );
        a.__noInsertionPoint = !i.hasInsertionPoint;
        let c = a.nodeList = new Array(r.length);
        a.$ = {};
        for (let u = 0, h = r.length, f; u < h && (f = r[u]); u++) {
          let g = c[u] = El(a, f);
          gd(this, a.$, g, f), vd(this, g, f, i), md(this, g, f);
        }
        return a = /** @type {!StampedTemplate} */
        a, a;
      }
      /**
       * Adds an event listener by method name for the event provided.
       *
       * This method generates a handler function that looks up the method
       * name at handling time.
       *
       * @param {!EventTarget} node Node to add listener on
       * @param {string} eventName Name of event
       * @param {string} methodName Name of method
       * @param {*=} context Context the method will be called on (defaults
       *   to `node`)
       * @return {Function} Generated handler function
       * @override
       */
      _addMethodEventListenerToNode(t, i, r, o) {
        o = o || t;
        let a = _d(o, i, r);
        return this._addEventListenerToNode(t, i, a), a;
      }
      /**
       * Override point for adding custom or simulated event handling.
       *
       * @param {!EventTarget} node Node to add event listener to
       * @param {string} eventName Name of event
       * @param {function(!Event):void} handler Listener function to add
       * @return {void}
       * @override
       */
      _addEventListenerToNode(t, i, r) {
        t.addEventListener(i, r);
      }
      /**
       * Override point for adding custom or simulated event handling.
       *
       * @param {!EventTarget} node Node to remove event listener from
       * @param {string} eventName Name of event
       * @param {function(!Event):void} handler Listener function to remove
       * @return {void}
       * @override
       */
      _removeEventListenerFromNode(t, i, r) {
        t.removeEventListener(i, r);
      }
    }
    return n;
  }
);
/**
 * @fileoverview
 * @suppress {checkPrototypalTypes}
 * @license Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt The complete set of authors may be found
 * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may
 * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by
 * Google as part of the polymer project is also subject to an additional IP
 * rights grant found at http://polymer.github.io/PATENTS.txt
 */
let mr = 0;
const vr = [], Oe = {
  COMPUTE: "__computeEffects",
  REFLECT: "__reflectEffects",
  NOTIFY: "__notifyEffects",
  PROPAGATE: "__propagateEffects",
  OBSERVE: "__observeEffects",
  READ_ONLY: "__readOnly"
}, Pl = "__computeInfo", yd = /[A-Z]/;
function go(s, n, e) {
  let t = s[n];
  if (!t)
    t = s[n] = {};
  else if (!s.hasOwnProperty(n) && (t = s[n] = Object.create(s[n]), e))
    for (let i in t) {
      let r = t[i], o = t[i] = Array(r.length);
      for (let a = 0; a < r.length; a++)
        o[a] = r[a];
    }
  return t;
}
function ar(s, n, e, t, i, r) {
  if (n) {
    let o = !1;
    const a = mr++;
    for (let c in e) {
      let u = i ? gi(c) : c, h = n[u];
      if (h)
        for (let f = 0, g = h.length, x; f < g && (x = h[f]); f++)
          (!x.info || x.info.lastRun !== a) && (!i || ls(c, x.trigger)) && (x.info && (x.info.lastRun = a), x.fn(s, c, e, t, x.info, i, r), o = !0);
    }
    return o;
  }
  return !1;
}
function wd(s, n, e, t, i, r, o, a) {
  let c = !1, u = o ? gi(t) : t, h = n[u];
  if (h)
    for (let f = 0, g = h.length, x; f < g && (x = h[f]); f++)
      (!x.info || x.info.lastRun !== e) && (!o || ls(t, x.trigger)) && (x.info && (x.info.lastRun = e), x.fn(s, t, i, r, x.info, o, a), c = !0);
  return c;
}
function ls(s, n) {
  if (n) {
    let e = (
      /** @type {string} */
      n.name
    );
    return e == s || !!(n.structured && $u(e, s)) || !!(n.wildcard && _n(e, s));
  } else
    return !0;
}
function Ca(s, n, e, t, i) {
  let r = typeof i.method == "string" ? s[i.method] : i.method, o = i.property;
  r ? r.call(s, s.__data[o], t[o]) : i.dynamicFn || console.warn("observer method `" + i.method + "` not defined");
}
function xd(s, n, e, t, i) {
  let r = s[Oe.NOTIFY], o, a = mr++;
  for (let u in n)
    n[u] && (r && wd(s, r, a, u, e, t, i) || i && Cd(s, u, e)) && (o = !0);
  let c;
  o && (c = s.__dataHost) && c._invalidateProperties && c._invalidateProperties();
}
function Cd(s, n, e) {
  let t = gi(n);
  if (t !== n) {
    let i = Rn(t) + "-changed";
    return Sl(s, i, e[n], n), !0;
  }
  return !1;
}
function Sl(s, n, e, t) {
  let i = {
    value: e,
    queueProperty: !0
  };
  t && (i.path = t), ci(
    /** @type {!HTMLElement} */
    s
  ).dispatchEvent(new CustomEvent(n, { detail: i }));
}
function Td(s, n, e, t, i, r) {
  let a = (r ? gi(n) : n) != n ? n : null, c = a ? dt(s, a) : s.__data[n];
  a && c === void 0 && (c = e[n]), Sl(s, i.eventName, c, a);
}
function Ed(s, n, e, t, i) {
  let r, o = (
    /** @type {Object} */
    s.detail
  ), a = o && o.path;
  a ? (t = bn(e, t, a), r = o && o.value) : r = s.currentTarget[e], r = i ? !r : r, (!n[Oe.READ_ONLY] || !n[Oe.READ_ONLY][t]) && n._setPendingPropertyOrPath(t, r, !0, !!a) && (!o || !o.queueProperty) && n._invalidateProperties();
}
function Pd(s, n, e, t, i) {
  let r = s.__data[n];
  vn && (r = vn(
    r,
    i.attrName,
    "attribute",
    /** @type {Node} */
    s
  )), s._propertyToAttribute(n, i.attrName, r);
}
function Sd(s, n, e, t) {
  let i = s[Oe.COMPUTE];
  if (i)
    if (Wu) {
      mr++;
      const r = Rd(s), o = [];
      for (let c in n)
        Ta(c, i, o, r, t);
      let a;
      for (; a = o.shift(); )
        kl(s, "", n, e, a) && Ta(a.methodInfo, i, o, r, t);
      Object.assign(
        /** @type {!Object} */
        e,
        s.__dataOld
      ), Object.assign(
        /** @type {!Object} */
        n,
        s.__dataPending
      ), s.__dataPending = null;
    } else {
      let r = n;
      for (; ar(s, i, r, e, t); )
        Object.assign(
          /** @type {!Object} */
          e,
          s.__dataOld
        ), Object.assign(
          /** @type {!Object} */
          n,
          s.__dataPending
        ), r = s.__dataPending, s.__dataPending = null;
    }
}
const kd = (s, n, e) => {
  let t = 0, i = n.length - 1, r = -1;
  for (; t <= i; ) {
    const o = t + i >> 1, a = e.get(n[o].methodInfo) - e.get(s.methodInfo);
    if (a < 0)
      t = o + 1;
    else if (a > 0)
      i = o - 1;
    else {
      r = o;
      break;
    }
  }
  r < 0 && (r = i + 1), n.splice(r, 0, s);
}, Ta = (s, n, e, t, i) => {
  const r = i ? gi(s) : s, o = n[r];
  if (o)
    for (let a = 0; a < o.length; a++) {
      const c = o[a];
      c.info.lastRun !== mr && (!i || ls(s, c.trigger)) && (c.info.lastRun = mr, kd(c.info, e, t));
    }
};
function Rd(s) {
  let n = s.constructor.__orderedComputedDeps;
  if (!n) {
    n = /* @__PURE__ */ new Map();
    const e = s[Oe.COMPUTE];
    let { counts: t, ready: i, total: r } = Ad(s), o;
    for (; o = i.shift(); ) {
      n.set(o, n.size);
      const a = e[o];
      a && a.forEach((c) => {
        const u = c.info.methodInfo;
        --r, --t[u] === 0 && i.push(u);
      });
    }
    r !== 0 && console.warn(`Computed graph for ${/** @type {HTMLElement} */
    s.localName} incomplete; circular?`), s.constructor.__orderedComputedDeps = n;
  }
  return n;
}
function Ad(s) {
  const n = s[Pl], e = {}, t = s[Oe.COMPUTE], i = [];
  let r = 0;
  for (let o in n) {
    const a = n[o];
    r += e[o] = a.args.filter((c) => !c.literal).length + (a.dynamicFn ? 1 : 0);
  }
  for (let o in t)
    n[o] || i.push(o);
  return { counts: e, ready: i, total: r };
}
function kl(s, n, e, t, i) {
  let r = Bo(s, n, e, t, i);
  if (r === vr)
    return !1;
  let o = i.methodInfo;
  return s.__dataHasAccessor && s.__dataHasAccessor[o] ? s._setPendingProperty(o, r, !0) : (s[o] = r, !1);
}
function Id(s, n, e) {
  let t = s.__dataLinkedPaths;
  if (t) {
    let i;
    for (let r in t) {
      let o = t[r];
      _n(r, n) ? (i = bn(r, o, n), s._setPendingPropertyOrPath(i, e, !0, !0)) : _n(o, n) && (i = bn(o, r, n), s._setPendingPropertyOrPath(i, e, !0, !0));
    }
  }
}
function mo(s, n, e, t, i, r, o) {
  e.bindings = e.bindings || [];
  let a = { kind: t, target: i, parts: r, literal: o, isCompound: r.length !== 1 };
  if (e.bindings.push(a), Md(a)) {
    let { event: u, negate: h } = a.parts[0];
    a.listenerEvent = u || Rn(i) + "-changed", a.listenerNegate = h;
  }
  let c = n.nodeInfoList.length;
  for (let u = 0; u < a.parts.length; u++) {
    let h = a.parts[u];
    h.compoundIndex = u, Dd(s, n, a, h, c);
  }
}
function Dd(s, n, e, t, i) {
  if (!t.literal)
    if (e.kind === "attribute" && e.target[0] === "-")
      console.warn("Cannot set attribute " + e.target + ' because "-" is not a valid attribute starting character');
    else {
      let r = t.dependencies, o = { index: i, binding: e, part: t, evaluator: s };
      for (let a = 0; a < r.length; a++) {
        let c = r[a];
        typeof c == "string" && (c = Al(c), c.wildcard = !0), s._addTemplatePropertyEffect(n, c.rootProperty, {
          fn: Od,
          info: o,
          trigger: c
        });
      }
    }
}
function Od(s, n, e, t, i, r, o) {
  let a = o[i.index], c = i.binding, u = i.part;
  if (r && u.source && n.length > u.source.length && c.kind == "property" && !c.isCompound && a.__isPropertyEffectsClient && a.__dataHasAccessor && a.__dataHasAccessor[c.target]) {
    let h = e[n];
    n = bn(u.source, c.target, n), a._setPendingPropertyOrPath(n, h, !1, !0) && s._enqueueClient(a);
  } else {
    let h = i.evaluator._evaluateBinding(s, u, n, e, t, r);
    h !== vr && zd(s, a, c, u, h);
  }
}
function zd(s, n, e, t, i) {
  if (i = Fd(n, i, e, t), vn && (i = vn(i, e.target, e.kind, n)), e.kind == "attribute")
    s._valueToNodeAttribute(
      /** @type {Element} */
      n,
      i,
      e.target
    );
  else {
    let r = e.target;
    n.__isPropertyEffectsClient && n.__dataHasAccessor && n.__dataHasAccessor[r] ? (!n[Oe.READ_ONLY] || !n[Oe.READ_ONLY][r]) && n._setPendingProperty(r, i) && s._enqueueClient(n) : s._setUnmanagedPropertyToNode(n, r, i);
  }
}
function Fd(s, n, e, t) {
  if (e.isCompound) {
    let i = s.__dataCompoundStorage[e.target];
    i[t.compoundIndex] = n, n = i.join("");
  }
  return e.kind !== "attribute" && (e.target === "textContent" || e.target === "value" && (s.localName === "input" || s.localName === "textarea")) && (n = n ?? ""), n;
}
function Md(s) {
  return !!s.target && s.kind != "attribute" && s.kind != "text" && !s.isCompound && s.parts[0].mode === "{";
}
function Ld(s, n) {
  let { nodeList: e, nodeInfoList: t } = n;
  if (t.length)
    for (let i = 0; i < t.length; i++) {
      let r = t[i], o = e[i], a = r.bindings;
      if (a)
        for (let c = 0; c < a.length; c++) {
          let u = a[c];
          Bd(o, u), Nd(o, s, u);
        }
      o.__dataHost = s;
    }
}
function Bd(s, n) {
  if (n.isCompound) {
    let e = s.__dataCompoundStorage || (s.__dataCompoundStorage = {}), t = n.parts, i = new Array(t.length);
    for (let o = 0; o < t.length; o++)
      i[o] = t[o].literal;
    let r = n.target;
    e[r] = i, n.literal && n.kind == "property" && (r === "className" && (s = ci(s)), s[r] = n.literal);
  }
}
function Nd(s, n, e) {
  if (e.listenerEvent) {
    let t = e.parts[0];
    s.addEventListener(e.listenerEvent, function(i) {
      Ed(i, n, e.target, t.source, t.negate);
    });
  }
}
function Ea(s, n, e, t, i, r) {
  r = n.static || r && (typeof r != "object" || r[n.methodName]);
  let o = {
    methodName: n.methodName,
    args: n.args,
    methodInfo: i,
    dynamicFn: r
  };
  for (let a = 0, c; a < n.args.length && (c = n.args[a]); a++)
    c.literal || s._addPropertyEffect(c.rootProperty, e, {
      fn: t,
      info: o,
      trigger: c
    });
  return r && s._addPropertyEffect(n.methodName, e, {
    fn: t,
    info: o
  }), o;
}
function Bo(s, n, e, t, i) {
  let r = s._methodHost || s, o = r[i.methodName];
  if (o) {
    let a = s._marshalArgs(i.args, n, e);
    return a === vr ? vr : o.apply(r, a);
  } else i.dynamicFn || console.warn("method `" + i.methodName + "` not defined");
}
const Hd = [], Rl = "(?:[a-zA-Z_$][\\w.:$\\-*]*)", Vd = "(?:[-+]?[0-9]*\\.?[0-9]+(?:[eE][-+]?[0-9]+)?)", Ud = "(?:'(?:[^'\\\\]|\\\\.)*')", Wd = '(?:"(?:[^"\\\\]|\\\\.)*")', jd = "(?:" + Ud + "|" + Wd + ")", Pa = "(?:(" + Rl + "|" + Vd + "|" + jd + ")\\s*)", Gd = "(?:" + Pa + "(?:,\\s*" + Pa + ")*)", qd = "(?:\\(\\s*(?:" + Gd + "?)\\)\\s*)", Kd = "(" + Rl + "\\s*" + qd + "?)", Zd = "(\\[\\[|{{)\\s*", Yd = "(?:]]|}})", Xd = "(?:(!)\\s*)?", Qd = Zd + Xd + Kd + Yd, Sa = new RegExp(Qd, "g");
function ka(s) {
  let n = "";
  for (let e = 0; e < s.length; e++) {
    let t = s[e].literal;
    n += t || "";
  }
  return n;
}
function vo(s) {
  let n = s.match(/([^\s]+?)\(([\s\S]*)\)/);
  if (n) {
    let t = { methodName: n[1], static: !0, args: Hd };
    if (n[2].trim()) {
      let i = n[2].replace(/\\,/g, "&comma;").split(",");
      return Jd(i, t);
    } else
      return t;
  }
  return null;
}
function Jd(s, n) {
  return n.args = s.map(function(e) {
    let t = Al(e);
    return t.literal || (n.static = !1), t;
  }, this), n;
}
function Al(s) {
  let n = s.trim().replace(/&comma;/g, ",").replace(/\\(.)/g, "$1"), e = {
    name: n,
    value: "",
    literal: !1
  }, t = n[0];
  switch (t === "-" && (t = n[1]), t >= "0" && t <= "9" && (t = "#"), t) {
    case "'":
    case '"':
      e.value = n.slice(1, -1), e.literal = !0;
      break;
    case "#":
      e.value = Number(n), e.literal = !0;
      break;
  }
  return e.literal || (e.rootProperty = gi(n), e.structured = Mo(n), e.structured && (e.wildcard = n.slice(-2) == ".*", e.wildcard && (e.name = n.slice(0, -2)))), e;
}
function Ra(s, n, e) {
  let t = dt(s, e);
  return t === void 0 && (t = n[e]), t;
}
function Il(s, n, e, t) {
  const i = { indexSplices: t };
  Fo && !s._overrideLegacyUndefined && (n.splices = i), s.notifyPath(e + ".splices", i), s.notifyPath(e + ".length", n.length), Fo && !s._overrideLegacyUndefined && (i.indexSplices = []);
}
function ir(s, n, e, t, i, r) {
  Il(s, n, e, [{
    index: t,
    addedCount: i,
    removed: r,
    object: n,
    type: "splice"
  }]);
}
function $d(s) {
  return s[0].toUpperCase() + s.substring(1);
}
const eh = rt((s) => {
  const n = bd(cd(s));
  class e extends n {
    constructor() {
      super(), this.__isPropertyEffectsClient = !0, this.__dataClientsReady, this.__dataPendingClients, this.__dataToNotify, this.__dataLinkedPaths, this.__dataHasPaths, this.__dataCompoundStorage, this.__dataHost, this.__dataTemp, this.__dataClientsInitialized, this.__data, this.__dataPending, this.__dataOld, this.__computeEffects, this.__computeInfo, this.__reflectEffects, this.__notifyEffects, this.__propagateEffects, this.__observeEffects, this.__readOnly, this.__templateInfo, this._overrideLegacyUndefined;
    }
    get PROPERTY_EFFECT_TYPES() {
      return Oe;
    }
    /**
     * @override
     * @return {void}
     */
    _initializeProperties() {
      super._initializeProperties(), this._registerHost(), this.__dataClientsReady = !1, this.__dataPendingClients = null, this.__dataToNotify = null, this.__dataLinkedPaths = null, this.__dataHasPaths = !1, this.__dataCompoundStorage = this.__dataCompoundStorage || null, this.__dataHost = this.__dataHost || null, this.__dataTemp = {}, this.__dataClientsInitialized = !1;
    }
    _registerHost() {
      if (rr.length) {
        let i = rr[rr.length - 1];
        i._enqueueClient(this), this.__dataHost = i;
      }
    }
    /**
     * Overrides `PropertyAccessors` implementation to provide a
     * more efficient implementation of initializing properties from
     * the prototype on the instance.
     *
     * @override
     * @param {Object} props Properties to initialize on the prototype
     * @return {void}
     */
    _initializeProtoProperties(i) {
      this.__data = Object.create(i), this.__dataPending = Object.create(i), this.__dataOld = {};
    }
    /**
     * Overrides `PropertyAccessors` implementation to avoid setting
     * `_setProperty`'s `shouldNotify: true`.
     *
     * @override
     * @param {Object} props Properties to initialize on the instance
     * @return {void}
     */
    _initializeInstanceProperties(i) {
      let r = this[Oe.READ_ONLY];
      for (let o in i)
        (!r || !r[o]) && (this.__dataPending = this.__dataPending || {}, this.__dataOld = this.__dataOld || {}, this.__data[o] = this.__dataPending[o] = i[o]);
    }
    // Prototype setup ----------------------------------------
    /**
     * Equivalent to static `addPropertyEffect` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @override
     * @param {string} property Property that should trigger the effect
     * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
     * @param {Object=} effect Effect metadata object
     * @return {void}
     * @protected
     */
    _addPropertyEffect(i, r, o) {
      this._createPropertyAccessor(i, r == Oe.READ_ONLY);
      let a = go(this, r, !0)[i];
      a || (a = this[r][i] = []), a.push(o);
    }
    /**
     * Removes the given property effect.
     *
     * @override
     * @param {string} property Property the effect was associated with
     * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
     * @param {Object=} effect Effect metadata object to remove
     * @return {void}
     */
    _removePropertyEffect(i, r, o) {
      let a = go(this, r, !0)[i], c = a.indexOf(o);
      c >= 0 && a.splice(c, 1);
    }
    /**
     * Returns whether the current prototype/instance has a property effect
     * of a certain type.
     *
     * @override
     * @param {string} property Property name
     * @param {string=} type Effect type, from this.PROPERTY_EFFECT_TYPES
     * @return {boolean} True if the prototype/instance has an effect of this
     *     type
     * @protected
     */
    _hasPropertyEffect(i, r) {
      let o = this[r];
      return !!(o && o[i]);
    }
    /**
     * Returns whether the current prototype/instance has a "read only"
     * accessor for the given property.
     *
     * @override
     * @param {string} property Property name
     * @return {boolean} True if the prototype/instance has an effect of this
     *     type
     * @protected
     */
    _hasReadOnlyEffect(i) {
      return this._hasPropertyEffect(i, Oe.READ_ONLY);
    }
    /**
     * Returns whether the current prototype/instance has a "notify"
     * property effect for the given property.
     *
     * @override
     * @param {string} property Property name
     * @return {boolean} True if the prototype/instance has an effect of this
     *     type
     * @protected
     */
    _hasNotifyEffect(i) {
      return this._hasPropertyEffect(i, Oe.NOTIFY);
    }
    /**
     * Returns whether the current prototype/instance has a "reflect to
     * attribute" property effect for the given property.
     *
     * @override
     * @param {string} property Property name
     * @return {boolean} True if the prototype/instance has an effect of this
     *     type
     * @protected
     */
    _hasReflectEffect(i) {
      return this._hasPropertyEffect(i, Oe.REFLECT);
    }
    /**
     * Returns whether the current prototype/instance has a "computed"
     * property effect for the given property.
     *
     * @override
     * @param {string} property Property name
     * @return {boolean} True if the prototype/instance has an effect of this
     *     type
     * @protected
     */
    _hasComputedEffect(i) {
      return this._hasPropertyEffect(i, Oe.COMPUTE);
    }
    // Runtime ----------------------------------------
    /**
     * Sets a pending property or path.  If the root property of the path in
     * question had no accessor, the path is set, otherwise it is enqueued
     * via `_setPendingProperty`.
     *
     * This function isolates relatively expensive functionality necessary
     * for the public API (`set`, `setProperties`, `notifyPath`, and property
     * change listeners via {{...}} bindings), such that it is only done
     * when paths enter the system, and not at every propagation step.  It
     * also sets a `__dataHasPaths` flag on the instance which is used to
     * fast-path slower path-matching code in the property effects host paths.
     *
     * `path` can be a path string or array of path parts as accepted by the
     * public API.
     *
     * @override
     * @param {string | !Array<number|string>} path Path to set
     * @param {*} value Value to set
     * @param {boolean=} shouldNotify Set to true if this change should
     *  cause a property notification event dispatch
     * @param {boolean=} isPathNotification If the path being set is a path
     *   notification of an already changed value, as opposed to a request
     *   to set and notify the change.  In the latter `false` case, a dirty
     *   check is performed and then the value is set to the path before
     *   enqueuing the pending property change.
     * @return {boolean} Returns true if the property/path was enqueued in
     *   the pending changes bag.
     * @protected
     */
    _setPendingPropertyOrPath(i, r, o, a) {
      if (a || gi(Array.isArray(i) ? i[0] : i) !== i) {
        if (!a) {
          let c = dt(this, i);
          if (i = /** @type {string} */
          ya(this, i, r), !i || !super._shouldPropertyChange(i, r, c))
            return !1;
        }
        if (this.__dataHasPaths = !0, this._setPendingProperty(
          /**@type{string}*/
          i,
          r,
          o
        ))
          return Id(
            this,
            /**@type{string}*/
            i,
            r
          ), !0;
      } else {
        if (this.__dataHasAccessor && this.__dataHasAccessor[i])
          return this._setPendingProperty(
            /**@type{string}*/
            i,
            r,
            o
          );
        this[i] = r;
      }
      return !1;
    }
    /**
     * Applies a value to a non-Polymer element/node's property.
     *
     * The implementation makes a best-effort at binding interop:
     * Some native element properties have side-effects when
     * re-setting the same value (e.g. setting `<input>.value` resets the
     * cursor position), so we do a dirty-check before setting the value.
     * However, for better interop with non-Polymer custom elements that
     * accept objects, we explicitly re-set object changes coming from the
     * Polymer world (which may include deep object changes without the
     * top reference changing), erring on the side of providing more
     * information.
     *
     * Users may override this method to provide alternate approaches.
     *
     * @override
     * @param {!Node} node The node to set a property on
     * @param {string} prop The property to set
     * @param {*} value The value to set
     * @return {void}
     * @protected
     */
    _setUnmanagedPropertyToNode(i, r, o) {
      (o !== i[r] || typeof o == "object") && (r === "className" && (i = /** @type {!Node} */
      ci(i)), i[r] = o);
    }
    /**
     * Overrides the `PropertiesChanged` implementation to introduce special
     * dirty check logic depending on the property & value being set:
     *
     * 1. Any value set to a path (e.g. 'obj.prop': 42 or 'obj.prop': {...})
     *    Stored in `__dataTemp`, dirty checked against `__dataTemp`
     * 2. Object set to simple property (e.g. 'prop': {...})
     *    Stored in `__dataTemp` and `__data`, dirty checked against
     *    `__dataTemp` by default implementation of `_shouldPropertyChange`
     * 3. Primitive value set to simple property (e.g. 'prop': 42)
     *    Stored in `__data`, dirty checked against `__data`
     *
     * The dirty-check is important to prevent cycles due to two-way
     * notification, but paths and objects are only dirty checked against any
     * previous value set during this turn via a "temporary cache" that is
     * cleared when the last `_propertiesChanged` exits. This is so:
     * a. any cached array paths (e.g. 'array.3.prop') may be invalidated
     *    due to array mutations like shift/unshift/splice; this is fine
     *    since path changes are dirty-checked at user entry points like `set`
     * b. dirty-checking for objects only lasts one turn to allow the user
     *    to mutate the object in-place and re-set it with the same identity
     *    and have all sub-properties re-propagated in a subsequent turn.
     *
     * The temp cache is not necessarily sufficient to prevent invalid array
     * paths, since a splice can happen during the same turn (with pathological
     * user code); we could introduce a "fixup" for temporarily cached array
     * paths if needed: https://github.com/Polymer/polymer/issues/4227
     *
     * @override
     * @param {string} property Name of the property
     * @param {*} value Value to set
     * @param {boolean=} shouldNotify True if property should fire notification
     *   event (applies only for `notify: true` properties)
     * @return {boolean} Returns true if the property changed
     */
    _setPendingProperty(i, r, o) {
      let a = this.__dataHasPaths && Mo(i), c = a ? this.__dataTemp : this.__data;
      return this._shouldPropertyChange(i, r, c[i]) ? (this.__dataPending || (this.__dataPending = {}, this.__dataOld = {}), i in this.__dataOld || (this.__dataOld[i] = this.__data[i]), a ? this.__dataTemp[i] = r : this.__data[i] = r, this.__dataPending[i] = r, (a || this[Oe.NOTIFY] && this[Oe.NOTIFY][i]) && (this.__dataToNotify = this.__dataToNotify || {}, this.__dataToNotify[i] = o), !0) : !1;
    }
    /**
     * Overrides base implementation to ensure all accessors set `shouldNotify`
     * to true, for per-property notification tracking.
     *
     * @override
     * @param {string} property Name of the property
     * @param {*} value Value to set
     * @return {void}
     */
    _setProperty(i, r) {
      this._setPendingProperty(i, r, !0) && this._invalidateProperties();
    }
    /**
     * Overrides `PropertyAccessor`'s default async queuing of
     * `_propertiesChanged`: if `__dataReady` is false (has not yet been
     * manually flushed), the function no-ops; otherwise flushes
     * `_propertiesChanged` synchronously.
     *
     * @override
     * @return {void}
     */
    _invalidateProperties() {
      this.__dataReady && this._flushProperties();
    }
    /**
     * Enqueues the given client on a list of pending clients, whose
     * pending property changes can later be flushed via a call to
     * `_flushClients`.
     *
     * @override
     * @param {Object} client PropertyEffects client to enqueue
     * @return {void}
     * @protected
     */
    _enqueueClient(i) {
      this.__dataPendingClients = this.__dataPendingClients || [], i !== this && this.__dataPendingClients.push(i);
    }
    /**
     * Flushes any clients previously enqueued via `_enqueueClient`, causing
     * their `_flushProperties` method to run.
     *
     * @override
     * @return {void}
     * @protected
     */
    _flushClients() {
      this.__dataClientsReady ? this.__enableOrFlushClients() : (this.__dataClientsReady = !0, this._readyClients(), this.__dataReady = !0);
    }
    // NOTE: We ensure clients either enable or flush as appropriate. This
    // handles two corner cases:
    // (1) clients flush properly when connected/enabled before the host
    // enables; e.g.
    //   (a) Templatize stamps with no properties and does not flush and
    //   (b) the instance is inserted into dom and
    //   (c) then the instance flushes.
    // (2) clients enable properly when not connected/enabled when the host
    // flushes; e.g.
    //   (a) a template is runtime stamped and not yet connected/enabled
    //   (b) a host sets a property, causing stamped dom to flush
    //   (c) the stamped dom enables.
    __enableOrFlushClients() {
      let i = this.__dataPendingClients;
      if (i) {
        this.__dataPendingClients = null;
        for (let r = 0; r < i.length; r++) {
          let o = i[r];
          o.__dataEnabled ? o.__dataPending && o._flushProperties() : o._enableProperties();
        }
      }
    }
    /**
     * Perform any initial setup on client dom. Called before the first
     * `_flushProperties` call on client dom and before any element
     * observers are called.
     *
     * @override
     * @return {void}
     * @protected
     */
    _readyClients() {
      this.__enableOrFlushClients();
    }
    /**
     * Sets a bag of property changes to this instance, and
     * synchronously processes all effects of the properties as a batch.
     *
     * Property names must be simple properties, not paths.  Batched
     * path propagation is not supported.
     *
     * @override
     * @param {Object} props Bag of one or more key-value pairs whose key is
     *   a property and value is the new value to set for that property.
     * @param {boolean=} setReadOnly When true, any private values set in
     *   `props` will be set. By default, `setProperties` will not set
     *   `readOnly: true` root properties.
     * @return {void}
     * @public
     */
    setProperties(i, r) {
      for (let o in i)
        (r || !this[Oe.READ_ONLY] || !this[Oe.READ_ONLY][o]) && this._setPendingPropertyOrPath(o, i[o], !0);
      this._invalidateProperties();
    }
    /**
     * Overrides `PropertyAccessors` so that property accessor
     * side effects are not enabled until after client dom is fully ready.
     * Also calls `_flushClients` callback to ensure client dom is enabled
     * that was not enabled as a result of flushing properties.
     *
     * @override
     * @return {void}
     */
    ready() {
      this._flushProperties(), this.__dataClientsReady || this._flushClients(), this.__dataPending && this._flushProperties();
    }
    /**
     * Implements `PropertyAccessors`'s properties changed callback.
     *
     * Runs each class of effects for the batch of changed properties in
     * a specific order (compute, propagate, reflect, observe, notify).
     *
     * @override
     * @param {!Object} currentProps Bag of all current accessor values
     * @param {?Object} changedProps Bag of properties changed since the last
     *   call to `_propertiesChanged`
     * @param {?Object} oldProps Bag of previous values for each property
     *   in `changedProps`
     * @return {void}
     */
    _propertiesChanged(i, r, o) {
      let a = this.__dataHasPaths;
      this.__dataHasPaths = !1;
      let c;
      Sd(this, r, o, a), c = this.__dataToNotify, this.__dataToNotify = null, this._propagatePropertyChanges(r, o, a), this._flushClients(), ar(this, this[Oe.REFLECT], r, o, a), ar(this, this[Oe.OBSERVE], r, o, a), c && xd(this, c, r, o, a), this.__dataCounter == 1 && (this.__dataTemp = {});
    }
    /**
     * Called to propagate any property changes to stamped template nodes
     * managed by this element.
     *
     * @override
     * @param {Object} changedProps Bag of changed properties
     * @param {Object} oldProps Bag of previous values for changed properties
     * @param {boolean} hasPaths True with `props` contains one or more paths
     * @return {void}
     * @protected
     */
    _propagatePropertyChanges(i, r, o) {
      this[Oe.PROPAGATE] && ar(this, this[Oe.PROPAGATE], i, r, o), this.__templateInfo && this._runEffectsForTemplate(this.__templateInfo, i, r, o);
    }
    _runEffectsForTemplate(i, r, o, a) {
      const c = (u, h) => {
        ar(
          this,
          i.propertyEffects,
          u,
          o,
          h,
          i.nodeList
        );
        for (let f = i.firstChild; f; f = f.nextSibling)
          this._runEffectsForTemplate(f, u, o, h);
      };
      i.runEffects ? i.runEffects(c, r, a) : c(r, a);
    }
    /**
     * Aliases one data path as another, such that path notifications from one
     * are routed to the other.
     *
     * @override
     * @param {string | !Array<string|number>} to Target path to link.
     * @param {string | !Array<string|number>} from Source path to link.
     * @return {void}
     * @public
     */
    linkPaths(i, r) {
      i = sr(i), r = sr(r), this.__dataLinkedPaths = this.__dataLinkedPaths || {}, this.__dataLinkedPaths[i] = r;
    }
    /**
     * Removes a data path alias previously established with `_linkPaths`.
     *
     * Note, the path to unlink should be the target (`to`) used when
     * linking the paths.
     *
     * @override
     * @param {string | !Array<string|number>} path Target path to unlink.
     * @return {void}
     * @public
     */
    unlinkPaths(i) {
      i = sr(i), this.__dataLinkedPaths && delete this.__dataLinkedPaths[i];
    }
    /**
     * Notify that an array has changed.
     *
     * Example:
     *
     *     this.items = [ {name: 'Jim'}, {name: 'Todd'}, {name: 'Bill'} ];
     *     ...
     *     this.items.splice(1, 1, {name: 'Sam'});
     *     this.items.push({name: 'Bob'});
     *     this.notifySplices('items', [
     *       { index: 1, removed: [{name: 'Todd'}], addedCount: 1,
     *         object: this.items, type: 'splice' },
     *       { index: 3, removed: [], addedCount: 1,
     *         object: this.items, type: 'splice'}
     *     ]);
     *
     * @param {string} path Path that should be notified.
     * @param {Array} splices Array of splice records indicating ordered
     *   changes that occurred to the array. Each record should have the
     *   following fields:
     *    * index: index at which the change occurred
     *    * removed: array of items that were removed from this index
     *    * addedCount: number of new items added at this index
     *    * object: a reference to the array in question
     *    * type: the string literal 'splice'
     *
     *   Note that splice records _must_ be normalized such that they are
     *   reported in index order (raw results from `Object.observe` are not
     *   ordered and must be normalized/merged before notifying).
     *
     * @override
     * @return {void}
     * @public
     */
    notifySplices(i, r) {
      let o = { path: "" }, a = (
        /** @type {Array} */
        dt(this, i, o)
      );
      Il(this, a, o.path, r);
    }
    /**
     * Convenience method for reading a value from a path.
     *
     * Note, if any part in the path is undefined, this method returns
     * `undefined` (this method does not throw when dereferencing undefined
     * paths).
     *
     * @override
     * @param {(string|!Array<(string|number)>)} path Path to the value
     *   to read.  The path may be specified as a string (e.g. `foo.bar.baz`)
     *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that
     *   bracketed expressions are not supported; string-based path parts
     *   *must* be separated by dots.  Note that when dereferencing array
     *   indices, the index may be used as a dotted part directly
     *   (e.g. `users.12.name` or `['users', 12, 'name']`).
     * @param {Object=} root Root object from which the path is evaluated.
     * @return {*} Value at the path, or `undefined` if any part of the path
     *   is undefined.
     * @public
     */
    get(i, r) {
      return dt(r || this, i);
    }
    /**
     * Convenience method for setting a value to a path and notifying any
     * elements bound to the same path.
     *
     * Note, if any part in the path except for the last is undefined,
     * this method does nothing (this method does not throw when
     * dereferencing undefined paths).
     *
     * @override
     * @param {(string|!Array<(string|number)>)} path Path to the value
     *   to write.  The path may be specified as a string (e.g. `'foo.bar.baz'`)
     *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that
     *   bracketed expressions are not supported; string-based path parts
     *   *must* be separated by dots.  Note that when dereferencing array
     *   indices, the index may be used as a dotted part directly
     *   (e.g. `'users.12.name'` or `['users', 12, 'name']`).
     * @param {*} value Value to set at the specified path.
     * @param {Object=} root Root object from which the path is evaluated.
     *   When specified, no notification will occur.
     * @return {void}
     * @public
     */
    set(i, r, o) {
      o ? ya(o, i, r) : (!this[Oe.READ_ONLY] || !this[Oe.READ_ONLY][
        /** @type {string} */
        i
      ]) && this._setPendingPropertyOrPath(i, r, !0) && this._invalidateProperties();
    }
    /**
     * Adds items onto the end of the array at the path specified.
     *
     * The arguments after `path` and return value match that of
     * `Array.prototype.push`.
     *
     * This method notifies other paths to the same array that a
     * splice occurred to the array.
     *
     * @override
     * @param {string | !Array<string|number>} path Path to array.
     * @param {...*} items Items to push onto array
     * @return {number} New length of the array.
     * @public
     */
    push(i, ...r) {
      let o = { path: "" }, a = (
        /** @type {Array}*/
        dt(this, i, o)
      ), c = a.length, u = a.push(...r);
      return r.length && ir(this, a, o.path, c, r.length, []), u;
    }
    /**
     * Removes an item from the end of array at the path specified.
     *
     * The arguments after `path` and return value match that of
     * `Array.prototype.pop`.
     *
     * This method notifies other paths to the same array that a
     * splice occurred to the array.
     *
     * @override
     * @param {string | !Array<string|number>} path Path to array.
     * @return {*} Item that was removed.
     * @public
     */
    pop(i) {
      let r = { path: "" }, o = (
        /** @type {Array} */
        dt(this, i, r)
      ), a = !!o.length, c = o.pop();
      return a && ir(this, o, r.path, o.length, 0, [c]), c;
    }
    /**
     * Starting from the start index specified, removes 0 or more items
     * from the array and inserts 0 or more new items in their place.
     *
     * The arguments after `path` and return value match that of
     * `Array.prototype.splice`.
     *
     * This method notifies other paths to the same array that a
     * splice occurred to the array.
     *
     * @override
     * @param {string | !Array<string|number>} path Path to array.
     * @param {number} start Index from which to start removing/inserting.
     * @param {number=} deleteCount Number of items to remove.
     * @param {...*} items Items to insert into array.
     * @return {!Array} Array of removed items.
     * @public
     */
    splice(i, r, o, ...a) {
      let c = { path: "" }, u = (
        /** @type {Array} */
        dt(this, i, c)
      );
      r < 0 ? r = u.length - Math.floor(-r) : r && (r = Math.floor(r));
      let h;
      return arguments.length === 2 ? h = u.splice(r) : h = u.splice(r, o, ...a), (a.length || h.length) && ir(this, u, c.path, r, a.length, h), h;
    }
    /**
     * Removes an item from the beginning of array at the path specified.
     *
     * The arguments after `path` and return value match that of
     * `Array.prototype.pop`.
     *
     * This method notifies other paths to the same array that a
     * splice occurred to the array.
     *
     * @override
     * @param {string | !Array<string|number>} path Path to array.
     * @return {*} Item that was removed.
     * @public
     */
    shift(i) {
      let r = { path: "" }, o = (
        /** @type {Array} */
        dt(this, i, r)
      ), a = !!o.length, c = o.shift();
      return a && ir(this, o, r.path, 0, 0, [c]), c;
    }
    /**
     * Adds items onto the beginning of the array at the path specified.
     *
     * The arguments after `path` and return value match that of
     * `Array.prototype.push`.
     *
     * This method notifies other paths to the same array that a
     * splice occurred to the array.
     *
     * @override
     * @param {string | !Array<string|number>} path Path to array.
     * @param {...*} items Items to insert info array
     * @return {number} New length of the array.
     * @public
     */
    unshift(i, ...r) {
      let o = { path: "" }, a = (
        /** @type {Array} */
        dt(this, i, o)
      ), c = a.unshift(...r);
      return r.length && ir(this, a, o.path, 0, r.length, []), c;
    }
    /**
     * Notify that a path has changed.
     *
     * Example:
     *
     *     this.item.user.name = 'Bob';
     *     this.notifyPath('item.user.name');
     *
     * @override
     * @param {string} path Path that should be notified.
     * @param {*=} value Value at the path (optional).
     * @return {void}
     * @public
     */
    notifyPath(i, r) {
      let o;
      if (arguments.length == 1) {
        let a = { path: "" };
        r = dt(this, i, a), o = a.path;
      } else Array.isArray(i) ? o = sr(i) : o = /** @type{string} */
      i;
      this._setPendingPropertyOrPath(o, r, !0, !0) && this._invalidateProperties();
    }
    /**
     * Equivalent to static `createReadOnlyProperty` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @override
     * @param {string} property Property name
     * @param {boolean=} protectedSetter Creates a custom protected setter
     *   when `true`.
     * @return {void}
     * @protected
     */
    _createReadOnlyProperty(i, r) {
      this._addPropertyEffect(i, Oe.READ_ONLY), r && (this["_set" + $d(i)] = /** @this {PropertyEffects} */
      function(o) {
        this._setProperty(i, o);
      });
    }
    /**
     * Equivalent to static `createPropertyObserver` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @override
     * @param {string} property Property name
     * @param {string|function(*,*)} method Function or name of observer method
     *     to call
     * @param {boolean=} dynamicFn Whether the method name should be included as
     *   a dependency to the effect.
     * @return {void}
     * @protected
     */
    _createPropertyObserver(i, r, o) {
      let a = { property: i, method: r, dynamicFn: !!o };
      this._addPropertyEffect(i, Oe.OBSERVE, {
        fn: Ca,
        info: a,
        trigger: { name: i }
      }), o && this._addPropertyEffect(
        /** @type {string} */
        r,
        Oe.OBSERVE,
        {
          fn: Ca,
          info: a,
          trigger: { name: r }
        }
      );
    }
    /**
     * Equivalent to static `createMethodObserver` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @override
     * @param {string} expression Method expression
     * @param {boolean|Object=} dynamicFn Boolean or object map indicating
     *   whether method names should be included as a dependency to the effect.
     * @return {void}
     * @protected
     */
    _createMethodObserver(i, r) {
      let o = vo(i);
      if (!o)
        throw new Error("Malformed observer expression '" + i + "'");
      Ea(this, o, Oe.OBSERVE, Bo, null, r);
    }
    /**
     * Equivalent to static `createNotifyingProperty` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @override
     * @param {string} property Property name
     * @return {void}
     * @protected
     */
    _createNotifyingProperty(i) {
      this._addPropertyEffect(i, Oe.NOTIFY, {
        fn: Td,
        info: {
          eventName: Rn(i) + "-changed",
          property: i
        }
      });
    }
    /**
     * Equivalent to static `createReflectedProperty` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @override
     * @param {string} property Property name
     * @return {void}
     * @protected
     * @suppress {missingProperties} go/missingfnprops
     */
    _createReflectedProperty(i) {
      let r = this.constructor.attributeNameForProperty(i);
      r[0] === "-" ? console.warn("Property " + i + " cannot be reflected to attribute " + r + ' because "-" is not a valid starting attribute name. Use a lowercase first letter for the property instead.') : this._addPropertyEffect(i, Oe.REFLECT, {
        fn: Pd,
        info: {
          attrName: r
        }
      });
    }
    /**
     * Equivalent to static `createComputedProperty` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @override
     * @param {string} property Name of computed property to set
     * @param {string} expression Method expression
     * @param {boolean|Object=} dynamicFn Boolean or object map indicating
     *   whether method names should be included as a dependency to the effect.
     * @return {void}
     * @protected
     */
    _createComputedProperty(i, r, o) {
      let a = vo(r);
      if (!a)
        throw new Error("Malformed computed expression '" + r + "'");
      const c = Ea(this, a, Oe.COMPUTE, kl, i, o);
      go(this, Pl)[i] = c;
    }
    /**
     * Gather the argument values for a method specified in the provided array
     * of argument metadata.
     *
     * The `path` and `value` arguments are used to fill in wildcard descriptor
     * when the method is being called as a result of a path notification.
     *
     * @param {!Array<!MethodArg>} args Array of argument metadata
     * @param {string} path Property/path name that triggered the method effect
     * @param {Object} props Bag of current property changes
     * @return {!Array<*>} Array of argument values
     * @private
     */
    _marshalArgs(i, r, o) {
      const a = this.__data, c = [];
      for (let u = 0, h = i.length; u < h; u++) {
        let { name: f, structured: g, wildcard: x, value: C, literal: E } = i[u];
        if (!E)
          if (x) {
            const R = _n(f, r), D = Ra(a, o, R ? r : f);
            C = {
              path: R ? r : f,
              value: D,
              base: R ? dt(a, f) : D
            };
          } else
            C = g ? Ra(a, o, f) : a[f];
        if (Fo && !this._overrideLegacyUndefined && C === void 0 && i.length > 1)
          return vr;
        c[u] = C;
      }
      return c;
    }
    // -- static class methods ------------
    /**
     * Ensures an accessor exists for the specified property, and adds
     * to a list of "property effects" that will run when the accessor for
     * the specified property is set.  Effects are grouped by "type", which
     * roughly corresponds to a phase in effect processing.  The effect
     * metadata should be in the following form:
     *
     *     {
     *       fn: effectFunction, // Reference to function to call to perform effect
     *       info: { ... }       // Effect metadata passed to function
     *       trigger: {          // Optional triggering metadata; if not provided
     *         name: string      // the property is treated as a wildcard
     *         structured: boolean
     *         wildcard: boolean
     *       }
     *     }
     *
     * Effects are called from `_propertiesChanged` in the following order by
     * type:
     *
     * 1. COMPUTE
     * 2. PROPAGATE
     * 3. REFLECT
     * 4. OBSERVE
     * 5. NOTIFY
     *
     * Effect functions are called with the following signature:
     *
     *     effectFunction(inst, path, props, oldProps, info, hasPaths)
     *
     * @param {string} property Property that should trigger the effect
     * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
     * @param {Object=} effect Effect metadata object
     * @return {void}
     * @protected
     * @nocollapse
     */
    static addPropertyEffect(i, r, o) {
      this.prototype._addPropertyEffect(i, r, o);
    }
    /**
     * Creates a single-property observer for the given property.
     *
     * @param {string} property Property name
     * @param {string|function(*,*)} method Function or name of observer method to call
     * @param {boolean=} dynamicFn Whether the method name should be included as
     *   a dependency to the effect.
     * @return {void}
     * @protected
     * @nocollapse
     */
    static createPropertyObserver(i, r, o) {
      this.prototype._createPropertyObserver(i, r, o);
    }
    /**
     * Creates a multi-property "method observer" based on the provided
     * expression, which should be a string in the form of a normal JavaScript
     * function signature: `'methodName(arg1, [..., argn])'`.  Each argument
     * should correspond to a property or path in the context of this
     * prototype (or instance), or may be a literal string or number.
     *
     * @param {string} expression Method expression
     * @param {boolean|Object=} dynamicFn Boolean or object map indicating
     * @return {void}
     *   whether method names should be included as a dependency to the effect.
     * @protected
     * @nocollapse
     */
    static createMethodObserver(i, r) {
      this.prototype._createMethodObserver(i, r);
    }
    /**
     * Causes the setter for the given property to dispatch `<property>-changed`
     * events to notify of changes to the property.
     *
     * @param {string} property Property name
     * @return {void}
     * @protected
     * @nocollapse
     */
    static createNotifyingProperty(i) {
      this.prototype._createNotifyingProperty(i);
    }
    /**
     * Creates a read-only accessor for the given property.
     *
     * To set the property, use the protected `_setProperty` API.
     * To create a custom protected setter (e.g. `_setMyProp()` for
     * property `myProp`), pass `true` for `protectedSetter`.
     *
     * Note, if the property will have other property effects, this method
     * should be called first, before adding other effects.
     *
     * @param {string} property Property name
     * @param {boolean=} protectedSetter Creates a custom protected setter
     *   when `true`.
     * @return {void}
     * @protected
     * @nocollapse
     */
    static createReadOnlyProperty(i, r) {
      this.prototype._createReadOnlyProperty(i, r);
    }
    /**
     * Causes the setter for the given property to reflect the property value
     * to a (dash-cased) attribute of the same name.
     *
     * @param {string} property Property name
     * @return {void}
     * @protected
     * @nocollapse
     */
    static createReflectedProperty(i) {
      this.prototype._createReflectedProperty(i);
    }
    /**
     * Creates a computed property whose value is set to the result of the
     * method described by the given `expression` each time one or more
     * arguments to the method changes.  The expression should be a string
     * in the form of a normal JavaScript function signature:
     * `'methodName(arg1, [..., argn])'`
     *
     * @param {string} property Name of computed property to set
     * @param {string} expression Method expression
     * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether
     *   method names should be included as a dependency to the effect.
     * @return {void}
     * @protected
     * @nocollapse
     */
    static createComputedProperty(i, r, o) {
      this.prototype._createComputedProperty(i, r, o);
    }
    /**
     * Parses the provided template to ensure binding effects are created
     * for them, and then ensures property accessors are created for any
     * dependent properties in the template.  Binding effects for bound
     * templates are stored in a linked list on the instance so that
     * templates can be efficiently stamped and unstamped.
     *
     * @param {!HTMLTemplateElement} template Template containing binding
     *   bindings
     * @return {!TemplateInfo} Template metadata object
     * @protected
     * @nocollapse
     */
    static bindTemplate(i) {
      return this.prototype._bindTemplate(i);
    }
    // -- binding ----------------------------------------------
    /*
     * Overview of binding flow:
     *
     * During finalization (`instanceBinding==false`, `wasPreBound==false`):
     *  `_bindTemplate(t, false)` called directly during finalization - parses
     *  the template (for the first time), and then assigns that _prototypical_
     *  template info to `__preboundTemplateInfo` _on the prototype_; note in
     *  this case `wasPreBound` is false; this is the first time we're binding
     *  it, thus we create accessors.
     *
     * During first stamping (`instanceBinding==true`, `wasPreBound==true`):
     *   `_stampTemplate` calls `_bindTemplate(t, true)`: the `templateInfo`
     *   returned matches the prebound one, and so this is `wasPreBound == true`
     *   state; thus we _skip_ creating accessors, but _do_ create an instance
     *   of the template info to serve as the start of our linked list (needs to
     *   be an instance, not the prototypical one, so that we can add `nodeList`
     *   to it to contain the `nodeInfo`-ordered list of instance nodes for
     *   bindings, and so we can chain runtime-stamped template infos off of
     *   it). At this point, the call to `_stampTemplate` calls
     *   `applyTemplateInfo` for each nested `<template>` found during parsing
     *   to hand prototypical `_templateInfo` to them; we also pass the _parent_
     *   `templateInfo` to the `<template>` so that we have the instance-time
     *   parent to link the `templateInfo` under in the case it was
     *   runtime-stamped.
     *
     * During subsequent runtime stamping (`instanceBinding==true`,
     *   `wasPreBound==false`): `_stampTemplate` calls `_bindTemplate(t, true)`
     *   - here `templateInfo` is guaranteed to _not_ match the prebound one,
     *   because it was either a different template altogether, or even if it
     *   was the same template, the step above created a instance of the info;
     *   in this case `wasPreBound == false`, so we _do_ create accessors, _and_
     *   link a instance into the linked list.
     */
    /**
     * Equivalent to static `bindTemplate` API but can be called on an instance
     * to add effects at runtime.  See that method for full API docs.
     *
     * This method may be called on the prototype (for prototypical template
     * binding, to avoid creating accessors every instance) once per prototype,
     * and will be called with `runtimeBinding: true` by `_stampTemplate` to
     * create and link an instance of the template metadata associated with a
     * particular stamping.
     *
     * @override
     * @param {!HTMLTemplateElement} template Template containing binding
     * bindings
     * @param {boolean=} instanceBinding When false (default), performs
     * "prototypical" binding of the template and overwrites any previously
     * bound template for the class. When true (as passed from
     * `_stampTemplate`), the template info is instanced and linked into the
     * list of bound templates.
     * @return {!TemplateInfo} Template metadata object; for `runtimeBinding`,
     * this is an instance of the prototypical template info
     * @protected
     * @suppress {missingProperties} go/missingfnprops
     */
    _bindTemplate(i, r) {
      let o = this.constructor._parseTemplate(i), a = this.__preBoundTemplateInfo == o;
      if (!a)
        for (let c in o.propertyEffects)
          this._createPropertyAccessor(c);
      if (r)
        if (o = /** @type {!TemplateInfo} */
        Object.create(o), o.wasPreBound = a, !this.__templateInfo)
          this.__templateInfo = o;
        else {
          const c = i._parentTemplateInfo || this.__templateInfo, u = c.lastChild;
          o.parent = c, c.lastChild = o, o.previousSibling = u, u ? u.nextSibling = o : c.firstChild = o;
        }
      else
        this.__preBoundTemplateInfo = o;
      return o;
    }
    /**
     * Adds a property effect to the given template metadata, which is run
     * at the "propagate" stage of `_propertiesChanged` when the template
     * has been bound to the element via `_bindTemplate`.
     *
     * The `effect` object should match the format in `_addPropertyEffect`.
     *
     * @param {Object} templateInfo Template metadata to add effect to
     * @param {string} prop Property that should trigger the effect
     * @param {Object=} effect Effect metadata object
     * @return {void}
     * @protected
     * @nocollapse
     */
    static _addTemplatePropertyEffect(i, r, o) {
      let a = i.hostProps = i.hostProps || {};
      a[r] = !0;
      let c = i.propertyEffects = i.propertyEffects || {};
      (c[r] = c[r] || []).push(o);
    }
    /**
     * Stamps the provided template and performs instance-time setup for
     * Polymer template features, including data bindings, declarative event
     * listeners, and the `this.$` map of `id`'s to nodes.  A document fragment
     * is returned containing the stamped DOM, ready for insertion into the
     * DOM.
     *
     * This method may be called more than once; however note that due to
     * `shadycss` polyfill limitations, only styles from templates prepared
     * using `ShadyCSS.prepareTemplate` will be correctly polyfilled (scoped
     * to the shadow root and support CSS custom properties), and note that
     * `ShadyCSS.prepareTemplate` may only be called once per element. As such,
     * any styles required by in runtime-stamped templates must be included
     * in the main element template.
     *
     * @param {!HTMLTemplateElement} template Template to stamp
     * @param {TemplateInfo=} templateInfo Optional bound template info associated
     *   with the template to be stamped; if omitted the template will be
     *   automatically bound.
     * @return {!StampedTemplate} Cloned template content
     * @override
     * @protected
     */
    _stampTemplate(i, r) {
      r = r || /** @type {!TemplateInfo} */
      this._bindTemplate(i, !0), rr.push(this);
      let o = super._stampTemplate(i, r);
      if (rr.pop(), r.nodeList = o.nodeList, !r.wasPreBound) {
        let a = r.childNodes = [];
        for (let c = o.firstChild; c; c = c.nextSibling)
          a.push(c);
      }
      return o.templateInfo = r, Ld(this, r), this.__dataClientsReady && (this._runEffectsForTemplate(r, this.__data, null, !1), this._flushClients()), o;
    }
    /**
     * Removes and unbinds the nodes previously contained in the provided
     * DocumentFragment returned from `_stampTemplate`.
     *
     * @override
     * @param {!StampedTemplate} dom DocumentFragment previously returned
     *   from `_stampTemplate` associated with the nodes to be removed
     * @return {void}
     * @protected
     */
    _removeBoundDom(i) {
      const r = i.templateInfo, { previousSibling: o, nextSibling: a, parent: c } = r;
      o ? o.nextSibling = a : c && (c.firstChild = a), a ? a.previousSibling = o : c && (c.lastChild = o), r.nextSibling = r.previousSibling = null;
      let u = r.childNodes;
      for (let h = 0; h < u.length; h++) {
        let f = u[h];
        ci(ci(f).parentNode).removeChild(f);
      }
    }
    /**
     * Overrides default `TemplateStamp` implementation to add support for
     * parsing bindings from `TextNode`'s' `textContent`.  A `bindings`
     * array is added to `nodeInfo` and populated with binding metadata
     * with information capturing the binding target, and a `parts` array
     * with one or more metadata objects capturing the source(s) of the
     * binding.
     *
     * @param {Node} node Node to parse
     * @param {TemplateInfo} templateInfo Template metadata for current template
     * @param {NodeInfo} nodeInfo Node metadata for current template node
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     * @protected
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     * @nocollapse
     */
    static _parseTemplateNode(i, r, o) {
      let a = n._parseTemplateNode.call(
        this,
        i,
        r,
        o
      );
      if (i.nodeType === Node.TEXT_NODE) {
        let c = this._parseBindings(i.textContent, r);
        c && (i.textContent = ka(c) || " ", mo(this, r, o, "text", "textContent", c), a = !0);
      }
      return a;
    }
    /**
     * Overrides default `TemplateStamp` implementation to add support for
     * parsing bindings from attributes.  A `bindings`
     * array is added to `nodeInfo` and populated with binding metadata
     * with information capturing the binding target, and a `parts` array
     * with one or more metadata objects capturing the source(s) of the
     * binding.
     *
     * @param {Element} node Node to parse
     * @param {TemplateInfo} templateInfo Template metadata for current template
     * @param {NodeInfo} nodeInfo Node metadata for current template node
     * @param {string} name Attribute name
     * @param {string} value Attribute value
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     * @protected
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     * @nocollapse
     */
    static _parseTemplateNodeAttribute(i, r, o, a, c) {
      let u = this._parseBindings(c, r);
      if (u) {
        let h = a, f = "property";
        yd.test(a) ? f = "attribute" : a[a.length - 1] == "$" && (a = a.slice(0, -1), f = "attribute");
        let g = ka(u);
        return g && f == "attribute" && (a == "class" && i.hasAttribute("class") && (g += " " + i.getAttribute(a)), i.setAttribute(a, g)), f == "attribute" && h == "disable-upgrade$" && i.setAttribute(a, ""), i.localName === "input" && h === "value" && i.setAttribute(h, ""), i.removeAttribute(h), f === "property" && (a = yl(a)), mo(this, r, o, f, a, u, g), !0;
      } else
        return n._parseTemplateNodeAttribute.call(
          this,
          i,
          r,
          o,
          a,
          c
        );
    }
    /**
     * Overrides default `TemplateStamp` implementation to add support for
     * binding the properties that a nested template depends on to the template
     * as `_host_<property>`.
     *
     * @param {Node} node Node to parse
     * @param {TemplateInfo} templateInfo Template metadata for current template
     * @param {NodeInfo} nodeInfo Node metadata for current template node
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     * @protected
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     * @nocollapse
     */
    static _parseTemplateNestedTemplate(i, r, o) {
      let a = n._parseTemplateNestedTemplate.call(
        this,
        i,
        r,
        o
      );
      const c = i.parentNode, u = o.templateInfo, h = c.localName === "dom-if", f = c.localName === "dom-repeat";
      ga && (h || f) && (c.removeChild(i), o = o.parentInfo, o.templateInfo = u, o.noted = !0, a = !1);
      let g = u.hostProps;
      if (ju && h)
        g && (r.hostProps = Object.assign(r.hostProps || {}, g), ga || (o.parentInfo.noted = !0));
      else {
        let x = "{";
        for (let C in g) {
          let E = [{ mode: x, source: C, dependencies: [C], hostProp: !0 }];
          mo(this, r, o, "property", "_host_" + C, E);
        }
      }
      return a;
    }
    /**
     * Called to parse text in a template (either attribute values or
     * textContent) into binding metadata.
     *
     * Any overrides of this method should return an array of binding part
     * metadata  representing one or more bindings found in the provided text
     * and any "literal" text in between.  Any non-literal parts will be passed
     * to `_evaluateBinding` when any dependencies change.  The only required
     * fields of each "part" in the returned array are as follows:
     *
     * - `dependencies` - Array containing trigger metadata for each property
     *   that should trigger the binding to update
     * - `literal` - String containing text if the part represents a literal;
     *   in this case no `dependencies` are needed
     *
     * Additional metadata for use by `_evaluateBinding` may be provided in
     * each part object as needed.
     *
     * The default implementation handles the following types of bindings
     * (one or more may be intermixed with literal strings):
     * - Property binding: `[[prop]]`
     * - Path binding: `[[object.prop]]`
     * - Negated property or path bindings: `[[!prop]]` or `[[!object.prop]]`
     * - Two-way property or path bindings (supports negation):
     *   `{{prop}}`, `{{object.prop}}`, `{{!prop}}` or `{{!object.prop}}`
     * - Inline computed method (supports negation):
     *   `[[compute(a, 'literal', b)]]`, `[[!compute(a, 'literal', b)]]`
     *
     * The default implementation uses a regular expression for best
     * performance. However, the regular expression uses a white-list of
     * allowed characters in a data-binding, which causes problems for
     * data-bindings that do use characters not in this white-list.
     *
     * Instead of updating the white-list with all allowed characters,
     * there is a StrictBindingParser (see lib/mixins/strict-binding-parser)
     * that uses a state machine instead. This state machine is able to handle
     * all characters. However, it is slightly less performant, therefore we
     * extracted it into a separate optional mixin.
     *
     * @param {string} text Text to parse from attribute or textContent
     * @param {Object} templateInfo Current template metadata
     * @return {Array<!BindingPart>} Array of binding part metadata
     * @protected
     * @nocollapse
     */
    static _parseBindings(i, r) {
      let o = [], a = 0, c;
      for (; (c = Sa.exec(i)) !== null; ) {
        c.index > a && o.push({ literal: i.slice(a, c.index) });
        let u = c[1][0], h = !!c[2], f = c[3].trim(), g = !1, x = "", C = -1;
        u == "{" && (C = f.indexOf("::")) > 0 && (x = f.substring(C + 2), f = f.substring(0, C), g = !0);
        let E = vo(f), R = [];
        if (E) {
          let { args: D, methodName: U } = E;
          for (let ce = 0; ce < D.length; ce++) {
            let re = D[ce];
            re.literal || R.push(re);
          }
          let Z = r.dynamicFns;
          (Z && Z[U] || E.static) && (R.push(U), E.dynamicFn = !0);
        } else
          R.push(f);
        o.push({
          source: f,
          mode: u,
          negate: h,
          customEvent: g,
          signature: E,
          dependencies: R,
          event: x
        }), a = Sa.lastIndex;
      }
      if (a && a < i.length) {
        let u = i.substring(a);
        u && o.push({
          literal: u
        });
      }
      return o.length ? o : null;
    }
    /**
     * Called to evaluate a previously parsed binding part based on a set of
     * one or more changed dependencies.
     *
     * @param {!Polymer_PropertyEffects} inst Element that should be used as
     *     scope for binding dependencies
     * @param {BindingPart} part Binding part metadata
     * @param {string} path Property/path that triggered this effect
     * @param {Object} props Bag of current property changes
     * @param {Object} oldProps Bag of previous values for changed properties
     * @param {boolean} hasPaths True with `props` contains one or more paths
     * @return {*} Value the binding part evaluated to
     * @protected
     * @nocollapse
     */
    static _evaluateBinding(i, r, o, a, c, u) {
      let h;
      return r.signature ? h = Bo(i, o, a, c, r.signature) : o != r.source ? h = dt(i, r.source) : u && Mo(o) ? h = dt(i, o) : h = i.__data[o], r.negate && (h = !h), h;
    }
  }
  return e;
}), rr = [];
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
function th(s) {
  const n = {};
  for (let e in s) {
    const t = s[e];
    n[e] = typeof t == "function" ? { type: t } : t;
  }
  return n;
}
const ih = rt((s) => {
  const n = Cl(s);
  function e(r) {
    const o = Object.getPrototypeOf(r);
    return o.prototype instanceof i ? (
      /** @type {!PropertiesMixinConstructor} */
      o
    ) : null;
  }
  function t(r) {
    if (!r.hasOwnProperty(JSCompiler_renameProperty("__ownProperties", r))) {
      let o = null;
      if (r.hasOwnProperty(JSCompiler_renameProperty("properties", r))) {
        const a = r.properties;
        a && (o = th(a));
      }
      r.__ownProperties = o;
    }
    return r.__ownProperties;
  }
  class i extends n {
    /**
     * Implements standard custom elements getter to observes the attributes
     * listed in `properties`.
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     * @nocollapse
     */
    static get observedAttributes() {
      if (!this.hasOwnProperty(JSCompiler_renameProperty("__observedAttributes", this))) {
        this.prototype;
        const o = this._properties;
        this.__observedAttributes = o ? Object.keys(o).map((a) => this.prototype._addPropertyToAttributeMap(a)) : [];
      }
      return this.__observedAttributes;
    }
    /**
     * Finalizes an element definition, including ensuring any super classes
     * are also finalized. This includes ensuring property
     * accessors exist on the element prototype. This method calls
     * `_finalizeClass` to finalize each constructor in the prototype chain.
     * @return {void}
     * @nocollapse
     */
    static finalize() {
      if (!this.hasOwnProperty(JSCompiler_renameProperty("__finalized", this))) {
        const o = e(
          /** @type {!PropertiesMixinConstructor} */
          this
        );
        o && o.finalize(), this.__finalized = !0, this._finalizeClass();
      }
    }
    /**
     * Finalize an element class. This includes ensuring property
     * accessors exist on the element prototype. This method is called by
     * `finalize` and finalizes the class constructor.
     *
     * @protected
     * @nocollapse
     */
    static _finalizeClass() {
      const o = t(
        /** @type {!PropertiesMixinConstructor} */
        this
      );
      o && this.createProperties(o);
    }
    /**
     * Returns a memoized version of all properties, including those inherited
     * from super classes. Properties not in object format are converted to
     * at least {type}.
     *
     * @return {Object} Object containing properties for this class
     * @protected
     * @nocollapse
     */
    static get _properties() {
      if (!this.hasOwnProperty(
        JSCompiler_renameProperty("__properties", this)
      )) {
        const o = e(
          /** @type {!PropertiesMixinConstructor} */
          this
        );
        this.__properties = Object.assign(
          {},
          o && o._properties,
          t(
            /** @type {PropertiesMixinConstructor} */
            this
          )
        );
      }
      return this.__properties;
    }
    /**
     * Overrides `PropertiesChanged` method to return type specified in the
     * static `properties` object for the given property.
     * @param {string} name Name of property
     * @return {*} Type to which to deserialize attribute
     *
     * @protected
     * @nocollapse
     */
    static typeForProperty(o) {
      const a = this._properties[o];
      return a && a.type;
    }
    /**
     * Overrides `PropertiesChanged` method and adds a call to
     * `finalize` which lazily configures the element's property accessors.
     * @override
     * @return {void}
     */
    _initializeProperties() {
      this.constructor.finalize(), super._initializeProperties();
    }
    /**
     * Called when the element is added to a document.
     * Calls `_enableProperties` to turn on property system from
     * `PropertiesChanged`.
     * @suppress {missingProperties} Super may or may not implement the callback
     * @return {void}
     * @override
     */
    connectedCallback() {
      super.connectedCallback && super.connectedCallback(), this._enableProperties();
    }
    /**
     * Called when the element is removed from a document
     * @suppress {missingProperties} Super may or may not implement the callback
     * @return {void}
     * @override
     */
    disconnectedCallback() {
      super.disconnectedCallback && super.disconnectedCallback();
    }
  }
  return i;
});
/**
 * @fileoverview
 * @suppress {checkPrototypalTypes}
 * @license Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt The complete set of authors may be found
 * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may
 * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by
 * Google as part of the polymer project is also subject to an additional IP
 * rights grant found at http://polymer.github.io/PATENTS.txt
 */
const rh = "3.5.1", Aa = window.ShadyCSS && window.ShadyCSS.cssBuild, nh = rt((s) => {
  const n = ih(eh(s));
  function e(c) {
    if (!c.hasOwnProperty(
      JSCompiler_renameProperty("__propertyDefaults", c)
    )) {
      c.__propertyDefaults = null;
      let u = c._properties;
      for (let h in u) {
        let f = u[h];
        "value" in f && (c.__propertyDefaults = c.__propertyDefaults || {}, c.__propertyDefaults[h] = f);
      }
    }
    return c.__propertyDefaults;
  }
  function t(c) {
    return c.hasOwnProperty(
      JSCompiler_renameProperty("__ownObservers", c)
    ) || (c.__ownObservers = c.hasOwnProperty(
      JSCompiler_renameProperty("observers", c)
    ) ? (
      /** @type {PolymerElementConstructor} */
      c.observers
    ) : null), c.__ownObservers;
  }
  function i(c, u, h, f) {
    h.computed && (h.readOnly = !0), h.computed && (c._hasReadOnlyEffect(u) ? console.warn(`Cannot redefine computed property '${u}'.`) : c._createComputedProperty(u, h.computed, f)), h.readOnly && !c._hasReadOnlyEffect(u) ? c._createReadOnlyProperty(u, !h.computed) : h.readOnly === !1 && c._hasReadOnlyEffect(u) && console.warn(`Cannot make readOnly property '${u}' non-readOnly.`), h.reflectToAttribute && !c._hasReflectEffect(u) ? c._createReflectedProperty(u) : h.reflectToAttribute === !1 && c._hasReflectEffect(u) && console.warn(`Cannot make reflected property '${u}' non-reflected.`), h.notify && !c._hasNotifyEffect(u) ? c._createNotifyingProperty(u) : h.notify === !1 && c._hasNotifyEffect(u) && console.warn(`Cannot make notify property '${u}' non-notify.`), h.observer && c._createPropertyObserver(u, h.observer, f[h.observer]), c._addPropertyToAttributeMap(u);
  }
  function r(c, u, h, f) {
    if (!Aa) {
      const g = u.content.querySelectorAll("style"), x = vl(u), C = Ju(h), E = u.content.firstElementChild;
      for (let D = 0; D < C.length; D++) {
        let U = C[D];
        U.textContent = c._processStyleText(U.textContent, f), u.content.insertBefore(U, E);
      }
      let R = 0;
      for (let D = 0; D < x.length; D++) {
        let U = x[D], Z = g[R];
        Z !== U ? (U = U.cloneNode(!0), Z.parentNode.insertBefore(U, Z)) : R++, U.textContent = c._processStyleText(U.textContent, f);
      }
    }
    if (window.ShadyCSS && window.ShadyCSS.prepareTemplate(u, h), Gu && Aa && Lu) {
      const g = u.content.querySelectorAll("style");
      if (g) {
        let x = "";
        Array.from(g).forEach((C) => {
          x += C.textContent, C.parentNode.removeChild(C);
        }), c._styleSheet = new CSSStyleSheet(), c._styleSheet.replaceSync(x);
      }
    }
  }
  function o(c) {
    let u = null;
    if (c && (!zo || Nu) && (u = /** @type {?HTMLTemplateElement} */
    gr.import(c, "template"), zo && !u))
      throw new Error(`strictTemplatePolicy: expecting dom-module or null template for ${c}`);
    return u;
  }
  class a extends n {
    /**
     * Current Polymer version in Semver notation.
     * @type {string} Semver notation of the current version of Polymer.
     * @nocollapse
     */
    static get polymerElementVersion() {
      return rh;
    }
    /**
     * Override of PropertiesMixin _finalizeClass to create observers and
     * find the template.
     * @return {void}
     * @protected
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     * @nocollapse
     */
    static _finalizeClass() {
      n._finalizeClass.call(this);
      const u = t(this);
      u && this.createObservers(u, this._properties), this._prepareTemplate();
    }
    /** @nocollapse */
    static _prepareTemplate() {
      let u = (
        /** @type {PolymerElementConstructor} */
        this.template
      );
      u && (typeof u == "string" ? (console.error("template getter must return HTMLTemplateElement"), u = null) : Hu || (u = u.cloneNode(!0))), this.prototype._template = u;
    }
    /**
     * Override of PropertiesChanged createProperties to create accessors
     * and property effects for all of the properties.
     * @param {!Object} props .
     * @return {void}
     * @protected
     * @nocollapse
     */
    static createProperties(u) {
      for (let h in u)
        i(
          /** @type {?} */
          this.prototype,
          h,
          u[h],
          u
        );
    }
    /**
     * Creates observers for the given `observers` array.
     * Leverages `PropertyEffects` to create observers.
     * @param {Object} observers Array of observer descriptors for
     *   this class
     * @param {Object} dynamicFns Object containing keys for any properties
     *   that are functions and should trigger the effect when the function
     *   reference is changed
     * @return {void}
     * @protected
     * @nocollapse
     */
    static createObservers(u, h) {
      const f = this.prototype;
      for (let g = 0; g < u.length; g++)
        f._createMethodObserver(u[g], h);
    }
    /**
     * Returns the template that will be stamped into this element's shadow root.
     *
     * If a `static get is()` getter is defined, the default implementation will
     * return the first `<template>` in a `dom-module` whose `id` matches this
     * element's `is` (note that a `_template` property on the class prototype
     * takes precedence over the `dom-module` template, to maintain legacy
     * element semantics; a subclass will subsequently fall back to its super
     * class template if neither a `prototype._template` or a `dom-module` for
     * the class's `is` was found).
     *
     * Users may override this getter to return an arbitrary template
     * (in which case the `is` getter is unnecessary). The template returned
     * must be an `HTMLTemplateElement`.
     *
     * Note that when subclassing, if the super class overrode the default
     * implementation and the subclass would like to provide an alternate
     * template via a `dom-module`, it should override this getter and
     * return `DomModule.import(this.is, 'template')`.
     *
     * If a subclass would like to modify the super class template, it should
     * clone it rather than modify it in place.  If the getter does expensive
     * work such as cloning/modifying a template, it should memoize the
     * template for maximum performance:
     *
     *   let memoizedTemplate;
     *   class MySubClass extends MySuperClass {
     *     static get template() {
     *       if (!memoizedTemplate) {
     *         memoizedTemplate = super.template.cloneNode(true);
     *         let subContent = document.createElement('div');
     *         subContent.textContent = 'This came from MySubClass';
     *         memoizedTemplate.content.appendChild(subContent);
     *       }
     *       return memoizedTemplate;
     *     }
     *   }
     *
     * @return {!HTMLTemplateElement|string} Template to be stamped
     * @nocollapse
     */
    static get template() {
      if (!this.hasOwnProperty(JSCompiler_renameProperty("_template", this))) {
        let u = this.prototype.hasOwnProperty(
          JSCompiler_renameProperty("_template", this.prototype)
        ) ? this.prototype._template : void 0;
        typeof u == "function" && (u = u()), this._template = // If user has put template on prototype (e.g. in legacy via registered
        // callback or info object), prefer that first. Note that `null` is
        // used as a sentinel to indicate "no template" and can be used to
        // override a super template, whereas `undefined` is used as a
        // sentinel to mean "fall-back to default template lookup" via
        // dom-module and/or super.template.
        u !== void 0 ? u : (
          // Look in dom-module associated with this element's is
          this.hasOwnProperty(JSCompiler_renameProperty("is", this)) && o(
            /** @type {PolymerElementConstructor}*/
            this.is
          ) || // Next look for superclass template (call the super impl this
          // way so that `this` points to the superclass)
          Object.getPrototypeOf(
            /** @type {PolymerElementConstructor}*/
            this.prototype
          ).constructor.template
        );
      }
      return this._template;
    }
    /**
     * Set the template.
     *
     * @param {!HTMLTemplateElement|string} value Template to set.
     * @nocollapse
     */
    static set template(u) {
      this._template = u;
    }
    /**
     * Path matching the url from which the element was imported.
     *
     * This path is used to resolve url's in template style cssText.
     * The `importPath` property is also set on element instances and can be
     * used to create bindings relative to the import path.
     *
     * For elements defined in ES modules, users should implement
     * `static get importMeta() { return import.meta; }`, and the default
     * implementation of `importPath` will  return `import.meta.url`'s path.
     * For elements defined in HTML imports, this getter will return the path
     * to the document containing a `dom-module` element matching this
     * element's static `is` property.
     *
     * Note, this path should contain a trailing `/`.
     *
     * @return {string} The import path for this element class
     * @suppress {missingProperties}
     * @nocollapse
     */
    static get importPath() {
      if (!this.hasOwnProperty(JSCompiler_renameProperty("_importPath", this))) {
        const u = this.importMeta;
        if (u)
          this._importPath = ss(u.url);
        else {
          const h = gr.import(
            /** @type {PolymerElementConstructor} */
            this.is
          );
          this._importPath = h && h.assetpath || Object.getPrototypeOf(
            /** @type {PolymerElementConstructor}*/
            this.prototype
          ).constructor.importPath;
        }
      }
      return this._importPath;
    }
    constructor() {
      super(), this._template, this._importPath, this.rootPath, this.importPath, this.root, this.$;
    }
    /**
     * Overrides the default `PropertyAccessors` to ensure class
     * metaprogramming related to property accessors and effects has
     * completed (calls `finalize`).
     *
     * It also initializes any property defaults provided via `value` in
     * `properties` metadata.
     *
     * @return {void}
     * @override
     * @suppress {invalidCasts,missingProperties} go/missingfnprops
     */
    _initializeProperties() {
      this.constructor.finalize(), this.constructor._finalizeTemplate(
        /** @type {!HTMLElement} */
        this.localName
      ), super._initializeProperties(), this.rootPath = Bu, this.importPath = this.constructor.importPath;
      let u = e(this.constructor);
      if (u)
        for (let h in u) {
          let f = u[h];
          if (this._canApplyPropertyDefault(h)) {
            let g = typeof f.value == "function" ? f.value.call(this) : f.value;
            this._hasAccessor(h) ? this._setPendingProperty(h, g, !0) : this[h] = g;
          }
        }
    }
    /**
     * Determines if a property dfeault can be applied. For example, this
     * prevents a default from being applied when a property that has no
     * accessor is overridden by its host before upgrade (e.g. via a binding).
     * @override
     * @param {string} property Name of the property
     * @return {boolean} Returns true if the property default can be applied.
     */
    _canApplyPropertyDefault(u) {
      return !this.hasOwnProperty(u);
    }
    /**
     * Gather style text for a style element in the template.
     *
     * @param {string} cssText Text containing styling to process
     * @param {string} baseURI Base URI to rebase CSS paths against
     * @return {string} The processed CSS text
     * @protected
     * @nocollapse
     */
    static _processStyleText(u, h) {
      return os(u, h);
    }
    /**
    * Configures an element `proto` to function with a given `template`.
    * The element name `is` and extends `ext` must be specified for ShadyCSS
    * style scoping.
    *
    * @param {string} is Tag name (or type extension name) for this element
    * @return {void}
    * @protected
    * @nocollapse
    */
    static _finalizeTemplate(u) {
      const h = this.prototype._template;
      if (h && !h.__polymerFinalized) {
        h.__polymerFinalized = !0;
        const f = this.importPath, g = f ? ur(f) : "";
        r(this, h, u, g), this.prototype._bindTemplate(h);
      }
    }
    /**
     * Provides a default implementation of the standard Custom Elements
     * `connectedCallback`.
     *
     * The default implementation enables the property effects system and
     * flushes any pending properties, and updates shimmed CSS properties
     * when using the ShadyCSS scoping/custom properties polyfill.
     *
     * @override
     * @suppress {missingProperties, invalidCasts} Super may or may not
     *     implement the callback
     * @return {void}
     */
    connectedCallback() {
      window.ShadyCSS && this._template && window.ShadyCSS.styleElement(
        /** @type {!HTMLElement} */
        this
      ), super.connectedCallback();
    }
    /**
     * Stamps the element template.
     *
     * @return {void}
     * @override
     */
    ready() {
      this._template && (this.root = this._stampTemplate(this._template), this.$ = this.root.$), super.ready();
    }
    /**
     * Implements `PropertyEffects`'s `_readyClients` call. Attaches
     * element dom by calling `_attachDom` with the dom stamped from the
     * element's template via `_stampTemplate`. Note that this allows
     * client dom to be attached to the element prior to any observers
     * running.
     *
     * @return {void}
     * @override
     */
    _readyClients() {
      this._template && (this.root = this._attachDom(
        /** @type {StampedTemplate} */
        this.root
      )), super._readyClients();
    }
    /**
     * Attaches an element's stamped dom to itself. By default,
     * this method creates a `shadowRoot` and adds the dom to it.
     * However, this method may be overridden to allow an element
     * to put its dom in another location.
     *
     * @override
     * @throws {Error}
     * @suppress {missingReturn}
     * @param {StampedTemplate} dom to attach to the element.
     * @return {ShadowRoot} node to which the dom has been attached.
     */
    _attachDom(u) {
      const h = ci(this);
      if (h.attachShadow)
        return u ? (h.shadowRoot || (h.attachShadow({ mode: "open", shadyUpgradeFragment: u }), h.shadowRoot.appendChild(u), this.constructor._styleSheet && (h.shadowRoot.adoptedStyleSheets = [this.constructor._styleSheet])), Uu && window.ShadyDOM && window.ShadyDOM.flushInitial(h.shadowRoot), h.shadowRoot) : null;
      throw new Error("ShadowDOM not available. PolymerElement can create dom as children instead of in ShadowDOM by setting `this.root = this;` before `ready`.");
    }
    /**
     * When using the ShadyCSS scoping and custom property shim, causes all
     * shimmed styles in this element (and its subtree) to be updated
     * based on current custom property values.
     *
     * The optional parameter overrides inline custom property styles with an
     * object of properties where the keys are CSS properties, and the values
     * are strings.
     *
     * Example: `this.updateStyles({'--color': 'blue'})`
     *
     * These properties are retained unless a value of `null` is set.
     *
     * Note: This function does not support updating CSS mixins.
     * You can not dynamically change the value of an `@apply`.
     *
     * @override
     * @param {Object=} properties Bag of custom property key/values to
     *   apply to this element.
     * @return {void}
     * @suppress {invalidCasts}
     */
    updateStyles(u) {
      window.ShadyCSS && window.ShadyCSS.styleSubtree(
        /** @type {!HTMLElement} */
        this,
        u
      );
    }
    /**
     * Rewrites a given URL relative to a base URL. The base URL defaults to
     * the original location of the document containing the `dom-module` for
     * this element. This method will return the same URL before and after
     * bundling.
     *
     * Note that this function performs no resolution for URLs that start
     * with `/` (absolute URLs) or `#` (hash identifiers).  For general purpose
     * URL resolution, use `window.URL`.
     *
     * @override
     * @param {string} url URL to resolve.
     * @param {string=} base Optional base URL to resolve against, defaults
     * to the element's `importPath`
     * @return {string} Rewritten URL relative to base
     */
    resolveUrl(u, h) {
      return !h && this.importPath && (h = ur(this.importPath)), ur(u, h);
    }
    /**
     * Overrides `PropertyEffects` to add map of dynamic functions on
     * template info, for consumption by `PropertyEffects` template binding
     * code. This map determines which method templates should have accessors
     * created for them.
     *
     * @param {!HTMLTemplateElement} template Template
     * @param {!TemplateInfo} templateInfo Template metadata for current template
     * @param {!NodeInfo} nodeInfo Node metadata for current template.
     * @return {boolean} .
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     * @nocollapse
     */
    static _parseTemplateContent(u, h, f) {
      return h.dynamicFns = h.dynamicFns || this._properties, n._parseTemplateContent.call(
        this,
        u,
        h,
        f
      );
    }
    /**
     * Overrides `PropertyEffects` to warn on use of undeclared properties in
     * template.
     *
     * @param {Object} templateInfo Template metadata to add effect to
     * @param {string} prop Property that should trigger the effect
     * @param {Object=} effect Effect metadata object
     * @return {void}
     * @protected
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     * @nocollapse
     */
    static _addTemplatePropertyEffect(u, h, f) {
      return Vu && !(h in this._properties) && // Methods used in templates with no dependencies (or only literal
      // dependencies) become accessors with template effects; ignore these
      !(f.info.part.signature && f.info.part.signature.static) && // Warnings for bindings added to nested templates are handled by
      // templatizer so ignore both the host-to-template bindings
      // (`hostProp`) and TemplateInstance-to-child bindings
      // (`nestedTemplate`)
      !f.info.part.hostProp && !u.nestedTemplate && console.warn(`Property '${h}' used in template but not declared in 'properties'; attribute will not be observed.`), n._addTemplatePropertyEffect.call(
        this,
        u,
        h,
        f
      );
    }
  }
  return a;
});
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const Ia = window.trustedTypes && trustedTypes.createPolicy("polymer-html-literal", { createHTML: (s) => s });
class Dl {
  /**
   * @param {!ITemplateArray} strings Constant parts of tagged template literal
   * @param {!Array<*>} values Variable parts of tagged template literal
   */
  constructor(n, e) {
    zl(n, e);
    const t = e.reduce(
      (i, r, o) => i + Ol(r) + n[o + 1],
      n[0]
    );
    this.value = t.toString();
  }
  /**
   * @return {string} LiteralString string value
   * @override
   */
  toString() {
    return this.value;
  }
}
function Ol(s) {
  if (s instanceof Dl)
    return (
      /** @type {!LiteralString} */
      s.value
    );
  throw new Error(
    `non-literal value passed to Polymer's htmlLiteral function: ${s}`
  );
}
function oh(s) {
  if (s instanceof HTMLTemplateElement)
    return (
      /** @type {!HTMLTemplateElement } */
      s.innerHTML
    );
  if (s instanceof Dl)
    return Ol(s);
  throw new Error(
    `non-template value passed to Polymer's html function: ${s}`
  );
}
const Vi = function(n, ...e) {
  zl(n, e);
  const t = (
    /** @type {!HTMLTemplateElement} */
    document.createElement("template")
  );
  let i = e.reduce(
    (r, o, a) => r + oh(o) + n[a + 1],
    n[0]
  );
  return Ia && (i = Ia.createHTML(i)), t.innerHTML = i, t;
}, zl = (s, n) => {
  if (!Array.isArray(s) || !Array.isArray(s.raw) || n.length !== s.length - 1)
    throw new TypeError("Invalid call to the html template tag");
};
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const mi = nh(HTMLElement);
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
let Da = 0, Fl = 0;
const Oi = [];
let No = !1;
function sh() {
  No = !1;
  const s = Oi.length;
  for (let n = 0; n < s; n++) {
    const e = Oi[n];
    if (e)
      try {
        e();
      } catch (t) {
        setTimeout(() => {
          throw t;
        });
      }
  }
  Oi.splice(0, s), Fl += s;
}
const zt = {
  /**
   * Returns a sub-module with the async interface providing the provided
   * delay.
   *
   * @memberof timeOut
   * @param {number=} delay Time to wait before calling callbacks in ms
   * @return {!AsyncInterface} An async timeout interface
   */
  after(s) {
    return {
      run(n) {
        return window.setTimeout(n, s);
      },
      cancel(n) {
        window.clearTimeout(n);
      }
    };
  },
  /**
   * Enqueues a function called in the next task.
   *
   * @memberof timeOut
   * @param {!Function} fn Callback to run
   * @param {number=} delay Delay in milliseconds
   * @return {number} Handle used for canceling task
   */
  run(s, n) {
    return window.setTimeout(s, n);
  },
  /**
   * Cancels a previously enqueued `timeOut` callback.
   *
   * @memberof timeOut
   * @param {number} handle Handle returned from `run` of callback to cancel
   * @return {void}
   */
  cancel(s) {
    window.clearTimeout(s);
  }
}, qt = {
  /**
   * Enqueues a function called at `requestAnimationFrame` timing.
   *
   * @memberof animationFrame
   * @param {function(number):void} fn Callback to run
   * @return {number} Handle used for canceling task
   */
  run(s) {
    return window.requestAnimationFrame(s);
  },
  /**
   * Cancels a previously enqueued `animationFrame` callback.
   *
   * @memberof animationFrame
   * @param {number} handle Handle returned from `run` of callback to cancel
   * @return {void}
   */
  cancel(s) {
    window.cancelAnimationFrame(s);
  }
}, Ml = {
  /**
   * Enqueues a function called at `requestIdleCallback` timing.
   *
   * @memberof idlePeriod
   * @param {function(!IdleDeadline):void} fn Callback to run
   * @return {number} Handle used for canceling task
   */
  run(s) {
    return window.requestIdleCallback ? window.requestIdleCallback(s) : window.setTimeout(s, 16);
  },
  /**
   * Cancels a previously enqueued `idlePeriod` callback.
   *
   * @memberof idlePeriod
   * @param {number} handle Handle returned from `run` of callback to cancel
   * @return {void}
   */
  cancel(s) {
    window.cancelIdleCallback ? window.cancelIdleCallback(s) : window.clearTimeout(s);
  }
}, yt = {
  /**
   * Enqueues a function called at microtask timing.
   *
   * @memberof microTask
   * @param {!Function=} callback Callback to run
   * @return {number} Handle used for canceling task
   */
  run(s) {
    No || (No = !0, queueMicrotask(() => sh())), Oi.push(s);
    const n = Da;
    return Da += 1, n;
  },
  /**
   * Cancels a previously enqueued `microTask` callback.
   *
   * @memberof microTask
   * @param {number} handle Handle returned from `run` of callback to cancel
   * @return {void}
   */
  cancel(s) {
    const n = s - Fl;
    if (n >= 0) {
      if (!Oi[n])
        throw new Error(`invalid async handle: ${s}`);
      Oi[n] = null;
    }
  }
};
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const _r = /* @__PURE__ */ new Set();
class Me {
  /**
   * Creates a debouncer if no debouncer is passed as a parameter
   * or it cancels an active debouncer otherwise. The following
   * example shows how a debouncer can be called multiple times within a
   * microtask and "debounced" such that the provided callback function is
   * called once. Add this method to a custom element:
   *
   * ```js
   * import {microTask} from '@vaadin/component-base/src/async.js';
   * import {Debouncer} from '@vaadin/component-base/src/debounce.js';
   * // ...
   *
   * _debounceWork() {
   *   this._debounceJob = Debouncer.debounce(this._debounceJob,
   *       microTask, () => this._doWork());
   * }
   * ```
   *
   * If the `_debounceWork` method is called multiple times within the same
   * microtask, the `_doWork` function will be called only once at the next
   * microtask checkpoint.
   *
   * Note: In testing it is often convenient to avoid asynchrony. To accomplish
   * this with a debouncer, you can use `enqueueDebouncer` and
   * `flush`. For example, extend the above example by adding
   * `enqueueDebouncer(this._debounceJob)` at the end of the
   * `_debounceWork` method. Then in a test, call `flush` to ensure
   * the debouncer has completed.
   *
   * @param {Debouncer?} debouncer Debouncer object.
   * @param {!AsyncInterface} asyncModule Object with Async interface
   * @param {function()} callback Callback to run.
   * @return {!Debouncer} Returns a debouncer object.
   */
  static debounce(n, e, t) {
    return n instanceof Me ? n._cancelAsync() : n = new Me(), n.setConfig(e, t), n;
  }
  constructor() {
    this._asyncModule = null, this._callback = null, this._timer = null;
  }
  /**
   * Sets the scheduler; that is, a module with the Async interface,
   * a callback and optional arguments to be passed to the run function
   * from the async module.
   *
   * @param {!AsyncInterface} asyncModule Object with Async interface.
   * @param {function()} callback Callback to run.
   * @return {void}
   */
  setConfig(n, e) {
    this._asyncModule = n, this._callback = e, this._timer = this._asyncModule.run(() => {
      this._timer = null, _r.delete(this), this._callback();
    });
  }
  /**
   * Cancels an active debouncer and returns a reference to itself.
   *
   * @return {void}
   */
  cancel() {
    this.isActive() && (this._cancelAsync(), _r.delete(this));
  }
  /**
   * Cancels a debouncer's async callback.
   *
   * @return {void}
   */
  _cancelAsync() {
    this.isActive() && (this._asyncModule.cancel(
      /** @type {number} */
      this._timer
    ), this._timer = null);
  }
  /**
   * Flushes an active debouncer and returns a reference to itself.
   *
   * @return {void}
   */
  flush() {
    this.isActive() && (this.cancel(), this._callback());
  }
  /**
   * Returns true if the debouncer is active.
   *
   * @return {boolean} True if active.
   */
  isActive() {
    return this._timer != null;
  }
}
function Ll(s) {
  _r.add(s);
}
function ah() {
  const s = !!_r.size;
  return _r.forEach((n) => {
    try {
      n.flush();
    } catch (e) {
      setTimeout(() => {
        throw e;
      });
    }
  }), s;
}
const lr = () => {
  let s;
  do
    s = ah();
  while (s);
};
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const It = [];
function Ho(s, n, e = s.getAttribute("dir")) {
  n ? s.setAttribute("dir", n) : e != null && s.removeAttribute("dir");
}
function Vo() {
  return document.documentElement.getAttribute("dir");
}
function lh() {
  const s = Vo();
  It.forEach((n) => {
    Ho(n, s);
  });
}
const ch = new MutationObserver(lh);
ch.observe(document.documentElement, { attributes: !0, attributeFilter: ["dir"] });
const Cr = (s) => class extends s {
  static get properties() {
    return {
      /**
       * @protected
       */
      dir: {
        type: String,
        value: "",
        reflectToAttribute: !0,
        converter: {
          fromAttribute: (e) => e || "",
          toAttribute: (e) => e === "" ? null : e
        }
      }
    };
  }
  /**
   * @return {boolean}
   * @protected
   */
  get __isRTL() {
    return this.getAttribute("dir") === "rtl";
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback(), (!this.hasAttribute("dir") || this.__restoreSubscription) && (this.__subscribe(), Ho(this, Vo(), null));
  }
  /** @protected */
  attributeChangedCallback(e, t, i) {
    if (super.attributeChangedCallback(e, t, i), e !== "dir")
      return;
    const r = Vo(), o = i === r && It.indexOf(this) === -1, a = !i && t && It.indexOf(this) === -1;
    o || a ? (this.__subscribe(), Ho(this, r, i)) : i !== r && t === r && this.__unsubscribe();
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback(), this.__restoreSubscription = It.includes(this), this.__unsubscribe();
  }
  /** @protected */
  _valueToNodeAttribute(e, t, i) {
    i === "dir" && t === "" && !e.hasAttribute("dir") || super._valueToNodeAttribute(e, t, i);
  }
  /** @protected */
  _attributeToProperty(e, t, i) {
    e === "dir" && !t ? this.dir = "" : super._attributeToProperty(e, t, i);
  }
  /** @private */
  __subscribe() {
    It.includes(this) || It.push(this);
  }
  /** @private */
  __unsubscribe() {
    It.includes(this) && It.splice(It.indexOf(this), 1);
  }
};
/**
 * @license
 * Copyright (c) 2023 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function pi(s, n) {
  return s.split(".").reduce((e, t) => e ? e[t] : void 0, n);
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function cs(s) {
  if (window.Vaadin && window.Vaadin.templateRendererCallback) {
    window.Vaadin.templateRendererCallback(s);
    return;
  }
  s.querySelector("template") && console.warn(
    `WARNING: <template> inside <${s.localName}> is no longer supported. Import @vaadin/polymer-legacy-adapter/template-renderer.js to enable compatibility.`
  );
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function uh(s) {
  const n = [];
  for (; s; ) {
    if (s.nodeType === Node.DOCUMENT_NODE) {
      n.push(s);
      break;
    }
    if (s.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
      n.push(s), s = s.host;
      continue;
    }
    if (s.assignedSlot) {
      s = s.assignedSlot;
      continue;
    }
    s = s.parentNode;
  }
  return n;
}
function Bl(s, n) {
  return n ? n.closest(s) || Bl(s, n.getRootNode().host) : null;
}
function us(s) {
  return s ? new Set(s.split(" ")) : /* @__PURE__ */ new Set();
}
function An(s) {
  return s ? [...s].join(" ") : "";
}
function In(s, n, e) {
  const t = us(s.getAttribute(n));
  t.add(e), s.setAttribute(n, An(t));
}
function ds(s, n, e) {
  const t = us(s.getAttribute(n));
  if (t.delete(e), t.size === 0) {
    s.removeAttribute(n);
    return;
  }
  s.setAttribute(n, An(t));
}
function dh(s) {
  return s.nodeType === Node.TEXT_NODE && s.textContent.trim() === "";
}
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function Li(s) {
  return s.__cells || Array.from(s.querySelectorAll('[part~="cell"]:not([part~="details-cell"])'));
}
function ht(s, n) {
  [...s.children].forEach(n);
}
function Bi(s, n) {
  Li(s).forEach(n), s.__detailsCell && n(s.__detailsCell);
}
function hh(s, n, e) {
  let t = 1;
  s.forEach((i) => {
    t % 10 === 0 && (t += 1), i._order = e + t * n, t += 1;
  });
}
function Dn(s, n, e) {
  switch (typeof e) {
    case "boolean":
      s.toggleAttribute(n, e);
      break;
    case "string":
      s.setAttribute(n, e);
      break;
    default:
      s.removeAttribute(n);
      break;
  }
}
function Kt(s, n, e) {
  n || n === "" ? In(s, "part", e) : ds(s, "part", e);
}
function jt(s, n, e) {
  s.forEach((t) => {
    Kt(t, e, n);
  });
}
function Ai(s, n) {
  const e = Li(s);
  Object.entries(n).forEach(([t, i]) => {
    Dn(s, t, i);
    const r = `${t}-row`;
    Kt(s, i, r), jt(e, `${r}-cell`, i);
  });
}
function Oa(s, n) {
  const e = Li(s);
  Object.entries(n).forEach(([t, i]) => {
    const r = s.getAttribute(t);
    if (Dn(s, t, i), r) {
      const o = `${t}-${r}-row`;
      Kt(s, !1, o), jt(e, `${o}-cell`, !1);
    }
    if (i) {
      const o = `${t}-${i}-row`;
      Kt(s, i, o), jt(e, `${o}-cell`, i);
    }
  });
}
function si(s, n, e, t, i) {
  Dn(s, n, e), i && Kt(s, !1, i), Kt(s, e, t || `${n}-cell`);
}
class zi {
  constructor(n, e) {
    this.__host = n, this.__callback = e, this.__currentSlots = [], this.__onMutation = this.__onMutation.bind(this), this.__observer = new MutationObserver(this.__onMutation), this.__observer.observe(n, {
      childList: !0
    }), this.__initialCallDebouncer = Me.debounce(this.__initialCallDebouncer, yt, () => this.__onMutation());
  }
  disconnect() {
    this.__observer.disconnect(), this.__initialCallDebouncer.cancel(), this.__toggleSlotChangeListeners(!1);
  }
  flush() {
    this.__onMutation();
  }
  __toggleSlotChangeListeners(n) {
    this.__currentSlots.forEach((e) => {
      n ? e.addEventListener("slotchange", this.__onMutation) : e.removeEventListener("slotchange", this.__onMutation);
    });
  }
  __onMutation() {
    const n = !this.__currentColumns;
    this.__currentColumns ||= [];
    const e = zi.getColumns(this.__host), t = e.filter((a) => !this.__currentColumns.includes(a)), i = this.__currentColumns.filter((a) => !e.includes(a)), r = this.__currentColumns.some((a, c) => a !== e[c]);
    this.__currentColumns = e, this.__toggleSlotChangeListeners(!1), this.__currentSlots = [...this.__host.children].filter((a) => a instanceof HTMLSlotElement), this.__toggleSlotChangeListeners(!0), (n || t.length || i.length || r) && this.__callback(t, i);
  }
  /**
   * Default filter for column elements.
   */
  static __isColumnElement(n) {
    return n.nodeType === Node.ELEMENT_NODE && /\bcolumn\b/u.test(n.localName);
  }
  static getColumns(n) {
    const e = [], t = n._isColumnElement || zi.__isColumnElement;
    return [...n.children].forEach((i) => {
      t(i) ? e.push(i) : i instanceof HTMLSlotElement && [...i.assignedElements({ flatten: !0 })].filter((r) => t(r)).forEach((r) => e.push(r));
    }), e;
  }
}
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const fh = (s) => class extends s {
  static get properties() {
    return {
      /**
       * When set to true, the column is user-resizable.
       * @default false
       */
      resizable: {
        type: Boolean,
        sync: !0,
        value() {
          if (this.localName === "vaadin-grid-column-group")
            return;
          const e = this.parentNode;
          return e && e.localName === "vaadin-grid-column-group" && e.resizable || !1;
        }
      },
      /**
       * When true, the column is frozen. When a column inside of a column group is frozen,
       * all of the sibling columns inside the group will get frozen also.
       * @type {boolean}
       */
      frozen: {
        type: Boolean,
        value: !1,
        sync: !0
      },
      /**
       * When true, the column is frozen to end of grid.
       *
       * When a column inside of a column group is frozen to end, all of the sibling columns
       * inside the group will get frozen to end also.
       *
       * Column can not be set as `frozen` and `frozenToEnd` at the same time.
       * @attr {boolean} frozen-to-end
       * @type {boolean}
       */
      frozenToEnd: {
        type: Boolean,
        value: !1,
        sync: !0
      },
      /**
       * When true, the cells for this column will be rendered with the `role` attribute
       * set as `rowheader`, instead of the `gridcell` role value used by default.
       *
       * When a column is set as row header, its cells will be announced by screen readers
       * while navigating to help user identify the current row as uniquely as possible.
       *
       * @attr {boolean} row-header
       * @type {boolean}
       */
      rowHeader: {
        type: Boolean,
        value: !1,
        sync: !0
      },
      /**
       * When set to true, the cells for this column are hidden.
       */
      hidden: {
        type: Boolean,
        value: !1,
        sync: !0
      },
      /**
       * Text content to display in the header cell of the column.
       */
      header: {
        type: String,
        sync: !0
      },
      /**
       * Aligns the columns cell content horizontally.
       * Supported values: "start", "center" and "end".
       * @attr {start|center|end} text-align
       * @type {GridColumnTextAlign | null | undefined}
       */
      textAlign: {
        type: String,
        sync: !0
      },
      /**
       * Custom part name for the header cell.
       *
       * @attr {string} header-part-name
       */
      headerPartName: {
        type: String,
        sync: !0
      },
      /**
       * Custom part name for the footer cell.
       *
       * @attr {string} footer-part-name
       */
      footerPartName: {
        type: String,
        sync: !0
      },
      /**
       * @type {boolean}
       * @protected
       */
      _lastFrozen: {
        type: Boolean,
        value: !1,
        sync: !0
      },
      /**
       * @type {boolean}
       * @protected
       */
      _bodyContentHidden: {
        type: Boolean,
        value: !1,
        sync: !0
      },
      /**
       * @type {boolean}
       * @protected
       */
      _firstFrozenToEnd: {
        type: Boolean,
        value: !1,
        sync: !0
      },
      /** @protected */
      _order: {
        type: Number,
        sync: !0
      },
      /** @private */
      _reorderStatus: {
        type: Boolean,
        sync: !0
      },
      /**
       * @type {Array<!HTMLElement>}
       * @protected
       */
      _emptyCells: Array,
      /** @private */
      _headerCell: Object,
      /** @private */
      _footerCell: Object,
      /** @protected */
      _grid: Object,
      /**
       * By default, the Polymer doesn't invoke the observer
       * during initialization if all of its dependencies are `undefined`.
       * This internal property can be used to force initial invocation of an observer
       * even the other dependencies of the observer are `undefined`.
       *
       * @private
       */
      __initialized: {
        type: Boolean,
        value: !0
      },
      /**
       * Custom function for rendering the header content.
       * Receives two arguments:
       *
       * - `root` The header cell content DOM element. Append your content to it.
       * - `column` The `<vaadin-grid-column>` element.
       *
       * @type {GridHeaderFooterRenderer | null | undefined}
       */
      headerRenderer: {
        type: Function,
        sync: !0
      },
      /**
       * Represents the final header renderer computed on the set of observable arguments.
       * It is supposed to be used internally when rendering the header cell content.
       *
       * @protected
       * @type {GridHeaderFooterRenderer | undefined}
       */
      _headerRenderer: {
        type: Function,
        computed: "_computeHeaderRenderer(headerRenderer, header, __initialized)",
        sync: !0
      },
      /**
       * Custom function for rendering the footer content.
       * Receives two arguments:
       *
       * - `root` The footer cell content DOM element. Append your content to it.
       * - `column` The `<vaadin-grid-column>` element.
       *
       * @type {GridHeaderFooterRenderer | null | undefined}
       */
      footerRenderer: {
        type: Function,
        sync: !0
      },
      /**
       * Represents the final footer renderer computed on the set of observable arguments.
       * It is supposed to be used internally when rendering the footer cell content.
       *
       * @protected
       * @type {GridHeaderFooterRenderer | undefined}
       */
      _footerRenderer: {
        type: Function,
        computed: "_computeFooterRenderer(footerRenderer, __initialized)",
        sync: !0
      },
      /**
       * An internal property that is mainly used by `vaadin-template-renderer`
       * to identify grid column elements.
       *
       * @private
       */
      __gridColumnElement: {
        type: Boolean,
        value: !0
      }
    };
  }
  static get observers() {
    return [
      "_widthChanged(width, _headerCell, _footerCell, _cells)",
      "_frozenChanged(frozen, _headerCell, _footerCell, _cells)",
      "_frozenToEndChanged(frozenToEnd, _headerCell, _footerCell, _cells)",
      "_flexGrowChanged(flexGrow, _headerCell, _footerCell, _cells)",
      "_textAlignChanged(textAlign, _cells, _headerCell, _footerCell)",
      "_orderChanged(_order, _headerCell, _footerCell, _cells)",
      "_lastFrozenChanged(_lastFrozen)",
      "_firstFrozenToEndChanged(_firstFrozenToEnd)",
      "_onRendererOrBindingChanged(_renderer, _cells, _bodyContentHidden, path)",
      "_onHeaderRendererOrBindingChanged(_headerRenderer, _headerCell, path, header)",
      "_onFooterRendererOrBindingChanged(_footerRenderer, _footerCell)",
      "_resizableChanged(resizable, _headerCell)",
      "_reorderStatusChanged(_reorderStatus, _headerCell, _footerCell, _cells)",
      "_hiddenChanged(hidden, _headerCell, _footerCell, _cells)",
      "_rowHeaderChanged(rowHeader, _cells)",
      "__headerFooterPartNameChanged(_headerCell, _footerCell, headerPartName, footerPartName)"
    ];
  }
  /**
   * @return {!Grid | undefined}
   * @protected
   */
  get _grid() {
    return this._gridValue || (this._gridValue = this._findHostGrid()), this._gridValue;
  }
  /**
   * @return {!Array<!HTMLElement>}
   * @protected
   */
  get _allCells() {
    return [].concat(this._cells || []).concat(this._emptyCells || []).concat(this._headerCell).concat(this._footerCell).filter((e) => e);
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback(), requestAnimationFrame(() => {
      this._grid && this._allCells.forEach((e) => {
        e._content.parentNode || this._grid.appendChild(e._content);
      });
    });
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback(), requestAnimationFrame(() => {
      this._grid || this._allCells.forEach((e) => {
        e._content.parentNode && e._content.parentNode.removeChild(e._content);
      });
    }), this._gridValue = void 0;
  }
  /** @protected */
  ready() {
    super.ready(), cs(this);
  }
  /**
   * @return {!Grid | undefined}
   * @protected
   */
  _findHostGrid() {
    let e = this;
    for (; e && !/^vaadin.*grid(-pro)?$/u.test(e.localName); )
      e = e.assignedSlot ? e.assignedSlot.parentNode : e.parentNode;
    return e || void 0;
  }
  /** @protected */
  _renderHeaderAndFooter() {
    this._renderHeaderCellContent(this._headerRenderer, this._headerCell), this._renderFooterCellContent(this._footerRenderer, this._footerCell);
  }
  /** @private */
  _flexGrowChanged(e) {
    this.parentElement && this.parentElement._columnPropChanged && this.parentElement._columnPropChanged("flexGrow"), this._allCells.forEach((t) => {
      t.style.flexGrow = e;
    });
  }
  /** @private */
  _orderChanged(e) {
    this._allCells.forEach((t) => {
      t.style.order = e;
    });
  }
  /** @private */
  _widthChanged(e) {
    this.parentElement && this.parentElement._columnPropChanged && this.parentElement._columnPropChanged("width"), this._allCells.forEach((t) => {
      t.style.width = e;
    });
  }
  /** @private */
  _frozenChanged(e) {
    this.parentElement && this.parentElement._columnPropChanged && this.parentElement._columnPropChanged("frozen", e), this._allCells.forEach((t) => {
      si(t, "frozen", e);
    }), this._grid && this._grid._frozenCellsChanged && this._grid._frozenCellsChanged();
  }
  /** @private */
  _frozenToEndChanged(e) {
    this.parentElement && this.parentElement._columnPropChanged && this.parentElement._columnPropChanged("frozenToEnd", e), this._allCells.forEach((t) => {
      this._grid && t.parentElement === this._grid.$.sizer || si(t, "frozen-to-end", e);
    }), this._grid && this._grid._frozenCellsChanged && this._grid._frozenCellsChanged();
  }
  /** @private */
  _lastFrozenChanged(e) {
    this._allCells.forEach((t) => {
      si(t, "last-frozen", e);
    }), this.parentElement && this.parentElement._columnPropChanged && (this.parentElement._lastFrozen = e);
  }
  /** @private */
  _firstFrozenToEndChanged(e) {
    this._allCells.forEach((t) => {
      this._grid && t.parentElement === this._grid.$.sizer || si(t, "first-frozen-to-end", e);
    }), this.parentElement && this.parentElement._columnPropChanged && (this.parentElement._firstFrozenToEnd = e);
  }
  /** @private */
  _rowHeaderChanged(e, t) {
    t && t.forEach((i) => {
      i.setAttribute("role", e ? "rowheader" : "gridcell");
    });
  }
  /**
   * @param {string} path
   * @return {string}
   * @protected
   */
  _generateHeader(e) {
    return e.substr(e.lastIndexOf(".") + 1).replace(/([A-Z])/gu, "-$1").toLowerCase().replace(/-/gu, " ").replace(/^./u, (t) => t.toUpperCase());
  }
  /** @private */
  _reorderStatusChanged(e) {
    const t = this.__previousReorderStatus, i = t ? `reorder-${t}-cell` : "", r = `reorder-${e}-cell`;
    this._allCells.forEach((o) => {
      si(o, "reorder-status", e, r, i);
    }), this.__previousReorderStatus = e;
  }
  /** @private */
  _resizableChanged(e, t) {
    e === void 0 || t === void 0 || t && [t].concat(this._emptyCells).forEach((i) => {
      if (i) {
        const r = i.querySelector('[part~="resize-handle"]');
        if (r && i.removeChild(r), e) {
          const o = document.createElement("div");
          o.setAttribute("part", "resize-handle"), i.appendChild(o);
        }
      }
    });
  }
  /** @private */
  _textAlignChanged(e) {
    if (e === void 0 || this._grid === void 0)
      return;
    if (["start", "end", "center"].indexOf(e) === -1) {
      console.warn('textAlign can only be set as "start", "end" or "center"');
      return;
    }
    let t;
    getComputedStyle(this._grid).direction === "ltr" ? e === "start" ? t = "left" : e === "end" && (t = "right") : e === "start" ? t = "right" : e === "end" && (t = "left"), this._allCells.forEach((i) => {
      i._content.style.textAlign = e, getComputedStyle(i._content).textAlign !== e && (i._content.style.textAlign = t);
    });
  }
  /** @private */
  _hiddenChanged(e) {
    this.parentElement && this.parentElement._columnPropChanged && this.parentElement._columnPropChanged("hidden", e), !!e != !!this._previousHidden && this._grid && (e === !0 && this._allCells.forEach((t) => {
      t._content.parentNode && t._content.parentNode.removeChild(t._content);
    }), this._grid._debouncerHiddenChanged = Me.debounce(
      this._grid._debouncerHiddenChanged,
      qt,
      () => {
        this._grid && this._grid._renderColumnTree && this._grid._renderColumnTree(this._grid._columnTree);
      }
    ), this._grid._debounceUpdateFrozenColumn && this._grid._debounceUpdateFrozenColumn(), this._grid._resetKeyboardNavigation && this._grid._resetKeyboardNavigation()), this._previousHidden = e;
  }
  /** @protected */
  _runRenderer(e, t, i) {
    const r = i && i.item && !t.parentElement.hidden;
    if (!(r || e === this._headerRenderer || e === this._footerRenderer))
      return;
    const a = [t._content, this];
    r && a.push(i), e.apply(this, a);
  }
  /**
   * Renders the content to the given cells using a renderer.
   *
   * @private
   */
  __renderCellsContent(e, t) {
    this.hidden || !this._grid || t.forEach((i) => {
      if (!i.parentElement)
        return;
      const r = this._grid.__getRowModel(i.parentElement);
      e && (i._renderer !== e && this._clearCellContent(i), i._renderer = e, this._runRenderer(e, i, r));
    });
  }
  /**
   * Clears the content of a cell.
   *
   * @protected
   */
  _clearCellContent(e) {
    e._content.innerHTML = "", delete e._content._$litPart$;
  }
  /**
   * Renders the header cell content using a renderer,
   * and then updates the visibility of the parent row depending on
   * whether all its children cells are empty or not.
   *
   * @protected
   */
  _renderHeaderCellContent(e, t) {
    !t || !e || (this.__renderCellsContent(e, [t]), this._grid && t.parentElement && this._grid.__debounceUpdateHeaderFooterRowVisibility(t.parentElement));
  }
  /** @protected */
  _onHeaderRendererOrBindingChanged(e, t, ...i) {
    this._renderHeaderCellContent(e, t);
  }
  /** @private */
  __headerFooterPartNameChanged(e, t, i, r) {
    [
      { cell: e, partName: i },
      { cell: t, partName: r }
    ].forEach(({ cell: o, partName: a }) => {
      if (o) {
        const c = o.__customParts || [];
        o.part.remove(...c), o.__customParts = a ? a.trim().split(" ") : [], o.part.add(...o.__customParts);
      }
    });
  }
  /**
   * Renders the content of body cells using a renderer.
   *
   * @protected
   */
  _renderBodyCellsContent(e, t) {
    !t || !e || this.__renderCellsContent(e, t);
  }
  /** @protected */
  _onRendererOrBindingChanged(e, t, ...i) {
    this._renderBodyCellsContent(e, t);
  }
  /**
   * Renders the footer cell content using a renderer
   * and then updates the visibility of the parent row depending on
   * whether all its children cells are empty or not.
   *
   * @protected
   */
  _renderFooterCellContent(e, t) {
    !t || !e || (this.__renderCellsContent(e, [t]), this._grid && t.parentElement && this._grid.__debounceUpdateHeaderFooterRowVisibility(t.parentElement));
  }
  /** @protected */
  _onFooterRendererOrBindingChanged(e, t) {
    this._renderFooterCellContent(e, t);
  }
  /** @private */
  __setTextContent(e, t) {
    e.textContent !== t && (e.textContent = t);
  }
  /**
   * Renders the text header to the header cell.
   *
   * @private
   */
  __textHeaderRenderer() {
    this.__setTextContent(this._headerCell._content, this.header);
  }
  /**
   * Computes the property name based on the path and renders it to the header cell.
   * If the path is not defined, then nothing is rendered.
   *
   * @protected
   */
  _defaultHeaderRenderer() {
    this.path && this.__setTextContent(this._headerCell._content, this._generateHeader(this.path));
  }
  /**
   * Computes the item property value based on the path and renders it to the body cell.
   * If the path is not defined, then nothing is rendered.
   *
   * @protected
   */
  _defaultRenderer(e, t, { item: i }) {
    this.path && this.__setTextContent(e, pi(this.path, i));
  }
  /**
   * By default, nothing is rendered to the footer cell.
   *
   * @protected
   */
  _defaultFooterRenderer() {
  }
  /**
   * Computes the final header renderer for the `_headerRenderer` computed property.
   * All the arguments are observable by the Polymer, it re-calls the method
   * once an argument is changed to update the property value.
   *
   * @protected
   * @return {GridHeaderFooterRenderer | undefined}
   */
  _computeHeaderRenderer(e, t) {
    return e || (t != null ? this.__textHeaderRenderer : this._defaultHeaderRenderer);
  }
  /**
   * Computes the final renderer for the `_renderer` property.
   * All the arguments are observable by the Polymer, it re-calls the method
   * once an argument is changed to update the property value.
   *
   * @protected
   * @return {GridBodyRenderer | undefined}
   */
  _computeRenderer(e) {
    return e || this._defaultRenderer;
  }
  /**
   * Computes the final footer renderer for the `_footerRenderer` property.
   * All the arguments are observable by the Polymer, it re-calls the method
   * once an argument is changed to update the property value.
   *
   * @protected
   * @return {GridHeaderFooterRenderer | undefined}
   */
  _computeFooterRenderer(e) {
    return e || this._defaultFooterRenderer;
  }
}, ph = (s) => class extends fh(Cr(s)) {
  static get properties() {
    return {
      /**
       * Width of the cells for this column.
       *
       * Please note that using the `em` length unit is discouraged as
       * it might lead to misalignment issues if the header, body, and footer
       * cells have different font sizes. Instead, use `rem` if you need
       * a length unit relative to the font size.
       */
      width: {
        type: String,
        value: "100px",
        sync: !0
      },
      /**
       * Flex grow ratio for the cell widths. When set to 0, cell width is fixed.
       * @attr {number} flex-grow
       * @type {number}
       */
      flexGrow: {
        type: Number,
        value: 1,
        sync: !0
      },
      /**
       * Custom function for rendering the cell content.
       * Receives three arguments:
       *
       * - `root` The cell content DOM element. Append your content to it.
       * - `column` The `<vaadin-grid-column>` element.
       * - `model` The object with the properties related with
       *   the rendered item, contains:
       *   - `model.index` The index of the item.
       *   - `model.item` The item.
       *   - `model.expanded` Sublevel toggle state.
       *   - `model.level` Level of the tree represented with a horizontal offset of the toggle button.
       *   - `model.selected` Selected state.
       *   - `model.detailsOpened` Details opened state.
       *
       * @type {GridBodyRenderer | null | undefined}
       */
      renderer: {
        type: Function,
        sync: !0
      },
      /**
       * Represents the final renderer computed on the set of observable arguments.
       * It is supposed to be used internally when rendering the content of a body cell.
       *
       * @protected
       * @type {GridBodyRenderer | undefined}
       */
      _renderer: {
        type: Function,
        computed: "_computeRenderer(renderer, __initialized)",
        sync: !0
      },
      /**
       * Path to an item sub-property whose value gets displayed in the column body cells.
       * The property name is also shown in the column header if an explicit header or renderer isn't defined.
       */
      path: {
        type: String,
        sync: !0
      },
      /**
       * Automatically sets the width of the column based on the column contents when this is set to `true`.
       *
       * For performance reasons the column width is calculated automatically only once when the grid items
       * are rendered for the first time and the calculation only considers the rows which are currently
       * rendered in DOM (a bit more than what is currently visible). If the grid is scrolled, or the cell
       * content changes, the column width might not match the contents anymore.
       *
       * Hidden columns are ignored in the calculation and their widths are not automatically updated when
       * you show a column that was initially hidden.
       *
       * You can manually trigger the auto sizing behavior again by calling `grid.recalculateColumnWidths()`.
       *
       * The column width may still grow larger when `flexGrow` is not 0.
       * @attr {boolean} auto-width
       * @type {boolean}
       */
      autoWidth: {
        type: Boolean,
        value: !1
      },
      /**
       * When true, wraps the cell's slot into an element with role="button", and sets
       * the tabindex attribute on the button element, instead of the cell itself.
       * This is needed to keep focus in sync with VoiceOver cursor when navigating
       * with Control + Option + arrow keys: focusing the `<td>` element does not fire
       * a focus event, but focusing an element with role="button" inside a cell fires it.
       * @protected
       */
      _focusButtonMode: {
        type: Boolean,
        value: !1
      },
      /**
       * @type {Array<!HTMLElement>}
       * @protected
       */
      _cells: {
        type: Array,
        sync: !0
      }
    };
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class gh extends ph(mi) {
  static get is() {
    return "vaadin-grid-column";
  }
}
Zt(gh);
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Tr = rt((s) => typeof s.prototype.addController == "function" ? s : class extends s {
  constructor() {
    super(), this.__controllers = /* @__PURE__ */ new Set();
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback(), this.__controllers.forEach((e) => {
      e.hostConnected && e.hostConnected();
    });
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback(), this.__controllers.forEach((e) => {
      e.hostDisconnected && e.hostDisconnected();
    });
  }
  /**
   * Registers a controller to participate in the element update cycle.
   *
   * @param {ReactiveController} controller
   * @protected
   */
  addController(e) {
    this.__controllers.add(e), this.$ !== void 0 && this.isConnected && e.hostConnected && e.hostConnected();
  }
  /**
   * Removes a controller from the element.
   *
   * @param {ReactiveController} controller
   * @protected
   */
  removeController(e) {
    this.__controllers.delete(e);
  }
}), mh = /\/\*[\*!]\s+vaadin-dev-mode:start([\s\S]*)vaadin-dev-mode:end\s+\*\*\//i, sn = window.Vaadin && window.Vaadin.Flow && window.Vaadin.Flow.clients;
function vh() {
  function s() {
    return !0;
  }
  return Nl(s);
}
function _h() {
  try {
    return bh() ? !0 : yh() ? sn ? !wh() : !vh() : !1;
  } catch {
    return !1;
  }
}
function bh() {
  return localStorage.getItem("vaadin.developmentmode.force");
}
function yh() {
  return ["localhost", "127.0.0.1"].indexOf(window.location.hostname) >= 0;
}
function wh() {
  return !!(sn && Object.keys(sn).map((n) => sn[n]).filter((n) => n.productionMode).length > 0);
}
function Nl(s, n) {
  if (typeof s != "function")
    return;
  const e = mh.exec(s.toString());
  if (e)
    try {
      s = new Function(e[1]);
    } catch (t) {
      console.log("vaadin-development-mode-detector: uncommentAndRun() failed", t);
    }
  return s(n);
}
window.Vaadin = window.Vaadin || {};
const za = function(s, n) {
  if (window.Vaadin.developmentMode)
    return Nl(s, n);
};
window.Vaadin.developmentMode === void 0 && (window.Vaadin.developmentMode = _h());
function xh() {
  /*! vaadin-dev-mode:start
    (function () {
  'use strict';
  
  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };
  
  var classCallCheck = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };
  
  var createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
  
    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  
  var getPolymerVersion = function getPolymerVersion() {
    return window.Polymer && window.Polymer.version;
  };
  
  var StatisticsGatherer = function () {
    function StatisticsGatherer(logger) {
      classCallCheck(this, StatisticsGatherer);
  
      this.now = new Date().getTime();
      this.logger = logger;
    }
  
    createClass(StatisticsGatherer, [{
      key: 'frameworkVersionDetectors',
      value: function frameworkVersionDetectors() {
        return {
          'Flow': function Flow() {
            if (window.Vaadin && window.Vaadin.Flow && window.Vaadin.Flow.clients) {
              var flowVersions = Object.keys(window.Vaadin.Flow.clients).map(function (key) {
                return window.Vaadin.Flow.clients[key];
              }).filter(function (client) {
                return client.getVersionInfo;
              }).map(function (client) {
                return client.getVersionInfo().flow;
              });
              if (flowVersions.length > 0) {
                return flowVersions[0];
              }
            }
          },
          'Vaadin Framework': function VaadinFramework() {
            if (window.vaadin && window.vaadin.clients) {
              var frameworkVersions = Object.values(window.vaadin.clients).filter(function (client) {
                return client.getVersionInfo;
              }).map(function (client) {
                return client.getVersionInfo().vaadinVersion;
              });
              if (frameworkVersions.length > 0) {
                return frameworkVersions[0];
              }
            }
          },
          'AngularJs': function AngularJs() {
            if (window.angular && window.angular.version && window.angular.version) {
              return window.angular.version.full;
            }
          },
          'Angular': function Angular() {
            if (window.ng) {
              var tags = document.querySelectorAll("[ng-version]");
              if (tags.length > 0) {
                return tags[0].getAttribute("ng-version");
              }
              return "Unknown";
            }
          },
          'Backbone.js': function BackboneJs() {
            if (window.Backbone) {
              return window.Backbone.VERSION;
            }
          },
          'React': function React() {
            var reactSelector = '[data-reactroot], [data-reactid]';
            if (!!document.querySelector(reactSelector)) {
              // React does not publish the version by default
              return "unknown";
            }
          },
          'Ember': function Ember() {
            if (window.Em && window.Em.VERSION) {
              return window.Em.VERSION;
            } else if (window.Ember && window.Ember.VERSION) {
              return window.Ember.VERSION;
            }
          },
          'jQuery': function (_jQuery) {
            function jQuery() {
              return _jQuery.apply(this, arguments);
            }
  
            jQuery.toString = function () {
              return _jQuery.toString();
            };
  
            return jQuery;
          }(function () {
            if (typeof jQuery === 'function' && jQuery.prototype.jquery !== undefined) {
              return jQuery.prototype.jquery;
            }
          }),
          'Polymer': function Polymer() {
            var version = getPolymerVersion();
            if (version) {
              return version;
            }
          },
          'LitElement': function LitElement() {
            var version = window.litElementVersions && window.litElementVersions[0];
            if (version) {
              return version;
            }
          },
          'LitHtml': function LitHtml() {
            var version = window.litHtmlVersions && window.litHtmlVersions[0];
            if (version) {
              return version;
            }
          },
          'Vue.js': function VueJs() {
            if (window.Vue) {
              return window.Vue.version;
            }
          }
        };
      }
    }, {
      key: 'getUsedVaadinElements',
      value: function getUsedVaadinElements(elements) {
        var version = getPolymerVersion();
        var elementClasses = void 0;
        // NOTE: In case you edit the code here, YOU MUST UPDATE any statistics reporting code in Flow.
        // Check all locations calling the method getEntries() in
        // https://github.com/vaadin/flow/blob/master/flow-server/src/main/java/com/vaadin/flow/internal/UsageStatistics.java#L106
        // Currently it is only used by BootstrapHandler.
        if (version && version.indexOf('2') === 0) {
          // Polymer 2: components classes are stored in window.Vaadin
          elementClasses = Object.keys(window.Vaadin).map(function (c) {
            return window.Vaadin[c];
          }).filter(function (c) {
            return c.is;
          });
        } else {
          // Polymer 3: components classes are stored in window.Vaadin.registrations
          elementClasses = window.Vaadin.registrations || [];
        }
        elementClasses.forEach(function (klass) {
          var version = klass.version ? klass.version : "0.0.0";
          elements[klass.is] = { version: version };
        });
      }
    }, {
      key: 'getUsedVaadinThemes',
      value: function getUsedVaadinThemes(themes) {
        ['Lumo', 'Material'].forEach(function (themeName) {
          var theme;
          var version = getPolymerVersion();
          if (version && version.indexOf('2') === 0) {
            // Polymer 2: themes are stored in window.Vaadin
            theme = window.Vaadin[themeName];
          } else {
            // Polymer 3: themes are stored in custom element registry
            theme = customElements.get('vaadin-' + themeName.toLowerCase() + '-styles');
          }
          if (theme && theme.version) {
            themes[themeName] = { version: theme.version };
          }
        });
      }
    }, {
      key: 'getFrameworks',
      value: function getFrameworks(frameworks) {
        var detectors = this.frameworkVersionDetectors();
        Object.keys(detectors).forEach(function (framework) {
          var detector = detectors[framework];
          try {
            var version = detector();
            if (version) {
              frameworks[framework] = { version: version };
            }
          } catch (e) {}
        });
      }
    }, {
      key: 'gather',
      value: function gather(storage) {
        var storedStats = storage.read();
        var gatheredStats = {};
        var types = ["elements", "frameworks", "themes"];
  
        types.forEach(function (type) {
          gatheredStats[type] = {};
          if (!storedStats[type]) {
            storedStats[type] = {};
          }
        });
  
        var previousStats = JSON.stringify(storedStats);
  
        this.getUsedVaadinElements(gatheredStats.elements);
        this.getFrameworks(gatheredStats.frameworks);
        this.getUsedVaadinThemes(gatheredStats.themes);
  
        var now = this.now;
        types.forEach(function (type) {
          var keys = Object.keys(gatheredStats[type]);
          keys.forEach(function (key) {
            if (!storedStats[type][key] || _typeof(storedStats[type][key]) != _typeof({})) {
              storedStats[type][key] = { firstUsed: now };
            }
            // Discards any previously logged version number
            storedStats[type][key].version = gatheredStats[type][key].version;
            storedStats[type][key].lastUsed = now;
          });
        });
  
        var newStats = JSON.stringify(storedStats);
        storage.write(newStats);
        if (newStats != previousStats && Object.keys(storedStats).length > 0) {
          this.logger.debug("New stats: " + newStats);
        }
      }
    }]);
    return StatisticsGatherer;
  }();
  
  var StatisticsStorage = function () {
    function StatisticsStorage(key) {
      classCallCheck(this, StatisticsStorage);
  
      this.key = key;
    }
  
    createClass(StatisticsStorage, [{
      key: 'read',
      value: function read() {
        var localStorageStatsString = localStorage.getItem(this.key);
        try {
          return JSON.parse(localStorageStatsString ? localStorageStatsString : '{}');
        } catch (e) {
          return {};
        }
      }
    }, {
      key: 'write',
      value: function write(data) {
        localStorage.setItem(this.key, data);
      }
    }, {
      key: 'clear',
      value: function clear() {
        localStorage.removeItem(this.key);
      }
    }, {
      key: 'isEmpty',
      value: function isEmpty() {
        var storedStats = this.read();
        var empty = true;
        Object.keys(storedStats).forEach(function (key) {
          if (Object.keys(storedStats[key]).length > 0) {
            empty = false;
          }
        });
  
        return empty;
      }
    }]);
    return StatisticsStorage;
  }();
  
  var StatisticsSender = function () {
    function StatisticsSender(url, logger) {
      classCallCheck(this, StatisticsSender);
  
      this.url = url;
      this.logger = logger;
    }
  
    createClass(StatisticsSender, [{
      key: 'send',
      value: function send(data, errorHandler) {
        var logger = this.logger;
  
        if (navigator.onLine === false) {
          logger.debug("Offline, can't send");
          errorHandler();
          return;
        }
        logger.debug("Sending data to " + this.url);
  
        var req = new XMLHttpRequest();
        req.withCredentials = true;
        req.addEventListener("load", function () {
          // Stats sent, nothing more to do
          logger.debug("Response: " + req.responseText);
        });
        req.addEventListener("error", function () {
          logger.debug("Send failed");
          errorHandler();
        });
        req.addEventListener("abort", function () {
          logger.debug("Send aborted");
          errorHandler();
        });
        req.open("POST", this.url);
        req.setRequestHeader("Content-Type", "application/json");
        req.send(data);
      }
    }]);
    return StatisticsSender;
  }();
  
  var StatisticsLogger = function () {
    function StatisticsLogger(id) {
      classCallCheck(this, StatisticsLogger);
  
      this.id = id;
    }
  
    createClass(StatisticsLogger, [{
      key: '_isDebug',
      value: function _isDebug() {
        return localStorage.getItem("vaadin." + this.id + ".debug");
      }
    }, {
      key: 'debug',
      value: function debug(msg) {
        if (this._isDebug()) {
          console.info(this.id + ": " + msg);
        }
      }
    }]);
    return StatisticsLogger;
  }();
  
  var UsageStatistics = function () {
    function UsageStatistics() {
      classCallCheck(this, UsageStatistics);
  
      this.now = new Date();
      this.timeNow = this.now.getTime();
      this.gatherDelay = 10; // Delay between loading this file and gathering stats
      this.initialDelay = 24 * 60 * 60;
  
      this.logger = new StatisticsLogger("statistics");
      this.storage = new StatisticsStorage("vaadin.statistics.basket");
      this.gatherer = new StatisticsGatherer(this.logger);
      this.sender = new StatisticsSender("https://tools.vaadin.com/usage-stats/submit", this.logger);
    }
  
    createClass(UsageStatistics, [{
      key: 'maybeGatherAndSend',
      value: function maybeGatherAndSend() {
        var _this = this;
  
        if (localStorage.getItem(UsageStatistics.optOutKey)) {
          return;
        }
        this.gatherer.gather(this.storage);
        setTimeout(function () {
          _this.maybeSend();
        }, this.gatherDelay * 1000);
      }
    }, {
      key: 'lottery',
      value: function lottery() {
        return true;
      }
    }, {
      key: 'currentMonth',
      value: function currentMonth() {
        return this.now.getYear() * 12 + this.now.getMonth();
      }
    }, {
      key: 'maybeSend',
      value: function maybeSend() {
        var firstUse = Number(localStorage.getItem(UsageStatistics.firstUseKey));
        var monthProcessed = Number(localStorage.getItem(UsageStatistics.monthProcessedKey));
  
        if (!firstUse) {
          // Use a grace period to avoid interfering with tests, incognito mode etc
          firstUse = this.timeNow;
          localStorage.setItem(UsageStatistics.firstUseKey, firstUse);
        }
  
        if (this.timeNow < firstUse + this.initialDelay * 1000) {
          this.logger.debug("No statistics will be sent until the initial delay of " + this.initialDelay + "s has passed");
          return;
        }
        if (this.currentMonth() <= monthProcessed) {
          this.logger.debug("This month has already been processed");
          return;
        }
        localStorage.setItem(UsageStatistics.monthProcessedKey, this.currentMonth());
        // Use random sampling
        if (this.lottery()) {
          this.logger.debug("Congratulations, we have a winner!");
        } else {
          this.logger.debug("Sorry, no stats from you this time");
          return;
        }
  
        this.send();
      }
    }, {
      key: 'send',
      value: function send() {
        // Ensure we have the latest data
        this.gatherer.gather(this.storage);
  
        // Read, send and clean up
        var data = this.storage.read();
        data["firstUse"] = Number(localStorage.getItem(UsageStatistics.firstUseKey));
        data["usageStatisticsVersion"] = UsageStatistics.version;
        var info = 'This request contains usage statistics gathered from the application running in development mode. \n\nStatistics gathering is automatically disabled and excluded from production builds.\n\nFor details and to opt-out, see https://github.com/vaadin/vaadin-usage-statistics.\n\n\n\n';
        var self = this;
        this.sender.send(info + JSON.stringify(data), function () {
          // Revert the 'month processed' flag
          localStorage.setItem(UsageStatistics.monthProcessedKey, self.currentMonth() - 1);
        });
      }
    }], [{
      key: 'version',
      get: function get$1() {
        return '2.1.2';
      }
    }, {
      key: 'firstUseKey',
      get: function get$1() {
        return 'vaadin.statistics.firstuse';
      }
    }, {
      key: 'monthProcessedKey',
      get: function get$1() {
        return 'vaadin.statistics.monthProcessed';
      }
    }, {
      key: 'optOutKey',
      get: function get$1() {
        return 'vaadin.statistics.optout';
      }
    }]);
    return UsageStatistics;
  }();
  
  try {
    window.Vaadin = window.Vaadin || {};
    window.Vaadin.usageStatsChecker = window.Vaadin.usageStatsChecker || new UsageStatistics();
    window.Vaadin.usageStatsChecker.maybeGatherAndSend();
  } catch (e) {
    // Intentionally ignored as this is not a problem in the app being developed
  }
  
  }());
  
    vaadin-dev-mode:end **/
}
const Ch = function() {
  if (typeof za == "function")
    return za(xh);
};
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
window.Vaadin || (window.Vaadin = {});
window.Vaadin.registrations || (window.Vaadin.registrations = []);
window.Vaadin.developmentModeCallback || (window.Vaadin.developmentModeCallback = {});
window.Vaadin.developmentModeCallback["vaadin-usage-statistics"] = function() {
  Ch();
};
let _o;
const Fa = /* @__PURE__ */ new Set(), Hl = (s) => class extends Cr(s) {
  /** @protected */
  static finalize() {
    super.finalize();
    const { is: e } = this;
    e && !Fa.has(e) && (window.Vaadin.registrations.push(this), Fa.add(e), window.Vaadin.developmentModeCallback && (_o = Me.debounce(_o, Ml, () => {
      window.Vaadin.developmentModeCallback["vaadin-usage-statistics"]();
    }), Ll(_o)));
  }
  constructor() {
    super(), document.doctype === null && console.warn(
      'Vaadin components require the "standards mode" declaration. Please add <!DOCTYPE html> to the HTML document.'
    );
  }
};
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
let hs = !1;
window.addEventListener(
  "keydown",
  () => {
    hs = !0;
  },
  { capture: !0 }
);
window.addEventListener(
  "mousedown",
  () => {
    hs = !1;
  },
  { capture: !0 }
);
function Uo() {
  let s = document.activeElement || document.body;
  for (; s.shadowRoot && s.shadowRoot.activeElement; )
    s = s.shadowRoot.activeElement;
  return s;
}
function On() {
  return hs;
}
function Vl(s) {
  const n = s.style;
  if (n.visibility === "hidden" || n.display === "none")
    return !0;
  const e = window.getComputedStyle(s);
  return e.visibility === "hidden" || e.display === "none";
}
function Th(s, n) {
  const e = Math.max(s.tabIndex, 0), t = Math.max(n.tabIndex, 0);
  return e === 0 || t === 0 ? t > e : e > t;
}
function Eh(s, n) {
  const e = [];
  for (; s.length > 0 && n.length > 0; )
    Th(s[0], n[0]) ? e.push(n.shift()) : e.push(s.shift());
  return e.concat(s, n);
}
function Wo(s) {
  const n = s.length;
  if (n < 2)
    return s;
  const e = Math.ceil(n / 2), t = Wo(s.slice(0, e)), i = Wo(s.slice(e));
  return Eh(t, i);
}
function wn(s) {
  return s.offsetParent === null && s.clientWidth === 0 && s.clientHeight === 0 ? !0 : Vl(s);
}
function fs(s) {
  return s.matches('[tabindex="-1"]') ? !1 : s.matches("input, select, textarea, button, object") ? s.matches(":not([disabled])") : s.matches("a[href], area[href], iframe, [tabindex], [contentEditable]");
}
function Ul(s) {
  return s.getRootNode().activeElement === s;
}
function Ph(s) {
  if (!fs(s))
    return -1;
  const n = s.getAttribute("tabindex") || 0;
  return Number(n);
}
function Wl(s, n) {
  if (s.nodeType !== Node.ELEMENT_NODE || Vl(s))
    return !1;
  const e = (
    /** @type {HTMLElement} */
    s
  ), t = Ph(e);
  let i = t > 0;
  t >= 0 && n.push(e);
  let r = [];
  return e.localName === "slot" ? r = e.assignedNodes({ flatten: !0 }) : r = (e.shadowRoot || e).children, [...r].forEach((o) => {
    i = Wl(o, n) || i;
  }), i;
}
function Sh(s) {
  const n = [];
  return Wl(s, n) ? Wo(n) : n;
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const jl = rt(
  (s) => class extends s {
    static get properties() {
      return {
        /**
         * If true, the user cannot interact with this element.
         */
        disabled: {
          type: Boolean,
          value: !1,
          observer: "_disabledChanged",
          reflectToAttribute: !0
        }
      };
    }
    /**
     * @param {boolean} disabled
     * @protected
     */
    _disabledChanged(e) {
      this._setAriaDisabled(e);
    }
    /**
     * @param {boolean} disabled
     * @protected
     */
    _setAriaDisabled(e) {
      e ? this.setAttribute("aria-disabled", "true") : this.removeAttribute("aria-disabled");
    }
    /**
     * Overrides the default element `click` method in order to prevent
     * firing the `click` event when the element is disabled.
     * @protected
     * @override
     */
    click() {
      this.disabled || super.click();
    }
  }
);
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Gl = (s) => class extends jl(s) {
  static get properties() {
    return {
      /**
       * Indicates whether the element can be focused and where it participates in sequential keyboard navigation.
       *
       * @protected
       */
      tabindex: {
        type: Number,
        reflectToAttribute: !0,
        observer: "_tabindexChanged"
      },
      /**
       * Stores the last known tabindex since the element has been disabled.
       *
       * @protected
       */
      _lastTabIndex: {
        type: Number
      }
    };
  }
  /**
   * When the element gets disabled, the observer saves the last known tabindex
   * and makes the element not focusable by setting tabindex to -1.
   * As soon as the element gets enabled, the observer restores the last known tabindex
   * so that the element can be focusable again.
   *
   * @protected
   * @override
   */
  _disabledChanged(e, t) {
    super._disabledChanged(e, t), e ? (this.tabindex !== void 0 && (this._lastTabIndex = this.tabindex), this.tabindex = -1) : t && (this.tabindex = this._lastTabIndex);
  }
  /**
   * When the user has changed tabindex while the element is disabled,
   * the observer reverts tabindex to -1 and rather saves the new tabindex value to apply it later.
   * The new value will be applied as soon as the element becomes enabled.
   *
   * @protected
   */
  _tabindexChanged(e) {
    this.disabled && e !== -1 && (this._lastTabIndex = e, this.tabindex = -1);
  }
};
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const zn = (s) => s.test(navigator.userAgent), jo = (s) => s.test(navigator.platform), kh = (s) => s.test(navigator.vendor), Ma = zn(/Android/u), Rh = zn(/Chrome/u) && kh(/Google Inc/u), Ah = zn(/Firefox/u), Ih = jo(/^iPad/u) || jo(/^Mac/u) && navigator.maxTouchPoints > 1, Dh = jo(/^iPhone/u), Go = Dh || Ih, ql = zn(/^((?!chrome|android).)*safari/iu), br = (() => {
  try {
    return document.createEvent("TouchEvent"), !0;
  } catch {
    return !1;
  }
})();
/**
 * @license
 * Copyright (c) 2023 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class Kl {
  constructor(n, e) {
    this.slot = n, this.callback = e, this._storedNodes = [], this._connected = !1, this._scheduled = !1, this._boundSchedule = () => {
      this._schedule();
    }, this.connect(), this._schedule();
  }
  /**
   * Activates an observer. This method is automatically called when
   * a `SlotObserver` is created. It should only be called to  re-activate
   * an observer that has been deactivated via the `disconnect` method.
   */
  connect() {
    this.slot.addEventListener("slotchange", this._boundSchedule), this._connected = !0;
  }
  /**
   * Deactivates the observer. After calling this method the observer callback
   * will not be called when changes to slotted nodes occur. The `connect` method
   * may be subsequently called to reactivate the observer.
   */
  disconnect() {
    this.slot.removeEventListener("slotchange", this._boundSchedule), this._connected = !1;
  }
  /** @private */
  _schedule() {
    this._scheduled || (this._scheduled = !0, queueMicrotask(() => {
      this.flush();
    }));
  }
  /**
   * Run the observer callback synchronously.
   */
  flush() {
    this._connected && (this._scheduled = !1, this._processNodes());
  }
  /** @private */
  _processNodes() {
    const n = this.slot.assignedNodes({ flatten: !0 });
    let e = [];
    const t = [], i = [];
    n.length && (e = n.filter((r) => !this._storedNodes.includes(r))), this._storedNodes.length && this._storedNodes.forEach((r, o) => {
      const a = n.indexOf(r);
      a === -1 ? t.push(r) : a !== o && i.push(r);
    }), (e.length || t.length || i.length) && this.callback({ addedNodes: e, currentNodes: n, movedNodes: i, removedNodes: t }), this._storedNodes = n;
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
let Oh = 0;
function Zl() {
  return Oh++;
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class ps extends EventTarget {
  /**
   * Ensure that every instance has unique ID.
   *
   * @param {HTMLElement} host
   * @param {string} slotName
   * @return {string}
   * @protected
   */
  static generateId(n, e = "default") {
    return `${e}-${n.localName}-${Zl()}`;
  }
  constructor(n, e, t, i = {}) {
    super();
    const { initializer: r, multiple: o, observe: a, useUniqueId: c, uniqueIdPrefix: u } = i;
    this.host = n, this.slotName = e, this.tagName = t, this.observe = typeof a == "boolean" ? a : !0, this.multiple = typeof o == "boolean" ? o : !1, this.slotInitializer = r, o && (this.nodes = []), c && (this.defaultId = this.constructor.generateId(n, u || e));
  }
  hostConnected() {
    this.initialized || (this.multiple ? this.initMultiple() : this.initSingle(), this.observe && this.observeSlot(), this.initialized = !0);
  }
  /** @protected */
  initSingle() {
    let n = this.getSlotChild();
    n ? (this.node = n, this.initAddedNode(n)) : (n = this.attachDefaultNode(), this.initNode(n));
  }
  /** @protected */
  initMultiple() {
    const n = this.getSlotChildren();
    if (n.length === 0) {
      const e = this.attachDefaultNode();
      e && (this.nodes = [e], this.initNode(e));
    } else
      this.nodes = n, n.forEach((e) => {
        this.initAddedNode(e);
      });
  }
  /**
   * Create and attach default node using the provided tag name, if any.
   * @return {Node | undefined}
   * @protected
   */
  attachDefaultNode() {
    const { host: n, slotName: e, tagName: t } = this;
    let i = this.defaultNode;
    return !i && t && (i = document.createElement(t), i instanceof Element && (e !== "" && i.setAttribute("slot", e), this.defaultNode = i)), i && (this.node = i, n.appendChild(i)), i;
  }
  /**
   * Return the list of nodes matching the slot managed by the controller.
   * @return {Node}
   */
  getSlotChildren() {
    const { slotName: n } = this;
    return Array.from(this.host.childNodes).filter((e) => e.nodeType === Node.ELEMENT_NODE && e.slot === n || e.nodeType === Node.TEXT_NODE && e.textContent.trim() && n === "");
  }
  /**
   * Return a reference to the node managed by the controller.
   * @return {Node}
   */
  getSlotChild() {
    return this.getSlotChildren()[0];
  }
  /**
   * Run `slotInitializer` for the node managed by the controller.
   *
   * @param {Node} node
   * @protected
   */
  initNode(n) {
    const { slotInitializer: e } = this;
    e && e(n, this.host);
  }
  /**
   * Override to initialize the newly added custom node.
   *
   * @param {Node} _node
   * @protected
   */
  initCustomNode(n) {
  }
  /**
   * Override to teardown slotted node when it's removed.
   *
   * @param {Node} _node
   * @protected
   */
  teardownNode(n) {
  }
  /**
   * Run both `initCustomNode` and `initNode` for a custom slotted node.
   *
   * @param {Node} node
   * @protected
   */
  initAddedNode(n) {
    n !== this.defaultNode && (this.initCustomNode(n), this.initNode(n));
  }
  /**
   * Setup the observer to manage slot content changes.
   * @protected
   */
  observeSlot() {
    const { slotName: n } = this, e = n === "" ? "slot:not([name])" : `slot[name=${n}]`, t = this.host.shadowRoot.querySelector(e);
    this.__slotObserver = new Kl(t, ({ addedNodes: i, removedNodes: r }) => {
      const o = this.multiple ? this.nodes : [this.node], a = i.filter((c) => !dh(c) && !o.includes(c));
      r.length && (this.nodes = o.filter((c) => !r.includes(c)), r.forEach((c) => {
        this.teardownNode(c);
      })), a && a.length > 0 && (this.multiple ? (this.defaultNode && this.defaultNode.remove(), this.nodes = [...o, ...a].filter((c) => c !== this.defaultNode), a.forEach((c) => {
        this.initAddedNode(c);
      })) : (this.node && this.node.remove(), this.node = a[0], this.initAddedNode(this.node)));
    });
  }
}
/**
 * @license
 * Copyright (c) 2022 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class Yl extends ps {
  constructor(n) {
    super(n, "tooltip"), this.setTarget(n);
  }
  /**
   * Override to initialize the newly added custom tooltip.
   *
   * @param {Node} tooltipNode
   * @protected
   * @override
   */
  initCustomNode(n) {
    n.target = this.target, this.ariaTarget !== void 0 && (n.ariaTarget = this.ariaTarget), this.context !== void 0 && (n.context = this.context), this.manual !== void 0 && (n.manual = this.manual), this.opened !== void 0 && (n.opened = this.opened), this.position !== void 0 && (n._position = this.position), this.shouldShow !== void 0 && (n.shouldShow = this.shouldShow), this.__notifyChange();
  }
  /**
   * Override to notify the host when the tooltip is removed.
   *
   * @param {Node} tooltipNode
   * @protected
   * @override
   */
  teardownNode() {
    this.__notifyChange();
  }
  /**
   * Set an HTML element for linking with the tooltip overlay
   * via `aria-describedby` attribute used by screen readers.
   * @param {HTMLElement} ariaTarget
   */
  setAriaTarget(n) {
    this.ariaTarget = n;
    const e = this.node;
    e && (e.ariaTarget = n);
  }
  /**
   * Set a context object to be used by generator.
   * @param {object} context
   */
  setContext(n) {
    this.context = n;
    const e = this.node;
    e && (e.context = n);
  }
  /**
   * Toggle manual state on the slotted tooltip.
   * @param {boolean} manual
   */
  setManual(n) {
    this.manual = n;
    const e = this.node;
    e && (e.manual = n);
  }
  /**
   * Toggle opened state on the slotted tooltip.
   * @param {boolean} opened
   */
  setOpened(n) {
    this.opened = n;
    const e = this.node;
    e && (e.opened = n);
  }
  /**
   * Set default position for the slotted tooltip.
   * This can be overridden by setting the position
   * using corresponding property or attribute.
   * @param {string} position
   */
  setPosition(n) {
    this.position = n;
    const e = this.node;
    e && (e._position = n);
  }
  /**
   * Set function used to detect whether to show
   * the tooltip based on a condition.
   * @param {Function} shouldShow
   */
  setShouldShow(n) {
    this.shouldShow = n;
    const e = this.node;
    e && (e.shouldShow = n);
  }
  /**
   * Set an HTML element to attach the tooltip to.
   * @param {HTMLElement} target
   */
  setTarget(n) {
    this.target = n;
    const e = this.node;
    e && (e.target = n);
  }
  /** @private */
  __notifyChange() {
    this.dispatchEvent(new CustomEvent("tooltip-changed", { detail: { node: this.node } }));
  }
}
/**
 * @license
 * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
const La = navigator.userAgent.match(/iP(?:hone|ad;(?: U;)? CPU) OS (\d+)/u), zh = La && La[1] >= 8, Ba = 3, Fh = {
  /**
   * The ratio of hidden tiles that should remain in the scroll direction.
   * Recommended value ~0.5, so it will distribute tiles evenly in both
   * directions.
   */
  _ratio: 0.5,
  /**
   * The padding-top value for the list.
   */
  _scrollerPaddingTop: 0,
  /**
   * This value is a cached value of `scrollTop` from the last `scroll` event.
   */
  _scrollPosition: 0,
  /**
   * The sum of the heights of all the tiles in the DOM.
   */
  _physicalSize: 0,
  /**
   * The average `offsetHeight` of the tiles observed till now.
   */
  _physicalAverage: 0,
  /**
   * The number of tiles which `offsetHeight` > 0 observed until now.
   */
  _physicalAverageCount: 0,
  /**
   * The Y position of the item rendered in the `_physicalStart`
   * tile relative to the scrolling list.
   */
  _physicalTop: 0,
  /**
   * The number of items in the list.
   */
  _virtualCount: 0,
  /**
   * The estimated scroll height based on `_physicalAverage`
   */
  _estScrollHeight: 0,
  /**
   * The scroll height of the dom node
   */
  _scrollHeight: 0,
  /**
   * The height of the list. This is referred as the viewport in the context of
   * list.
   */
  _viewportHeight: 0,
  /**
   * The width of the list. This is referred as the viewport in the context of
   * list.
   */
  _viewportWidth: 0,
  /**
   * An array of DOM nodes that are currently in the tree
   * @type {?Array<!HTMLElement>}
   */
  _physicalItems: null,
  /**
   * An array of heights for each item in `_physicalItems`
   * @type {?Array<number>}
   */
  _physicalSizes: null,
  /**
   * A cached value for the first visible index.
   * See `firstVisibleIndex`
   * @type {?number}
   */
  _firstVisibleIndexVal: null,
  /**
   * A cached value for the last visible index.
   * See `lastVisibleIndex`
   * @type {?number}
   */
  _lastVisibleIndexVal: null,
  /**
   * The max number of pages to render. One page is equivalent to the height of
   * the list.
   */
  _maxPages: 2,
  /**
   * The cost of stamping a template in ms.
   */
  _templateCost: 0,
  /**
   * The bottom of the physical content.
   */
  get _physicalBottom() {
    return this._physicalTop + this._physicalSize;
  },
  /**
   * The bottom of the scroll.
   */
  get _scrollBottom() {
    return this._scrollPosition + this._viewportHeight;
  },
  /**
   * The n-th item rendered in the last physical item.
   */
  get _virtualEnd() {
    return this._virtualStart + this._physicalCount - 1;
  },
  /**
   * The height of the physical content that isn't on the screen.
   */
  get _hiddenContentSize() {
    return this._physicalSize - this._viewportHeight;
  },
  /**
   * The maximum scroll top value.
   */
  get _maxScrollTop() {
    return this._estScrollHeight - this._viewportHeight + this._scrollOffset;
  },
  /**
   * The largest n-th value for an item such that it can be rendered in
   * `_physicalStart`.
   */
  get _maxVirtualStart() {
    const s = this._virtualCount;
    return Math.max(0, s - this._physicalCount);
  },
  get _virtualStart() {
    return this._virtualStartVal || 0;
  },
  set _virtualStart(s) {
    s = this._clamp(s, 0, this._maxVirtualStart), this._virtualStartVal = s;
  },
  get _physicalStart() {
    return this._physicalStartVal || 0;
  },
  /**
   * The k-th tile that is at the top of the scrolling list.
   */
  set _physicalStart(s) {
    s %= this._physicalCount, s < 0 && (s = this._physicalCount + s), this._physicalStartVal = s;
  },
  /**
   * The k-th tile that is at the bottom of the scrolling list.
   */
  get _physicalEnd() {
    return (this._physicalStart + this._physicalCount - 1) % this._physicalCount;
  },
  get _physicalCount() {
    return this._physicalCountVal || 0;
  },
  set _physicalCount(s) {
    this._physicalCountVal = s;
  },
  /**
   * An optimal physical size such that we will have enough physical items
   * to fill up the viewport and recycle when the user scrolls.
   *
   * This default value assumes that we will at least have the equivalent
   * to a viewport of physical items above and below the user's viewport.
   */
  get _optPhysicalSize() {
    return this._viewportHeight === 0 ? 1 / 0 : this._viewportHeight * this._maxPages;
  },
  /**
   * True if the current list is visible.
   */
  get _isVisible() {
    return !!(this.offsetWidth || this.offsetHeight);
  },
  /**
   * Gets the index of the first visible item in the viewport.
   *
   * @type {number}
   */
  get firstVisibleIndex() {
    let s = this._firstVisibleIndexVal;
    if (s == null) {
      let n = this._physicalTop + this._scrollOffset;
      s = this._iterateItems((e, t) => {
        if (n += this._getPhysicalSizeIncrement(e), n > this._scrollPosition)
          return t;
      }) || 0, this._firstVisibleIndexVal = s;
    }
    return s;
  },
  /**
   * Gets the index of the last visible item in the viewport.
   *
   * @type {number}
   */
  get lastVisibleIndex() {
    let s = this._lastVisibleIndexVal;
    if (s == null) {
      let n = this._physicalTop + this._scrollOffset;
      this._iterateItems((e, t) => {
        n < this._scrollBottom && (s = t), n += this._getPhysicalSizeIncrement(e);
      }), this._lastVisibleIndexVal = s;
    }
    return s;
  },
  get _scrollOffset() {
    return this._scrollerPaddingTop + this.scrollOffset;
  },
  /**
   * Recycles the physical items when needed.
   */
  _scrollHandler() {
    const s = Math.max(0, Math.min(this._maxScrollTop, this._scrollTop));
    let n = s - this._scrollPosition;
    const e = n >= 0;
    if (this._scrollPosition = s, this._firstVisibleIndexVal = null, this._lastVisibleIndexVal = null, Math.abs(n) > this._physicalSize && this._physicalSize > 0) {
      n -= this._scrollOffset;
      const t = Math.round(n / this._physicalAverage);
      this._virtualStart += t, this._physicalStart += t, this._physicalTop = Math.min(Math.floor(this._virtualStart) * this._physicalAverage, this._scrollPosition), this._update();
    } else if (this._physicalCount > 0) {
      const t = this._getReusables(e);
      e ? (this._physicalTop = t.physicalTop, this._virtualStart += t.indexes.length, this._physicalStart += t.indexes.length) : (this._virtualStart -= t.indexes.length, this._physicalStart -= t.indexes.length), this._update(t.indexes, e ? null : t.indexes), this._debounce("_increasePoolIfNeeded", this._increasePoolIfNeeded.bind(this, 0), yt);
    }
  },
  /**
   * Returns an object that contains the indexes of the physical items
   * that might be reused and the physicalTop.
   *
   * @param {boolean} fromTop If the potential reusable items are above the scrolling region.
   */
  _getReusables(s) {
    let n, e, t;
    const i = [], r = this._hiddenContentSize * this._ratio, o = this._virtualStart, a = this._virtualEnd, c = this._physicalCount;
    let u = this._physicalTop + this._scrollOffset;
    const h = this._physicalBottom + this._scrollOffset, f = this._scrollPosition, g = this._scrollBottom;
    for (s ? (n = this._physicalStart, e = f - u) : (n = this._physicalEnd, e = h - g); t = this._getPhysicalSizeIncrement(n), e -= t, !(i.length >= c || e <= r); )
      if (s) {
        if (a + i.length + 1 >= this._virtualCount || u + t >= f - this._scrollOffset)
          break;
        i.push(n), u += t, n = (n + 1) % c;
      } else {
        if (o - i.length <= 0 || u + this._physicalSize - t <= g)
          break;
        i.push(n), u -= t, n = n === 0 ? c - 1 : n - 1;
      }
    return { indexes: i, physicalTop: u - this._scrollOffset };
  },
  /**
   * Update the list of items, starting from the `_virtualStart` item.
   * @param {!Array<number>=} itemSet
   * @param {!Array<number>=} movingUp
   */
  _update(s, n) {
    if (!(s && s.length === 0 || this._physicalCount === 0)) {
      if (this._assignModels(s), this._updateMetrics(s), n)
        for (; n.length; ) {
          const e = n.pop();
          this._physicalTop -= this._getPhysicalSizeIncrement(e);
        }
      this._positionItems(), this._updateScrollerSize();
    }
  },
  _isClientFull() {
    return this._scrollBottom !== 0 && this._physicalBottom - 1 >= this._scrollBottom && this._physicalTop <= this._scrollPosition;
  },
  /**
   * Increases the pool size.
   */
  _increasePoolIfNeeded(s) {
    const e = this._clamp(
      this._physicalCount + s,
      Ba,
      this._virtualCount - this._virtualStart
    ) - this._physicalCount;
    let t = Math.round(this._physicalCount * 0.5);
    if (!(e < 0)) {
      if (e > 0) {
        const i = window.performance.now();
        [].push.apply(this._physicalItems, this._createPool(e));
        for (let r = 0; r < e; r++)
          this._physicalSizes.push(0);
        this._physicalCount += e, this._physicalStart > this._physicalEnd && this._isIndexRendered(this._focusedVirtualIndex) && this._getPhysicalIndex(this._focusedVirtualIndex) < this._physicalEnd && (this._physicalStart += e), this._update(), this._templateCost = (window.performance.now() - i) / e, t = Math.round(this._physicalCount * 0.5);
      }
      this._virtualEnd >= this._virtualCount - 1 || t === 0 || (this._isClientFull() ? this._physicalSize < this._optPhysicalSize && this._debounce(
        "_increasePoolIfNeeded",
        this._increasePoolIfNeeded.bind(this, this._clamp(Math.round(50 / this._templateCost), 1, t)),
        Ml
      ) : this._debounce("_increasePoolIfNeeded", this._increasePoolIfNeeded.bind(this, t), yt));
    }
  },
  /**
   * Renders the a new list.
   */
  _render() {
    if (!(!this.isAttached || !this._isVisible))
      if (this._physicalCount !== 0) {
        const s = this._getReusables(!0);
        this._physicalTop = s.physicalTop, this._virtualStart += s.indexes.length, this._physicalStart += s.indexes.length, this._update(s.indexes), this._update(), this._increasePoolIfNeeded(0);
      } else this._virtualCount > 0 && (this.updateViewportBoundaries(), this._increasePoolIfNeeded(Ba));
  },
  /**
   * Called when the items have changed. That is, reassignments
   * to `items`, splices or updates to a single item.
   */
  _itemsChanged(s) {
    s.path === "items" && (this._virtualStart = 0, this._physicalTop = 0, this._virtualCount = this.items ? this.items.length : 0, this._physicalIndexForKey = {}, this._firstVisibleIndexVal = null, this._lastVisibleIndexVal = null, this._physicalItems || (this._physicalItems = []), this._physicalSizes || (this._physicalSizes = []), this._physicalStart = 0, this._scrollTop > this._scrollOffset && this._resetScrollPosition(0), this._debounce("_render", this._render, qt));
  },
  /**
   * Executes a provided function per every physical index in `itemSet`
   * `itemSet` default value is equivalent to the entire set of physical
   * indexes.
   *
   * @param {!function(number, number)} fn
   * @param {!Array<number>=} itemSet
   */
  _iterateItems(s, n) {
    let e, t, i, r;
    if (arguments.length === 2 && n) {
      for (r = 0; r < n.length; r++)
        if (e = n[r], t = this._computeVidx(e), (i = s.call(this, e, t)) != null)
          return i;
    } else {
      for (e = this._physicalStart, t = this._virtualStart; e < this._physicalCount; e++, t++)
        if ((i = s.call(this, e, t)) != null)
          return i;
      for (e = 0; e < this._physicalStart; e++, t++)
        if ((i = s.call(this, e, t)) != null)
          return i;
    }
  },
  /**
   * Returns the virtual index for a given physical index
   *
   * @param {number} pidx Physical index
   * @return {number}
   */
  _computeVidx(s) {
    return s >= this._physicalStart ? this._virtualStart + (s - this._physicalStart) : this._virtualStart + (this._physicalCount - this._physicalStart) + s;
  },
  /**
   * Updates the position of the physical items.
   */
  _positionItems() {
    this._adjustScrollPosition();
    let s = this._physicalTop;
    this._iterateItems((n) => {
      this.translate3d(0, `${s}px`, 0, this._physicalItems[n]), s += this._physicalSizes[n];
    });
  },
  _getPhysicalSizeIncrement(s) {
    return this._physicalSizes[s];
  },
  /**
   * Adjusts the scroll position when it was overestimated.
   */
  _adjustScrollPosition() {
    const s = this._virtualStart === 0 ? this._physicalTop : Math.min(this._scrollPosition + this._physicalTop, 0);
    if (s !== 0) {
      this._physicalTop -= s;
      const n = this._scrollPosition;
      !zh && n > 0 && this._resetScrollPosition(n - s);
    }
  },
  /**
   * Sets the position of the scroll.
   */
  _resetScrollPosition(s) {
    this.scrollTarget && s >= 0 && (this._scrollTop = s, this._scrollPosition = this._scrollTop);
  },
  /**
   * Sets the scroll height, that's the height of the content,
   *
   * @param {boolean=} forceUpdate If true, updates the height no matter what.
   */
  _updateScrollerSize(s) {
    const n = this._physicalBottom + Math.max(this._virtualCount - this._physicalCount - this._virtualStart, 0) * this._physicalAverage;
    this._estScrollHeight = n, (s || this._scrollHeight === 0 || this._scrollPosition >= n - this._physicalSize || Math.abs(n - this._scrollHeight) >= this._viewportHeight) && (this.$.items.style.height = `${n}px`, this._scrollHeight = n);
  },
  /**
   * Scroll to a specific index in the virtual list regardless
   * of the physical items in the DOM tree.
   *
   * @method scrollToIndex
   * @param {number} idx The index of the item
   */
  scrollToIndex(s) {
    if (typeof s != "number" || s < 0 || s > this.items.length - 1 || (lr(), this._physicalCount === 0))
      return;
    s = this._clamp(s, 0, this._virtualCount - 1), (!this._isIndexRendered(s) || s >= this._maxVirtualStart) && (this._virtualStart = s - 1), this._assignModels(), this._updateMetrics(), this._physicalTop = this._virtualStart * this._physicalAverage;
    let n = this._physicalStart, e = this._virtualStart, t = 0;
    const i = this._hiddenContentSize;
    for (; e < s && t <= i; )
      t += this._getPhysicalSizeIncrement(n), n = (n + 1) % this._physicalCount, e += 1;
    this._updateScrollerSize(!0), this._positionItems(), this._resetScrollPosition(this._physicalTop + this._scrollOffset + t), this._increasePoolIfNeeded(0), this._firstVisibleIndexVal = null, this._lastVisibleIndexVal = null;
  },
  /**
   * Reset the physical average and the average count.
   */
  _resetAverage() {
    this._physicalAverage = 0, this._physicalAverageCount = 0;
  },
  /**
   * A handler for the `iron-resize` event triggered by `IronResizableBehavior`
   * when the element is resized.
   */
  _resizeHandler() {
    this._debounce(
      "_render",
      () => {
        this._firstVisibleIndexVal = null, this._lastVisibleIndexVal = null, this._isVisible ? (this.updateViewportBoundaries(), this.toggleScrollListener(!0), this._resetAverage(), this._render()) : this.toggleScrollListener(!1);
      },
      qt
    );
  },
  _isIndexRendered(s) {
    return s >= this._virtualStart && s <= this._virtualEnd;
  },
  _getPhysicalIndex(s) {
    return (this._physicalStart + (s - this._virtualStart)) % this._physicalCount;
  },
  _clamp(s, n, e) {
    return Math.min(e, Math.max(n, s));
  },
  _debounce(s, n, e) {
    this._debouncers || (this._debouncers = {}), this._debouncers[s] = Me.debounce(this._debouncers[s], e, n.bind(this)), Ll(this._debouncers[s]);
  }
};
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Mh = 1e5, bo = 1e3;
class Xl {
  constructor({ createElements: n, updateElement: e, scrollTarget: t, scrollContainer: i, elementsContainer: r, reorderElements: o }) {
    this.isAttached = !0, this._vidxOffset = 0, this.createElements = n, this.updateElement = e, this.scrollTarget = t, this.scrollContainer = i, this.elementsContainer = r || i, this.reorderElements = o, this._maxPages = 1.3, this.__placeholderHeight = 200, this.__elementHeightQueue = Array(10), this.timeouts = {
      SCROLL_REORDER: 500,
      IGNORE_WHEEL: 500,
      FIX_INVALID_ITEM_POSITIONING: 100
    }, this.__resizeObserver = new ResizeObserver(() => this._resizeHandler()), getComputedStyle(this.scrollTarget).overflow === "visible" && (this.scrollTarget.style.overflow = "auto"), getComputedStyle(this.scrollContainer).position === "static" && (this.scrollContainer.style.position = "relative"), this.__resizeObserver.observe(this.scrollTarget), this.scrollTarget.addEventListener("scroll", () => this._scrollHandler()), this._scrollLineHeight = this._getScrollLineHeight(), this.scrollTarget.addEventListener("wheel", (a) => this.__onWheel(a)), this.scrollTarget.addEventListener("virtualizer-element-focused", (a) => this.__onElementFocused(a)), this.elementsContainer.addEventListener("focusin", () => {
      this.scrollTarget.dispatchEvent(
        new CustomEvent("virtualizer-element-focused", { detail: { element: this.__getFocusedElement() } })
      );
    }), this.reorderElements && (this.scrollTarget.addEventListener("mousedown", () => {
      this.__mouseDown = !0;
    }), this.scrollTarget.addEventListener("mouseup", () => {
      this.__mouseDown = !1, this.__pendingReorder && this.__reorderElements();
    }));
  }
  get scrollOffset() {
    return 0;
  }
  get adjustedFirstVisibleIndex() {
    return this.firstVisibleIndex + this._vidxOffset;
  }
  get adjustedLastVisibleIndex() {
    return this.lastVisibleIndex + this._vidxOffset;
  }
  get _maxVirtualIndexOffset() {
    return this.size - this._virtualCount;
  }
  __hasPlaceholders() {
    return this.__getVisibleElements().some((n) => n.__virtualizerPlaceholder);
  }
  scrollToIndex(n) {
    if (typeof n != "number" || isNaN(n) || this.size === 0 || !this.scrollTarget.offsetHeight)
      return;
    delete this.__pendingScrollToIndex, this._physicalCount <= 3 && this.flush(), n = this._clamp(n, 0, this.size - 1);
    const e = this.__getVisibleElements().length;
    let t = Math.floor(n / this.size * this._virtualCount);
    this._virtualCount - t < e ? (t = this._virtualCount - (this.size - n), this._vidxOffset = this._maxVirtualIndexOffset) : t < e ? n < bo ? (t = n, this._vidxOffset = 0) : (t = bo, this._vidxOffset = n - t) : this._vidxOffset = n - t, this.__skipNextVirtualIndexAdjust = !0, super.scrollToIndex(t), this.adjustedFirstVisibleIndex !== n && this._scrollTop < this._maxScrollTop && !this.grid && (this._scrollTop -= this.__getIndexScrollOffset(n) || 0), this._scrollHandler(), this.__hasPlaceholders() && (this.__pendingScrollToIndex = n);
  }
  flush() {
    this.scrollTarget.offsetHeight !== 0 && (this._resizeHandler(), lr(), this._scrollHandler(), this.__fixInvalidItemPositioningDebouncer && this.__fixInvalidItemPositioningDebouncer.flush(), this.__scrollReorderDebouncer && this.__scrollReorderDebouncer.flush(), this.__debouncerWheelAnimationFrame && this.__debouncerWheelAnimationFrame.flush());
  }
  update(n = 0, e = this.size - 1) {
    const t = [];
    this.__getVisibleElements().forEach((i) => {
      i.__virtualIndex >= n && i.__virtualIndex <= e && (this.__updateElement(i, i.__virtualIndex, !0), t.push(i));
    }), this.__afterElementsUpdated(t);
  }
  /**
   * Updates the height for a given set of items.
   *
   * @param {!Array<number>=} itemSet
   */
  _updateMetrics(n) {
    lr();
    let e = 0, t = 0;
    const i = this._physicalAverageCount, r = this._physicalAverage;
    this._iterateItems((o, a) => {
      t += this._physicalSizes[o], this._physicalSizes[o] = Math.ceil(this.__getBorderBoxHeight(this._physicalItems[o])), e += this._physicalSizes[o], this._physicalAverageCount += this._physicalSizes[o] ? 1 : 0;
    }, n), this._physicalSize = this._physicalSize + e - t, this._physicalAverageCount !== i && (this._physicalAverage = Math.round(
      (r * i + e) / this._physicalAverageCount
    ));
  }
  __getBorderBoxHeight(n) {
    const e = getComputedStyle(n), t = parseFloat(e.height) || 0;
    if (e.boxSizing === "border-box")
      return t;
    const i = parseFloat(e.paddingBottom) || 0, r = parseFloat(e.paddingTop) || 0, o = parseFloat(e.borderBottomWidth) || 0, a = parseFloat(e.borderTopWidth) || 0;
    return t + i + r + o + a;
  }
  __updateElement(n, e, t) {
    n.__virtualizerPlaceholder && (n.style.paddingTop = "", n.style.opacity = "", n.__virtualizerPlaceholder = !1), !this.__preventElementUpdates && (n.__lastUpdatedIndex !== e || t) && (this.updateElement(n, e), n.__lastUpdatedIndex = e);
  }
  /**
   * Called synchronously right after elements have been updated.
   * This is a good place to do any post-update work.
   *
   * @param {!Array<!HTMLElement>} updatedElements
   */
  __afterElementsUpdated(n) {
    n.forEach((e) => {
      const t = e.offsetHeight;
      if (t === 0)
        e.style.paddingTop = `${this.__placeholderHeight}px`, e.style.opacity = "0", e.__virtualizerPlaceholder = !0, this.__placeholderClearDebouncer = Me.debounce(
          this.__placeholderClearDebouncer,
          qt,
          () => this._resizeHandler()
        );
      else {
        this.__elementHeightQueue.push(t), this.__elementHeightQueue.shift();
        const i = this.__elementHeightQueue.filter((r) => r !== void 0);
        this.__placeholderHeight = Math.round(i.reduce((r, o) => r + o, 0) / i.length);
      }
    }), this.__pendingScrollToIndex !== void 0 && !this.__hasPlaceholders() && this.scrollToIndex(this.__pendingScrollToIndex);
  }
  __getIndexScrollOffset(n) {
    const e = this.__getVisibleElements().find((t) => t.__virtualIndex === n);
    return e ? this.scrollTarget.getBoundingClientRect().top - e.getBoundingClientRect().top : void 0;
  }
  get size() {
    return this.__size;
  }
  set size(n) {
    if (n === this.size)
      return;
    this.__fixInvalidItemPositioningDebouncer && this.__fixInvalidItemPositioningDebouncer.cancel(), this._debouncers && this._debouncers._increasePoolIfNeeded && this._debouncers._increasePoolIfNeeded.cancel(), this.__preventElementUpdates = !0;
    let e, t;
    if (n > 0 && (e = this.adjustedFirstVisibleIndex, t = this.__getIndexScrollOffset(e)), this.__size = n, this._itemsChanged({
      path: "items"
    }), lr(), n > 0) {
      e = Math.min(e, n - 1), this.scrollToIndex(e);
      const i = this.__getIndexScrollOffset(e);
      t !== void 0 && i !== void 0 && (this._scrollTop += t - i);
    }
    this.__preventElementUpdates = !1, this._isVisible || this._assignModels(), this.elementsContainer.children.length || requestAnimationFrame(() => this._resizeHandler()), this._resizeHandler(), lr(), this._debounce("_update", this._update, yt);
  }
  /** @private */
  get _scrollTop() {
    return this.scrollTarget.scrollTop;
  }
  /** @private */
  set _scrollTop(n) {
    this.scrollTarget.scrollTop = n;
  }
  /** @private */
  get items() {
    return {
      length: Math.min(this.size, Mh)
    };
  }
  /** @private */
  get offsetHeight() {
    return this.scrollTarget.offsetHeight;
  }
  /** @private */
  get $() {
    return {
      items: this.scrollContainer
    };
  }
  /** @private */
  updateViewportBoundaries() {
    const n = window.getComputedStyle(this.scrollTarget);
    this._scrollerPaddingTop = this.scrollTarget === this ? 0 : parseInt(n["padding-top"], 10), this._isRTL = n.direction === "rtl", this._viewportWidth = this.elementsContainer.offsetWidth, this._viewportHeight = this.scrollTarget.offsetHeight, this._scrollPageHeight = this._viewportHeight - this._scrollLineHeight, this.grid && this._updateGridMetrics();
  }
  /** @private */
  setAttribute() {
  }
  /** @private */
  _createPool(n) {
    const e = this.createElements(n), t = document.createDocumentFragment();
    return e.forEach((i) => {
      i.style.position = "absolute", t.appendChild(i), this.__resizeObserver.observe(i);
    }), this.elementsContainer.appendChild(t), e;
  }
  /** @private */
  _assignModels(n) {
    const e = [];
    this._iterateItems((t, i) => {
      const r = this._physicalItems[t];
      r.hidden = i >= this.size, r.hidden ? delete r.__lastUpdatedIndex : (r.__virtualIndex = i + (this._vidxOffset || 0), this.__updateElement(r, r.__virtualIndex), e.push(r));
    }, n), this.__afterElementsUpdated(e);
  }
  /** @private */
  _isClientFull() {
    return setTimeout(() => {
      this.__clientFull = !0;
    }), this.__clientFull || super._isClientFull();
  }
  /** @private */
  translate3d(n, e, t, i) {
    i.style.transform = `translateY(${e})`;
  }
  /** @private */
  toggleScrollListener() {
  }
  /** @private */
  __getFocusedElement(n = this.__getVisibleElements()) {
    return n.find(
      (e) => e.contains(this.elementsContainer.getRootNode().activeElement) || e.contains(this.scrollTarget.getRootNode().activeElement)
    );
  }
  /** @private */
  __nextFocusableSiblingMissing(n, e) {
    return (
      // Check if focused element is the last visible DOM element
      e.indexOf(n) === e.length - 1 && // ...while there are more items available
      this.size > n.__virtualIndex + 1
    );
  }
  /** @private */
  __previousFocusableSiblingMissing(n, e) {
    return (
      // Check if focused element is the first visible DOM element
      e.indexOf(n) === 0 && // ...while there are preceding items available
      n.__virtualIndex > 0
    );
  }
  /** @private */
  __onElementFocused(n) {
    if (!this.reorderElements)
      return;
    const e = n.detail.element;
    if (!e)
      return;
    const t = this.__getVisibleElements();
    (this.__previousFocusableSiblingMissing(e, t) || this.__nextFocusableSiblingMissing(e, t)) && this.flush();
    const i = this.__getVisibleElements();
    this.__nextFocusableSiblingMissing(e, i) ? (this._scrollTop += Math.ceil(e.getBoundingClientRect().bottom) - Math.floor(this.scrollTarget.getBoundingClientRect().bottom - 1), this.flush()) : this.__previousFocusableSiblingMissing(e, i) && (this._scrollTop -= Math.ceil(this.scrollTarget.getBoundingClientRect().top + 1) - Math.floor(e.getBoundingClientRect().top), this.flush());
  }
  _scrollHandler() {
    if (this.scrollTarget.offsetHeight === 0)
      return;
    this._adjustVirtualIndexOffset(this._scrollTop - (this.__previousScrollTop || 0));
    const n = this.scrollTarget.scrollTop - this._scrollPosition;
    if (super._scrollHandler(), this._physicalCount !== 0) {
      const e = n >= 0, t = this._getReusables(!e);
      t.indexes.length && (this._physicalTop = t.physicalTop, e ? (this._virtualStart -= t.indexes.length, this._physicalStart -= t.indexes.length) : (this._virtualStart += t.indexes.length, this._physicalStart += t.indexes.length), this._resizeHandler());
    }
    n && (this.__fixInvalidItemPositioningDebouncer = Me.debounce(
      this.__fixInvalidItemPositioningDebouncer,
      zt.after(this.timeouts.FIX_INVALID_ITEM_POSITIONING),
      () => this.__fixInvalidItemPositioning()
    )), this.reorderElements && (this.__scrollReorderDebouncer = Me.debounce(
      this.__scrollReorderDebouncer,
      zt.after(this.timeouts.SCROLL_REORDER),
      () => this.__reorderElements()
    )), this.__previousScrollTop = this._scrollTop, this._scrollTop === 0 && this.firstVisibleIndex !== 0 && Math.abs(n) > 0 && this.scrollToIndex(0);
  }
  /**
   * Work around an iron-list issue with invalid item positioning.
   * See https://github.com/vaadin/flow-components/issues/4306
   * @private
   */
  __fixInvalidItemPositioning() {
    if (!this.scrollTarget.isConnected)
      return;
    const n = this._physicalTop > this._scrollTop, e = this._physicalBottom < this._scrollBottom, t = this.adjustedFirstVisibleIndex === 0, i = this.adjustedLastVisibleIndex === this.size - 1;
    if (n && !t || e && !i) {
      const r = e, o = this._ratio;
      this._ratio = 0, this._scrollPosition = this._scrollTop + (r ? -1 : 1), this._scrollHandler(), this._ratio = o;
    }
  }
  /** @private */
  __onWheel(n) {
    if (n.ctrlKey || this._hasScrolledAncestor(n.target, n.deltaX, n.deltaY))
      return;
    let e = n.deltaY;
    if (n.deltaMode === WheelEvent.DOM_DELTA_LINE ? e *= this._scrollLineHeight : n.deltaMode === WheelEvent.DOM_DELTA_PAGE && (e *= this._scrollPageHeight), this._deltaYAcc || (this._deltaYAcc = 0), this._wheelAnimationFrame) {
      this._deltaYAcc += e, n.preventDefault();
      return;
    }
    e += this._deltaYAcc, this._deltaYAcc = 0, this._wheelAnimationFrame = !0, this.__debouncerWheelAnimationFrame = Me.debounce(
      this.__debouncerWheelAnimationFrame,
      qt,
      () => {
        this._wheelAnimationFrame = !1;
      }
    );
    const t = Math.abs(n.deltaX) + Math.abs(e);
    this._canScroll(this.scrollTarget, n.deltaX, e) ? (n.preventDefault(), this.scrollTarget.scrollTop += e, this.scrollTarget.scrollLeft += n.deltaX, this._hasResidualMomentum = !0, this._ignoreNewWheel = !0, this._debouncerIgnoreNewWheel = Me.debounce(
      this._debouncerIgnoreNewWheel,
      zt.after(this.timeouts.IGNORE_WHEEL),
      () => {
        this._ignoreNewWheel = !1;
      }
    )) : this._hasResidualMomentum && t <= this._previousMomentum || this._ignoreNewWheel ? n.preventDefault() : t > this._previousMomentum && (this._hasResidualMomentum = !1), this._previousMomentum = t;
  }
  /**
   * Determines if the element has an ancestor that handles the scroll delta prior to this
   *
   * @private
   */
  _hasScrolledAncestor(n, e, t) {
    if (n === this.scrollTarget || n === this.scrollTarget.getRootNode().host)
      return !1;
    if (this._canScroll(n, e, t) && ["auto", "scroll"].indexOf(getComputedStyle(n).overflow) !== -1)
      return !0;
    if (n !== this && n.parentElement)
      return this._hasScrolledAncestor(n.parentElement, e, t);
  }
  _canScroll(n, e, t) {
    return t > 0 && n.scrollTop < n.scrollHeight - n.offsetHeight || t < 0 && n.scrollTop > 0 || e > 0 && n.scrollLeft < n.scrollWidth - n.offsetWidth || e < 0 && n.scrollLeft > 0;
  }
  /**
   * Increases the pool size.
   * @override
   */
  _increasePoolIfNeeded(n) {
    if (this._physicalCount > 2 && n) {
      const t = Math.ceil(this._optPhysicalSize / this._physicalAverage) - this._physicalCount;
      super._increasePoolIfNeeded(Math.max(n, Math.min(100, t)));
    } else
      super._increasePoolIfNeeded(n);
  }
  /**
   * An optimal physical size such that we will have enough physical items
   * to fill up the viewport and recycle when the user scrolls.
   *
   * This default value assumes that we will at least have the equivalent
   * to a viewport of physical items above and below the user's viewport.
   * @override
   */
  get _optPhysicalSize() {
    const n = super._optPhysicalSize;
    return n <= 0 || this.__hasPlaceholders() ? n : n + this.__getItemHeightBuffer();
  }
  /**
   * Extra item height buffer used when calculating optimal physical size.
   *
   * The iron list core uses the optimal physical size when determining whether to increase the item pool.
   * For the cases where some items are much larger than the average, the iron list core might not increase item pool.
   * This can lead to the large item not being rendered.
   *
   * @returns {Number} - Extra item height buffer
   * @private
   */
  __getItemHeightBuffer() {
    if (this._physicalCount === 0)
      return 0;
    const n = Math.ceil(this._viewportHeight * (this._maxPages - 1) / 2), e = Math.max(...this._physicalSizes);
    return e > Math.min(...this._physicalSizes) ? Math.max(0, e - n) : 0;
  }
  /**
   * @returns {Number|undefined} - The browser's default font-size in pixels
   * @private
   */
  _getScrollLineHeight() {
    const n = document.createElement("div");
    n.style.fontSize = "initial", n.style.display = "none", document.body.appendChild(n);
    const e = window.getComputedStyle(n).fontSize;
    return document.body.removeChild(n), e ? window.parseInt(e) : void 0;
  }
  __getVisibleElements() {
    return Array.from(this.elementsContainer.children).filter((n) => !n.hidden);
  }
  /** @private */
  __reorderElements() {
    if (this.__mouseDown) {
      this.__pendingReorder = !0;
      return;
    }
    this.__pendingReorder = !1;
    const n = this._virtualStart + (this._vidxOffset || 0), e = this.__getVisibleElements(), t = this.__getFocusedElement(e) || e[0];
    if (!t)
      return;
    const i = t.__virtualIndex - n, r = e.indexOf(t) - i;
    if (r > 0)
      for (let o = 0; o < r; o++)
        this.elementsContainer.appendChild(e[o]);
    else if (r < 0)
      for (let o = e.length + r; o < e.length; o++)
        this.elementsContainer.insertBefore(e[o], e[0]);
    if (ql) {
      const { transform: o } = this.scrollTarget.style;
      this.scrollTarget.style.transform = "translateZ(0)", setTimeout(() => {
        this.scrollTarget.style.transform = o;
      });
    }
  }
  /** @private */
  _adjustVirtualIndexOffset(n) {
    const e = this._maxVirtualIndexOffset;
    if (this._virtualCount >= this.size)
      this._vidxOffset = 0;
    else if (this.__skipNextVirtualIndexAdjust)
      this.__skipNextVirtualIndexAdjust = !1;
    else if (Math.abs(n) > 1e4) {
      const t = this._scrollTop / (this.scrollTarget.scrollHeight - this.scrollTarget.clientHeight);
      this._vidxOffset = Math.round(t * e);
    } else {
      const t = this._vidxOffset, i = bo, r = 100;
      this._scrollTop === 0 ? (this._vidxOffset = 0, t !== this._vidxOffset && super.scrollToIndex(0)) : this.firstVisibleIndex < i && this._vidxOffset > 0 && (this._vidxOffset -= Math.min(this._vidxOffset, r), super.scrollToIndex(this.firstVisibleIndex + (t - this._vidxOffset))), this._scrollTop >= this._maxScrollTop && this._maxScrollTop > 0 ? (this._vidxOffset = e, t !== this._vidxOffset && super.scrollToIndex(this._virtualCount - 1)) : this.firstVisibleIndex > this._virtualCount - i && this._vidxOffset < e && (this._vidxOffset += Math.min(e - this._vidxOffset, r), super.scrollToIndex(this.firstVisibleIndex - (this._vidxOffset - t)));
    }
  }
}
Object.setPrototypeOf(Xl.prototype, Fh);
class Ql {
  /**
   * @typedef {Object} VirtualizerConfig
   * @property {Function} createElements Function that returns the given number of new elements
   * @property {Function} updateElement Function that updates the element at a specific index
   * @property {HTMLElement} scrollTarget Reference to the scrolling element
   * @property {HTMLElement} scrollContainer Reference to a wrapper for the item elements (or a slot) inside the scrollTarget
   * @property {HTMLElement | undefined} elementsContainer Reference to the container in which the item elements are placed, defaults to scrollContainer
   * @property {boolean | undefined} reorderElements Determines whether the physical item elements should be kept in order in the DOM
   * @param {VirtualizerConfig} config Configuration for the virtualizer
   */
  constructor(n) {
    this.__adapter = new Xl(n);
  }
  /**
   * Gets the index of the first visible item in the viewport.
   *
   * @return {number}
   */
  get firstVisibleIndex() {
    return this.__adapter.adjustedFirstVisibleIndex;
  }
  /**
   * Gets the index of the last visible item in the viewport.
   *
   * @return {number}
   */
  get lastVisibleIndex() {
    return this.__adapter.adjustedLastVisibleIndex;
  }
  /**
   * The size of the virtualizer
   * @return {number | undefined} The size of the virtualizer
   */
  get size() {
    return this.__adapter.size;
  }
  /**
   * The size of the virtualizer
   * @param {number} size The size of the virtualizer
   */
  set size(n) {
    this.__adapter.size = n;
  }
  /**
   * Scroll to a specific index in the virtual list
   *
   * @method scrollToIndex
   * @param {number} index The index of the item
   */
  scrollToIndex(n) {
    this.__adapter.scrollToIndex(n);
  }
  /**
   * Requests the virtualizer to re-render the item elements on an index range, if currently in the DOM
   *
   * @method update
   * @param {number | undefined} startIndex The start index of the range
   * @param {number | undefined} endIndex The end index of the range
   */
  update(n = 0, e = this.size - 1) {
    this.__adapter.update(n, e);
  }
  /**
   * Flushes active asynchronous tasks so that the component and the DOM end up in a stable state
   *
   * @method update
   * @param {number | undefined} startIndex The start index of the range
   * @param {number | undefined} endIndex The end index of the range
   */
  flush() {
    this.__adapter.flush();
  }
}
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Lh = (s) => class extends s {
  static get observers() {
    return ["_a11yUpdateGridSize(size, _columnTree)"];
  }
  /** @private */
  _a11yGetHeaderRowCount(e) {
    return e.filter(
      (t) => t.some((i) => i.headerRenderer || i.path && i.header !== null || i.header)
    ).length;
  }
  /** @private */
  _a11yGetFooterRowCount(e) {
    return e.filter((t) => t.some((i) => i.headerRenderer)).length;
  }
  /** @private */
  _a11yUpdateGridSize(e, t) {
    if (e === void 0 || t === void 0)
      return;
    const i = t[t.length - 1];
    this.$.table.setAttribute(
      "aria-rowcount",
      e + this._a11yGetHeaderRowCount(t) + this._a11yGetFooterRowCount(t)
    ), this.$.table.setAttribute("aria-colcount", i && i.length || 0), this._a11yUpdateHeaderRows(), this._a11yUpdateFooterRows();
  }
  /** @protected */
  _a11yUpdateHeaderRows() {
    ht(this.$.header, (e, t) => {
      e.setAttribute("aria-rowindex", t + 1);
    });
  }
  /** @protected */
  _a11yUpdateFooterRows() {
    ht(this.$.footer, (e, t) => {
      e.setAttribute("aria-rowindex", this._a11yGetHeaderRowCount(this._columnTree) + this.size + t + 1);
    });
  }
  /**
   * @param {!HTMLElement} row
   * @param {number} index
   * @protected
   */
  _a11yUpdateRowRowindex(e, t) {
    e.setAttribute("aria-rowindex", t + this._a11yGetHeaderRowCount(this._columnTree) + 1);
  }
  /**
   * @param {!HTMLElement} row
   * @param {boolean} selected
   * @protected
   */
  _a11yUpdateRowSelected(e, t) {
    e.setAttribute("aria-selected", !!t), Bi(e, (i) => {
      i.setAttribute("aria-selected", !!t);
    });
  }
  /**
   * @param {!HTMLElement} row
   * @protected
   */
  _a11yUpdateRowExpanded(e) {
    this.__isRowExpandable(e) ? e.setAttribute("aria-expanded", "false") : this.__isRowCollapsible(e) ? e.setAttribute("aria-expanded", "true") : e.removeAttribute("aria-expanded");
  }
  /**
   * @param {!HTMLElement} row
   * @param {number} level
   * @protected
   */
  _a11yUpdateRowLevel(e, t) {
    t > 0 || this.__isRowCollapsible(e) || this.__isRowExpandable(e) ? e.setAttribute("aria-level", t + 1) : e.removeAttribute("aria-level");
  }
  /**
   * @param {!HTMLElement} row
   * @param {!HTMLElement} detailsCell
   * @protected
   */
  _a11ySetRowDetailsCell(e, t) {
    Bi(e, (i) => {
      i !== t && i.setAttribute("aria-controls", t.id);
    });
  }
  /**
   * @param {!HTMLElement} row
   * @param {number} colspan
   * @protected
   */
  _a11yUpdateCellColspan(e, t) {
    e.setAttribute("aria-colspan", Number(t));
  }
  /** @protected */
  _a11yUpdateSorters() {
    Array.from(this.querySelectorAll("vaadin-grid-sorter")).forEach((e) => {
      let t = e.parentNode;
      for (; t && t.localName !== "vaadin-grid-cell-content"; )
        t = t.parentNode;
      t && t.assignedSlot && t.assignedSlot.parentNode.setAttribute(
        "aria-sort",
        {
          asc: "ascending",
          desc: "descending"
        }[String(e.direction)] || "none"
      );
    });
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Bh = (s) => s.offsetParent && !s.part.contains("body-cell") && fs(s) && getComputedStyle(s).visibility !== "hidden", Nh = (s) => class extends s {
  static get properties() {
    return {
      /**
       * The item user has last interacted with. Turns to `null` after user deactivates
       * the item by re-interacting with the currently active item.
       * @type {GridItem}
       */
      activeItem: {
        type: Object,
        notify: !0,
        value: null,
        sync: !0
      }
    };
  }
  /** @protected */
  ready() {
    super.ready(), this.$.scroller.addEventListener("click", this._onClick.bind(this)), this.addEventListener("cell-activate", this._activateItem.bind(this)), this.addEventListener("row-activate", this._activateItem.bind(this));
  }
  /** @private */
  _activateItem(e) {
    const t = e.detail.model, i = t ? t.item : null;
    i && (this.activeItem = this._itemsEqual(this.activeItem, i) ? null : i);
  }
  /**
   * Checks whether the click event should not activate the cell on which it occurred.
   *
   * @protected
   */
  _shouldPreventCellActivationOnClick(e) {
    const { cell: t } = this._getGridEventLocation(e);
    return (
      // Something has handled this click already, e. g., <vaadin-grid-sorter>
      e.defaultPrevented || // No clicked cell available
      !t || // Cell is a details cell
      t.getAttribute("part").includes("details-cell") || // Cell is the empty state cell
      t === this.$.emptystatecell || // Cell content is focused
      t._content.contains(this.getRootNode().activeElement) || // Clicked on a focusable element
      this._isFocusable(e.target) || // Clicked on a label element
      e.target instanceof HTMLLabelElement
    );
  }
  /**
   * @param {!MouseEvent} e
   * @protected
   */
  _onClick(e) {
    if (this._shouldPreventCellActivationOnClick(e))
      return;
    const { cell: t } = this._getGridEventLocation(e);
    t && this.dispatchEvent(
      new CustomEvent("cell-activate", {
        detail: {
          model: this.__getRowModel(t.parentElement)
        }
      })
    );
  }
  /**
   * @param {!Element} target
   * @return {boolean}
   * @protected
   */
  _isFocusable(e) {
    return Bh(e);
  }
  /**
   * Fired when the `activeItem` property changes.
   *
   * @event active-item-changed
   */
  /**
   * Fired when the cell is activated with click or keyboard.
   *
   * @event cell-activate
   */
};
function Ii(s, n) {
  return s.split(".").reduce((e, t) => e[t], n);
}
function Na(s, n, e) {
  if (e.length === 0)
    return !1;
  let t = !0;
  return s.forEach(({ path: i }) => {
    if (!i || i.indexOf(".") === -1)
      return;
    const r = i.replace(/\.[^.]*$/u, "");
    Ii(r, e[0]) === void 0 && (console.warn(`Path "${i}" used for ${n} does not exist in all of the items, ${n} is disabled.`), t = !1);
  }), t;
}
function xn(s) {
  return [void 0, null].indexOf(s) >= 0 ? "" : isNaN(s) ? s.toString() : s;
}
function Ha(s, n) {
  return s = xn(s), n = xn(n), s < n ? -1 : s > n ? 1 : 0;
}
function Hh(s, n) {
  return s.sort((e, t) => n.map((i) => i.direction === "asc" ? Ha(Ii(i.path, e), Ii(i.path, t)) : i.direction === "desc" ? Ha(Ii(i.path, t), Ii(i.path, e)) : 0).reduce((i, r) => i !== 0 ? i : r, 0));
}
function Vh(s, n) {
  return s.filter((e) => n.every((t) => {
    const i = xn(Ii(t.path, e)), r = xn(t.value).toString().toLowerCase();
    return i.toString().toLowerCase().includes(r);
  }));
}
const Uh = (s) => (n, e) => {
  let t = s ? [...s] : [];
  n.filters && Na(n.filters, "filtering", t) && (t = Vh(t, n.filters)), Array.isArray(n.sortOrders) && n.sortOrders.length && Na(n.sortOrders, "sorting", t) && (t = Hh(t, n.sortOrders));
  const i = Math.min(t.length, n.pageSize), r = n.page * i, o = r + i, a = t.slice(r, o);
  e(a, t.length);
};
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Wh = (s) => class extends s {
  static get properties() {
    return {
      /**
       * An array containing the items which will be passed to renderer functions.
       *
       * @type {Array<!GridItem> | undefined}
       */
      items: {
        type: Array,
        sync: !0
      }
    };
  }
  static get observers() {
    return ["__dataProviderOrItemsChanged(dataProvider, items, isAttached, items.*)"];
  }
  /** @private */
  __setArrayDataProvider(e) {
    const t = Uh(this.items);
    t.__items = e, this._arrayDataProvider = t, this.size = e.length, this.dataProvider = t;
  }
  /**
   * @override
   * @protected
   */
  _onDataProviderPageReceived() {
    super._onDataProviderPageReceived(), this._arrayDataProvider && (this.size = this._flatSize);
  }
  /** @private */
  __dataProviderOrItemsChanged(e, t, i) {
    i && (this._arrayDataProvider ? e !== this._arrayDataProvider ? (this._arrayDataProvider = void 0, this.items = void 0) : t ? this._arrayDataProvider.__items === t ? this.clearCache() : this.__setArrayDataProvider(t) : (this._arrayDataProvider = void 0, this.dataProvider = void 0, this.size = 0, this.clearCache()) : t && this.__setArrayDataProvider(t));
  }
};
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const jh = (s) => s, Jl = typeof document.head.style.touchAction == "string", qo = "__polymerGestures", yo = "__polymerGesturesHandled", Ko = "__polymerGesturesTouchAction", Va = 25, Ua = 5, Gh = 2, qh = ["mousedown", "mousemove", "mouseup", "click"], Kh = [0, 1, 4, 2], Zh = (function() {
  try {
    return new MouseEvent("test", { buttons: 1 }).buttons === 1;
  } catch {
    return !1;
  }
})();
function gs(s) {
  return qh.indexOf(s) > -1;
}
let Yh = !1;
(function() {
  try {
    const s = Object.defineProperty({}, "passive", {
      // eslint-disable-next-line getter-return
      get() {
        Yh = !0;
      }
    });
    window.addEventListener("test", null, s), window.removeEventListener("test", null, s);
  } catch {
  }
})();
function Xh(s) {
  gs(s);
}
const Qh = navigator.userAgent.match(/iP(?:[oa]d|hone)|Android/u), Jh = {
  button: !0,
  command: !0,
  fieldset: !0,
  input: !0,
  keygen: !0,
  optgroup: !0,
  option: !0,
  select: !0,
  textarea: !0
};
function ui(s) {
  const n = s.type;
  if (!gs(n))
    return !1;
  if (n === "mousemove") {
    let t = s.buttons === void 0 ? 1 : s.buttons;
    return s instanceof window.MouseEvent && !Zh && (t = Kh[s.which] || 0), !!(t & 1);
  }
  return (s.button === void 0 ? 0 : s.button) === 0;
}
function $h(s) {
  if (s.type === "click") {
    if (s.detail === 0)
      return !0;
    const n = Gt(s);
    if (!n.nodeType || /** @type {Element} */
    n.nodeType !== Node.ELEMENT_NODE)
      return !0;
    const e = (
      /** @type {Element} */
      n.getBoundingClientRect()
    ), t = s.pageX, i = s.pageY;
    return !(t >= e.left && t <= e.right && i >= e.top && i <= e.bottom);
  }
  return !1;
}
const Dt = {
  touch: {
    x: 0,
    y: 0,
    id: -1,
    scrollDecided: !1
  }
};
function ef(s) {
  let n = "auto";
  const e = ec(s);
  for (let t = 0, i; t < e.length; t++)
    if (i = e[t], i[Ko]) {
      n = i[Ko];
      break;
    }
  return n;
}
function $l(s, n, e) {
  s.movefn = n, s.upfn = e, document.addEventListener("mousemove", n), document.addEventListener("mouseup", e);
}
function Fi(s) {
  document.removeEventListener("mousemove", s.movefn), document.removeEventListener("mouseup", s.upfn), s.movefn = null, s.upfn = null;
}
const ec = window.ShadyDOM && window.ShadyDOM.noPatch ? window.ShadyDOM.composedPath : (s) => s.composedPath && s.composedPath() || [], ms = {}, li = [];
function tf(s, n) {
  let e = document.elementFromPoint(s, n), t = e;
  for (; t && t.shadowRoot && !window.ShadyDOM; ) {
    const i = t;
    if (t = t.shadowRoot.elementFromPoint(s, n), i === t)
      break;
    t && (e = t);
  }
  return e;
}
function Gt(s) {
  const n = ec(
    /** @type {?Event} */
    s
  );
  return n.length > 0 ? n[0] : s.target;
}
function rf(s) {
  const n = s.type, t = s.currentTarget[qo];
  if (!t)
    return;
  const i = t[n];
  if (!i)
    return;
  if (!s[yo] && (s[yo] = {}, n.startsWith("touch"))) {
    const o = s.changedTouches[0];
    if (n === "touchstart" && s.touches.length === 1 && (Dt.touch.id = o.identifier), Dt.touch.id !== o.identifier)
      return;
    Jl || (n === "touchstart" || n === "touchmove") && nf(s);
  }
  const r = s[yo];
  if (!r.skip) {
    for (let o = 0, a; o < li.length; o++)
      a = li[o], i[a.name] && !r[a.name] && a.flow && a.flow.start.indexOf(s.type) > -1 && a.reset && a.reset();
    for (let o = 0, a; o < li.length; o++)
      a = li[o], i[a.name] && !r[a.name] && (r[a.name] = !0, a[n](s));
  }
}
function nf(s) {
  const n = s.changedTouches[0], e = s.type;
  if (e === "touchstart")
    Dt.touch.x = n.clientX, Dt.touch.y = n.clientY, Dt.touch.scrollDecided = !1;
  else if (e === "touchmove") {
    if (Dt.touch.scrollDecided)
      return;
    Dt.touch.scrollDecided = !0;
    const t = ef(s);
    let i = !1;
    const r = Math.abs(Dt.touch.x - n.clientX), o = Math.abs(Dt.touch.y - n.clientY);
    s.cancelable && (t === "none" ? i = !0 : t === "pan-x" ? i = o > r : t === "pan-y" && (i = r > o)), i ? s.preventDefault() : Cn("track");
  }
}
function tc(s, n, e) {
  return ms[n] ? (of(s, n, e), !0) : !1;
}
function of(s, n, e) {
  const t = ms[n], i = t.deps, r = t.name;
  let o = s[qo];
  o || (s[qo] = o = {});
  for (let a = 0, c, u; a < i.length; a++)
    c = i[a], !(Qh && gs(c) && c !== "click") && (u = o[c], u || (o[c] = u = { _count: 0 }), u._count === 0 && s.addEventListener(c, rf, Xh(c)), u[r] = (u[r] || 0) + 1, u._count = (u._count || 0) + 1);
  s.addEventListener(n, e), t.touchAction && af(s, t.touchAction);
}
function vs(s) {
  li.push(s), s.emits.forEach((n) => {
    ms[n] = s;
  });
}
function sf(s) {
  for (let n = 0, e; n < li.length; n++) {
    e = li[n];
    for (let t = 0, i; t < e.emits.length; t++)
      if (i = e.emits[t], i === s)
        return e;
  }
  return null;
}
function af(s, n) {
  Jl && s instanceof HTMLElement && yt.run(() => {
    s.style.touchAction = n;
  }), s[Ko] = n;
}
function _s(s, n, e) {
  const t = new Event(n, { bubbles: !0, cancelable: !0, composed: !0 });
  if (t.detail = e, jh(
    /** @type {!Node} */
    s
  ).dispatchEvent(t), t.defaultPrevented) {
    const i = e.preventer || e.sourceEvent;
    i && i.preventDefault && i.preventDefault();
  }
}
function Cn(s) {
  const n = sf(s);
  n.info && (n.info.prevent = !0);
}
vs({
  name: "downup",
  deps: ["mousedown", "touchstart", "touchend"],
  flow: {
    start: ["mousedown", "touchstart"],
    end: ["mouseup", "touchend"]
  },
  emits: ["down", "up"],
  info: {
    movefn: null,
    upfn: null
  },
  /**
   * @this {GestureRecognizer}
   * @return {void}
   */
  reset() {
    Fi(this.info);
  },
  /**
   * @this {GestureRecognizer}
   * @param {MouseEvent} e
   * @return {void}
   */
  mousedown(s) {
    if (!ui(s))
      return;
    const n = Gt(s), e = this, t = (r) => {
      ui(r) || (nr("up", n, r), Fi(e.info));
    }, i = (r) => {
      ui(r) && nr("up", n, r), Fi(e.info);
    };
    $l(this.info, t, i), nr("down", n, s);
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   * @return {void}
   */
  touchstart(s) {
    nr("down", Gt(s), s.changedTouches[0], s);
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   * @return {void}
   */
  touchend(s) {
    nr("up", Gt(s), s.changedTouches[0], s);
  }
});
function nr(s, n, e, t) {
  n && _s(n, s, {
    x: e.clientX,
    y: e.clientY,
    sourceEvent: e,
    preventer: t,
    prevent(i) {
      return Cn(i);
    }
  });
}
vs({
  name: "track",
  touchAction: "none",
  deps: ["mousedown", "touchstart", "touchmove", "touchend"],
  flow: {
    start: ["mousedown", "touchstart"],
    end: ["mouseup", "touchend"]
  },
  emits: ["track"],
  info: {
    x: 0,
    y: 0,
    state: "start",
    started: !1,
    moves: [],
    /** @this {GestureInfo} */
    addMove(s) {
      this.moves.length > Gh && this.moves.shift(), this.moves.push(s);
    },
    movefn: null,
    upfn: null,
    prevent: !1
  },
  /**
   * @this {GestureRecognizer}
   * @return {void}
   */
  reset() {
    this.info.state = "start", this.info.started = !1, this.info.moves = [], this.info.x = 0, this.info.y = 0, this.info.prevent = !1, Fi(this.info);
  },
  /**
   * @this {GestureRecognizer}
   * @param {MouseEvent} e
   * @return {void}
   */
  mousedown(s) {
    if (!ui(s))
      return;
    const n = Gt(s), e = this, t = (r) => {
      const o = r.clientX, a = r.clientY;
      Wa(e.info, o, a) && (e.info.state = e.info.started ? r.type === "mouseup" ? "end" : "track" : "start", e.info.state === "start" && Cn("tap"), e.info.addMove({ x: o, y: a }), ui(r) || (e.info.state = "end", Fi(e.info)), n && wo(e.info, n, r), e.info.started = !0);
    }, i = (r) => {
      e.info.started && t(r), Fi(e.info);
    };
    $l(this.info, t, i), this.info.x = s.clientX, this.info.y = s.clientY;
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   * @return {void}
   */
  touchstart(s) {
    const n = s.changedTouches[0];
    this.info.x = n.clientX, this.info.y = n.clientY;
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   * @return {void}
   */
  touchmove(s) {
    const n = Gt(s), e = s.changedTouches[0], t = e.clientX, i = e.clientY;
    Wa(this.info, t, i) && (this.info.state === "start" && Cn("tap"), this.info.addMove({ x: t, y: i }), wo(this.info, n, e), this.info.state = "track", this.info.started = !0);
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   * @return {void}
   */
  touchend(s) {
    const n = Gt(s), e = s.changedTouches[0];
    this.info.started && (this.info.state = "end", this.info.addMove({ x: e.clientX, y: e.clientY }), wo(this.info, n, e));
  }
});
function Wa(s, n, e) {
  if (s.prevent)
    return !1;
  if (s.started)
    return !0;
  const t = Math.abs(s.x - n), i = Math.abs(s.y - e);
  return t >= Ua || i >= Ua;
}
function wo(s, n, e) {
  if (!n)
    return;
  const t = s.moves[s.moves.length - 2], i = s.moves[s.moves.length - 1], r = i.x - s.x, o = i.y - s.y;
  let a, c = 0;
  t && (a = i.x - t.x, c = i.y - t.y), _s(n, "track", {
    state: s.state,
    x: e.clientX,
    y: e.clientY,
    dx: r,
    dy: o,
    ddx: a,
    ddy: c,
    sourceEvent: e,
    hover() {
      return tf(e.clientX, e.clientY);
    }
  });
}
vs({
  name: "tap",
  deps: ["mousedown", "click", "touchstart", "touchend"],
  flow: {
    start: ["mousedown", "touchstart"],
    end: ["click", "touchend"]
  },
  emits: ["tap"],
  info: {
    x: NaN,
    y: NaN,
    prevent: !1
  },
  /**
   * @this {GestureRecognizer}
   * @return {void}
   */
  reset() {
    this.info.x = NaN, this.info.y = NaN, this.info.prevent = !1;
  },
  /**
   * @this {GestureRecognizer}
   * @param {MouseEvent} e
   * @return {void}
   */
  mousedown(s) {
    ui(s) && (this.info.x = s.clientX, this.info.y = s.clientY);
  },
  /**
   * @this {GestureRecognizer}
   * @param {MouseEvent} e
   * @return {void}
   */
  click(s) {
    ui(s) && ja(this.info, s);
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   * @return {void}
   */
  touchstart(s) {
    const n = s.changedTouches[0];
    this.info.x = n.clientX, this.info.y = n.clientY;
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   * @return {void}
   */
  touchend(s) {
    ja(this.info, s.changedTouches[0], s);
  }
});
function ja(s, n, e) {
  const t = Math.abs(n.clientX - s.x), i = Math.abs(n.clientY - s.y), r = Gt(e || n);
  !r || Jh[
    /** @type {!HTMLElement} */
    r.localName
  ] && r.hasAttribute("disabled") || (isNaN(t) || isNaN(i) || t <= Va && i <= Va || $h(n)) && (s.prevent || _s(r, "tap", {
    x: n.clientX,
    y: n.clientY,
    sourceEvent: n,
    preventer: e
  }));
}
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const lf = (s) => class extends s {
  static get properties() {
    return {
      /**
       * Set to true to allow column reordering.
       * @attr {boolean} column-reordering-allowed
       * @type {boolean}
       */
      columnReorderingAllowed: {
        type: Boolean,
        value: !1
      },
      /** @private */
      _orderBaseScope: {
        type: Number,
        value: 1e7
      }
    };
  }
  static get observers() {
    return ["_updateOrders(_columnTree)"];
  }
  /** @protected */
  ready() {
    super.ready(), tc(this, "track", this._onTrackEvent), this._reorderGhost = this.shadowRoot.querySelector('[part="reorder-ghost"]'), this.addEventListener("touchstart", this._onTouchStart.bind(this)), this.addEventListener("touchmove", this._onTouchMove.bind(this)), this.addEventListener("touchend", this._onTouchEnd.bind(this)), this.addEventListener("contextmenu", this._onContextMenu.bind(this));
  }
  /** @private */
  _onContextMenu(e) {
    this.hasAttribute("reordering") && (e.preventDefault(), br || this._onTrackEnd());
  }
  /** @private */
  _onTouchStart(e) {
    this._startTouchReorderTimeout = setTimeout(() => {
      this._onTrackStart({
        detail: {
          x: e.touches[0].clientX,
          y: e.touches[0].clientY
        }
      });
    }, 100);
  }
  /** @private */
  _onTouchMove(e) {
    this._draggedColumn && e.preventDefault(), clearTimeout(this._startTouchReorderTimeout);
  }
  /** @private */
  _onTouchEnd() {
    clearTimeout(this._startTouchReorderTimeout), this._onTrackEnd();
  }
  /** @private */
  _onTrackEvent(e) {
    if (e.detail.state === "start") {
      const t = e.composedPath(), i = t[t.indexOf(this.$.header) - 2];
      if (!i || !i._content || i._content.contains(this.getRootNode().activeElement) || this.$.scroller.hasAttribute("column-resizing"))
        return;
      this._touchDevice || this._onTrackStart(e);
    } else e.detail.state === "track" ? this._onTrack(e) : e.detail.state === "end" && this._onTrackEnd(e);
  }
  /** @private */
  _onTrackStart(e) {
    if (!this.columnReorderingAllowed)
      return;
    const t = e.composedPath && e.composedPath();
    if (t && t.some((r) => r.hasAttribute && r.hasAttribute("draggable")))
      return;
    const i = this._cellFromPoint(e.detail.x, e.detail.y);
    if (!(!i || !i.getAttribute("part").includes("header-cell"))) {
      for (this.toggleAttribute("reordering", !0), this._draggedColumn = i._column; this._draggedColumn.parentElement.childElementCount === 1; )
        this._draggedColumn = this._draggedColumn.parentElement;
      this._setSiblingsReorderStatus(this._draggedColumn, "allowed"), this._draggedColumn._reorderStatus = "dragging", this._updateGhost(i), this._reorderGhost.style.visibility = "visible", this._updateGhostPosition(e.detail.x, this._touchDevice ? e.detail.y - 50 : e.detail.y), this._autoScroller();
    }
  }
  /** @private */
  _onTrack(e) {
    if (!this._draggedColumn)
      return;
    const t = this._cellFromPoint(e.detail.x, e.detail.y);
    if (!t)
      return;
    const i = this._getTargetColumn(t, this._draggedColumn);
    if (this._isSwapAllowed(this._draggedColumn, i) && this._isSwappableByPosition(i, e.detail.x)) {
      const r = this._columnTree.findIndex((h) => h.includes(i)), o = this._getColumnsInOrder(r), a = o.indexOf(this._draggedColumn), c = o.indexOf(i), u = a < c ? 1 : -1;
      for (let h = a; h !== c; h += u)
        this._swapColumnOrders(this._draggedColumn, o[h + u]);
    }
    this._updateGhostPosition(e.detail.x, this._touchDevice ? e.detail.y - 50 : e.detail.y), this._lastDragClientX = e.detail.x;
  }
  /** @private */
  _onTrackEnd() {
    this._draggedColumn && (this.toggleAttribute("reordering", !1), this._draggedColumn._reorderStatus = "", this._setSiblingsReorderStatus(this._draggedColumn, ""), this._draggedColumn = null, this._lastDragClientX = null, this._reorderGhost.style.visibility = "hidden", this.dispatchEvent(
      new CustomEvent("column-reorder", {
        detail: {
          columns: this._getColumnsInOrder()
        }
      })
    ));
  }
  /**
   * Returns the columns (or column groups) on the specified header level in visual order.
   * By default, the bottom level is used.
   *
   * @return {!Array<!GridColumn>}
   * @protected
   */
  _getColumnsInOrder(e = this._columnTree.length - 1) {
    return this._columnTree[e].filter((t) => !t.hidden).sort((t, i) => t._order - i._order);
  }
  /**
   * @param {number} x
   * @param {number} y
   * @return {HTMLElement | undefined}
   * @protected
   */
  _cellFromPoint(e = 0, t = 0) {
    this._draggedColumn || this.$.scroller.toggleAttribute("no-content-pointer-events", !0);
    const i = this.shadowRoot.elementFromPoint(e, t);
    return this.$.scroller.toggleAttribute("no-content-pointer-events", !1), this._getCellFromElement(i);
  }
  /** @private */
  _getCellFromElement(e) {
    if (e) {
      if (e._column)
        return e;
      const { parentElement: t } = e;
      if (t && t._focusButton === e)
        return t;
    }
    return null;
  }
  /**
   * @param {number} eventClientX
   * @param {number} eventClientY
   * @protected
   */
  _updateGhostPosition(e, t) {
    const i = this._reorderGhost.getBoundingClientRect(), r = e - i.width / 2, o = t - i.height / 2, a = parseInt(this._reorderGhost._left || 0), c = parseInt(this._reorderGhost._top || 0);
    this._reorderGhost._left = a - (i.left - r), this._reorderGhost._top = c - (i.top - o), this._reorderGhost.style.transform = `translate(${this._reorderGhost._left}px, ${this._reorderGhost._top}px)`;
  }
  /**
   * @param {!HTMLElement} cell
   * @return {!HTMLElement}
   * @protected
   */
  _updateGhost(e) {
    const t = this._reorderGhost;
    t.textContent = e._content.innerText;
    const i = window.getComputedStyle(e);
    return [
      "boxSizing",
      "display",
      "width",
      "height",
      "background",
      "alignItems",
      "padding",
      "border",
      "flex-direction",
      "overflow"
    ].forEach((r) => {
      t.style[r] = i[r];
    }), t;
  }
  /** @private */
  _updateOrders(e) {
    e !== void 0 && (e[0].forEach((t) => {
      t._order = 0;
    }), hh(e[0], this._orderBaseScope, 0));
  }
  /**
   * @param {!GridColumn} column
   * @param {string} status
   * @protected
   */
  _setSiblingsReorderStatus(e, t) {
    ht(e.parentNode, (i) => {
      /column/u.test(i.localName) && this._isSwapAllowed(i, e) && (i._reorderStatus = t);
    });
  }
  /** @protected */
  _autoScroller() {
    if (this._lastDragClientX) {
      const e = this._lastDragClientX - this.getBoundingClientRect().right + 50, t = this.getBoundingClientRect().left - this._lastDragClientX + 50;
      e > 0 ? this.$.table.scrollLeft += e / 10 : t > 0 && (this.$.table.scrollLeft -= t / 10);
    }
    this._draggedColumn && setTimeout(() => this._autoScroller(), 10);
  }
  /**
   * @param {GridColumn | undefined} column1
   * @param {GridColumn | undefined} column2
   * @return {boolean | undefined}
   * @protected
   */
  _isSwapAllowed(e, t) {
    if (e && t) {
      const i = e !== t, r = e.parentElement === t.parentElement, o = e.frozen && t.frozen || // Both columns are frozen
      e.frozenToEnd && t.frozenToEnd || // Both columns are frozen to end
      !e.frozen && !e.frozenToEnd && !t.frozen && !t.frozenToEnd;
      return i && r && o;
    }
  }
  /**
   * @param {!GridColumn} targetColumn
   * @param {number} clientX
   * @return {boolean}
   * @protected
   */
  _isSwappableByPosition(e, t) {
    const i = Array.from(this.$.header.querySelectorAll('tr:not([hidden]) [part~="cell"]')).find(
      (a) => e.contains(a._column)
    ), r = this.$.header.querySelector("tr:not([hidden]) [reorder-status=dragging]").getBoundingClientRect(), o = i.getBoundingClientRect();
    return o.left > r.left ? t > o.right - r.width : t < o.left + r.width;
  }
  /**
   * @param {!GridColumn} column1
   * @param {!GridColumn} column2
   * @protected
   */
  _swapColumnOrders(e, t) {
    [e._order, t._order] = [t._order, e._order], this._debounceUpdateFrozenColumn(), this._updateFirstAndLastColumn();
  }
  /**
   * @param {HTMLElement | undefined} targetCell
   * @param {GridColumn} draggedColumn
   * @return {GridColumn | undefined}
   * @protected
   */
  _getTargetColumn(e, t) {
    if (e && t) {
      let i = e._column;
      for (; i.parentElement !== t.parentElement && i !== this; )
        i = i.parentElement;
      return i.parentElement === t.parentElement ? i : e._column;
    }
  }
  /**
   * Fired when the columns in the grid are reordered.
   *
   * @event column-reorder
   * @param {Object} detail
   * @param {Object} detail.columns the columns in the new order
   */
};
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const cf = (s) => class extends s {
  /** @protected */
  ready() {
    super.ready();
    const e = this.$.scroller;
    tc(e, "track", this._onHeaderTrack.bind(this)), e.addEventListener("touchmove", (t) => e.hasAttribute("column-resizing") && t.preventDefault()), e.addEventListener(
      "contextmenu",
      (t) => t.target.getAttribute("part") === "resize-handle" && t.preventDefault()
    ), e.addEventListener(
      "mousedown",
      (t) => t.target.getAttribute("part") === "resize-handle" && t.preventDefault()
    );
  }
  /** @private */
  _onHeaderTrack(e) {
    const t = e.target;
    if (t.getAttribute("part") === "resize-handle") {
      let r = t.parentElement._column;
      for (this.$.scroller.toggleAttribute("column-resizing", !0); r.localName === "vaadin-grid-column-group"; )
        r = r._childColumns.slice(0).sort((f, g) => f._order - g._order).filter((f) => !f.hidden).pop();
      const o = this.__isRTL, a = e.detail.x, c = Array.from(this.$.header.querySelectorAll('[part~="row"]:last-child [part~="cell"]')), u = c.find((f) => f._column === r);
      if (u.offsetWidth) {
        const f = getComputedStyle(u._content), g = 10 + parseInt(f.paddingLeft) + parseInt(f.paddingRight) + parseInt(f.borderLeftWidth) + parseInt(f.borderRightWidth) + parseInt(f.marginLeft) + parseInt(f.marginRight);
        let x;
        const C = u.offsetWidth, E = u.getBoundingClientRect();
        u.hasAttribute("frozen-to-end") ? x = C + (o ? a - E.right : E.left - a) : x = C + (o ? E.left - a : a - E.right), r.width = `${Math.max(g, x)}px`, r.flexGrow = 0;
      }
      c.sort((f, g) => f._column._order - g._column._order).forEach((f, g, x) => {
        g < x.indexOf(u) && (f._column.width = `${f.offsetWidth}px`, f._column.flexGrow = 0);
      });
      const h = this._frozenToEndCells[0];
      if (h && this.$.table.scrollWidth > this.$.table.offsetWidth) {
        const f = h.getBoundingClientRect(), g = a - (o ? f.right : f.left);
        (o && g <= 0 || !o && g >= 0) && (this.$.table.scrollLeft += g);
      }
      e.detail.state === "end" && (this.$.scroller.toggleAttribute("column-resizing", !1), this.dispatchEvent(
        new CustomEvent("column-resize", {
          detail: { resizedColumn: r }
        })
      )), this._resizeHandler();
    }
  }
  /**
   * Fired when a column in the grid is resized by the user.
   *
   * @event column-resize
   * @param {Object} detail
   * @param {Object} detail.resizedColumn the column that was resized
   */
};
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function Tn(s, n, e = 0) {
  let t = n;
  for (const i of s.subCaches) {
    const r = i.parentCacheIndex;
    if (t <= r)
      break;
    if (t <= r + i.flatSize)
      return Tn(i, t - r - 1, e + 1);
    t -= i.flatSize;
  }
  return {
    cache: s,
    item: s.items[t],
    index: t,
    page: Math.floor(t / s.pageSize),
    level: e
  };
}
function ic({ getItemId: s }, n, e, t = 0, i = 0) {
  for (let r = 0; r < n.items.length; r++) {
    const o = n.items[r];
    if (o && s(o) === s(e))
      return {
        cache: n,
        level: t,
        item: o,
        index: r,
        page: Math.floor(r / n.pageSize),
        subCache: n.getSubCache(r),
        flatIndex: i + n.getFlatIndex(r)
      };
  }
  for (const r of n.subCaches) {
    const o = i + n.getFlatIndex(r.parentCacheIndex), a = ic({ getItemId: s }, r, e, t + 1, o + 1);
    if (a)
      return a;
  }
}
function rc(s, [n, ...e], t = 0) {
  n === 1 / 0 && (n = s.size - 1);
  const i = s.getFlatIndex(n), r = s.getSubCache(n);
  return r && r.flatSize > 0 && e.length ? rc(r, e, t + i + 1) : t + i;
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class bs {
  /**
   * A context object.
   *
   * @type {{ isExpanded: (item: unknown) => boolean }}
   */
  context;
  /**
   * The number of items to display per page.
   *
   * @type {number}
   */
  pageSize;
  /**
   * An array of cached items.
   *
   * @type {object[]}
   */
  items = [];
  /**
   * A map where the key is a requested page and the value is a callback
   * that will be called with data once the request is complete.
   *
   * @type {Record<number, Function>}
   */
  pendingRequests = {};
  /**
   * A map where the key is the index of an item in the `items` array
   * and the value is a sub-cache associated with that item.
   *
   * Note, it's intentionally defined as an object instead of a Map
   * to ensure that Object.entries() returns an array with keys sorted
   * in alphabetical order, rather than the order they were added.
   *
   * @type {Record<number, Cache>}
   * @private
   */
  __subCacheByIndex = {};
  /**
   * The number of items.
   *
   * @type {number}
   * @private
   */
  __size = 0;
  /**
   * The total number of items, including items from expanded sub-caches.
   *
   * @type {number}
   * @private
   */
  __flatSize = 0;
  /**
   * @param {Cache['context']} context
   * @param {number} pageSize
   * @param {number | undefined} size
   * @param {Cache | undefined} parentCache
   * @param {number | undefined} parentCacheIndex
   */
  constructor(n, e, t, i, r) {
    this.context = n, this.pageSize = e, this.size = t, this.parentCache = i, this.parentCacheIndex = r, this.__flatSize = t || 0;
  }
  /**
   * An item in the parent cache that the current cache is associated with.
   *
   * @return {object | undefined}
   */
  get parentItem() {
    return this.parentCache && this.parentCache.items[this.parentCacheIndex];
  }
  /**
   * An array of sub-caches sorted in the same order as their associated items
   * appear in the `items` array.
   *
   * @return {Cache[]}
   */
  get subCaches() {
    return Object.values(this.__subCacheByIndex);
  }
  /**
   * Whether the cache or any of its descendant caches have pending requests.
   *
   * @return {boolean}
   */
  get isLoading() {
    return Object.keys(this.pendingRequests).length > 0 ? !0 : this.subCaches.some((n) => n.isLoading);
  }
  /**
   * The total number of items, including items from expanded sub-caches.
   *
   * @return {number}
   */
  get flatSize() {
    return this.__flatSize;
  }
  /**
   * The total number of items, including items from expanded sub-caches.
   *
   * @protected
   * @deprecated since 24.3 and will be removed in Vaadin 25.
   */
  get effectiveSize() {
    return console.warn(
      "<vaadin-grid> The `effectiveSize` property of ItemCache is deprecated and will be removed in Vaadin 25."
    ), this.flatSize;
  }
  /**
   * The number of items.
   *
   * @return {number}
   */
  get size() {
    return this.__size;
  }
  /**
   * Sets the number of items.
   *
   * @param {number} size
   */
  set size(n) {
    if (this.__size !== n) {
      if (this.__size = n, this.context.placeholder !== void 0) {
        this.items.length = n || 0;
        for (let t = 0; t < n; t++)
          this.items[t] ||= this.context.placeholder;
      }
      Object.keys(this.pendingRequests).forEach((t) => {
        parseInt(t) * this.pageSize >= this.size && delete this.pendingRequests[t];
      });
    }
  }
  /**
   * Recalculates the flattened size for the cache and its descendant caches recursively.
   */
  recalculateFlatSize() {
    this.__flatSize = !this.parentItem || this.context.isExpanded(this.parentItem) ? this.size + this.subCaches.reduce((n, e) => (e.recalculateFlatSize(), n + e.flatSize), 0) : 0;
  }
  /**
   * Adds an array of items corresponding to the given page
   * to the `items` array.
   *
   * @param {number} page
   * @param {object[]} items
   */
  setPage(n, e) {
    const t = n * this.pageSize;
    e.forEach((i, r) => {
      const o = t + r;
      (this.size === void 0 || o < this.size) && (this.items[o] = i);
    });
  }
  /**
   * Retrieves the sub-cache associated with the item at the given index
   * in the `items` array.
   *
   * @param {number} index
   * @return {Cache | undefined}
   */
  getSubCache(n) {
    return this.__subCacheByIndex[n];
  }
  /**
   * Removes the sub-cache associated with the item at the given index
   * in the `items` array.
   *
   * @param {number} index
   */
  removeSubCache(n) {
    delete this.__subCacheByIndex[n];
  }
  /**
   * Removes all sub-caches.
   */
  removeSubCaches() {
    this.__subCacheByIndex = {};
  }
  /**
   * Creates and associates a sub-cache for the item at the given index
   * in the `items` array.
   *
   * @param {number} index
   * @return {Cache}
   */
  createSubCache(n) {
    const e = new bs(this.context, this.pageSize, 0, this, n);
    return this.__subCacheByIndex[n] = e, e;
  }
  /**
   * Retrieves the flattened index corresponding to the given index
   * of an item in the `items` array.
   *
   * @param {number} index
   * @return {number}
   */
  getFlatIndex(n) {
    const e = Math.max(0, Math.min(this.size - 1, n));
    return this.subCaches.reduce((t, i) => {
      const r = i.parentCacheIndex;
      return e > r ? t + i.flatSize : t;
    }, e);
  }
  /**
   * @deprecated since 24.3 and will be removed in Vaadin 25.
   */
  getItemForIndex(n) {
    console.warn(
      "<vaadin-grid> The `getItemForIndex` method of ItemCache is deprecated and will be removed in Vaadin 25."
    );
    const { item: e } = Tn(this, n);
    return e;
  }
  /**
   * @deprecated since 24.3 and will be removed in Vaadin 25.
   */
  getCacheAndIndex(n) {
    console.warn(
      "<vaadin-grid> The `getCacheAndIndex` method of ItemCache is deprecated and will be removed in Vaadin 25."
    );
    const { cache: e, index: t } = Tn(this, n);
    return { cache: e, scaledIndex: t };
  }
  /**
   * @deprecated since 24.3 and will be removed in Vaadin 25.
   */
  updateSize() {
    console.warn("<vaadin-grid> The `updateSize` method of ItemCache is deprecated and will be removed in Vaadin 25."), this.recalculateFlatSize();
  }
  /**
   * @deprecated since 24.3 and will be removed in Vaadin 25.
   */
  ensureSubCacheForScaledIndex(n) {
    if (console.warn(
      "<vaadin-grid> The `ensureSubCacheForScaledIndex` method of ItemCache is deprecated and will be removed in Vaadin 25."
    ), !this.getSubCache(n)) {
      const e = this.createSubCache(n);
      this.context.__controller.__loadCachePage(e, 0);
    }
  }
  /**
   * @deprecated since 24.3 and will be removed in Vaadin 25.
   */
  get grid() {
    return console.warn("<vaadin-grid> The `grid` property of ItemCache is deprecated and will be removed in Vaadin 25."), this.context.__controller.host;
  }
  /**
   * @deprecated since 24.3 and will be removed in Vaadin 25.
   */
  get itemCaches() {
    return console.warn(
      "<vaadin-grid> The `itemCaches` property of ItemCache is deprecated and will be removed in Vaadin 25."
    ), this.__subCacheByIndex;
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class nc extends EventTarget {
  /**
   * The controller host element.
   *
   * @param {HTMLElement}
   */
  host;
  /**
   * A callback that returns data based on the passed params such as
   * `page`, `pageSize`, `parentItem`, etc.
   */
  dataProvider;
  /**
   * A callback that returns additional params that need to be passed
   * to the data provider callback with every request.
   */
  dataProviderParams;
  /**
   * A number of items to display per page.
   *
   * @type {number}
   */
  pageSize;
  /**
   * A callback that returns whether the given item is expanded.
   *
   * @type {(item: unknown) => boolean}
   */
  isExpanded;
  /**
   * A callback that returns the id for the given item and that
   * is used when checking object items for equality.
   *
   * @type { (item: unknown) => unknown}
   */
  getItemId;
  /**
   * A reference to the root cache instance.
   *
   * @param {Cache}
   */
  rootCache;
  /**
   * A placeholder item that is used to indicate that the item is not loaded yet.
   *
   * @type {unknown}
   */
  placeholder;
  /**
   * A callback that returns whether the given item is a placeholder.
   *
   * @type {(item: unknown) => boolean}
   */
  isPlaceholder;
  constructor(n, { size: e, pageSize: t, isExpanded: i, getItemId: r, isPlaceholder: o, placeholder: a, dataProvider: c, dataProviderParams: u }) {
    super(), this.host = n, this.pageSize = t, this.getItemId = r, this.isExpanded = i, this.placeholder = a, this.isPlaceholder = o, this.dataProvider = c, this.dataProviderParams = u, this.rootCache = this.__createRootCache(e);
  }
  /**
   * The total number of items, including items from expanded sub-caches.
   */
  get flatSize() {
    return this.rootCache.flatSize;
  }
  /** @private */
  get __cacheContext() {
    return {
      isExpanded: this.isExpanded,
      placeholder: this.placeholder,
      // The controller instance is needed to ensure deprecated cache methods work.
      __controller: this
    };
  }
  /**
   * Whether the root cache or any of its decendant caches have pending requests.
   *
   * @return {boolean}
   */
  isLoading() {
    return this.rootCache.isLoading;
  }
  /**
   * Sets the page size and clears the cache.
   *
   * @param {number} pageSize
   */
  setPageSize(n) {
    this.pageSize = n, this.clearCache();
  }
  /**
   * Sets the data provider callback and clears the cache.
   *
   * @type {Function}
   */
  setDataProvider(n) {
    this.dataProvider = n, this.clearCache();
  }
  /**
   * Recalculates the flattened size.
   */
  recalculateFlatSize() {
    this.rootCache.recalculateFlatSize();
  }
  /**
   * Clears the cache.
   */
  clearCache() {
    this.rootCache = this.__createRootCache(this.rootCache.size);
  }
  /**
   * Returns context for the given flattened index, including:
   * - the corresponding cache
   * - the cache level
   * - the corresponding item (if loaded)
   * - the item's index in the cache's items array
   * - the page containing the item
   *
   * @param {number} flatIndex
   */
  getFlatIndexContext(n) {
    return Tn(this.rootCache, n);
  }
  /**
   * Returns context for the given item, including:
   * - the cache containing the item
   * - the cache level
   * - the item
   * - the item's index in the cache's items array
   * - the item's flattened index
   * - the item's sub-cache (if exists)
   * - the page containing the item
   *
   * If the item isn't found, the method returns undefined.
   */
  getItemContext(n) {
    return ic({ getItemId: this.getItemId }, this.rootCache, n);
  }
  /**
   * Returns the flattened index for the item that the given indexes point to.
   * Each index in the path array points to a sub-item of the previous index.
   * Using `Infinity` as an index will point to the last item on the level.
   *
   * @param {number[]} path
   * @return {number}
   */
  getFlatIndexByPath(n) {
    return rc(this.rootCache, n);
  }
  /**
   * Requests the data provider to load the page with the item corresponding
   * to the given flattened index. If the item is already loaded, the method
   * returns immediatelly.
   *
   * @param {number} flatIndex
   */
  ensureFlatIndexLoaded(n) {
    const { cache: e, page: t, item: i } = this.getFlatIndexContext(n);
    this.__isItemLoaded(i) || this.__loadCachePage(e, t);
  }
  /**
   * Creates a sub-cache for the item corresponding to the given flattened index and
   * requests the data provider to load the first page into the created sub-cache.
   * If the sub-cache already exists, the method returns immediatelly.
   *
   * @param {number} flatIndex
   */
  ensureFlatIndexHierarchy(n) {
    const { cache: e, item: t, index: i } = this.getFlatIndexContext(n);
    if (this.__isItemLoaded(t) && this.isExpanded(t) && !e.getSubCache(i)) {
      const r = e.createSubCache(i);
      this.__loadCachePage(r, 0);
    }
  }
  /**
   * Loads the first page into the root cache.
   */
  loadFirstPage() {
    this.__loadCachePage(this.rootCache, 0);
  }
  /** @private */
  __createRootCache(n) {
    return new bs(this.__cacheContext, this.pageSize, n);
  }
  /** @private */
  __loadCachePage(n, e) {
    if (!this.dataProvider || n.pendingRequests[e])
      return;
    let t = {
      page: e,
      pageSize: this.pageSize,
      parentItem: n.parentItem
    };
    this.dataProviderParams && (t = { ...t, ...this.dataProviderParams() });
    const i = (r, o) => {
      n.pendingRequests[e] === i && (o !== void 0 ? n.size = o : t.parentItem && (n.size = r.length), n.setPage(e, r), this.recalculateFlatSize(), this.dispatchEvent(new CustomEvent("page-received")), delete n.pendingRequests[e], this.dispatchEvent(new CustomEvent("page-loaded")));
    };
    n.pendingRequests[e] = i, this.dispatchEvent(new CustomEvent("page-requested")), this.dataProvider(t, i);
  }
  /** @private */
  __isItemLoaded(n) {
    return this.isPlaceholder ? !this.isPlaceholder(n) : this.placeholder ? n !== this.placeholder : !!n;
  }
}
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const uf = (s) => class extends s {
  static get properties() {
    return {
      /**
       * The number of root-level items in the grid.
       * @attr {number} size
       * @type {number}
       */
      size: {
        type: Number,
        notify: !0,
        sync: !0
      },
      /**
       * @type {number}
       * @protected
       */
      _flatSize: {
        type: Number,
        sync: !0
      },
      /**
       * Number of items fetched at a time from the dataprovider.
       * @attr {number} page-size
       * @type {number}
       */
      pageSize: {
        type: Number,
        value: 50,
        observer: "_pageSizeChanged",
        sync: !0
      },
      /**
       * Function that provides items lazily. Receives arguments `params`, `callback`
       *
       * `params.page` Requested page index
       *
       * `params.pageSize` Current page size
       *
       * `params.filters` Currently applied filters
       *
       * `params.sortOrders` Currently applied sorting orders
       *
       * `params.parentItem` When tree is used, and sublevel items
       * are requested, reference to parent item of the requested sublevel.
       * Otherwise `undefined`.
       *
       * `callback(items, size)` Callback function with arguments:
       *   - `items` Current page of items
       *   - `size` Total number of items. When tree sublevel items
       *     are requested, total number of items in the requested sublevel.
       *     Optional when tree is not used, required for tree.
       *
       * @type {GridDataProvider | null | undefined}
       */
      dataProvider: {
        type: Object,
        notify: !0,
        observer: "_dataProviderChanged",
        sync: !0
      },
      /**
       * `true` while data is being requested from the data provider.
       */
      loading: {
        type: Boolean,
        notify: !0,
        readOnly: !0,
        reflectToAttribute: !0
      },
      /**
       * @protected
       */
      _hasData: {
        type: Boolean,
        value: !1,
        sync: !0
      },
      /**
       * Path to an item sub-property that indicates whether the item has child items.
       * @attr {string} item-has-children-path
       */
      itemHasChildrenPath: {
        type: String,
        value: "children",
        observer: "__itemHasChildrenPathChanged",
        sync: !0
      },
      /**
       * Path to an item sub-property that identifies the item.
       * @attr {string} item-id-path
       */
      itemIdPath: {
        type: String,
        value: null,
        sync: !0
      },
      /**
       * An array that contains the expanded items.
       * @type {!Array<!GridItem>}
       */
      expandedItems: {
        type: Object,
        notify: !0,
        value: () => [],
        sync: !0
      },
      /**
       * @private
       */
      __expandedKeys: {
        type: Object,
        computed: "__computeExpandedKeys(itemIdPath, expandedItems)"
      }
    };
  }
  static get observers() {
    return ["_sizeChanged(size)", "_expandedItemsChanged(expandedItems)"];
  }
  constructor() {
    super(), this._dataProviderController = new nc(this, {
      size: this.size || 0,
      pageSize: this.pageSize,
      getItemId: this.getItemId.bind(this),
      isExpanded: this._isExpanded.bind(this),
      dataProvider: this.dataProvider ? this.dataProvider.bind(this) : null,
      dataProviderParams: () => ({
        sortOrders: this._mapSorters(),
        filters: this._mapFilters()
      })
    }), this._dataProviderController.addEventListener("page-requested", this._onDataProviderPageRequested.bind(this)), this._dataProviderController.addEventListener("page-received", this._onDataProviderPageReceived.bind(this)), this._dataProviderController.addEventListener("page-loaded", this._onDataProviderPageLoaded.bind(this));
  }
  /**
   * @protected
   * @deprecated since 24.3 and will be removed in Vaadin 25.
   */
  get _cache() {
    return console.warn("<vaadin-grid> The `_cache` property is deprecated and will be removed in Vaadin 25."), this._dataProviderController.rootCache;
  }
  /**
   * @protected
   * @deprecated since 24.3 and will be removed in Vaadin 25.
   */
  get _effectiveSize() {
    return console.warn("<vaadin-grid> The `_effectiveSize` property is deprecated and will be removed in Vaadin 25."), this._flatSize;
  }
  /** @private */
  _sizeChanged(e) {
    this._dataProviderController.rootCache.size = e, this._dataProviderController.recalculateFlatSize(), this._flatSize = this._dataProviderController.flatSize;
  }
  /** @private */
  __itemHasChildrenPathChanged(e, t) {
    !t && e === "children" || this.requestContentUpdate();
  }
  /**
   * @param {number} index
   * @param {HTMLElement} el
   * @protected
   */
  _getItem(e, t) {
    t.index = e;
    const { item: i } = this._dataProviderController.getFlatIndexContext(e);
    i ? (this.__updateLoading(t, !1), this._updateItem(t, i), this._isExpanded(i) && this._dataProviderController.ensureFlatIndexHierarchy(e)) : (this.__updateLoading(t, !0), this._dataProviderController.ensureFlatIndexLoaded(e));
  }
  /**
   * @param {!HTMLElement} row
   * @param {boolean} loading
   * @private
   */
  __updateLoading(e, t) {
    const i = Li(e);
    Dn(e, "loading", t), jt(i, "loading-row-cell", t), t && (this._generateCellClassNames(e), this._generateCellPartNames(e));
  }
  /**
   * Returns a value that identifies the item. Uses `itemIdPath` if available.
   * Can be customized by overriding.
   * @param {!GridItem} item
   * @return {!GridItem | !unknown}
   */
  getItemId(e) {
    return this.itemIdPath ? pi(this.itemIdPath, e) : e;
  }
  /**
   * @param {!GridItem} item
   * @return {boolean}
   * @protected
   */
  _isExpanded(e) {
    return this.__expandedKeys && this.__expandedKeys.has(this.getItemId(e));
  }
  /** @private */
  _expandedItemsChanged() {
    this._dataProviderController.recalculateFlatSize(), this._flatSize = this._dataProviderController.flatSize, this.__updateVisibleRows();
  }
  /** @private */
  __computeExpandedKeys(e, t) {
    const i = t || [], r = /* @__PURE__ */ new Set();
    return i.forEach((o) => {
      r.add(this.getItemId(o));
    }), r;
  }
  /**
   * Expands the given item tree.
   * @param {!GridItem} item
   */
  expandItem(e) {
    this._isExpanded(e) || (this.expandedItems = [...this.expandedItems, e]);
  }
  /**
   * Collapses the given item tree.
   * @param {!GridItem} item
   */
  collapseItem(e) {
    this._isExpanded(e) && (this.expandedItems = this.expandedItems.filter((t) => !this._itemsEqual(t, e)));
  }
  /**
   * @param {number} index
   * @return {number}
   * @protected
   */
  _getIndexLevel(e = 0) {
    const { level: t } = this._dataProviderController.getFlatIndexContext(e);
    return t;
  }
  /**
   * @param {number} page
   * @param {ItemCache} cache
   * @protected
   * @deprecated since 24.3 and will be removed in Vaadin 25.
   */
  _loadPage(e, t) {
    console.warn("<vaadin-grid> The `_loadPage` method is deprecated and will be removed in Vaadin 25."), this._dataProviderController.__loadCachePage(t, e);
  }
  /** @protected */
  _onDataProviderPageRequested() {
    this._setLoading(!0);
  }
  /** @protected */
  _onDataProviderPageReceived() {
    this._flatSize !== this._dataProviderController.flatSize && (this._shouldUpdateAllRenderedRowsAfterPageLoad = !0, this._flatSize = this._dataProviderController.flatSize), this._getRenderedRows().forEach((e) => {
      this._dataProviderController.ensureFlatIndexHierarchy(e.index);
    }), this._hasData = !0;
  }
  /** @protected */
  _onDataProviderPageLoaded() {
    this._debouncerApplyCachedData = Me.debounce(this._debouncerApplyCachedData, zt.after(0), () => {
      this._setLoading(!1);
      const e = this._shouldUpdateAllRenderedRowsAfterPageLoad;
      this._shouldUpdateAllRenderedRowsAfterPageLoad = !1, this._getRenderedRows().forEach((t) => {
        const { item: i } = this._dataProviderController.getFlatIndexContext(t.index);
        (i || e) && this._getItem(t.index, t);
      }), this.__scrollToPendingIndexes(), this.__dispatchPendingBodyCellFocus();
    }), this._dataProviderController.isLoading() || this._debouncerApplyCachedData.flush();
  }
  /** @private */
  __debounceClearCache() {
    this.__clearCacheDebouncer = Me.debounce(this.__clearCacheDebouncer, yt, () => this.clearCache());
  }
  /**
   * Clears the cached pages and reloads data from dataprovider when needed.
   */
  clearCache() {
    this._dataProviderController.clearCache(), this._dataProviderController.rootCache.size = this.size, this._dataProviderController.recalculateFlatSize(), this._hasData = !1, this.__updateVisibleRows(), (!this.__virtualizer || !this.__virtualizer.size) && this._dataProviderController.loadFirstPage();
  }
  /** @private */
  _pageSizeChanged(e, t) {
    this._dataProviderController.setPageSize(e), t !== void 0 && e !== t && this.clearCache();
  }
  /** @protected */
  _checkSize() {
    this.size === void 0 && this._flatSize === 0 && console.warn(
      "The <vaadin-grid> needs the total number of items in order to display rows, which you can specify either by setting the `size` property, or by providing it to the second argument of the `dataProvider` function `callback` call."
    );
  }
  /** @private */
  _dataProviderChanged(e, t) {
    this._dataProviderController.setDataProvider(e ? e.bind(this) : null), t !== void 0 && this.clearCache(), this._ensureFirstPageLoaded(), this._debouncerCheckSize = Me.debounce(
      this._debouncerCheckSize,
      zt.after(2e3),
      this._checkSize.bind(this)
    );
  }
  /** @protected */
  _ensureFirstPageLoaded() {
    this._hasData || this._dataProviderController.loadFirstPage();
  }
  /**
   * @param {!GridItem} item1
   * @param {!GridItem} item2
   * @return {boolean}
   * @protected
   */
  _itemsEqual(e, t) {
    return this.getItemId(e) === this.getItemId(t);
  }
  /**
   * @param {!GridItem} item
   * @param {!Array<!GridItem>} array
   * @return {number}
   * @protected
   */
  _getItemIndexInArray(e, t) {
    let i = -1;
    return t.forEach((r, o) => {
      this._itemsEqual(r, e) && (i = o);
    }), i;
  }
  /**
   * Scroll to a specific row index in the virtual list. Note that the row index is
   * not always the same for any particular item. For example, sorting or filtering
   * items can affect the row index related to an item.
   *
   * The `indexes` parameter can be either a single number or multiple numbers.
   * The grid will first try to scroll to the item at the first index on the top level.
   * In case the item at the first index is expanded, the grid will then try scroll to the
   * item at the second index within the children of the expanded first item, and so on.
   * Each given index points to a child of the item at the previous index.
   *
   * Using `Infinity` as an index will point to the last item on the level.
   *
   * @param indexes {...number} Row indexes to scroll to
   */
  scrollToIndex(...e) {
    let t;
    for (; t !== (t = this._dataProviderController.getFlatIndexByPath(e)); )
      this._scrollToFlatIndex(t);
    (this._dataProviderController.isLoading() || !this.clientHeight) && (this.__pendingScrollToIndexes = e);
  }
  /** @private */
  __scrollToPendingIndexes() {
    if (this.__pendingScrollToIndexes && this.$.items.children.length) {
      const e = this.__pendingScrollToIndexes;
      delete this.__pendingScrollToIndexes, this.scrollToIndex(...e);
    }
  }
  /**
   * Fired when the `expandedItems` property changes.
   *
   * @event expanded-items-changed
   */
  /**
   * Fired when the `loading` property changes.
   *
   * @event loading-changed
   */
};
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const or = {
  BETWEEN: "between",
  ON_TOP_OR_BETWEEN: "on-top-or-between",
  ON_GRID: "on-grid"
}, Ut = {
  ON_TOP: "on-top",
  ABOVE: "above",
  BELOW: "below",
  EMPTY: "empty"
}, df = !("draggable" in document.createElement("div")), hf = (s) => class extends s {
  static get properties() {
    return {
      /**
       * Defines the locations within the Grid row where an element can be dropped.
       *
       * Possible values are:
       * - `between`: The drop event can happen between Grid rows.
       * - `on-top`: The drop event can happen on top of Grid rows.
       * - `on-top-or-between`: The drop event can happen either on top of or between Grid rows.
       * - `on-grid`: The drop event will not happen on any specific row, it will show the drop target outline around the whole grid.
       * @attr {between|on-top|on-top-or-between|on-grid} drop-mode
       * @type {GridDropMode | null | undefined}
       */
      dropMode: {
        type: String,
        sync: !0
      },
      /**
       * Marks the grid's rows to be available for dragging.
       * @attr {boolean} rows-draggable
       */
      rowsDraggable: {
        type: Boolean,
        sync: !0
      },
      /**
       * A function that filters dragging of specific grid rows. The return value should be false
       * if dragging of the row should be disabled.
       *
       * Receives one argument:
       * - `model` The object with the properties related with
       *   the rendered item, contains:
       *   - `model.index` The index of the item.
       *   - `model.item` The item.
       *   - `model.expanded` Sublevel toggle state.
       *   - `model.level` Level of the tree represented with a horizontal offset of the toggle button.
       *   - `model.selected` Selected state.
       *
       * @type {GridDragAndDropFilter | null | undefined}
       */
      dragFilter: {
        type: Function,
        sync: !0
      },
      /**
       * A function that filters dropping on specific grid rows. The return value should be false
       * if dropping on the row should be disabled.
       *
       * Receives one argument:
       * - `model` The object with the properties related with
       *   the rendered item, contains:
       *   - `model.index` The index of the item.
       *   - `model.item` The item.
       *   - `model.expanded` Sublevel toggle state.
       *   - `model.level` Level of the tree represented with a horizontal offset of the toggle button.
       *   - `model.selected` Selected state.
       *
       * @type {GridDragAndDropFilter | null | undefined}
       */
      dropFilter: {
        type: Function,
        sync: !0
      },
      /** @private */
      __dndAutoScrollThreshold: {
        value: 50
      },
      /** @private  */
      __draggedItems: {
        value: () => []
      }
    };
  }
  static get observers() {
    return ["_dragDropAccessChanged(rowsDraggable, dropMode, dragFilter, dropFilter, loading)"];
  }
  constructor() {
    super(), this.__onDocumentDragStart = this.__onDocumentDragStart.bind(this);
  }
  /** @protected */
  ready() {
    super.ready(), this.$.table.addEventListener("dragstart", this._onDragStart.bind(this)), this.$.table.addEventListener("dragend", this._onDragEnd.bind(this)), this.$.table.addEventListener("dragover", this._onDragOver.bind(this)), this.$.table.addEventListener("dragleave", this._onDragLeave.bind(this)), this.$.table.addEventListener("drop", this._onDrop.bind(this)), this.$.table.addEventListener("dragenter", (e) => {
      this.dropMode && (e.preventDefault(), e.stopPropagation());
    });
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback(), document.addEventListener("dragstart", this.__onDocumentDragStart, { capture: !0 });
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback(), document.removeEventListener("dragstart", this.__onDocumentDragStart, { capture: !0 });
  }
  /** @private */
  _onDragStart(e) {
    if (this.rowsDraggable) {
      let t = e.target;
      if (t.localName === "vaadin-grid-cell-content" && (t = t.assignedSlot.parentNode.parentNode), t.parentNode !== this.$.items)
        return;
      if (e.stopPropagation(), this.toggleAttribute("dragging-rows", !0), this._safari) {
        const a = t.style.transform;
        t.style.top = /translateY\((.*)\)/u.exec(a)[1], t.style.transform = "none", requestAnimationFrame(() => {
          t.style.top = "", t.style.transform = a;
        });
      }
      const i = t.getBoundingClientRect();
      df ? e.dataTransfer.setDragImage(t) : e.dataTransfer.setDragImage(t, e.clientX - i.left, e.clientY - i.top);
      let r = [t];
      this._isSelected(t._item) && (r = this.__getViewportRows().filter((a) => this._isSelected(a._item)).filter((a) => !this.dragFilter || this.dragFilter(this.__getRowModel(a)))), this.__draggedItems = r.map((a) => a._item), e.dataTransfer.setData("text", this.__formatDefaultTransferData(r)), Ai(t, { dragstart: r.length > 1 ? `${r.length}` : "" }), this.style.setProperty("--_grid-drag-start-x", `${e.clientX - i.left + 20}px`), this.style.setProperty("--_grid-drag-start-y", `${e.clientY - i.top + 10}px`), requestAnimationFrame(() => {
        Ai(t, { dragstart: !1 }), this.style.setProperty("--_grid-drag-start-x", ""), this.style.setProperty("--_grid-drag-start-y", ""), this.requestContentUpdate();
      });
      const o = new CustomEvent("grid-dragstart", {
        detail: {
          draggedItems: [...this.__draggedItems],
          setDragData: (a, c) => e.dataTransfer.setData(a, c),
          setDraggedItemsCount: (a) => t.setAttribute("dragstart", a)
        }
      });
      o.originalEvent = e, this.dispatchEvent(o);
    }
  }
  /** @private */
  _onDragEnd(e) {
    this.toggleAttribute("dragging-rows", !1), e.stopPropagation();
    const t = new CustomEvent("grid-dragend");
    t.originalEvent = e, this.dispatchEvent(t), this.__draggedItems = [], this.requestContentUpdate();
  }
  /** @private */
  _onDragLeave(e) {
    e.stopPropagation(), this._clearDragStyles();
  }
  /** @private */
  _onDragOver(e) {
    if (this.dropMode) {
      if (this._dropLocation = void 0, this._dragOverItem = void 0, this.__dndAutoScroll(e.clientY)) {
        this._clearDragStyles();
        return;
      }
      let t = e.composedPath().find((i) => i.localName === "tr");
      if (!this._flatSize || this.dropMode === or.ON_GRID)
        this._dropLocation = Ut.EMPTY;
      else if (!t || t.parentNode !== this.$.items) {
        if (t)
          return;
        if (this.dropMode === or.BETWEEN || this.dropMode === or.ON_TOP_OR_BETWEEN)
          t = Array.from(this.$.items.children).filter((i) => !i.hidden).pop(), this._dropLocation = Ut.BELOW;
        else
          return;
      } else {
        const i = t.getBoundingClientRect();
        if (this._dropLocation = Ut.ON_TOP, this.dropMode === or.BETWEEN) {
          const r = e.clientY - i.top < i.bottom - e.clientY;
          this._dropLocation = r ? Ut.ABOVE : Ut.BELOW;
        } else this.dropMode === or.ON_TOP_OR_BETWEEN && (e.clientY - i.top < i.height / 3 ? this._dropLocation = Ut.ABOVE : e.clientY - i.top > i.height / 3 * 2 && (this._dropLocation = Ut.BELOW));
      }
      if (t && t.hasAttribute("drop-disabled")) {
        this._dropLocation = void 0;
        return;
      }
      e.stopPropagation(), e.preventDefault(), this._dropLocation === Ut.EMPTY ? this.toggleAttribute("dragover", !0) : t ? (this._dragOverItem = t._item, t.getAttribute("dragover") !== this._dropLocation && Oa(t, { dragover: this._dropLocation })) : this._clearDragStyles();
    }
  }
  /** @private */
  __onDocumentDragStart(e) {
    if (e.target.contains(this) && this.$.items.offsetHeight > 2e4) {
      const t = this.$.items.style.maxHeight, i = this.$.table.style.overflow;
      this.$.items.style.maxHeight = "0", this.$.table.style.overflow = "hidden", requestAnimationFrame(() => {
        this.$.items.style.maxHeight = t, this.$.table.style.overflow = i;
      });
    }
  }
  /** @private */
  __dndAutoScroll(e) {
    if (this.__dndAutoScrolling)
      return !0;
    const t = this.$.header.getBoundingClientRect().bottom, i = this.$.footer.getBoundingClientRect().top, r = t - e + this.__dndAutoScrollThreshold, o = e - i + this.__dndAutoScrollThreshold;
    let a = 0;
    if (o > 0 ? a = o * 2 : r > 0 && (a = -r * 2), a) {
      const c = this.$.table.scrollTop;
      if (this.$.table.scrollTop += a, c !== this.$.table.scrollTop)
        return this.__dndAutoScrolling = !0, setTimeout(() => {
          this.__dndAutoScrolling = !1;
        }, 20), !0;
    }
  }
  /** @private */
  __getViewportRows() {
    const e = this.$.header.getBoundingClientRect().bottom, t = this.$.footer.getBoundingClientRect().top;
    return Array.from(this.$.items.children).filter((i) => {
      const r = i.getBoundingClientRect();
      return r.bottom > e && r.top < t;
    });
  }
  /** @protected */
  _clearDragStyles() {
    this.removeAttribute("dragover"), ht(this.$.items, (e) => {
      Oa(e, { dragover: null });
    });
  }
  /** @private */
  __updateDragSourceParts(e, t) {
    Ai(e, { "drag-source": this.__draggedItems.includes(t.item) });
  }
  /** @private */
  _onDrop(e) {
    if (this.dropMode) {
      e.stopPropagation(), e.preventDefault();
      const t = e.dataTransfer.types && Array.from(e.dataTransfer.types).map((r) => ({
        type: r,
        data: e.dataTransfer.getData(r)
      }));
      this._clearDragStyles();
      const i = new CustomEvent("grid-drop", {
        bubbles: e.bubbles,
        cancelable: e.cancelable,
        detail: {
          dropTargetItem: this._dragOverItem,
          dropLocation: this._dropLocation,
          dragData: t
        }
      });
      i.originalEvent = e, this.dispatchEvent(i);
    }
  }
  /** @private */
  __formatDefaultTransferData(e) {
    return e.map((t) => Array.from(t.children).filter((i) => !i.hidden && i.getAttribute("part").indexOf("details-cell") === -1).sort((i, r) => i._column._order > r._column._order ? 1 : -1).map((i) => i._content.textContent.trim()).filter((i) => i).join("	")).join(`
`);
  }
  /** @private */
  _dragDropAccessChanged() {
    this.filterDragAndDrop();
  }
  /**
   * Runs the `dragFilter` and `dropFilter` hooks for the visible cells.
   * If the filter depends on varying conditions, you may need to
   * call this function manually in order to update the draggability when
   * the conditions change.
   */
  filterDragAndDrop() {
    ht(this.$.items, (e) => {
      e.hidden || this._filterDragAndDrop(e, this.__getRowModel(e));
    });
  }
  /**
   * @param {!HTMLElement} row
   * @param {!GridItemModel} model
   * @protected
   */
  _filterDragAndDrop(e, t) {
    const i = this.loading || e.hasAttribute("loading"), r = !this.rowsDraggable || i || this.dragFilter && !this.dragFilter(t), o = !this.dropMode || i || this.dropFilter && !this.dropFilter(t);
    Bi(e, (a) => {
      r ? a._content.removeAttribute("draggable") : a._content.setAttribute("draggable", !0);
    }), Ai(e, {
      "drag-disabled": !!r,
      "drop-disabled": !!o
    });
  }
  /**
   * Fired when starting to drag grid rows.
   *
   * @event grid-dragstart
   * @param {Object} originalEvent The native dragstart event
   * @param {Object} detail
   * @param {Object} detail.draggedItems the items in the visible viewport that are dragged
   * @param {Function} detail.setDraggedItemsCount Overrides the default number shown in the drag image on multi row drag.
   * Parameter is of type number.
   * @param {Function} detail.setDragData Sets dataTransfer data for the drag operation.
   * Note that "text" is the only data type supported by all the browsers the grid currently supports (including IE11).
   * The function takes two parameters:
   * - type:string The type of the data
   * - data:string The data
   */
  /**
   * Fired when the dragging of the rows ends.
   *
   * @event grid-dragend
   * @param {Object} originalEvent The native dragend event
   */
  /**
   * Fired when a drop occurs on top of the grid.
   *
   * @event grid-drop
   * @param {Object} originalEvent The native drop event
   * @param {Object} detail
   * @param {Object} detail.dropTargetItem The item of the grid row on which the drop occurred.
   * @param {string} detail.dropLocation The position at which the drop event took place relative to a row.
   * Depending on the dropMode value, the drop location can be one of the following
   * - `on-top`: when the drop occurred on top of the row
   * - `above`: when the drop occurred above the row
   * - `below`: when the drop occurred below the row
   * - `empty`: when the drop occurred over the grid, not relative to any specific row
   * @param {string} detail.dragData An array of items with the payload as a string representation as the
   * `data` property and the type of the data as `type` property.
   */
};
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function oc(s, n) {
  if (!s || !n || s.length !== n.length)
    return !1;
  for (let e = 0, t = s.length; e < t; e++)
    if (s[e] instanceof Array && n[e] instanceof Array) {
      if (!oc(s[e], n[e]))
        return !1;
    } else if (s[e] !== n[e])
      return !1;
  return !0;
}
const ff = (s) => class extends s {
  static get properties() {
    return {
      /**
       * @protected
       */
      _columnTree: Object
    };
  }
  /** @protected */
  ready() {
    super.ready(), this._addNodeObserver();
  }
  /** @private */
  _hasColumnGroups(e) {
    return e.some((t) => t.localName === "vaadin-grid-column-group");
  }
  /**
   * @param {!GridColumnGroup} el
   * @return {!Array<!GridColumn>}
   * @protected
   */
  _getChildColumns(e) {
    return zi.getColumns(e);
  }
  /** @private */
  _flattenColumnGroups(e) {
    return e.map((t) => t.localName === "vaadin-grid-column-group" ? this._getChildColumns(t) : [t]).reduce((t, i) => t.concat(i), []);
  }
  /** @private */
  _getColumnTree() {
    const e = zi.getColumns(this), t = [e];
    let i = e;
    for (; this._hasColumnGroups(i); )
      i = this._flattenColumnGroups(i), t.push(i);
    return t;
  }
  /** @protected */
  _debounceUpdateColumnTree() {
    this.__updateColumnTreeDebouncer = Me.debounce(
      this.__updateColumnTreeDebouncer,
      yt,
      () => this._updateColumnTree()
    );
  }
  /** @protected */
  _updateColumnTree() {
    const e = this._getColumnTree();
    oc(e, this._columnTree) || (e.forEach((t) => {
      t.forEach((i) => {
        i.performUpdate && i.performUpdate();
      });
    }), this._columnTree = e);
  }
  /** @private */
  _addNodeObserver() {
    this._observer = new zi(this, (e, t) => {
      const i = t.flatMap((o) => o._allCells), r = (o) => i.filter((a) => a && a._content.contains(o)).length;
      this.__removeSorters(this._sorters.filter(r)), this.__removeFilters(this._filters.filter(r)), this._debounceUpdateColumnTree(), this._debouncerCheckImports = Me.debounce(
        this._debouncerCheckImports,
        zt.after(2e3),
        this._checkImports.bind(this)
      ), this._ensureFirstPageLoaded();
    });
  }
  /** @protected */
  _checkImports() {
    [
      "vaadin-grid-column-group",
      "vaadin-grid-filter",
      "vaadin-grid-filter-column",
      "vaadin-grid-tree-toggle",
      "vaadin-grid-selection-column",
      "vaadin-grid-sort-column",
      "vaadin-grid-sorter"
    ].forEach((e) => {
      this.querySelector(e) && !customElements.get(e) && console.warn(`Make sure you have imported the required module for <${e}> element.`);
    });
  }
  /** @protected */
  _updateFirstAndLastColumn() {
    Array.from(this.shadowRoot.querySelectorAll("tr")).forEach((e) => this._updateFirstAndLastColumnForRow(e));
  }
  /**
   * @param {!HTMLElement} row
   * @protected
   */
  _updateFirstAndLastColumnForRow(e) {
    Array.from(e.querySelectorAll('[part~="cell"]:not([part~="details-cell"])')).sort((t, i) => t._column._order - i._column._order).forEach((t, i, r) => {
      si(t, "first-column", i === 0), si(t, "last-column", i === r.length - 1);
    });
  }
  /**
   * @param {!Node} node
   * @return {boolean}
   * @protected
   */
  _isColumnElement(e) {
    return e.nodeType === Node.ELEMENT_NODE && /\bcolumn\b/u.test(e.localName);
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const pf = (s) => class extends s {
  /**
   * Returns an object with context information about the event target:
   * - `item`: the data object corresponding to the targeted row (not specified when targeting header or footer)
   * - `column`: the column element corresponding to the targeted cell (not specified when targeting row details)
   * - `section`: whether the event targeted the body, header, footer or details of the grid
   *
   * These additional properties are included when `item` is specified:
   * - `index`: the index of the item
   * - `selected`: the selected state of the item
   * - `detailsOpened`: whether the row details are open for the item
   * - `expanded`: the expanded state of the tree toggle
   * - `level`: the tree hierarchy level
   *
   * The returned object is populated only when a grid cell, header, footer or row details is found in `event.composedPath()`.
   * This means mostly mouse and keyboard events. If such a grid part is not found in the path, an empty object is returned.
   * This may be the case eg. if the event is fired on the `<vaadin-grid>` element and not any deeper in the DOM, or if
   * the event targets the empty part of the grid body.
   *
   * @param {!Event} event
   * @return {GridEventContext}
   */
  getEventContext(e) {
    const t = {}, { cell: i } = this._getGridEventLocation(e);
    return i && (t.section = ["body", "header", "footer", "details"].find(
      (r) => i.getAttribute("part").indexOf(r) > -1
    ), i._column && (t.column = i._column), (t.section === "body" || t.section === "details") && Object.assign(t, this.__getRowModel(i.parentElement))), t;
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const gf = (s) => class extends s {
  static get properties() {
    return {
      /** @private */
      _filters: {
        type: Array,
        value: () => []
      }
    };
  }
  constructor() {
    super(), this._filterChanged = this._filterChanged.bind(this), this.addEventListener("filter-changed", this._filterChanged);
  }
  /** @private */
  _filterChanged(e) {
    e.stopPropagation(), this.__addFilter(e.target), this.__applyFilters();
  }
  /** @private */
  __removeFilters(e) {
    e.length !== 0 && (this._filters = this._filters.filter((t) => e.indexOf(t) < 0), this.__applyFilters());
  }
  /** @private */
  __addFilter(e) {
    this._filters.indexOf(e) === -1 && this._filters.push(e);
  }
  /** @private */
  __applyFilters() {
    this.dataProvider && this.isAttached && this.clearCache();
  }
  /**
   * @return {!Array<!GridFilterDefinition>}
   * @protected
   */
  _mapFilters() {
    return this._filters.map((e) => ({
      path: e.path,
      value: e.value
    }));
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function Xr(s) {
  return s instanceof HTMLTableRowElement;
}
function Qr(s) {
  return s instanceof HTMLTableCellElement;
}
function oi(s) {
  return s.matches('[part~="details-cell"]');
}
const mf = (s) => class extends s {
  static get properties() {
    return {
      /** @private */
      _headerFocusable: {
        type: Object,
        observer: "_focusableChanged",
        sync: !0
      },
      /**
       * @type {!HTMLElement | undefined}
       * @protected
       */
      _itemsFocusable: {
        type: Object,
        observer: "_focusableChanged",
        sync: !0
      },
      /** @private */
      _footerFocusable: {
        type: Object,
        observer: "_focusableChanged",
        sync: !0
      },
      /** @private */
      _navigatingIsHidden: Boolean,
      /**
       * @type {number}
       * @protected
       */
      _focusedItemIndex: {
        type: Number,
        value: 0
      },
      /** @private */
      _focusedColumnOrder: Number,
      /** @private */
      _focusedCell: {
        type: Object,
        observer: "_focusedCellChanged",
        sync: !0
      },
      /**
       * Indicates whether the grid is currently in interaction mode.
       * In interaction mode the user is currently interacting with a control,
       * such as an input or a select, within a cell.
       * In interaction mode keyboard navigation between cells is disabled.
       * Interaction mode also prevents the focus target cell of that section of
       * the grid from receiving focus, allowing the user to switch focus to
       * controls in adjacent cells, rather than focussing the outer cell
       * itself.
       * @type {boolean}
       * @private
       */
      interacting: {
        type: Boolean,
        value: !1,
        reflectToAttribute: !0,
        readOnly: !0,
        observer: "_interactingChanged"
      }
    };
  }
  /** @private */
  get __rowFocusMode() {
    return [this._headerFocusable, this._itemsFocusable, this._footerFocusable].some(Xr);
  }
  set __rowFocusMode(e) {
    ["_itemsFocusable", "_footerFocusable", "_headerFocusable"].forEach((t) => {
      const i = this[t];
      if (e) {
        const r = i && i.parentElement;
        Qr(i) ? this[t] = r : Qr(r) && (this[t] = r.parentElement);
      } else if (!e && Xr(i)) {
        const r = i.firstElementChild;
        this[t] = r._focusButton || r;
      }
    });
  }
  /** @private */
  get _visibleItemsCount() {
    return this._lastVisibleIndex - this._firstVisibleIndex - 1;
  }
  /** @protected */
  ready() {
    super.ready(), !(this._ios || this._android) && (this.addEventListener("keydown", this._onKeyDown), this.addEventListener("keyup", this._onKeyUp), this.addEventListener("focusin", this._onFocusIn), this.addEventListener("focusout", this._onFocusOut), this.$.table.addEventListener("focusin", this._onContentFocusIn.bind(this)), this.addEventListener("mousedown", () => {
      this.toggleAttribute("navigating", !1), this._isMousedown = !0, this._focusedColumnOrder = void 0;
    }), this.addEventListener("mouseup", () => {
      this._isMousedown = !1;
    }));
  }
  /** @private */
  _focusableChanged(e, t) {
    t && t.setAttribute("tabindex", "-1"), e && this._updateGridSectionFocusTarget(e);
  }
  /** @private */
  _focusedCellChanged(e, t) {
    t && ds(t, "part", "focused-cell"), e && In(e, "part", "focused-cell");
  }
  /** @private */
  _interactingChanged() {
    this._updateGridSectionFocusTarget(this._headerFocusable), this._updateGridSectionFocusTarget(this._itemsFocusable), this._updateGridSectionFocusTarget(this._footerFocusable);
  }
  /**
   * Since the focused cell/row state is stored as an element reference, the reference may get
   * out of sync when the virtual indexes for elements update due to effective size change.
   * This function updates the reference to the correct element after a possible index change.
   * @private
   */
  __updateItemsFocusable() {
    if (!this._itemsFocusable)
      return;
    const e = this.shadowRoot.activeElement === this._itemsFocusable;
    this._getRenderedRows().forEach((t) => {
      if (t.index === this._focusedItemIndex)
        if (this.__rowFocusMode)
          this._itemsFocusable = t;
        else {
          let i = this._itemsFocusable.parentElement, r = this._itemsFocusable;
          if (i) {
            Qr(i) && (r = i, i = i.parentElement);
            const o = [...i.children].indexOf(r);
            this._itemsFocusable = this.__getFocusable(t, t.children[o]);
          }
        }
    }), e && this._itemsFocusable.focus();
  }
  /**
   * @param {!KeyboardEvent} e
   * @protected
   */
  _onKeyDown(e) {
    const t = e.key;
    let i;
    switch (t) {
      case "ArrowUp":
      case "ArrowDown":
      case "ArrowLeft":
      case "ArrowRight":
      case "PageUp":
      case "PageDown":
      case "Home":
      case "End":
        i = "Navigation";
        break;
      case "Enter":
      case "Escape":
      case "F2":
        i = "Interaction";
        break;
      case "Tab":
        i = "Tab";
        break;
      case " ":
        i = "Space";
        break;
    }
    this._detectInteracting(e), this.interacting && i !== "Interaction" && (i = void 0), i && this[`_on${i}KeyDown`](e, t);
  }
  /** @private */
  __ensureFlatIndexInViewport(e) {
    [...this.$.items.children].find((i) => i.index === e) ? this.__scrollIntoViewport(e) : this._scrollToFlatIndex(e);
  }
  /** @private */
  __isRowExpandable(e) {
    if (this.itemHasChildrenPath) {
      const t = e._item;
      return !!(t && pi(this.itemHasChildrenPath, t) && !this._isExpanded(t));
    }
  }
  /** @private */
  __isRowCollapsible(e) {
    return this._isExpanded(e._item);
  }
  /** @private */
  _onNavigationKeyDown(e, t) {
    e.preventDefault();
    const i = this.__isRTL, r = e.composedPath().find(Xr), o = e.composedPath().find(Qr);
    let a = 0, c = 0;
    switch (t) {
      case "ArrowRight":
        a = i ? -1 : 1;
        break;
      case "ArrowLeft":
        a = i ? 1 : -1;
        break;
      case "Home":
        this.__rowFocusMode || e.ctrlKey ? c = -1 / 0 : a = -1 / 0;
        break;
      case "End":
        this.__rowFocusMode || e.ctrlKey ? c = 1 / 0 : a = 1 / 0;
        break;
      case "ArrowDown":
        c = 1;
        break;
      case "ArrowUp":
        c = -1;
        break;
      case "PageDown":
        if (this.$.items.contains(r)) {
          const f = this.__getIndexInGroup(r, this._focusedItemIndex);
          this._scrollToFlatIndex(f);
        }
        c = this._visibleItemsCount;
        break;
      case "PageUp":
        c = -this._visibleItemsCount;
        break;
    }
    if (this.__rowFocusMode && !r || !this.__rowFocusMode && !o)
      return;
    const u = i ? "ArrowLeft" : "ArrowRight", h = i ? "ArrowRight" : "ArrowLeft";
    if (t === u) {
      if (this.__rowFocusMode) {
        if (this.__isRowExpandable(r)) {
          this.expandItem(r._item);
          return;
        }
        this.__rowFocusMode = !1, this._onCellNavigation(r.firstElementChild, 0, 0);
        return;
      }
    } else if (t === h)
      if (this.__rowFocusMode) {
        if (this.__isRowCollapsible(r)) {
          this.collapseItem(r._item);
          return;
        }
      } else {
        const f = [...r.children].sort((g, x) => g._order - x._order);
        if (o === f[0] || oi(o)) {
          this.__rowFocusMode = !0, this._onRowNavigation(r, 0);
          return;
        }
      }
    this.__rowFocusMode ? this._onRowNavigation(r, c) : this._onCellNavigation(o, a, c);
  }
  /**
   * Focuses the target row after navigating by the given dy offset.
   * If the row is not in the viewport, it is first scrolled to.
   * @private
   */
  _onRowNavigation(e, t) {
    const { dstRow: i } = this.__navigateRows(t, e);
    i && i.focus();
  }
  /** @private */
  __getIndexInGroup(e, t) {
    const i = e.parentNode;
    return i === this.$.items ? t !== void 0 ? t : e.index : [...i.children].indexOf(e);
  }
  /**
   * Returns the target row after navigating by the given dy offset.
   * Also returns information whether the details cell should be the target on the target row.
   * If the row is not in the viewport, it is first scrolled to.
   * @private
   */
  __navigateRows(e, t, i) {
    const r = this.__getIndexInGroup(t, this._focusedItemIndex), o = t.parentNode, a = (o === this.$.items ? this._flatSize : o.children.length) - 1;
    let c = Math.max(0, Math.min(r + e, a));
    if (o !== this.$.items) {
      if (c > r)
        for (; c < a && o.children[c].hidden; )
          c += 1;
      else if (c < r)
        for (; c > 0 && o.children[c].hidden; )
          c -= 1;
      return this.toggleAttribute("navigating", !0), { dstRow: o.children[c] };
    }
    let u = !1;
    if (i) {
      const h = oi(i);
      if (o === this.$.items) {
        const f = t._item, { item: g } = this._dataProviderController.getFlatIndexContext(c);
        h ? u = e === 0 : u = e === 1 && this._isDetailsOpened(f) || e === -1 && c !== r && this._isDetailsOpened(g), u !== h && (e === 1 && u || e === -1 && !u) && (c = r);
      }
    }
    return this.__ensureFlatIndexInViewport(c), this._focusedItemIndex = c, this.toggleAttribute("navigating", !0), {
      dstRow: [...o.children].find((h) => !h.hidden && h.index === c),
      dstIsRowDetails: u
    };
  }
  /**
   * Focuses the target cell after navigating by the given dx and dy offset.
   * If the cell is not in the viewport, it is first scrolled to.
   * @private
   */
  _onCellNavigation(e, t, i) {
    const r = e.parentNode, { dstRow: o, dstIsRowDetails: a } = this.__navigateRows(i, r, e);
    if (!o)
      return;
    let c = [...r.children].indexOf(e);
    this.$.items.contains(e) && (c = [...this.$.sizer.children].findIndex((g) => g._column === e._column));
    const u = oi(e), h = r.parentNode, f = this.__getIndexInGroup(r, this._focusedItemIndex);
    if (this._focusedColumnOrder === void 0 && (u ? this._focusedColumnOrder = 0 : this._focusedColumnOrder = this._getColumns(h, f).filter((g) => !g.hidden)[c]._order), a)
      [...o.children].find(oi).focus();
    else {
      const g = this.__getIndexInGroup(o, this._focusedItemIndex), x = this._getColumns(h, g).filter((re) => !re.hidden), C = x.map((re) => re._order).sort((re, ue) => re - ue), E = C.length - 1, R = C.indexOf(
        C.slice(0).sort((re, ue) => Math.abs(re - this._focusedColumnOrder) - Math.abs(ue - this._focusedColumnOrder))[0]
      ), D = i === 0 && u ? R : Math.max(0, Math.min(R + t, E));
      D !== R && (this._focusedColumnOrder = void 0);
      const Z = x.reduce((re, ue, me) => (re[ue._order] = me, re), {})[C[D]];
      let ce;
      if (this.$.items.contains(e)) {
        const re = this.$.sizer.children[Z];
        this._lazyColumns && (this.__isColumnInViewport(re._column) || re.scrollIntoView(), this.__updateColumnsBodyContentHidden(), this.__updateHorizontalScrollPosition()), ce = [...o.children].find((ue) => ue._column === re._column), this._scrollHorizontallyToCell(ce);
      } else
        ce = o.children[Z], this._scrollHorizontallyToCell(ce);
      ce.focus();
    }
  }
  /** @private */
  _onInteractionKeyDown(e, t) {
    const i = e.composedPath()[0], r = i.localName === "input" && !/^(button|checkbox|color|file|image|radio|range|reset|submit)$/iu.test(i.type);
    let o;
    switch (t) {
      case "Enter":
        o = this.interacting ? !r : !0;
        break;
      case "Escape":
        o = !1;
        break;
      case "F2":
        o = !this.interacting;
        break;
    }
    const { cell: a } = this._getGridEventLocation(e);
    if (this.interacting !== o && a !== null)
      if (o) {
        const c = a._content.querySelector("[focus-target]") || // If a child element hasn't been explicitly marked as a focus target,
        // fall back to any focusable element inside the cell.
        [...a._content.querySelectorAll("*")].find((u) => this._isFocusable(u));
        c && (e.preventDefault(), c.focus(), this._setInteracting(!0), this.toggleAttribute("navigating", !1));
      } else
        e.preventDefault(), this._focusedColumnOrder = void 0, a.focus(), this._setInteracting(!1), this.toggleAttribute("navigating", !0);
    t === "Escape" && this._hideTooltip(!0);
  }
  /** @private */
  _predictFocusStepTarget(e, t) {
    const i = [
      this.$.table,
      this._headerFocusable,
      this.__emptyState ? this.$.emptystatecell : this._itemsFocusable,
      this._footerFocusable,
      this.$.focusexit
    ];
    let r = i.indexOf(e);
    for (r += t; r >= 0 && r <= i.length - 1; ) {
      let a = i[r];
      if (a && !this.__rowFocusMode && (a = i[r].parentNode), !a || a.hidden)
        r += t;
      else
        break;
    }
    let o = i[r];
    if (o && !this.__isHorizontallyInViewport(o)) {
      const a = this._getColumnsInOrder().find((c) => this.__isColumnInViewport(c));
      if (a)
        if (o === this._headerFocusable)
          o = a._headerCell;
        else if (o === this._itemsFocusable) {
          const c = o._column._cells.indexOf(o);
          o = a._cells[c];
        } else o === this._footerFocusable && (o = a._footerCell);
    }
    return o;
  }
  /** @private */
  _onTabKeyDown(e) {
    const t = this._predictFocusStepTarget(e.composedPath()[0], e.shiftKey ? -1 : 1);
    t && (e.stopPropagation(), t === this.$.table ? this.$.table.focus() : t === this.$.focusexit ? this.$.focusexit.focus() : t === this._itemsFocusable ? (this.__ensureFlatIndexInViewport(this._focusedItemIndex), this.__updateItemsFocusable(), e.preventDefault(), this._itemsFocusable.focus()) : (e.preventDefault(), t.focus()), this.toggleAttribute("navigating", !0));
  }
  /** @private */
  _onSpaceKeyDown(e) {
    e.preventDefault();
    const t = e.composedPath()[0], i = Xr(t);
    (i || !t._content || !t._content.firstElementChild) && this.dispatchEvent(
      new CustomEvent(i ? "row-activate" : "cell-activate", {
        detail: {
          model: this.__getRowModel(i ? t : t.parentElement)
        }
      })
    );
  }
  /** @private */
  _onKeyUp(e) {
    if (!/^( |SpaceBar)$/u.test(e.key) || this.interacting)
      return;
    e.preventDefault();
    const t = e.composedPath()[0];
    if (t._content && t._content.firstElementChild) {
      const i = this.hasAttribute("navigating");
      t._content.firstElementChild.dispatchEvent(
        new MouseEvent("click", {
          shiftKey: e.shiftKey,
          bubbles: !0,
          composed: !0,
          cancelable: !0
        })
      ), this.toggleAttribute("navigating", i);
    }
  }
  /**
   * @param {!FocusEvent} e
   * @protected
   */
  _onFocusIn(e) {
    this._isMousedown || this.toggleAttribute("navigating", !0);
    const t = e.composedPath()[0];
    t === this.$.table || t === this.$.focusexit ? (this._isMousedown || this._predictFocusStepTarget(t, t === this.$.table ? 1 : -1).focus(), this._setInteracting(!1)) : this._detectInteracting(e);
  }
  /**
   * @param {!FocusEvent} e
   * @protected
   */
  _onFocusOut(e) {
    this.toggleAttribute("navigating", !1), this._detectInteracting(e), this._hideTooltip(), this._focusedCell = null;
  }
  /** @private */
  _onContentFocusIn(e) {
    const { section: t, cell: i, row: r } = this._getGridEventLocation(e);
    if (!(!i && !this.__rowFocusMode) && (this._detectInteracting(e), t && (i || r)))
      if (this._activeRowGroup = t, t === this.$.header ? this._headerFocusable = this.__getFocusable(r, i) : t === this.$.items ? (this._itemsFocusable = this.__getFocusable(r, i), this._focusedItemIndex = r.index) : t === this.$.footer && (this._footerFocusable = this.__getFocusable(r, i)), i) {
        const o = this.getEventContext(e);
        this.__pendingBodyCellFocus = this.loading && o.section === "body", !this.__pendingBodyCellFocus && i !== this.$.emptystatecell && i.dispatchEvent(new CustomEvent("cell-focus", { bubbles: !0, composed: !0, detail: { context: o } })), this._focusedCell = i._focusButton || i, On() && e.target === i && this._showTooltip(e);
      } else
        this._focusedCell = null;
  }
  /**
   * @private
   */
  __dispatchPendingBodyCellFocus() {
    this.__pendingBodyCellFocus && this.shadowRoot.activeElement === this._itemsFocusable && this._itemsFocusable.dispatchEvent(new Event("focusin", { bubbles: !0, composed: !0 }));
  }
  /**
   * Get the focusable element depending on the current focus mode.
   * It can be a row, a cell, or a focusable div inside a cell.
   *
   * @param {HTMLElement} row
   * @param {HTMLElement} cell
   * @return {HTMLElement}
   * @private
   */
  __getFocusable(e, t) {
    return this.__rowFocusMode ? e : t._focusButton || t;
  }
  /**
   * Enables interaction mode if a cells descendant receives focus or keyboard
   * input. Disables it if the event is not related to cell content.
   * @param {!KeyboardEvent|!FocusEvent} e
   * @private
   */
  _detectInteracting(e) {
    const t = e.composedPath().some((i) => i.localName === "slot" && this.shadowRoot.contains(i));
    this._setInteracting(t), this.__updateHorizontalScrollPosition();
  }
  /**
   * Enables or disables the focus target of the containing section of the
   * grid from receiving focus, based on whether the user is interacting with
   * that section of the grid.
   * @param {HTMLElement} focusTarget
   * @private
   */
  _updateGridSectionFocusTarget(e) {
    if (!e)
      return;
    const t = this._getGridSectionFromFocusTarget(e), i = this.interacting && t === this._activeRowGroup;
    e.tabIndex = i ? -1 : 0;
  }
  /** @protected */
  _preventScrollerRotatingCellFocus() {
    this._activeRowGroup === this.$.items && (this.__preventScrollerRotatingCellFocusDebouncer = Me.debounce(
      this.__preventScrollerRotatingCellFocusDebouncer,
      qt,
      () => {
        const e = this._activeRowGroup === this.$.items;
        this._getRenderedRows().some((i) => i.index === this._focusedItemIndex) ? (this.__updateItemsFocusable(), e && !this.__rowFocusMode && (this._focusedCell = this._itemsFocusable), this._navigatingIsHidden && (this.toggleAttribute("navigating", !0), this._navigatingIsHidden = !1)) : e && (this._focusedCell = null, this.hasAttribute("navigating") && (this._navigatingIsHidden = !0, this.toggleAttribute("navigating", !1)));
      }
    ));
  }
  /**
   * @param {HTMLTableSectionElement=} rowGroup
   * @param {number=} rowIndex
   * @return {!Array<!GridColumn>}
   * @protected
   */
  _getColumns(e, t) {
    let i = this._columnTree.length - 1;
    return e === this.$.header ? i = t : e === this.$.footer && (i = this._columnTree.length - 1 - t), this._columnTree[i];
  }
  /** @private */
  __isValidFocusable(e) {
    return this.$.table.contains(e) && e.offsetHeight;
  }
  /** @protected */
  _resetKeyboardNavigation() {
    if (!this.$ && this.performUpdate && this.performUpdate(), ["header", "footer"].forEach((e) => {
      if (!this.__isValidFocusable(this[`_${e}Focusable`])) {
        const t = [...this.$[e].children].find((r) => r.offsetHeight), i = t ? [...t.children].find((r) => !r.hidden) : null;
        t && i && (this[`_${e}Focusable`] = this.__getFocusable(t, i));
      }
    }), !this.__isValidFocusable(this._itemsFocusable) && this.$.items.firstElementChild) {
      const e = this.__getFirstVisibleItem(), t = e ? [...e.children].find((i) => !i.hidden) : null;
      t && e && (this._focusedColumnOrder = void 0, this._itemsFocusable = this.__getFocusable(e, t));
    } else
      this.__updateItemsFocusable();
  }
  /**
   * @param {!HTMLElement} dstCell
   * @protected
   */
  _scrollHorizontallyToCell(e) {
    if (e.hasAttribute("frozen") || e.hasAttribute("frozen-to-end") || oi(e))
      return;
    const t = e.getBoundingClientRect(), i = e.parentNode, r = Array.from(i.children).indexOf(e), o = this.$.table.getBoundingClientRect();
    let a = o.left, c = o.right;
    for (let u = r - 1; u >= 0; u--) {
      const h = i.children[u];
      if (!(h.hasAttribute("hidden") || oi(h)) && (h.hasAttribute("frozen") || h.hasAttribute("frozen-to-end"))) {
        a = h.getBoundingClientRect().right;
        break;
      }
    }
    for (let u = r + 1; u < i.children.length; u++) {
      const h = i.children[u];
      if (!(h.hasAttribute("hidden") || oi(h)) && (h.hasAttribute("frozen") || h.hasAttribute("frozen-to-end"))) {
        c = h.getBoundingClientRect().left;
        break;
      }
    }
    t.left < a && (this.$.table.scrollLeft += Math.round(t.left - a)), t.right > c && (this.$.table.scrollLeft += Math.round(t.right - c));
  }
  /**
   * @typedef {Object} GridEventLocation
   * @property {HTMLTableSectionElement | null} section - The table section element that the event occurred in (header, body, or footer), or null if the event did not occur in a section
   * @property {HTMLTableRowElement | null} row - The row element that the event occurred in, or null if the event did not occur in a row
   * @property {HTMLTableCellElement | null} cell - The cell element that the event occurred in, or null if the event did not occur in a cell
   * @private
   */
  /**
   * Takes an event and returns a location object describing in which part of the grid the event occurred.
   * The event may either target table section, a row, a cell or contents of a cell.
   * @param {Event} e
   * @returns {GridEventLocation}
   * @protected
   */
  _getGridEventLocation(e) {
    const t = e.__composedPath || e.composedPath(), i = t.indexOf(this.$.table), r = i >= 1 ? t[i - 1] : null, o = i >= 2 ? t[i - 2] : null, a = i >= 3 ? t[i - 3] : null;
    return {
      section: r,
      row: o,
      cell: a
    };
  }
  /**
   * Helper method that maps a focus target cell to the containing grid section
   * @param {HTMLElement} focusTarget
   * @returns {HTMLTableSectionElement | null}
   * @private
   */
  _getGridSectionFromFocusTarget(e) {
    return e === this._headerFocusable ? this.$.header : e === this._itemsFocusable ? this.$.items : e === this._footerFocusable ? this.$.footer : null;
  }
  /**
   * Fired when a cell is focused with click or keyboard navigation.
   *
   * Use context property of @see {@link GridCellFocusEvent} to get detail information about the event.
   *
   * @event cell-focus
   */
};
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const vf = (s) => class extends s {
  static get properties() {
    return {
      /**
       * An array containing references to items with open row details.
       * @type {!Array<!GridItem>}
       */
      detailsOpenedItems: {
        type: Array,
        value: () => [],
        sync: !0
      },
      /**
       * Custom function for rendering the content of the row details.
       * Receives three arguments:
       *
       * - `root` The row details content DOM element. Append your content to it.
       * - `grid` The `<vaadin-grid>` element.
       * - `model` The object with the properties related with
       *   the rendered item, contains:
       *   - `model.index` The index of the item.
       *   - `model.item` The item.
       *   - `model.level` The number of the item's tree sublevel, starts from 0.
       *   - `model.expanded` True if the item's tree sublevel is expanded.
       *   - `model.selected` True if the item is selected.
       *
       * @type {GridRowDetailsRenderer | null | undefined}
       */
      rowDetailsRenderer: {
        type: Function,
        sync: !0
      },
      /**
       * @type {!Array<!HTMLElement> | undefined}
       * @protected
       */
      _detailsCells: {
        type: Array
      }
    };
  }
  static get observers() {
    return [
      "_detailsOpenedItemsChanged(detailsOpenedItems, rowDetailsRenderer)",
      "_rowDetailsRendererChanged(rowDetailsRenderer)"
    ];
  }
  /** @protected */
  ready() {
    super.ready(), this._detailsCellResizeObserver = new ResizeObserver((e) => {
      e.forEach(({ target: t }) => {
        this._updateDetailsCellHeight(t.parentElement);
      }), this.__virtualizer.__adapter._resizeHandler();
    });
  }
  /** @private */
  _rowDetailsRendererChanged(e) {
    e && this._columnTree && ht(this.$.items, (t) => {
      if (!t.querySelector("[part~=details-cell]")) {
        this._updateRow(t, this._columnTree[this._columnTree.length - 1]);
        const i = this._isDetailsOpened(t._item);
        this._toggleDetailsCell(t, i);
      }
    });
  }
  /** @private */
  _detailsOpenedItemsChanged(e, t) {
    ht(this.$.items, (i) => {
      if (i.hasAttribute("details-opened")) {
        this._updateItem(i, i._item);
        return;
      }
      t && this._isDetailsOpened(i._item) && this._updateItem(i, i._item);
    });
  }
  /**
   * @param {!HTMLElement} cell
   * @protected
   */
  _configureDetailsCell(e) {
    e.setAttribute("part", "cell details-cell"), e.toggleAttribute("frozen", !0), this._detailsCellResizeObserver.observe(e);
  }
  /**
   * @param {!HTMLElement} row
   * @param {!GridItem} item
   * @protected
   */
  _toggleDetailsCell(e, t) {
    const i = e.querySelector('[part~="details-cell"]');
    i && (i.hidden = !t, !i.hidden && this.rowDetailsRenderer && (i._renderer = this.rowDetailsRenderer));
  }
  /** @protected */
  _updateDetailsCellHeight(e) {
    const t = e.querySelector('[part~="details-cell"]');
    t && (this.__updateDetailsRowPadding(e, t), requestAnimationFrame(() => this.__updateDetailsRowPadding(e, t)));
  }
  /** @private */
  __updateDetailsRowPadding(e, t) {
    t.hidden ? e.style.removeProperty("padding-bottom") : e.style.setProperty("padding-bottom", `${t.offsetHeight}px`);
  }
  /** @protected */
  _updateDetailsCellHeights() {
    ht(this.$.items, (e) => {
      this._updateDetailsCellHeight(e);
    });
  }
  /**
   * @param {!GridItem} item
   * @return {boolean}
   * @protected
   */
  _isDetailsOpened(e) {
    return this.detailsOpenedItems && this._getItemIndexInArray(e, this.detailsOpenedItems) !== -1;
  }
  /**
   * Open the details row of a given item.
   * @param {!GridItem} item
   */
  openItemDetails(e) {
    this._isDetailsOpened(e) || (this.detailsOpenedItems = [...this.detailsOpenedItems, e]);
  }
  /**
   * Close the details row of a given item.
   * @param {!GridItem} item
   */
  closeItemDetails(e) {
    this._isDetailsOpened(e) && (this.detailsOpenedItems = this.detailsOpenedItems.filter((t) => !this._itemsEqual(t, e)));
  }
};
/**
 * @license
 * Copyright (c) 2022 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Fn = document.createElement("div");
Fn.style.position = "fixed";
Fn.style.clip = "rect(0px, 0px, 0px, 0px)";
Fn.setAttribute("aria-live", "polite");
document.body.appendChild(Fn);
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const ys = rt(
  (s) => class extends s {
    /** @protected */
    ready() {
      super.ready(), this.addEventListener("keydown", (e) => {
        this._onKeyDown(e);
      }), this.addEventListener("keyup", (e) => {
        this._onKeyUp(e);
      });
    }
    /**
     * A handler for the `keydown` event. By default, it calls
     * separate methods for handling "Enter" and "Escape" keys.
     * Override the method to implement your own behavior.
     *
     * @param {KeyboardEvent} event
     * @protected
     */
    _onKeyDown(e) {
      switch (e.key) {
        case "Enter":
          this._onEnter(e);
          break;
        case "Escape":
          this._onEscape(e);
          break;
      }
    }
    /**
     * A handler for the `keyup` event. By default, it does nothing.
     * Override the method to implement your own behavior.
     *
     * @param {KeyboardEvent} _event
     * @protected
     */
    _onKeyUp(e) {
    }
    /**
     * A handler for the "Enter" key. By default, it does nothing.
     * Override the method to implement your own behavior.
     *
     * @param {KeyboardEvent} _event
     * @protected
     */
    _onEnter(e) {
    }
    /**
     * A handler for the "Escape" key. By default, it does nothing.
     * Override the method to implement your own behavior.
     *
     * @param {KeyboardEvent} _event
     * @protected
     */
    _onEscape(e) {
    }
  }
);
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const sc = rt(
  (s) => class extends s {
    /**
     * @protected
     * @return {boolean}
     */
    get _keyboardActive() {
      return On();
    }
    /** @protected */
    ready() {
      this.addEventListener("focusin", (e) => {
        this._shouldSetFocus(e) && this._setFocused(!0);
      }), this.addEventListener("focusout", (e) => {
        this._shouldRemoveFocus(e) && this._setFocused(!1);
      }), super.ready();
    }
    /** @protected */
    disconnectedCallback() {
      super.disconnectedCallback(), this.hasAttribute("focused") && this._setFocused(!1);
    }
    /**
     * Override to change how focused and focus-ring attributes are set.
     *
     * @param {boolean} focused
     * @protected
     */
    _setFocused(e) {
      this.toggleAttribute("focused", e), this.toggleAttribute("focus-ring", e && this._keyboardActive);
    }
    /**
     * Override to define if the field receives focus based on the event.
     *
     * @param {FocusEvent} _event
     * @return {boolean}
     * @protected
     */
    _shouldSetFocus(e) {
      return !0;
    }
    /**
     * Override to define if the field loses focus based on the event.
     *
     * @param {FocusEvent} _event
     * @return {boolean}
     * @protected
     */
    _shouldRemoveFocus(e) {
      return !0;
    }
  }
);
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const _f = rt(
  (s) => class extends sc(Gl(s)) {
    static get properties() {
      return {
        /**
         * Specify that this control should have input focus when the page loads.
         */
        autofocus: {
          type: Boolean
        },
        /**
         * A reference to the focusable element controlled by the mixin.
         * It can be an input, textarea, button or any element with tabindex > -1.
         *
         * Any component implementing this mixin is expected to provide it
         * by using `this._setFocusElement(input)` Polymer API.
         *
         * Toggling `tabindex` attribute on the host element propagates its value to `focusElement`.
         *
         * @protected
         * @type {!HTMLElement}
         */
        focusElement: {
          type: Object,
          readOnly: !0,
          observer: "_focusElementChanged"
        },
        /**
         * Override the property from `TabIndexMixin`
         * to ensure the `tabindex` attribute of the focus element
         * will be restored to `0` after re-enabling the element.
         *
         * @protected
         * @override
         */
        _lastTabIndex: {
          value: 0
        }
      };
    }
    constructor() {
      super(), this._boundOnBlur = this._onBlur.bind(this), this._boundOnFocus = this._onFocus.bind(this);
    }
    /** @protected */
    ready() {
      super.ready(), this.autofocus && !this.disabled && requestAnimationFrame(() => {
        this.focus(), this.setAttribute("focus-ring", "");
      });
    }
    /**
     * @protected
     * @override
     */
    focus() {
      this.focusElement && !this.disabled && this.focusElement.focus();
    }
    /**
     * @protected
     * @override
     */
    blur() {
      this.focusElement && this.focusElement.blur();
    }
    /**
     * @protected
     * @override
     */
    click() {
      this.focusElement && !this.disabled && this.focusElement.click();
    }
    /** @protected */
    _focusElementChanged(e, t) {
      e ? (e.disabled = this.disabled, this._addFocusListeners(e), this.__forwardTabIndex(this.tabindex)) : t && this._removeFocusListeners(t);
    }
    /**
     * @param {HTMLElement} element
     * @protected
     */
    _addFocusListeners(e) {
      e.addEventListener("blur", this._boundOnBlur), e.addEventListener("focus", this._boundOnFocus);
    }
    /**
     * @param {HTMLElement} element
     * @protected
     */
    _removeFocusListeners(e) {
      e.removeEventListener("blur", this._boundOnBlur), e.removeEventListener("focus", this._boundOnFocus);
    }
    /**
     * Focus event does not bubble, so we dispatch it manually
     * on the host element to support adding focus listeners
     * when the focusable element is placed in light DOM.
     * @param {FocusEvent} event
     * @protected
     */
    _onFocus(e) {
      e.stopPropagation(), this.dispatchEvent(new Event("focus"));
    }
    /**
     * Blur event does not bubble, so we dispatch it manually
     * on the host element to support adding blur listeners
     * when the focusable element is placed in light DOM.
     * @param {FocusEvent} event
     * @protected
     */
    _onBlur(e) {
      e.stopPropagation(), this.dispatchEvent(new Event("blur"));
    }
    /**
     * @param {FocusEvent} event
     * @return {boolean}
     * @protected
     * @override
     */
    _shouldSetFocus(e) {
      return e.target === this.focusElement;
    }
    /**
     * @param {FocusEvent} event
     * @return {boolean}
     * @protected
     * @override
     */
    _shouldRemoveFocus(e) {
      return e.target === this.focusElement;
    }
    /**
     * @param {boolean} disabled
     * @param {boolean} oldDisabled
     * @protected
     * @override
     */
    _disabledChanged(e, t) {
      super._disabledChanged(e, t), this.focusElement && (this.focusElement.disabled = e), e && this.blur();
    }
    /**
     * Override an observer from `TabindexMixin`.
     * Do not call super to remove tabindex attribute
     * from the host after it has been forwarded.
     * @param {string} tabindex
     * @protected
     * @override
     */
    _tabindexChanged(e) {
      this.__forwardTabIndex(e);
    }
    /** @private */
    __forwardTabIndex(e) {
      e !== void 0 && this.focusElement && (this.focusElement.tabIndex = e, e !== -1 && (this.tabindex = void 0)), this.disabled && e && (e !== -1 && (this._lastTabIndex = e), this.tabindex = void 0);
    }
  }
);
/**
 * @license
 * Copyright (c) 2023 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const xo = /* @__PURE__ */ new Map();
function ws(s) {
  return xo.has(s) || xo.set(s, /* @__PURE__ */ new WeakMap()), xo.get(s);
}
function ac(s, n) {
  s && s.removeAttribute(n);
}
function lc(s, n) {
  if (!s || !n)
    return;
  const e = ws(n);
  if (e.has(s))
    return;
  const t = us(s.getAttribute(n));
  e.set(s, new Set(t));
}
function bf(s, n) {
  if (!s || !n)
    return;
  const e = ws(n), t = e.get(s);
  !t || t.size === 0 ? s.removeAttribute(n) : In(s, n, An(t)), e.delete(s);
}
function Co(s, n, e = { newId: null, oldId: null, fromUser: !1 }) {
  if (!s || !n)
    return;
  const { newId: t, oldId: i, fromUser: r } = e, o = ws(n), a = o.get(s);
  if (!r && a) {
    i && a.delete(i), t && a.add(t);
    return;
  }
  r && (a ? t || o.delete(s) : lc(s, n), ac(s, n)), ds(s, n, i);
  const c = t || An(a);
  c && In(s, n, c);
}
function yf(s, n) {
  lc(s, n), ac(s, n);
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class wf {
  constructor(n) {
    this.host = n, this.__required = !1;
  }
  /**
   * Sets a target element to which ARIA attributes are added.
   *
   * @param {HTMLElement} target
   */
  setTarget(n) {
    this.__target = n, this.__setAriaRequiredAttribute(this.__required), this.__setLabelIdToAriaAttribute(this.__labelId, this.__labelId), this.__labelIdFromUser != null && this.__setLabelIdToAriaAttribute(this.__labelIdFromUser, this.__labelIdFromUser, !0), this.__setErrorIdToAriaAttribute(this.__errorId), this.__setHelperIdToAriaAttribute(this.__helperId), this.setAriaLabel(this.__label);
  }
  /**
   * Toggles the `aria-required` attribute on the target element
   * if the target is the host component (e.g. a field group).
   * Otherwise, it does nothing.
   *
   * @param {boolean} required
   */
  setRequired(n) {
    this.__setAriaRequiredAttribute(n), this.__required = n;
  }
  /**
   * Defines the `aria-label` attribute of the target element.
   *
   * To remove the attribute, pass `null` as `label`.
   *
   * @param {string | null | undefined} label
   */
  setAriaLabel(n) {
    this.__setAriaLabelToAttribute(n), this.__label = n;
  }
  /**
   * Links the target element with a slotted label element
   * via the target's attribute `aria-labelledby`.
   *
   * To unlink the previous slotted label element, pass `null` as `labelId`.
   *
   * @param {string | null} labelId
   */
  setLabelId(n, e = !1) {
    const t = e ? this.__labelIdFromUser : this.__labelId;
    this.__setLabelIdToAriaAttribute(n, t, e), e ? this.__labelIdFromUser = n : this.__labelId = n;
  }
  /**
   * Links the target element with a slotted error element via the target's attribute:
   * - `aria-labelledby` if the target is the host component (e.g a field group).
   * - `aria-describedby` otherwise.
   *
   * To unlink the previous slotted error element, pass `null` as `errorId`.
   *
   * @param {string | null} errorId
   */
  setErrorId(n) {
    this.__setErrorIdToAriaAttribute(n, this.__errorId), this.__errorId = n;
  }
  /**
   * Links the target element with a slotted helper element via the target's attribute:
   * - `aria-labelledby` if the target is the host component (e.g a field group).
   * - `aria-describedby` otherwise.
   *
   * To unlink the previous slotted helper element, pass `null` as `helperId`.
   *
   * @param {string | null} helperId
   */
  setHelperId(n) {
    this.__setHelperIdToAriaAttribute(n, this.__helperId), this.__helperId = n;
  }
  /**
   * @param {string | null | undefined} label
   * @private
   * */
  __setAriaLabelToAttribute(n) {
    this.__target && (n ? (yf(this.__target, "aria-labelledby"), this.__target.setAttribute("aria-label", n)) : this.__label && (bf(this.__target, "aria-labelledby"), this.__target.removeAttribute("aria-label")));
  }
  /**
   * @param {string | null | undefined} labelId
   * @param {string | null | undefined} oldLabelId
   * @param {boolean | null | undefined} fromUser
   * @private
   */
  __setLabelIdToAriaAttribute(n, e, t) {
    Co(this.__target, "aria-labelledby", { newId: n, oldId: e, fromUser: t });
  }
  /**
   * @param {string | null | undefined} errorId
   * @param {string | null | undefined} oldErrorId
   * @private
   */
  __setErrorIdToAriaAttribute(n, e) {
    Co(this.__target, "aria-describedby", { newId: n, oldId: e, fromUser: !1 });
  }
  /**
   * @param {string | null | undefined} helperId
   * @param {string | null | undefined} oldHelperId
   * @private
   */
  __setHelperIdToAriaAttribute(n, e) {
    Co(this.__target, "aria-describedby", { newId: n, oldId: e, fromUser: !1 });
  }
  /**
   * @param {boolean} required
   * @private
   */
  __setAriaRequiredAttribute(n) {
    this.__target && (["input", "textarea"].includes(this.__target.localName) || (n ? this.__target.setAttribute("aria-required", "true") : this.__target.removeAttribute("aria-required")));
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const To = [];
class xf {
  /**
   * @param {HTMLElement} host
   */
  constructor(n) {
    this.host = n, this.__trapNode = null, this.__onKeyDown = this.__onKeyDown.bind(this);
  }
  /**
   * An array of tab-ordered focusable elements inside the trap node.
   *
   * @return {HTMLElement[]}
   * @private
   */
  get __focusableElements() {
    return Sh(this.__trapNode);
  }
  /**
   * The index of the element inside the trap node that currently has focus.
   *
   * @return {HTMLElement | undefined}
   * @private
   */
  get __focusedElementIndex() {
    const n = this.__focusableElements;
    return n.indexOf(n.filter(Ul).pop());
  }
  hostConnected() {
    document.addEventListener("keydown", this.__onKeyDown);
  }
  hostDisconnected() {
    document.removeEventListener("keydown", this.__onKeyDown);
  }
  /**
   * Activates a focus trap for a DOM node that will prevent focus from escaping the node.
   * The trap can be deactivated with the `.releaseFocus()` method.
   *
   * If focus is initially outside the trap, the method will move focus inside,
   * on the first focusable element of the trap in the tab order.
   * The first focusable element can be the trap node itself if it is focusable
   * and comes first in the tab order.
   *
   * If there are no focusable elements, the method will throw an exception
   * and the trap will not be set.
   *
   * @param {HTMLElement} trapNode
   */
  trapFocus(n) {
    if (this.__trapNode = n, this.__focusableElements.length === 0)
      throw this.__trapNode = null, new Error("The trap node should have at least one focusable descendant or be focusable itself.");
    To.push(this), this.__focusedElementIndex === -1 && this.__focusableElements[0].focus();
  }
  /**
   * Deactivates the focus trap set with the `.trapFocus()` method
   * so that it becomes possible to tab outside the trap node.
   */
  releaseFocus() {
    this.__trapNode = null, To.pop();
  }
  /**
   * A `keydown` event handler that manages tabbing navigation when the trap is enabled.
   *
   * - Moves focus to the next focusable element of the trap on `Tab` press.
   * When no next element to focus, the method moves focus to the first focusable element.
   * - Moves focus to the prev focusable element of the trap on `Shift+Tab` press.
   * When no prev element to focus, the method moves focus to the last focusable element.
   *
   * @param {KeyboardEvent} event
   * @private
   */
  __onKeyDown(n) {
    if (this.__trapNode && this === Array.from(To).pop() && n.key === "Tab") {
      n.preventDefault();
      const e = n.shiftKey;
      this.__focusNextElement(e);
    }
  }
  /**
   * - Moves focus to the next focusable element if `backward === false`.
   * When no next element to focus, the method moves focus to the first focusable element.
   * - Moves focus to the prev focusable element if `backward === true`.
   * When no prev element to focus the method moves focus to the last focusable element.
   *
   * If no focusable elements, the method returns immediately.
   *
   * @param {boolean} backward
   * @private
   */
  __focusNextElement(n = !1) {
    const e = this.__focusableElements, t = n ? -1 : 1, i = this.__focusedElementIndex, r = (e.length + i + t) % e.length, o = e[r];
    o.focus(), o.localName === "input" && o.select();
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class Cf {
  /**
   * Saves the given node as a target for restoring focus to
   * when `restoreFocus()` is called. If no node is provided,
   * the currently focused node in the DOM is saved as a target.
   *
   * @param {Node | null | undefined} focusNode
   */
  saveFocus(n) {
    this.focusNode = n || Uo();
  }
  /**
   * Restores focus to the target node that was saved previously with `saveFocus()`.
   */
  restoreFocus(n) {
    const e = this.focusNode;
    if (!e)
      return;
    const t = n ? n.preventScroll : !1;
    Uo() === document.body ? setTimeout(() => e.focus({ preventScroll: t })) : e.focus({ preventScroll: t }), this.focusNode = null;
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function Ga(s, n) {
  const { scrollLeft: e } = s;
  return n !== "rtl" ? e : s.scrollWidth - s.clientWidth + e;
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Jr = new ResizeObserver((s) => {
  setTimeout(() => {
    s.forEach((n) => {
      n.target.resizables ? n.target.resizables.forEach((e) => {
        e._onResize(n.contentRect);
      }) : n.target._onResize(n.contentRect);
    });
  });
}), Tf = rt(
  (s) => class extends s {
    /**
     * When true, the parent element resize will be also observed.
     * Override this getter and return `true` to enable this.
     *
     * @protected
     */
    get _observeParent() {
      return !1;
    }
    /** @protected */
    connectedCallback() {
      if (super.connectedCallback(), Jr.observe(this), this._observeParent) {
        const e = this.parentNode instanceof ShadowRoot ? this.parentNode.host : this.parentNode;
        e.resizables || (e.resizables = /* @__PURE__ */ new Set(), Jr.observe(e)), e.resizables.add(this), this.__parent = e;
      }
    }
    /** @protected */
    disconnectedCallback() {
      super.disconnectedCallback(), Jr.unobserve(this);
      const e = this.__parent;
      if (this._observeParent && e) {
        const t = e.resizables;
        t && (t.delete(this), t.size === 0 && Jr.unobserve(e)), this.__parent = null;
      }
    }
    /**
     * A handler invoked on host resize. By default, it does nothing.
     * Override the method to implement your own behavior.
     *
     * @protected
     */
    _onResize(e) {
    }
  }
);
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const qa = {
  SCROLLING: 500,
  UPDATE_CONTENT_VISIBILITY: 100
}, Ef = (s) => class extends Tf(s) {
  static get properties() {
    return {
      /**
       * Allows you to choose between modes for rendering columns in the grid:
       *
       * "eager" (default): All columns are rendered upfront, regardless of their visibility within the viewport.
       * This mode should generally be preferred, as it avoids the limitations imposed by the "lazy" mode.
       * Use this mode unless the grid has a large number of columns and performance outweighs the limitations
       * in priority.
       *
       * "lazy": Optimizes the rendering of cells when there are multiple columns in the grid by virtualizing
       * horizontal scrolling. In this mode, body cells are rendered only when their corresponding columns are
       * inside the visible viewport.
       *
       * Using "lazy" rendering should be used only if you're dealing with a large number of columns and performance
       * is your highest priority. For most use cases, the default "eager" mode is recommended due to the
       * limitations imposed by the "lazy" mode.
       *
       * When using the "lazy" mode, keep the following limitations in mind:
       *
       * - Row Height: When only a number of columns are visible at once, the height of a row can only be that of
       * the highest cell currently visible on that row. Make sure each cell on a single row has the same height
       * as all other cells on that row. If row cells have different heights, users may experience jumpiness when
       * scrolling the grid horizontally as lazily rendered cells with different heights are scrolled into view.
       *
       * - Auto-width Columns: For the columns that are initially outside the visible viewport but still use auto-width,
       * only the header content is taken into account when calculating the column width because the body cells
       * of the columns outside the viewport are not initially rendered.
       *
       * - Screen Reader Compatibility: Screen readers may not be able to associate the focused cells with the correct
       * headers when only a subset of the body cells on a row is rendered.
       *
       * - Keyboard Navigation: Tabbing through focusable elements inside the grid body may not work as expected because
       * some of the columns that would include focusable elements in the body cells may be outside the visible viewport
       * and thus not rendered.
       *
       * @attr {eager|lazy} column-rendering
       * @type {!ColumnRendering}
       */
      columnRendering: {
        type: String,
        value: "eager",
        sync: !0
      },
      /**
       * Cached array of frozen cells
       * @private
       */
      _frozenCells: {
        type: Array,
        value: () => []
      },
      /**
       * Cached array of cells frozen to end
       * @private
       */
      _frozenToEndCells: {
        type: Array,
        value: () => []
      },
      /** @private */
      _rowWithFocusedElement: Element
    };
  }
  static get observers() {
    return ["__columnRenderingChanged(_columnTree, columnRendering)"];
  }
  /** @private */
  get _scrollLeft() {
    return this.$.table.scrollLeft;
  }
  /** @private */
  get _scrollTop() {
    return this.$.table.scrollTop;
  }
  /**
   * Override (from iron-scroll-target-behavior) to avoid document scroll
   * @private
   */
  set _scrollTop(e) {
    this.$.table.scrollTop = e;
  }
  /** @protected */
  get _lazyColumns() {
    return this.columnRendering === "lazy";
  }
  /** @protected */
  ready() {
    super.ready(), this.scrollTarget = this.$.table, this.$.items.addEventListener("focusin", (e) => {
      const t = e.composedPath().indexOf(this.$.items);
      this._rowWithFocusedElement = e.composedPath()[t - 1], this._rowWithFocusedElement && (this._isMousedown || this.__scrollIntoViewport(this._rowWithFocusedElement.index), this.$.table.contains(e.relatedTarget) || this.$.table.dispatchEvent(
        new CustomEvent("virtualizer-element-focused", { detail: { element: this._rowWithFocusedElement } })
      ));
    }), this.$.items.addEventListener("focusout", () => {
      this._rowWithFocusedElement = void 0;
    }), this.$.table.addEventListener("scroll", () => this._afterScroll());
  }
  /**
   * @protected
   * @override
   */
  _onResize() {
    if (this._updateOverflow(), this.__updateHorizontalScrollPosition(), this._firefox) {
      const e = !wn(this);
      e && this.__previousVisible === !1 && (this._scrollTop = this.__memorizedScrollTop || 0), this.__previousVisible = e;
    }
  }
  /**
   * Scroll to a flat index in the grid. The method doesn't take into account
   * the hierarchy of the items.
   *
   * @param {number} index Row index to scroll to
   * @protected
   */
  _scrollToFlatIndex(e) {
    e = Math.min(this._flatSize - 1, Math.max(0, e)), this.__virtualizer.scrollToIndex(e), this.__scrollIntoViewport(e);
  }
  /**
   * Makes sure the row with the given index (if found in the DOM) is fully
   * inside the visible viewport, taking header/footer into account.
   * @private
   */
  __scrollIntoViewport(e) {
    const t = [...this.$.items.children].find((i) => i.index === e);
    if (t) {
      const i = t.getBoundingClientRect(), r = this.$.footer.getBoundingClientRect().top, o = this.$.header.getBoundingClientRect().bottom;
      i.bottom > r ? this.$.table.scrollTop += i.bottom - r : i.top < o && (this.$.table.scrollTop -= o - i.top);
    }
  }
  /** @private */
  _scheduleScrolling() {
    this._scrollingFrame || (this._scrollingFrame = requestAnimationFrame(() => this.$.scroller.toggleAttribute("scrolling", !0))), this._debounceScrolling = Me.debounce(this._debounceScrolling, zt.after(qa.SCROLLING), () => {
      cancelAnimationFrame(this._scrollingFrame), delete this._scrollingFrame, this.$.scroller.toggleAttribute("scrolling", !1);
    });
  }
  /** @private */
  _afterScroll() {
    this.__updateHorizontalScrollPosition(), this.hasAttribute("reordering") || this._scheduleScrolling(), this.hasAttribute("navigating") || this._hideTooltip(!0), this._updateOverflow(), this._debounceColumnContentVisibility = Me.debounce(
      this._debounceColumnContentVisibility,
      zt.after(qa.UPDATE_CONTENT_VISIBILITY),
      () => {
        this._lazyColumns && this.__cachedScrollLeft !== this._scrollLeft && (this.__cachedScrollLeft = this._scrollLeft, this.__updateColumnsBodyContentHidden());
      }
    ), this._firefox && !wn(this) && this.__previousVisible !== !1 && (this.__memorizedScrollTop = this._scrollTop);
  }
  /** @private */
  __updateColumnsBodyContentHidden() {
    if (!this._columnTree || !this._areSizerCellsAssigned())
      return;
    const e = this._getColumnsInOrder();
    let t = !1;
    if (e.forEach((i) => {
      const r = this._lazyColumns && !this.__isColumnInViewport(i);
      i._bodyContentHidden !== r && (t = !0, i._cells.forEach((o) => {
        if (o !== i._sizerCell) {
          if (r)
            o.remove();
          else if (o.__parentRow) {
            const a = [...o.__parentRow.children].find(
              (c) => e.indexOf(c._column) > e.indexOf(i)
            );
            o.__parentRow.insertBefore(o, a);
          }
        }
      })), i._bodyContentHidden = r;
    }), t && this._frozenCellsChanged(), this._lazyColumns) {
      const i = [...e].reverse().find((a) => a.frozen), r = this.__getColumnEnd(i), o = e.find((a) => !a.frozen && !a._bodyContentHidden);
      this.__lazyColumnsStart = this.__getColumnStart(o) - r, this.$.items.style.setProperty("--_grid-lazy-columns-start", `${this.__lazyColumnsStart}px`), this._resetKeyboardNavigation();
    }
  }
  /** @private */
  __getColumnEnd(e) {
    return e ? e._sizerCell.offsetLeft + (this.__isRTL ? 0 : e._sizerCell.offsetWidth) : this.__isRTL ? this.$.table.clientWidth : 0;
  }
  /** @private */
  __getColumnStart(e) {
    return e ? e._sizerCell.offsetLeft + (this.__isRTL ? e._sizerCell.offsetWidth : 0) : this.__isRTL ? this.$.table.clientWidth : 0;
  }
  /**
   * Returns true if the given column is horizontally inside the viewport.
   * @private
   */
  __isColumnInViewport(e) {
    return e.frozen || e.frozenToEnd ? !0 : this.__isHorizontallyInViewport(e._sizerCell);
  }
  /** @private */
  __isHorizontallyInViewport(e) {
    return e.offsetLeft + e.offsetWidth >= this._scrollLeft && e.offsetLeft <= this._scrollLeft + this.clientWidth;
  }
  /** @private */
  __columnRenderingChanged(e, t) {
    t === "eager" ? this.$.scroller.removeAttribute("column-rendering") : this.$.scroller.setAttribute("column-rendering", t), this.__updateColumnsBodyContentHidden();
  }
  /** @private */
  _updateOverflow() {
    this._debounceOverflow = Me.debounce(this._debounceOverflow, qt, () => {
      this.__doUpdateOverflow();
    });
  }
  /** @private */
  __doUpdateOverflow() {
    let e = "";
    const t = this.$.table;
    t.scrollTop < t.scrollHeight - t.clientHeight && (e += " bottom"), t.scrollTop > 0 && (e += " top");
    const i = Ga(t, this.getAttribute("dir"));
    i > 0 && (e += " start"), i < t.scrollWidth - t.clientWidth && (e += " end"), this.__isRTL && (e = e.replace(/start|end/giu, (o) => o === "start" ? "end" : "start")), t.scrollLeft < t.scrollWidth - t.clientWidth && (e += " right"), t.scrollLeft > 0 && (e += " left");
    const r = e.trim();
    r.length > 0 && this.getAttribute("overflow") !== r ? this.setAttribute("overflow", r) : r.length === 0 && this.hasAttribute("overflow") && this.removeAttribute("overflow");
  }
  /** @protected */
  _frozenCellsChanged() {
    this._debouncerCacheElements = Me.debounce(this._debouncerCacheElements, yt, () => {
      Array.from(this.shadowRoot.querySelectorAll('[part~="cell"]')).forEach((e) => {
        e.style.transform = "";
      }), this._frozenCells = Array.prototype.slice.call(this.$.table.querySelectorAll("[frozen]")), this._frozenToEndCells = Array.prototype.slice.call(this.$.table.querySelectorAll("[frozen-to-end]")), this.__updateHorizontalScrollPosition();
    }), this._debounceUpdateFrozenColumn();
  }
  /** @protected */
  _debounceUpdateFrozenColumn() {
    this.__debounceUpdateFrozenColumn = Me.debounce(
      this.__debounceUpdateFrozenColumn,
      yt,
      () => this._updateFrozenColumn()
    );
  }
  /** @private */
  _updateFrozenColumn() {
    if (!this._columnTree)
      return;
    const e = this._columnTree[this._columnTree.length - 1].slice(0);
    e.sort((r, o) => r._order - o._order);
    let t, i;
    for (let r = 0; r < e.length; r++) {
      const o = e[r];
      o._lastFrozen = !1, o._firstFrozenToEnd = !1, i === void 0 && o.frozenToEnd && !o.hidden && (i = r), o.frozen && !o.hidden && (t = r);
    }
    t !== void 0 && (e[t]._lastFrozen = !0), i !== void 0 && (e[i]._firstFrozenToEnd = !0), this.__updateColumnsBodyContentHidden();
  }
  /** @private */
  __updateHorizontalScrollPosition() {
    if (!this._columnTree)
      return;
    const e = this.$.table.scrollWidth, t = this.$.table.clientWidth, i = Math.max(0, this.$.table.scrollLeft), r = Ga(this.$.table, this.getAttribute("dir")), o = `translate(${-i}px, 0)`;
    this.$.header.style.transform = o, this.$.footer.style.transform = o, this.$.items.style.transform = o;
    const a = this.__isRTL ? r + t - e : i, c = `translate(${a}px, 0)`;
    this._frozenCells.forEach((g) => {
      g.style.transform = c;
    });
    const u = this.__isRTL ? r : i + t - e, h = `translate(${u}px, 0)`;
    let f = h;
    if (this._lazyColumns && this._areSizerCellsAssigned()) {
      const g = this._getColumnsInOrder(), x = [...g].reverse().find((U) => !U.frozenToEnd && !U._bodyContentHidden), C = this.__getColumnEnd(x), E = g.find((U) => U.frozenToEnd), R = this.__getColumnStart(E);
      f = `translate(${u + (R - C) + this.__lazyColumnsStart}px, 0)`;
    }
    this._frozenToEndCells.forEach((g) => {
      this.$.items.contains(g) ? g.style.transform = f : g.style.transform = h;
    }), this.hasAttribute("navigating") && this.__rowFocusMode && this.$.table.style.setProperty("--_grid-horizontal-scroll-position", `${-a}px`);
  }
  /** @private */
  _areSizerCellsAssigned() {
    return this._getColumnsInOrder().every((e) => e._sizerCell);
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Pf = (s) => class extends s {
  static get properties() {
    return {
      /**
       * An array that contains the selected items.
       * @type {!Array<!GridItem>}
       */
      selectedItems: {
        type: Object,
        notify: !0,
        value: () => [],
        sync: !0
      },
      /**
       * Set of selected item ids
       * @private
       */
      __selectedKeys: {
        type: Object,
        computed: "__computeSelectedKeys(itemIdPath, selectedItems)"
      }
    };
  }
  static get observers() {
    return ["__selectedItemsChanged(itemIdPath, selectedItems)"];
  }
  /**
   * @param {!GridItem} item
   * @return {boolean}
   * @protected
   */
  _isSelected(e) {
    return this.__selectedKeys.has(this.getItemId(e));
  }
  /**
   * Selects the given item.
   *
   * @method selectItem
   * @param {!GridItem} item The item object
   */
  selectItem(e) {
    this._isSelected(e) || (this.selectedItems = [...this.selectedItems, e]);
  }
  /**
   * Deselects the given item if it is already selected.
   *
   * @method deselect
   * @param {!GridItem} item The item object
   */
  deselectItem(e) {
    this._isSelected(e) && (this.selectedItems = this.selectedItems.filter((t) => !this._itemsEqual(t, e)));
  }
  /**
   * Toggles the selected state of the given item.
   *
   * @method toggle
   * @param {!GridItem} item The item object
   * @protected
   */
  _toggleItem(e) {
    this._isSelected(e) ? this.deselectItem(e) : this.selectItem(e);
  }
  /** @private */
  __selectedItemsChanged() {
    this.requestContentUpdate();
  }
  /** @private */
  __computeSelectedKeys(e, t) {
    const i = t || [], r = /* @__PURE__ */ new Set();
    return i.forEach((o) => {
      r.add(this.getItemId(o));
    }), r;
  }
  /**
   * Fired when the `selectedItems` property changes.
   *
   * @event selected-items-changed
   */
};
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
let Ka = "prepend";
const Sf = (s) => class extends s {
  static get properties() {
    return {
      /**
       * When `true`, all `<vaadin-grid-sorter>` are applied for sorting.
       * @attr {boolean} multi-sort
       * @type {boolean}
       */
      multiSort: {
        type: Boolean,
        value: !1
      },
      /**
       * Controls how columns are added to the sort order when using multi-sort.
       * The sort order is visually indicated by numbers in grid sorters placed in column headers.
       *
       * By default, whenever an unsorted column is sorted, or the sort-direction of a column is
       * changed, that column gets sort priority 1, thus affecting the priority for all the other
       * sorted columns. This is identical to using `multi-sort-priority="prepend"`.
       *
       * Using this property allows to change this behavior so that sorting an unsorted column
       * would add it to the "end" of the sort, and changing column's sort direction would retain
       * it's previous priority. To set this, use `multi-sort-priority="append"`.
       *
       * @attr {string} multi-sort-priority
       */
      multiSortPriority: {
        type: String,
        value: () => Ka
      },
      /**
       * When `true`, Shift-clicking an unsorted column's sorter adds it to the multi-sort.
       * Shift + Space does the same action via keyboard. This property has precedence over the
       * `multiSort` property. If `multiSortOnShiftClick` is true, the multiSort property is effectively ignored.
       *
       * @attr {boolean} multi-sort-on-shift-click
       * @type {boolean}
       */
      multiSortOnShiftClick: {
        type: Boolean,
        value: !1
      },
      /**
       * @type {!Array<!GridSorterDefinition>}
       * @protected
       */
      _sorters: {
        type: Array,
        value: () => []
      },
      /** @private */
      _previousSorters: {
        type: Array,
        value: () => []
      }
    };
  }
  /**
   * Sets the default multi-sort priority to use for all grid instances.
   * This method should be called before creating any grid instances.
   * Changing this setting does not affect the default for existing grids.
   *
   * @param {string} priority
   */
  static setDefaultMultiSortPriority(e) {
    Ka = ["append", "prepend"].includes(e) ? e : "prepend";
  }
  /** @protected */
  ready() {
    super.ready(), this.addEventListener("sorter-changed", this._onSorterChanged);
  }
  /** @private */
  _onSorterChanged(e) {
    const t = e.target;
    e.stopPropagation(), t._grid = this, this.__updateSorter(t, e.detail.shiftClick, e.detail.fromSorterClick), this.__applySorters();
  }
  /** @private */
  __removeSorters(e) {
    e.length !== 0 && (this._sorters = this._sorters.filter((t) => !e.includes(t)), this.__applySorters());
  }
  /** @private */
  __updateSortOrders() {
    this._sorters.forEach((t) => {
      t._order = null;
    });
    const e = this._getActiveSorters();
    e.length > 1 && e.forEach((t, i) => {
      t._order = i;
    });
  }
  /** @private */
  __updateSorter(e, t, i) {
    if (!e.direction && !this._sorters.includes(e))
      return;
    e._order = null;
    const r = this._sorters.filter((o) => o !== e);
    this.multiSort && (!this.multiSortOnShiftClick || !i) || this.multiSortOnShiftClick && t ? this.multiSortPriority === "append" ? this._sorters = [...r, e] : this._sorters = [e, ...r] : (e.direction || this.multiSortOnShiftClick) && (this._sorters = e.direction ? [e] : [], r.forEach((o) => {
      o._order = null, o.direction = null;
    }));
  }
  /** @private */
  __applySorters() {
    this.__updateSortOrders(), this.dataProvider && // No need to clear cache if sorters didn't change and grid is attached
    this.isAttached && JSON.stringify(this._previousSorters) !== JSON.stringify(this._mapSorters()) && this.__debounceClearCache(), this._a11yUpdateSorters(), this._previousSorters = this._mapSorters();
  }
  /**
   * @type {GridSorterDefinition[]}
   * @protected
   */
  _getActiveSorters() {
    return this._sorters.filter((e) => e.direction && e.isConnected);
  }
  /**
   * @return {!Array<!GridSorterDefinition>}
   * @protected
   */
  _mapSorters() {
    return this._getActiveSorters().map((e) => ({
      path: e.path,
      direction: e.direction
    }));
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const kf = (s) => class extends s {
  static get properties() {
    return {
      /**
       * A function that allows generating CSS class names for grid cells
       * based on their row and column. The return value should be the generated
       * class name as a string, or multiple class names separated by whitespace
       * characters.
       *
       * Receives two arguments:
       * - `column` The `<vaadin-grid-column>` element (`undefined` for details-cell).
       * - `model` The object with the properties related with
       *   the rendered item, contains:
       *   - `model.index` The index of the item.
       *   - `model.item` The item.
       *   - `model.expanded` Sublevel toggle state.
       *   - `model.level` Level of the tree represented with a horizontal offset of the toggle button.
       *   - `model.selected` Selected state.
       *
       * @type {GridCellClassNameGenerator | null | undefined}
       * @deprecated Use `cellPartNameGenerator` instead.
       */
      cellClassNameGenerator: {
        type: Function,
        sync: !0
      },
      /**
       * A function that allows generating CSS `part` names for grid cells in Shadow DOM based
       * on their row and column, for styling from outside using the `::part()` selector.
       *
       * The return value should be the generated part name as a string, or multiple part names
       * separated by whitespace characters.
       *
       * Receives two arguments:
       * - `column` The `<vaadin-grid-column>` element (`undefined` for details-cell).
       * - `model` The object with the properties related with
       *   the rendered item, contains:
       *   - `model.index` The index of the item.
       *   - `model.item` The item.
       *   - `model.expanded` Sublevel toggle state.
       *   - `model.level` Level of the tree represented with a horizontal offset of the toggle button.
       *   - `model.selected` Selected state.
       *
       * @type {GridCellPartNameGenerator | null | undefined}
       */
      cellPartNameGenerator: {
        type: Function,
        sync: !0
      }
    };
  }
  static get observers() {
    return [
      "__cellClassNameGeneratorChanged(cellClassNameGenerator)",
      "__cellPartNameGeneratorChanged(cellPartNameGenerator)"
    ];
  }
  /** @private */
  __cellClassNameGeneratorChanged() {
    this.generateCellClassNames();
  }
  /** @private */
  __cellPartNameGeneratorChanged() {
    this.generateCellPartNames();
  }
  /**
   * Runs the `cellClassNameGenerator` for the visible cells.
   * If the generator depends on varying conditions, you need to
   * call this function manually in order to update the styles when
   * the conditions change.
   *
   * @deprecated Use `cellPartNameGenerator` and `generateCellPartNames()` instead.
   */
  generateCellClassNames() {
    ht(this.$.items, (e) => {
      e.hidden || this._generateCellClassNames(e, this.__getRowModel(e));
    });
  }
  /**
   * Runs the `cellPartNameGenerator` for the visible cells.
   * If the generator depends on varying conditions, you need to
   * call this function manually in order to update the styles when
   * the conditions change.
   */
  generateCellPartNames() {
    ht(this.$.items, (e) => {
      e.hidden || this._generateCellPartNames(e, this.__getRowModel(e));
    });
  }
  /** @private */
  _generateCellClassNames(e, t) {
    Bi(e, (i) => {
      if (i.__generatedClasses && i.__generatedClasses.forEach((r) => i.classList.remove(r)), this.cellClassNameGenerator && !e.hasAttribute("loading")) {
        const r = this.cellClassNameGenerator(i._column, t);
        i.__generatedClasses = r && r.split(" ").filter((o) => o.length > 0), i.__generatedClasses && i.__generatedClasses.forEach((o) => i.classList.add(o));
      }
    });
  }
  /** @private */
  _generateCellPartNames(e, t) {
    Bi(e, (i) => {
      if (i.__generatedParts && i.__generatedParts.forEach((r) => {
        Kt(i, null, r);
      }), this.cellPartNameGenerator && !e.hasAttribute("loading")) {
        const r = this.cellPartNameGenerator(i._column, t);
        i.__generatedParts = r && r.split(" ").filter((o) => o.length > 0), i.__generatedParts && i.__generatedParts.forEach((o) => {
          Kt(i, !0, o);
        });
      }
    });
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Rf = (s) => class extends Wh(
  uf(
    ff(
      Nh(
        Ef(
          Pf(
            Sf(
              vf(
                mf(
                  Lh(
                    gf(
                      lf(
                        cf(
                          pf(hf(kf(Gl(s))))
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  )
) {
  static get observers() {
    return ["_columnTreeChanged(_columnTree)", "_flatSizeChanged(_flatSize, __virtualizer, _hasData, _columnTree)"];
  }
  static get properties() {
    return {
      /** @private */
      _safari: {
        type: Boolean,
        value: ql
      },
      /** @private */
      _ios: {
        type: Boolean,
        value: Go
      },
      /** @private */
      _firefox: {
        type: Boolean,
        value: Ah
      },
      /** @private */
      _android: {
        type: Boolean,
        value: Ma
      },
      /** @private */
      _touchDevice: {
        type: Boolean,
        value: br
      },
      /**
       * If true, the grid's height is defined by its rows.
       *
       * Effectively, this disables the grid's virtual scrolling so that all the rows are rendered in the DOM at once.
       * If the grid has a large number of items, using the feature is discouraged to avoid performance issues.
       * @attr {boolean} all-rows-visible
       * @type {boolean}
       */
      allRowsVisible: {
        type: Boolean,
        value: !1,
        reflectToAttribute: !0
      },
      /** @private */
      __pendingRecalculateColumnWidths: {
        type: Boolean,
        value: !0
      },
      /** @private */
      isAttached: {
        value: !1
      },
      /**
       * An internal property that is mainly used by `vaadin-template-renderer`
       * to identify grid elements.
       *
       * @private
       */
      __gridElement: {
        type: Boolean,
        value: !0
      },
      /** @private */
      __hasEmptyStateContent: {
        type: Boolean,
        value: !1
      },
      /** @private */
      __emptyState: {
        type: Boolean,
        computed: "__computeEmptyState(_flatSize, __hasEmptyStateContent)"
      }
    };
  }
  constructor() {
    super(), this.addEventListener("animationend", this._onAnimationEnd);
  }
  /** @private */
  get _firstVisibleIndex() {
    const n = this.__getFirstVisibleItem();
    return n ? n.index : void 0;
  }
  /** @private */
  get _lastVisibleIndex() {
    const n = this.__getLastVisibleItem();
    return n ? n.index : void 0;
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback(), this.isAttached = !0, this.recalculateColumnWidths();
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback(), this.isAttached = !1, this._hideTooltip(!0);
  }
  /** @private */
  __getFirstVisibleItem() {
    return this._getRenderedRows().find((n) => this._isInViewport(n));
  }
  /** @private */
  __getLastVisibleItem() {
    return this._getRenderedRows().reverse().find((n) => this._isInViewport(n));
  }
  /** @private */
  _isInViewport(n) {
    const e = this.$.table.getBoundingClientRect(), t = n.getBoundingClientRect(), i = this.$.header.getBoundingClientRect().height, r = this.$.footer.getBoundingClientRect().height;
    return t.bottom > e.top + i && t.top < e.bottom - r;
  }
  /** @private */
  _getRenderedRows() {
    return Array.from(this.$.items.children).filter((n) => !n.hidden).sort((n, e) => n.index - e.index);
  }
  /** @protected */
  _getRowContainingNode(n) {
    const e = Bl("vaadin-grid-cell-content", n);
    return e ? e.assignedSlot.parentElement.parentElement : void 0;
  }
  /** @protected */
  _isItemAssignedToRow(n, e) {
    const t = this.__getRowModel(e);
    return this.getItemId(n) === this.getItemId(t.item);
  }
  /** @protected */
  ready() {
    super.ready(), this.__virtualizer = new Ql({
      createElements: this._createScrollerRows.bind(this),
      updateElement: this._updateScrollerItem.bind(this),
      scrollContainer: this.$.items,
      scrollTarget: this.$.table,
      reorderElements: !0
    }), new ResizeObserver(
      () => setTimeout(() => {
        this.__updateColumnsBodyContentHidden(), this.__tryToRecalculateColumnWidthsIfPending();
      })
    ).observe(this.$.table), cs(this), this._tooltipController = new Yl(this), this.addController(this._tooltipController), this._tooltipController.setManual(!0), this.__emptyStateContentObserver = new Kl(this.$.emptystateslot, ({ currentNodes: n }) => {
      this.$.emptystatecell._content = n[0], this.__hasEmptyStateContent = !!this.$.emptystatecell._content;
    });
  }
  /** @private */
  __getBodyCellCoordinates(n) {
    if (this.$.items.contains(n) && n.localName === "td")
      return {
        item: n.parentElement._item,
        column: n._column
      };
  }
  /** @private */
  __focusBodyCell({ item: n, column: e }) {
    const t = this._getRenderedRows().find((r) => r._item === n), i = t && [...t.children].find((r) => r._column === e);
    i && i.focus();
  }
  /** @protected */
  _focusFirstVisibleRow() {
    const n = this.__getFirstVisibleItem();
    this.__rowFocusMode = !0, n.focus();
  }
  /** @private */
  _flatSizeChanged(n, e, t, i) {
    if (e && t && i) {
      const r = this.shadowRoot.activeElement, o = this.__getBodyCellCoordinates(r), a = e.size || 0;
      e.size = n, e.update(a - 1, a - 1), n < a && e.update(n - 1, n - 1), o && r.parentElement.hidden && this.__focusBodyCell(o), this._resetKeyboardNavigation();
    }
  }
  /** @private */
  __getIntrinsicWidth(n) {
    return this.__intrinsicWidthCache.has(n) || this.__calculateAndCacheIntrinsicWidths([n]), this.__intrinsicWidthCache.get(n);
  }
  /** @private */
  __getDistributedWidth(n, e) {
    if (n == null || n === this)
      return 0;
    const t = Math.max(
      this.__getIntrinsicWidth(n),
      this.__getDistributedWidth((n.assignedSlot || n).parentElement, n)
    );
    if (!e)
      return t;
    const i = n, r = t, o = i._visibleChildColumns.map((h) => this.__getIntrinsicWidth(h)).reduce((h, f) => h + f, 0), a = Math.max(0, r - o), u = this.__getIntrinsicWidth(e) / o * a;
    return this.__getIntrinsicWidth(e) + u;
  }
  /**
   * @param {!Array<!GridColumn>} cols the columns to auto size based on their content width
   * @private
   */
  _recalculateColumnWidths(n) {
    this.__virtualizer.flush(), [...this.$.header.children, ...this.$.footer.children].forEach((i) => {
      i.__debounceUpdateHeaderFooterRowVisibility && i.__debounceUpdateHeaderFooterRowVisibility.flush();
    }), this._debouncerHiddenChanged && this._debouncerHiddenChanged.flush(), this.__intrinsicWidthCache = /* @__PURE__ */ new Map();
    const e = this._firstVisibleIndex, t = this._lastVisibleIndex;
    this.__viewportRowsCache = this._getRenderedRows().filter((i) => i.index >= e && i.index <= t), this.__calculateAndCacheIntrinsicWidths(n), n.forEach((i) => {
      i.width = `${this.__getDistributedWidth(i)}px`;
    });
  }
  /**
   * Toggles the cell content for the given column to use or not use auto width.
   *
   * While content for all the column cells uses auto width (instead of the default 100%),
   * their offsetWidth can be used to calculate the collective intrinsic width of the column.
   *
   * @private
   */
  __setVisibleCellContentAutoWidth(n, e) {
    n._allCells.filter((t) => this.$.items.contains(t) ? this.__viewportRowsCache.includes(t.parentElement) : !0).forEach((t) => {
      t.__measuringAutoWidth = e, t.__measuringAutoWidth ? (t.__originalWidth = t.style.width, t.style.width = "auto", t.style.position = "absolute") : (t.style.width = t.__originalWidth, delete t.__originalWidth, t.style.position = "");
    }), e ? this.$.scroller.setAttribute("measuring-auto-width", "") : this.$.scroller.removeAttribute("measuring-auto-width");
  }
  /**
   * Returns the maximum intrinsic width of the cell content in the given column.
   * Only cells which are marked for measuring auto width are considered.
   *
   * @private
   */
  __getAutoWidthCellsMaxWidth(n) {
    return n._allCells.reduce((e, t) => t.__measuringAutoWidth ? Math.max(e, t.offsetWidth + 1) : e, 0);
  }
  /**
   * Calculates and caches the intrinsic width of each given column.
   *
   * @private
   */
  __calculateAndCacheIntrinsicWidths(n) {
    n.forEach((e) => this.__setVisibleCellContentAutoWidth(e, !0)), n.forEach((e) => {
      const t = this.__getAutoWidthCellsMaxWidth(e);
      this.__intrinsicWidthCache.set(e, t);
    }), n.forEach((e) => this.__setVisibleCellContentAutoWidth(e, !1));
  }
  /**
   * Updates the `width` of all columns which have `autoWidth` set to `true`.
   */
  recalculateColumnWidths() {
    if (!this._columnTree)
      return;
    if (wn(this) || this._dataProviderController.isLoading()) {
      this.__pendingRecalculateColumnWidths = !0;
      return;
    }
    const n = this._getColumns().filter((t) => !t.hidden && t.autoWidth), e = n.filter((t) => !customElements.get(t.localName));
    e.length ? Promise.all(e.map((t) => customElements.whenDefined(t.localName))).then(() => {
      this._recalculateColumnWidths(n);
    }) : this._recalculateColumnWidths(n);
  }
  /** @private */
  __tryToRecalculateColumnWidthsIfPending() {
    if (!this.__pendingRecalculateColumnWidths || wn(this) || this._dataProviderController.isLoading() || [...this.$.items.children].some((t) => t.index === void 0))
      return;
    [...this.$.items.children].some((t) => t.clientHeight > 0) && (this.__pendingRecalculateColumnWidths = !1, this.recalculateColumnWidths());
  }
  /**
   * @protected
   * @override
   */
  _onDataProviderPageLoaded() {
    super._onDataProviderPageLoaded(), this.__tryToRecalculateColumnWidthsIfPending();
  }
  /** @private */
  _createScrollerRows(n) {
    const e = [];
    for (let t = 0; t < n; t++) {
      const i = document.createElement("tr");
      i.setAttribute("part", "row body-row"), i.setAttribute("role", "row"), i.setAttribute("tabindex", "-1"), this._columnTree && this._updateRow(i, this._columnTree[this._columnTree.length - 1], "body", !1, !0), e.push(i);
    }
    return this._columnTree && this._columnTree[this._columnTree.length - 1].forEach((t) => {
      t.isConnected && t._cells && (t._cells = [...t._cells]);
    }), this.__afterCreateScrollerRowsDebouncer = Me.debounce(
      this.__afterCreateScrollerRowsDebouncer,
      qt,
      () => {
        this._afterScroll(), this.__tryToRecalculateColumnWidthsIfPending();
      }
    ), e;
  }
  /** @private */
  _createCell(n, e) {
    const i = `vaadin-grid-cell-content-${this._contentIndex = this._contentIndex + 1 || 0}`, r = document.createElement("vaadin-grid-cell-content");
    r.setAttribute("slot", i);
    const o = document.createElement(n);
    o.id = i.replace("-content-", "-"), o.setAttribute("role", n === "td" ? "gridcell" : "columnheader"), !Ma && !Go && (o.addEventListener("mouseenter", (c) => {
      this.$.scroller.hasAttribute("scrolling") || this._showTooltip(c);
    }), o.addEventListener("mouseleave", () => {
      this._hideTooltip();
    }), o.addEventListener("mousedown", () => {
      this._hideTooltip(!0);
    }));
    const a = document.createElement("slot");
    if (a.setAttribute("name", i), e && e._focusButtonMode) {
      const c = document.createElement("div");
      c.setAttribute("role", "button"), c.setAttribute("tabindex", "-1"), o.appendChild(c), o._focusButton = c, o.focus = function(u) {
        o._focusButton.focus(u);
      }, c.appendChild(a);
    } else
      o.setAttribute("tabindex", "-1"), o.appendChild(a);
    return o._content = r, r.addEventListener("mousedown", () => {
      if (Rh) {
        const c = (u) => {
          const h = r.contains(this.getRootNode().activeElement), f = u.composedPath().includes(r);
          !h && f && o.focus({ preventScroll: !0 }), document.removeEventListener("mouseup", c, !0);
        };
        document.addEventListener("mouseup", c, !0);
      } else
        setTimeout(() => {
          r.contains(this.getRootNode().activeElement) || o.focus({ preventScroll: !0 });
        });
    }), o;
  }
  /**
   * @param {!HTMLTableRowElement} row
   * @param {!Array<!GridColumn>} columns
   * @param {?string} section
   * @param {boolean} isColumnRow
   * @param {boolean} noNotify
   * @protected
   */
  _updateRow(n, e, t = "body", i = !1, r = !1) {
    const o = document.createDocumentFragment();
    Bi(n, (a) => {
      a._vacant = !0;
    }), n.innerHTML = "", t === "body" && (n.__cells = [], n.__detailsCell = null), e.filter((a) => !a.hidden).forEach((a, c, u) => {
      let h;
      if (t === "body") {
        a._cells || (a._cells = []), h = a._cells.find((g) => g._vacant), h || (h = this._createCell("td", a), a._onCellKeyDown && h.addEventListener("keydown", a._onCellKeyDown.bind(a)), a._cells.push(h)), h.setAttribute("part", "cell body-cell"), h.__parentRow = n, n.__cells.push(h);
        const f = n === this.$.sizer;
        if ((!a._bodyContentHidden || f) && n.appendChild(h), f && (a._sizerCell = h), c === u.length - 1 && this.rowDetailsRenderer) {
          this._detailsCells || (this._detailsCells = []);
          const g = this._detailsCells.find((x) => x._vacant) || this._createCell("td");
          this._detailsCells.indexOf(g) === -1 && this._detailsCells.push(g), g._content.parentElement || o.appendChild(g._content), this._configureDetailsCell(g), n.appendChild(g), n.__detailsCell = g, this._a11ySetRowDetailsCell(n, g), g._vacant = !1;
        }
        r || (a._cells = [...a._cells]);
      } else {
        const f = t === "header" ? "th" : "td";
        i || a.localName === "vaadin-grid-column-group" ? (h = a[`_${t}Cell`], h || (h = this._createCell(f), a._onCellKeyDown && h.addEventListener("keydown", a._onCellKeyDown.bind(a))), h._column = a, n.appendChild(h), a[`_${t}Cell`] = h) : (a._emptyCells || (a._emptyCells = []), h = a._emptyCells.find((g) => g._vacant) || this._createCell(f), h._column = a, n.appendChild(h), a._emptyCells.indexOf(h) === -1 && a._emptyCells.push(h)), h.part.add("cell", `${t}-cell`);
      }
      h._content.parentElement || o.appendChild(h._content), h._vacant = !1, h._column = a;
    }), t !== "body" && this.__debounceUpdateHeaderFooterRowVisibility(n), this.appendChild(o), this._frozenCellsChanged(), this._updateFirstAndLastColumnForRow(n);
  }
  /**
   * @param {HTMLTableRowElement} row
   * @protected
   */
  __debounceUpdateHeaderFooterRowVisibility(n) {
    n.__debounceUpdateHeaderFooterRowVisibility = Me.debounce(
      n.__debounceUpdateHeaderFooterRowVisibility,
      yt,
      () => this.__updateHeaderFooterRowVisibility(n)
    );
  }
  /**
   * @param {HTMLTableRowElement} row
   * @protected
   */
  __updateHeaderFooterRowVisibility(n) {
    if (!n)
      return;
    const e = Array.from(n.children).filter((t) => {
      const i = t._column;
      if (i._emptyCells && i._emptyCells.indexOf(t) > -1)
        return !1;
      if (n.parentElement === this.$.header) {
        if (i.headerRenderer)
          return !0;
        if (i.header === null)
          return !1;
        if (i.path || i.header !== void 0)
          return !0;
      } else if (i.footerRenderer)
        return !0;
      return !1;
    });
    n.hidden !== !e.length && (n.hidden = !e.length), this._resetKeyboardNavigation();
  }
  /** @private */
  _updateScrollerItem(n, e) {
    this._preventScrollerRotatingCellFocus(n, e), this._columnTree && (this._updateRowOrderParts(n, e), this._a11yUpdateRowRowindex(n, e), this._getItem(e, n));
  }
  /** @private */
  _columnTreeChanged(n) {
    this._renderColumnTree(n), this.recalculateColumnWidths(), this.__updateColumnsBodyContentHidden();
  }
  /** @private */
  _updateRowOrderParts(n, e = n.index) {
    Ai(n, {
      first: e === 0,
      last: e === this._flatSize - 1,
      odd: e % 2 !== 0,
      even: e % 2 === 0
    });
  }
  /** @private */
  _updateRowStateParts(n, { expanded: e, selected: t, detailsOpened: i }) {
    Ai(n, {
      expanded: e,
      collapsed: this.__isRowExpandable(n),
      selected: t,
      "details-opened": i
    });
  }
  /** @private */
  __computeEmptyState(n, e) {
    return n === 0 && e;
  }
  /**
   * @param {!Array<!GridColumn>} columnTree
   * @protected
   */
  _renderColumnTree(n) {
    for (ht(this.$.items, (e) => {
      this._updateRow(e, n[n.length - 1], "body", !1, !0);
      const t = this.__getRowModel(e);
      this._updateRowOrderParts(e), this._updateRowStateParts(e, t), this._filterDragAndDrop(e, t);
    }); this.$.header.children.length < n.length; ) {
      const e = document.createElement("tr");
      e.setAttribute("part", "row"), e.setAttribute("role", "row"), e.setAttribute("tabindex", "-1"), this.$.header.appendChild(e);
      const t = document.createElement("tr");
      t.setAttribute("part", "row"), t.setAttribute("role", "row"), t.setAttribute("tabindex", "-1"), this.$.footer.appendChild(t);
    }
    for (; this.$.header.children.length > n.length; )
      this.$.header.removeChild(this.$.header.firstElementChild), this.$.footer.removeChild(this.$.footer.firstElementChild);
    ht(this.$.header, (e, t, i) => {
      this._updateRow(e, n[t], "header", t === n.length - 1);
      const r = Li(e);
      jt(r, "first-header-row-cell", t === 0), jt(r, "last-header-row-cell", t === i.length - 1);
    }), ht(this.$.footer, (e, t, i) => {
      this._updateRow(e, n[n.length - 1 - t], "footer", t === 0);
      const r = Li(e);
      jt(r, "first-footer-row-cell", t === 0), jt(r, "last-footer-row-cell", t === i.length - 1);
    }), this._updateRow(this.$.sizer, n[n.length - 1]), this._resizeHandler(), this._frozenCellsChanged(), this._updateFirstAndLastColumn(), this._resetKeyboardNavigation(), this._a11yUpdateHeaderRows(), this._a11yUpdateFooterRows(), this.generateCellClassNames(), this.generateCellPartNames(), this.__updateHeaderAndFooter();
  }
  /**
   * @param {!HTMLElement} row
   * @param {GridItem} item
   * @protected
   */
  _updateItem(n, e) {
    n._item = e;
    const t = this.__getRowModel(n);
    this._toggleDetailsCell(n, t.detailsOpened), this._a11yUpdateRowLevel(n, t.level), this._a11yUpdateRowSelected(n, t.selected), this._updateRowStateParts(n, t), this._generateCellClassNames(n, t), this._generateCellPartNames(n, t), this._filterDragAndDrop(n, t), this.__updateDragSourceParts(n, t), ht(n, (i) => {
      if (!(i._column && !i._column.isConnected) && i._renderer) {
        const r = i._column || this;
        i._renderer.call(r, i._content, r, t);
      }
    }), this._updateDetailsCellHeight(n), this._a11yUpdateRowExpanded(n, t.expanded);
  }
  /** @private */
  _resizeHandler() {
    this._updateDetailsCellHeights(), this.__updateHorizontalScrollPosition();
  }
  /** @private */
  _onAnimationEnd(n) {
    n.animationName.indexOf("vaadin-grid-appear") === 0 && (n.stopPropagation(), this.__tryToRecalculateColumnWidthsIfPending(), this._resetKeyboardNavigation(), requestAnimationFrame(() => {
      this.__scrollToPendingIndexes();
    }));
  }
  /**
   * @param {!HTMLTableRowElement} row
   * @return {!GridItemModel}
   * @protected
   */
  __getRowModel(n) {
    return {
      index: n.index,
      item: n._item,
      level: this._getIndexLevel(n.index),
      expanded: this._isExpanded(n._item),
      selected: this._isSelected(n._item),
      detailsOpened: !!this.rowDetailsRenderer && this._isDetailsOpened(n._item)
    };
  }
  /**
   * @param {Event} event
   * @protected
   */
  _showTooltip(n) {
    const e = this._tooltipController.node;
    if (e && e.isConnected) {
      const t = n.target;
      if (!this.__isCellFullyVisible(t))
        return;
      this._tooltipController.setTarget(t), this._tooltipController.setContext(this.getEventContext(n)), e._stateController.open({
        focus: n.type === "focusin",
        hover: n.type === "mouseenter"
      });
    }
  }
  /** @private */
  __isCellFullyVisible(n) {
    if (n.hasAttribute("frozen") || n.hasAttribute("frozen-to-end"))
      return !0;
    let { left: e, right: t } = this.getBoundingClientRect();
    const i = [...n.parentNode.children].find((a) => a.hasAttribute("last-frozen"));
    if (i) {
      const a = i.getBoundingClientRect();
      e = this.__isRTL ? e : a.right, t = this.__isRTL ? a.left : t;
    }
    const r = [...n.parentNode.children].find((a) => a.hasAttribute("first-frozen-to-end"));
    if (r) {
      const a = r.getBoundingClientRect();
      e = this.__isRTL ? a.right : e, t = this.__isRTL ? t : a.left;
    }
    const o = n.getBoundingClientRect();
    return o.left >= e && o.right <= t;
  }
  /** @protected */
  _hideTooltip(n) {
    const e = this._tooltipController && this._tooltipController.node;
    e && e._stateController.close(n);
  }
  /**
   * Requests an update for the content of cells.
   *
   * While performing the update, the following renderers are invoked:
   * - `Grid.rowDetailsRenderer`
   * - `GridColumn.renderer`
   * - `GridColumn.headerRenderer`
   * - `GridColumn.footerRenderer`
   *
   * It is not guaranteed that the update happens immediately (synchronously) after it is requested.
   */
  requestContentUpdate() {
    this.__updateHeaderAndFooter(), this.__updateVisibleRows();
  }
  /** @private */
  __updateHeaderAndFooter() {
    (this._columnTree || []).forEach((n) => {
      n.forEach((e) => {
        e._renderHeaderAndFooter && e._renderHeaderAndFooter();
      });
    });
  }
  /** @protected */
  __updateVisibleRows(n, e) {
    this.__virtualizer && this.__virtualizer.update(n, e);
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Af = ke`
  @keyframes vaadin-grid-appear {
    to {
      opacity: 1;
    }
  }

  :host {
    display: flex;
    flex-direction: column;
    animation: 1ms vaadin-grid-appear;
    height: 400px;
    flex: 1 1 auto;
    align-self: stretch;
    position: relative;
  }

  :host([hidden]) {
    display: none !important;
  }

  :host([disabled]) {
    pointer-events: none;
  }

  #scroller {
    display: flex;
    flex-direction: column;
    min-height: 100%;
    transform: translateY(0);
    width: auto;
    height: auto;
    position: absolute;
    inset: 0;
  }

  :host([all-rows-visible]) {
    height: auto;
    align-self: flex-start;
    flex-grow: 0;
    width: 100%;
  }

  :host([all-rows-visible]) #scroller {
    width: 100%;
    height: 100%;
    position: relative;
  }

  :host([all-rows-visible]) #items {
    min-height: 1px;
  }

  #table {
    display: flex;
    flex-direction: column;
    width: 100%;
    height: 100%;
    overflow: auto;
    position: relative;
    outline: none;
    /* Workaround for a Desktop Safari bug: new stacking context here prevents the scrollbar from getting hidden */
    z-index: 0;
  }

  #header,
  #footer {
    display: block;
    position: -webkit-sticky;
    position: sticky;
    left: 0;
    overflow: visible;
    width: 100%;
    z-index: 1;
  }

  #header {
    top: 0;
  }

  th {
    text-align: inherit;
  }

  /* Safari doesn't work with "inherit" */
  [safari] th {
    text-align: initial;
  }

  #footer {
    bottom: 0;
  }

  #items {
    flex-grow: 1;
    flex-shrink: 0;
    display: block;
    position: -webkit-sticky;
    position: sticky;
    width: 100%;
    left: 0;
    overflow: visible;
  }

  [part~='row'] {
    display: flex;
    width: 100%;
    box-sizing: border-box;
    margin: 0;
  }

  [part~='row'][loading] [part~='body-cell'] ::slotted(vaadin-grid-cell-content) {
    visibility: hidden;
  }

  [column-rendering='lazy'] [part~='body-cell']:not([frozen]):not([frozen-to-end]) {
    transform: translateX(var(--_grid-lazy-columns-start));
  }

  #items [part~='row'] {
    position: absolute;
  }

  #items [part~='row']:empty {
    height: 100%;
  }

  [part~='cell']:not([part~='details-cell']) {
    flex-shrink: 0;
    flex-grow: 1;
    box-sizing: border-box;
    display: flex;
    width: 100%;
    position: relative;
    align-items: center;
    padding: 0;
    white-space: nowrap;
  }

  [part~='cell'] {
    outline: none;
  }

  [part~='cell'] > [tabindex] {
    display: flex;
    align-items: inherit;
    outline: none;
    position: absolute;
    inset: 0;
  }

  /* Switch the focusButtonMode wrapping element to "position: static" temporarily
     when measuring real width of the cells in the auto-width columns. */
  [measuring-auto-width] [part~='cell'] > [tabindex] {
    position: static;
  }

  [part~='details-cell'] {
    position: absolute;
    bottom: 0;
    width: 100%;
    box-sizing: border-box;
    padding: 0;
  }

  [part~='cell'] ::slotted(vaadin-grid-cell-content) {
    display: block;
    width: 100%;
    box-sizing: border-box;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  [hidden] {
    display: none !important;
  }

  [frozen],
  [frozen-to-end] {
    z-index: 2;
    will-change: transform;
  }

  [no-scrollbars][safari] #table,
  [no-scrollbars][firefox] #table {
    overflow: hidden;
  }

  /* Empty state */

  #scroller:not([empty-state]) #emptystatebody,
  #scroller[empty-state] #items {
    display: none;
  }

  #emptystatebody {
    display: flex;
    position: sticky;
    inset: 0;
    flex: 1;
    overflow: hidden;
  }

  #emptystaterow {
    display: flex;
    flex: 1;
  }

  #emptystatecell {
    display: block;
    flex: 1;
    overflow: auto;
  }

  /* Reordering styles */
  :host([reordering]) [part~='cell'] ::slotted(vaadin-grid-cell-content),
  :host([reordering]) [part~='resize-handle'],
  #scroller[no-content-pointer-events] [part~='cell'] ::slotted(vaadin-grid-cell-content) {
    pointer-events: none;
  }

  [part~='reorder-ghost'] {
    visibility: hidden;
    position: fixed;
    pointer-events: none;
    opacity: 0.5;

    /* Prevent overflowing the grid in Firefox */
    top: 0;
    left: 0;
  }

  :host([reordering]) {
    -moz-user-select: none;
    -webkit-user-select: none;
    user-select: none;
  }

  /* Resizing styles */
  [part~='resize-handle'] {
    position: absolute;
    top: 0;
    right: 0;
    height: 100%;
    cursor: col-resize;
    z-index: 1;
  }

  [part~='resize-handle']::before {
    position: absolute;
    content: '';
    height: 100%;
    width: 35px;
    transform: translateX(-50%);
  }

  [last-column] [part~='resize-handle']::before,
  [last-frozen] [part~='resize-handle']::before {
    width: 18px;
    transform: none;
    right: 0;
  }

  [frozen-to-end] [part~='resize-handle'] {
    left: 0;
    right: auto;
  }

  [frozen-to-end] [part~='resize-handle']::before {
    left: 0;
    right: auto;
  }

  [first-frozen-to-end] [part~='resize-handle']::before {
    width: 18px;
    transform: none;
  }

  [first-frozen-to-end] {
    margin-inline-start: auto;
  }

  /* Hide resize handle if scrolled to end */
  :host(:not([overflow~='end'])) [first-frozen-to-end] [part~='resize-handle'] {
    display: none;
  }

  #scroller[column-resizing] {
    -ms-user-select: none;
    -moz-user-select: none;
    -webkit-user-select: none;
    user-select: none;
  }

  /* Sizer styles */
  #sizer {
    display: flex;
    position: absolute;
    visibility: hidden;
  }

  #sizer [part~='details-cell'] {
    display: none !important;
  }

  #sizer [part~='cell'][hidden] {
    display: none !important;
  }

  #sizer [part~='cell'] {
    display: block;
    flex-shrink: 0;
    line-height: 0;
    height: 0 !important;
    min-height: 0 !important;
    max-height: 0 !important;
    padding: 0 !important;
    border: none !important;
  }

  #sizer [part~='cell']::before {
    content: '-';
  }

  #sizer [part~='cell'] ::slotted(vaadin-grid-cell-content) {
    display: none !important;
  }

  /* RTL specific styles */

  :host([dir='rtl']) #items,
  :host([dir='rtl']) #header,
  :host([dir='rtl']) #footer {
    left: auto;
  }

  :host([dir='rtl']) [part~='reorder-ghost'] {
    left: auto;
    right: 0;
  }

  :host([dir='rtl']) [part~='resize-handle'] {
    left: 0;
    right: auto;
  }

  :host([dir='rtl']) [part~='resize-handle']::before {
    transform: translateX(50%);
  }

  :host([dir='rtl']) [last-column] [part~='resize-handle']::before,
  :host([dir='rtl']) [last-frozen] [part~='resize-handle']::before {
    left: 0;
    right: auto;
  }

  :host([dir='rtl']) [frozen-to-end] [part~='resize-handle'] {
    right: 0;
    left: auto;
  }

  :host([dir='rtl']) [frozen-to-end] [part~='resize-handle']::before {
    right: 0;
    left: auto;
  }

  @media (forced-colors: active) {
    [part~='selected-row'] [part~='first-column-cell']::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      bottom: 0;
      border: 2px solid;
    }

    [part~='focused-cell']::before {
      outline: 2px solid !important;
      outline-offset: -1px;
    }
  }
`;
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
Qe("vaadin-grid", Af, { moduleId: "vaadin-grid-styles" });
class If extends Rf(Hl(xr(Tr(mi)))) {
  static get template() {
    return Vi`
      <div
        id="scroller"
        safari$="[[_safari]]"
        ios$="[[_ios]]"
        loading$="[[loading]]"
        column-reordering-allowed$="[[columnReorderingAllowed]]"
        empty-state$="[[__emptyState]]"
      >
        <table id="table" role="treegrid" aria-multiselectable="true" tabindex="0">
          <caption id="sizer" part="row"></caption>
          <thead id="header" role="rowgroup"></thead>
          <tbody id="items" role="rowgroup"></tbody>
          <tbody id="emptystatebody">
            <tr id="emptystaterow">
              <td part="empty-state" id="emptystatecell" tabindex="0">
                <slot name="empty-state" id="emptystateslot"></slot>
              </td>
            </tr>
          </tbody>
          <tfoot id="footer" role="rowgroup"></tfoot>
        </table>

        <div part="reorder-ghost"></div>
      </div>

      <slot name="tooltip"></slot>

      <div id="focusexit" tabindex="0"></div>
    `;
  }
  static get is() {
    return "vaadin-grid";
  }
}
Zt(If);
const cc = ke`
  :host {
    display: flex;
    align-items: center;
    box-sizing: border-box;
    font-family: var(--lumo-font-family);
    font-size: var(--lumo-font-size-m);
    line-height: var(--lumo-line-height-xs);
    padding: 0.5em calc(var(--lumo-space-l) + var(--lumo-border-radius-m) / 4) 0.5em
      var(--_lumo-list-box-item-padding-left, calc(var(--lumo-border-radius-m) / 4));
    min-height: var(--lumo-size-m);
    outline: none;
    border-radius: var(--lumo-border-radius-m);
    cursor: var(--lumo-clickable-cursor);
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    -webkit-tap-highlight-color: var(--lumo-primary-color-10pct);
    --_focus-ring-color: var(--vaadin-focus-ring-color, var(--lumo-primary-color-50pct));
    --_focus-ring-width: var(--vaadin-focus-ring-width, 2px);
    --_selection-color-text: var(--vaadin-selection-color-text, var(--lumo-primary-text-color));
  }

  /* Checkmark */
  [part='checkmark']::before {
    display: var(--_lumo-item-selected-icon-display, none);
    content: var(--lumo-icons-checkmark);
    font-family: lumo-icons;
    font-size: var(--lumo-icon-size-m);
    line-height: 1;
    font-weight: normal;
    width: 1em;
    height: 1em;
    margin: calc((1 - var(--lumo-line-height-xs)) * var(--lumo-font-size-m) / 2) 0;
    color: var(--_selection-color-text);
    flex: none;
    opacity: 0;
    transition:
      transform 0.2s cubic-bezier(0.12, 0.32, 0.54, 2),
      opacity 0.1s;
  }

  :host([selected]) [part='checkmark']::before {
    opacity: 1;
  }

  :host([active]:not([selected])) [part='checkmark']::before {
    transform: scale(0.8);
    opacity: 0;
    transition-duration: 0s;
  }

  [part='content'] {
    flex: auto;
  }

  /* Disabled */
  :host([disabled]) {
    color: var(--lumo-disabled-text-color);
    cursor: default;
    pointer-events: none;
  }

  /* TODO a workaround until we have "focus-follows-mouse". After that, use the hover style for focus-ring as well */
  @media (any-hover: hover) {
    :host(:hover:not([disabled])) {
      background-color: var(--lumo-primary-color-10pct);
    }
  }

  :host([focus-ring]:not([disabled])) {
    box-shadow: inset 0 0 0 var(--_focus-ring-width) var(--_focus-ring-color);
  }

  /* RTL specific styles */
  :host([dir='rtl']) {
    padding-left: calc(var(--lumo-space-l) + var(--lumo-border-radius-m) / 4);
    padding-right: var(--_lumo-list-box-item-padding-left, calc(var(--lumo-border-radius-m) / 4));
  }

  /* Slotted icons */
  :host ::slotted(vaadin-icon) {
    width: var(--lumo-icon-size-m);
    height: var(--lumo-icon-size-m);
  }
`;
Qe("vaadin-item", cc, { moduleId: "lumo-item" });
const Df = ke`
  :host {
    transition: background-color 100ms;
    overflow: hidden;
    --_lumo-item-selected-icon-display: block;
    --_focus-ring-color: var(--vaadin-focus-ring-color, var(--lumo-primary-color-50pct));
    --_focus-ring-width: var(--vaadin-focus-ring-width, 2px);
  }

  :host([focused]:not([disabled])) {
    box-shadow: inset 0 0 0 var(--_focus-ring-width) var(--_focus-ring-color);
  }
`;
Qe("vaadin-combo-box-item", [cc, Df], {
  moduleId: "lumo-combo-box-item"
});
/**
 * @license
 * Copyright (c) 2022 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Of = ke`
  [part~='loader'] {
    box-sizing: border-box;
    width: var(--lumo-icon-size-s);
    height: var(--lumo-icon-size-s);
    border: 2px solid transparent;
    border-color: var(--lumo-primary-color-10pct) var(--lumo-primary-color-10pct) var(--lumo-primary-color)
      var(--lumo-primary-color);
    border-radius: calc(0.5 * var(--lumo-icon-size-s));
    opacity: 0;
    pointer-events: none;
  }

  :host(:not([loading])) [part~='loader'] {
    display: none;
  }

  :host([loading]) [part~='loader'] {
    animation:
      1s linear infinite lumo-loader-rotate,
      0.3s 0.1s lumo-loader-fade-in both;
  }

  @keyframes lumo-loader-fade-in {
    0% {
      opacity: 0;
    }

    100% {
      opacity: 1;
    }
  }

  @keyframes lumo-loader-rotate {
    0% {
      transform: rotate(0deg);
    }

    100% {
      transform: rotate(360deg);
    }
  }
`;
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const xs = ke`
  :host {
    top: var(--lumo-space-m);
    right: var(--lumo-space-m);
    bottom: var(--lumo-space-m);
    left: var(--lumo-space-m);
    /* Workaround for Edge issue (only on Surface), where an overflowing vaadin-list-box inside vaadin-select-overlay makes the overlay transparent */
    /* stylelint-disable-next-line */
    outline: 0px solid transparent;
  }

  [part='overlay'] {
    background-color: var(--lumo-base-color);
    background-image: linear-gradient(var(--lumo-tint-5pct), var(--lumo-tint-5pct));
    border-radius: var(--lumo-border-radius-m);
    box-shadow:
      0 0 0 1px var(--lumo-shade-5pct),
      var(--lumo-box-shadow-m);
    color: var(--lumo-body-text-color);
    font-family: var(--lumo-font-family);
    font-size: var(--lumo-font-size-m);
    font-weight: 400;
    line-height: var(--lumo-line-height-m);
    letter-spacing: 0;
    text-transform: none;
    -webkit-text-size-adjust: 100%;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }

  [part='content'] {
    padding: var(--lumo-space-xs);
  }

  [part='backdrop'] {
    background-color: var(--lumo-shade-20pct);
    animation: 0.2s lumo-overlay-backdrop-enter both;
    will-change: opacity;
  }

  @keyframes lumo-overlay-backdrop-enter {
    0% {
      opacity: 0;
    }
  }

  :host([closing]) [part='backdrop'] {
    animation: 0.2s lumo-overlay-backdrop-exit both;
  }

  @keyframes lumo-overlay-backdrop-exit {
    100% {
      opacity: 0;
    }
  }

  @keyframes lumo-overlay-dummy-animation {
    0% {
      opacity: 1;
    }

    100% {
      opacity: 1;
    }
  }
`;
Qe("", xs, { moduleId: "lumo-overlay" });
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Cs = ke`
  :host([opening]),
  :host([closing]) {
    animation: 0.14s lumo-overlay-dummy-animation;
  }

  [part='overlay'] {
    will-change: opacity, transform;
  }

  :host([opening]) [part='overlay'] {
    animation: 0.1s lumo-menu-overlay-enter ease-out both;
  }

  @keyframes lumo-menu-overlay-enter {
    0% {
      opacity: 0;
      transform: translateY(-4px);
    }
  }

  :host([closing]) [part='overlay'] {
    animation: 0.1s lumo-menu-overlay-exit both;
  }

  @keyframes lumo-menu-overlay-exit {
    100% {
      opacity: 0;
    }
  }
`;
Qe("", Cs, { moduleId: "lumo-menu-overlay-core" });
const zf = ke`
  /* Small viewport (bottom sheet) styles */
  /* Use direct media queries instead of the state attributes ([phone] and [fullscreen]) provided by the elements */
  @media (max-width: 420px), (max-height: 420px) {
    :host {
      top: 0 !important;
      right: 0 !important;
      bottom: var(--vaadin-overlay-viewport-bottom, 0) !important;
      left: 0 !important;
      align-items: stretch !important;
      justify-content: flex-end !important;
    }

    [part='overlay'] {
      max-height: 50vh;
      width: 100vw;
      border-radius: 0;
      box-shadow: var(--lumo-box-shadow-xl);
    }

    /* The content part scrolls instead of the overlay part, because of the gradient fade-out */
    [part='content'] {
      padding: 30px var(--lumo-space-m);
      max-height: inherit;
      box-sizing: border-box;
      -webkit-overflow-scrolling: touch;
      overflow: auto;
      -webkit-mask-image: linear-gradient(transparent, #000 40px, #000 calc(100% - 40px), transparent);
      mask-image: linear-gradient(transparent, #000 40px, #000 calc(100% - 40px), transparent);
    }

    [part='backdrop'] {
      display: block;
    }

    /* Animations */

    :host([opening]) [part='overlay'] {
      animation: 0.2s lumo-mobile-menu-overlay-enter cubic-bezier(0.215, 0.61, 0.355, 1) both;
    }

    :host([closing]),
    :host([closing]) [part='backdrop'] {
      animation-delay: 0.14s;
    }

    :host([closing]) [part='overlay'] {
      animation: 0.14s 0.14s lumo-mobile-menu-overlay-exit cubic-bezier(0.55, 0.055, 0.675, 0.19) both;
    }
  }

  @keyframes lumo-mobile-menu-overlay-enter {
    0% {
      transform: translateY(150%);
    }
  }

  @keyframes lumo-mobile-menu-overlay-exit {
    100% {
      transform: translateY(150%);
    }
  }
`, Ff = [xs, Cs, zf];
Qe("", Ff, { moduleId: "lumo-menu-overlay" });
const Mf = ke`
  [part='content'] {
    padding: 0;
  }

  /* When items are empty, the spinner needs some room */
  :host(:not([closing])) [part~='content'] {
    min-height: calc(2 * var(--lumo-space-s) + var(--lumo-icon-size-s));
  }

  [part~='overlay'] {
    position: relative;
  }

  :host([top-aligned]) [part~='overlay'] {
    margin-top: var(--lumo-space-xs);
  }

  :host([bottom-aligned]) [part~='overlay'] {
    margin-bottom: var(--lumo-space-xs);
  }
`, Lf = ke`
  [part~='loader'] {
    position: absolute;
    z-index: 1;
    inset-inline: var(--lumo-space-s);
    top: var(--lumo-space-s);
    margin-inline: auto 0;
  }
`;
Qe(
  "vaadin-combo-box-overlay",
  [
    xs,
    Cs,
    Mf,
    Of,
    Lf,
    ke`
      :host {
        --_vaadin-combo-box-items-container-border-width: var(--lumo-space-xs);
        --_vaadin-combo-box-items-container-border-style: solid;
      }
    `
  ],
  { moduleId: "lumo-combo-box-overlay" }
);
Qe(
  "vaadin-input-container",
  ke`
    :host {
      background: var(--_background);
      padding: 0 calc(0.375em + var(--_input-container-radius) / 4 - 1px);
      font-weight: var(--vaadin-input-field-value-font-weight, 500);
      line-height: 1;
      position: relative;
      cursor: text;
      box-sizing: border-box;
      border-radius:
        /* See https://developer.mozilla.org/en-US/docs/Web/CSS/border-radius#syntax */
        var(--vaadin-input-field-top-start-radius, var(--_input-container-radius))
        var(--vaadin-input-field-top-end-radius, var(--_input-container-radius))
        var(--vaadin-input-field-bottom-end-radius, var(--_input-container-radius))
        var(--vaadin-input-field-bottom-start-radius, var(--_input-container-radius));
      /* Fallback */
      --_input-container-radius: var(--vaadin-input-field-border-radius, var(--lumo-border-radius-m));
      --_input-height: var(--lumo-text-field-size, var(--lumo-size-m));
      /* Default values */
      --_background: var(--vaadin-input-field-background, var(--lumo-contrast-10pct));
      --_hover-highlight: var(--vaadin-input-field-hover-highlight, var(--lumo-contrast-50pct));
      --_input-border-color: var(--vaadin-input-field-border-color, var(--lumo-contrast-50pct));
      --_icon-color: var(--vaadin-input-field-icon-color, var(--lumo-contrast-60pct));
      --_icon-size: var(--vaadin-input-field-icon-size, var(--lumo-icon-size-m));
      --_invalid-background: var(--vaadin-input-field-invalid-background, var(--lumo-error-color-10pct));
      --_invalid-hover-highlight: var(--vaadin-input-field-invalid-hover-highlight, var(--lumo-error-color-50pct));
      --_disabled-background: var(--vaadin-input-field-disabled-background, var(--lumo-contrast-5pct));
      --_disabled-value-color: var(--vaadin-input-field-disabled-value-color, var(--lumo-disabled-text-color));
    }

    :host([dir='rtl']) {
      border-radius:
        /* Don't use logical props, see https://github.com/vaadin/vaadin-time-picker/issues/145 */
        var(--vaadin-input-field-top-end-radius, var(--_input-container-radius))
        var(--vaadin-input-field-top-start-radius, var(--_input-container-radius))
        var(--vaadin-input-field-bottom-start-radius, var(--_input-container-radius))
        var(--vaadin-input-field-bottom-end-radius, var(--_input-container-radius));
    }

    /* Used for hover and activation effects */
    :host::after {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: inherit;
      pointer-events: none;
      background: var(--_hover-highlight);
      opacity: 0;
      transition:
        transform 0.15s,
        opacity 0.2s;
      transform-origin: 100% 0;
    }

    ::slotted(:not([slot$='fix'])) {
      cursor: inherit;
      min-height: var(--vaadin-input-field-height, var(--_input-height));
      padding: 0 0.25em;
      --_lumo-text-field-overflow-mask-image: linear-gradient(to left, transparent, #000 1.25em);
      -webkit-mask-image: var(--_lumo-text-field-overflow-mask-image);
      mask-image: var(--_lumo-text-field-overflow-mask-image);
    }

    /* Read-only */
    :host([readonly]) {
      color: var(--lumo-secondary-text-color);
      background-color: transparent;
      cursor: default;
    }

    :host([readonly])::after {
      background-color: transparent;
      opacity: 1;
      border: var(--vaadin-input-field-readonly-border, 1px dashed var(--lumo-contrast-30pct));
    }

    /* Disabled */
    :host([disabled]) {
      background: var(--_disabled-background);
    }

    :host([disabled]) ::slotted(:not([slot$='fix'])) {
      -webkit-text-fill-color: var(--_disabled-value-color);
      color: var(--_disabled-value-color);
    }

    /* Invalid */
    :host([invalid]) {
      background: var(--_invalid-background);
    }

    :host([invalid]:not([readonly]))::after {
      background: var(--_invalid-hover-highlight);
    }

    /* Slotted icons */
    ::slotted(vaadin-icon) {
      color: var(--_icon-color);
      width: var(--_icon-size);
      height: var(--_icon-size);
    }

    /* Vaadin icons are based on a 16x16 grid (unlike Lumo and Material icons with 24x24), so they look too big by default */
    ::slotted(vaadin-icon[icon^='vaadin:']) {
      padding: 0.25em;
      box-sizing: border-box !important;
    }

    /* Text align */
    :host([dir='rtl']) ::slotted(:not([slot$='fix'])) {
      --_lumo-text-field-overflow-mask-image: linear-gradient(to right, transparent, #000 1.25em);
    }

    @-moz-document url-prefix() {
      :host([dir='rtl']) ::slotted(:not([slot$='fix'])) {
        mask-image: var(--_lumo-text-field-overflow-mask-image);
      }
    }

    :host([theme~='align-left']) ::slotted(:not([slot$='fix'])) {
      text-align: start;
      --_lumo-text-field-overflow-mask-image: none;
    }

    :host([theme~='align-center']) ::slotted(:not([slot$='fix'])) {
      text-align: center;
      --_lumo-text-field-overflow-mask-image: none;
    }

    :host([theme~='align-right']) ::slotted(:not([slot$='fix'])) {
      text-align: end;
      --_lumo-text-field-overflow-mask-image: none;
    }

    @-moz-document url-prefix() {
      /* Firefox is smart enough to align overflowing text to right */
      :host([theme~='align-right']) ::slotted(:not([slot$='fix'])) {
        --_lumo-text-field-overflow-mask-image: linear-gradient(to right, transparent 0.25em, #000 1.5em);
      }
    }

    @-moz-document url-prefix() {
      /* Firefox is smart enough to align overflowing text to right */
      :host([theme~='align-left']) ::slotted(:not([slot$='fix'])) {
        --_lumo-text-field-overflow-mask-image: linear-gradient(to left, transparent 0.25em, #000 1.5em);
      }
    }

    /* RTL specific styles */
    :host([dir='rtl'])::after {
      transform-origin: 0% 0;
    }

    :host([theme~='align-left'][dir='rtl']) ::slotted(:not([slot$='fix'])) {
      --_lumo-text-field-overflow-mask-image: none;
    }

    :host([theme~='align-center'][dir='rtl']) ::slotted(:not([slot$='fix'])) {
      --_lumo-text-field-overflow-mask-image: none;
    }

    :host([theme~='align-right'][dir='rtl']) ::slotted(:not([slot$='fix'])) {
      --_lumo-text-field-overflow-mask-image: none;
    }

    @-moz-document url-prefix() {
      /* Firefox is smart enough to align overflowing text to right */
      :host([theme~='align-right'][dir='rtl']) ::slotted(:not([slot$='fix'])) {
        --_lumo-text-field-overflow-mask-image: linear-gradient(to right, transparent 0.25em, #000 1.5em);
      }
    }

    @-moz-document url-prefix() {
      /* Firefox is smart enough to align overflowing text to right */
      :host([theme~='align-left'][dir='rtl']) ::slotted(:not([slot$='fix'])) {
        --_lumo-text-field-overflow-mask-image: linear-gradient(to left, transparent 0.25em, #000 1.5em);
      }
    }
  `,
  { moduleId: "lumo-input-container" }
);
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const uc = ke`
  [part$='button'] {
    flex: none;
    width: 1em;
    height: 1em;
    line-height: 1;
    font-size: var(--lumo-icon-size-m);
    text-align: center;
    color: var(--lumo-contrast-60pct);
    transition: 0.2s color;
    cursor: var(--lumo-clickable-cursor);
  }

  [part$='button']:hover {
    color: var(--lumo-contrast-90pct);
  }

  :host([disabled]) [part$='button'],
  :host([readonly]) [part$='button'] {
    color: var(--lumo-contrast-20pct);
    cursor: default;
  }

  [part$='button']::before {
    font-family: 'lumo-icons';
    display: block;
  }
`;
Qe("", uc, { moduleId: "lumo-field-button" });
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Bf = ke`
  :host {
    --_helper-spacing: var(--vaadin-input-field-helper-spacing, 0.4em);
  }

  :host([has-helper]) [part='helper-text']::before {
    content: '';
    display: block;
    height: var(--_helper-spacing);
  }

  [part='helper-text'] {
    display: block;
    color: var(--vaadin-input-field-helper-color, var(--lumo-secondary-text-color));
    font-size: var(--vaadin-input-field-helper-font-size, var(--lumo-font-size-xs));
    line-height: var(--lumo-line-height-xs);
    font-weight: var(--vaadin-input-field-helper-font-weight, 400);
    margin-left: calc(var(--lumo-border-radius-m) / 4);
    transition: color 0.2s;
  }

  :host(:hover:not([readonly])) [part='helper-text'] {
    color: var(--lumo-body-text-color);
  }

  :host([disabled]) [part='helper-text'] {
    color: var(--lumo-disabled-text-color);
    -webkit-text-fill-color: var(--lumo-disabled-text-color);
  }

  :host([has-helper][theme~='helper-above-field']) [part='helper-text']::before {
    display: none;
  }

  :host([has-helper][theme~='helper-above-field']) [part='helper-text']::after {
    content: '';
    display: block;
    height: var(--_helper-spacing);
  }

  :host([has-helper][theme~='helper-above-field']) [part='label'] {
    order: 0;
    padding-bottom: var(--_helper-spacing);
  }

  :host([has-helper][theme~='helper-above-field']) [part='helper-text'] {
    order: 1;
  }

  :host([has-helper][theme~='helper-above-field']) [part='label'] + * {
    order: 2;
  }

  :host([has-helper][theme~='helper-above-field']) [part='error-message'] {
    order: 3;
  }
`;
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const dc = ke`
  [part='label'] {
    align-self: flex-start;
    color: var(--vaadin-input-field-label-color, var(--lumo-secondary-text-color));
    font-weight: var(--vaadin-input-field-label-font-weight, 500);
    font-size: var(--vaadin-input-field-label-font-size, var(--lumo-font-size-s));
    margin-left: calc(var(--lumo-border-radius-m) / 4);
    transition: color 0.2s;
    line-height: 1;
    padding-right: 1em;
    padding-bottom: 0.5em;
    /* As a workaround for diacritics being cut off, add a top padding and a
    negative margin to compensate */
    padding-top: 0.25em;
    margin-top: -0.25em;
    overflow: hidden;
    white-space: nowrap;
    text-overflow: ellipsis;
    position: relative;
    max-width: 100%;
    box-sizing: border-box;
  }

  :host([focused]:not([readonly])) [part='label'] {
    color: var(--vaadin-input-field-focused-label-color, var(--lumo-primary-text-color));
  }

  :host(:hover:not([readonly]):not([focused])) [part='label'] {
    color: var(--vaadin-input-field-hovered-label-color, var(--lumo-body-text-color));
  }

  /* Touch device adjustment */
  @media (pointer: coarse) {
    :host(:hover:not([readonly]):not([focused])) [part='label'] {
      color: var(--vaadin-input-field-label-color, var(--lumo-secondary-text-color));
    }
  }

  :host([has-label])::before {
    margin-top: calc(var(--lumo-font-size-s) * 1.5);
  }

  :host([has-label][theme~='small'])::before {
    margin-top: calc(var(--lumo-font-size-xs) * 1.5);
  }

  :host([has-label]) {
    padding-top: var(--lumo-space-m);
  }

  :host([has-label]) ::slotted([slot='tooltip']) {
    --vaadin-tooltip-offset-bottom: calc((var(--lumo-space-m) - var(--lumo-space-xs)) * -1);
  }

  :host([required]) [part='required-indicator']::after {
    content: var(--lumo-required-field-indicator, '\\2022');
    transition: opacity 0.2s;
    color: var(--lumo-required-field-indicator-color, var(--lumo-primary-text-color));
    position: absolute;
    right: 0;
    width: 1em;
    text-align: center;
  }

  :host([invalid]) [part='required-indicator']::after {
    color: var(--lumo-required-field-indicator-color, var(--lumo-error-text-color));
  }

  [part='error-message'] {
    margin-left: calc(var(--lumo-border-radius-m) / 4);
    font-size: var(--vaadin-input-field-error-font-size, var(--lumo-font-size-xs));
    line-height: var(--lumo-line-height-xs);
    font-weight: var(--vaadin-input-field-error-font-weight, 400);
    color: var(--vaadin-input-field-error-color, var(--lumo-error-text-color));
    will-change: max-height;
    transition: 0.4s max-height;
    max-height: 5em;
  }

  :host([has-error-message]) [part='error-message']::before,
  :host([has-error-message]) [part='error-message']::after {
    content: '';
    display: block;
    height: 0.4em;
  }

  :host(:not([invalid])) [part='error-message'] {
    max-height: 0;
    overflow: hidden;
  }

  /* RTL specific styles */

  :host([dir='rtl']) [part='label'] {
    margin-left: 0;
    margin-right: calc(var(--lumo-border-radius-m) / 4);
  }

  :host([dir='rtl']) [part='label'] {
    padding-left: 1em;
    padding-right: 0;
  }

  :host([dir='rtl']) [part='required-indicator']::after {
    right: auto;
    left: 0;
  }

  :host([dir='rtl']) [part='error-message'] {
    margin-left: 0;
    margin-right: calc(var(--lumo-border-radius-m) / 4);
  }
`;
Qe("", dc, { moduleId: "lumo-required-field" });
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Nf = ke`
  :host {
    --lumo-text-field-size: var(--lumo-size-m);
    color: var(--vaadin-input-field-value-color, var(--lumo-body-text-color));
    font-size: var(--vaadin-input-field-value-font-size, var(--lumo-font-size-m));
    font-family: var(--lumo-font-family);
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    -webkit-tap-highlight-color: transparent;
    padding: var(--lumo-space-xs) 0;
    --_focus-ring-color: var(--vaadin-focus-ring-color, var(--lumo-primary-color-50pct));
    --_focus-ring-width: var(--vaadin-focus-ring-width, 2px);
    --_input-height: var(--vaadin-input-field-height, var(--lumo-text-field-size));
    --_disabled-value-color: var(--vaadin-input-field-disabled-value-color, var(--lumo-disabled-text-color));
  }

  :host::before {
    height: var(--_input-height);
    box-sizing: border-box;
    display: inline-flex;
    align-items: center;
  }

  :host([focused]) [part='input-field'] ::slotted(:is(input, textarea)) {
    -webkit-mask-image: none;
    mask-image: none;
  }

  ::slotted(:is(input, textarea):placeholder-shown) {
    color: var(--vaadin-input-field-placeholder-color, var(--lumo-secondary-text-color));
  }

  /* Hover */
  :host(:hover:not([readonly]):not([focused])) [part='input-field']::after {
    opacity: var(--vaadin-input-field-hover-highlight-opacity, 0.1);
  }

  /* Touch device adjustment */
  @media (pointer: coarse) {
    :host(:hover:not([readonly]):not([focused])) [part='input-field']::after {
      opacity: 0;
    }

    :host(:active:not([readonly]):not([focused])) [part='input-field']::after {
      opacity: 0.2;
    }
  }

  /* Trigger when not focusing using the keyboard */
  :host([focused]:not([focus-ring]):not([readonly])) [part='input-field']::after {
    transform: scaleX(0);
    transition-duration: 0.15s, 1s;
  }

  /* Focus-ring */
  :host([focus-ring]) [part='input-field'] {
    box-shadow: 0 0 0 var(--_focus-ring-width) var(--_focus-ring-color);
  }

  /* Read-only and disabled */
  :host(:is([readonly], [disabled])) ::slotted(:is(input, textarea):placeholder-shown) {
    opacity: 0;
  }

  /* Read-only style */
  :host([readonly]) {
    --vaadin-input-field-border-color: transparent;
  }

  /* Disabled style */
  :host([disabled]) {
    pointer-events: none;
    --vaadin-input-field-border-color: var(--lumo-contrast-20pct);
  }

  :host([disabled]) [part='label'],
  :host([disabled]) [part='input-field'] ::slotted([slot$='fix']) {
    color: var(--lumo-disabled-text-color);
    -webkit-text-fill-color: var(--lumo-disabled-text-color);
  }

  :host([disabled]) [part='input-field'] ::slotted(:not([slot$='fix'])) {
    color: var(--_disabled-value-color);
    -webkit-text-fill-color: var(--_disabled-value-color);
  }

  /* Invalid style */
  :host([invalid]) {
    --vaadin-input-field-border-color: var(--lumo-error-color);
  }

  :host([invalid][focus-ring]) [part='input-field'] {
    box-shadow: 0 0 0 2px var(--lumo-error-color-50pct);
  }

  :host([input-prevented]) [part='input-field'] {
    animation: shake 0.15s infinite;
  }

  @keyframes shake {
    25% {
      transform: translateX(4px);
    }
    75% {
      transform: translateX(-4px);
    }
  }

  /* Small theme */
  :host([theme~='small']) {
    font-size: var(--lumo-font-size-s);
    --lumo-text-field-size: var(--lumo-size-s);
  }

  :host([theme~='small']) [part='label'] {
    font-size: var(--lumo-font-size-xs);
  }

  :host([theme~='small']) [part='error-message'] {
    font-size: var(--lumo-font-size-xxs);
  }

  /* Slotted content */
  [part='input-field'] ::slotted(:not(vaadin-icon):not(input):not(textarea)) {
    color: var(--lumo-secondary-text-color);
    font-weight: 400;
  }

  [part='clear-button']::before {
    content: var(--lumo-icons-cross);
  }
`, hc = [dc, uc, Bf, Nf];
Qe("", hc, {
  moduleId: "lumo-input-field-shared-styles"
});
const Hf = ke`
  [part='toggle-button']::before {
    content: var(--lumo-icons-dropdown);
  }
`;
Qe("vaadin-combo-box", [hc, Hf], { moduleId: "lumo-combo-box" });
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Vf = (s) => class extends s {
  static get properties() {
    return {
      /**
       * If true, the user cannot interact with this element.
       */
      disabled: {
        type: Boolean,
        reflectToAttribute: !0
      },
      /**
       * Set to true to make this element read-only.
       */
      readonly: {
        type: Boolean,
        reflectToAttribute: !0
      },
      /**
       * Set to true when the element is invalid.
       */
      invalid: {
        type: Boolean,
        reflectToAttribute: !0
      }
    };
  }
  /** @protected */
  ready() {
    super.ready(), this.addEventListener("pointerdown", (e) => {
      e.target === this && e.preventDefault();
    }), this.addEventListener("click", (e) => {
      e.target === this && this.shadowRoot.querySelector("slot:not([name])").assignedNodes({ flatten: !0 }).forEach((t) => t.focus && t.focus());
    });
  }
};
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Uf = ke`
  :host {
    display: flex;
    align-items: center;
    flex: 0 1 auto;
    border-radius:
            /* See https://developer.mozilla.org/en-US/docs/Web/CSS/border-radius */
      var(--vaadin-input-field-top-start-radius, var(--__border-radius))
      var(--vaadin-input-field-top-end-radius, var(--__border-radius))
      var(--vaadin-input-field-bottom-end-radius, var(--__border-radius))
      var(--vaadin-input-field-bottom-start-radius, var(--__border-radius));
    --_border-radius: var(--vaadin-input-field-border-radius, 0);
    --_input-border-width: var(--vaadin-input-field-border-width, 0);
    --_input-border-color: var(--vaadin-input-field-border-color, transparent);
    box-shadow: inset 0 0 0 var(--_input-border-width, 0) var(--_input-border-color);
  }

  :host([dir='rtl']) {
    border-radius:
            /* Don't use logical props, see https://github.com/vaadin/vaadin-time-picker/issues/145 */
      var(--vaadin-input-field-top-end-radius, var(--_border-radius))
      var(--vaadin-input-field-top-start-radius, var(--_border-radius))
      var(--vaadin-input-field-bottom-start-radius, var(--_border-radius))
      var(--vaadin-input-field-bottom-end-radius, var(--_border-radius));
  }

  :host([hidden]) {
    display: none !important;
  }

  /* Reset the native input styles */
  ::slotted(input) {
    -webkit-appearance: none;
    -moz-appearance: none;
    flex: auto;
    white-space: nowrap;
    overflow: hidden;
    width: 100%;
    height: 100%;
    outline: none;
    margin: 0;
    padding: 0;
    border: 0;
    border-radius: 0;
    min-width: 0;
    font: inherit;
    line-height: normal;
    color: inherit;
    background-color: transparent;
    /* Disable default invalid style in Firefox */
    box-shadow: none;
  }

  ::slotted(*) {
    flex: none;
  }

  ::slotted(:is(input, textarea))::placeholder {
    /* Use ::slotted(input:placeholder-shown) in themes to style the placeholder. */
    /* because ::slotted(...)::placeholder does not work in Safari. */
    font: inherit;
    color: inherit;
    /* Override default opacity in Firefox */
    opacity: 1;
  }
`;
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
Qe("vaadin-input-container", Uf, { moduleId: "vaadin-input-container-styles" });
class Wf extends Vf(xr(Cr(mi))) {
  static get is() {
    return "vaadin-input-container";
  }
  static get template() {
    return Vi`
      <slot name="prefix"></slot>
      <slot></slot>
      <slot name="suffix"></slot>
    `;
  }
}
Zt(Wf);
/**
 * @license
 * Copyright (c) 2015 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const jf = (s) => class extends s {
  static get properties() {
    return {
      /**
       * The index of the item.
       */
      index: {
        type: Number
      },
      /**
       * The item to render.
       */
      item: {
        type: Object
      },
      /**
       * The text to render in the item.
       */
      label: {
        type: String
      },
      /**
       * True when item is selected.
       */
      selected: {
        type: Boolean,
        value: !1,
        reflectToAttribute: !0
      },
      /**
       * True when item is focused.
       */
      focused: {
        type: Boolean,
        value: !1,
        reflectToAttribute: !0
      },
      /**
       * Custom function for rendering the item content.
       */
      renderer: {
        type: Function
      }
    };
  }
  static get observers() {
    return ["__rendererOrItemChanged(renderer, index, item, selected, focused)", "__updateLabel(label, renderer)"];
  }
  static get observedAttributes() {
    return [...super.observedAttributes, "hidden"];
  }
  attributeChangedCallback(e, t, i) {
    e === "hidden" && i !== null ? this.index = void 0 : super.attributeChangedCallback(e, t, i);
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback(), this._owner = this.parentNode.owner;
    const e = this._owner.getAttribute("dir");
    e && this.setAttribute("dir", e);
  }
  /**
   * Requests an update for the content of the item.
   * While performing the update, it invokes the renderer passed in the `renderer` property.
   *
   * It is not guaranteed that the update happens immediately (synchronously) after it is requested.
   */
  requestContentUpdate() {
    if (!this.renderer || this.hidden)
      return;
    const e = {
      index: this.index,
      item: this.item,
      focused: this.focused,
      selected: this.selected
    };
    this.renderer(this, this._owner, e);
  }
  /** @private */
  __rendererOrItemChanged(e, t, i) {
    i === void 0 || t === void 0 || (this._oldRenderer !== e && (this.innerHTML = "", delete this._$litPart$), e && (this._oldRenderer = e, this.requestContentUpdate()));
  }
  /** @private */
  __updateLabel(e, t) {
    t || (this.textContent = e);
  }
};
/**
 * @license
 * Copyright (c) 2015 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class Gf extends jf(xr(Cr(mi))) {
  static get template() {
    return Vi`
      <style>
        :host {
          display: block;
        }

        :host([hidden]) {
          display: none;
        }
      </style>
      <span part="checkmark" aria-hidden="true"></span>
      <div part="content">
        <slot></slot>
      </div>
    `;
  }
  static get is() {
    return "vaadin-combo-box-item";
  }
}
Zt(Gf);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
let Zo = !1, qf = [], fc = [];
function Kf() {
  Zo = !0, requestAnimationFrame(function() {
    Zo = !1, Zf(qf), setTimeout(function() {
      Yf(fc);
    });
  });
}
function Zf(s) {
  for (; s.length; )
    pc(s.shift());
}
function Yf(s) {
  for (let n = 0, e = s.length; n < e; n++)
    pc(s.shift());
}
function pc(s) {
  const n = s[0], e = s[1], t = s[2];
  try {
    e.apply(n, t);
  } catch (i) {
    setTimeout(() => {
      throw i;
    });
  }
}
function Xf(s, n, e) {
  Zo || Kf(), fc.push([s, n, e]);
}
/**
 * @license
 * Copyright (c) 2017 Anton Korzunov
 * SPDX-License-Identifier: MIT
 */
let ki = /* @__PURE__ */ new WeakMap(), $r = /* @__PURE__ */ new WeakMap(), en = {}, Eo = 0;
const Za = (s) => s && s.nodeType === Node.ELEMENT_NODE, Po = (...s) => {
  console.error(`Error: ${s.join(" ")}. Skip setting aria-hidden.`);
}, Qf = (s, n) => Za(s) ? n.map((e) => {
  if (!Za(e))
    return Po(e, "is not a valid element"), null;
  let t = e;
  for (; t && t !== s; ) {
    if (s.contains(t))
      return e;
    t = t.getRootNode().host;
  }
  return Po(e, "is not contained inside", s), null;
}).filter((e) => !!e) : (Po(s, "is not a valid element"), []), Jf = (s, n, e, t) => {
  const i = Qf(n, Array.isArray(s) ? s : [s]);
  en[e] || (en[e] = /* @__PURE__ */ new WeakMap());
  const r = en[e], o = [], a = /* @__PURE__ */ new Set(), c = new Set(i), u = (f) => {
    if (!f || a.has(f))
      return;
    a.add(f);
    const g = f.assignedSlot;
    g && u(g), u(f.parentNode || f.host);
  };
  i.forEach(u);
  const h = (f) => {
    if (!f || c.has(f))
      return;
    const g = f.shadowRoot;
    (g ? [...f.children, ...g.children] : [...f.children]).forEach((C) => {
      if (!["template", "script", "style"].includes(C.localName))
        if (a.has(C))
          h(C);
        else {
          const E = C.getAttribute(t), R = E !== null && E !== "false", D = (ki.get(C) || 0) + 1, U = (r.get(C) || 0) + 1;
          ki.set(C, D), r.set(C, U), o.push(C), D === 1 && R && $r.set(C, !0), U === 1 && C.setAttribute(e, "true"), R || C.setAttribute(t, "true");
        }
    });
  };
  return h(n), a.clear(), Eo += 1, () => {
    o.forEach((f) => {
      const g = ki.get(f) - 1, x = r.get(f) - 1;
      ki.set(f, g), r.set(f, x), g || ($r.has(f) ? $r.delete(f) : f.removeAttribute(t)), x || f.removeAttribute(e);
    }), Eo -= 1, Eo || (ki = /* @__PURE__ */ new WeakMap(), ki = /* @__PURE__ */ new WeakMap(), $r = /* @__PURE__ */ new WeakMap(), en = {});
  };
}, $f = (s, n = document.body, e = "data-aria-hidden") => {
  const t = Array.from(Array.isArray(s) ? s : [s]);
  return n && t.push(...Array.from(n.querySelectorAll("[aria-live]"))), Jf(t, n, e, "aria-hidden");
};
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class ep {
  /**
   * @param {HTMLElement} host
   */
  constructor(n, e) {
    this.host = n, this.callback = typeof e == "function" ? e : () => n;
  }
  /**
   * Make the controller host modal by hiding other elements from screen readers
   * using `aria-hidden` attribute (can be replaced with `inert` in the future).
   *
   * The method name is chosen to align with the one provided by native `<dialog>`:
   * https://developer.mozilla.org/en-US/docs/Web/API/HTMLDialogElement/showModal
   */
  showModal() {
    const n = this.callback();
    this.__showOthers = $f(n);
  }
  /**
   * Remove `aria-hidden` from other elements unless there are any other
   * controller hosts on the page activated by using `showModal()` call.
   */
  close() {
    this.__showOthers && (this.__showOthers(), this.__showOthers = null);
  }
}
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const tp = (s) => class extends Tr(s) {
  static get properties() {
    return {
      /**
       * When true, opening the overlay moves focus to the first focusable child,
       * or to the overlay part with tabindex if there are no focusable children.
       * @attr {boolean} focus-trap
       */
      focusTrap: {
        type: Boolean,
        value: !1
      },
      /**
       * Set to true to enable restoring of focus when overlay is closed.
       * @attr {boolean} restore-focus-on-close
       */
      restoreFocusOnClose: {
        type: Boolean,
        value: !1
      },
      /**
       * Set to specify the element which should be focused on overlay close,
       * if `restoreFocusOnClose` is set to true.
       * @type {HTMLElement}
       */
      restoreFocusNode: {
        type: HTMLElement
      }
    };
  }
  constructor() {
    super(), this.__ariaModalController = new ep(this), this.__focusTrapController = new xf(this), this.__focusRestorationController = new Cf();
  }
  /** @protected */
  ready() {
    super.ready(), this.addController(this.__ariaModalController), this.addController(this.__focusTrapController), this.addController(this.__focusRestorationController);
  }
  /**
   * Release focus and restore focus after the overlay is closed.
   *
   * @protected
   */
  _resetFocus() {
    if (this.focusTrap && (this.__ariaModalController.close(), this.__focusTrapController.releaseFocus()), this.restoreFocusOnClose && this._shouldRestoreFocus()) {
      const e = !On();
      this.__focusRestorationController.restoreFocus({ preventScroll: e });
    }
  }
  /**
   * Save the previously focused node when the overlay starts to open.
   *
   * @protected
   */
  _saveFocus() {
    this.restoreFocusOnClose && this.__focusRestorationController.saveFocus(this.restoreFocusNode);
  }
  /**
   * Trap focus within the overlay after opening has completed.
   *
   * @protected
   */
  _trapFocus() {
    this.focusTrap && (this.__ariaModalController.showModal(), this.__focusTrapController.trapFocus(this.$.overlay));
  }
  /**
   * Returns true if focus is still inside the overlay or on the body element,
   * otherwise false.
   *
   * Focus shouldn't be restored if it's been moved elsewhere by another
   * component or as a result of a user interaction e.g. the user clicked
   * on a button outside the overlay while the overlay was open.
   *
   * @protected
   * @return {boolean}
   */
  _shouldRestoreFocus() {
    const e = Uo();
    return e === document.body || this._deepContains(e);
  }
  /**
   * Returns true if the overlay contains the given node,
   * including those within shadow DOM trees.
   *
   * @param {Node} node
   * @return {boolean}
   * @protected
   */
  _deepContains(e) {
    if (this.contains(e))
      return !0;
    let t = e;
    const i = e.ownerDocument;
    for (; t && t !== i && t !== this; )
      t = t.parentNode || t.host;
    return t === this;
  }
};
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const an = () => Array.from(document.body.children).filter((s) => s instanceof HTMLElement && s._hasOverlayStackMixin && !s.hasAttribute("closing")).sort((s, n) => s.__zIndex - n.__zIndex || 0), ip = (s) => s === an().pop(), rp = (s) => class extends s {
  constructor() {
    super(), this._hasOverlayStackMixin = !0;
  }
  /**
   * Returns true if this is the last one in the opened overlays stack.
   *
   * @return {boolean}
   * @protected
   */
  get _last() {
    return ip(this);
  }
  /**
   * Brings the overlay as visually the frontmost one.
   */
  bringToFront() {
    let e = "";
    const t = an().filter((i) => i !== this).pop();
    t && (e = t.__zIndex + 1), this.style.zIndex = e, this.__zIndex = e || parseFloat(getComputedStyle(this).zIndex);
  }
  /** @protected */
  _enterModalState() {
    document.body.style.pointerEvents !== "none" && (this._previousDocumentPointerEvents = document.body.style.pointerEvents, document.body.style.pointerEvents = "none"), an().forEach((e) => {
      e !== this && e.$.overlay && (e.$.overlay.style.pointerEvents = "none");
    });
  }
  /** @protected */
  _exitModalState() {
    this._previousDocumentPointerEvents !== void 0 && (document.body.style.pointerEvents = this._previousDocumentPointerEvents, delete this._previousDocumentPointerEvents);
    const e = an();
    let t;
    for (; (t = e.pop()) && !(t !== this && (t.$.overlay && t.$.overlay.style.removeProperty("pointer-events"), !t.modeless)); )
      ;
  }
};
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const np = (s) => class extends tp(rp(s)) {
  static get properties() {
    return {
      /**
       * When true, the overlay is visible and attached to body.
       */
      opened: {
        type: Boolean,
        notify: !0,
        observer: "_openedChanged",
        reflectToAttribute: !0
      },
      /**
       * Owner element passed with renderer function
       * @type {HTMLElement}
       */
      owner: {
        type: Object
      },
      /**
       * Object with properties that is passed to `renderer` function
       */
      model: {
        type: Object
      },
      /**
       * Custom function for rendering the content of the overlay.
       * Receives three arguments:
       *
       * - `root` The root container DOM element. Append your content to it.
       * - `owner` The host element of the renderer function.
       * - `model` The object with the properties related with rendering.
       * @type {OverlayRenderer | null | undefined}
       */
      renderer: {
        type: Object
      },
      /**
       * When true the overlay won't disable the main content, showing
       * it doesn't change the functionality of the user interface.
       * @type {boolean}
       */
      modeless: {
        type: Boolean,
        value: !1,
        reflectToAttribute: !0,
        observer: "_modelessChanged"
      },
      /**
       * When set to true, the overlay is hidden. This also closes the overlay
       * immediately in case there is a closing animation in progress.
       * @type {boolean}
       */
      hidden: {
        type: Boolean,
        reflectToAttribute: !0,
        observer: "_hiddenChanged"
      },
      /**
       * When true the overlay has backdrop on top of content when opened.
       * @type {boolean}
       */
      withBackdrop: {
        type: Boolean,
        value: !1,
        reflectToAttribute: !0
      }
    };
  }
  static get observers() {
    return ["_rendererOrDataChanged(renderer, owner, model, opened)"];
  }
  constructor() {
    super(), this._boundMouseDownListener = this._mouseDownListener.bind(this), this._boundMouseUpListener = this._mouseUpListener.bind(this), this._boundOutsideClickListener = this._outsideClickListener.bind(this), this._boundKeydownListener = this._keydownListener.bind(this), Go && (this._boundIosResizeListener = () => this._detectIosNavbar());
  }
  /** @protected */
  ready() {
    super.ready(), this.addEventListener("click", () => {
    }), this.$.backdrop.addEventListener("click", () => {
    }), this.addEventListener("mouseup", () => {
      document.activeElement === document.body && this.$.overlay.getAttribute("tabindex") === "0" && this.$.overlay.focus();
    });
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback(), this._boundIosResizeListener && (this._detectIosNavbar(), window.addEventListener("resize", this._boundIosResizeListener));
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback(), this._boundIosResizeListener && window.removeEventListener("resize", this._boundIosResizeListener);
  }
  /**
   * Requests an update for the content of the overlay.
   * While performing the update, it invokes the renderer passed in the `renderer` property.
   *
   * It is not guaranteed that the update happens immediately (synchronously) after it is requested.
   */
  requestContentUpdate() {
    this.renderer && this.renderer.call(this.owner, this, this.owner, this.model);
  }
  /**
   * @param {Event=} sourceEvent
   */
  close(e) {
    const t = new CustomEvent("vaadin-overlay-close", {
      bubbles: !0,
      cancelable: !0,
      detail: { sourceEvent: e }
    });
    this.dispatchEvent(t), t.defaultPrevented || (this.opened = !1);
  }
  /** @private */
  _detectIosNavbar() {
    if (!this.opened)
      return;
    const e = window.innerHeight, i = window.innerWidth > e, r = document.documentElement.clientHeight;
    i && r > e ? this.style.setProperty("--vaadin-overlay-viewport-bottom", `${r - e}px`) : this.style.setProperty("--vaadin-overlay-viewport-bottom", "0");
  }
  /** @private */
  _addGlobalListeners() {
    document.addEventListener("mousedown", this._boundMouseDownListener), document.addEventListener("mouseup", this._boundMouseUpListener), document.documentElement.addEventListener("click", this._boundOutsideClickListener, !0);
  }
  /** @private */
  _removeGlobalListeners() {
    document.removeEventListener("mousedown", this._boundMouseDownListener), document.removeEventListener("mouseup", this._boundMouseUpListener), document.documentElement.removeEventListener("click", this._boundOutsideClickListener, !0);
  }
  /** @private */
  _rendererOrDataChanged(e, t, i, r) {
    const o = this._oldOwner !== t || this._oldModel !== i;
    this._oldModel = i, this._oldOwner = t;
    const a = this._oldRenderer !== e, c = this._oldRenderer !== void 0;
    this._oldRenderer = e;
    const u = this._oldOpened !== r;
    this._oldOpened = r, a && c && (this.innerHTML = "", delete this._$litPart$), r && e && (a || u || o) && this.requestContentUpdate();
  }
  /** @private */
  _modelessChanged(e) {
    e ? (this._removeGlobalListeners(), this._exitModalState()) : this.opened && (this._addGlobalListeners(), this._enterModalState());
  }
  /** @private */
  _openedChanged(e, t) {
    e ? (this._saveFocus(), this._animatedOpening(), Xf(this, () => {
      this._trapFocus();
      const i = new CustomEvent("vaadin-overlay-open", { bubbles: !0 });
      this.dispatchEvent(i);
    }), document.addEventListener("keydown", this._boundKeydownListener), this.modeless || this._addGlobalListeners()) : t && (this._resetFocus(), this._animatedClosing(), document.removeEventListener("keydown", this._boundKeydownListener), this.modeless || this._removeGlobalListeners());
  }
  /** @private */
  _hiddenChanged(e) {
    e && this.hasAttribute("closing") && this._flushAnimation("closing");
  }
  /**
   * @return {boolean}
   * @private
   */
  _shouldAnimate() {
    const e = getComputedStyle(this), t = e.getPropertyValue("animation-name");
    return !(e.getPropertyValue("display") === "none") && t && t !== "none";
  }
  /**
   * @param {string} type
   * @param {Function} callback
   * @private
   */
  _enqueueAnimation(e, t) {
    const i = `__${e}Handler`, r = (o) => {
      o && o.target !== this || (t(), this.removeEventListener("animationend", r), delete this[i]);
    };
    this[i] = r, this.addEventListener("animationend", r);
  }
  /**
   * @param {string} type
   * @protected
   */
  _flushAnimation(e) {
    const t = `__${e}Handler`;
    typeof this[t] == "function" && this[t]();
  }
  /** @private */
  _animatedOpening() {
    this.parentNode === document.body && this.hasAttribute("closing") && this._flushAnimation("closing"), this._attachOverlay(), this.modeless || this._enterModalState(), this.setAttribute("opening", ""), this._shouldAnimate() ? this._enqueueAnimation("opening", () => {
      this._finishOpening();
    }) : this._finishOpening();
  }
  /** @private */
  _attachOverlay() {
    this._placeholder = document.createComment("vaadin-overlay-placeholder"), this.parentNode.insertBefore(this._placeholder, this), document.body.appendChild(this), this.bringToFront();
  }
  /** @private */
  _finishOpening() {
    this.removeAttribute("opening");
  }
  /** @private */
  _finishClosing() {
    this._detachOverlay(), this.$.overlay.style.removeProperty("pointer-events"), this.removeAttribute("closing"), this.dispatchEvent(new CustomEvent("vaadin-overlay-closed"));
  }
  /** @private */
  _animatedClosing() {
    this.hasAttribute("opening") && this._flushAnimation("opening"), this._placeholder && (this._exitModalState(), this.setAttribute("closing", ""), this.dispatchEvent(new CustomEvent("vaadin-overlay-closing")), this._shouldAnimate() ? this._enqueueAnimation("closing", () => {
      this._finishClosing();
    }) : this._finishClosing());
  }
  /** @private */
  _detachOverlay() {
    this._placeholder.parentNode.insertBefore(this, this._placeholder), this._placeholder.parentNode.removeChild(this._placeholder);
  }
  /** @private */
  _mouseDownListener(e) {
    this._mouseDownInside = e.composedPath().indexOf(this.$.overlay) >= 0;
  }
  /** @private */
  _mouseUpListener(e) {
    this._mouseUpInside = e.composedPath().indexOf(this.$.overlay) >= 0;
  }
  /**
   * Whether to close the overlay on outside click or not.
   * Override this method to customize the closing logic.
   *
   * @param {Event} _event
   * @return {boolean}
   * @protected
   */
  _shouldCloseOnOutsideClick(e) {
    return this._last;
  }
  /**
   * Outside click listener used in capture phase to close the overlay before
   * propagating the event to the listener on the element that triggered it.
   * Otherwise, calling `open()` would result in closing and re-opening.
   *
   * @private
   */
  _outsideClickListener(e) {
    if (e.composedPath().includes(this.$.overlay) || this._mouseDownInside || this._mouseUpInside) {
      this._mouseDownInside = !1, this._mouseUpInside = !1;
      return;
    }
    if (!this._shouldCloseOnOutsideClick(e))
      return;
    const t = new CustomEvent("vaadin-overlay-outside-click", {
      bubbles: !0,
      cancelable: !0,
      detail: { sourceEvent: e }
    });
    this.dispatchEvent(t), this.opened && !t.defaultPrevented && this.close(e);
  }
  /**
   * Listener used to close whe overlay on Escape press, if it is the last one.
   * @private
   */
  _keydownListener(e) {
    if (this._last && !(this.modeless && !e.composedPath().includes(this.$.overlay)) && e.key === "Escape") {
      const t = new CustomEvent("vaadin-overlay-escape-press", {
        bubbles: !0,
        cancelable: !0,
        detail: { sourceEvent: e }
      });
      this.dispatchEvent(t), this.opened && !t.defaultPrevented && this.close(e);
    }
  }
};
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const op = ke`
  :host {
    z-index: 200;
    position: fixed;

    /* Despite of what the names say, <vaadin-overlay> is just a container
          for position/sizing/alignment. The actual overlay is the overlay part. */

    /* Default position constraints: the entire viewport. Note: themes can
          override this to introduce gaps between the overlay and the viewport. */
    inset: 0;
    bottom: var(--vaadin-overlay-viewport-bottom);

    /* Use flexbox alignment for the overlay part. */
    display: flex;
    flex-direction: column; /* makes dropdowns sizing easier */
    /* Align to center by default. */
    align-items: center;
    justify-content: center;

    /* Allow centering when max-width/max-height applies. */
    margin: auto;

    /* The host is not clickable, only the overlay part is. */
    pointer-events: none;

    /* Remove tap highlight on touch devices. */
    -webkit-tap-highlight-color: transparent;

    /* CSS API for host */
    --vaadin-overlay-viewport-bottom: 0;
  }

  :host([hidden]),
  :host(:not([opened]):not([closing])),
  :host(:not([opened]):not([closing])) [part='overlay'] {
    display: none !important;
  }

  [part='overlay'] {
    -webkit-overflow-scrolling: touch;
    overflow: auto;
    pointer-events: auto;

    /* Prevent overflowing the host */
    max-width: 100%;
    box-sizing: border-box;

    -webkit-tap-highlight-color: initial; /* reenable tap highlight inside */
  }

  [part='backdrop'] {
    z-index: -1;
    content: '';
    background: rgba(0, 0, 0, 0.5);
    position: fixed;
    inset: 0;
    pointer-events: auto;
  }
`;
/**
 * @license
 * Copyright (c) 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function sp(s, n) {
  let e = null;
  const t = document.documentElement;
  function i() {
    e && e.disconnect(), e = null;
  }
  function r(o = !1, a = 1) {
    i();
    const { left: c, top: u, width: h, height: f } = s.getBoundingClientRect();
    if (o || n(), !h || !f)
      return;
    const g = Math.floor(u), x = Math.floor(t.clientWidth - (c + h)), C = Math.floor(t.clientHeight - (u + f)), E = Math.floor(c), D = {
      rootMargin: `${-g}px ${-x}px ${-C}px ${-E}px`,
      threshold: Math.max(0, Math.min(1, a)) || 1
    };
    let U = !0;
    function Z(ce) {
      let re = ce[0].intersectionRatio;
      if (re !== a) {
        if (!U)
          return r();
        re === 0 && (re = 1e-7), r(!1, re);
      }
      U = !1;
    }
    e = new IntersectionObserver(Z, D), e.observe(s);
  }
  return r(!0), i;
}
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const So = {
  start: "top",
  end: "bottom"
}, ko = {
  start: "left",
  end: "right"
}, Ya = new ResizeObserver((s) => {
  setTimeout(() => {
    s.forEach((n) => {
      n.target.__overlay && n.target.__overlay._updatePosition();
    });
  });
}), ap = (s) => class extends s {
  static get properties() {
    return {
      /**
       * The element next to which this overlay should be aligned.
       * The position of the overlay relative to the positionTarget can be adjusted
       * with properties `horizontalAlign`, `verticalAlign`, `noHorizontalOverlap`
       * and `noVerticalOverlap`.
       */
      positionTarget: {
        type: Object,
        value: null,
        sync: !0
      },
      /**
       * When `positionTarget` is set, this property defines whether to align the overlay's
       * left or right side to the target element by default.
       * Possible values are `start` and `end`.
       * RTL is taken into account when interpreting the value.
       * The overlay is automatically flipped to the opposite side when it doesn't fit into
       * the default side defined by this property.
       *
       * @attr {start|end} horizontal-align
       */
      horizontalAlign: {
        type: String,
        value: "start",
        sync: !0
      },
      /**
       * When `positionTarget` is set, this property defines whether to align the overlay's
       * top or bottom side to the target element by default.
       * Possible values are `top` and `bottom`.
       * The overlay is automatically flipped to the opposite side when it doesn't fit into
       * the default side defined by this property.
       *
       * @attr {top|bottom} vertical-align
       */
      verticalAlign: {
        type: String,
        value: "top",
        sync: !0
      },
      /**
       * When `positionTarget` is set, this property defines whether the overlay should overlap
       * the target element in the x-axis, or be positioned right next to it.
       *
       * @attr {boolean} no-horizontal-overlap
       */
      noHorizontalOverlap: {
        type: Boolean,
        value: !1,
        sync: !0
      },
      /**
       * When `positionTarget` is set, this property defines whether the overlay should overlap
       * the target element in the y-axis, or be positioned right above/below it.
       *
       * @attr {boolean} no-vertical-overlap
       */
      noVerticalOverlap: {
        type: Boolean,
        value: !1,
        sync: !0
      },
      /**
       * If the overlay content has no intrinsic height, this property can be used to set
       * the minimum vertical space (in pixels) required by the overlay. Setting a value to
       * the property effectively disables the content measurement in favor of using this
       * fixed value for determining the open direction.
       *
       * @attr {number} required-vertical-space
       */
      requiredVerticalSpace: {
        type: Number,
        value: 0,
        sync: !0
      }
    };
  }
  static get observers() {
    return [
      "__positionSettingsChanged(horizontalAlign, verticalAlign, noHorizontalOverlap, noVerticalOverlap, requiredVerticalSpace)",
      "__overlayOpenedChanged(opened, positionTarget)"
    ];
  }
  constructor() {
    super(), this.__onScroll = this.__onScroll.bind(this), this._updatePosition = this._updatePosition.bind(this);
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback(), this.opened && this.__addUpdatePositionEventListeners();
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback(), this.__removeUpdatePositionEventListeners();
  }
  /** @private */
  __addUpdatePositionEventListeners() {
    window.visualViewport.addEventListener("resize", this._updatePosition), window.visualViewport.addEventListener("scroll", this.__onScroll, !0), this.__positionTargetAncestorRootNodes = uh(this.positionTarget), this.__positionTargetAncestorRootNodes.forEach((e) => {
      e.addEventListener("scroll", this.__onScroll, !0);
    }), this.positionTarget && (this.__observePositionTargetMove = sp(this.positionTarget, () => {
      this._updatePosition();
    }));
  }
  /** @private */
  __removeUpdatePositionEventListeners() {
    window.visualViewport.removeEventListener("resize", this._updatePosition), window.visualViewport.removeEventListener("scroll", this.__onScroll, !0), this.__positionTargetAncestorRootNodes && (this.__positionTargetAncestorRootNodes.forEach((e) => {
      e.removeEventListener("scroll", this.__onScroll, !0);
    }), this.__positionTargetAncestorRootNodes = null), this.__observePositionTargetMove && (this.__observePositionTargetMove(), this.__observePositionTargetMove = null);
  }
  /** @private */
  __overlayOpenedChanged(e, t) {
    if (this.__removeUpdatePositionEventListeners(), t && (t.__overlay = null, Ya.unobserve(t), e && (this.__addUpdatePositionEventListeners(), t.__overlay = this, Ya.observe(t))), e) {
      const i = getComputedStyle(this);
      this.__margins || (this.__margins = {}, ["top", "bottom", "left", "right"].forEach((r) => {
        this.__margins[r] = parseInt(i[r], 10);
      })), this._updatePosition(), requestAnimationFrame(() => this._updatePosition());
    }
  }
  __positionSettingsChanged() {
    this._updatePosition();
  }
  /** @private */
  __onScroll(e) {
    e.target instanceof Node && this.contains(e.target) || this._updatePosition();
  }
  _updatePosition() {
    if (!this.positionTarget || !this.opened || !this.__margins)
      return;
    const e = this.positionTarget.getBoundingClientRect();
    if (e.width === 0 && e.height === 0 && this.opened) {
      this.opened = !1;
      return;
    }
    const t = this.__shouldAlignStartVertically(e);
    this.style.justifyContent = t ? "flex-start" : "flex-end";
    const i = this.__isRTL, r = this.__shouldAlignStartHorizontally(e, i), o = !i && r || i && !r;
    this.style.alignItems = o ? "flex-start" : "flex-end";
    const a = this.getBoundingClientRect(), c = this.__calculatePositionInOneDimension(
      e,
      a,
      this.noVerticalOverlap,
      So,
      this,
      t
    ), u = this.__calculatePositionInOneDimension(
      e,
      a,
      this.noHorizontalOverlap,
      ko,
      this,
      r
    );
    Object.assign(this.style, c, u), this.toggleAttribute("bottom-aligned", !t), this.toggleAttribute("top-aligned", t), this.toggleAttribute("end-aligned", !o), this.toggleAttribute("start-aligned", o);
  }
  __shouldAlignStartHorizontally(e, t) {
    const i = Math.max(this.__oldContentWidth || 0, this.$.overlay.offsetWidth);
    this.__oldContentWidth = this.$.overlay.offsetWidth;
    const r = Math.min(window.innerWidth, document.documentElement.clientWidth), o = !t && this.horizontalAlign === "start" || t && this.horizontalAlign === "end";
    return this.__shouldAlignStart(
      e,
      i,
      r,
      this.__margins,
      o,
      this.noHorizontalOverlap,
      ko
    );
  }
  __shouldAlignStartVertically(e) {
    const t = this.requiredVerticalSpace || Math.max(this.__oldContentHeight || 0, this.$.overlay.offsetHeight);
    this.__oldContentHeight = this.$.overlay.offsetHeight;
    const i = Math.min(window.innerHeight, document.documentElement.clientHeight), r = this.verticalAlign === "top";
    return this.__shouldAlignStart(
      e,
      t,
      i,
      this.__margins,
      r,
      this.noVerticalOverlap,
      So
    );
  }
  // eslint-disable-next-line @typescript-eslint/max-params
  __shouldAlignStart(e, t, i, r, o, a, c) {
    const u = i - e[a ? c.end : c.start] - r[c.end], h = e[a ? c.start : c.end] - r[c.start], f = o ? u : h, x = f > (o ? h : u) || f > t;
    return o === x;
  }
  /**
   * Returns an adjusted value after resizing the browser window,
   * to avoid wrong calculations when e.g. previously set `bottom`
   * CSS property value is larger than the updated viewport height.
   * See https://github.com/vaadin/web-components/issues/4604
   */
  __adjustBottomProperty(e, t, i) {
    let r;
    if (e === t.end) {
      if (t.end === So.end) {
        const o = Math.min(window.innerHeight, document.documentElement.clientHeight);
        if (i > o && this.__oldViewportHeight) {
          const a = this.__oldViewportHeight - o;
          r = i - a;
        }
        this.__oldViewportHeight = o;
      }
      if (t.end === ko.end) {
        const o = Math.min(window.innerWidth, document.documentElement.clientWidth);
        if (i > o && this.__oldViewportWidth) {
          const a = this.__oldViewportWidth - o;
          r = i - a;
        }
        this.__oldViewportWidth = o;
      }
    }
    return r;
  }
  /**
   * Returns an object with CSS position properties to set,
   * e.g. { top: "100px" }
   */
  // eslint-disable-next-line @typescript-eslint/max-params
  __calculatePositionInOneDimension(e, t, i, r, o, a) {
    const c = a ? r.start : r.end, u = a ? r.end : r.start, h = parseFloat(o.style[c] || getComputedStyle(o)[c]), f = this.__adjustBottomProperty(c, r, h), g = t[a ? r.start : r.end] - e[i === a ? r.end : r.start], x = f ? `${f}px` : `${h + g * (a ? -1 : 1)}px`;
    return {
      [c]: x,
      [u]: ""
    };
  }
};
/**
 * @license
 * Copyright (c) 2015 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const lp = (s) => class extends ap(s) {
  static get observers() {
    return ["_setOverlayWidth(positionTarget, opened)"];
  }
  constructor() {
    super(), this.requiredVerticalSpace = 200;
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    const e = this._comboBox, t = e && e.getAttribute("dir");
    t && this.setAttribute("dir", t);
  }
  /**
   * Override method inherited from `Overlay`
   * to not close on position target click.
   *
   * @param {Event} event
   * @return {boolean}
   * @protected
   */
  _shouldCloseOnOutsideClick(e) {
    const t = e.composedPath();
    return !t.includes(this.positionTarget) && !t.includes(this);
  }
  /**
   * @protected
   * @override
   */
  _mouseDownListener(e) {
    super._mouseDownListener(e), this._shouldCloseOnOutsideClick(e) && !fs(e.composedPath()[0]) && e.preventDefault();
  }
  /** @protected */
  _updateOverlayWidth() {
    const e = this.localName;
    this.style.setProperty(`--_${e}-default-width`, `${this.positionTarget.clientWidth}px`);
    const t = getComputedStyle(this._comboBox).getPropertyValue(`--${e}-width`);
    t === "" ? this.style.removeProperty(`--${e}-width`) : this.style.setProperty(`--${e}-width`, t);
  }
  /** @private */
  _setOverlayWidth(e, t) {
    e && t && (this._updateOverlayWidth(), this._updatePosition());
  }
};
/**
 * @license
 * Copyright (c) 2015 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const cp = ke`
  #overlay {
    width: var(--vaadin-combo-box-overlay-width, var(--_vaadin-combo-box-overlay-default-width, auto));
  }

  [part='content'] {
    display: flex;
    flex-direction: column;
    height: 100%;
  }
`;
Qe("vaadin-combo-box-overlay", [op, cp], {
  moduleId: "vaadin-combo-box-overlay-styles"
});
class up extends lp(np(Cr(xr(mi)))) {
  static get is() {
    return "vaadin-combo-box-overlay";
  }
  static get template() {
    return Vi`
      <div id="backdrop" part="backdrop" hidden></div>
      <div part="overlay" id="overlay">
        <div part="loader"></div>
        <div part="content" id="content"><slot></slot></div>
      </div>
    `;
  }
}
Zt(up);
/**
 * @license
 * Copyright (c) 2015 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Ni = class {
  toString() {
    return "";
  }
};
/**
 * @license
 * Copyright (c) 2015 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const dp = (s) => class extends s {
  static get properties() {
    return {
      /**
       * A full set of items to filter the visible options from.
       * Set to an empty array when combo-box is not opened.
       */
      items: {
        type: Array,
        sync: !0,
        observer: "__itemsChanged"
      },
      /**
       * Index of an item that has focus outline and is scrolled into view.
       * The actual focus still remains in the input field.
       */
      focusedIndex: {
        type: Number,
        sync: !0,
        observer: "__focusedIndexChanged"
      },
      /**
       * Set to true while combo-box fetches new page from the data provider.
       */
      loading: {
        type: Boolean,
        sync: !0,
        observer: "__loadingChanged"
      },
      /**
       * Whether the combo-box is currently opened or not. If set to false,
       * calling `scrollIntoView` does not have any effect.
       */
      opened: {
        type: Boolean,
        sync: !0,
        observer: "__openedChanged"
      },
      /**
       * The selected item from the `items` array.
       */
      selectedItem: {
        type: Object,
        sync: !0,
        observer: "__selectedItemChanged"
      },
      /**
       * A function used to generate CSS class names for dropdown
       * items based on the item. The return value should be the
       * generated class name as a string, or multiple class names
       * separated by whitespace characters.
       */
      itemClassNameGenerator: {
        type: Object,
        observer: "__itemClassNameGeneratorChanged"
      },
      /**
       * Path for the id of the item, used to detect whether the item is selected.
       */
      itemIdPath: {
        type: String
      },
      /**
       * Reference to the owner (combo-box owner), used by the item elements.
       */
      owner: {
        type: Object
      },
      /**
       * Function used to set a label for every combo-box item.
       */
      getItemLabel: {
        type: Object
      },
      /**
       * Function used to render the content of every combo-box item.
       */
      renderer: {
        type: Object,
        sync: !0,
        observer: "__rendererChanged"
      },
      /**
       * Used to propagate the `theme` attribute from the host element.
       */
      theme: {
        type: String
      }
    };
  }
  constructor() {
    super(), this.__boundOnItemClick = this.__onItemClick.bind(this);
  }
  /** @private */
  get _viewportTotalPaddingBottom() {
    if (this._cachedViewportTotalPaddingBottom === void 0) {
      const e = window.getComputedStyle(this.$.selector);
      this._cachedViewportTotalPaddingBottom = [e.paddingBottom, e.borderBottomWidth].map((t) => parseInt(t, 10)).reduce((t, i) => t + i);
    }
    return this._cachedViewportTotalPaddingBottom;
  }
  /** @protected */
  ready() {
    super.ready(), this.setAttribute("role", "listbox"), this.id = `${this.localName}-${Zl()}`, this.__hostTagName = this.constructor.is.replace("-scroller", ""), this.addEventListener("click", (e) => e.stopPropagation()), this.__patchWheelOverScrolling();
  }
  /**
   * Updates the virtualizer's size and items.
   */
  requestContentUpdate() {
    this.__virtualizer && (this.items && (this.__virtualizer.size = this.items.length), this.opened && this.__virtualizer.update());
  }
  /**
   * Scrolls an item at given index into view and adjusts `scrollTop`
   * so that the element gets fully visible on Arrow Down key press.
   * @param {number} index
   */
  scrollIntoView(e) {
    if (!this.__virtualizer || !(this.opened && e >= 0))
      return;
    const t = this._visibleItemsCount();
    let i = e;
    e > this.__virtualizer.lastVisibleIndex - 1 ? (this.__virtualizer.scrollToIndex(e), i = e - t + 1) : e > this.__virtualizer.firstVisibleIndex && (i = this.__virtualizer.firstVisibleIndex), this.__virtualizer.scrollToIndex(Math.max(0, i));
    const r = [...this.children].find(
      (u) => !u.hidden && u.index === this.__virtualizer.lastVisibleIndex
    );
    if (!r || e !== r.index)
      return;
    const o = r.getBoundingClientRect(), a = this.getBoundingClientRect(), c = o.bottom - a.bottom + this._viewportTotalPaddingBottom;
    c > 0 && (this.scrollTop += c);
  }
  /**
   * @param {string | object} item
   * @param {string | object} selectedItem
   * @param {string} itemIdPath
   * @protected
   */
  _isItemSelected(e, t, i) {
    return e instanceof Ni ? !1 : i && e !== void 0 && t !== void 0 ? pi(i, e) === pi(i, t) : e === t;
  }
  /** @private */
  __initVirtualizer() {
    this.__virtualizer = new Ql({
      createElements: this.__createElements.bind(this),
      updateElement: this._updateElement.bind(this),
      elementsContainer: this,
      scrollTarget: this,
      scrollContainer: this.$.selector,
      reorderElements: !0
    });
  }
  /** @private */
  __itemsChanged(e) {
    e && this.__virtualizer && this.requestContentUpdate();
  }
  /** @private */
  __loadingChanged() {
    this.requestContentUpdate();
  }
  /** @private */
  __openedChanged(e) {
    e && (this.__virtualizer || this.__initVirtualizer(), this.requestContentUpdate());
  }
  /** @private */
  __selectedItemChanged() {
    this.requestContentUpdate();
  }
  /** @private */
  __itemClassNameGeneratorChanged(e, t) {
    (e || t) && this.requestContentUpdate();
  }
  /** @private */
  __focusedIndexChanged(e, t) {
    e !== t && this.requestContentUpdate(), e >= 0 && !this.loading && this.scrollIntoView(e);
  }
  /** @private */
  __rendererChanged(e, t) {
    (e || t) && this.requestContentUpdate();
  }
  /** @private */
  __createElements(e) {
    return [...Array(e)].map(() => {
      const t = document.createElement(`${this.__hostTagName}-item`);
      return t.addEventListener("click", this.__boundOnItemClick), t.tabIndex = "-1", t.style.width = "100%", t;
    });
  }
  /**
   * @param {HTMLElement} el
   * @param {number} index
   * @protected
   */
  _updateElement(e, t) {
    const i = this.items[t], r = this.focusedIndex, o = this._isItemSelected(i, this.selectedItem, this.itemIdPath);
    e.setProperties({
      item: i,
      index: t,
      label: this.getItemLabel(i),
      selected: o,
      renderer: this.renderer,
      focused: !this.loading && r === t
    }), typeof this.itemClassNameGenerator == "function" ? e.className = this.itemClassNameGenerator(i) : e.className !== "" && (e.className = ""), e.performUpdate && !e.hasUpdated && e.performUpdate(), e.id = `${this.__hostTagName}-item-${t}`, e.setAttribute("role", t !== void 0 ? "option" : !1), e.setAttribute("aria-selected", o.toString()), e.setAttribute("aria-posinset", t + 1), e.setAttribute("aria-setsize", this.items.length), this.theme ? e.setAttribute("theme", this.theme) : e.removeAttribute("theme"), i instanceof Ni && this.__requestItemByIndex(t);
  }
  /** @private */
  __onItemClick(e) {
    this.dispatchEvent(new CustomEvent("selection-changed", { detail: { item: e.currentTarget.item } }));
  }
  /**
   * We want to prevent the kinetic scrolling energy from being transferred from the overlay contents over to the parent.
   * Further improvement ideas: after the contents have been scrolled to the top or bottom and scrolling has stopped, it could allow
   * scrolling the parent similarly to touch scrolling.
   * @private
   */
  __patchWheelOverScrolling() {
    this.$.selector.addEventListener("wheel", (e) => {
      const t = this.scrollTop === 0, i = this.scrollHeight - this.scrollTop - this.clientHeight <= 1;
      (t && e.deltaY < 0 || i && e.deltaY > 0) && e.preventDefault();
    });
  }
  /**
   * Dispatches an `index-requested` event for the given index to notify
   * the data provider that it should start loading the page containing the requested index.
   *
   * The event is dispatched asynchronously to prevent an immediate page request and therefore
   * a possible infinite recursion in case the data provider implements page request cancelation logic
   * by invoking data provider page callbacks with an empty array.
   * The infinite recursion may occur otherwise since invoking a data provider page callback with an empty array
   * triggers a synchronous scroller update and, if the callback corresponds to the currently visible page,
   * the scroller will synchronously request the page again which may lead to looping in the end.
   * That was the case for the Flow counterpart:
   * https://github.com/vaadin/flow-components/issues/3553#issuecomment-1239344828
   * @private
   */
  __requestItemByIndex(e) {
    requestAnimationFrame(() => {
      this.dispatchEvent(
        new CustomEvent("index-requested", {
          detail: {
            index: e
          }
        })
      );
    });
  }
  /** @private */
  _visibleItemsCount() {
    return this.__virtualizer.scrollToIndex(this.__virtualizer.firstVisibleIndex), this.__virtualizer.size > 0 ? this.__virtualizer.lastVisibleIndex - this.__virtualizer.firstVisibleIndex + 1 : 0;
  }
};
/**
 * @license
 * Copyright (c) 2015 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class hp extends dp(mi) {
  static get is() {
    return "vaadin-combo-box-scroller";
  }
  static get template() {
    return Vi`
      <style>
        :host {
          display: block;
          min-height: 1px;
          overflow: auto;

          /* Fixes item background from getting on top of scrollbars on Safari */
          transform: translate3d(0, 0, 0);

          /* Enable momentum scrolling on iOS */
          -webkit-overflow-scrolling: touch;

          /* Fixes scrollbar disappearing when 'Show scroll bars: Always' enabled in Safari */
          box-shadow: 0 0 0 white;
        }

        #selector {
          border-width: var(--_vaadin-combo-box-items-container-border-width);
          border-style: var(--_vaadin-combo-box-items-container-border-style);
          border-color: var(--_vaadin-combo-box-items-container-border-color, transparent);
          position: relative;
        }
      </style>
      <div id="selector">
        <slot></slot>
      </div>
    `;
  }
}
Zt(hp);
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Ro = /* @__PURE__ */ new WeakMap();
function fp(s) {
  return Ro.has(s) || Ro.set(s, /* @__PURE__ */ new Set()), Ro.get(s);
}
function pp(s, n) {
  const e = document.createElement("style");
  e.textContent = s, n === document ? document.head.appendChild(e) : n.insertBefore(e, n.firstChild);
}
const gp = rt(
  (s) => class extends s {
    /**
     * List of styles to insert into root.
     * @protected
     */
    get slotStyles() {
      return {};
    }
    /** @protected */
    connectedCallback() {
      super.connectedCallback(), this.__applySlotStyles();
    }
    /** @private */
    __applySlotStyles() {
      const e = this.getRootNode(), t = fp(e);
      this.slotStyles.forEach((i) => {
        t.has(i) || (pp(i, e), t.add(i));
      });
    }
  }
);
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Ts = rt(
  (s) => class extends s {
    static get properties() {
      return {
        /**
         * A reference to the input element controlled by the mixin.
         * Any component implementing this mixin is expected to provide it
         * by using `this._setInputElement(input)` Polymer API.
         *
         * A typical case is using `InputController` that does this automatically.
         * However, the input element does not have to always be native <input>:
         * as an example, <vaadin-combo-box-light> accepts other components.
         *
         * @protected
         * @type {!HTMLElement}
         */
        inputElement: {
          type: Object,
          readOnly: !0,
          observer: "_inputElementChanged"
        },
        /**
         * String used to define input type.
         * @protected
         */
        type: {
          type: String,
          readOnly: !0
        },
        /**
         * The value of the field.
         */
        value: {
          type: String,
          value: "",
          observer: "_valueChanged",
          notify: !0,
          sync: !0
        },
        /**
         * Whether the input element has a non-empty value.
         *
         * @protected
         */
        _hasInputValue: {
          type: Boolean,
          value: !1,
          observer: "_hasInputValueChanged"
        }
      };
    }
    constructor() {
      super(), this._boundOnInput = this.__onInput.bind(this), this._boundOnChange = this._onChange.bind(this);
    }
    /**
     * Indicates whether the value is different from the default one.
     * Override if the `value` property has a type other than `string`.
     *
     * @protected
     */
    get _hasValue() {
      return this.value != null && this.value !== "";
    }
    /**
     * A property for accessing the input element's value.
     *
     * Override this getter if the property is different from the default `value` one.
     *
     * @protected
     * @return {string}
     */
    get _inputElementValueProperty() {
      return "value";
    }
    /**
     * The input element's value.
     *
     * @protected
     * @return {string}
     */
    get _inputElementValue() {
      return this.inputElement ? this.inputElement[this._inputElementValueProperty] : void 0;
    }
    /**
     * The input element's value.
     *
     * @protected
     */
    set _inputElementValue(e) {
      this.inputElement && (this.inputElement[this._inputElementValueProperty] = e);
    }
    /**
     * Clear the value of the field.
     */
    clear() {
      this._hasInputValue = !1, this.value = "", this._inputElementValue = "";
    }
    /**
     * Add event listeners to the input element instance.
     * Override this method to add custom listeners.
     * @param {!HTMLElement} input
     * @protected
     */
    _addInputListeners(e) {
      e.addEventListener("input", this._boundOnInput), e.addEventListener("change", this._boundOnChange);
    }
    /**
     * Remove event listeners from the input element instance.
     * @param {!HTMLElement} input
     * @protected
     */
    _removeInputListeners(e) {
      e.removeEventListener("input", this._boundOnInput), e.removeEventListener("change", this._boundOnChange);
    }
    /**
     * A method to forward the value property set on the field
     * programmatically back to the input element value.
     * Override this method to perform additional checks,
     * for example to skip this in certain conditions.
     * @param {string} value
     * @protected
     */
    _forwardInputValue(e) {
      this.inputElement && (this._inputElementValue = e ?? "");
    }
    /**
     * @param {HTMLElement | undefined} input
     * @param {HTMLElement | undefined} oldInput
     * @protected
     */
    _inputElementChanged(e, t) {
      e ? this._addInputListeners(e) : t && this._removeInputListeners(t);
    }
    /**
     * Observer to notify about the change of private property.
     *
     * @private
     */
    _hasInputValueChanged(e, t) {
      (e || t) && this.dispatchEvent(new CustomEvent("has-input-value-changed"));
    }
    /**
     * An input event listener used to update `_hasInputValue` property.
     * Do not override this method.
     *
     * @param {Event} event
     * @private
     */
    __onInput(e) {
      this._setHasInputValue(e), this._onInput(e);
    }
    /**
     * An input event listener used to update the field value.
     *
     * @param {Event} event
     * @protected
     */
    _onInput(e) {
      const t = e.composedPath()[0];
      this.__userInput = e.isTrusted, this.value = t.value, this.__userInput = !1;
    }
    /**
     * A change event listener.
     * Override this method with an actual implementation.
     * @param {Event} _event
     * @protected
     */
    _onChange(e) {
    }
    /**
     * Toggle the has-value attribute based on the value property.
     *
     * @param {boolean} hasValue
     * @protected
     */
    _toggleHasValue(e) {
      this.toggleAttribute("has-value", e);
    }
    /**
     * Observer called when a value property changes.
     * @param {string | undefined} newVal
     * @param {string | undefined} oldVal
     * @protected
     */
    _valueChanged(e, t) {
      this._toggleHasValue(this._hasValue), !(e === "" && t === void 0) && (this.__userInput || this._forwardInputValue(e));
    }
    /**
     * Sets the `_hasInputValue` property based on the `input` event.
     *
     * @param {InputEvent} event
     * @protected
     */
    _setHasInputValue(e) {
      const t = e.composedPath()[0];
      this._hasInputValue = t.value.length > 0;
    }
  }
);
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const mp = (s) => class extends Ts(ys(s)) {
  static get properties() {
    return {
      /**
       * Set to true to display the clear icon which clears the input.
       *
       * It is up to the component to choose where to place the clear icon:
       * in the Shadow DOM or in the light DOM. In any way, a reference to
       * the clear icon element should be provided via the `clearElement` getter.
       *
       * @attr {boolean} clear-button-visible
       */
      clearButtonVisible: {
        type: Boolean,
        reflectToAttribute: !0,
        value: !1
      }
    };
  }
  /**
   * Any element extending this mixin is required to implement this getter.
   * It returns the reference to the clear button element.
   *
   * @protected
   * @return {Element | null | undefined}
   */
  get clearElement() {
    return console.warn(`Please implement the 'clearElement' property in <${this.localName}>`), null;
  }
  /** @protected */
  ready() {
    super.ready(), this.clearElement && (this.clearElement.addEventListener("mousedown", (e) => this._onClearButtonMouseDown(e)), this.clearElement.addEventListener("click", (e) => this._onClearButtonClick(e)));
  }
  /**
   * @param {Event} event
   * @protected
   */
  _onClearButtonClick(e) {
    e.preventDefault(), this._onClearAction();
  }
  /**
   * @param {MouseEvent} event
   * @protected
   */
  _onClearButtonMouseDown(e) {
    e.preventDefault(), br || this.inputElement.focus();
  }
  /**
   * Override an event listener inherited from `KeydownMixin` to clear on Esc.
   * Components that extend this mixin can prevent this behavior by overriding
   * this method without calling `super._onEscape` to provide custom logic.
   *
   * @param {KeyboardEvent} event
   * @protected
   * @override
   */
  _onEscape(e) {
    super._onEscape(e), this.clearButtonVisible && this.value && (e.stopPropagation(), this._onClearAction());
  }
  /**
   * Clears the value and dispatches `input` and `change` events
   * on the input element. This method should be called
   * when the clear action originates from the user.
   *
   * @protected
   */
  _onClearAction() {
    this._inputElementValue = "", this.inputElement.dispatchEvent(new Event("input", { bubbles: !0, composed: !0 })), this.inputElement.dispatchEvent(new Event("change", { bubbles: !0 }));
  }
};
/**
 * @license
 * Copyright (c) 2022 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class Es extends ps {
  constructor(n, e, t, i = {}) {
    super(n, e, t, { ...i, useUniqueId: !0 });
  }
  /**
   * Override to initialize the newly added custom node.
   *
   * @param {Node} node
   * @protected
   * @override
   */
  initCustomNode(n) {
    this.__updateNodeId(n), this.__notifyChange(n);
  }
  /**
   * Override to notify the controller host about removal of
   * the custom node, and to apply the default one if needed.
   *
   * @param {Node} _node
   * @protected
   * @override
   */
  teardownNode(n) {
    const e = this.getSlotChild();
    e && e !== this.defaultNode ? this.__notifyChange(e) : (this.restoreDefaultNode(), this.updateDefaultNode(this.node));
  }
  /**
   * Override method inherited from `SlotMixin`
   * to set ID attribute on the default node.
   *
   * @return {Node}
   * @protected
   * @override
   */
  attachDefaultNode() {
    const n = super.attachDefaultNode();
    return n && this.__updateNodeId(n), n;
  }
  /**
   * Override to restore default node when a custom one is removed.
   *
   * @protected
   */
  restoreDefaultNode() {
  }
  /**
   * Override to update default node text on property change.
   *
   * @param {Node} node
   * @protected
   */
  updateDefaultNode(n) {
    this.__notifyChange(n);
  }
  /**
   * Setup the mutation observer on the node to update ID and notify host.
   * Node doesn't get observed automatically until this method is called.
   *
   * @param {Node} node
   * @protected
   */
  observeNode(n) {
    this.__nodeObserver && this.__nodeObserver.disconnect(), this.__nodeObserver = new MutationObserver((e) => {
      e.forEach((t) => {
        const i = t.target, r = i === this.node;
        t.type === "attributes" ? r && this.__updateNodeId(i) : (r || i.parentElement === this.node) && this.__notifyChange(this.node);
      });
    }), this.__nodeObserver.observe(n, {
      attributes: !0,
      attributeFilter: ["id"],
      childList: !0,
      subtree: !0,
      characterData: !0
    });
  }
  /**
   * Returns true if a node is an HTML element with children,
   * or is a defined custom element, or has non-empty text.
   *
   * @param {Node} node
   * @return {boolean}
   * @private
   */
  __hasContent(n) {
    return n ? n.nodeType === Node.ELEMENT_NODE && (customElements.get(n.localName) || n.children.length > 0) || n.textContent && n.textContent.trim() !== "" : !1;
  }
  /**
   * Fire an event to notify the controller host about node changes.
   *
   * @param {Node} node
   * @private
   */
  __notifyChange(n) {
    this.dispatchEvent(
      new CustomEvent("slot-content-changed", {
        detail: { hasContent: this.__hasContent(n), node: n }
      })
    );
  }
  /**
   * Set default ID on the node in case it is an HTML element.
   *
   * @param {Node} node
   * @private
   */
  __updateNodeId(n) {
    const e = !this.nodes || n === this.nodes[0];
    n.nodeType === Node.ELEMENT_NODE && (!this.multiple || e) && !n.id && (n.id = this.defaultId);
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class vp extends Es {
  constructor(n) {
    super(n, "error-message", "div");
  }
  /**
   * Set the error message element text content.
   *
   * @param {string} errorMessage
   */
  setErrorMessage(n) {
    this.errorMessage = n, this.updateDefaultNode(this.node);
  }
  /**
   * Set invalid state for detecting whether to show error message.
   *
   * @param {boolean} invalid
   */
  setInvalid(n) {
    this.invalid = n, this.updateDefaultNode(this.node);
  }
  /**
   * Override method inherited from `SlotController` to not run
   * initializer on the custom slotted node unnecessarily.
   *
   * @param {Node} node
   * @protected
   * @override
   */
  initAddedNode(n) {
    n !== this.defaultNode && this.initCustomNode(n);
  }
  /**
   * Override to initialize the newly added default error message.
   *
   * @param {Node} errorNode
   * @protected
   * @override
   */
  initNode(n) {
    this.updateDefaultNode(n);
  }
  /**
   * Override to initialize the newly added custom error message.
   *
   * @param {Node} errorNode
   * @protected
   * @override
   */
  initCustomNode(n) {
    n.textContent && !this.errorMessage && (this.errorMessage = n.textContent.trim()), super.initCustomNode(n);
  }
  /**
   * Override method inherited from `SlotChildObserveController`
   * to restore the default error message element.
   *
   * @protected
   * @override
   */
  restoreDefaultNode() {
    this.attachDefaultNode();
  }
  /**
   * Override method inherited from `SlotChildObserveController`
   * to update the error message text and hidden state.
   *
   * Note: unlike with other controllers, this method is
   * called for both default and custom error message.
   *
   * @param {Node | undefined} node
   * @protected
   * @override
   */
  updateDefaultNode(n) {
    const { errorMessage: e, invalid: t } = this, i = !!(t && e && e.trim() !== "");
    n && (n.textContent = i ? e : "", n.hidden = !i, i ? n.setAttribute("role", "alert") : n.removeAttribute("role")), super.updateDefaultNode(n);
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class _p extends Es {
  constructor(n) {
    super(n, "helper", null);
  }
  /**
   * Set helper text based on corresponding host property.
   *
   * @param {string} helperText
   */
  setHelperText(n) {
    this.helperText = n, this.getSlotChild() || this.restoreDefaultNode(), this.node === this.defaultNode && this.updateDefaultNode(this.node);
  }
  /**
   * Override method inherited from `SlotChildObserveController`
   * to create the default helper element lazily as needed.
   *
   * @param {Node | undefined} node
   * @protected
   * @override
   */
  restoreDefaultNode() {
    const { helperText: n } = this;
    if (n && n.trim() !== "") {
      this.tagName = "div";
      const e = this.attachDefaultNode();
      this.observeNode(e);
    }
  }
  /**
   * Override method inherited from `SlotChildObserveController`
   * to update the default helper element text content.
   *
   * @param {Node | undefined} node
   * @protected
   * @override
   */
  updateDefaultNode(n) {
    n && (n.textContent = this.helperText), super.updateDefaultNode(n);
  }
  /**
   * Override to observe the newly added custom node.
   *
   * @param {Node} node
   * @protected
   * @override
   */
  initCustomNode(n) {
    super.initCustomNode(n), this.observeNode(n);
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class bp extends Es {
  constructor(n) {
    super(n, "label", "label");
  }
  /**
   * Set label based on corresponding host property.
   *
   * @param {string} label
   */
  setLabel(n) {
    this.label = n, this.getSlotChild() || this.restoreDefaultNode(), this.node === this.defaultNode && this.updateDefaultNode(this.node);
  }
  /**
   * Override method inherited from `SlotChildObserveController`
   * to restore and observe the default label element.
   *
   * @protected
   * @override
   */
  restoreDefaultNode() {
    const { label: n } = this;
    if (n && n.trim() !== "") {
      const e = this.attachDefaultNode();
      this.observeNode(e);
    }
  }
  /**
   * Override method inherited from `SlotChildObserveController`
   * to update the default label element text content.
   *
   * @param {Node | undefined} node
   * @protected
   * @override
   */
  updateDefaultNode(n) {
    n && (n.textContent = this.label), super.updateDefaultNode(n);
  }
  /**
   * Override to observe the newly added custom node.
   *
   * @param {Node} node
   * @protected
   * @override
   */
  initCustomNode(n) {
    super.initCustomNode(n), this.observeNode(n);
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const yp = rt(
  (s) => class extends Tr(s) {
    static get properties() {
      return {
        /**
         * The label text for the input node.
         * When no light dom defined via [slot=label], this value will be used.
         */
        label: {
          type: String,
          observer: "_labelChanged"
        }
      };
    }
    constructor() {
      super(), this._labelController = new bp(this), this._labelController.addEventListener("slot-content-changed", (e) => {
        this.toggleAttribute("has-label", e.detail.hasContent);
      });
    }
    /** @protected */
    get _labelId() {
      const e = this._labelNode;
      return e && e.id;
    }
    /** @protected */
    get _labelNode() {
      return this._labelController.node;
    }
    /** @protected */
    ready() {
      super.ready(), this.addController(this._labelController);
    }
    /** @protected */
    _labelChanged(e) {
      this._labelController.setLabel(e);
    }
  }
);
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Ps = rt(
  (s) => class extends s {
    static get properties() {
      return {
        /**
         * Set to true when the field is invalid.
         */
        invalid: {
          type: Boolean,
          reflectToAttribute: !0,
          notify: !0,
          value: !1
        },
        /**
         * Specifies that the user must fill in a value.
         */
        required: {
          type: Boolean,
          reflectToAttribute: !0
        }
      };
    }
    /**
     * Validates the field and sets the `invalid` property based on the result.
     *
     * The method fires a `validated` event with the result of the validation.
     *
     * @return {boolean} True if the value is valid.
     */
    validate() {
      const e = this.checkValidity();
      return this._setInvalid(!e), this.dispatchEvent(new CustomEvent("validated", { detail: { valid: e } })), e;
    }
    /**
     * Returns true if the field value satisfies all constraints (if any).
     *
     * @return {boolean}
     */
    checkValidity() {
      return !this.required || !!this.value;
    }
    /**
     * @param {boolean} invalid
     * @protected
     */
    _setInvalid(e) {
      this._shouldSetInvalid(e) && (this.invalid = e);
    }
    /**
     * Override this method to define whether the given `invalid` state should be set.
     *
     * @param {boolean} _invalid
     * @return {boolean}
     * @protected
     */
    _shouldSetInvalid(e) {
      return !0;
    }
    /**
     * Fired whenever the field is validated.
     *
     * @event validated
     * @param {Object} detail
     * @param {boolean} detail.valid the result of the validation.
     */
  }
);
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const wp = (s) => class extends Ps(yp(Tr(s))) {
  static get properties() {
    return {
      /**
       * A target element to which ARIA attributes are set.
       * @protected
       */
      ariaTarget: {
        type: Object,
        observer: "_ariaTargetChanged"
      },
      /**
       * Error to show when the field is invalid.
       *
       * @attr {string} error-message
       */
      errorMessage: {
        type: String,
        observer: "_errorMessageChanged"
      },
      /**
       * String used for the helper text.
       * @attr {string} helper-text
       */
      helperText: {
        type: String,
        observer: "_helperTextChanged"
      },
      /**
       * String used to label the component to screen reader users.
       * @attr {string} accessible-name
       */
      accessibleName: {
        type: String,
        observer: "_accessibleNameChanged"
      },
      /**
       * Id of the element used as label of the component to screen reader users.
       * @attr {string} accessible-name-ref
       */
      accessibleNameRef: {
        type: String,
        observer: "_accessibleNameRefChanged"
      }
    };
  }
  static get observers() {
    return ["_invalidChanged(invalid)", "_requiredChanged(required)"];
  }
  constructor() {
    super(), this._fieldAriaController = new wf(this), this._helperController = new _p(this), this._errorController = new vp(this), this._errorController.addEventListener("slot-content-changed", (e) => {
      this.toggleAttribute("has-error-message", e.detail.hasContent);
    }), this._labelController.addEventListener("slot-content-changed", (e) => {
      const { hasContent: t, node: i } = e.detail;
      this.__labelChanged(t, i);
    }), this._helperController.addEventListener("slot-content-changed", (e) => {
      const { hasContent: t, node: i } = e.detail;
      this.toggleAttribute("has-helper", t), this.__helperChanged(t, i);
    });
  }
  /**
   * @protected
   * @return {HTMLElement}
   */
  get _errorNode() {
    return this._errorController.node;
  }
  /**
   * @protected
   * @return {HTMLElement}
   */
  get _helperNode() {
    return this._helperController.node;
  }
  /** @protected */
  ready() {
    super.ready(), this.addController(this._fieldAriaController), this.addController(this._helperController), this.addController(this._errorController);
  }
  /** @private */
  __helperChanged(e, t) {
    e ? this._fieldAriaController.setHelperId(t.id) : this._fieldAriaController.setHelperId(null);
  }
  /** @protected */
  _accessibleNameChanged(e) {
    this._fieldAriaController.setAriaLabel(e);
  }
  /** @protected */
  _accessibleNameRefChanged(e) {
    this._fieldAriaController.setLabelId(e, !0);
  }
  /** @private */
  __labelChanged(e, t) {
    e ? this._fieldAriaController.setLabelId(t.id) : this._fieldAriaController.setLabelId(null);
  }
  /**
   * @param {string | null | undefined} errorMessage
   * @protected
   */
  _errorMessageChanged(e) {
    this._errorController.setErrorMessage(e);
  }
  /**
   * @param {string} helperText
   * @protected
   */
  _helperTextChanged(e) {
    this._helperController.setHelperText(e);
  }
  /**
   * @param {HTMLElement | null | undefined} target
   * @protected
   */
  _ariaTargetChanged(e) {
    e && this._fieldAriaController.setTarget(e);
  }
  /**
   * @param {boolean} required
   * @protected
   */
  _requiredChanged(e) {
    this._fieldAriaController.setRequired(e);
  }
  /**
   * @param {boolean} invalid
   * @protected
   */
  _invalidChanged(e) {
    this._errorController.setInvalid(e), setTimeout(() => {
      if (e) {
        const t = this._errorNode;
        this._fieldAriaController.setErrorId(t && t.id);
      } else
        this._fieldAriaController.setErrorId(null);
    });
  }
};
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const xp = rt(
  (s) => class extends s {
    static get properties() {
      return {
        /**
         * A target element to which attributes and properties are delegated.
         * @protected
         */
        stateTarget: {
          type: Object,
          observer: "_stateTargetChanged"
        }
      };
    }
    /**
     * An array of the host attributes to delegate to the target element.
     */
    static get delegateAttrs() {
      return [];
    }
    /**
     * An array of the host properties to delegate to the target element.
     */
    static get delegateProps() {
      return [];
    }
    /** @protected */
    ready() {
      super.ready(), this._createDelegateAttrsObserver(), this._createDelegatePropsObserver();
    }
    /** @protected */
    _stateTargetChanged(e) {
      e && (this._ensureAttrsDelegated(), this._ensurePropsDelegated());
    }
    /** @protected */
    _createDelegateAttrsObserver() {
      this._createMethodObserver(`_delegateAttrsChanged(${this.constructor.delegateAttrs.join(", ")})`);
    }
    /** @protected */
    _createDelegatePropsObserver() {
      this._createMethodObserver(`_delegatePropsChanged(${this.constructor.delegateProps.join(", ")})`);
    }
    /** @protected */
    _ensureAttrsDelegated() {
      this.constructor.delegateAttrs.forEach((e) => {
        this._delegateAttribute(e, this[e]);
      });
    }
    /** @protected */
    _ensurePropsDelegated() {
      this.constructor.delegateProps.forEach((e) => {
        this._delegateProperty(e, this[e]);
      });
    }
    /** @protected */
    _delegateAttrsChanged(...e) {
      this.constructor.delegateAttrs.forEach((t, i) => {
        this._delegateAttribute(t, e[i]);
      });
    }
    /** @protected */
    _delegatePropsChanged(...e) {
      this.constructor.delegateProps.forEach((t, i) => {
        this._delegateProperty(t, e[i]);
      });
    }
    /** @protected */
    _delegateAttribute(e, t) {
      this.stateTarget && (e === "invalid" && this._delegateAttribute("aria-invalid", t ? "true" : !1), typeof t == "boolean" ? this.stateTarget.toggleAttribute(e, t) : t ? this.stateTarget.setAttribute(e, t) : this.stateTarget.removeAttribute(e));
    }
    /** @protected */
    _delegateProperty(e, t) {
      this.stateTarget && (this.stateTarget[e] = t);
    }
  }
);
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const gc = rt(
  (s) => class extends xp(Ps(Ts(s))) {
    /**
     * An array of attributes which participate in the input validation.
     * Changing these attributes will cause the input to re-validate.
     *
     * IMPORTANT: The attributes should be properly delegated to the input element
     * from the host using `delegateAttrs` getter (see `DelegateStateMixin`).
     * The `required` attribute is already delegated.
     */
    static get constraints() {
      return ["required"];
    }
    static get delegateAttrs() {
      return [...super.delegateAttrs, "required"];
    }
    /** @protected */
    ready() {
      super.ready(), this._createConstraintsObserver();
    }
    /**
     * Returns true if the current input value satisfies all constraints (if any).
     * @return {boolean}
     */
    checkValidity() {
      return this.inputElement && this._hasValidConstraints(this.constructor.constraints.map((e) => this[e])) ? this.inputElement.checkValidity() : !this.invalid;
    }
    /**
     * Returns true if some of the provided set of constraints are valid.
     * @param {Array} constraints
     * @return {boolean}
     * @protected
     */
    _hasValidConstraints(e) {
      return e.some((t) => this.__isValidConstraint(t));
    }
    /**
     * Override this method to customize setting up constraints observer.
     * @protected
     */
    _createConstraintsObserver() {
      this._createMethodObserver(`_constraintsChanged(stateTarget, ${this.constructor.constraints.join(", ")})`);
    }
    /**
     * Override this method to implement custom validation constraints.
     * @param {HTMLElement | undefined} stateTarget
     * @param {unknown[]} constraints
     * @protected
     */
    _constraintsChanged(e, ...t) {
      if (!e)
        return;
      const i = this._hasValidConstraints(t), r = this.__previousHasConstraints && !i;
      (this._hasValue || this.invalid) && i ? this.validate() : r && this._setInvalid(!1), this.__previousHasConstraints = i;
    }
    /**
     * Override an event listener inherited from `InputMixin`
     * to capture native `change` event and make sure that
     * a new one is dispatched after validation runs.
     * @param {Event} event
     * @protected
     * @override
     */
    _onChange(e) {
      e.stopPropagation(), this.validate(), this.dispatchEvent(
        new CustomEvent("change", {
          detail: {
            sourceEvent: e
          },
          bubbles: e.bubbles,
          cancelable: e.cancelable
        })
      );
    }
    /** @private */
    __isValidConstraint(e) {
      return !!e || e === 0;
    }
  }
);
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Cp = (s) => class extends gp(
  _f(gc(wp(mp(ys(s)))))
) {
  static get properties() {
    return {
      /**
       * A pattern matched against individual characters the user inputs.
       *
       * When set, the field will prevent:
       * - `keydown` events if the entered key doesn't match `/^allowedCharPattern$/`
       * - `paste` events if the pasted text doesn't match `/^allowedCharPattern*$/`
       * - `drop` events if the dropped text doesn't match `/^allowedCharPattern*$/`
       *
       * For example, to allow entering only numbers and minus signs, use:
       * `allowedCharPattern = "[\\d-]"`
       * @attr {string} allowed-char-pattern
       */
      allowedCharPattern: {
        type: String,
        observer: "_allowedCharPatternChanged"
      },
      /**
       * If true, the input text gets fully selected when the field is focused using click or touch / tap.
       */
      autoselect: {
        type: Boolean,
        value: !1
      },
      /**
       * The name of this field.
       */
      name: {
        type: String,
        reflectToAttribute: !0
      },
      /**
       * A hint to the user of what can be entered in the field.
       */
      placeholder: {
        type: String,
        reflectToAttribute: !0
      },
      /**
       * When present, it specifies that the field is read-only.
       */
      readonly: {
        type: Boolean,
        value: !1,
        reflectToAttribute: !0
      },
      /**
       * The text usually displayed in a tooltip popup when the mouse is over the field.
       */
      title: {
        type: String,
        reflectToAttribute: !0
      }
    };
  }
  static get delegateAttrs() {
    return [...super.delegateAttrs, "name", "type", "placeholder", "readonly", "invalid", "title"];
  }
  constructor() {
    super(), this._boundOnPaste = this._onPaste.bind(this), this._boundOnDrop = this._onDrop.bind(this), this._boundOnBeforeInput = this._onBeforeInput.bind(this);
  }
  /** @protected */
  get slotStyles() {
    return [
      `
          :is(input[slot='input'], textarea[slot='textarea'])::placeholder {
            font: inherit;
            color: inherit;
          }
        `
    ];
  }
  /**
   * Override an event listener from `DelegateFocusMixin`.
   * @param {FocusEvent} event
   * @protected
   * @override
   */
  _onFocus(e) {
    super._onFocus(e), this.autoselect && this.inputElement && this.inputElement.select();
  }
  /**
   * Override an event listener inherited from `InputMixin`
   * to capture native `change` event and make sure that
   * a new one is dispatched after validation runs.
   * @param {Event} event
   * @protected
   * @override
   */
  _onChange(e) {
    e.stopPropagation(), this.validate(), this.dispatchEvent(
      new CustomEvent("change", {
        detail: {
          sourceEvent: e
        },
        bubbles: e.bubbles,
        cancelable: e.cancelable
      })
    );
  }
  /**
   * Override a method from `InputMixin`.
   * @param {!HTMLElement} input
   * @protected
   * @override
   */
  _addInputListeners(e) {
    super._addInputListeners(e), e.addEventListener("paste", this._boundOnPaste), e.addEventListener("drop", this._boundOnDrop), e.addEventListener("beforeinput", this._boundOnBeforeInput);
  }
  /**
   * Override a method from `InputMixin`.
   * @param {!HTMLElement} input
   * @protected
   * @override
   */
  _removeInputListeners(e) {
    super._removeInputListeners(e), e.removeEventListener("paste", this._boundOnPaste), e.removeEventListener("drop", this._boundOnDrop), e.removeEventListener("beforeinput", this._boundOnBeforeInput);
  }
  /**
   * Override an event listener from `KeyboardMixin`.
   * @param {!KeyboardEvent} event
   * @protected
   * @override
   */
  _onKeyDown(e) {
    super._onKeyDown(e), this.allowedCharPattern && !this.__shouldAcceptKey(e) && e.target === this.inputElement && (e.preventDefault(), this._markInputPrevented());
  }
  /** @protected */
  _markInputPrevented() {
    this.setAttribute("input-prevented", ""), this._preventInputDebouncer = Me.debounce(this._preventInputDebouncer, zt.after(200), () => {
      this.removeAttribute("input-prevented");
    });
  }
  /** @private */
  __shouldAcceptKey(e) {
    return e.metaKey || e.ctrlKey || !e.key || // Allow typing anything if event.key is not supported
    e.key.length !== 1 || // Allow "Backspace", "ArrowLeft" etc.
    this.__allowedCharRegExp.test(e.key);
  }
  /** @private */
  _onPaste(e) {
    if (this.allowedCharPattern) {
      const t = e.clipboardData.getData("text");
      this.__allowedTextRegExp.test(t) || (e.preventDefault(), this._markInputPrevented());
    }
  }
  /** @private */
  _onDrop(e) {
    if (this.allowedCharPattern) {
      const t = e.dataTransfer.getData("text");
      this.__allowedTextRegExp.test(t) || (e.preventDefault(), this._markInputPrevented());
    }
  }
  /** @private */
  _onBeforeInput(e) {
    this.allowedCharPattern && e.data && !this.__allowedTextRegExp.test(e.data) && (e.preventDefault(), this._markInputPrevented());
  }
  /** @private */
  _allowedCharPatternChanged(e) {
    if (e)
      try {
        this.__allowedCharRegExp = new RegExp(`^${e}$`, "u"), this.__allowedTextRegExp = new RegExp(`^${e}*$`, "u");
      } catch (t) {
        console.error(t);
      }
  }
  /**
   * Fired when the user commits a value change.
   *
   * @event change
   */
  /**
   * Fired when the value is changed by the user: on every typing keystroke,
   * and the value is cleared using the clear button.
   *
   * @event input
   */
};
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class Tp extends ps {
  constructor(n, e, t = {}) {
    const { uniqueIdPrefix: i } = t;
    super(n, "input", "input", {
      initializer: (r, o) => {
        o.value && (r.value = o.value), o.type && r.setAttribute("type", o.type), r.id = this.defaultId, typeof e == "function" && e(r);
      },
      useUniqueId: !0,
      uniqueIdPrefix: i
    });
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class Ep {
  constructor(n, e) {
    this.input = n, this.__preventDuplicateLabelClick = this.__preventDuplicateLabelClick.bind(this), e.addEventListener("slot-content-changed", (t) => {
      this.__initLabel(t.detail.node);
    }), this.__initLabel(e.node);
  }
  /**
   * @param {HTMLElement} label
   * @private
   */
  __initLabel(n) {
    n && (n.addEventListener("click", this.__preventDuplicateLabelClick), this.input && n.setAttribute("for", this.input.id));
  }
  /**
   * The native platform fires an event for both the click on the label, and also
   * the subsequent click on the native input element caused by label click.
   * This results in two click events arriving at the host, but we only want one.
   * This method prevents the duplicate click and ensures the correct isTrusted event
   * with the correct event.target arrives at the host.
   * @private
   */
  __preventDuplicateLabelClick() {
    const n = (e) => {
      e.stopImmediatePropagation(), this.input.removeEventListener("click", n);
    };
    this.input.addEventListener("click", n);
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Pp = (s) => class extends gc(s) {
  static get properties() {
    return {
      /**
       * A regular expression that the value is checked against.
       * The pattern must match the entire value, not just some subset.
       */
      pattern: {
        type: String
      }
    };
  }
  static get delegateAttrs() {
    return [...super.delegateAttrs, "pattern"];
  }
  static get constraints() {
    return [...super.constraints, "pattern"];
  }
};
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd..
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Sp = ke`
  [part='clear-button'] {
    display: none;
    cursor: default;
  }

  [part='clear-button']::before {
    content: '\\2715';
  }

  :host([clear-button-visible][has-value]:not([disabled]):not([readonly])) [part='clear-button'] {
    display: block;
  }
`;
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd..
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const kp = ke`
  :host {
    display: inline-flex;
    outline: none;
  }

  :host::before {
    content: '\\2003';
    width: 0;
    display: inline-block;
    /* Size and position this element on the same vertical position as the input-field element
          to make vertical align for the host element work as expected */
  }

  :host([hidden]) {
    display: none !important;
  }

  :host(:not([has-label])) [part='label'] {
    display: none;
  }

  @media (forced-colors: active) {
    :host(:not([readonly])) [part='input-field'] {
      outline: 1px solid;
      outline-offset: -1px;
    }
    :host([focused]) [part='input-field'] {
      outline-width: 2px;
    }
    :host([disabled]) [part='input-field'] {
      outline-color: GrayText;
    }
  }
`;
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd..
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Rp = ke`
  [class$='container'] {
    display: flex;
    flex-direction: column;
    min-width: 100%;
    max-width: 100%;
    width: var(--vaadin-field-default-width, 12em);
  }
`;
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd..
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Ap = [kp, Rp, Sp];
/**
 * @license
 * Copyright (c) 2015 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Ip = (s) => class extends s {
  static get properties() {
    return {
      /**
       * Number of items fetched at a time from the dataprovider.
       * @attr {number} page-size
       * @type {number}
       */
      pageSize: {
        type: Number,
        value: 50,
        observer: "_pageSizeChanged",
        sync: !0
      },
      /**
       * Total number of items.
       * @type {number | undefined}
       */
      size: {
        type: Number,
        observer: "_sizeChanged",
        sync: !0
      },
      /**
       * Function that provides items lazily. Receives arguments `params`, `callback`
       *
       * `params.page` Requested page index
       *
       * `params.pageSize` Current page size
       *
       * `params.filter` Currently applied filter
       *
       * `callback(items, size)` Callback function with arguments:
       *   - `items` Current page of items
       *   - `size` Total number of items.
       * @type {ComboBoxDataProvider | undefined}
       */
      dataProvider: {
        type: Object,
        observer: "_dataProviderChanged",
        sync: !0
      },
      /** @private */
      __dataProviderInitialized: {
        type: Boolean,
        value: !1
      },
      /** @private */
      __previousDataProviderFilter: {
        type: String
      }
    };
  }
  static get observers() {
    return [
      "_dataProviderFilterChanged(filter)",
      "_warnDataProviderValue(dataProvider, value)",
      "_ensureFirstPage(opened)"
    ];
  }
  constructor() {
    super(), this.__dataProviderController = new nc(this, {
      placeholder: new Ni(),
      isPlaceholder: (e) => e instanceof Ni,
      dataProviderParams: () => ({ filter: this.filter })
    }), this.__dataProviderController.addEventListener("page-requested", this.__onDataProviderPageRequested.bind(this)), this.__dataProviderController.addEventListener("page-loaded", this.__onDataProviderPageLoaded.bind(this));
  }
  /** @protected */
  ready() {
    super.ready(), this._scroller.addEventListener("index-requested", (e) => {
      if (!this._shouldFetchData())
        return;
      const t = e.detail.index;
      t !== void 0 && this.__dataProviderController.ensureFlatIndexLoaded(t);
    }), this.__dataProviderInitialized = !0, this.dataProvider && this.__synchronizeControllerState();
  }
  /** @private */
  _dataProviderFilterChanged(e) {
    if (this.__previousDataProviderFilter === void 0 && e === "") {
      this.__previousDataProviderFilter = e;
      return;
    }
    this.__previousDataProviderFilter !== e && (this.__previousDataProviderFilter = e, this.__keepOverlayOpened = !0, this.size = void 0, this.clearCache(), this.__keepOverlayOpened = !1);
  }
  /** @protected */
  _shouldFetchData() {
    return this.dataProvider ? this.opened || this.filter && this.filter.length : !1;
  }
  /** @private */
  _ensureFirstPage(e) {
    !this._shouldFetchData() || !e || (this._forceNextRequest || this.size === void 0 ? (this._forceNextRequest = !1, this.__dataProviderController.loadFirstPage()) : this.size > 0 && this.__dataProviderController.ensureFlatIndexLoaded(0));
  }
  /** @private */
  __onDataProviderPageRequested() {
    this.loading = !0;
  }
  /** @private */
  __onDataProviderPageLoaded() {
    const { rootCache: e } = this.__dataProviderController;
    e.items = [...e.items], this.__synchronizeControllerState(), !this.opened && !this._isInputFocused() && this._commitValue();
  }
  /**
   * Clears the cached pages and reloads data from dataprovider when needed.
   */
  clearCache() {
    this.dataProvider && (this.__dataProviderController.clearCache(), this.__synchronizeControllerState(), this._shouldFetchData() ? (this._forceNextRequest = !1, this.__dataProviderController.loadFirstPage()) : this._forceNextRequest = !0);
  }
  /**
   * When the size change originates externally, synchronizes the new size with
   * the controller and request a content update to re-render the scroller.
   *
   * @private
   */
  _sizeChanged(e) {
    const { rootCache: t } = this.__dataProviderController;
    t.size !== e && (t.size = e, t.items = [...t.items], this.__synchronizeControllerState());
  }
  /**
   * When the items change originates externally, synchronizes the new items with
   * the controller and requests a content update to re-render the scroller.
   *
   * @private
   * @override
   */
  _filteredItemsChanged(e) {
    if (super._filteredItemsChanged(e), this.dataProvider && e) {
      const { rootCache: t } = this.__dataProviderController;
      t.items !== e && (t.items = e, this.__synchronizeControllerState());
    }
  }
  /**
   * Synchronizes the controller's state with the component, which can be
   * out of sync after the controller receives new data from the data provider
   * or if the state in the controller is directly manipulated.
   *
   * @private
   */
  __synchronizeControllerState() {
    if (this.__dataProviderInitialized && this.dataProvider) {
      const { rootCache: e } = this.__dataProviderController;
      this.size = e.size, this.filteredItems = e.items, this.loading = this.__dataProviderController.isLoading();
    }
  }
  /** @private */
  _pageSizeChanged(e, t) {
    if (Math.floor(e) !== e || e < 1)
      throw this.pageSize = t, new Error("`pageSize` value must be an integer > 0");
    this.__dataProviderController.setPageSize(e), this.clearCache();
  }
  /** @private */
  _dataProviderChanged(e, t) {
    this._ensureItemsOrDataProvider(() => {
      this.dataProvider = t;
    }), this.__dataProviderController.setDataProvider(e), this.clearCache();
  }
  /** @private */
  _ensureItemsOrDataProvider(e) {
    if (this.items !== void 0 && this.dataProvider !== void 0)
      throw e(), new Error("Using `items` and `dataProvider` together is not supported");
  }
  /** @private */
  _warnDataProviderValue(e, t) {
    if (e && t !== "" && (this.selectedItem === void 0 || this.selectedItem === null)) {
      const i = this.__getItemIndexByValue(this.filteredItems, t);
      (i < 0 || !this._getItemLabel(this.filteredItems[i])) && console.warn(
        "Warning: unable to determine the label for the provided `value`. Nothing to display in the text field. This usually happens when setting an initial `value` before any items are returned from the `dataProvider` callback. Consider setting `selectedItem` instead of `value`"
      );
    }
  }
};
/**
 * @license
 * Copyright (c) 2023 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Dp = (s) => class extends s {
  static get properties() {
    return {
      /**
       * A space-delimited list of CSS class names to set on the overlay element.
       * This property does not affect other CSS class names set manually via JS.
       *
       * Note, if the CSS class name was set with this property, clearing it will
       * remove it from the overlay, even if the same class name was also added
       * manually, e.g. by using `classList.add()` in the `renderer` function.
       *
       * @attr {string} overlay-class
       */
      overlayClass: {
        type: String
      },
      /**
       * An overlay element on which CSS class names are set.
       *
       * @protected
       */
      _overlayElement: {
        type: Object
      }
    };
  }
  static get observers() {
    return ["__updateOverlayClassNames(overlayClass, _overlayElement)"];
  }
  /** @private */
  __updateOverlayClassNames(e, t) {
    if (!t || e === void 0)
      return;
    const { classList: i } = t;
    if (this.__initialClasses || (this.__initialClasses = new Set(i)), Array.isArray(this.__previousClasses)) {
      const o = this.__previousClasses.filter((a) => !this.__initialClasses.has(a));
      o.length > 0 && i.remove(...o);
    }
    const r = typeof e == "string" ? e.split(" ").filter(Boolean) : [];
    r.length > 0 && i.add(...r), this.__previousClasses = r;
  }
};
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class Op {
  /**
   * @param {{ inputElement?: HTMLElement; opened: boolean } & HTMLElement} host
   */
  constructor(n) {
    this.host = n, n.addEventListener("opened-changed", () => {
      n.opened || this.__setVirtualKeyboardEnabled(!1);
    }), n.addEventListener("blur", () => this.__setVirtualKeyboardEnabled(!0)), n.addEventListener("touchstart", () => this.__setVirtualKeyboardEnabled(!0));
  }
  /** @private */
  __setVirtualKeyboardEnabled(n) {
    this.host.inputElement && (this.host.inputElement.inputMode = n ? "" : "none");
  }
}
/**
 * @license
 * Copyright (c) 2015 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function Xa(s) {
  return s != null;
}
function Qa(s, n) {
  return s.findIndex((e) => e instanceof Ni ? !1 : n(e));
}
const zp = (s) => class extends Dp(
  Tr(Ps(sc(ys(Ts(jl(s))))))
) {
  static get properties() {
    return {
      /**
       * True if the dropdown is open, false otherwise.
       * @type {boolean}
       */
      opened: {
        type: Boolean,
        notify: !0,
        value: !1,
        reflectToAttribute: !0,
        sync: !0,
        observer: "_openedChanged"
      },
      /**
       * Set true to prevent the overlay from opening automatically.
       * @attr {boolean} auto-open-disabled
       */
      autoOpenDisabled: {
        type: Boolean,
        sync: !0
      },
      /**
       * When present, it specifies that the field is read-only.
       * @type {boolean}
       */
      readonly: {
        type: Boolean,
        value: !1,
        reflectToAttribute: !0
      },
      /**
       * Custom function for rendering the content of every item.
       * Receives three arguments:
       *
       * - `root` The `<vaadin-combo-box-item>` internal container DOM element.
       * - `comboBox` The reference to the `<vaadin-combo-box>` element.
       * - `model` The object with the properties related with the rendered
       *   item, contains:
       *   - `model.index` The index of the rendered item.
       *   - `model.item` The item.
       * @type {ComboBoxRenderer | undefined}
       */
      renderer: {
        type: Object,
        sync: !0
      },
      /**
       * A full set of items to filter the visible options from.
       * The items can be of either `String` or `Object` type.
       * @type {!Array<!ComboBoxItem | string> | undefined}
       */
      items: {
        type: Array,
        sync: !0,
        observer: "_itemsChanged"
      },
      /**
       * If `true`, the user can input a value that is not present in the items list.
       * `value` property will be set to the input value in this case.
       * Also, when `value` is set programmatically, the input value will be set
       * to reflect that value.
       * @attr {boolean} allow-custom-value
       * @type {boolean}
       */
      allowCustomValue: {
        type: Boolean,
        value: !1
      },
      /**
       * A subset of items, filtered based on the user input. Filtered items
       * can be assigned directly to omit the internal filtering functionality.
       * The items can be of either `String` or `Object` type.
       * @type {!Array<!ComboBoxItem | string> | undefined}
       */
      filteredItems: {
        type: Array,
        observer: "_filteredItemsChanged",
        sync: !0
      },
      /**
       * Used to detect user value changes and fire `change` events.
       * @private
       */
      _lastCommittedValue: String,
      /**
       * When set to `true`, "loading" attribute is added to host and the overlay element.
       * @type {boolean}
       */
      loading: {
        type: Boolean,
        value: !1,
        reflectToAttribute: !0,
        sync: !0
      },
      /**
       * @type {number}
       * @protected
       */
      _focusedIndex: {
        type: Number,
        observer: "_focusedIndexChanged",
        value: -1,
        sync: !0
      },
      /**
       * Filtering string the user has typed into the input field.
       * @type {string}
       */
      filter: {
        type: String,
        value: "",
        notify: !0,
        sync: !0
      },
      /**
       * The selected item from the `items` array.
       * @type {ComboBoxItem | string | undefined}
       */
      selectedItem: {
        type: Object,
        notify: !0,
        sync: !0
      },
      /**
       * A function used to generate CSS class names for dropdown
       * items based on the item. The return value should be the
       * generated class name as a string, or multiple class names
       * separated by whitespace characters.
       */
      itemClassNameGenerator: {
        type: Object
      },
      /**
       * Path for label of the item. If `items` is an array of objects, the
       * `itemLabelPath` is used to fetch the displayed string label for each
       * item.
       *
       * The item label is also used for matching items when processing user
       * input, i.e., for filtering and selecting items.
       * @attr {string} item-label-path
       * @type {string}
       */
      itemLabelPath: {
        type: String,
        value: "label",
        observer: "_itemLabelPathChanged",
        sync: !0
      },
      /**
       * Path for the value of the item. If `items` is an array of objects, the
       * `itemValuePath:` is used to fetch the string value for the selected
       * item.
       *
       * The item value is used in the `value` property of the combo box,
       * to provide the form value.
       * @attr {string} item-value-path
       * @type {string}
       */
      itemValuePath: {
        type: String,
        value: "value",
        sync: !0
      },
      /**
       * Path for the id of the item. If `items` is an array of objects,
       * the `itemIdPath` is used to compare and identify the same item
       * in `selectedItem` and `filteredItems` (items given by the
       * `dataProvider` callback).
       * @attr {string} item-id-path
       */
      itemIdPath: {
        type: String,
        sync: !0
      },
      /**
       * @type {!HTMLElement | undefined}
       * @protected
       */
      _toggleElement: {
        type: Object,
        observer: "_toggleElementChanged"
      },
      /**
       * Set of items to be rendered in the dropdown.
       * @protected
       */
      _dropdownItems: {
        type: Array,
        sync: !0
      },
      /** @private */
      _closeOnBlurIsPrevented: Boolean,
      /** @private */
      _scroller: {
        type: Object,
        sync: !0
      },
      /** @private */
      _overlayOpened: {
        type: Boolean,
        sync: !0,
        observer: "_overlayOpenedChanged"
      },
      /** @private */
      __keepOverlayOpened: {
        type: Boolean,
        sync: !0
      }
    };
  }
  static get observers() {
    return [
      "_selectedItemChanged(selectedItem, itemValuePath, itemLabelPath)",
      "_openedOrItemsChanged(opened, _dropdownItems, loading, __keepOverlayOpened)",
      "_updateScroller(_scroller, _dropdownItems, opened, loading, selectedItem, itemIdPath, _focusedIndex, renderer, _theme, itemClassNameGenerator)"
    ];
  }
  constructor() {
    super(), this._boundOverlaySelectedItemChanged = this._overlaySelectedItemChanged.bind(this), this._boundOnClearButtonMouseDown = this.__onClearButtonMouseDown.bind(this), this._boundOnClick = this._onClick.bind(this), this._boundOnOverlayTouchAction = this._onOverlayTouchAction.bind(this), this._boundOnTouchend = this._onTouchend.bind(this);
  }
  /**
   * Tag name prefix used by scroller and items.
   * @protected
   * @return {string}
   */
  get _tagNamePrefix() {
    return "vaadin-combo-box";
  }
  /**
   * Get a reference to the native `<input>` element.
   * Override to provide a custom input.
   * @protected
   * @return {HTMLInputElement | undefined}
   */
  get _nativeInput() {
    return this.inputElement;
  }
  /**
   * Override method inherited from `InputMixin`
   * to customize the input element.
   * @protected
   * @override
   */
  _inputElementChanged(e) {
    super._inputElementChanged(e);
    const t = this._nativeInput;
    t && (t.autocomplete = "off", t.autocapitalize = "off", t.setAttribute("role", "combobox"), t.setAttribute("aria-autocomplete", "list"), t.setAttribute("aria-expanded", !!this.opened), t.setAttribute("spellcheck", "false"), t.setAttribute("autocorrect", "off"), this._revertInputValueToValue(), this.clearElement && this.clearElement.addEventListener("mousedown", this._boundOnClearButtonMouseDown));
  }
  /** @protected */
  ready() {
    super.ready(), this._initOverlay(), this._initScroller(), this._lastCommittedValue = this.value, this.addEventListener("click", this._boundOnClick), this.addEventListener("touchend", this._boundOnTouchend);
    const e = () => {
      requestAnimationFrame(() => {
        this._overlayElement.bringToFront();
      });
    };
    this.addEventListener("mousedown", e), this.addEventListener("touchstart", e), cs(this), this.addController(new Op(this));
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback(), this.close();
  }
  /**
   * Requests an update for the content of items.
   * While performing the update, it invokes the renderer (passed in the `renderer` property) once an item.
   *
   * It is not guaranteed that the update happens immediately (synchronously) after it is requested.
   */
  requestContentUpdate() {
    this._scroller && (this._scroller.requestContentUpdate(), this._getItemElements().forEach((e) => {
      e.requestContentUpdate();
    }));
  }
  /**
   * Opens the dropdown list.
   */
  open() {
    !this.disabled && !this.readonly && (this.opened = !0);
  }
  /**
   * Closes the dropdown list.
   */
  close() {
    this.opened = !1;
  }
  /**
   * Override Polymer lifecycle callback to handle `filter` property change after
   * the observer for `opened` property is triggered. This is needed when opening
   * combo-box on user input to ensure the focused index is set correctly.
   *
   * @param {!Object} currentProps Current accessor values
   * @param {?Object} changedProps Properties changed since the last call
   * @param {?Object} oldProps Previous values for each changed property
   * @protected
   * @override
   */
  _propertiesChanged(e, t, i) {
    super._propertiesChanged(e, t, i), t.filter !== void 0 && this._filterChanged(t.filter);
  }
  /**
   * Override LitElement lifecycle callback to handle filter property change.
   * @param {Object} props
   */
  updated(e) {
    super.updated(e), e.has("filter") && this._filterChanged(this.filter);
  }
  /** @private */
  _initOverlay() {
    const e = this.$.overlay;
    e._comboBox = this, e.addEventListener("touchend", this._boundOnOverlayTouchAction), e.addEventListener("touchmove", this._boundOnOverlayTouchAction), e.addEventListener("mousedown", (t) => t.preventDefault()), e.addEventListener("opened-changed", (t) => {
      this._overlayOpened = t.detail.value;
    }), this._overlayElement = e;
  }
  /**
   * Create and initialize the scroller element.
   * Override to provide custom host reference.
   *
   * @protected
   */
  _initScroller(e) {
    const t = document.createElement(`${this._tagNamePrefix}-scroller`);
    t.owner = e || this, t.getItemLabel = this._getItemLabel.bind(this), t.addEventListener("selection-changed", this._boundOverlaySelectedItemChanged);
    const i = this._overlayElement;
    i.renderer = (r) => {
      r.innerHTML || r.appendChild(t);
    }, i.requestContentUpdate(), this._scroller = t;
  }
  /** @private */
  // eslint-disable-next-line @typescript-eslint/max-params
  _updateScroller(e, t, i, r, o, a, c, u, h, f) {
    if (e && (i && (e.style.maxHeight = getComputedStyle(this).getPropertyValue(`--${this._tagNamePrefix}-overlay-max-height`) || "65vh"), e.setProperties({
      items: i ? t : [],
      opened: i,
      loading: r,
      selectedItem: o,
      itemIdPath: a,
      focusedIndex: c,
      renderer: u,
      theme: h,
      itemClassNameGenerator: f
    }), e.performUpdate && !e.hasUpdated))
      try {
        e.performUpdate();
      } catch {
      }
  }
  /** @private */
  _openedOrItemsChanged(e, t, i, r) {
    this._overlayOpened = e && (r || i || !!(t && t.length));
  }
  /** @private */
  _overlayOpenedChanged(e, t) {
    e ? (this.dispatchEvent(new CustomEvent("vaadin-combo-box-dropdown-opened", { bubbles: !0, composed: !0 })), this._onOpened()) : t && this._dropdownItems && this._dropdownItems.length && (this.close(), this.dispatchEvent(new CustomEvent("vaadin-combo-box-dropdown-closed", { bubbles: !0, composed: !0 })));
  }
  /** @private */
  _focusedIndexChanged(e, t) {
    t !== void 0 && this._updateActiveDescendant(e);
  }
  /** @protected */
  _isInputFocused() {
    return this.inputElement && Ul(this.inputElement);
  }
  /** @private */
  _updateActiveDescendant(e) {
    const t = this._nativeInput;
    if (!t)
      return;
    const i = this._getItemElements().find((r) => r.index === e);
    i ? t.setAttribute("aria-activedescendant", i.id) : t.removeAttribute("aria-activedescendant");
  }
  /** @private */
  _openedChanged(e, t) {
    if (t === void 0)
      return;
    e ? !this._isInputFocused() && !br && this.inputElement && this.inputElement.focus() : this._onClosed();
    const i = this._nativeInput;
    i && (i.setAttribute("aria-expanded", !!e), e ? i.setAttribute("aria-controls", this._scroller.id) : i.removeAttribute("aria-controls"));
  }
  /** @private */
  _onOverlayTouchAction() {
    this._closeOnBlurIsPrevented = !0, this.inputElement.blur(), this._closeOnBlurIsPrevented = !1;
  }
  /** @protected */
  _isClearButton(e) {
    return e.composedPath()[0] === this.clearElement;
  }
  /** @private */
  __onClearButtonMouseDown(e) {
    e.preventDefault(), this.inputElement.focus();
  }
  /**
   * @param {Event} event
   * @protected
   */
  _onClearButtonClick(e) {
    e.preventDefault(), this._onClearAction(), this.opened && this.requestContentUpdate();
  }
  /**
   * @param {Event} event
   * @private
   */
  _onToggleButtonClick(e) {
    e.preventDefault(), this.opened ? this.close() : this.open();
  }
  /**
   * @param {Event} event
   * @protected
   */
  _onHostClick(e) {
    this.autoOpenDisabled || (e.preventDefault(), this.open());
  }
  /** @private */
  _onClick(e) {
    this._isClearButton(e) ? this._onClearButtonClick(e) : e.composedPath().includes(this._toggleElement) ? this._onToggleButtonClick(e) : this._onHostClick(e);
  }
  /**
   * Override an event listener from `KeyboardMixin`.
   *
   * @param {KeyboardEvent} e
   * @protected
   * @override
   */
  _onKeyDown(e) {
    super._onKeyDown(e), e.key === "ArrowDown" ? (this._onArrowDown(), e.preventDefault()) : e.key === "ArrowUp" && (this._onArrowUp(), e.preventDefault());
  }
  /** @private */
  _getItemLabel(e) {
    let t = e && this.itemLabelPath ? pi(this.itemLabelPath, e) : void 0;
    return t == null && (t = e ? e.toString() : ""), t;
  }
  /** @private */
  _getItemValue(e) {
    let t = e && this.itemValuePath ? pi(this.itemValuePath, e) : void 0;
    return t === void 0 && (t = e ? e.toString() : ""), t;
  }
  /** @private */
  _onArrowDown() {
    if (this.opened) {
      const e = this._dropdownItems;
      e && (this._focusedIndex = Math.min(e.length - 1, this._focusedIndex + 1), this._prefillFocusedItemLabel());
    } else
      this.open();
  }
  /** @private */
  _onArrowUp() {
    if (this.opened) {
      if (this._focusedIndex > -1)
        this._focusedIndex = Math.max(0, this._focusedIndex - 1);
      else {
        const e = this._dropdownItems;
        e && (this._focusedIndex = e.length - 1);
      }
      this._prefillFocusedItemLabel();
    } else
      this.open();
  }
  /** @private */
  _prefillFocusedItemLabel() {
    if (this._focusedIndex > -1) {
      const e = this._dropdownItems[this._focusedIndex];
      this._inputElementValue = this._getItemLabel(e), this._markAllSelectionRange();
    }
  }
  /** @private */
  _setSelectionRange(e, t) {
    this._isInputFocused() && this.inputElement.setSelectionRange && this.inputElement.setSelectionRange(e, t);
  }
  /** @private */
  _markAllSelectionRange() {
    this._inputElementValue !== void 0 && this._setSelectionRange(0, this._inputElementValue.length);
  }
  /** @private */
  _clearSelectionRange() {
    if (this._inputElementValue !== void 0) {
      const e = this._inputElementValue ? this._inputElementValue.length : 0;
      this._setSelectionRange(e, e);
    }
  }
  /** @private */
  _closeOrCommit() {
    !this.opened && !this.loading ? this._commitValue() : this.close();
  }
  /**
   * Override an event listener from `KeyboardMixin`.
   *
   * @param {KeyboardEvent} e
   * @protected
   * @override
   */
  _onEnter(e) {
    if (!this._hasValidInputValue()) {
      e.preventDefault(), e.stopPropagation();
      return;
    }
    this.opened && (e.preventDefault(), e.stopPropagation()), this._closeOrCommit();
  }
  /**
   * @protected
   */
  _hasValidInputValue() {
    const e = this._focusedIndex < 0 && this._inputElementValue !== "" && this._getItemLabel(this.selectedItem) !== this._inputElementValue;
    return this.allowCustomValue || !e;
  }
  /**
   * Override an event listener from `KeyboardMixin`.
   * Do not call `super` in order to override clear
   * button logic defined in `InputControlMixin`.
   *
   * @param {!KeyboardEvent} e
   * @protected
   * @override
   */
  _onEscape(e) {
    this.autoOpenDisabled ? this.opened || this.value !== this._inputElementValue && this._inputElementValue.length > 0 ? (e.stopPropagation(), this._focusedIndex = -1, this.cancel()) : this.clearButtonVisible && !this.opened && this.value && (e.stopPropagation(), this._onClearAction()) : this.opened ? (e.stopPropagation(), this._focusedIndex > -1 ? (this._focusedIndex = -1, this._revertInputValue()) : this.cancel()) : this.clearButtonVisible && this.value && (e.stopPropagation(), this._onClearAction());
  }
  /** @private */
  _toggleElementChanged(e) {
    e && (e.addEventListener("mousedown", (t) => t.preventDefault()), e.addEventListener("click", () => {
      br && !this._isInputFocused() && document.activeElement.blur();
    }));
  }
  /**
   * Clears the current value.
   * @protected
   */
  _onClearAction() {
    this.selectedItem = null, this.allowCustomValue && (this.value = ""), this._detectAndDispatchChange();
  }
  /**
   * Clears the current filter. Should be used instead of setting the property
   * directly in order to allow overriding this in multi-select combo box.
   * @protected
   */
  _clearFilter() {
    this.filter = "";
  }
  /**
   * Reverts back to original value.
   */
  cancel() {
    this._revertInputValueToValue(), this._lastCommittedValue = this.value, this._closeOrCommit();
  }
  /** @private */
  _onOpened() {
    this._lastCommittedValue = this.value;
  }
  /** @private */
  _onClosed() {
    (!this.loading || this.allowCustomValue) && this._commitValue();
  }
  /** @private */
  _commitValue() {
    if (this._focusedIndex > -1) {
      const e = this._dropdownItems[this._focusedIndex];
      this.selectedItem !== e && (this.selectedItem = e), this._inputElementValue = this._getItemLabel(this.selectedItem), this._focusedIndex = -1;
    } else if (this._inputElementValue === "" || this._inputElementValue === void 0)
      this.selectedItem = null, this.allowCustomValue && (this.value = "");
    else {
      const e = [this.selectedItem, ...this._dropdownItems || []], t = e[this.__getItemIndexByLabel(e, this._inputElementValue)];
      if (this.allowCustomValue && // To prevent a repetitive input value being saved after pressing ESC and Tab.
      !t) {
        const i = this._inputElementValue;
        this._lastCustomValue = i;
        const r = new CustomEvent("custom-value-set", {
          detail: i,
          composed: !0,
          cancelable: !0,
          bubbles: !0
        });
        this.dispatchEvent(r), r.defaultPrevented || (this.value = i);
      } else !this.allowCustomValue && !this.opened && t ? this.value = this._getItemValue(t) : this._revertInputValueToValue();
    }
    this._detectAndDispatchChange(), this._clearSelectionRange(), this._clearFilter();
  }
  /**
   * Override an event listener from `InputMixin`.
   * @param {!Event} event
   * @protected
   * @override
   */
  _onInput(e) {
    const t = this._inputElementValue, i = {};
    this.filter === t ? this._filterChanged(this.filter) : i.filter = t, !this.opened && !this._isClearButton(e) && !this.autoOpenDisabled && (i.opened = !0), this.setProperties(i);
  }
  /**
   * Override an event listener from `InputMixin`.
   * @param {!Event} event
   * @protected
   * @override
   */
  _onChange(e) {
    e.stopPropagation();
  }
  /** @private */
  _itemLabelPathChanged(e) {
    typeof e != "string" && console.error("You should set itemLabelPath to a valid string");
  }
  /** @private */
  _filterChanged(e) {
    this._scrollIntoView(0), this._focusedIndex = -1, this.items ? this.filteredItems = this._filterItems(this.items, e) : this._filteredItemsChanged(this.filteredItems);
  }
  /** @protected */
  _revertInputValue() {
    this.filter !== "" ? this._inputElementValue = this.filter : this._revertInputValueToValue(), this._clearSelectionRange();
  }
  /** @private */
  _revertInputValueToValue() {
    this.allowCustomValue && !this.selectedItem ? this._inputElementValue = this.value : this._inputElementValue = this._getItemLabel(this.selectedItem);
  }
  /** @private */
  _selectedItemChanged(e) {
    if (e == null)
      this.filteredItems && (this.allowCustomValue || (this.value = ""), this._toggleHasValue(this._hasValue), this._inputElementValue = this.value);
    else {
      const t = this._getItemValue(e);
      if (this.value !== t && (this.value = t, this.value !== t))
        return;
      this._toggleHasValue(!0), this._inputElementValue = this._getItemLabel(e);
    }
  }
  /**
   * Override an observer from `InputMixin`.
   * @protected
   * @override
   */
  _valueChanged(e, t) {
    e === "" && t === void 0 || (Xa(e) ? (this._getItemValue(this.selectedItem) !== e && this._selectItemForValue(e), !this.selectedItem && this.allowCustomValue && (this._inputElementValue = e), this._toggleHasValue(this._hasValue)) : this.selectedItem = null, this._clearFilter(), this._lastCommittedValue = void 0);
  }
  /** @private */
  _detectAndDispatchChange() {
    document.hasFocus() && this.validate(), this.value !== this._lastCommittedValue && (this.dispatchEvent(new CustomEvent("change", { bubbles: !0 })), this._lastCommittedValue = this.value);
  }
  /** @private */
  _itemsChanged(e, t) {
    this._ensureItemsOrDataProvider(() => {
      this.items = t;
    }), e ? this.filteredItems = e.slice(0) : t && (this.filteredItems = null);
  }
  /** @private */
  _filteredItemsChanged(e) {
    this._setDropdownItems(e);
  }
  /** @private */
  _filterItems(e, t) {
    return e && e.filter((r) => (t = t ? t.toString().toLowerCase() : "", this._getItemLabel(r).toString().toLowerCase().indexOf(t) > -1));
  }
  /** @private */
  _selectItemForValue(e) {
    const t = this.__getItemIndexByValue(this.filteredItems, e), i = this.selectedItem;
    t >= 0 ? this.selectedItem = this.filteredItems[t] : this.dataProvider && this.selectedItem === void 0 ? this.selectedItem = void 0 : this.selectedItem = null, this.selectedItem === null && i === null && this._selectedItemChanged(this.selectedItem);
  }
  /**
   * Provide items to be rendered in the dropdown.
   * Override this method to show custom items.
   *
   * @protected
   */
  _setDropdownItems(e) {
    const t = this._dropdownItems;
    this._dropdownItems = e;
    const i = t ? t[this._focusedIndex] : null, r = this.__getItemIndexByValue(e, this.value);
    (this.selectedItem === null || this.selectedItem === void 0) && r >= 0 && (this.selectedItem = e[r]);
    const o = this.__getItemIndexByValue(e, this._getItemValue(i));
    o > -1 ? this._focusedIndex = o : this._focusedIndex = this.__getItemIndexByLabel(e, this.filter);
  }
  /** @private */
  _getItemElements() {
    return Array.from(this._scroller.querySelectorAll(`${this._tagNamePrefix}-item`));
  }
  /** @private */
  _scrollIntoView(e) {
    this._scroller && this._scroller.scrollIntoView(e);
  }
  /**
   * Returns the first item that matches the provided value.
   *
   * @private
   */
  __getItemIndexByValue(e, t) {
    return !e || !Xa(t) ? -1 : Qa(e, (i) => this._getItemValue(i) === t);
  }
  /**
   * Returns the first item that matches the provided label.
   * Labels are matched against each other case insensitively.
   *
   * @private
   */
  __getItemIndexByLabel(e, t) {
    return !e || !t ? -1 : Qa(e, (i) => this._getItemLabel(i).toString().toLowerCase() === t.toString().toLowerCase());
  }
  /** @private */
  _overlaySelectedItemChanged(e) {
    e.stopPropagation(), !(e.detail.item instanceof Ni) && this.opened && (this._focusedIndex = this.filteredItems.indexOf(e.detail.item), this.close());
  }
  /**
   * Override method inherited from `FocusMixin`
   * to close the overlay on blur and commit the value.
   *
   * @param {boolean} focused
   * @protected
   * @override
   */
  _setFocused(e) {
    if (super._setFocused(e), !e && !this.readonly && !this._closeOnBlurIsPrevented) {
      if (!this.opened && this.allowCustomValue && this._inputElementValue === this._lastCustomValue) {
        delete this._lastCustomValue;
        return;
      }
      if (On()) {
        this._closeOrCommit();
        return;
      }
      this.opened ? this._overlayOpened || this.close() : this._commitValue();
    }
  }
  /**
   * Override method inherited from `FocusMixin` to not remove focused
   * state when focus moves to the overlay.
   *
   * @param {FocusEvent} event
   * @return {boolean}
   * @protected
   * @override
   */
  _shouldRemoveFocus(e) {
    return e.relatedTarget && e.relatedTarget.localName === `${this._tagNamePrefix}-item` ? !1 : e.relatedTarget === this._overlayElement ? (e.composedPath()[0].focus(), !1) : !0;
  }
  /** @private */
  _onTouchend(e) {
    !this.clearElement || e.composedPath()[0] !== this.clearElement || (e.preventDefault(), this._onClearAction());
  }
  /**
   * Fired when the value changes.
   *
   * @event value-changed
   * @param {Object} detail
   * @param {String} detail.value the combobox value
   */
  /**
   * Fired when selected item changes.
   *
   * @event selected-item-changed
   * @param {Object} detail
   * @param {Object|String} detail.value the selected item. Type is the same as the type of `items`.
   */
  /**
   * Fired when the user sets a custom value.
   * @event custom-value-set
   * @param {String} detail the custom value
   */
  /**
   * Fired when value changes.
   * To comply with https://developer.mozilla.org/en-US/docs/Web/Events/change
   * @event change
   */
  /**
   * Fired after the `vaadin-combo-box-overlay` opens.
   *
   * @event vaadin-combo-box-dropdown-opened
   */
  /**
   * Fired after the `vaadin-combo-box-overlay` closes.
   *
   * @event vaadin-combo-box-dropdown-closed
   */
};
/**
 * @license
 * Copyright (c) 2015 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
Qe("vaadin-combo-box", Ap, { moduleId: "vaadin-combo-box-styles" });
class Fp extends Ip(
  zp(Pp(Cp(xr(Hl(mi)))))
) {
  static get is() {
    return "vaadin-combo-box";
  }
  static get template() {
    return Vi`
      <style>
        :host([opened]) {
          pointer-events: auto;
        }
      </style>

      <div class="vaadin-combo-box-container">
        <div part="label">
          <slot name="label"></slot>
          <span part="required-indicator" aria-hidden="true" on-click="focus"></span>
        </div>

        <vaadin-input-container
          part="input-field"
          readonly="[[readonly]]"
          disabled="[[disabled]]"
          invalid="[[invalid]]"
          theme$="[[_theme]]"
        >
          <slot name="prefix" slot="prefix"></slot>
          <slot name="input"></slot>
          <div id="clearButton" part="clear-button" slot="suffix" aria-hidden="true"></div>
          <div id="toggleButton" part="toggle-button" slot="suffix" aria-hidden="true"></div>
        </vaadin-input-container>

        <div part="helper-text">
          <slot name="helper"></slot>
        </div>

        <div part="error-message">
          <slot name="error-message"></slot>
        </div>
      </div>

      <vaadin-combo-box-overlay
        id="overlay"
        opened="[[_overlayOpened]]"
        loading$="[[loading]]"
        theme$="[[_theme]]"
        position-target="[[_positionTarget]]"
        no-vertical-overlap
      ></vaadin-combo-box-overlay>

      <slot name="tooltip"></slot>
    `;
  }
  static get properties() {
    return {
      /**
       * @protected
       */
      _positionTarget: {
        type: Object
      }
    };
  }
  /**
   * Used by `InputControlMixin` as a reference to the clear button element.
   * @protected
   * @return {!HTMLElement}
   */
  get clearElement() {
    return this.$.clearButton;
  }
  /** @protected */
  ready() {
    super.ready(), this.addController(
      new Tp(this, (n) => {
        this._setInputElement(n), this._setFocusElement(n), this.stateTarget = n, this.ariaTarget = n;
      })
    ), this.addController(new Ep(this.inputElement, this._labelController)), this._tooltipController = new Yl(this), this.addController(this._tooltipController), this._tooltipController.setPosition("top"), this._tooltipController.setAriaTarget(this.inputElement), this._tooltipController.setShouldShow((n) => !n.opened), this._positionTarget = this.shadowRoot.querySelector('[part="input-field"]'), this._toggleElement = this.$.toggleButton;
  }
  /**
   * Override the method from `InputControlMixin`
   * to stop event propagation to prevent `ComboBoxMixin`
   * from handling this click event also on its own.
   *
   * @param {Event} event
   * @protected
   * @override
   */
  _onClearButtonClick(n) {
    n.stopPropagation(), super._onClearButtonClick(n);
  }
  /**
   * @param {Event} event
   * @protected
   */
  _onHostClick(n) {
    const e = n.composedPath();
    (e.includes(this._labelNode) || e.includes(this._positionTarget)) && super._onHostClick(n);
  }
}
Zt(Fp);
const Mp = '*{padding:0;margin:0;border:0px;-webkit-user-select:none;user-select:none}p,div{-webkit-user-select:text;user-select:text}select{-webkit-user-select:none;user-select:none}.col-bg-body-lighter{background-color:var(--col-bg-body-lighter)}.col-bg-body{background-color:var(--col-bg-body)}.col-bg-body-darker{background-color:var(--col-bg-body-darker)}.col-bg-1-lighter{background-color:var(--col-bg-1-lighter)}.col-bg-1{background-color:var(--col-bg-1)}.col-bg-1-darker{background-color:var(--col-bg-1-darker)}.col-bg-1-input{background-color:var(--col-bg-1-input)}.col-primary-bg-1{background-color:var(--col-primary-bg-1)}.col-accent-bg-1{background-color:var(--col-accent-bg-1)}.col-success-bg-1{background-color:var(--col-success-bg-1)}.col-warning-bg-1{background-color:var(--col-warning-bg-1)}.col-error-bg-1{background-color:var(--col-error-bg-1)}.col-bg-2-lighter{background-color:var(--col-bg-2-lighter)}.col-bg-2{background-color:var(--col-bg-2)}.col-bg-2-darker{background-color:var(--col-bg-2-darker)}.col-bg-2-button{background-color:var(--col-bg-2-button)}.col-bg-2-input{background-color:var(--col-bg-2-input)}.col-primary-bg-2{background-color:var(--col-primary-bg-2)}.col-accent-bg-2{background-color:var(--col-accent-bg-2)}.col-success-bg-2{background-color:var(--col-success-bg-2)}.col-warning-bg-2{background-color:var(--col-warning-bg-2)}.col-error-bg-2{background-color:var(--col-error-bg-2)}.col-bg-3-lighter{background-color:var(--col-bg-3-lighter)}.col-bg-3{background-color:var(--col-bg-3)}.col-bg-3-darker{background-color:var(--col-bg-3-darker)}.col-bg-3-button{background-color:var(--col-bg-3-button)}.col-bg-3-input{background-color:var(--col-bg-3-input)}.col-primary-bg-3{background-color:var(--col-primary-bg-3)}.col-accent-bg-3{background-color:var(--col-accent-bg-3)}.col-success-bg-3{background-color:var(--col-success-bg-3)}.col-warning-bg-3{background-color:var(--col-warning-bg-3)}.col-error-bg-3{background-color:var(--col-error-bg-3)}.col-bg-ack-lighter{background-color:var(--col-bg-ack-lighter)}.col-bg-ack{background-color:var(--col-bg-ack)}.col-bg-ack-darker{background-color:var(--col-bg-ack-darker)}.col-primary-bg-ack{background-color:var(--col-primary-bg-ack)}.col-accent-bg-ack{background-color:var(--col-accent-bg-ack)}.col-bg-att-lighter{background-color:var(--col-bg-att-lighter)}.col-bg-att{background-color:var(--col-bg-att)}.col-bg-att-darker{background-color:var(--col-bg-att-darker)}.col-primary-bg-att{background-color:var(--col-primary-bg-att)}.col-accent-bg-att{background-color:var(--col-accent-bg-att)}.col-bg-alert-lighter{background-color:var(--col-bg-alert-lighter)}.col-bg-alert{background-color:var(--col-bg-alert)}.col-bg-alert-darker{background-color:var(--col-bg-alert-darker)}.col-primary-bg-alert{background-color:var(--col-primary-bg-alert)}.col-accent-bg-alert{background-color:var(--col-accent-bg-alert)}.col-bg-btn-lighter{background-color:var(--col-bg-btn-lighter)}.col-bg-btn{background-color:var(--col-bg-btn)}.col-bg-btn-darker{background-color:var(--col-bg-btn-darker)}.col-primary-bg-btn{background-color:var(--col-primary-bg-btn)}.col-accent-bg-btn{background-color:var(--col-accent-bg-btn)}.pattern-diagonal-stripes-sm{background:repeating-linear-gradient(45deg,transparent,transparent 10px,currentColor 10px,currentColor 20px)}.pattern-dots-lg{background-image:radial-gradient(currentColor 1.5px,transparent 1.5px);background-size:15px 15px}.pattern-dots-md{background-image:radial-gradient(currentColor 1px,transparent 1px);background-size:8px 8px}.pattern-dots-medium-dense{background-image:radial-gradient(currentColor .5px,transparent .5px);background-size:3px 3px}.pattern-dots-sm{background-image:radial-gradient(currentColor .5px,transparent .5px);background-size:5px 5px}.pattern-cross-dots-md,.imagelist-background{background-image:radial-gradient(currentColor .7px,transparent 1px),radial-gradient(currentColor .7px,transparent 1px);background-size:6.5px 6.5px;background-position:0 0,3.5px 3.5px}.imagelist-background{background-color:#fff9;background-blend-mode:overlay}label{font-family:var(--monospace-font);font-size:.9em}input,select{-webkit-user-select:text;-moz-user-select:text;-ms-user-select:text;box-sizing:border-box;border-radius:0;user-select:text;font-family:var(--standard-text-font);background-color:var(--col-bg-1-input);border:none;color:var(--col-primary-bg-1);padding:2px;margin-bottom:2px;outline:none}textarea{outline:none}input:not([type=radio],[type=checkbox]),select,textarea{width:100%}input:not([type=radio],[type=checkbox]):focus,select:focus,textarea:focus{margin-bottom:0;border-bottom:2px solid rgb(0,0,0)}h1{font-size:var(--font-size-h1)}h2{font-size:var(--font-size-h2)}h3{font-size:var(--font-size-h3)}h4{font-size:var(--font-size-h4)}small,.font-small{font-size:var(--font-size-small)}button{width:60px;height:60px;border-radius:35px;border-style:solid;border-width:2px;background-color:var(--col-bg-btn);color:var(--col-primary-bg-btn);border-color:var(--col-bg-btn-darker);font-family:var(--headline-text-font);font-size:var(--font-size-h4);font-weight:700}button:hover,button:focus{outline:none;background-color:var(--col-bg-btn-lighter)}button:active{padding-top:3px;color:var(--col-primary-bg-btn);background-color:var(--col-bg-btn-darker);border-color:var(--col-bg-btn-darker)}.kiosk-btn-128{width:128px;height:128px}.kiosk-btn-32{width:32px;height:32px}.kiosk-dropdown-btn{box-sizing:content-box;border-radius:0;background-color:var(--col-bg-btn);border-color:var(--col-bg-btn-darker);color:var(--col-primary-bg-btn);height:30px;width:30px}.kiosk-dropdown-btn .drop-down-btn{float:left}.kiosk-dropdown-btn .caret{color:var(--col-primary-bg-btn);display:inline-block;width:0;height:0;margin-left:2px;vertical-align:middle;border-color:var(--col-primary-bg-btn);border-top:4px solid;border-right:4px solid transparent;border-left:4px solid transparent}button:disabled{opacity:.3}.modal-round-button,.modal-delete,.modal-close,.modal-cancel,.modal-back,.modal-next,.modal-ok,.modal-button{box-sizing:border-box;margin-left:25px;background-image:none;display:inline-block;font-style:normal;font-variant:normal;text-rendering:auto;-webkit-font-smoothing:antialiased;font-family:"Font Awesome 6 Free";font-weight:900;font-size:24px;line-height:24px;vertical-align:center;text-align:center}.modal-ok:after{content:var(--icon-bt-ok)}.modal-next:after{padding-left:2px;content:var(--icon-bt-next)}.modal-back:after{padding-right:2px;content:var(--icon-bt-back)}.modal-cancel:after{content:var(--icon-bt-cancel)}.modal-close:before{content:var(--icon-bt-close)}.modal-delete{background-color:var(--col-bg-alert);color:var(--col-primary-bg-alert)}.modal-delete:before{content:var(--icon-bt-trash)}.modal-delete:hover,.modal-delete:focus{border-color:var(--col-bg-alert);background-color:var(--col-bg-alert-lighter);background-size:75%}.modal-delete:active{border-color:var(--col-bg-alert);background-color:var(--col-bg-alert-darker);color:var(--col-primary-bg-alert)}.kiosk-rounded{border-radius:15px}.kiosk-shaded{box-shadow:2px 2px 10px #2e380394}.kiosk-margin-bottom{margin-bottom:1em}.flex-line-break{width:100%;height:0px}.kiosk-align-flex-end{align-items:flex-end}.kiosk-align-flex-start{align-items:flex-start}.full-background-bg-1{background:linear-gradient(to right bottom,var(--col-bg-1-darker),var(--col-bg-1-lighter));height:100%;width:100%}.small-list-button i{border-radius:25px;box-shadow:2px 2px 5px #2e380394}.small-list-button:hover{color:var(--col-bg-att)}.small-list-button:hover i{box-shadow:2px 2px 5px #2e380394}.small-list-button:active,.small-list-button:focus{color:var(--col-bg-ack);transform:translateY(5px)}.small-list-button:active i,.small-list-button:focus i{box-shadow:none}.dialog-radio-div{display:flex;flex-direction:row}.dialog-radio-div input[type=radio]{margin-right:.5em}.rainbow-loading{display:flex;justify-content:center;align-items:center;height:5px;width:100%;background-color:#000}.rainbow-loading.to-top{position:fixed;top:0;z-index:1000}.rainbow-loading-progress{height:5px;width:100%;border-radius:3px;background:linear-gradient(90deg,red,#ff0,#0f0 30%,#0ff 50%,#00f,#f0f 80%,red);background-size:200%;animation:move-gradient 2s ease-in infinite}@keyframes move-gradient{0%{background-position:0% 0%}to{background-position:-200% 0%}}.fa,.fas{font-family:"Font Awesome 6 Free";font-weight:900;font-style:normal}.fa-trash:before{content:""}.fa-view-grid:before{content:""}.fa-reload:before{content:""}.fa-view-list:before{content:""}.fa-camera:before{content:""}.fa-view-image:before{content:""}.fa-check:before{content:""}.fa-bug:before{content:""}.fa-lightbulb:before{content:""}.fa-query:before{content:""}.fa-footsteps{transform:rotate(270deg)}.fa-footsteps:before{content:""}.fa-next:before{content:""}.fa-prev:before{content:""}.fa-hide:before{content:""}.fa-circle-half-stroke:before{content:""}i{font-family:"Font Awesome 6 Free";font-style:normal;font-variant:normal;text-rendering:auto;-webkit-font-smoothing:antialiased;font-weight:900;font-size:.9em}div,p{font-family:var(--standard-text-font)}:host{--lumo-font-size-s: $font-size-standard;--_lumo-grid-secondary-border-color: $col-bg-2-lighter;--_lumo-grid-border-width: 5px;--lumo-font-family: $standard-text;--lumo-size-m: $font-size-standard}vaadin-grid{margin-top:.5em;background-color:var(--col-bg-2);--_lumo-grid-selected-row-color: var(--col-bg-2-darker)}vaadin-grid::part(cell){padding-left:.5em;padding-top:3px;padding-bottom:3px;background-color:var(--col-bg-2)}vaadin-grid::part(header-cell){min-height:auto;padding-top:.2em;padding-bottom:.2em;border-bottom-color:var(--col-bg-2-darker);border-bottom-width:2px;background-color:var(--col-bg-2-darker)}vaadin-grid::part(row){background-color:var(--col-bg-2);color:var(--col-primary-bg-2)}vaadin-grid::part(selected-row){color:var(--col-accent-bg-2)}';
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Mn = (s) => (n, e) => {
  e !== void 0 ? e.addInitializer((() => {
    customElements.define(s, n);
  })) : customElements.define(s, n);
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Lp = { attribute: !0, type: String, converter: pn, reflect: !1, hasChanged: es }, Bp = (s = Lp, n, e) => {
  const { kind: t, metadata: i } = e;
  let r = globalThis.litPropertyMetadata.get(i);
  if (r === void 0 && globalThis.litPropertyMetadata.set(i, r = /* @__PURE__ */ new Map()), t === "setter" && ((s = Object.create(s)).wrapped = !0), r.set(e.name, s), t === "accessor") {
    const { name: o } = e;
    return { set(a) {
      const c = n.get.call(this);
      n.set.call(this, a), this.requestUpdate(o, c, s);
    }, init(a) {
      return a !== void 0 && this.C(o, void 0, s, a), a;
    } };
  }
  if (t === "setter") {
    const { name: o } = e;
    return function(a) {
      const c = this[o];
      n.call(this, a), this.requestUpdate(o, c, s);
    };
  }
  throw Error("Unsupported decorator location: " + t);
};
function Xe(s) {
  return (n, e) => typeof e == "object" ? Bp(s, n, e) : ((t, i, r) => {
    const o = i.hasOwnProperty(r);
    return i.constructor.createProperty(r, t), o ? Object.getOwnPropertyDescriptor(i, r) : void 0;
  })(s, n, e);
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function Pt(s) {
  return Xe({ ...s, state: !0, attribute: !1 });
}
var Np = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function mc(s) {
  return s && s.__esModule && Object.prototype.hasOwnProperty.call(s, "default") ? s.default : s;
}
var ln = { exports: {} }, Hp = ln.exports, Ja;
function Vp() {
  return Ja || (Ja = 1, (function(s, n) {
    (function(e, t) {
      s.exports = t();
    })(Hp, function() {
      var e = function(l, d) {
        return (e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(p, m) {
          p.__proto__ = m;
        } || function(p, m) {
          for (var b in m) Object.prototype.hasOwnProperty.call(m, b) && (p[b] = m[b]);
        })(l, d);
      }, t = function() {
        return (t = Object.assign || function(l) {
          for (var d, p = 1, m = arguments.length; p < m; p++) for (var b in d = arguments[p]) Object.prototype.hasOwnProperty.call(d, b) && (l[b] = d[b]);
          return l;
        }).apply(this, arguments);
      };
      function i(l, d, p) {
        for (var m, b = 0, w = d.length; b < w; b++) !m && b in d || ((m = m || Array.prototype.slice.call(d, 0, b))[b] = d[b]);
        return l.concat(m || Array.prototype.slice.call(d));
      }
      var r = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : Np, o = Object.keys, a = Array.isArray;
      function c(l, d) {
        return typeof d != "object" || o(d).forEach(function(p) {
          l[p] = d[p];
        }), l;
      }
      typeof Promise > "u" || r.Promise || (r.Promise = Promise);
      var u = Object.getPrototypeOf, h = {}.hasOwnProperty;
      function f(l, d) {
        return h.call(l, d);
      }
      function g(l, d) {
        typeof d == "function" && (d = d(u(l))), (typeof Reflect > "u" ? o : Reflect.ownKeys)(d).forEach(function(p) {
          C(l, p, d[p]);
        });
      }
      var x = Object.defineProperty;
      function C(l, d, p, m) {
        x(l, d, c(p && f(p, "get") && typeof p.get == "function" ? { get: p.get, set: p.set, configurable: !0 } : { value: p, configurable: !0, writable: !0 }, m));
      }
      function E(l) {
        return { from: function(d) {
          return l.prototype = Object.create(d.prototype), C(l.prototype, "constructor", l), { extend: g.bind(null, l.prototype) };
        } };
      }
      var R = Object.getOwnPropertyDescriptor, D = [].slice;
      function U(l, d, p) {
        return D.call(l, d, p);
      }
      function Z(l, d) {
        return d(l);
      }
      function ce(l) {
        if (!l) throw new Error("Assertion Failed");
      }
      function re(l) {
        r.setImmediate ? setImmediate(l) : setTimeout(l, 0);
      }
      function ue(l, d) {
        if (typeof d == "string" && f(l, d)) return l[d];
        if (!d) return l;
        if (typeof d != "string") {
          for (var p = [], m = 0, b = d.length; m < b; ++m) {
            var w = ue(l, d[m]);
            p.push(w);
          }
          return p;
        }
        var k = d.indexOf(".");
        if (k !== -1) {
          var A = l[d.substr(0, k)];
          return A == null ? void 0 : ue(A, d.substr(k + 1));
        }
      }
      function me(l, d, p) {
        if (l && d !== void 0 && !("isFrozen" in Object && Object.isFrozen(l))) if (typeof d != "string" && "length" in d) {
          ce(typeof p != "string" && "length" in p);
          for (var m = 0, b = d.length; m < b; ++m) me(l, d[m], p[m]);
        } else {
          var w, k, A = d.indexOf(".");
          A !== -1 ? (w = d.substr(0, A), (k = d.substr(A + 1)) === "" ? p === void 0 ? a(l) && !isNaN(parseInt(w)) ? l.splice(w, 1) : delete l[w] : l[w] = p : me(A = !(A = l[w]) || !f(l, w) ? l[w] = {} : A, k, p)) : p === void 0 ? a(l) && !isNaN(parseInt(d)) ? l.splice(d, 1) : delete l[d] : l[d] = p;
        }
      }
      function Te(l) {
        var d, p = {};
        for (d in l) f(l, d) && (p[d] = l[d]);
        return p;
      }
      var Re = [].concat;
      function He(l) {
        return Re.apply([], l);
      }
      var Se = "BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(He([8, 16, 32, 64].map(function(l) {
        return ["Int", "Uint", "Float"].map(function(d) {
          return d + l + "Array";
        });
      }))).filter(function(l) {
        return r[l];
      }), Fe = new Set(Se.map(function(l) {
        return r[l];
      })), _e = null;
      function Ae(l) {
        return _e = /* @__PURE__ */ new WeakMap(), l = (function d(p) {
          if (!p || typeof p != "object") return p;
          var m = _e.get(p);
          if (m) return m;
          if (a(p)) {
            m = [], _e.set(p, m);
            for (var b = 0, w = p.length; b < w; ++b) m.push(d(p[b]));
          } else if (Fe.has(p.constructor)) m = p;
          else {
            var k, A = u(p);
            for (k in m = A === Object.prototype ? {} : Object.create(A), _e.set(p, m), p) f(p, k) && (m[k] = d(p[k]));
          }
          return m;
        })(l), _e = null, l;
      }
      var Je = {}.toString;
      function Ge(l) {
        return Je.call(l).slice(8, -1);
      }
      var qe = typeof Symbol < "u" ? Symbol.iterator : "@@iterator", nt = typeof qe == "symbol" ? function(l) {
        var d;
        return l != null && (d = l[qe]) && d.apply(l);
      } : function() {
        return null;
      };
      function Ve(l, d) {
        return d = l.indexOf(d), 0 <= d && l.splice(d, 1), 0 <= d;
      }
      var ot = {};
      function $e(l) {
        var d, p, m, b;
        if (arguments.length === 1) {
          if (a(l)) return l.slice();
          if (this === ot && typeof l == "string") return [l];
          if (b = nt(l)) {
            for (p = []; !(m = b.next()).done; ) p.push(m.value);
            return p;
          }
          if (l == null) return [l];
          if (typeof (d = l.length) != "number") return [l];
          for (p = new Array(d); d--; ) p[d] = l[d];
          return p;
        }
        for (d = arguments.length, p = new Array(d); d--; ) p[d] = arguments[d];
        return p;
      }
      var Yt = typeof Symbol < "u" ? function(l) {
        return l[Symbol.toStringTag] === "AsyncFunction";
      } : function() {
        return !1;
      }, Ce = ["Unknown", "Constraint", "Data", "TransactionInactive", "ReadOnly", "Version", "NotFound", "InvalidState", "InvalidAccess", "Abort", "Timeout", "QuotaExceeded", "Syntax", "DataClone"], vt = ["Modify", "Bulk", "OpenFailed", "VersionChange", "Schema", "Upgrade", "InvalidTable", "MissingAPI", "NoSuchDatabase", "InvalidArgument", "SubTransaction", "Unsupported", "Internal", "DatabaseClosed", "PrematureCommit", "ForeignAwait"].concat(Ce), Wi = { VersionChanged: "Database version changed by other database connection", DatabaseClosed: "Database has been closed", Abort: "Transaction aborted", TransactionInactive: "Transaction has already completed or failed", MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb" };
      function be(l, d) {
        this.name = l, this.message = d;
      }
      function Xt(l, d) {
        return l + ". Errors: " + Object.keys(d).map(function(p) {
          return d[p].toString();
        }).filter(function(p, m, b) {
          return b.indexOf(p) === m;
        }).join(`
`);
      }
      function St(l, d, p, m) {
        this.failures = d, this.failedKeys = m, this.successCount = p, this.message = Xt(l, d);
      }
      function _t(l, d) {
        this.name = "BulkError", this.failures = Object.keys(d).map(function(p) {
          return d[p];
        }), this.failuresByPos = d, this.message = Xt(l, this.failures);
      }
      E(be).from(Error).extend({ toString: function() {
        return this.name + ": " + this.message;
      } }), E(St).from(be), E(_t).from(be);
      var xt = vt.reduce(function(l, d) {
        return l[d] = d + "Error", l;
      }, {}), vi = be, fe = vt.reduce(function(l, d) {
        var p = d + "Error";
        function m(b, w) {
          this.name = p, b ? typeof b == "string" ? (this.message = "".concat(b).concat(w ? `
 ` + w : ""), this.inner = w || null) : typeof b == "object" && (this.message = "".concat(b.name, " ").concat(b.message), this.inner = b) : (this.message = Wi[d] || p, this.inner = null);
        }
        return E(m).from(vi), l[d] = m, l;
      }, {});
      fe.Syntax = SyntaxError, fe.Type = TypeError, fe.Range = RangeError;
      var Qt = Ce.reduce(function(l, d) {
        return l[d + "Error"] = fe[d], l;
      }, {}), kt = vt.reduce(function(l, d) {
        return ["Syntax", "Type", "Range"].indexOf(d) === -1 && (l[d + "Error"] = fe[d]), l;
      }, {});
      function Ie() {
      }
      function Ct(l) {
        return l;
      }
      function ji(l, d) {
        return l == null || l === Ct ? d : function(p) {
          return d(l(p));
        };
      }
      function ft(l, d) {
        return function() {
          l.apply(this, arguments), d.apply(this, arguments);
        };
      }
      function Ft(l, d) {
        return l === Ie ? d : function() {
          var p = l.apply(this, arguments);
          p !== void 0 && (arguments[0] = p);
          var m = this.onsuccess, b = this.onerror;
          this.onsuccess = null, this.onerror = null;
          var w = d.apply(this, arguments);
          return m && (this.onsuccess = this.onsuccess ? ft(m, this.onsuccess) : m), b && (this.onerror = this.onerror ? ft(b, this.onerror) : b), w !== void 0 ? w : p;
        };
      }
      function v(l, d) {
        return l === Ie ? d : function() {
          l.apply(this, arguments);
          var p = this.onsuccess, m = this.onerror;
          this.onsuccess = this.onerror = null, d.apply(this, arguments), p && (this.onsuccess = this.onsuccess ? ft(p, this.onsuccess) : p), m && (this.onerror = this.onerror ? ft(m, this.onerror) : m);
        };
      }
      function P(l, d) {
        return l === Ie ? d : function(p) {
          var m = l.apply(this, arguments);
          c(p, m);
          var b = this.onsuccess, w = this.onerror;
          return this.onsuccess = null, this.onerror = null, p = d.apply(this, arguments), b && (this.onsuccess = this.onsuccess ? ft(b, this.onsuccess) : b), w && (this.onerror = this.onerror ? ft(w, this.onerror) : w), m === void 0 ? p === void 0 ? void 0 : p : c(m, p);
        };
      }
      function W(l, d) {
        return l === Ie ? d : function() {
          return d.apply(this, arguments) !== !1 && l.apply(this, arguments);
        };
      }
      function X(l, d) {
        return l === Ie ? d : function() {
          var p = l.apply(this, arguments);
          if (p && typeof p.then == "function") {
            for (var m = this, b = arguments.length, w = new Array(b); b--; ) w[b] = arguments[b];
            return p.then(function() {
              return d.apply(m, w);
            });
          }
          return d.apply(this, arguments);
        };
      }
      kt.ModifyError = St, kt.DexieError = be, kt.BulkError = _t;
      var $ = typeof location < "u" && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
      function he(l) {
        $ = l;
      }
      var Y = {}, ve = 100, Se = typeof Promise > "u" ? [] : (function() {
        var l = Promise.resolve();
        if (typeof crypto > "u" || !crypto.subtle) return [l, u(l), l];
        var d = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
        return [d, u(d), l];
      })(), Ce = Se[0], vt = Se[1], Se = Se[2], vt = vt && vt.then, ge = Ce && Ce.constructor, Le = !!Se, y = function(l, d) {
        pe.push([l, d]), T && (queueMicrotask(Pc), T = !1);
      }, _ = !0, T = !0, S = [], G = [], Q = Ct, de = { id: "global", global: !0, ref: 0, unhandleds: [], onunhandled: Ie, pgp: !1, env: {}, finalize: Ie }, te = de, pe = [], Ke = 0, Ue = [];
      function oe(l) {
        if (typeof this != "object") throw new TypeError("Promises must be constructed via new");
        this._listeners = [], this._lib = !1;
        var d = this._PSD = te;
        if (typeof l != "function") {
          if (l !== Y) throw new TypeError("Not a function");
          return this._state = arguments[1], this._value = arguments[2], void (this._state === !1 && bi(this, this._value));
        }
        this._state = null, this._value = null, ++d.ref, (function p(m, b) {
          try {
            b(function(w) {
              if (m._state === null) {
                if (w === m) throw new TypeError("A promise cannot be resolved with itself.");
                var k = m._lib && yi();
                w && typeof w.then == "function" ? p(m, function(A, O) {
                  w instanceof oe ? w._then(A, O) : w.then(A, O);
                }) : (m._state = !0, m._value = w, ks(m)), k && wi();
              }
            }, bi.bind(null, m));
          } catch (w) {
            bi(m, w);
          }
        })(this, l);
      }
      var _i = { get: function() {
        var l = te, d = kr;
        function p(m, b) {
          var w = this, k = !l.global && (l !== te || d !== kr), A = k && !Lt(), O = new oe(function(F, L) {
            Bn(w, new Gi(As(m, l, k, A), As(b, l, k, A), F, L, l));
          });
          return this._consoleTask && (O._consoleTask = this._consoleTask), O;
        }
        return p.prototype = Y, p;
      }, set: function(l) {
        C(this, "then", l && l.prototype === Y ? _i : { get: function() {
          return l;
        }, set: _i.set });
      } };
      function Gi(l, d, p, m, b) {
        this.onFulfilled = typeof l == "function" ? l : null, this.onRejected = typeof d == "function" ? d : null, this.resolve = p, this.reject = m, this.psd = b;
      }
      function bi(l, d) {
        var p, m;
        G.push(d), l._state === null && (p = l._lib && yi(), d = Q(d), l._state = !1, l._value = d, m = l, S.some(function(b) {
          return b._value === m._value;
        }) || S.push(m), ks(l), p && wi());
      }
      function ks(l) {
        var d = l._listeners;
        l._listeners = [];
        for (var p = 0, m = d.length; p < m; ++p) Bn(l, d[p]);
        var b = l._PSD;
        --b.ref || b.finalize(), Ke === 0 && (++Ke, y(function() {
          --Ke == 0 && Nn();
        }, []));
      }
      function Bn(l, d) {
        if (l._state !== null) {
          var p = l._state ? d.onFulfilled : d.onRejected;
          if (p === null) return (l._state ? d.resolve : d.reject)(l._value);
          ++d.psd.ref, ++Ke, y(Ec, [p, l, d]);
        } else l._listeners.push(d);
      }
      function Ec(l, d, p) {
        try {
          var m, b = d._value;
          !d._state && G.length && (G = []), m = $ && d._consoleTask ? d._consoleTask.run(function() {
            return l(b);
          }) : l(b), d._state || G.indexOf(b) !== -1 || (function(w) {
            for (var k = S.length; k; ) if (S[--k]._value === w._value) return S.splice(k, 1);
          })(d), p.resolve(m);
        } catch (w) {
          p.reject(w);
        } finally {
          --Ke == 0 && Nn(), --p.psd.ref || p.psd.finalize();
        }
      }
      function Pc() {
        Jt(de, function() {
          yi() && wi();
        });
      }
      function yi() {
        var l = _;
        return T = _ = !1, l;
      }
      function wi() {
        var l, d, p;
        do
          for (; 0 < pe.length; ) for (l = pe, pe = [], p = l.length, d = 0; d < p; ++d) {
            var m = l[d];
            m[0].apply(null, m[1]);
          }
        while (0 < pe.length);
        T = _ = !0;
      }
      function Nn() {
        var l = S;
        S = [], l.forEach(function(m) {
          m._PSD.onunhandled.call(null, m._value, m);
        });
        for (var d = Ue.slice(0), p = d.length; p; ) d[--p]();
      }
      function Er(l) {
        return new oe(Y, !1, l);
      }
      function Ne(l, d) {
        var p = te;
        return function() {
          var m = yi(), b = te;
          try {
            return Bt(p, !0), l.apply(this, arguments);
          } catch (w) {
            d && d(w);
          } finally {
            Bt(b, !1), m && wi();
          }
        };
      }
      g(oe.prototype, { then: _i, _then: function(l, d) {
        Bn(this, new Gi(null, null, l, d, te));
      }, catch: function(l) {
        if (arguments.length === 1) return this.then(null, l);
        var d = l, p = arguments[1];
        return typeof d == "function" ? this.then(null, function(m) {
          return (m instanceof d ? p : Er)(m);
        }) : this.then(null, function(m) {
          return (m && m.name === d ? p : Er)(m);
        });
      }, finally: function(l) {
        return this.then(function(d) {
          return oe.resolve(l()).then(function() {
            return d;
          });
        }, function(d) {
          return oe.resolve(l()).then(function() {
            return Er(d);
          });
        });
      }, timeout: function(l, d) {
        var p = this;
        return l < 1 / 0 ? new oe(function(m, b) {
          var w = setTimeout(function() {
            return b(new fe.Timeout(d));
          }, l);
          p.then(m, b).finally(clearTimeout.bind(null, w));
        }) : this;
      } }), typeof Symbol < "u" && Symbol.toStringTag && C(oe.prototype, Symbol.toStringTag, "Dexie.Promise"), de.env = Rs(), g(oe, { all: function() {
        var l = $e.apply(null, arguments).map(Rr);
        return new oe(function(d, p) {
          l.length === 0 && d([]);
          var m = l.length;
          l.forEach(function(b, w) {
            return oe.resolve(b).then(function(k) {
              l[w] = k, --m || d(l);
            }, p);
          });
        });
      }, resolve: function(l) {
        return l instanceof oe ? l : l && typeof l.then == "function" ? new oe(function(d, p) {
          l.then(d, p);
        }) : new oe(Y, !0, l);
      }, reject: Er, race: function() {
        var l = $e.apply(null, arguments).map(Rr);
        return new oe(function(d, p) {
          l.map(function(m) {
            return oe.resolve(m).then(d, p);
          });
        });
      }, PSD: { get: function() {
        return te;
      }, set: function(l) {
        return te = l;
      } }, totalEchoes: { get: function() {
        return kr;
      } }, newPSD: Mt, usePSD: Jt, scheduler: { get: function() {
        return y;
      }, set: function(l) {
        y = l;
      } }, rejectionMapper: { get: function() {
        return Q;
      }, set: function(l) {
        Q = l;
      } }, follow: function(l, d) {
        return new oe(function(p, m) {
          return Mt(function(b, w) {
            var k = te;
            k.unhandleds = [], k.onunhandled = w, k.finalize = ft(function() {
              var A, O = this;
              A = function() {
                O.unhandleds.length === 0 ? b() : w(O.unhandleds[0]);
              }, Ue.push(function F() {
                A(), Ue.splice(Ue.indexOf(F), 1);
              }), ++Ke, y(function() {
                --Ke == 0 && Nn();
              }, []);
            }, k.finalize), l();
          }, d, p, m);
        });
      } }), ge && (ge.allSettled && C(oe, "allSettled", function() {
        var l = $e.apply(null, arguments).map(Rr);
        return new oe(function(d) {
          l.length === 0 && d([]);
          var p = l.length, m = new Array(p);
          l.forEach(function(b, w) {
            return oe.resolve(b).then(function(k) {
              return m[w] = { status: "fulfilled", value: k };
            }, function(k) {
              return m[w] = { status: "rejected", reason: k };
            }).then(function() {
              return --p || d(m);
            });
          });
        });
      }), ge.any && typeof AggregateError < "u" && C(oe, "any", function() {
        var l = $e.apply(null, arguments).map(Rr);
        return new oe(function(d, p) {
          l.length === 0 && p(new AggregateError([]));
          var m = l.length, b = new Array(m);
          l.forEach(function(w, k) {
            return oe.resolve(w).then(function(A) {
              return d(A);
            }, function(A) {
              b[k] = A, --m || p(new AggregateError(b));
            });
          });
        });
      }), ge.withResolvers && (oe.withResolvers = ge.withResolvers));
      var et = { awaits: 0, echoes: 0, id: 0 }, Sc = 0, Pr = [], Sr = 0, kr = 0, kc = 0;
      function Mt(l, d, p, m) {
        var b = te, w = Object.create(b);
        return w.parent = b, w.ref = 0, w.global = !1, w.id = ++kc, de.env, w.env = Le ? { Promise: oe, PromiseProp: { value: oe, configurable: !0, writable: !0 }, all: oe.all, race: oe.race, allSettled: oe.allSettled, any: oe.any, resolve: oe.resolve, reject: oe.reject } : {}, d && c(w, d), ++b.ref, w.finalize = function() {
          --this.parent.ref || this.parent.finalize();
        }, m = Jt(w, l, p, m), w.ref === 0 && w.finalize(), m;
      }
      function xi() {
        return et.id || (et.id = ++Sc), ++et.awaits, et.echoes += ve, et.id;
      }
      function Lt() {
        return !!et.awaits && (--et.awaits == 0 && (et.id = 0), et.echoes = et.awaits * ve, !0);
      }
      function Rr(l) {
        return et.echoes && l && l.constructor === ge ? (xi(), l.then(function(d) {
          return Lt(), d;
        }, function(d) {
          return Lt(), Ze(d);
        })) : l;
      }
      function Rc() {
        var l = Pr[Pr.length - 1];
        Pr.pop(), Bt(l, !1);
      }
      function Bt(l, d) {
        var p, m = te;
        (d ? !et.echoes || Sr++ && l === te : !Sr || --Sr && l === te) || queueMicrotask(d ? (function(b) {
          ++kr, et.echoes && --et.echoes != 0 || (et.echoes = et.awaits = et.id = 0), Pr.push(te), Bt(b, !0);
        }).bind(null, l) : Rc), l !== te && (te = l, m === de && (de.env = Rs()), Le && (p = de.env.Promise, d = l.env, (m.global || l.global) && (Object.defineProperty(r, "Promise", d.PromiseProp), p.all = d.all, p.race = d.race, p.resolve = d.resolve, p.reject = d.reject, d.allSettled && (p.allSettled = d.allSettled), d.any && (p.any = d.any))));
      }
      function Rs() {
        var l = r.Promise;
        return Le ? { Promise: l, PromiseProp: Object.getOwnPropertyDescriptor(r, "Promise"), all: l.all, race: l.race, allSettled: l.allSettled, any: l.any, resolve: l.resolve, reject: l.reject } : {};
      }
      function Jt(l, d, p, m, b) {
        var w = te;
        try {
          return Bt(l, !0), d(p, m, b);
        } finally {
          Bt(w, !1);
        }
      }
      function As(l, d, p, m) {
        return typeof l != "function" ? l : function() {
          var b = te;
          p && xi(), Bt(d, !0);
          try {
            return l.apply(this, arguments);
          } finally {
            Bt(b, !1), m && queueMicrotask(Lt);
          }
        };
      }
      function Hn(l) {
        Promise === ge && et.echoes === 0 ? Sr === 0 ? l() : enqueueNativeMicroTask(l) : setTimeout(l, 0);
      }
      ("" + vt).indexOf("[native code]") === -1 && (xi = Lt = Ie);
      var Ze = oe.reject, $t = "", Rt = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.", Is = "String expected.", Ci = [], Ar = "__dbnames", Vn = "readonly", Un = "readwrite";
      function ei(l, d) {
        return l ? d ? function() {
          return l.apply(this, arguments) && d.apply(this, arguments);
        } : l : d;
      }
      var Ds = { type: 3, lower: -1 / 0, lowerOpen: !1, upper: [[]], upperOpen: !1 };
      function Ir(l) {
        return typeof l != "string" || /\./.test(l) ? function(d) {
          return d;
        } : function(d) {
          return d[l] === void 0 && l in d && delete (d = Ae(d))[l], d;
        };
      }
      function Os() {
        throw fe.Type("Entity instances must never be new:ed. Instances are generated by the framework bypassing the constructor.");
      }
      function Ee(l, d) {
        try {
          var p = zs(l), m = zs(d);
          if (p !== m) return p === "Array" ? 1 : m === "Array" ? -1 : p === "binary" ? 1 : m === "binary" ? -1 : p === "string" ? 1 : m === "string" ? -1 : p === "Date" ? 1 : m !== "Date" ? NaN : -1;
          switch (p) {
            case "number":
            case "Date":
            case "string":
              return d < l ? 1 : l < d ? -1 : 0;
            case "binary":
              return (function(b, w) {
                for (var k = b.length, A = w.length, O = k < A ? k : A, F = 0; F < O; ++F) if (b[F] !== w[F]) return b[F] < w[F] ? -1 : 1;
                return k === A ? 0 : k < A ? -1 : 1;
              })(Fs(l), Fs(d));
            case "Array":
              return (function(b, w) {
                for (var k = b.length, A = w.length, O = k < A ? k : A, F = 0; F < O; ++F) {
                  var L = Ee(b[F], w[F]);
                  if (L !== 0) return L;
                }
                return k === A ? 0 : k < A ? -1 : 1;
              })(l, d);
          }
        } catch {
        }
        return NaN;
      }
      function zs(l) {
        var d = typeof l;
        return d != "object" ? d : ArrayBuffer.isView(l) ? "binary" : (l = Ge(l), l === "ArrayBuffer" ? "binary" : l);
      }
      function Fs(l) {
        return l instanceof Uint8Array ? l : ArrayBuffer.isView(l) ? new Uint8Array(l.buffer, l.byteOffset, l.byteLength) : new Uint8Array(l);
      }
      function Dr(l, d, p) {
        var m = l.schema.yProps;
        return m ? (d && 0 < p.numFailures && (d = d.filter(function(b, w) {
          return !p.failures[w];
        })), Promise.all(m.map(function(b) {
          return b = b.updatesTable, d ? l.db.table(b).where("k").anyOf(d).delete() : l.db.table(b).clear();
        })).then(function() {
          return p;
        })) : p;
      }
      var Ms = (Be.prototype._trans = function(l, d, p) {
        var m = this._tx || te.trans, b = this.name, w = $ && typeof console < "u" && console.createTask && console.createTask("Dexie: ".concat(l === "readonly" ? "read" : "write", " ").concat(this.name));
        function k(F, L, I) {
          if (!I.schema[b]) throw new fe.NotFound("Table " + b + " not part of transaction");
          return d(I.idbtrans, I);
        }
        var A = yi();
        try {
          var O = m && m.db._novip === this.db._novip ? m === te.trans ? m._promise(l, k, p) : Mt(function() {
            return m._promise(l, k, p);
          }, { trans: m, transless: te.transless || te }) : (function F(L, I, H, z) {
            if (L.idbdb && (L._state.openComplete || te.letThrough || L._vip)) {
              var M = L._createTransaction(I, H, L._dbSchema);
              try {
                M.create(), L._state.PR1398_maxLoop = 3;
              } catch (N) {
                return N.name === xt.InvalidState && L.isOpen() && 0 < --L._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), L.close({ disableAutoOpen: !1 }), L.open().then(function() {
                  return F(L, I, H, z);
                })) : Ze(N);
              }
              return M._promise(I, function(N, B) {
                return Mt(function() {
                  return te.trans = M, z(N, B, M);
                });
              }).then(function(N) {
                if (I === "readwrite") try {
                  M.idbtrans.commit();
                } catch {
                }
                return I === "readonly" ? N : M._completion.then(function() {
                  return N;
                });
              });
            }
            if (L._state.openComplete) return Ze(new fe.DatabaseClosed(L._state.dbOpenError));
            if (!L._state.isBeingOpened) {
              if (!L._state.autoOpen) return Ze(new fe.DatabaseClosed());
              L.open().catch(Ie);
            }
            return L._state.dbReadyPromise.then(function() {
              return F(L, I, H, z);
            });
          })(this.db, l, [this.name], k);
          return w && (O._consoleTask = w, O = O.catch(function(F) {
            return console.trace(F), Ze(F);
          })), O;
        } finally {
          A && wi();
        }
      }, Be.prototype.get = function(l, d) {
        var p = this;
        return l && l.constructor === Object ? this.where(l).first(d) : l == null ? Ze(new fe.Type("Invalid argument to Table.get()")) : this._trans("readonly", function(m) {
          return p.core.get({ trans: m, key: l }).then(function(b) {
            return p.hook.reading.fire(b);
          });
        }).then(d);
      }, Be.prototype.where = function(l) {
        if (typeof l == "string") return new this.db.WhereClause(this, l);
        if (a(l)) return new this.db.WhereClause(this, "[".concat(l.join("+"), "]"));
        var d = o(l);
        if (d.length === 1) return this.where(d[0]).equals(l[d[0]]);
        var p = this.schema.indexes.concat(this.schema.primKey).filter(function(A) {
          if (A.compound && d.every(function(F) {
            return 0 <= A.keyPath.indexOf(F);
          })) {
            for (var O = 0; O < d.length; ++O) if (d.indexOf(A.keyPath[O]) === -1) return !1;
            return !0;
          }
          return !1;
        }).sort(function(A, O) {
          return A.keyPath.length - O.keyPath.length;
        })[0];
        if (p && this.db._maxKey !== $t) {
          var w = p.keyPath.slice(0, d.length);
          return this.where(w).equals(w.map(function(O) {
            return l[O];
          }));
        }
        !p && $ && console.warn("The query ".concat(JSON.stringify(l), " on ").concat(this.name, " would benefit from a ") + "compound index [".concat(d.join("+"), "]"));
        var m = this.schema.idxByName;
        function b(A, O) {
          return Ee(A, O) === 0;
        }
        var k = d.reduce(function(I, O) {
          var F = I[0], L = I[1], I = m[O], H = l[O];
          return [F || I, F || !I ? ei(L, I && I.multi ? function(z) {
            return z = ue(z, O), a(z) && z.some(function(M) {
              return b(H, M);
            });
          } : function(z) {
            return b(H, ue(z, O));
          }) : L];
        }, [null, null]), w = k[0], k = k[1];
        return w ? this.where(w.name).equals(l[w.keyPath]).filter(k) : p ? this.filter(k) : this.where(d).equals("");
      }, Be.prototype.filter = function(l) {
        return this.toCollection().and(l);
      }, Be.prototype.count = function(l) {
        return this.toCollection().count(l);
      }, Be.prototype.offset = function(l) {
        return this.toCollection().offset(l);
      }, Be.prototype.limit = function(l) {
        return this.toCollection().limit(l);
      }, Be.prototype.each = function(l) {
        return this.toCollection().each(l);
      }, Be.prototype.toArray = function(l) {
        return this.toCollection().toArray(l);
      }, Be.prototype.toCollection = function() {
        return new this.db.Collection(new this.db.WhereClause(this));
      }, Be.prototype.orderBy = function(l) {
        return new this.db.Collection(new this.db.WhereClause(this, a(l) ? "[".concat(l.join("+"), "]") : l));
      }, Be.prototype.reverse = function() {
        return this.toCollection().reverse();
      }, Be.prototype.mapToClass = function(l) {
        var d, p = this.db, m = this.name;
        function b() {
          return d !== null && d.apply(this, arguments) || this;
        }
        (this.schema.mappedClass = l).prototype instanceof Os && ((function(O, F) {
          if (typeof F != "function" && F !== null) throw new TypeError("Class extends value " + String(F) + " is not a constructor or null");
          function L() {
            this.constructor = O;
          }
          e(O, F), O.prototype = F === null ? Object.create(F) : (L.prototype = F.prototype, new L());
        })(b, d = l), Object.defineProperty(b.prototype, "db", { get: function() {
          return p;
        }, enumerable: !1, configurable: !0 }), b.prototype.table = function() {
          return m;
        }, l = b);
        for (var w = /* @__PURE__ */ new Set(), k = l.prototype; k; k = u(k)) Object.getOwnPropertyNames(k).forEach(function(O) {
          return w.add(O);
        });
        function A(O) {
          if (!O) return O;
          var F, L = Object.create(l.prototype);
          for (F in O) if (!w.has(F)) try {
            L[F] = O[F];
          } catch {
          }
          return L;
        }
        return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = A, this.hook("reading", A), l;
      }, Be.prototype.defineClass = function() {
        return this.mapToClass(function(l) {
          c(this, l);
        });
      }, Be.prototype.add = function(l, d) {
        var p = this, m = this.schema.primKey, b = m.auto, w = m.keyPath, k = l;
        return w && b && (k = Ir(w)(l)), this._trans("readwrite", function(A) {
          return p.core.mutate({ trans: A, type: "add", keys: d != null ? [d] : null, values: [k] });
        }).then(function(A) {
          return A.numFailures ? oe.reject(A.failures[0]) : A.lastResult;
        }).then(function(A) {
          if (w) try {
            me(l, w, A);
          } catch {
          }
          return A;
        });
      }, Be.prototype.update = function(l, d) {
        return typeof l != "object" || a(l) ? this.where(":id").equals(l).modify(d) : (l = ue(l, this.schema.primKey.keyPath), l === void 0 ? Ze(new fe.InvalidArgument("Given object does not contain its primary key")) : this.where(":id").equals(l).modify(d));
      }, Be.prototype.put = function(l, d) {
        var p = this, m = this.schema.primKey, b = m.auto, w = m.keyPath, k = l;
        return w && b && (k = Ir(w)(l)), this._trans("readwrite", function(A) {
          return p.core.mutate({ trans: A, type: "put", values: [k], keys: d != null ? [d] : null });
        }).then(function(A) {
          return A.numFailures ? oe.reject(A.failures[0]) : A.lastResult;
        }).then(function(A) {
          if (w) try {
            me(l, w, A);
          } catch {
          }
          return A;
        });
      }, Be.prototype.delete = function(l) {
        var d = this;
        return this._trans("readwrite", function(p) {
          return d.core.mutate({ trans: p, type: "delete", keys: [l] }).then(function(m) {
            return Dr(d, [l], m);
          }).then(function(m) {
            return m.numFailures ? oe.reject(m.failures[0]) : void 0;
          });
        });
      }, Be.prototype.clear = function() {
        var l = this;
        return this._trans("readwrite", function(d) {
          return l.core.mutate({ trans: d, type: "deleteRange", range: Ds }).then(function(p) {
            return Dr(l, null, p);
          });
        }).then(function(d) {
          return d.numFailures ? oe.reject(d.failures[0]) : void 0;
        });
      }, Be.prototype.bulkGet = function(l) {
        var d = this;
        return this._trans("readonly", function(p) {
          return d.core.getMany({ keys: l, trans: p }).then(function(m) {
            return m.map(function(b) {
              return d.hook.reading.fire(b);
            });
          });
        });
      }, Be.prototype.bulkAdd = function(l, d, p) {
        var m = this, b = Array.isArray(d) ? d : void 0, w = (p = p || (b ? void 0 : d)) ? p.allKeys : void 0;
        return this._trans("readwrite", function(k) {
          var F = m.schema.primKey, A = F.auto, F = F.keyPath;
          if (F && b) throw new fe.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
          if (b && b.length !== l.length) throw new fe.InvalidArgument("Arguments objects and keys must have the same length");
          var O = l.length, F = F && A ? l.map(Ir(F)) : l;
          return m.core.mutate({ trans: k, type: "add", keys: b, values: F, wantResults: w }).then(function(M) {
            var I = M.numFailures, H = M.results, z = M.lastResult, M = M.failures;
            if (I === 0) return w ? H : z;
            throw new _t("".concat(m.name, ".bulkAdd(): ").concat(I, " of ").concat(O, " operations failed"), M);
          });
        });
      }, Be.prototype.bulkPut = function(l, d, p) {
        var m = this, b = Array.isArray(d) ? d : void 0, w = (p = p || (b ? void 0 : d)) ? p.allKeys : void 0;
        return this._trans("readwrite", function(k) {
          var F = m.schema.primKey, A = F.auto, F = F.keyPath;
          if (F && b) throw new fe.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
          if (b && b.length !== l.length) throw new fe.InvalidArgument("Arguments objects and keys must have the same length");
          var O = l.length, F = F && A ? l.map(Ir(F)) : l;
          return m.core.mutate({ trans: k, type: "put", keys: b, values: F, wantResults: w }).then(function(M) {
            var I = M.numFailures, H = M.results, z = M.lastResult, M = M.failures;
            if (I === 0) return w ? H : z;
            throw new _t("".concat(m.name, ".bulkPut(): ").concat(I, " of ").concat(O, " operations failed"), M);
          });
        });
      }, Be.prototype.bulkUpdate = function(l) {
        var d = this, p = this.core, m = l.map(function(k) {
          return k.key;
        }), b = l.map(function(k) {
          return k.changes;
        }), w = [];
        return this._trans("readwrite", function(k) {
          return p.getMany({ trans: k, keys: m, cache: "clone" }).then(function(A) {
            var O = [], F = [];
            l.forEach(function(I, H) {
              var z = I.key, M = I.changes, N = A[H];
              if (N) {
                for (var B = 0, V = Object.keys(M); B < V.length; B++) {
                  var j = V[B], q = M[j];
                  if (j === d.schema.primKey.keyPath) {
                    if (Ee(q, z) !== 0) throw new fe.Constraint("Cannot update primary key in bulkUpdate()");
                  } else me(N, j, q);
                }
                w.push(H), O.push(z), F.push(N);
              }
            });
            var L = O.length;
            return p.mutate({ trans: k, type: "put", keys: O, values: F, updates: { keys: m, changeSpecs: b } }).then(function(I) {
              var H = I.numFailures, z = I.failures;
              if (H === 0) return L;
              for (var M = 0, N = Object.keys(z); M < N.length; M++) {
                var B, V = N[M], j = w[Number(V)];
                j != null && (B = z[V], delete z[V], z[j] = B);
              }
              throw new _t("".concat(d.name, ".bulkUpdate(): ").concat(H, " of ").concat(L, " operations failed"), z);
            });
          });
        });
      }, Be.prototype.bulkDelete = function(l) {
        var d = this, p = l.length;
        return this._trans("readwrite", function(m) {
          return d.core.mutate({ trans: m, type: "delete", keys: l }).then(function(b) {
            return Dr(d, l, b);
          });
        }).then(function(k) {
          var b = k.numFailures, w = k.lastResult, k = k.failures;
          if (b === 0) return w;
          throw new _t("".concat(d.name, ".bulkDelete(): ").concat(b, " of ").concat(p, " operations failed"), k);
        });
      }, Be);
      function Be() {
      }
      function qi(l) {
        function d(k, A) {
          if (A) {
            for (var O = arguments.length, F = new Array(O - 1); --O; ) F[O - 1] = arguments[O];
            return p[k].subscribe.apply(null, F), l;
          }
          if (typeof k == "string") return p[k];
        }
        var p = {};
        d.addEventType = w;
        for (var m = 1, b = arguments.length; m < b; ++m) w(arguments[m]);
        return d;
        function w(k, A, O) {
          if (typeof k != "object") {
            var F;
            A = A || W;
            var L = { subscribers: [], fire: O = O || Ie, subscribe: function(I) {
              L.subscribers.indexOf(I) === -1 && (L.subscribers.push(I), L.fire = A(L.fire, I));
            }, unsubscribe: function(I) {
              L.subscribers = L.subscribers.filter(function(H) {
                return H !== I;
              }), L.fire = L.subscribers.reduce(A, O);
            } };
            return p[k] = d[k] = L;
          }
          o(F = k).forEach(function(I) {
            var H = F[I];
            if (a(H)) w(I, F[I][0], F[I][1]);
            else {
              if (H !== "asap") throw new fe.InvalidArgument("Invalid event config");
              var z = w(I, Ct, function() {
                for (var M = arguments.length, N = new Array(M); M--; ) N[M] = arguments[M];
                z.subscribers.forEach(function(B) {
                  re(function() {
                    B.apply(null, N);
                  });
                });
              });
            }
          });
        }
      }
      function Ki(l, d) {
        return E(d).from({ prototype: l }), d;
      }
      function Ti(l, d) {
        return !(l.filter || l.algorithm || l.or) && (d ? l.justLimit : !l.replayFilter);
      }
      function Wn(l, d) {
        l.filter = ei(l.filter, d);
      }
      function jn(l, d, p) {
        var m = l.replayFilter;
        l.replayFilter = m ? function() {
          return ei(m(), d());
        } : d, l.justLimit = p && !m;
      }
      function Or(l, d) {
        if (l.isPrimKey) return d.primaryKey;
        var p = d.getIndexByKeyPath(l.index);
        if (!p) throw new fe.Schema("KeyPath " + l.index + " on object store " + d.name + " is not indexed");
        return p;
      }
      function Ls(l, d, p) {
        var m = Or(l, d.schema);
        return d.openCursor({ trans: p, values: !l.keysOnly, reverse: l.dir === "prev", unique: !!l.unique, query: { index: m, range: l.range } });
      }
      function zr(l, d, p, m) {
        var b = l.replayFilter ? ei(l.filter, l.replayFilter()) : l.filter;
        if (l.or) {
          var w = {}, k = function(A, O, F) {
            var L, I;
            b && !b(O, F, function(H) {
              return O.stop(H);
            }, function(H) {
              return O.fail(H);
            }) || ((I = "" + (L = O.primaryKey)) == "[object ArrayBuffer]" && (I = "" + new Uint8Array(L)), f(w, I) || (w[I] = !0, d(A, O, F)));
          };
          return Promise.all([l.or._iterate(k, p), Bs(Ls(l, m, p), l.algorithm, k, !l.keysOnly && l.valueMapper)]);
        }
        return Bs(Ls(l, m, p), ei(l.algorithm, b), d, !l.keysOnly && l.valueMapper);
      }
      function Bs(l, d, p, m) {
        var b = Ne(m ? function(w, k, A) {
          return p(m(w), k, A);
        } : p);
        return l.then(function(w) {
          if (w) return w.start(function() {
            var k = function() {
              return w.continue();
            };
            d && !d(w, function(A) {
              return k = A;
            }, function(A) {
              w.stop(A), k = Ie;
            }, function(A) {
              w.fail(A), k = Ie;
            }) || b(w.value, w, function(A) {
              return k = A;
            }), k();
          });
        });
      }
      var Zi = (Ns.prototype.execute = function(l) {
        var d = this["@@propmod"];
        if (d.add !== void 0) {
          var p = d.add;
          if (a(p)) return i(i([], a(l) ? l : [], !0), p).sort();
          if (typeof p == "number") return (Number(l) || 0) + p;
          if (typeof p == "bigint") try {
            return BigInt(l) + p;
          } catch {
            return BigInt(0) + p;
          }
          throw new TypeError("Invalid term ".concat(p));
        }
        if (d.remove !== void 0) {
          var m = d.remove;
          if (a(m)) return a(l) ? l.filter(function(b) {
            return !m.includes(b);
          }).sort() : [];
          if (typeof m == "number") return Number(l) - m;
          if (typeof m == "bigint") try {
            return BigInt(l) - m;
          } catch {
            return BigInt(0) - m;
          }
          throw new TypeError("Invalid subtrahend ".concat(m));
        }
        return p = (p = d.replacePrefix) === null || p === void 0 ? void 0 : p[0], p && typeof l == "string" && l.startsWith(p) ? d.replacePrefix[1] + l.substring(p.length) : l;
      }, Ns);
      function Ns(l) {
        this["@@propmod"] = l;
      }
      var Ac = (De.prototype._read = function(l, d) {
        var p = this._ctx;
        return p.error ? p.table._trans(null, Ze.bind(null, p.error)) : p.table._trans("readonly", l).then(d);
      }, De.prototype._write = function(l) {
        var d = this._ctx;
        return d.error ? d.table._trans(null, Ze.bind(null, d.error)) : d.table._trans("readwrite", l, "locked");
      }, De.prototype._addAlgorithm = function(l) {
        var d = this._ctx;
        d.algorithm = ei(d.algorithm, l);
      }, De.prototype._iterate = function(l, d) {
        return zr(this._ctx, l, d, this._ctx.table.core);
      }, De.prototype.clone = function(l) {
        var d = Object.create(this.constructor.prototype), p = Object.create(this._ctx);
        return l && c(p, l), d._ctx = p, d;
      }, De.prototype.raw = function() {
        return this._ctx.valueMapper = null, this;
      }, De.prototype.each = function(l) {
        var d = this._ctx;
        return this._read(function(p) {
          return zr(d, l, p, d.table.core);
        });
      }, De.prototype.count = function(l) {
        var d = this;
        return this._read(function(p) {
          var m = d._ctx, b = m.table.core;
          if (Ti(m, !0)) return b.count({ trans: p, query: { index: Or(m, b.schema), range: m.range } }).then(function(k) {
            return Math.min(k, m.limit);
          });
          var w = 0;
          return zr(m, function() {
            return ++w, !1;
          }, p, b).then(function() {
            return w;
          });
        }).then(l);
      }, De.prototype.sortBy = function(l, d) {
        var p = l.split(".").reverse(), m = p[0], b = p.length - 1;
        function w(O, F) {
          return F ? w(O[p[F]], F - 1) : O[m];
        }
        var k = this._ctx.dir === "next" ? 1 : -1;
        function A(O, F) {
          return Ee(w(O, b), w(F, b)) * k;
        }
        return this.toArray(function(O) {
          return O.sort(A);
        }).then(d);
      }, De.prototype.toArray = function(l) {
        var d = this;
        return this._read(function(p) {
          var m = d._ctx;
          if (m.dir === "next" && Ti(m, !0) && 0 < m.limit) {
            var b = m.valueMapper, w = Or(m, m.table.core.schema);
            return m.table.core.query({ trans: p, limit: m.limit, values: !0, query: { index: w, range: m.range } }).then(function(A) {
              return A = A.result, b ? A.map(b) : A;
            });
          }
          var k = [];
          return zr(m, function(A) {
            return k.push(A);
          }, p, m.table.core).then(function() {
            return k;
          });
        }, l);
      }, De.prototype.offset = function(l) {
        var d = this._ctx;
        return l <= 0 || (d.offset += l, Ti(d) ? jn(d, function() {
          var p = l;
          return function(m, b) {
            return p === 0 || (p === 1 ? --p : b(function() {
              m.advance(p), p = 0;
            }), !1);
          };
        }) : jn(d, function() {
          var p = l;
          return function() {
            return --p < 0;
          };
        })), this;
      }, De.prototype.limit = function(l) {
        return this._ctx.limit = Math.min(this._ctx.limit, l), jn(this._ctx, function() {
          var d = l;
          return function(p, m, b) {
            return --d <= 0 && m(b), 0 <= d;
          };
        }, !0), this;
      }, De.prototype.until = function(l, d) {
        return Wn(this._ctx, function(p, m, b) {
          return !l(p.value) || (m(b), d);
        }), this;
      }, De.prototype.first = function(l) {
        return this.limit(1).toArray(function(d) {
          return d[0];
        }).then(l);
      }, De.prototype.last = function(l) {
        return this.reverse().first(l);
      }, De.prototype.filter = function(l) {
        var d;
        return Wn(this._ctx, function(p) {
          return l(p.value);
        }), (d = this._ctx).isMatch = ei(d.isMatch, l), this;
      }, De.prototype.and = function(l) {
        return this.filter(l);
      }, De.prototype.or = function(l) {
        return new this.db.WhereClause(this._ctx.table, l, this);
      }, De.prototype.reverse = function() {
        return this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev", this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this;
      }, De.prototype.desc = function() {
        return this.reverse();
      }, De.prototype.eachKey = function(l) {
        var d = this._ctx;
        return d.keysOnly = !d.isMatch, this.each(function(p, m) {
          l(m.key, m);
        });
      }, De.prototype.eachUniqueKey = function(l) {
        return this._ctx.unique = "unique", this.eachKey(l);
      }, De.prototype.eachPrimaryKey = function(l) {
        var d = this._ctx;
        return d.keysOnly = !d.isMatch, this.each(function(p, m) {
          l(m.primaryKey, m);
        });
      }, De.prototype.keys = function(l) {
        var d = this._ctx;
        d.keysOnly = !d.isMatch;
        var p = [];
        return this.each(function(m, b) {
          p.push(b.key);
        }).then(function() {
          return p;
        }).then(l);
      }, De.prototype.primaryKeys = function(l) {
        var d = this._ctx;
        if (d.dir === "next" && Ti(d, !0) && 0 < d.limit) return this._read(function(m) {
          var b = Or(d, d.table.core.schema);
          return d.table.core.query({ trans: m, values: !1, limit: d.limit, query: { index: b, range: d.range } });
        }).then(function(m) {
          return m.result;
        }).then(l);
        d.keysOnly = !d.isMatch;
        var p = [];
        return this.each(function(m, b) {
          p.push(b.primaryKey);
        }).then(function() {
          return p;
        }).then(l);
      }, De.prototype.uniqueKeys = function(l) {
        return this._ctx.unique = "unique", this.keys(l);
      }, De.prototype.firstKey = function(l) {
        return this.limit(1).keys(function(d) {
          return d[0];
        }).then(l);
      }, De.prototype.lastKey = function(l) {
        return this.reverse().firstKey(l);
      }, De.prototype.distinct = function() {
        var l = this._ctx, l = l.index && l.table.schema.idxByName[l.index];
        if (!l || !l.multi) return this;
        var d = {};
        return Wn(this._ctx, function(b) {
          var m = b.primaryKey.toString(), b = f(d, m);
          return d[m] = !0, !b;
        }), this;
      }, De.prototype.modify = function(l) {
        var d = this, p = this._ctx;
        return this._write(function(m) {
          var b, w, k;
          k = typeof l == "function" ? l : (b = o(l), w = b.length, function(V) {
            for (var j = !1, q = 0; q < w; ++q) {
              var K = b[q], J = l[K], ne = ue(V, K);
              J instanceof Zi ? (me(V, K, J.execute(ne)), j = !0) : ne !== J && (me(V, K, J), j = !0);
            }
            return j;
          });
          var A = p.table.core, I = A.schema.primaryKey, O = I.outbound, F = I.extractKey, L = 200, I = d.db._options.modifyChunkSize;
          I && (L = typeof I == "object" ? I[A.name] || I["*"] || 200 : I);
          function H(V, K) {
            var q = K.failures, K = K.numFailures;
            M += V - K;
            for (var J = 0, ne = o(q); J < ne.length; J++) {
              var ee = ne[J];
              z.push(q[ee]);
            }
          }
          var z = [], M = 0, N = [], B = l === Hs;
          return d.clone().primaryKeys().then(function(V) {
            function j(K) {
              var J = Math.min(L, V.length - K), ne = V.slice(K, K + J);
              return (B ? Promise.resolve([]) : A.getMany({ trans: m, keys: ne, cache: "immutable" })).then(function(ee) {
                var ie = [], ae = [], se = O ? [] : null, le = B ? ne : [];
                if (!B) for (var xe = 0; xe < J; ++xe) {
                  var Pe = ee[xe], we = { value: Ae(Pe), primKey: V[K + xe] };
                  k.call(we, we.value, we) !== !1 && (we.value == null ? le.push(V[K + xe]) : O || Ee(F(Pe), F(we.value)) === 0 ? (ae.push(we.value), O && se.push(V[K + xe])) : (le.push(V[K + xe]), ie.push(we.value)));
                }
                return Promise.resolve(0 < ie.length && A.mutate({ trans: m, type: "add", values: ie }).then(function(je) {
                  for (var ye in je.failures) le.splice(parseInt(ye), 1);
                  H(ie.length, je);
                })).then(function() {
                  return (0 < ae.length || q && typeof l == "object") && A.mutate({ trans: m, type: "put", keys: se, values: ae, criteria: q, changeSpec: typeof l != "function" && l, isAdditionalChunk: 0 < K }).then(function(je) {
                    return H(ae.length, je);
                  });
                }).then(function() {
                  return (0 < le.length || q && B) && A.mutate({ trans: m, type: "delete", keys: le, criteria: q, isAdditionalChunk: 0 < K }).then(function(je) {
                    return Dr(p.table, le, je);
                  }).then(function(je) {
                    return H(le.length, je);
                  });
                }).then(function() {
                  return V.length > K + J && j(K + L);
                });
              });
            }
            var q = Ti(p) && p.limit === 1 / 0 && (typeof l != "function" || B) && { index: p.index, range: p.range };
            return j(0).then(function() {
              if (0 < z.length) throw new St("Error modifying one or more objects", z, M, N);
              return V.length;
            });
          });
        });
      }, De.prototype.delete = function() {
        var l = this._ctx, d = l.range;
        return !Ti(l) || l.table.schema.yProps || !l.isPrimKey && d.type !== 3 ? this.modify(Hs) : this._write(function(p) {
          var m = l.table.core.schema.primaryKey, b = d;
          return l.table.core.count({ trans: p, query: { index: m, range: b } }).then(function(w) {
            return l.table.core.mutate({ trans: p, type: "deleteRange", range: b }).then(function(O) {
              var A = O.failures, O = O.numFailures;
              if (O) throw new St("Could not delete some values", Object.keys(A).map(function(F) {
                return A[F];
              }), w - O);
              return w - O;
            });
          });
        });
      }, De);
      function De() {
      }
      var Hs = function(l, d) {
        return d.value = null;
      };
      function Ic(l, d) {
        return l < d ? -1 : l === d ? 0 : 1;
      }
      function Dc(l, d) {
        return d < l ? -1 : l === d ? 0 : 1;
      }
      function pt(l, d, p) {
        return l = l instanceof Us ? new l.Collection(l) : l, l._ctx.error = new (p || TypeError)(d), l;
      }
      function Ei(l) {
        return new l.Collection(l, function() {
          return Vs("");
        }).limit(0);
      }
      function Fr(l, d, p, m) {
        var b, w, k, A, O, F, L, I = p.length;
        if (!p.every(function(M) {
          return typeof M == "string";
        })) return pt(l, Is);
        function H(M) {
          b = M === "next" ? function(B) {
            return B.toUpperCase();
          } : function(B) {
            return B.toLowerCase();
          }, w = M === "next" ? function(B) {
            return B.toLowerCase();
          } : function(B) {
            return B.toUpperCase();
          }, k = M === "next" ? Ic : Dc;
          var N = p.map(function(B) {
            return { lower: w(B), upper: b(B) };
          }).sort(function(B, V) {
            return k(B.lower, V.lower);
          });
          A = N.map(function(B) {
            return B.upper;
          }), O = N.map(function(B) {
            return B.lower;
          }), L = (F = M) === "next" ? "" : m;
        }
        H("next"), l = new l.Collection(l, function() {
          return Nt(A[0], O[I - 1] + m);
        }), l._ondirectionchange = function(M) {
          H(M);
        };
        var z = 0;
        return l._addAlgorithm(function(M, N, B) {
          var V = M.key;
          if (typeof V != "string") return !1;
          var j = w(V);
          if (d(j, O, z)) return !0;
          for (var q = null, K = z; K < I; ++K) {
            var J = (function(ne, ee, ie, ae, se, le) {
              for (var xe = Math.min(ne.length, ae.length), Pe = -1, we = 0; we < xe; ++we) {
                var je = ee[we];
                if (je !== ae[we]) return se(ne[we], ie[we]) < 0 ? ne.substr(0, we) + ie[we] + ie.substr(we + 1) : se(ne[we], ae[we]) < 0 ? ne.substr(0, we) + ae[we] + ie.substr(we + 1) : 0 <= Pe ? ne.substr(0, Pe) + ee[Pe] + ie.substr(Pe + 1) : null;
                se(ne[we], je) < 0 && (Pe = we);
              }
              return xe < ae.length && le === "next" ? ne + ie.substr(ne.length) : xe < ne.length && le === "prev" ? ne.substr(0, ie.length) : Pe < 0 ? null : ne.substr(0, Pe) + ae[Pe] + ie.substr(Pe + 1);
            })(V, j, A[K], O[K], k, F);
            J === null && q === null ? z = K + 1 : (q === null || 0 < k(q, J)) && (q = J);
          }
          return N(q !== null ? function() {
            M.continue(q + L);
          } : B), !1;
        }), l;
      }
      function Nt(l, d, p, m) {
        return { type: 2, lower: l, upper: d, lowerOpen: p, upperOpen: m };
      }
      function Vs(l) {
        return { type: 1, lower: l, upper: l };
      }
      var Us = (Object.defineProperty(tt.prototype, "Collection", { get: function() {
        return this._ctx.table.db.Collection;
      }, enumerable: !1, configurable: !0 }), tt.prototype.between = function(l, d, p, m) {
        p = p !== !1, m = m === !0;
        try {
          return 0 < this._cmp(l, d) || this._cmp(l, d) === 0 && (p || m) && (!p || !m) ? Ei(this) : new this.Collection(this, function() {
            return Nt(l, d, !p, !m);
          });
        } catch {
          return pt(this, Rt);
        }
      }, tt.prototype.equals = function(l) {
        return l == null ? pt(this, Rt) : new this.Collection(this, function() {
          return Vs(l);
        });
      }, tt.prototype.above = function(l) {
        return l == null ? pt(this, Rt) : new this.Collection(this, function() {
          return Nt(l, void 0, !0);
        });
      }, tt.prototype.aboveOrEqual = function(l) {
        return l == null ? pt(this, Rt) : new this.Collection(this, function() {
          return Nt(l, void 0, !1);
        });
      }, tt.prototype.below = function(l) {
        return l == null ? pt(this, Rt) : new this.Collection(this, function() {
          return Nt(void 0, l, !1, !0);
        });
      }, tt.prototype.belowOrEqual = function(l) {
        return l == null ? pt(this, Rt) : new this.Collection(this, function() {
          return Nt(void 0, l);
        });
      }, tt.prototype.startsWith = function(l) {
        return typeof l != "string" ? pt(this, Is) : this.between(l, l + $t, !0, !0);
      }, tt.prototype.startsWithIgnoreCase = function(l) {
        return l === "" ? this.startsWith(l) : Fr(this, function(d, p) {
          return d.indexOf(p[0]) === 0;
        }, [l], $t);
      }, tt.prototype.equalsIgnoreCase = function(l) {
        return Fr(this, function(d, p) {
          return d === p[0];
        }, [l], "");
      }, tt.prototype.anyOfIgnoreCase = function() {
        var l = $e.apply(ot, arguments);
        return l.length === 0 ? Ei(this) : Fr(this, function(d, p) {
          return p.indexOf(d) !== -1;
        }, l, "");
      }, tt.prototype.startsWithAnyOfIgnoreCase = function() {
        var l = $e.apply(ot, arguments);
        return l.length === 0 ? Ei(this) : Fr(this, function(d, p) {
          return p.some(function(m) {
            return d.indexOf(m) === 0;
          });
        }, l, $t);
      }, tt.prototype.anyOf = function() {
        var l = this, d = $e.apply(ot, arguments), p = this._cmp;
        try {
          d.sort(p);
        } catch {
          return pt(this, Rt);
        }
        if (d.length === 0) return Ei(this);
        var m = new this.Collection(this, function() {
          return Nt(d[0], d[d.length - 1]);
        });
        m._ondirectionchange = function(w) {
          p = w === "next" ? l._ascending : l._descending, d.sort(p);
        };
        var b = 0;
        return m._addAlgorithm(function(w, k, A) {
          for (var O = w.key; 0 < p(O, d[b]); ) if (++b === d.length) return k(A), !1;
          return p(O, d[b]) === 0 || (k(function() {
            w.continue(d[b]);
          }), !1);
        }), m;
      }, tt.prototype.notEqual = function(l) {
        return this.inAnyRange([[-1 / 0, l], [l, this.db._maxKey]], { includeLowers: !1, includeUppers: !1 });
      }, tt.prototype.noneOf = function() {
        var l = $e.apply(ot, arguments);
        if (l.length === 0) return new this.Collection(this);
        try {
          l.sort(this._ascending);
        } catch {
          return pt(this, Rt);
        }
        var d = l.reduce(function(p, m) {
          return p ? p.concat([[p[p.length - 1][1], m]]) : [[-1 / 0, m]];
        }, null);
        return d.push([l[l.length - 1], this.db._maxKey]), this.inAnyRange(d, { includeLowers: !1, includeUppers: !1 });
      }, tt.prototype.inAnyRange = function(V, d) {
        var p = this, m = this._cmp, b = this._ascending, w = this._descending, k = this._min, A = this._max;
        if (V.length === 0) return Ei(this);
        if (!V.every(function(j) {
          return j[0] !== void 0 && j[1] !== void 0 && b(j[0], j[1]) <= 0;
        })) return pt(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", fe.InvalidArgument);
        var O = !d || d.includeLowers !== !1, F = d && d.includeUppers === !0, L, I = b;
        function H(j, q) {
          return I(j[0], q[0]);
        }
        try {
          (L = V.reduce(function(j, q) {
            for (var K = 0, J = j.length; K < J; ++K) {
              var ne = j[K];
              if (m(q[0], ne[1]) < 0 && 0 < m(q[1], ne[0])) {
                ne[0] = k(ne[0], q[0]), ne[1] = A(ne[1], q[1]);
                break;
              }
            }
            return K === J && j.push(q), j;
          }, [])).sort(H);
        } catch {
          return pt(this, Rt);
        }
        var z = 0, M = F ? function(j) {
          return 0 < b(j, L[z][1]);
        } : function(j) {
          return 0 <= b(j, L[z][1]);
        }, N = O ? function(j) {
          return 0 < w(j, L[z][0]);
        } : function(j) {
          return 0 <= w(j, L[z][0]);
        }, B = M, V = new this.Collection(this, function() {
          return Nt(L[0][0], L[L.length - 1][1], !O, !F);
        });
        return V._ondirectionchange = function(j) {
          I = j === "next" ? (B = M, b) : (B = N, w), L.sort(H);
        }, V._addAlgorithm(function(j, q, K) {
          for (var J, ne = j.key; B(ne); ) if (++z === L.length) return q(K), !1;
          return !M(J = ne) && !N(J) || (p._cmp(ne, L[z][1]) === 0 || p._cmp(ne, L[z][0]) === 0 || q(function() {
            I === b ? j.continue(L[z][0]) : j.continue(L[z][1]);
          }), !1);
        }), V;
      }, tt.prototype.startsWithAnyOf = function() {
        var l = $e.apply(ot, arguments);
        return l.every(function(d) {
          return typeof d == "string";
        }) ? l.length === 0 ? Ei(this) : this.inAnyRange(l.map(function(d) {
          return [d, d + $t];
        })) : pt(this, "startsWithAnyOf() only works with strings");
      }, tt);
      function tt() {
      }
      function Tt(l) {
        return Ne(function(d) {
          return Yi(d), l(d.target.error), !1;
        });
      }
      function Yi(l) {
        l.stopPropagation && l.stopPropagation(), l.preventDefault && l.preventDefault();
      }
      var Xi = "storagemutated", Gn = "x-storagemutated-1", Ht = qi(null, Xi), Oc = (Et.prototype._lock = function() {
        return ce(!te.global), ++this._reculock, this._reculock !== 1 || te.global || (te.lockOwnerFor = this), this;
      }, Et.prototype._unlock = function() {
        if (ce(!te.global), --this._reculock == 0) for (te.global || (te.lockOwnerFor = null); 0 < this._blockedFuncs.length && !this._locked(); ) {
          var l = this._blockedFuncs.shift();
          try {
            Jt(l[1], l[0]);
          } catch {
          }
        }
        return this;
      }, Et.prototype._locked = function() {
        return this._reculock && te.lockOwnerFor !== this;
      }, Et.prototype.create = function(l) {
        var d = this;
        if (!this.mode) return this;
        var p = this.db.idbdb, m = this.db._state.dbOpenError;
        if (ce(!this.idbtrans), !l && !p) switch (m && m.name) {
          case "DatabaseClosedError":
            throw new fe.DatabaseClosed(m);
          case "MissingAPIError":
            throw new fe.MissingAPI(m.message, m);
          default:
            throw new fe.OpenFailed(m);
        }
        if (!this.active) throw new fe.TransactionInactive();
        return ce(this._completion._state === null), (l = this.idbtrans = l || (this.db.core || p).transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })).onerror = Ne(function(b) {
          Yi(b), d._reject(l.error);
        }), l.onabort = Ne(function(b) {
          Yi(b), d.active && d._reject(new fe.Abort(l.error)), d.active = !1, d.on("abort").fire(b);
        }), l.oncomplete = Ne(function() {
          d.active = !1, d._resolve(), "mutatedParts" in l && Ht.storagemutated.fire(l.mutatedParts);
        }), this;
      }, Et.prototype._promise = function(l, d, p) {
        var m = this;
        if (l === "readwrite" && this.mode !== "readwrite") return Ze(new fe.ReadOnly("Transaction is readonly"));
        if (!this.active) return Ze(new fe.TransactionInactive());
        if (this._locked()) return new oe(function(w, k) {
          m._blockedFuncs.push([function() {
            m._promise(l, d, p).then(w, k);
          }, te]);
        });
        if (p) return Mt(function() {
          var w = new oe(function(k, A) {
            m._lock();
            var O = d(k, A, m);
            O && O.then && O.then(k, A);
          });
          return w.finally(function() {
            return m._unlock();
          }), w._lib = !0, w;
        });
        var b = new oe(function(w, k) {
          var A = d(w, k, m);
          A && A.then && A.then(w, k);
        });
        return b._lib = !0, b;
      }, Et.prototype._root = function() {
        return this.parent ? this.parent._root() : this;
      }, Et.prototype.waitFor = function(l) {
        var d, p = this._root(), m = oe.resolve(l);
        p._waitingFor ? p._waitingFor = p._waitingFor.then(function() {
          return m;
        }) : (p._waitingFor = m, p._waitingQueue = [], d = p.idbtrans.objectStore(p.storeNames[0]), (function w() {
          for (++p._spinCount; p._waitingQueue.length; ) p._waitingQueue.shift()();
          p._waitingFor && (d.get(-1 / 0).onsuccess = w);
        })());
        var b = p._waitingFor;
        return new oe(function(w, k) {
          m.then(function(A) {
            return p._waitingQueue.push(Ne(w.bind(null, A)));
          }, function(A) {
            return p._waitingQueue.push(Ne(k.bind(null, A)));
          }).finally(function() {
            p._waitingFor === b && (p._waitingFor = null);
          });
        });
      }, Et.prototype.abort = function() {
        this.active && (this.active = !1, this.idbtrans && this.idbtrans.abort(), this._reject(new fe.Abort()));
      }, Et.prototype.table = function(l) {
        var d = this._memoizedTables || (this._memoizedTables = {});
        if (f(d, l)) return d[l];
        var p = this.schema[l];
        if (!p) throw new fe.NotFound("Table " + l + " not part of transaction");
        return p = new this.db.Table(l, p, this), p.core = this.db.core.table(l), d[l] = p;
      }, Et);
      function Et() {
      }
      function qn(l, d, p, m, b, w, k, A) {
        return { name: l, keyPath: d, unique: p, multi: m, auto: b, compound: w, src: (p && !k ? "&" : "") + (m ? "*" : "") + (b ? "++" : "") + Ws(d), type: A };
      }
      function Ws(l) {
        return typeof l == "string" ? l : l ? "[" + [].join.call(l, "+") + "]" : "";
      }
      function Kn(l, d, p) {
        return { name: l, primKey: d, indexes: p, mappedClass: null, idxByName: (m = function(b) {
          return [b.name, b];
        }, p.reduce(function(b, w, k) {
          return k = m(w, k), k && (b[k[0]] = k[1]), b;
        }, {})) };
        var m;
      }
      var Qi = function(l) {
        try {
          return l.only([[]]), Qi = function() {
            return [[]];
          }, [[]];
        } catch {
          return Qi = function() {
            return $t;
          }, $t;
        }
      };
      function Zn(l) {
        return l == null ? function() {
        } : typeof l == "string" ? (d = l).split(".").length === 1 ? function(p) {
          return p[d];
        } : function(p) {
          return ue(p, d);
        } : function(p) {
          return ue(p, l);
        };
        var d;
      }
      function js(l) {
        return [].slice.call(l);
      }
      var zc = 0;
      function Ji(l) {
        return l == null ? ":id" : typeof l == "string" ? l : "[".concat(l.join("+"), "]");
      }
      function Fc(l, d, O) {
        function m(B) {
          if (B.type === 3) return null;
          if (B.type === 4) throw new Error("Cannot convert never type to IDBKeyRange");
          var z = B.lower, M = B.upper, N = B.lowerOpen, B = B.upperOpen;
          return z === void 0 ? M === void 0 ? null : d.upperBound(M, !!B) : M === void 0 ? d.lowerBound(z, !!N) : d.bound(z, M, !!N, !!B);
        }
        function b(H) {
          var z, M = H.name;
          return { name: M, schema: H, mutate: function(N) {
            var B = N.trans, V = N.type, j = N.keys, q = N.values, K = N.range;
            return new Promise(function(J, ne) {
              J = Ne(J);
              var ee = B.objectStore(M), ie = ee.keyPath == null, ae = V === "put" || V === "add";
              if (!ae && V !== "delete" && V !== "deleteRange") throw new Error("Invalid operation type: " + V);
              var se, le = (j || q || { length: 1 }).length;
              if (j && q && j.length !== q.length) throw new Error("Given keys array must have same length as given values array.");
              if (le === 0) return J({ numFailures: 0, failures: {}, results: [], lastResult: void 0 });
              function xe(ut) {
                ++je, Yi(ut);
              }
              var Pe = [], we = [], je = 0;
              if (V === "deleteRange") {
                if (K.type === 4) return J({ numFailures: je, failures: we, results: [], lastResult: void 0 });
                K.type === 3 ? Pe.push(se = ee.clear()) : Pe.push(se = ee.delete(m(K)));
              } else {
                var ie = ae ? ie ? [q, j] : [q, null] : [j, null], ye = ie[0], at = ie[1];
                if (ae) for (var lt = 0; lt < le; ++lt) Pe.push(se = at && at[lt] !== void 0 ? ee[V](ye[lt], at[lt]) : ee[V](ye[lt])), se.onerror = xe;
                else for (lt = 0; lt < le; ++lt) Pe.push(se = ee[V](ye[lt])), se.onerror = xe;
              }
              function Kr(ut) {
                ut = ut.target.result, Pe.forEach(function(ri, fo) {
                  return ri.error != null && (we[fo] = ri.error);
                }), J({ numFailures: je, failures: we, results: V === "delete" ? j : Pe.map(function(ri) {
                  return ri.result;
                }), lastResult: ut });
              }
              se.onerror = function(ut) {
                xe(ut), Kr(ut);
              }, se.onsuccess = Kr;
            });
          }, getMany: function(N) {
            var B = N.trans, V = N.keys;
            return new Promise(function(j, q) {
              j = Ne(j);
              for (var K, J = B.objectStore(M), ne = V.length, ee = new Array(ne), ie = 0, ae = 0, se = function(Pe) {
                Pe = Pe.target, ee[Pe._pos] = Pe.result, ++ae === ie && j(ee);
              }, le = Tt(q), xe = 0; xe < ne; ++xe) V[xe] != null && ((K = J.get(V[xe]))._pos = xe, K.onsuccess = se, K.onerror = le, ++ie);
              ie === 0 && j(ee);
            });
          }, get: function(N) {
            var B = N.trans, V = N.key;
            return new Promise(function(j, q) {
              j = Ne(j);
              var K = B.objectStore(M).get(V);
              K.onsuccess = function(J) {
                return j(J.target.result);
              }, K.onerror = Tt(q);
            });
          }, query: (z = F, function(N) {
            return new Promise(function(B, V) {
              B = Ne(B);
              var j, q, K, ie = N.trans, J = N.values, ne = N.limit, se = N.query, ee = ne === 1 / 0 ? void 0 : ne, ae = se.index, se = se.range, ie = ie.objectStore(M), ae = ae.isPrimaryKey ? ie : ie.index(ae.name), se = m(se);
              if (ne === 0) return B({ result: [] });
              z ? ((ee = J ? ae.getAll(se, ee) : ae.getAllKeys(se, ee)).onsuccess = function(le) {
                return B({ result: le.target.result });
              }, ee.onerror = Tt(V)) : (j = 0, q = !J && "openKeyCursor" in ae ? ae.openKeyCursor(se) : ae.openCursor(se), K = [], q.onsuccess = function(le) {
                var xe = q.result;
                return xe ? (K.push(J ? xe.value : xe.primaryKey), ++j === ne ? B({ result: K }) : void xe.continue()) : B({ result: K });
              }, q.onerror = Tt(V));
            });
          }), openCursor: function(N) {
            var B = N.trans, V = N.values, j = N.query, q = N.reverse, K = N.unique;
            return new Promise(function(J, ne) {
              J = Ne(J);
              var ae = j.index, ee = j.range, ie = B.objectStore(M), ie = ae.isPrimaryKey ? ie : ie.index(ae.name), ae = q ? K ? "prevunique" : "prev" : K ? "nextunique" : "next", se = !V && "openKeyCursor" in ie ? ie.openKeyCursor(m(ee), ae) : ie.openCursor(m(ee), ae);
              se.onerror = Tt(ne), se.onsuccess = Ne(function(le) {
                var xe, Pe, we, je, ye = se.result;
                ye ? (ye.___id = ++zc, ye.done = !1, xe = ye.continue.bind(ye), Pe = (Pe = ye.continuePrimaryKey) && Pe.bind(ye), we = ye.advance.bind(ye), je = function() {
                  throw new Error("Cursor not stopped");
                }, ye.trans = B, ye.stop = ye.continue = ye.continuePrimaryKey = ye.advance = function() {
                  throw new Error("Cursor not started");
                }, ye.fail = Ne(ne), ye.next = function() {
                  var at = this, lt = 1;
                  return this.start(function() {
                    return lt-- ? at.continue() : at.stop();
                  }).then(function() {
                    return at;
                  });
                }, ye.start = function(at) {
                  function lt() {
                    if (se.result) try {
                      at();
                    } catch (ut) {
                      ye.fail(ut);
                    }
                    else ye.done = !0, ye.start = function() {
                      throw new Error("Cursor behind last entry");
                    }, ye.stop();
                  }
                  var Kr = new Promise(function(ut, ri) {
                    ut = Ne(ut), se.onerror = Tt(ri), ye.fail = ri, ye.stop = function(fo) {
                      ye.stop = ye.continue = ye.continuePrimaryKey = ye.advance = je, ut(fo);
                    };
                  });
                  return se.onsuccess = Ne(function(ut) {
                    se.onsuccess = lt, lt();
                  }), ye.continue = xe, ye.continuePrimaryKey = Pe, ye.advance = we, lt(), Kr;
                }, J(ye)) : J(null);
              }, ne);
            });
          }, count: function(N) {
            var B = N.query, V = N.trans, j = B.index, q = B.range;
            return new Promise(function(K, J) {
              var ne = V.objectStore(M), ee = j.isPrimaryKey ? ne : ne.index(j.name), ne = m(q), ee = ne ? ee.count(ne) : ee.count();
              ee.onsuccess = Ne(function(ie) {
                return K(ie.target.result);
              }), ee.onerror = Tt(J);
            });
          } };
        }
        var w, k, A, L = (k = O, A = js((w = l).objectStoreNames), { schema: { name: w.name, tables: A.map(function(H) {
          return k.objectStore(H);
        }).map(function(H) {
          var z = H.keyPath, B = H.autoIncrement, M = a(z), N = {}, B = { name: H.name, primaryKey: { name: null, isPrimaryKey: !0, outbound: z == null, compound: M, keyPath: z, autoIncrement: B, unique: !0, extractKey: Zn(z) }, indexes: js(H.indexNames).map(function(V) {
            return H.index(V);
          }).map(function(K) {
            var j = K.name, q = K.unique, J = K.multiEntry, K = K.keyPath, J = { name: j, compound: a(K), keyPath: K, unique: q, multiEntry: J, extractKey: Zn(K) };
            return N[Ji(K)] = J;
          }), getIndexByKeyPath: function(V) {
            return N[Ji(V)];
          } };
          return N[":id"] = B.primaryKey, z != null && (N[Ji(z)] = B.primaryKey), B;
        }) }, hasGetAll: 0 < A.length && "getAll" in k.objectStore(A[0]) && !(typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) }), O = L.schema, F = L.hasGetAll, L = O.tables.map(b), I = {};
        return L.forEach(function(H) {
          return I[H.name] = H;
        }), { stack: "dbcore", transaction: l.transaction.bind(l), table: function(H) {
          if (!I[H]) throw new Error("Table '".concat(H, "' not found"));
          return I[H];
        }, MIN_KEY: -1 / 0, MAX_KEY: Qi(d), schema: O };
      }
      function Mc(l, d, p, m) {
        var b = p.IDBKeyRange;
        return p.indexedDB, { dbcore: (m = Fc(d, b, m), l.dbcore.reduce(function(w, k) {
          return k = k.create, t(t({}, w), k(w));
        }, m)) };
      }
      function Mr(l, m) {
        var p = m.db, m = Mc(l._middlewares, p, l._deps, m);
        l.core = m.dbcore, l.tables.forEach(function(b) {
          var w = b.name;
          l.core.schema.tables.some(function(k) {
            return k.name === w;
          }) && (b.core = l.core.table(w), l[w] instanceof l.Table && (l[w].core = b.core));
        });
      }
      function Lr(l, d, p, m) {
        p.forEach(function(b) {
          var w = m[b];
          d.forEach(function(k) {
            var A = (function O(F, L) {
              return R(F, L) || (F = u(F)) && O(F, L);
            })(k, b);
            (!A || "value" in A && A.value === void 0) && (k === l.Transaction.prototype || k instanceof l.Transaction ? C(k, b, { get: function() {
              return this.table(b);
            }, set: function(O) {
              x(this, b, { value: O, writable: !0, configurable: !0, enumerable: !0 });
            } }) : k[b] = new l.Table(b, w));
          });
        });
      }
      function Yn(l, d) {
        d.forEach(function(p) {
          for (var m in p) p[m] instanceof l.Table && delete p[m];
        });
      }
      function Lc(l, d) {
        return l._cfg.version - d._cfg.version;
      }
      function Bc(l, d, p, m) {
        var b = l._dbSchema;
        p.objectStoreNames.contains("$meta") && !b.$meta && (b.$meta = Kn("$meta", qs("")[0], []), l._storeNames.push("$meta"));
        var w = l._createTransaction("readwrite", l._storeNames, b);
        w.create(p), w._completion.catch(m);
        var k = w._reject.bind(w), A = te.transless || te;
        Mt(function() {
          return te.trans = w, te.transless = A, d !== 0 ? (Mr(l, p), F = d, ((O = w).storeNames.includes("$meta") ? O.table("$meta").get("version").then(function(L) {
            return L ?? F;
          }) : oe.resolve(F)).then(function(L) {
            return H = L, z = w, M = p, N = [], L = (I = l)._versions, B = I._dbSchema = Nr(0, I.idbdb, M), (L = L.filter(function(V) {
              return V._cfg.version >= H;
            })).length !== 0 ? (L.forEach(function(V) {
              N.push(function() {
                var j = B, q = V._cfg.dbschema;
                Hr(I, j, M), Hr(I, q, M), B = I._dbSchema = q;
                var K = Xn(j, q);
                K.add.forEach(function(ae) {
                  Qn(M, ae[0], ae[1].primKey, ae[1].indexes);
                }), K.change.forEach(function(ae) {
                  if (ae.recreate) throw new fe.Upgrade("Not yet support for changing primary key");
                  var se = M.objectStore(ae.name);
                  ae.add.forEach(function(le) {
                    return Br(se, le);
                  }), ae.change.forEach(function(le) {
                    se.deleteIndex(le.name), Br(se, le);
                  }), ae.del.forEach(function(le) {
                    return se.deleteIndex(le);
                  });
                });
                var J = V._cfg.contentUpgrade;
                if (J && V._cfg.version > H) {
                  Mr(I, M), z._memoizedTables = {};
                  var ne = Te(q);
                  K.del.forEach(function(ae) {
                    ne[ae] = j[ae];
                  }), Yn(I, [I.Transaction.prototype]), Lr(I, [I.Transaction.prototype], o(ne), ne), z.schema = ne;
                  var ee, ie = Yt(J);
                  return ie && xi(), K = oe.follow(function() {
                    var ae;
                    (ee = J(z)) && ie && (ae = Lt.bind(null, null), ee.then(ae, ae));
                  }), ee && typeof ee.then == "function" ? oe.resolve(ee) : K.then(function() {
                    return ee;
                  });
                }
              }), N.push(function(j) {
                var q, K, J = V._cfg.dbschema;
                q = J, K = j, [].slice.call(K.db.objectStoreNames).forEach(function(ne) {
                  return q[ne] == null && K.db.deleteObjectStore(ne);
                }), Yn(I, [I.Transaction.prototype]), Lr(I, [I.Transaction.prototype], I._storeNames, I._dbSchema), z.schema = I._dbSchema;
              }), N.push(function(j) {
                I.idbdb.objectStoreNames.contains("$meta") && (Math.ceil(I.idbdb.version / 10) === V._cfg.version ? (I.idbdb.deleteObjectStore("$meta"), delete I._dbSchema.$meta, I._storeNames = I._storeNames.filter(function(q) {
                  return q !== "$meta";
                })) : j.objectStore("$meta").put(V._cfg.version, "version"));
              });
            }), (function V() {
              return N.length ? oe.resolve(N.shift()(z.idbtrans)).then(V) : oe.resolve();
            })().then(function() {
              Gs(B, M);
            })) : oe.resolve();
            var I, H, z, M, N, B;
          }).catch(k)) : (o(b).forEach(function(L) {
            Qn(p, L, b[L].primKey, b[L].indexes);
          }), Mr(l, p), void oe.follow(function() {
            return l.on.populate.fire(w);
          }).catch(k));
          var O, F;
        });
      }
      function Nc(l, d) {
        Gs(l._dbSchema, d), d.db.version % 10 != 0 || d.objectStoreNames.contains("$meta") || d.db.createObjectStore("$meta").add(Math.ceil(d.db.version / 10 - 1), "version");
        var p = Nr(0, l.idbdb, d);
        Hr(l, l._dbSchema, d);
        for (var m = 0, b = Xn(p, l._dbSchema).change; m < b.length; m++) {
          var w = (function(k) {
            if (k.change.length || k.recreate) return console.warn("Unable to patch indexes of table ".concat(k.name, " because it has changes on the type of index or primary key.")), { value: void 0 };
            var A = d.objectStore(k.name);
            k.add.forEach(function(O) {
              $ && console.debug("Dexie upgrade patch: Creating missing index ".concat(k.name, ".").concat(O.src)), Br(A, O);
            });
          })(b[m]);
          if (typeof w == "object") return w.value;
        }
      }
      function Xn(l, d) {
        var p, m = { del: [], add: [], change: [] };
        for (p in l) d[p] || m.del.push(p);
        for (p in d) {
          var b = l[p], w = d[p];
          if (b) {
            var k = { name: p, def: w, recreate: !1, del: [], add: [], change: [] };
            if ("" + (b.primKey.keyPath || "") != "" + (w.primKey.keyPath || "") || b.primKey.auto !== w.primKey.auto) k.recreate = !0, m.change.push(k);
            else {
              var A = b.idxByName, O = w.idxByName, F = void 0;
              for (F in A) O[F] || k.del.push(F);
              for (F in O) {
                var L = A[F], I = O[F];
                L ? L.src !== I.src && k.change.push(I) : k.add.push(I);
              }
              (0 < k.del.length || 0 < k.add.length || 0 < k.change.length) && m.change.push(k);
            }
          } else m.add.push([p, w]);
        }
        return m;
      }
      function Qn(l, d, p, m) {
        var b = l.db.createObjectStore(d, p.keyPath ? { keyPath: p.keyPath, autoIncrement: p.auto } : { autoIncrement: p.auto });
        return m.forEach(function(w) {
          return Br(b, w);
        }), b;
      }
      function Gs(l, d) {
        o(l).forEach(function(p) {
          d.db.objectStoreNames.contains(p) || ($ && console.debug("Dexie: Creating missing table", p), Qn(d, p, l[p].primKey, l[p].indexes));
        });
      }
      function Br(l, d) {
        l.createIndex(d.name, d.keyPath, { unique: d.unique, multiEntry: d.multi });
      }
      function Nr(l, d, p) {
        var m = {};
        return U(d.objectStoreNames, 0).forEach(function(b) {
          for (var w = p.objectStore(b), k = qn(Ws(F = w.keyPath), F || "", !0, !1, !!w.autoIncrement, F && typeof F != "string", !0), A = [], O = 0; O < w.indexNames.length; ++O) {
            var L = w.index(w.indexNames[O]), F = L.keyPath, L = qn(L.name, F, !!L.unique, !!L.multiEntry, !1, F && typeof F != "string", !1);
            A.push(L);
          }
          m[b] = Kn(b, k, A);
        }), m;
      }
      function Hr(l, d, p) {
        for (var m = p.db.objectStoreNames, b = 0; b < m.length; ++b) {
          var w = m[b], k = p.objectStore(w);
          l._hasGetAll = "getAll" in k;
          for (var A = 0; A < k.indexNames.length; ++A) {
            var O = k.indexNames[A], F = k.index(O).keyPath, L = typeof F == "string" ? F : "[" + U(F).join("+") + "]";
            !d[w] || (F = d[w].idxByName[L]) && (F.name = O, delete d[w].idxByName[L], d[w].idxByName[O] = F);
          }
        }
        typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && r.WorkerGlobalScope && r instanceof r.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604 && (l._hasGetAll = !1);
      }
      function qs(l) {
        return l.split(",").map(function(d, p) {
          var w = d.split(":"), m = (b = w[1]) === null || b === void 0 ? void 0 : b.trim(), b = (d = w[0].trim()).replace(/([&*]|\+\+)/g, ""), w = /^\[/.test(b) ? b.match(/^\[(.*)\]$/)[1].split("+") : b;
          return qn(b, w || null, /\&/.test(d), /\*/.test(d), /\+\+/.test(d), a(w), p === 0, m);
        });
      }
      var Hc = (Pi.prototype._createTableSchema = Kn, Pi.prototype._parseIndexSyntax = qs, Pi.prototype._parseStoresSpec = function(l, d) {
        var p = this;
        o(l).forEach(function(m) {
          if (l[m] !== null) {
            var b = p._parseIndexSyntax(l[m]), w = b.shift();
            if (!w) throw new fe.Schema("Invalid schema for table " + m + ": " + l[m]);
            if (w.unique = !0, w.multi) throw new fe.Schema("Primary key cannot be multiEntry*");
            b.forEach(function(k) {
              if (k.auto) throw new fe.Schema("Only primary key can be marked as autoIncrement (++)");
              if (!k.keyPath) throw new fe.Schema("Index must have a name and cannot be an empty string");
            }), b = p._createTableSchema(m, w, b), d[m] = b;
          }
        });
      }, Pi.prototype.stores = function(p) {
        var d = this.db;
        this._cfg.storesSource = this._cfg.storesSource ? c(this._cfg.storesSource, p) : p;
        var p = d._versions, m = {}, b = {};
        return p.forEach(function(w) {
          c(m, w._cfg.storesSource), b = w._cfg.dbschema = {}, w._parseStoresSpec(m, b);
        }), d._dbSchema = b, Yn(d, [d._allTables, d, d.Transaction.prototype]), Lr(d, [d._allTables, d, d.Transaction.prototype, this._cfg.tables], o(b), b), d._storeNames = o(b), this;
      }, Pi.prototype.upgrade = function(l) {
        return this._cfg.contentUpgrade = X(this._cfg.contentUpgrade || Ie, l), this;
      }, Pi);
      function Pi() {
      }
      function Jn(l, d) {
        var p = l._dbNamesDB;
        return p || (p = l._dbNamesDB = new At(Ar, { addons: [], indexedDB: l, IDBKeyRange: d })).version(1).stores({ dbnames: "name" }), p.table("dbnames");
      }
      function $n(l) {
        return l && typeof l.databases == "function";
      }
      function eo(l) {
        return Mt(function() {
          return te.letThrough = !0, l();
        });
      }
      function to(l) {
        return !("from" in l);
      }
      var st = function(l, d) {
        if (!this) {
          var p = new st();
          return l && "d" in l && c(p, l), p;
        }
        c(this, arguments.length ? { d: 1, from: l, to: 1 < arguments.length ? d : l } : { d: 0 });
      };
      function $i(l, d, p) {
        var m = Ee(d, p);
        if (!isNaN(m)) {
          if (0 < m) throw RangeError();
          if (to(l)) return c(l, { from: d, to: p, d: 1 });
          var b = l.l, m = l.r;
          if (Ee(p, l.from) < 0) return b ? $i(b, d, p) : l.l = { from: d, to: p, d: 1, l: null, r: null }, Zs(l);
          if (0 < Ee(d, l.to)) return m ? $i(m, d, p) : l.r = { from: d, to: p, d: 1, l: null, r: null }, Zs(l);
          Ee(d, l.from) < 0 && (l.from = d, l.l = null, l.d = m ? m.d + 1 : 1), 0 < Ee(p, l.to) && (l.to = p, l.r = null, l.d = l.l ? l.l.d + 1 : 1), p = !l.r, b && !l.l && er(l, b), m && p && er(l, m);
        }
      }
      function er(l, d) {
        to(d) || (function p(m, O) {
          var w = O.from, k = O.to, A = O.l, O = O.r;
          $i(m, w, k), A && p(m, A), O && p(m, O);
        })(l, d);
      }
      function Ks(l, d) {
        var p = Vr(d), m = p.next();
        if (m.done) return !1;
        for (var b = m.value, w = Vr(l), k = w.next(b.from), A = k.value; !m.done && !k.done; ) {
          if (Ee(A.from, b.to) <= 0 && 0 <= Ee(A.to, b.from)) return !0;
          Ee(b.from, A.from) < 0 ? b = (m = p.next(A.from)).value : A = (k = w.next(b.from)).value;
        }
        return !1;
      }
      function Vr(l) {
        var d = to(l) ? null : { s: 0, n: l };
        return { next: function(p) {
          for (var m = 0 < arguments.length; d; ) switch (d.s) {
            case 0:
              if (d.s = 1, m) for (; d.n.l && Ee(p, d.n.from) < 0; ) d = { up: d, n: d.n.l, s: 1 };
              else for (; d.n.l; ) d = { up: d, n: d.n.l, s: 1 };
            case 1:
              if (d.s = 2, !m || Ee(p, d.n.to) <= 0) return { value: d.n, done: !1 };
            case 2:
              if (d.n.r) {
                d.s = 3, d = { up: d, n: d.n.r, s: 0 };
                continue;
              }
            case 3:
              d = d.up;
          }
          return { done: !0 };
        } };
      }
      function Zs(l) {
        var d, p, m = (((d = l.r) === null || d === void 0 ? void 0 : d.d) || 0) - (((p = l.l) === null || p === void 0 ? void 0 : p.d) || 0), b = 1 < m ? "r" : m < -1 ? "l" : "";
        b && (d = b == "r" ? "l" : "r", p = t({}, l), m = l[b], l.from = m.from, l.to = m.to, l[b] = m[b], p[b] = m[d], (l[d] = p).d = Ys(p)), l.d = Ys(l);
      }
      function Ys(p) {
        var d = p.r, p = p.l;
        return (d ? p ? Math.max(d.d, p.d) : d.d : p ? p.d : 0) + 1;
      }
      function Ur(l, d) {
        return o(d).forEach(function(p) {
          l[p] ? er(l[p], d[p]) : l[p] = (function m(b) {
            var w, k, A = {};
            for (w in b) f(b, w) && (k = b[w], A[w] = !k || typeof k != "object" || Fe.has(k.constructor) ? k : m(k));
            return A;
          })(d[p]);
        }), l;
      }
      function io(l, d) {
        return l.all || d.all || Object.keys(l).some(function(p) {
          return d[p] && Ks(d[p], l[p]);
        });
      }
      g(st.prototype, ((vt = { add: function(l) {
        return er(this, l), this;
      }, addKey: function(l) {
        return $i(this, l, l), this;
      }, addKeys: function(l) {
        var d = this;
        return l.forEach(function(p) {
          return $i(d, p, p);
        }), this;
      }, hasKey: function(l) {
        var d = Vr(this).next(l).value;
        return d && Ee(d.from, l) <= 0 && 0 <= Ee(d.to, l);
      } })[qe] = function() {
        return Vr(this);
      }, vt));
      var ti = {}, ro = {}, no = !1;
      function Wr(l) {
        Ur(ro, l), no || (no = !0, setTimeout(function() {
          no = !1, oo(ro, !(ro = {}));
        }, 0));
      }
      function oo(l, d) {
        d === void 0 && (d = !1);
        var p = /* @__PURE__ */ new Set();
        if (l.all) for (var m = 0, b = Object.values(ti); m < b.length; m++) Xs(k = b[m], l, p, d);
        else for (var w in l) {
          var k, A = /^idb\:\/\/(.*)\/(.*)\//.exec(w);
          A && (w = A[1], A = A[2], (k = ti["idb://".concat(w, "/").concat(A)]) && Xs(k, l, p, d));
        }
        p.forEach(function(O) {
          return O();
        });
      }
      function Xs(l, d, p, m) {
        for (var b = [], w = 0, k = Object.entries(l.queries.query); w < k.length; w++) {
          for (var A = k[w], O = A[0], F = [], L = 0, I = A[1]; L < I.length; L++) {
            var H = I[L];
            io(d, H.obsSet) ? H.subscribers.forEach(function(B) {
              return p.add(B);
            }) : m && F.push(H);
          }
          m && b.push([O, F]);
        }
        if (m) for (var z = 0, M = b; z < M.length; z++) {
          var N = M[z], O = N[0], F = N[1];
          l.queries.query[O] = F;
        }
      }
      function Vc(l) {
        var d = l._state, p = l._deps.indexedDB;
        if (d.isBeingOpened || l.idbdb) return d.dbReadyPromise.then(function() {
          return d.dbOpenError ? Ze(d.dbOpenError) : l;
        });
        d.isBeingOpened = !0, d.dbOpenError = null, d.openComplete = !1;
        var m = d.openCanceller, b = Math.round(10 * l.verno), w = !1;
        function k() {
          if (d.openCanceller !== m) throw new fe.DatabaseClosed("db.open() was cancelled");
        }
        function A() {
          return new oe(function(H, z) {
            if (k(), !p) throw new fe.MissingAPI();
            var M = l.name, N = d.autoSchema || !b ? p.open(M) : p.open(M, b);
            if (!N) throw new fe.MissingAPI();
            N.onerror = Tt(z), N.onblocked = Ne(l._fireOnBlocked), N.onupgradeneeded = Ne(function(B) {
              var V;
              L = N.transaction, d.autoSchema && !l._options.allowEmptyDB ? (N.onerror = Yi, L.abort(), N.result.close(), (V = p.deleteDatabase(M)).onsuccess = V.onerror = Ne(function() {
                z(new fe.NoSuchDatabase("Database ".concat(M, " doesnt exist")));
              })) : (L.onerror = Tt(z), B = B.oldVersion > Math.pow(2, 62) ? 0 : B.oldVersion, I = B < 1, l.idbdb = N.result, w && Nc(l, L), Bc(l, B / 10, L, z));
            }, z), N.onsuccess = Ne(function() {
              L = null;
              var B, V, j, q, K, J = l.idbdb = N.result, ne = U(J.objectStoreNames);
              if (0 < ne.length) try {
                var ee = J.transaction((q = ne).length === 1 ? q[0] : q, "readonly");
                if (d.autoSchema) V = J, j = ee, (B = l).verno = V.version / 10, j = B._dbSchema = Nr(0, V, j), B._storeNames = U(V.objectStoreNames, 0), Lr(B, [B._allTables], o(j), j);
                else if (Hr(l, l._dbSchema, ee), ((K = Xn(Nr(0, (K = l).idbdb, ee), K._dbSchema)).add.length || K.change.some(function(ie) {
                  return ie.add.length || ie.change.length;
                })) && !w) return console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Dexie will add missing parts and increment native version number to workaround this."), J.close(), b = J.version + 1, w = !0, H(A());
                Mr(l, ee);
              } catch {
              }
              Ci.push(l), J.onversionchange = Ne(function(ie) {
                d.vcFired = !0, l.on("versionchange").fire(ie);
              }), J.onclose = Ne(function(ie) {
                l.on("close").fire(ie);
              }), I && (K = l._deps, ee = M, J = K.indexedDB, K = K.IDBKeyRange, $n(J) || ee === Ar || Jn(J, K).put({ name: ee }).catch(Ie)), H();
            }, z);
          }).catch(function(H) {
            switch (H?.name) {
              case "UnknownError":
                if (0 < d.PR1398_maxLoop) return d.PR1398_maxLoop--, console.warn("Dexie: Workaround for Chrome UnknownError on open()"), A();
                break;
              case "VersionError":
                if (0 < b) return b = 0, A();
            }
            return oe.reject(H);
          });
        }
        var O, F = d.dbReadyResolve, L = null, I = !1;
        return oe.race([m, (typeof navigator > "u" ? oe.resolve() : !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent) && indexedDB.databases ? new Promise(function(H) {
          function z() {
            return indexedDB.databases().finally(H);
          }
          O = setInterval(z, 100), z();
        }).finally(function() {
          return clearInterval(O);
        }) : Promise.resolve()).then(A)]).then(function() {
          return k(), d.onReadyBeingFired = [], oe.resolve(eo(function() {
            return l.on.ready.fire(l.vip);
          })).then(function H() {
            if (0 < d.onReadyBeingFired.length) {
              var z = d.onReadyBeingFired.reduce(X, Ie);
              return d.onReadyBeingFired = [], oe.resolve(eo(function() {
                return z(l.vip);
              })).then(H);
            }
          });
        }).finally(function() {
          d.openCanceller === m && (d.onReadyBeingFired = null, d.isBeingOpened = !1);
        }).catch(function(H) {
          d.dbOpenError = H;
          try {
            L && L.abort();
          } catch {
          }
          return m === d.openCanceller && l._close(), Ze(H);
        }).finally(function() {
          d.openComplete = !0, F();
        }).then(function() {
          var H;
          return I && (H = {}, l.tables.forEach(function(z) {
            z.schema.indexes.forEach(function(M) {
              M.name && (H["idb://".concat(l.name, "/").concat(z.name, "/").concat(M.name)] = new st(-1 / 0, [[[]]]));
            }), H["idb://".concat(l.name, "/").concat(z.name, "/")] = H["idb://".concat(l.name, "/").concat(z.name, "/:dels")] = new st(-1 / 0, [[[]]]);
          }), Ht(Xi).fire(H), oo(H, !0)), l;
        });
      }
      function so(l) {
        function d(w) {
          return l.next(w);
        }
        var p = b(d), m = b(function(w) {
          return l.throw(w);
        });
        function b(w) {
          return function(O) {
            var A = w(O), O = A.value;
            return A.done ? O : O && typeof O.then == "function" ? O.then(p, m) : a(O) ? Promise.all(O).then(p, m) : p(O);
          };
        }
        return b(d)();
      }
      function jr(l, d, p) {
        for (var m = a(l) ? l.slice() : [l], b = 0; b < p; ++b) m.push(d);
        return m;
      }
      var Uc = { stack: "dbcore", name: "VirtualIndexMiddleware", level: 1, create: function(l) {
        return t(t({}, l), { table: function(d) {
          var p = l.table(d), m = p.schema, b = {}, w = [];
          function k(I, H, z) {
            var M = Ji(I), N = b[M] = b[M] || [], B = I == null ? 0 : typeof I == "string" ? 1 : I.length, V = 0 < H, V = t(t({}, z), { name: V ? "".concat(M, "(virtual-from:").concat(z.name, ")") : z.name, lowLevelIndex: z, isVirtual: V, keyTail: H, keyLength: B, extractKey: Zn(I), unique: !V && z.unique });
            return N.push(V), V.isPrimaryKey || w.push(V), 1 < B && k(B === 2 ? I[0] : I.slice(0, B - 1), H + 1, z), N.sort(function(j, q) {
              return j.keyTail - q.keyTail;
            }), V;
          }
          d = k(m.primaryKey.keyPath, 0, m.primaryKey), b[":id"] = [d];
          for (var A = 0, O = m.indexes; A < O.length; A++) {
            var F = O[A];
            k(F.keyPath, 0, F);
          }
          function L(I) {
            var H, z = I.query.index;
            return z.isVirtual ? t(t({}, I), { query: { index: z.lowLevelIndex, range: (H = I.query.range, z = z.keyTail, { type: H.type === 1 ? 2 : H.type, lower: jr(H.lower, H.lowerOpen ? l.MAX_KEY : l.MIN_KEY, z), lowerOpen: !0, upper: jr(H.upper, H.upperOpen ? l.MIN_KEY : l.MAX_KEY, z), upperOpen: !0 }) } }) : I;
          }
          return t(t({}, p), { schema: t(t({}, m), { primaryKey: d, indexes: w, getIndexByKeyPath: function(I) {
            return (I = b[Ji(I)]) && I[0];
          } }), count: function(I) {
            return p.count(L(I));
          }, query: function(I) {
            return p.query(L(I));
          }, openCursor: function(I) {
            var H = I.query.index, z = H.keyTail, M = H.isVirtual, N = H.keyLength;
            return M ? p.openCursor(L(I)).then(function(V) {
              return V && B(V);
            }) : p.openCursor(I);
            function B(V) {
              return Object.create(V, { continue: { value: function(j) {
                j != null ? V.continue(jr(j, I.reverse ? l.MAX_KEY : l.MIN_KEY, z)) : I.unique ? V.continue(V.key.slice(0, N).concat(I.reverse ? l.MIN_KEY : l.MAX_KEY, z)) : V.continue();
              } }, continuePrimaryKey: { value: function(j, q) {
                V.continuePrimaryKey(jr(j, l.MAX_KEY, z), q);
              } }, primaryKey: { get: function() {
                return V.primaryKey;
              } }, key: { get: function() {
                var j = V.key;
                return N === 1 ? j[0] : j.slice(0, N);
              } }, value: { get: function() {
                return V.value;
              } } });
            }
          } });
        } });
      } };
      function ao(l, d, p, m) {
        return p = p || {}, m = m || "", o(l).forEach(function(b) {
          var w, k, A;
          f(d, b) ? (w = l[b], k = d[b], typeof w == "object" && typeof k == "object" && w && k ? (A = Ge(w)) !== Ge(k) ? p[m + b] = d[b] : A === "Object" ? ao(w, k, p, m + b + ".") : w !== k && (p[m + b] = d[b]) : w !== k && (p[m + b] = d[b])) : p[m + b] = void 0;
        }), o(d).forEach(function(b) {
          f(l, b) || (p[m + b] = d[b]);
        }), p;
      }
      function lo(l, d) {
        return d.type === "delete" ? d.keys : d.keys || d.values.map(l.extractKey);
      }
      var Wc = { stack: "dbcore", name: "HooksMiddleware", level: 2, create: function(l) {
        return t(t({}, l), { table: function(d) {
          var p = l.table(d), m = p.schema.primaryKey;
          return t(t({}, p), { mutate: function(b) {
            var w = te.trans, k = w.table(d).hook, A = k.deleting, O = k.creating, F = k.updating;
            switch (b.type) {
              case "add":
                if (O.fire === Ie) break;
                return w._promise("readwrite", function() {
                  return L(b);
                }, !0);
              case "put":
                if (O.fire === Ie && F.fire === Ie) break;
                return w._promise("readwrite", function() {
                  return L(b);
                }, !0);
              case "delete":
                if (A.fire === Ie) break;
                return w._promise("readwrite", function() {
                  return L(b);
                }, !0);
              case "deleteRange":
                if (A.fire === Ie) break;
                return w._promise("readwrite", function() {
                  return (function I(H, z, M) {
                    return p.query({ trans: H, values: !1, query: { index: m, range: z }, limit: M }).then(function(N) {
                      var B = N.result;
                      return L({ type: "delete", keys: B, trans: H }).then(function(V) {
                        return 0 < V.numFailures ? Promise.reject(V.failures[0]) : B.length < M ? { failures: [], numFailures: 0, lastResult: void 0 } : I(H, t(t({}, z), { lower: B[B.length - 1], lowerOpen: !0 }), M);
                      });
                    });
                  })(b.trans, b.range, 1e4);
                }, !0);
            }
            return p.mutate(b);
            function L(I) {
              var H, z, M, N = te.trans, B = I.keys || lo(m, I);
              if (!B) throw new Error("Keys missing");
              return (I = I.type === "add" || I.type === "put" ? t(t({}, I), { keys: B }) : t({}, I)).type !== "delete" && (I.values = i([], I.values)), I.keys && (I.keys = i([], I.keys)), H = p, M = B, ((z = I).type === "add" ? Promise.resolve([]) : H.getMany({ trans: z.trans, keys: M, cache: "immutable" })).then(function(V) {
                var j = B.map(function(q, K) {
                  var J, ne, ee, ie = V[K], ae = { onerror: null, onsuccess: null };
                  return I.type === "delete" ? A.fire.call(ae, q, ie, N) : I.type === "add" || ie === void 0 ? (J = O.fire.call(ae, q, I.values[K], N), q == null && J != null && (I.keys[K] = q = J, m.outbound || me(I.values[K], m.keyPath, q))) : (J = ao(ie, I.values[K]), (ne = F.fire.call(ae, J, q, ie, N)) && (ee = I.values[K], Object.keys(ne).forEach(function(se) {
                    f(ee, se) ? ee[se] = ne[se] : me(ee, se, ne[se]);
                  }))), ae;
                });
                return p.mutate(I).then(function(q) {
                  for (var K = q.failures, J = q.results, ne = q.numFailures, q = q.lastResult, ee = 0; ee < B.length; ++ee) {
                    var ie = (J || B)[ee], ae = j[ee];
                    ie == null ? ae.onerror && ae.onerror(K[ee]) : ae.onsuccess && ae.onsuccess(I.type === "put" && V[ee] ? I.values[ee] : ie);
                  }
                  return { failures: K, results: J, numFailures: ne, lastResult: q };
                }).catch(function(q) {
                  return j.forEach(function(K) {
                    return K.onerror && K.onerror(q);
                  }), Promise.reject(q);
                });
              });
            }
          } });
        } });
      } };
      function Qs(l, d, p) {
        try {
          if (!d || d.keys.length < l.length) return null;
          for (var m = [], b = 0, w = 0; b < d.keys.length && w < l.length; ++b) Ee(d.keys[b], l[w]) === 0 && (m.push(p ? Ae(d.values[b]) : d.values[b]), ++w);
          return m.length === l.length ? m : null;
        } catch {
          return null;
        }
      }
      var jc = { stack: "dbcore", level: -1, create: function(l) {
        return { table: function(d) {
          var p = l.table(d);
          return t(t({}, p), { getMany: function(m) {
            if (!m.cache) return p.getMany(m);
            var b = Qs(m.keys, m.trans._cache, m.cache === "clone");
            return b ? oe.resolve(b) : p.getMany(m).then(function(w) {
              return m.trans._cache = { keys: m.keys, values: m.cache === "clone" ? Ae(w) : w }, w;
            });
          }, mutate: function(m) {
            return m.type !== "add" && (m.trans._cache = null), p.mutate(m);
          } });
        } };
      } };
      function Js(l, d) {
        return l.trans.mode === "readonly" && !!l.subscr && !l.trans.explicit && l.trans.db._options.cache !== "disabled" && !d.schema.primaryKey.outbound;
      }
      function $s(l, d) {
        switch (l) {
          case "query":
            return d.values && !d.unique;
          case "get":
          case "getMany":
          case "count":
          case "openCursor":
            return !1;
        }
      }
      var Gc = { stack: "dbcore", level: 0, name: "Observability", create: function(l) {
        var d = l.schema.name, p = new st(l.MIN_KEY, l.MAX_KEY);
        return t(t({}, l), { transaction: function(m, b, w) {
          if (te.subscr && b !== "readonly") throw new fe.ReadOnly("Readwrite transaction in liveQuery context. Querier source: ".concat(te.querier));
          return l.transaction(m, b, w);
        }, table: function(m) {
          var b = l.table(m), w = b.schema, k = w.primaryKey, I = w.indexes, A = k.extractKey, O = k.outbound, F = k.autoIncrement && I.filter(function(z) {
            return z.compound && z.keyPath.includes(k.keyPath);
          }), L = t(t({}, b), { mutate: function(z) {
            function M(se) {
              return se = "idb://".concat(d, "/").concat(m, "/").concat(se), q[se] || (q[se] = new st());
            }
            var N, B, V, j = z.trans, q = z.mutatedParts || (z.mutatedParts = {}), K = M(""), J = M(":dels"), ne = z.type, ae = z.type === "deleteRange" ? [z.range] : z.type === "delete" ? [z.keys] : z.values.length < 50 ? [lo(k, z).filter(function(se) {
              return se;
            }), z.values] : [], ee = ae[0], ie = ae[1], ae = z.trans._cache;
            return a(ee) ? (K.addKeys(ee), (ae = ne === "delete" || ee.length === ie.length ? Qs(ee, ae) : null) || J.addKeys(ee), (ae || ie) && (N = M, B = ae, V = ie, w.indexes.forEach(function(se) {
              var le = N(se.name || "");
              function xe(we) {
                return we != null ? se.extractKey(we) : null;
              }
              function Pe(we) {
                return se.multiEntry && a(we) ? we.forEach(function(je) {
                  return le.addKey(je);
                }) : le.addKey(we);
              }
              (B || V).forEach(function(we, at) {
                var ye = B && xe(B[at]), at = V && xe(V[at]);
                Ee(ye, at) !== 0 && (ye != null && Pe(ye), at != null && Pe(at));
              });
            }))) : ee ? (ie = { from: (ie = ee.lower) !== null && ie !== void 0 ? ie : l.MIN_KEY, to: (ie = ee.upper) !== null && ie !== void 0 ? ie : l.MAX_KEY }, J.add(ie), K.add(ie)) : (K.add(p), J.add(p), w.indexes.forEach(function(se) {
              return M(se.name).add(p);
            })), b.mutate(z).then(function(se) {
              return !ee || z.type !== "add" && z.type !== "put" || (K.addKeys(se.results), F && F.forEach(function(le) {
                for (var xe = z.values.map(function(ye) {
                  return le.extractKey(ye);
                }), Pe = le.keyPath.findIndex(function(ye) {
                  return ye === k.keyPath;
                }), we = 0, je = se.results.length; we < je; ++we) xe[we][Pe] = se.results[we];
                M(le.name).addKeys(xe);
              })), j.mutatedParts = Ur(j.mutatedParts || {}, q), se;
            });
          } }), I = function(M) {
            var N = M.query, M = N.index, N = N.range;
            return [M, new st((M = N.lower) !== null && M !== void 0 ? M : l.MIN_KEY, (N = N.upper) !== null && N !== void 0 ? N : l.MAX_KEY)];
          }, H = { get: function(z) {
            return [k, new st(z.key)];
          }, getMany: function(z) {
            return [k, new st().addKeys(z.keys)];
          }, count: I, query: I, openCursor: I };
          return o(H).forEach(function(z) {
            L[z] = function(M) {
              var N = te.subscr, B = !!N, V = Js(te, b) && $s(z, M) ? M.obsSet = {} : N;
              if (B) {
                var j = function(ie) {
                  return ie = "idb://".concat(d, "/").concat(m, "/").concat(ie), V[ie] || (V[ie] = new st());
                }, q = j(""), K = j(":dels"), N = H[z](M), B = N[0], N = N[1];
                if ((z === "query" && B.isPrimaryKey && !M.values ? K : j(B.name || "")).add(N), !B.isPrimaryKey) {
                  if (z !== "count") {
                    var J = z === "query" && O && M.values && b.query(t(t({}, M), { values: !1 }));
                    return b[z].apply(this, arguments).then(function(ie) {
                      if (z === "query") {
                        if (O && M.values) return J.then(function(xe) {
                          return xe = xe.result, q.addKeys(xe), ie;
                        });
                        var ae = M.values ? ie.result.map(A) : ie.result;
                        (M.values ? q : K).addKeys(ae);
                      } else if (z === "openCursor") {
                        var se = ie, le = M.values;
                        return se && Object.create(se, { key: { get: function() {
                          return K.addKey(se.primaryKey), se.key;
                        } }, primaryKey: { get: function() {
                          var xe = se.primaryKey;
                          return K.addKey(xe), xe;
                        } }, value: { get: function() {
                          return le && q.addKey(se.primaryKey), se.value;
                        } } });
                      }
                      return ie;
                    });
                  }
                  K.add(p);
                }
              }
              return b[z].apply(this, arguments);
            };
          }), L;
        } });
      } };
      function ea(l, d, p) {
        if (p.numFailures === 0) return d;
        if (d.type === "deleteRange") return null;
        var m = d.keys ? d.keys.length : "values" in d && d.values ? d.values.length : 1;
        return p.numFailures === m ? null : (d = t({}, d), a(d.keys) && (d.keys = d.keys.filter(function(b, w) {
          return !(w in p.failures);
        })), "values" in d && a(d.values) && (d.values = d.values.filter(function(b, w) {
          return !(w in p.failures);
        })), d);
      }
      function co(l, d) {
        return p = l, ((m = d).lower === void 0 || (m.lowerOpen ? 0 < Ee(p, m.lower) : 0 <= Ee(p, m.lower))) && (l = l, (d = d).upper === void 0 || (d.upperOpen ? Ee(l, d.upper) < 0 : Ee(l, d.upper) <= 0));
        var p, m;
      }
      function ta(l, d, H, m, b, w) {
        if (!H || H.length === 0) return l;
        var k = d.query.index, A = k.multiEntry, O = d.query.range, F = m.schema.primaryKey.extractKey, L = k.extractKey, I = (k.lowLevelIndex || k).extractKey, H = H.reduce(function(z, M) {
          var N = z, B = [];
          if (M.type === "add" || M.type === "put") for (var V = new st(), j = M.values.length - 1; 0 <= j; --j) {
            var q, K = M.values[j], J = F(K);
            V.hasKey(J) || (q = L(K), (A && a(q) ? q.some(function(se) {
              return co(se, O);
            }) : co(q, O)) && (V.addKey(J), B.push(K)));
          }
          switch (M.type) {
            case "add":
              var ne = new st().addKeys(d.values ? z.map(function(le) {
                return F(le);
              }) : z), N = z.concat(d.values ? B.filter(function(le) {
                return le = F(le), !ne.hasKey(le) && (ne.addKey(le), !0);
              }) : B.map(function(le) {
                return F(le);
              }).filter(function(le) {
                return !ne.hasKey(le) && (ne.addKey(le), !0);
              }));
              break;
            case "put":
              var ee = new st().addKeys(M.values.map(function(le) {
                return F(le);
              }));
              N = z.filter(function(le) {
                return !ee.hasKey(d.values ? F(le) : le);
              }).concat(d.values ? B : B.map(function(le) {
                return F(le);
              }));
              break;
            case "delete":
              var ie = new st().addKeys(M.keys);
              N = z.filter(function(le) {
                return !ie.hasKey(d.values ? F(le) : le);
              });
              break;
            case "deleteRange":
              var ae = M.range;
              N = z.filter(function(le) {
                return !co(F(le), ae);
              });
          }
          return N;
        }, l);
        return H === l ? l : (H.sort(function(z, M) {
          return Ee(I(z), I(M)) || Ee(F(z), F(M));
        }), d.limit && d.limit < 1 / 0 && (H.length > d.limit ? H.length = d.limit : l.length === d.limit && H.length < d.limit && (b.dirty = !0)), w ? Object.freeze(H) : H);
      }
      function ia(l, d) {
        return Ee(l.lower, d.lower) === 0 && Ee(l.upper, d.upper) === 0 && !!l.lowerOpen == !!d.lowerOpen && !!l.upperOpen == !!d.upperOpen;
      }
      function qc(l, d) {
        return (function(p, m, b, w) {
          if (p === void 0) return m !== void 0 ? -1 : 0;
          if (m === void 0) return 1;
          if ((m = Ee(p, m)) === 0) {
            if (b && w) return 0;
            if (b) return 1;
            if (w) return -1;
          }
          return m;
        })(l.lower, d.lower, l.lowerOpen, d.lowerOpen) <= 0 && 0 <= (function(p, m, b, w) {
          if (p === void 0) return m !== void 0 ? 1 : 0;
          if (m === void 0) return -1;
          if ((m = Ee(p, m)) === 0) {
            if (b && w) return 0;
            if (b) return -1;
            if (w) return 1;
          }
          return m;
        })(l.upper, d.upper, l.upperOpen, d.upperOpen);
      }
      function Kc(l, d, p, m) {
        l.subscribers.add(p), m.addEventListener("abort", function() {
          var b, w;
          l.subscribers.delete(p), l.subscribers.size === 0 && (b = l, w = d, setTimeout(function() {
            b.subscribers.size === 0 && Ve(w, b);
          }, 3e3));
        });
      }
      var Zc = { stack: "dbcore", level: 0, name: "Cache", create: function(l) {
        var d = l.schema.name;
        return t(t({}, l), { transaction: function(p, m, b) {
          var w, k, A = l.transaction(p, m, b);
          return m === "readwrite" && (k = (w = new AbortController()).signal, b = function(O) {
            return function() {
              if (w.abort(), m === "readwrite") {
                for (var F = /* @__PURE__ */ new Set(), L = 0, I = p; L < I.length; L++) {
                  var H = I[L], z = ti["idb://".concat(d, "/").concat(H)];
                  if (z) {
                    var M = l.table(H), N = z.optimisticOps.filter(function(le) {
                      return le.trans === A;
                    });
                    if (A._explicit && O && A.mutatedParts) for (var B = 0, V = Object.values(z.queries.query); B < V.length; B++) for (var j = 0, q = (ne = V[B]).slice(); j < q.length; j++) io((ee = q[j]).obsSet, A.mutatedParts) && (Ve(ne, ee), ee.subscribers.forEach(function(le) {
                      return F.add(le);
                    }));
                    else if (0 < N.length) {
                      z.optimisticOps = z.optimisticOps.filter(function(le) {
                        return le.trans !== A;
                      });
                      for (var K = 0, J = Object.values(z.queries.query); K < J.length; K++) for (var ne, ee, ie, ae = 0, se = (ne = J[K]).slice(); ae < se.length; ae++) (ee = se[ae]).res != null && A.mutatedParts && (O && !ee.dirty ? (ie = Object.isFrozen(ee.res), ie = ta(ee.res, ee.req, N, M, ee, ie), ee.dirty ? (Ve(ne, ee), ee.subscribers.forEach(function(le) {
                        return F.add(le);
                      })) : ie !== ee.res && (ee.res = ie, ee.promise = oe.resolve({ result: ie }))) : (ee.dirty && Ve(ne, ee), ee.subscribers.forEach(function(le) {
                        return F.add(le);
                      })));
                    }
                  }
                }
                F.forEach(function(le) {
                  return le();
                });
              }
            };
          }, A.addEventListener("abort", b(!1), { signal: k }), A.addEventListener("error", b(!1), { signal: k }), A.addEventListener("complete", b(!0), { signal: k })), A;
        }, table: function(p) {
          var m = l.table(p), b = m.schema.primaryKey;
          return t(t({}, m), { mutate: function(w) {
            var k = te.trans;
            if (b.outbound || k.db._options.cache === "disabled" || k.explicit || k.idbtrans.mode !== "readwrite") return m.mutate(w);
            var A = ti["idb://".concat(d, "/").concat(p)];
            return A ? (k = m.mutate(w), w.type !== "add" && w.type !== "put" || !(50 <= w.values.length || lo(b, w).some(function(O) {
              return O == null;
            })) ? (A.optimisticOps.push(w), w.mutatedParts && Wr(w.mutatedParts), k.then(function(O) {
              0 < O.numFailures && (Ve(A.optimisticOps, w), (O = ea(0, w, O)) && A.optimisticOps.push(O), w.mutatedParts && Wr(w.mutatedParts));
            }), k.catch(function() {
              Ve(A.optimisticOps, w), w.mutatedParts && Wr(w.mutatedParts);
            })) : k.then(function(O) {
              var F = ea(0, t(t({}, w), { values: w.values.map(function(L, I) {
                var H;
                return O.failures[I] ? L : (L = (H = b.keyPath) !== null && H !== void 0 && H.includes(".") ? Ae(L) : t({}, L), me(L, b.keyPath, O.results[I]), L);
              }) }), O);
              A.optimisticOps.push(F), queueMicrotask(function() {
                return w.mutatedParts && Wr(w.mutatedParts);
              });
            }), k) : m.mutate(w);
          }, query: function(w) {
            if (!Js(te, m) || !$s("query", w)) return m.query(w);
            var k = ((F = te.trans) === null || F === void 0 ? void 0 : F.db._options.cache) === "immutable", I = te, A = I.requery, O = I.signal, F = (function(M, N, B, V) {
              var j = ti["idb://".concat(M, "/").concat(N)];
              if (!j) return [];
              if (!(N = j.queries[B])) return [null, !1, j, null];
              var q = N[(V.query ? V.query.index.name : null) || ""];
              if (!q) return [null, !1, j, null];
              switch (B) {
                case "query":
                  var K = q.find(function(J) {
                    return J.req.limit === V.limit && J.req.values === V.values && ia(J.req.query.range, V.query.range);
                  });
                  return K ? [K, !0, j, q] : [q.find(function(J) {
                    return ("limit" in J.req ? J.req.limit : 1 / 0) >= V.limit && (!V.values || J.req.values) && qc(J.req.query.range, V.query.range);
                  }), !1, j, q];
                case "count":
                  return K = q.find(function(J) {
                    return ia(J.req.query.range, V.query.range);
                  }), [K, !!K, j, q];
              }
            })(d, p, "query", w), L = F[0], I = F[1], H = F[2], z = F[3];
            return L && I ? L.obsSet = w.obsSet : (I = m.query(w).then(function(M) {
              var N = M.result;
              if (L && (L.res = N), k) {
                for (var B = 0, V = N.length; B < V; ++B) Object.freeze(N[B]);
                Object.freeze(N);
              } else M.result = Ae(N);
              return M;
            }).catch(function(M) {
              return z && L && Ve(z, L), Promise.reject(M);
            }), L = { obsSet: w.obsSet, promise: I, subscribers: /* @__PURE__ */ new Set(), type: "query", req: w, dirty: !1 }, z ? z.push(L) : (z = [L], (H = H || (ti["idb://".concat(d, "/").concat(p)] = { queries: { query: {}, count: {} }, objs: /* @__PURE__ */ new Map(), optimisticOps: [], unsignaledParts: {} })).queries.query[w.query.index.name || ""] = z)), Kc(L, z, A, O), L.promise.then(function(M) {
              return { result: ta(M.result, w, H?.optimisticOps, m, L, k) };
            });
          } });
        } });
      } };
      function Gr(l, d) {
        return new Proxy(l, { get: function(p, m, b) {
          return m === "db" ? d : Reflect.get(p, m, b);
        } });
      }
      var At = (Ye.prototype.version = function(l) {
        if (isNaN(l) || l < 0.1) throw new fe.Type("Given version is not a positive number");
        if (l = Math.round(10 * l) / 10, this.idbdb || this._state.isBeingOpened) throw new fe.Schema("Cannot add version when database is open");
        this.verno = Math.max(this.verno, l);
        var d = this._versions, p = d.filter(function(m) {
          return m._cfg.version === l;
        })[0];
        return p || (p = new this.Version(l), d.push(p), d.sort(Lc), p.stores({}), this._state.autoSchema = !1, p);
      }, Ye.prototype._whenReady = function(l) {
        var d = this;
        return this.idbdb && (this._state.openComplete || te.letThrough || this._vip) ? l() : new oe(function(p, m) {
          if (d._state.openComplete) return m(new fe.DatabaseClosed(d._state.dbOpenError));
          if (!d._state.isBeingOpened) {
            if (!d._state.autoOpen) return void m(new fe.DatabaseClosed());
            d.open().catch(Ie);
          }
          d._state.dbReadyPromise.then(p, m);
        }).then(l);
      }, Ye.prototype.use = function(l) {
        var d = l.stack, p = l.create, m = l.level, b = l.name;
        return b && this.unuse({ stack: d, name: b }), l = this._middlewares[d] || (this._middlewares[d] = []), l.push({ stack: d, create: p, level: m ?? 10, name: b }), l.sort(function(w, k) {
          return w.level - k.level;
        }), this;
      }, Ye.prototype.unuse = function(l) {
        var d = l.stack, p = l.name, m = l.create;
        return d && this._middlewares[d] && (this._middlewares[d] = this._middlewares[d].filter(function(b) {
          return m ? b.create !== m : !!p && b.name !== p;
        })), this;
      }, Ye.prototype.open = function() {
        var l = this;
        return Jt(de, function() {
          return Vc(l);
        });
      }, Ye.prototype._close = function() {
        this.on.close.fire(new CustomEvent("close"));
        var l = this._state, d = Ci.indexOf(this);
        if (0 <= d && Ci.splice(d, 1), this.idbdb) {
          try {
            this.idbdb.close();
          } catch {
          }
          this.idbdb = null;
        }
        l.isBeingOpened || (l.dbReadyPromise = new oe(function(p) {
          l.dbReadyResolve = p;
        }), l.openCanceller = new oe(function(p, m) {
          l.cancelOpen = m;
        }));
      }, Ye.prototype.close = function(p) {
        var d = (p === void 0 ? { disableAutoOpen: !0 } : p).disableAutoOpen, p = this._state;
        d ? (p.isBeingOpened && p.cancelOpen(new fe.DatabaseClosed()), this._close(), p.autoOpen = !1, p.dbOpenError = new fe.DatabaseClosed()) : (this._close(), p.autoOpen = this._options.autoOpen || p.isBeingOpened, p.openComplete = !1, p.dbOpenError = null);
      }, Ye.prototype.delete = function(l) {
        var d = this;
        l === void 0 && (l = { disableAutoOpen: !0 });
        var p = 0 < arguments.length && typeof arguments[0] != "object", m = this._state;
        return new oe(function(b, w) {
          function k() {
            d.close(l);
            var A = d._deps.indexedDB.deleteDatabase(d.name);
            A.onsuccess = Ne(function() {
              var O, F, L;
              O = d._deps, F = d.name, L = O.indexedDB, O = O.IDBKeyRange, $n(L) || F === Ar || Jn(L, O).delete(F).catch(Ie), b();
            }), A.onerror = Tt(w), A.onblocked = d._fireOnBlocked;
          }
          if (p) throw new fe.InvalidArgument("Invalid closeOptions argument to db.delete()");
          m.isBeingOpened ? m.dbReadyPromise.then(k) : k();
        });
      }, Ye.prototype.backendDB = function() {
        return this.idbdb;
      }, Ye.prototype.isOpen = function() {
        return this.idbdb !== null;
      }, Ye.prototype.hasBeenClosed = function() {
        var l = this._state.dbOpenError;
        return l && l.name === "DatabaseClosed";
      }, Ye.prototype.hasFailed = function() {
        return this._state.dbOpenError !== null;
      }, Ye.prototype.dynamicallyOpened = function() {
        return this._state.autoSchema;
      }, Object.defineProperty(Ye.prototype, "tables", { get: function() {
        var l = this;
        return o(this._allTables).map(function(d) {
          return l._allTables[d];
        });
      }, enumerable: !1, configurable: !0 }), Ye.prototype.transaction = function() {
        var l = (function(d, p, m) {
          var b = arguments.length;
          if (b < 2) throw new fe.InvalidArgument("Too few arguments");
          for (var w = new Array(b - 1); --b; ) w[b - 1] = arguments[b];
          return m = w.pop(), [d, He(w), m];
        }).apply(this, arguments);
        return this._transaction.apply(this, l);
      }, Ye.prototype._transaction = function(l, d, p) {
        var m = this, b = te.trans;
        b && b.db === this && l.indexOf("!") === -1 || (b = null);
        var w, k, A = l.indexOf("?") !== -1;
        l = l.replace("!", "").replace("?", "");
        try {
          if (k = d.map(function(F) {
            if (F = F instanceof m.Table ? F.name : F, typeof F != "string") throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
            return F;
          }), l == "r" || l === Vn) w = Vn;
          else {
            if (l != "rw" && l != Un) throw new fe.InvalidArgument("Invalid transaction mode: " + l);
            w = Un;
          }
          if (b) {
            if (b.mode === Vn && w === Un) {
              if (!A) throw new fe.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
              b = null;
            }
            b && k.forEach(function(F) {
              if (b && b.storeNames.indexOf(F) === -1) {
                if (!A) throw new fe.SubTransaction("Table " + F + " not included in parent transaction.");
                b = null;
              }
            }), A && b && !b.active && (b = null);
          }
        } catch (F) {
          return b ? b._promise(null, function(L, I) {
            I(F);
          }) : Ze(F);
        }
        var O = (function F(L, I, H, z, M) {
          return oe.resolve().then(function() {
            var N = te.transless || te, B = L._createTransaction(I, H, L._dbSchema, z);
            if (B.explicit = !0, N = { trans: B, transless: N }, z) B.idbtrans = z.idbtrans;
            else try {
              B.create(), B.idbtrans._explicit = !0, L._state.PR1398_maxLoop = 3;
            } catch (q) {
              return q.name === xt.InvalidState && L.isOpen() && 0 < --L._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), L.close({ disableAutoOpen: !1 }), L.open().then(function() {
                return F(L, I, H, null, M);
              })) : Ze(q);
            }
            var V, j = Yt(M);
            return j && xi(), N = oe.follow(function() {
              var q;
              (V = M.call(B, B)) && (j ? (q = Lt.bind(null, null), V.then(q, q)) : typeof V.next == "function" && typeof V.throw == "function" && (V = so(V)));
            }, N), (V && typeof V.then == "function" ? oe.resolve(V).then(function(q) {
              return B.active ? q : Ze(new fe.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"));
            }) : N.then(function() {
              return V;
            })).then(function(q) {
              return z && B._resolve(), B._completion.then(function() {
                return q;
              });
            }).catch(function(q) {
              return B._reject(q), Ze(q);
            });
          });
        }).bind(null, this, w, k, b, p);
        return b ? b._promise(w, O, "lock") : te.trans ? Jt(te.transless, function() {
          return m._whenReady(O);
        }) : this._whenReady(O);
      }, Ye.prototype.table = function(l) {
        if (!f(this._allTables, l)) throw new fe.InvalidTable("Table ".concat(l, " does not exist"));
        return this._allTables[l];
      }, Ye);
      function Ye(l, d) {
        var p = this;
        this._middlewares = {}, this.verno = 0;
        var m = Ye.dependencies;
        this._options = d = t({ addons: Ye.addons, autoOpen: !0, indexedDB: m.indexedDB, IDBKeyRange: m.IDBKeyRange, cache: "cloned" }, d), this._deps = { indexedDB: d.indexedDB, IDBKeyRange: d.IDBKeyRange }, m = d.addons, this._dbSchema = {}, this._versions = [], this._storeNames = [], this._allTables = {}, this.idbdb = null, this._novip = this;
        var b, w, k, A, O, F = { dbOpenError: null, isBeingOpened: !1, onReadyBeingFired: null, openComplete: !1, dbReadyResolve: Ie, dbReadyPromise: null, cancelOpen: Ie, openCanceller: null, autoSchema: !0, PR1398_maxLoop: 3, autoOpen: d.autoOpen };
        F.dbReadyPromise = new oe(function(I) {
          F.dbReadyResolve = I;
        }), F.openCanceller = new oe(function(I, H) {
          F.cancelOpen = H;
        }), this._state = F, this.name = l, this.on = qi(this, "populate", "blocked", "versionchange", "close", { ready: [X, Ie] }), this.once = function(I, H) {
          var z = function() {
            for (var M = [], N = 0; N < arguments.length; N++) M[N] = arguments[N];
            p.on(I).unsubscribe(z), H.apply(p, M);
          };
          return p.on(I, z);
        }, this.on.ready.subscribe = Z(this.on.ready.subscribe, function(I) {
          return function(H, z) {
            Ye.vip(function() {
              var M, N = p._state;
              N.openComplete ? (N.dbOpenError || oe.resolve().then(H), z && I(H)) : N.onReadyBeingFired ? (N.onReadyBeingFired.push(H), z && I(H)) : (I(H), M = p, z || I(function B() {
                M.on.ready.unsubscribe(H), M.on.ready.unsubscribe(B);
              }));
            });
          };
        }), this.Collection = (b = this, Ki(Ac.prototype, function(V, B) {
          this.db = b;
          var z = Ds, M = null;
          if (B) try {
            z = B();
          } catch (j) {
            M = j;
          }
          var N = V._ctx, B = N.table, V = B.hook.reading.fire;
          this._ctx = { table: B, index: N.index, isPrimKey: !N.index || B.schema.primKey.keyPath && N.index === B.schema.primKey.name, range: z, keysOnly: !1, dir: "next", unique: "", algorithm: null, filter: null, replayFilter: null, justLimit: !0, isMatch: null, offset: 0, limit: 1 / 0, error: M, or: N.or, valueMapper: V !== Ct ? V : null };
        })), this.Table = (w = this, Ki(Ms.prototype, function(I, H, z) {
          this.db = w, this._tx = z, this.name = I, this.schema = H, this.hook = w._allTables[I] ? w._allTables[I].hook : qi(null, { creating: [Ft, Ie], reading: [ji, Ct], updating: [P, Ie], deleting: [v, Ie] });
        })), this.Transaction = (k = this, Ki(Oc.prototype, function(I, H, z, M, N) {
          var B = this;
          I !== "readonly" && H.forEach(function(V) {
            V = (V = z[V]) === null || V === void 0 ? void 0 : V.yProps, V && (H = H.concat(V.map(function(j) {
              return j.updatesTable;
            })));
          }), this.db = k, this.mode = I, this.storeNames = H, this.schema = z, this.chromeTransactionDurability = M, this.idbtrans = null, this.on = qi(this, "complete", "error", "abort"), this.parent = N || null, this.active = !0, this._reculock = 0, this._blockedFuncs = [], this._resolve = null, this._reject = null, this._waitingFor = null, this._waitingQueue = null, this._spinCount = 0, this._completion = new oe(function(V, j) {
            B._resolve = V, B._reject = j;
          }), this._completion.then(function() {
            B.active = !1, B.on.complete.fire();
          }, function(V) {
            var j = B.active;
            return B.active = !1, B.on.error.fire(V), B.parent ? B.parent._reject(V) : j && B.idbtrans && B.idbtrans.abort(), Ze(V);
          });
        })), this.Version = (A = this, Ki(Hc.prototype, function(I) {
          this.db = A, this._cfg = { version: I, storesSource: null, dbschema: {}, tables: {}, contentUpgrade: null };
        })), this.WhereClause = (O = this, Ki(Us.prototype, function(I, H, z) {
          if (this.db = O, this._ctx = { table: I, index: H === ":id" ? null : H, or: z }, this._cmp = this._ascending = Ee, this._descending = function(M, N) {
            return Ee(N, M);
          }, this._max = function(M, N) {
            return 0 < Ee(M, N) ? M : N;
          }, this._min = function(M, N) {
            return Ee(M, N) < 0 ? M : N;
          }, this._IDBKeyRange = O._deps.IDBKeyRange, !this._IDBKeyRange) throw new fe.MissingAPI();
        })), this.on("versionchange", function(I) {
          0 < I.newVersion ? console.warn("Another connection wants to upgrade database '".concat(p.name, "'. Closing db now to resume the upgrade.")) : console.warn("Another connection wants to delete database '".concat(p.name, "'. Closing db now to resume the delete request.")), p.close({ disableAutoOpen: !1 });
        }), this.on("blocked", function(I) {
          !I.newVersion || I.newVersion < I.oldVersion ? console.warn("Dexie.delete('".concat(p.name, "') was blocked")) : console.warn("Upgrade '".concat(p.name, "' blocked by other connection holding version ").concat(I.oldVersion / 10));
        }), this._maxKey = Qi(d.IDBKeyRange), this._createTransaction = function(I, H, z, M) {
          return new p.Transaction(I, H, z, p._options.chromeTransactionDurability, M);
        }, this._fireOnBlocked = function(I) {
          p.on("blocked").fire(I), Ci.filter(function(H) {
            return H.name === p.name && H !== p && !H._state.vcFired;
          }).map(function(H) {
            return H.on("versionchange").fire(I);
          });
        }, this.use(jc), this.use(Zc), this.use(Gc), this.use(Uc), this.use(Wc);
        var L = new Proxy(this, { get: function(I, H, z) {
          if (H === "_vip") return !0;
          if (H === "table") return function(N) {
            return Gr(p.table(N), L);
          };
          var M = Reflect.get(I, H, z);
          return M instanceof Ms ? Gr(M, L) : H === "tables" ? M.map(function(N) {
            return Gr(N, L);
          }) : H === "_createTransaction" ? function() {
            return Gr(M.apply(this, arguments), L);
          } : M;
        } });
        this.vip = L, m.forEach(function(I) {
          return I(p);
        });
      }
      var qr, vt = typeof Symbol < "u" && "observable" in Symbol ? Symbol.observable : "@@observable", Yc = (uo.prototype.subscribe = function(l, d, p) {
        return this._subscribe(l && typeof l != "function" ? l : { next: l, error: d, complete: p });
      }, uo.prototype[vt] = function() {
        return this;
      }, uo);
      function uo(l) {
        this._subscribe = l;
      }
      try {
        qr = { indexedDB: r.indexedDB || r.mozIndexedDB || r.webkitIndexedDB || r.msIndexedDB, IDBKeyRange: r.IDBKeyRange || r.webkitIDBKeyRange };
      } catch {
        qr = { indexedDB: null, IDBKeyRange: null };
      }
      function ra(l) {
        var d, p = !1, m = new Yc(function(b) {
          var w = Yt(l), k, A = !1, O = {}, F = {}, L = { get closed() {
            return A;
          }, unsubscribe: function() {
            A || (A = !0, k && k.abort(), I && Ht.storagemutated.unsubscribe(z));
          } };
          b.start && b.start(L);
          var I = !1, H = function() {
            return Hn(M);
          }, z = function(N) {
            Ur(O, N), io(F, O) && H();
          }, M = function() {
            var N, B, V;
            !A && qr.indexedDB && (O = {}, N = {}, k && k.abort(), k = new AbortController(), V = (function(j) {
              var q = yi();
              try {
                w && xi();
                var K = Mt(l, j);
                return K = w ? K.finally(Lt) : K;
              } finally {
                q && wi();
              }
            })(B = { subscr: N, signal: k.signal, requery: H, querier: l, trans: null }), Promise.resolve(V).then(function(j) {
              p = !0, d = j, A || B.signal.aborted || (O = {}, (function(q) {
                for (var K in q) if (f(q, K)) return;
                return 1;
              })(F = N) || I || (Ht(Xi, z), I = !0), Hn(function() {
                return !A && b.next && b.next(j);
              }));
            }, function(j) {
              p = !1, ["DatabaseClosedError", "AbortError"].includes(j?.name) || A || Hn(function() {
                A || b.error && b.error(j);
              });
            }));
          };
          return setTimeout(H, 0), L;
        });
        return m.hasValue = function() {
          return p;
        }, m.getValue = function() {
          return d;
        }, m;
      }
      var ii = At;
      function ho(l) {
        var d = Vt;
        try {
          Vt = !0, Ht.storagemutated.fire(l), oo(l, !0);
        } finally {
          Vt = d;
        }
      }
      g(ii, t(t({}, kt), { delete: function(l) {
        return new ii(l, { addons: [] }).delete();
      }, exists: function(l) {
        return new ii(l, { addons: [] }).open().then(function(d) {
          return d.close(), !0;
        }).catch("NoSuchDatabaseError", function() {
          return !1;
        });
      }, getDatabaseNames: function(l) {
        try {
          return d = ii.dependencies, p = d.indexedDB, d = d.IDBKeyRange, ($n(p) ? Promise.resolve(p.databases()).then(function(m) {
            return m.map(function(b) {
              return b.name;
            }).filter(function(b) {
              return b !== Ar;
            });
          }) : Jn(p, d).toCollection().primaryKeys()).then(l);
        } catch {
          return Ze(new fe.MissingAPI());
        }
        var d, p;
      }, defineClass: function() {
        return function(l) {
          c(this, l);
        };
      }, ignoreTransaction: function(l) {
        return te.trans ? Jt(te.transless, l) : l();
      }, vip: eo, async: function(l) {
        return function() {
          try {
            var d = so(l.apply(this, arguments));
            return d && typeof d.then == "function" ? d : oe.resolve(d);
          } catch (p) {
            return Ze(p);
          }
        };
      }, spawn: function(l, d, p) {
        try {
          var m = so(l.apply(p, d || []));
          return m && typeof m.then == "function" ? m : oe.resolve(m);
        } catch (b) {
          return Ze(b);
        }
      }, currentTransaction: { get: function() {
        return te.trans || null;
      } }, waitFor: function(l, d) {
        return d = oe.resolve(typeof l == "function" ? ii.ignoreTransaction(l) : l).timeout(d || 6e4), te.trans ? te.trans.waitFor(d) : d;
      }, Promise: oe, debug: { get: function() {
        return $;
      }, set: function(l) {
        he(l);
      } }, derive: E, extend: c, props: g, override: Z, Events: qi, on: Ht, liveQuery: ra, extendObservabilitySet: Ur, getByKeyPath: ue, setByKeyPath: me, delByKeyPath: function(l, d) {
        typeof d == "string" ? me(l, d, void 0) : "length" in d && [].map.call(d, function(p) {
          me(l, p, void 0);
        });
      }, shallowClone: Te, deepClone: Ae, getObjectDiff: ao, cmp: Ee, asap: re, minKey: -1 / 0, addons: [], connections: Ci, errnames: xt, dependencies: qr, cache: ti, semVer: "4.2.0", version: "4.2.0".split(".").map(function(l) {
        return parseInt(l);
      }).reduce(function(l, d, p) {
        return l + d / Math.pow(10, 2 * p);
      }) })), ii.maxKey = Qi(ii.dependencies.IDBKeyRange), typeof dispatchEvent < "u" && typeof addEventListener < "u" && (Ht(Xi, function(l) {
        Vt || (l = new CustomEvent(Gn, { detail: l }), Vt = !0, dispatchEvent(l), Vt = !1);
      }), addEventListener(Gn, function(l) {
        l = l.detail, Vt || ho(l);
      }));
      var Si, Vt = !1, na = function() {
      };
      return typeof BroadcastChannel < "u" && ((na = function() {
        (Si = new BroadcastChannel(Gn)).onmessage = function(l) {
          return l.data && ho(l.data);
        };
      })(), typeof Si.unref == "function" && Si.unref(), Ht(Xi, function(l) {
        Vt || Si.postMessage(l);
      })), typeof addEventListener < "u" && (addEventListener("pagehide", function(l) {
        if (!At.disableBfCache && l.persisted) {
          $ && console.debug("Dexie: handling persisted pagehide"), Si?.close();
          for (var d = 0, p = Ci; d < p.length; d++) p[d].close({ disableAutoOpen: !1 });
        }
      }), addEventListener("pageshow", function(l) {
        !At.disableBfCache && l.persisted && ($ && console.debug("Dexie: handling persisted pageshow"), na(), ho({ all: new st(-1 / 0, [[]]) }));
      })), oe.rejectionMapper = function(l, d) {
        return !l || l instanceof be || l instanceof TypeError || l instanceof SyntaxError || !l.name || !Qt[l.name] ? l : (d = new Qt[l.name](d || l.message, l), "stack" in l && C(d, "stack", { get: function() {
          return this.inner.stack;
        } }), d);
      }, he($), t(At, Object.freeze({ __proto__: null, Dexie: At, liveQuery: ra, Entity: Os, cmp: Ee, PropModification: Zi, replacePrefix: function(l, d) {
        return new Zi({ replacePrefix: [l, d] });
      }, add: function(l) {
        return new Zi({ add: l });
      }, remove: function(l) {
        return new Zi({ remove: l });
      }, default: At, RangeSet: st, mergeRanges: er, rangesOverlap: Ks }), { default: At }), At;
    });
  })(ln)), ln.exports;
}
var Up = Vp();
const Yo = /* @__PURE__ */ mc(Up), $a = Symbol.for("Dexie"), En = globalThis[$a] || (globalThis[$a] = Yo);
if (Yo.semVer !== En.semVer)
  throw new Error(`Two different versions of Dexie loaded in the same app: ${Yo.semVer} and ${En.semVer}`);
const {
  liveQuery: Om,
  mergeRanges: zm,
  rangesOverlap: Fm,
  RangeSet: Mm,
  cmp: Lm,
  Entity: Bm,
  PropModification: Nm,
  replacePrefix: Hm,
  add: Vm,
  remove: Um,
  DexieYProvider: Wm
} = En, vc = 2, Xo = 3, Wp = class extends Ot {
  constructor() {
    super(), this.kiosk_base_url = "/", this.appErrors = [], this.apiContext = void 0, this.showProgress = !1;
  }
  onAppMessage(n) {
    this.addAppError(n.detail.headline + "<br>" + n.detail.body);
  }
  firstUpdated(n) {
    super.firstUpdated(n), this.addEventListener("send-message", this.onAppMessage);
  }
  updated(n) {
    n.has("apiContext") && (this.showProgress = !1, this.apiContext && this.apiContext.status === Xo && this.addAppError("Cannot connect to Kiosk API."), !n.apiContext && this.apiContext && this.apiConnected());
  }
  apiConnected() {
  }
  render() {
    let n;
    return this.apiContext && this.apiContext.status === vc ? n = this.apiRender() : this.apiContext && this.apiContext.status === Xo ? n = this.renderApiError() : n = this.renderNoContextYet(), We`
            <style>
                .system-message {
                    display: flex;
                    flex-direction: row;
                    justify-content: space-between;
                    border-style: solid;
                    border-width: 2px;
                    padding: 2px 1em;
                    position: relative;
                    margin-bottom: 10px;
                    background: linear-gradient(135deg, #882501, #bb3302);
                    color: #fabc02;
                }
                .system-message i {
                    
                }
                .loading {
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    height: 5px;
                    width: 100vw;
                    background-color: black;
                }
                .loading-progress {
                    height: 5px;
                    width: 100%;
                    border-radius: 3px;
                    background: linear-gradient(
                        90deg,
                        red 0%,
                        yellow 15%,
                        lime 30%,
                        cyan 50%,
                        blue 65%,
                        magenta 80%,
                        red 100%
                    );
                    background-size: 200%;
                    animation: move-gradient 2s ease-in infinite;
                }
                @keyframes move-gradient {
                    0% {
                        background-position: 0% 0%;
                    }
                    100% {
                        background-position: -200% 0%;
                    }
                }
            </style>
            <link rel="stylesheet" href="${this.kiosk_base_url}static/styles.css" />
            ${this.renderProgress()} ${this.renderErrors()} ${n}
        `;
  }
  renderNoContextYet() {
    return We` <link rel="stylesheet" href="${this.kiosk_base_url}static/styles.css" /> `;
  }
  renderApiError() {
  }
  renderErrors() {
    return this.appErrors.length > 0 ? We` ${this.appErrors.map((n) => We`<div class="system-message" @click="${this.errorClicked}"><span>${n}</span><i>x</i></div>`)} ` : ze;
  }
  errorClicked(n) {
    let e = n.currentTarget.children[0].textContent;
    e && this.deleteError(e);
  }
  renderProgress(n = !1) {
    if (n || this.showProgress)
      return We` <div class="loading">
                <div class="loading-progress"></div>
            </div>`;
  }
  addAppError(n) {
    this.appErrors.push(n), this.requestUpdate();
  }
  clearAppErrors() {
    this.appErrors = [], this.requestUpdate();
  }
  deleteError(n) {
    let e = -1;
    this.appErrors.find((t, i) => t === n ? (e = i, !0) : !1), e > -1 && (this.appErrors.splice(e, 1), this.appErrors = [...this.appErrors]);
  }
};
Wp.properties = {
  /**
   * The Api Context
   */
  apiContext: { type: Object },
  appErrors: { type: Array },
  showProgress: { type: Boolean }
};
var jp = Object.defineProperty, Gp = (s, n, e, t) => {
  for (var i = void 0, r = s.length - 1, o; r >= 0; r--)
    (o = s[r]) && (i = o(n, e, i) || i);
  return i && jp(n, e, i), i;
};
const _c = class extends Ot {
  constructor() {
    super(), this.kiosk_base_url = "/", this.showProgress = !1, this.apiContext = void 0;
  }
  updated(n) {
    n.has("apiContext") && (this.showProgress = !1);
  }
  /**
   * dispatches a BeforeEvent and coordinates calling cancelCallback and finishCallback either synchronously or asynchronously, if the
   * consumer of the event used .defer on the event object.
   *
   * The dispatched BeforeEvent has a method "defer" which returns a deferrance object that itself has methods finish and cancel.
   * One of those must be called to complete the event asynchronously.
   *
   * example for an emitter:
   *   tryClose() {
   *       if (!this.emitBeforeEvent("beforeClose", {},
   *           () => {
   *               this.closeDeferred = false
   *           },
   *           () => {
   *               this.open = false
   *           })
   *       ) this.closeDeferred = true
   * }
   *
   * example for an async consumer:
   *   beforeCloseLightbox(e: BeforeEvent) {
   *       const defObj = e.detail.defer(e)
   *       setTimeout(()=>defObj.finish(),1000)
   *   }
   *
   * example for a sync consumer that let's the event succeed:
   *   beforeCloseLightbox(e: BeforeEvent) {
   *       e.stopPropagation()
   *   }
   *
   *  example for a sync consumer that cancels the event:
   *   beforeCloseLightbox(e: BeforeEvent) {
   *       e.stopPropagation()
   *       e.preventDefault()
   *   }
   *
   * @param eventName Name a consumer can listen to
   * @param detail additional data to send to the consumer
   * @param cancelCallback the code to run in case the event gets cancelled (either synchronously or asynchronously)
   * @param finishCallback the code to run in case the event's default behaviour may proceed (either synchronously or asynchronously)
   * @returns false if the consumer of the event asked to defer the result of the event,
   *              otherwise true (in which case the default behaviour will run synchronously)
   */
  emitBeforeEvent(n, e, t, i) {
    let r = {
      // some this math is going on in here: here this points to the beforeEventDetail object. That's why the component's this needed saving
      component: this,
      _defer: !1,
      defer: function(a = void 0) {
        return this._defer = !0, a && (a.stopPropagation(), a.preventDefault()), {
          cancel: () => {
            this.component.updateComplete.then(() => {
              t();
            });
          },
          finish: () => {
            this.component.updateComplete.then(() => {
              i();
            });
          }
        };
      }
    };
    Object.assign(r, e);
    const o = new CustomEvent(n, {
      bubbles: !0,
      composed: !0,
      cancelable: !0,
      detail: r
    });
    if (this.dispatchEvent(o))
      i();
    else {
      if (r._defer)
        return !1;
      t();
    }
    return !0;
  }
  render() {
    let n;
    return this.apiContext && this.apiContext.status === vc ? n = this.apiRender() : this.apiContext && this.apiContext.status === Xo ? n = this.renderApiError() : n = this.renderNoContextYet(), We`
            <link rel="stylesheet" href="${this.kiosk_base_url}static/styles.css" />
            ${n}
        `;
  }
  renderNoContextYet() {
    return We` <link rel="stylesheet" href="${this.kiosk_base_url}static/styles.css" /> `;
  }
  renderApiError() {
  }
  renderProgress(n = !1) {
    if (n || this.showProgress)
      return We` <div class="loading">
                <div class="loading-progress"></div>
            </div>`;
  }
};
_c.properties = {
  /**
   * The Api Context
   */
  apiContext: { type: Object }
};
let Ln = _c;
Gp([
  Pt()
], Ln.prototype, "showProgress");
const Ao = "MSG_NETWORK_ERROR";
class qp {
  constructor(n, e, t = "") {
    this.messageId = n, this.headline = e, this.body = t;
  }
}
function Io(s, n, e, t = "") {
  let i = new qp(
    n,
    e,
    t
  );
  s.dispatchEvent(new CustomEvent(
    "send-message",
    { bubbles: !0, composed: !0, detail: i }
  ));
}
function Kp(s, n) {
  return s && n in s ? s[n] : n.replace("_", " ");
}
function Zp(s, n, e = "", t = null) {
  if (e && (e += ": "), n.response) {
    if (n.response.status == 403 || n.response.status == 401) {
      Io(
        s,
        Ao,
        `${e}You are not logged in properly or your session has timed out`,
        '<a href="/logout">Please log in again.</a>'
      );
      return;
    }
    t ? t(n) : Io(
      s,
      Ao,
      `${e}Kiosk server responded with an error.`,
      `(${n.msg}). 
                The server might be down or perhaps you are not logged in properly.`
    );
  } else {
    Io(
      s,
      Ao,
      `${e}Kiosk server responded with a network error.`,
      `(${n}). 
            The server might be down or perhaps you are not logged in properly.`
    );
    return;
  }
}
class Yp {
  constructor(n) {
    this.apiContext = void 0, this.db = void 0, this.hasRefreshedFavourites = !1, this.hasRefreshedAll = !1, this.localCache = /* @__PURE__ */ new Map(), this.apiContext = n, this.db = this.initDb();
  }
  initDb() {
    const n = new En("KioskTimeZones");
    return n.version(1).stores({
      kioskTimeZones: "&id, tz_long, tz_IANA, deprecated, version, favourite"
    }), n;
  }
  getLocalCache() {
    return this.localCache;
  }
  async getFavouriteTimeZones(n = !1, e = !1) {
    if (this.db) {
      const t = await this.db.kioskTimeZones.count();
      let i;
      return t == 0 && await this.refreshFavourites(), n ? i = await this.db.kioskTimeZones.where({ favourite: 1 }).toArray() : i = await this.db.kioskTimeZones.where({ deprecated: 0, favourite: 1 }).toArray(), e && this.refreshFavourites().finally(() => {
      }), i;
    } else return [];
  }
  async refreshFavourites() {
    if (!this.db) return [];
    if (!this.hasRefreshedFavourites) {
      const n = await this.fetchFavouriteTimeZones();
      if (n && n.length > 0) {
        await this.db?.kioskTimeZones.where("favourite").equals(1).delete();
        const e = n.map((t) => ({
          id: t.id,
          tz_IANA: t.tz_IANA,
          tz_long: t.tz_long,
          deprecated: t.deprecated ? 1 : 0,
          version: t.version,
          favourite: 1
        }));
        return await this.db?.kioskTimeZones.bulkAdd(e), this.hasRefreshedFavourites = !0, e;
      }
    }
    return [];
  }
  async fetchFavouriteTimeZones() {
    return await this.apiContext?.fetchFromApi(
      "",
      "favouritetimezones",
      {
        method: "GET",
        caller: "app.fetchFavouriteTimeZones"
      }
    ).then((n) => n).catch((n) => []);
  }
  async fetchAllTimeZones(n = 0) {
    const e = new URLSearchParams();
    return e.append("include_deprecated", "true"), n > 0 && e.append("newer_than", `${n}`), await this.apiContext?.fetchFromApi(
      "",
      "timezones",
      {
        method: "GET",
        caller: "app.fetchFavouriteTimeZones"
      },
      "v1",
      e
    ).then((t) => t).catch((t) => []);
  }
  async getAllTimeZones(n = !1, e = !1) {
    return await this.refreshAllTimeZones(e), (await this.db?.kioskTimeZones.toArray())?.filter((t) => t.deprecated == 0 || n);
  }
  async getTimeZoneByIndex(n, e = !1) {
    if (!this.db) return;
    await this.refreshAllTimeZones(e);
    let t = await this.db.kioskTimeZones.where("id").equals(n).toArray();
    return t.length > 0 ? t[0] : void 0;
  }
  /**
   * Asynchronously caches the time zone information locally based on the provided timezone index.
   * Locally cached time zone information can be retrieved synchronously using getTimeZoneInfoFromLocalCache
   * @param tzIndex a Kiosk Time Zone Index
   * @param tryRefresh Flag indicating whether to refresh the timezone information if not found in the cache.
   * @returns A Promise that resolves to the cached TimeZone object if found, otherwise undefined.
   */
  async cacheLocally(n, e = !1) {
    if (!this.db || typeof n != "number") return;
    let t = this.localCache.get(n);
    if (t) return t;
    if (t = await this.getTimeZoneByIndex(n), !t) {
      if (!e) return;
      await this.refreshAllTimeZones(!1), t = await this.getTimeZoneByIndex(n);
    }
    return t && this.localCache.set(n, t), this.localCache.get(n);
  }
  /**
   * Retrieves timezone information from the local cache based on the provided timezone index.
   * Unlike other methods this is synchronous.
   * @param tzIndex - The index of the timezone to retrieve information for.
   * @returns a TimeZone instance if found in the local cache, otherwise undefined.
   */
  getTimeZoneInfoFromLocalCache(n) {
    if (typeof n == "string" && (n = parseInt(n)), !!n)
      return this.localCache.get(n);
  }
  async refreshAllTimeZones(n) {
    let e = [];
    if (this.db && (n || !this.hasRefreshedAll)) {
      let t = 0;
      const i = (await this.getFavouriteTimeZones()).filter((o) => o.favourite == 1).map((o) => o.id);
      if (!n)
        try {
          t = (await this.db.kioskTimeZones.where("favourite").equals(0).reverse().sortBy("version"))[0].version;
        } catch {
        }
      const r = await this.fetchAllTimeZones(t);
      r && r.length > 0 && (await this.db.kioskTimeZones.where("version").above(t).delete(), e = r.map((o) => ({
        id: o.id,
        tz_IANA: o.tz_IANA,
        tz_long: o.tz_long,
        deprecated: o.deprecated ? 1 : 0,
        version: o.version,
        favourite: i.includes(o.id) ? 1 : 0
      })), await this.db.kioskTimeZones.bulkAdd(e)), this.hasRefreshedAll = !0;
    }
  }
}
const Xp = '*{padding:0;margin:0;border:0px;-webkit-user-select:none;user-select:none}p,div{-webkit-user-select:text;user-select:text}select{-webkit-user-select:none;user-select:none}.col-bg-body-lighter{background-color:var(--col-bg-body-lighter)}.col-bg-body{background-color:var(--col-bg-body)}.col-bg-body-darker{background-color:var(--col-bg-body-darker)}.col-bg-1-lighter{background-color:var(--col-bg-1-lighter)}.col-bg-1{background-color:var(--col-bg-1)}.col-bg-1-darker{background-color:var(--col-bg-1-darker)}.col-bg-1-input{background-color:var(--col-bg-1-input)}.col-primary-bg-1{background-color:var(--col-primary-bg-1)}.col-accent-bg-1{background-color:var(--col-accent-bg-1)}.col-success-bg-1{background-color:var(--col-success-bg-1)}.col-warning-bg-1{background-color:var(--col-warning-bg-1)}.col-error-bg-1{background-color:var(--col-error-bg-1)}.col-bg-2-lighter{background-color:var(--col-bg-2-lighter)}.col-bg-2{background-color:var(--col-bg-2)}.col-bg-2-darker{background-color:var(--col-bg-2-darker)}.col-bg-2-button{background-color:var(--col-bg-2-button)}.col-bg-2-input{background-color:var(--col-bg-2-input)}.col-primary-bg-2{background-color:var(--col-primary-bg-2)}.col-accent-bg-2{background-color:var(--col-accent-bg-2)}.col-success-bg-2{background-color:var(--col-success-bg-2)}.col-warning-bg-2{background-color:var(--col-warning-bg-2)}.col-error-bg-2{background-color:var(--col-error-bg-2)}.col-bg-3-lighter{background-color:var(--col-bg-3-lighter)}.col-bg-3{background-color:var(--col-bg-3)}.col-bg-3-darker{background-color:var(--col-bg-3-darker)}.col-bg-3-button{background-color:var(--col-bg-3-button)}.col-bg-3-input{background-color:var(--col-bg-3-input)}.col-primary-bg-3{background-color:var(--col-primary-bg-3)}.col-accent-bg-3{background-color:var(--col-accent-bg-3)}.col-success-bg-3{background-color:var(--col-success-bg-3)}.col-warning-bg-3{background-color:var(--col-warning-bg-3)}.col-error-bg-3{background-color:var(--col-error-bg-3)}.col-bg-ack-lighter{background-color:var(--col-bg-ack-lighter)}.col-bg-ack{background-color:var(--col-bg-ack)}.col-bg-ack-darker{background-color:var(--col-bg-ack-darker)}.col-primary-bg-ack{background-color:var(--col-primary-bg-ack)}.col-accent-bg-ack{background-color:var(--col-accent-bg-ack)}.col-bg-att-lighter{background-color:var(--col-bg-att-lighter)}.col-bg-att{background-color:var(--col-bg-att)}.col-bg-att-darker{background-color:var(--col-bg-att-darker)}.col-primary-bg-att{background-color:var(--col-primary-bg-att)}.col-accent-bg-att{background-color:var(--col-accent-bg-att)}.col-bg-alert-lighter{background-color:var(--col-bg-alert-lighter)}.col-bg-alert{background-color:var(--col-bg-alert)}.col-bg-alert-darker{background-color:var(--col-bg-alert-darker)}.col-primary-bg-alert{background-color:var(--col-primary-bg-alert)}.col-accent-bg-alert{background-color:var(--col-accent-bg-alert)}.col-bg-btn-lighter{background-color:var(--col-bg-btn-lighter)}.col-bg-btn{background-color:var(--col-bg-btn)}.col-bg-btn-darker{background-color:var(--col-bg-btn-darker)}.col-primary-bg-btn{background-color:var(--col-primary-bg-btn)}.col-accent-bg-btn{background-color:var(--col-accent-bg-btn)}.pattern-diagonal-stripes-sm{background:repeating-linear-gradient(45deg,transparent,transparent 10px,currentColor 10px,currentColor 20px)}.pattern-dots-lg{background-image:radial-gradient(currentColor 1.5px,transparent 1.5px);background-size:15px 15px}.pattern-dots-md{background-image:radial-gradient(currentColor 1px,transparent 1px);background-size:8px 8px}.pattern-dots-medium-dense{background-image:radial-gradient(currentColor .5px,transparent .5px);background-size:3px 3px}.pattern-dots-sm{background-image:radial-gradient(currentColor .5px,transparent .5px);background-size:5px 5px}.pattern-cross-dots-md,.imagelist-background{background-image:radial-gradient(currentColor .7px,transparent 1px),radial-gradient(currentColor .7px,transparent 1px);background-size:6.5px 6.5px;background-position:0 0,3.5px 3.5px}.imagelist-background{background-color:#fff9;background-blend-mode:overlay}label{font-family:var(--monospace-font);font-size:.9em}input,select{-webkit-user-select:text;-moz-user-select:text;-ms-user-select:text;box-sizing:border-box;border-radius:0;user-select:text;font-family:var(--standard-text-font);background-color:var(--col-bg-1-input);border:none;color:var(--col-primary-bg-1);padding:2px;margin-bottom:2px;outline:none}textarea{outline:none}input:not([type=radio],[type=checkbox]),select,textarea{width:100%}input:not([type=radio],[type=checkbox]):focus,select:focus,textarea:focus{margin-bottom:0;border-bottom:2px solid rgb(0,0,0)}h1{font-size:var(--font-size-h1)}h2{font-size:var(--font-size-h2)}h3{font-size:var(--font-size-h3)}h4{font-size:var(--font-size-h4)}small,.font-small{font-size:var(--font-size-small)}button{width:60px;height:60px;border-radius:35px;border-style:solid;border-width:2px;background-color:var(--col-bg-btn);color:var(--col-primary-bg-btn);border-color:var(--col-bg-btn-darker);font-family:var(--headline-text-font);font-size:var(--font-size-h4);font-weight:700}button:hover,button:focus{outline:none;background-color:var(--col-bg-btn-lighter)}button:active{padding-top:3px;color:var(--col-primary-bg-btn);background-color:var(--col-bg-btn-darker);border-color:var(--col-bg-btn-darker)}.kiosk-btn-128{width:128px;height:128px}.kiosk-btn-32{width:32px;height:32px}.kiosk-dropdown-btn{box-sizing:content-box;border-radius:0;background-color:var(--col-bg-btn);border-color:var(--col-bg-btn-darker);color:var(--col-primary-bg-btn);height:30px;width:30px}.kiosk-dropdown-btn .drop-down-btn{float:left}.kiosk-dropdown-btn .caret{color:var(--col-primary-bg-btn);display:inline-block;width:0;height:0;margin-left:2px;vertical-align:middle;border-color:var(--col-primary-bg-btn);border-top:4px solid;border-right:4px solid transparent;border-left:4px solid transparent}button:disabled{opacity:.3}.modal-round-button,.modal-delete,.modal-close,.modal-cancel,.modal-back,.modal-next,.modal-ok,.modal-button{box-sizing:border-box;margin-left:25px;background-image:none;display:inline-block;font-style:normal;font-variant:normal;text-rendering:auto;-webkit-font-smoothing:antialiased;font-family:"Font Awesome 6 Free";font-weight:900;font-size:24px;line-height:24px;vertical-align:center;text-align:center}.modal-ok:after{content:var(--icon-bt-ok)}.modal-next:after{padding-left:2px;content:var(--icon-bt-next)}.modal-back:after{padding-right:2px;content:var(--icon-bt-back)}.modal-cancel:after{content:var(--icon-bt-cancel)}.modal-close:before{content:var(--icon-bt-close)}.modal-delete{background-color:var(--col-bg-alert);color:var(--col-primary-bg-alert)}.modal-delete:before{content:var(--icon-bt-trash)}.modal-delete:hover,.modal-delete:focus{border-color:var(--col-bg-alert);background-color:var(--col-bg-alert-lighter);background-size:75%}.modal-delete:active{border-color:var(--col-bg-alert);background-color:var(--col-bg-alert-darker);color:var(--col-primary-bg-alert)}.kiosk-rounded{border-radius:15px}.kiosk-shaded{box-shadow:2px 2px 10px #2e380394}.kiosk-margin-bottom{margin-bottom:1em}.flex-line-break{width:100%;height:0px}.kiosk-align-flex-end{align-items:flex-end}.kiosk-align-flex-start{align-items:flex-start}.full-background-bg-1{background:linear-gradient(to right bottom,var(--col-bg-1-darker),var(--col-bg-1-lighter));height:100%;width:100%}.small-list-button i{border-radius:25px;box-shadow:2px 2px 5px #2e380394}.small-list-button:hover{color:var(--col-bg-att)}.small-list-button:hover i{box-shadow:2px 2px 5px #2e380394}.small-list-button:active,.small-list-button:focus{color:var(--col-bg-ack);transform:translateY(5px)}.small-list-button:active i,.small-list-button:focus i{box-shadow:none}.dialog-radio-div{display:flex;flex-direction:row}.dialog-radio-div input[type=radio]{margin-right:.5em}.rainbow-loading{display:flex;justify-content:center;align-items:center;height:5px;width:100%;background-color:#000}.rainbow-loading.to-top{position:fixed;top:0;z-index:1000}.rainbow-loading-progress{height:5px;width:100%;border-radius:3px;background:linear-gradient(90deg,red,#ff0,#0f0 30%,#0ff 50%,#00f,#f0f 80%,red);background-size:200%;animation:move-gradient 2s ease-in infinite}@keyframes move-gradient{0%{background-position:0% 0%}to{background-position:-200% 0%}}.fa,.fas{font-family:"Font Awesome 6 Free";font-weight:900;font-style:normal}.fa-trash:before{content:""}.fa-view-grid:before{content:""}.fa-reload:before{content:""}.fa-view-list:before{content:""}.fa-camera:before{content:""}.fa-view-image:before{content:""}.fa-check:before{content:""}.fa-bug:before{content:""}.fa-lightbulb:before{content:""}.fa-query:before{content:""}.fa-footsteps{transform:rotate(270deg)}.fa-footsteps:before{content:""}.fa-next:before{content:""}.fa-prev:before{content:""}.fa-hide:before{content:""}.fa-circle-half-stroke:before{content:""}i{font-family:"Font Awesome 6 Free";font-style:normal;font-variant:normal;text-rendering:auto;-webkit-font-smoothing:antialiased;font-weight:900;font-size:.9em}div,p{font-family:var(--standard-text-font)}dialog{margin:auto;width:100%;height:100%;background-color:unset;outline:none;border:none}dialog .dialog-outer-zone{display:grid;background-color:unset;width:100%;height:100%;place-items:center}.dialog-frame{position:relative;background-color:var(--col-bg-1);display:flex;padding:20px 25px 10px;flex-direction:column;justify-content:space-between;border:2px solid var(--col-bg-1)}.dialog-header{height:auto;display:flex;width:100%;flex-direction:row;flex-wrap:nowrap;align-items:center;padding-bottom:.5rem;margin-top:.5em;margin-right:1em;border:0px solid black;border-bottom-width:1px;margin-bottom:1rem}.dialog-image{box-sizing:border-box;padding-right:10px;background-repeat:no-repeat;z-index:0}.dialog-name h3{font-family:var(--monospace-font)}.close-button{-webkit-user-select:none;user-select:none;position:absolute;font-size:var(--font-size-h3);color:var(--col-primary-bg-1);margin-left:auto;right:.5rem;top:.5rem}.close-button :hover{background-color:var(--col-bg-btn);color:var(--col-primary-bg-btn)}.close-button :active{background-color:var(--col-bg-btn);color:var(--col-accent-bg-btn)}';
var Qp = Object.defineProperty, Jp = Object.getOwnPropertyDescriptor, $p = Object.getPrototypeOf, eg = Reflect.get, bc = (s, n, e, t) => {
  for (var i = t > 1 ? void 0 : t ? Jp(n, e) : n, r = s.length - 1, o; r >= 0; r--)
    (o = s[r]) && (i = (t ? o(n, e, i) : o(i)) || i);
  return t && i && Qp(n, e, i), i;
}, tg = (s, n, e) => eg($p(s), e, n);
let di = class extends Ot {
  constructor() {
    super(...arguments), this.heading = "";
  }
  firstUpdated(s) {
    console.log("KioskDialog first updated", s), super.firstUpdated(s);
  }
  openDialog() {
    let s = this.shadowRoot?.querySelector("dialog");
    s && s.showModal();
  }
  closeDialog(s) {
    let n = this.shadowRoot?.querySelector("dialog");
    n && n.close(s);
  }
  _overlayClicked(s) {
    s.target == this.shadowRoot?.querySelector(".dialog-outer-zone") && this.closeDialog();
  }
  _onCloseDialog() {
    let s = this.shadowRoot?.querySelector("dialog"), n = new CustomEvent("kiosk-dialog-closed", {
      bubbles: !1,
      cancelable: !1,
      composed: !1,
      detail: s?.returnValue
    });
    this.dispatchEvent(n);
  }
  render() {
    return We`
            <dialog id="my-dialog" @close="${this._onCloseDialog}">
                <div class="dialog-outer-zone" @click="${this._overlayClicked}">
                    <div class="dialog-frame">
                        <div class="dialog-header">
                            <div class="dialog-image">
                                <slot name="dialog-image"></slot>
                            </div>
                            <div class="dialog-name">
                                <h3 class="dialog-title">${this.heading}</h3>
                            </div>
                            <div class="close-button" @click="${this.closeDialog}">
                                <i class="fa"></i>
                            </div>
                        </div>
                        <slot name="dialog-content">
                        </slot>
                    </div>
                </div>
            </dialog>
        `;
  }
};
di.styles = yr(Xp);
di.properties = {
  ...tg(di, di, "properties")
};
bc([
  Xe()
], di.prototype, "heading", 2);
di = bc([
  Mn("kiosk-dialog")
], di);
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Ss = { ATTRIBUTE: 1, CHILD: 2, ELEMENT: 6 }, yc = (s) => (...n) => ({ _$litDirective$: s, values: n });
class wc {
  constructor(n) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(n, e, t) {
    this._$Ct = n, this._$AM = e, this._$Ci = t;
  }
  _$AS(n, e) {
    return this.update(n, e);
  }
  update(n, e) {
    return this.render(...e);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const ig = (s) => s.strings === void 0;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const dr = (s, n) => {
  const e = s._$AN;
  if (e === void 0) return !1;
  for (const t of e) t._$AO?.(n, !1), dr(t, n);
  return !0;
}, Pn = (s) => {
  let n, e;
  do {
    if ((n = s._$AM) === void 0) break;
    e = n._$AN, e.delete(s), s = n;
  } while (e?.size === 0);
}, xc = (s) => {
  for (let n; n = s._$AM; s = n) {
    let e = n._$AN;
    if (e === void 0) n._$AN = e = /* @__PURE__ */ new Set();
    else if (e.has(s)) break;
    e.add(s), og(n);
  }
};
function rg(s) {
  this._$AN !== void 0 ? (Pn(this), this._$AM = s, xc(this)) : this._$AM = s;
}
function ng(s, n = !1, e = 0) {
  const t = this._$AH, i = this._$AN;
  if (i !== void 0 && i.size !== 0) if (n) if (Array.isArray(t)) for (let r = e; r < t.length; r++) dr(t[r], !1), Pn(t[r]);
  else t != null && (dr(t, !1), Pn(t));
  else dr(this, s);
}
const og = (s) => {
  s.type == Ss.CHILD && (s._$AP ??= ng, s._$AQ ??= rg);
};
class sg extends wc {
  constructor() {
    super(...arguments), this._$AN = void 0;
  }
  _$AT(n, e, t) {
    super._$AT(n, e, t), xc(this), this.isConnected = n._$AU;
  }
  _$AO(n, e = !0) {
    n !== this.isConnected && (this.isConnected = n, n ? this.reconnected?.() : this.disconnected?.()), e && (dr(this, n), Pn(this));
  }
  setValue(n) {
    if (ig(this._$Ct)) this._$Ct._$AI(n, this);
    else {
      const e = [...this._$Ct._$AH];
      e[this._$Ci] = n, this._$Ct._$AI(e, this, 0);
    }
  }
  disconnected() {
  }
  reconnected() {
  }
}
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const el = Symbol("valueNotInitialized");
class ag extends sg {
  constructor(n) {
    if (super(n), n.type !== Ss.ELEMENT)
      throw new Error(`\`${this.constructor.name}\` must be bound to an element.`);
    this.previousValue = el;
  }
  /** @override */
  render(n, e) {
    return ze;
  }
  /** @override */
  update(n, [e, t]) {
    return this.hasChanged(t) && (this.host = n.options && n.options.host, this.element = n.element, this.renderer = e, this.previousValue === el ? this.addRenderer() : this.runRenderer(), this.previousValue = Array.isArray(t) ? [...t] : t), ze;
  }
  /** @override */
  reconnected() {
    this.addRenderer();
  }
  /** @override */
  disconnected() {
    this.removeRenderer();
  }
  /** @abstract */
  addRenderer() {
    throw new Error("The `addRenderer` method must be implemented.");
  }
  /** @abstract */
  runRenderer() {
    throw new Error("The `runRenderer` method must be implemented.");
  }
  /** @abstract */
  removeRenderer() {
    throw new Error("The `removeRenderer` method must be implemented.");
  }
  /** @protected */
  renderRenderer(n, ...e) {
    const t = this.renderer.call(this.host, ...e);
    ll(t, n, { host: this.host });
  }
  /** @protected */
  hasChanged(n) {
    return Array.isArray(n) ? !Array.isArray(this.previousValue) || this.previousValue.length !== n.length ? !0 : n.some((e, t) => e !== this.previousValue[t]) : this.previousValue !== n;
  }
}
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const tl = Symbol("contentUpdateDebouncer");
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class lg extends ag {
  /**
   * A property to that the renderer callback will be assigned.
   *
   * @abstract
   */
  get rendererProperty() {
    throw new Error("The `rendererProperty` getter must be implemented.");
  }
  /**
   * Adds the renderer callback to the grid column.
   */
  addRenderer() {
    this.element[this.rendererProperty] = (n, e) => {
      this.renderRenderer(n, e);
    };
  }
  /**
   * Runs the renderer callback on the grid column.
   */
  runRenderer() {
    const n = this.element._grid;
    n[tl] = Me.debounce(n[tl], yt, () => {
      n.requestContentUpdate();
    });
  }
  /**
   * Removes the renderer callback from the grid column.
   */
  removeRenderer() {
    this.element[this.rendererProperty] = null;
  }
}
class cg extends lg {
  get rendererProperty() {
    return "renderer";
  }
  addRenderer() {
    this.element[this.rendererProperty] = (n, e, t) => {
      this.renderRenderer(n, t.item, t, e);
    };
  }
}
const ug = yc(cg);
var dg = Object.defineProperty, hg = Object.getOwnPropertyDescriptor, fg = Object.getPrototypeOf, pg = Reflect.get, Cc = (s) => {
  throw TypeError(s);
}, wt = (s, n, e, t) => {
  for (var i = t > 1 ? void 0 : t ? hg(n, e) : n, r = s.length - 1, o; r >= 0; r--)
    (o = s[r]) && (i = (t ? o(n, e, i) : o(i)) || i);
  return t && i && dg(n, e, i), i;
}, Tc = (s, n, e) => n.has(s) || Cc("Cannot " + e), tn = (s, n, e) => (Tc(s, n, "read from private field"), e ? e.call(s) : n.get(s)), rn = (s, n, e) => n.has(s) ? Cc("Cannot add the same private member more than once") : n instanceof WeakSet ? n.add(s) : n.set(s, e), nn = (s, n, e, t) => (Tc(s, n, "write to private field"), n.set(s, e), e), gg = (s, n, e) => pg(fg(s), e, n), cn, un, dn, hn;
let ct = class extends Ln {
  constructor() {
    super(), this.constants = {}, rn(this, cn, []), rn(this, un, []), this.searchIdentifier = "", this.heading = "select archaeological entity", this.identifierColumnTitle = "entity", this.initialRecordType = "unit", rn(this, dn, []), rn(this, hn, {}), this.recordTypeFilter = [], this.cellRenderer = (s) => {
      const n = Kp(this.recordTypeAliases, s.record_type);
      return We`
            <div>
                ${n}
            </div>`;
    }, Qe("vaadin-grid", ke`
            :host [part~="header-cell"] ::slotted(vaadin-grid-cell-content), [part~="footer-cell"] ::slotted(vaadin-grid-cell-content), [part~="reorder-ghost"] {
                font-weight: bold
            }
        `);
  }
  get identifiers() {
    return tn(this, cn);
  }
  set identifiers(s) {
    nn(this, cn, s);
  }
  get _identifiers() {
    return tn(this, un);
  }
  set _identifiers(s) {
    nn(this, un, s);
  }
  get selectedItems() {
    return tn(this, dn);
  }
  set selectedItems(s) {
    nn(this, dn, s);
  }
  get recordTypeAliases() {
    return tn(this, hn);
  }
  set recordTypeAliases(s) {
    nn(this, hn, s);
  }
  updated(s) {
    if (super.updated(s), s.has("apiContext") && this.apiConnected(), s.has("selectedItems") && this.selectedItems.length > 0) {
      const n = this.shadowRoot?.querySelector("kiosk-dialog");
      n && setTimeout(() => {
        const e = new CustomEvent("closeSelection", {
          detail: this.selectedItems[0]
        });
        this.dispatchEvent(e), n.closeDialog();
      }, 250);
    }
  }
  willUpdate(s) {
    (s.has("identifiers") || s.has("recordTypeFilter")) && this.prepareIdentifiers();
  }
  apiConnected() {
    console.log("fetching identifiers"), (!this.identifiers || this.identifiers.length == 0) && this.fetchIdentifiers();
  }
  fetchIdentifiers() {
    this.apiContext.fetchFromApi(
      "",
      "contexts/full",
      {
        method: "GET",
        caller: "app.fetchIdentifiers"
      }
    ).then((s) => {
      this.identifiers = s.identifiers, console.log("identifier information fetched", this.identifiers);
    }).catch((s) => {
      this.showProgress = !1, console.log("fetching identifier information failed"), Zp(this, s, "loadConstants");
    });
  }
  prepareIdentifiers() {
    console.log("prepare identifiers"), this.recordTypeFilter.length > 0 ? this._identifiers = this.identifiers.filter((s) => this.recordTypeFilter.includes(s.record_type.toLowerCase())) : this._identifiers = this.identifiers;
  }
  filterIdentifiers() {
    return this.searchIdentifier === "" && this.initialRecordType !== "" ? this._identifiers.filter((s) => s.record_type === this.initialRecordType) : this.searchIdentifier || this._identifiers.length < 50 ? this._identifiers.filter((s) => s.identifier.toLowerCase().startsWith(this.searchIdentifier)) : [];
  }
  openDialog() {
    (this.shadowRoot?.querySelector("kiosk-dialog")).openDialog();
  }
  searchChanged(s) {
    let n = s.target.value;
    this.searchIdentifier = n.toLowerCase();
  }
  activeItemChanged(s) {
    const n = s.detail.value;
    n && (this.selectedItems = [n]);
  }
  renderGrid() {
    return We`
            <vaadin-grid id="grid" class="selection-grid"
                         .items=${this.filterIdentifiers()}
                         .selectedItems="${this.selectedItems}"
                         @active-item-changed="${this.activeItemChanged}">
                <vaadin-grid-column header="${this.identifierColumnTitle}" path="identifier"></vaadin-grid-column>
                <vaadin-grid-column header="type" ${ug(this.cellRenderer, [])}></vaadin-grid-column>
            </vaadin-grid>
        `;
  }
  apiRender() {
    return We`
            <kiosk-dialog api heading="${this.heading}">
                <!--svg slot="dialog-image" xmlns="http://www.w3.org/2000/svg" width="auto" height="auto" viewBox="0 0 24 24" style="fill: rgba(0, 0, 0, 1);transform: ;msFilter:;"><path d="M11 19.91 10 22h4l-1-2.09c4-.65 7-5.28 7-9.91a8 8 0 0 0-16 0c0 4.63 3.08 9.26 7 9.91zm1-15.66v1.5A4.26 4.26 0 0 0 7.75 10h-1.5A5.76 5.76 0 0 1 12 4.25z"></path></svg-->
                <div slot="dialog-image">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                         style="fill: rgba(0, 0, 0, 1);transform: ;msFilter:;">
                        <path d="M4 22h12v-2H4V8H2v12c0 1.103.897 2 2 2z"></path>
                        <path
                            d="M20 2H8c-1.103 0-2 .897-2 2v12c0 1.103.897 2 2 2h12c1.103 0 2-.897 2-2V4c0-1.103-.897-2-2-2zm-2 9h-3v3h-2v-3h-3V9h3V6h2v3h3v2z"></path>
                    </svg>
                </div>
                <div slot="dialog-content">
                    <label for="identifier">search word expands selection</label>
                    <input id="identifier" type="text" @input="${this.searchChanged}" autofocus>
                    ${this.renderGrid()}
                </div>
            </kiosk-dialog>
        `;
  }
};
cn = /* @__PURE__ */ new WeakMap();
un = /* @__PURE__ */ new WeakMap();
dn = /* @__PURE__ */ new WeakMap();
hn = /* @__PURE__ */ new WeakMap();
ct.styles = yr(Mp);
ct.properties = {
  ...gg(ct, ct, "properties")
};
wt([
  Xe()
], ct.prototype, "constants", 2);
wt([
  Xe()
], ct.prototype, "identifiers", 1);
wt([
  Pt()
], ct.prototype, "_identifiers", 1);
wt([
  Xe()
], ct.prototype, "searchIdentifier", 2);
wt([
  Xe()
], ct.prototype, "heading", 2);
wt([
  Xe()
], ct.prototype, "identifierColumnTitle", 2);
wt([
  Xe()
], ct.prototype, "initialRecordType", 2);
wt([
  Xe()
], ct.prototype, "selectedItems", 1);
wt([
  Xe()
], ct.prototype, "recordTypeAliases", 1);
wt([
  Xe()
], ct.prototype, "recordTypeFilter", 2);
ct = wt([
  Mn("kiosk-context-selector")
], ct);
const mg = '*{padding:0;margin:0;border:0px;-webkit-user-select:none;user-select:none}p,div{-webkit-user-select:text;user-select:text}select{-webkit-user-select:none;user-select:none}.col-bg-body-lighter{background-color:var(--col-bg-body-lighter)}.col-bg-body{background-color:var(--col-bg-body)}.col-bg-body-darker{background-color:var(--col-bg-body-darker)}.col-bg-1-lighter{background-color:var(--col-bg-1-lighter)}.col-bg-1{background-color:var(--col-bg-1)}.col-bg-1-darker{background-color:var(--col-bg-1-darker)}.col-bg-1-input{background-color:var(--col-bg-1-input)}.col-primary-bg-1{background-color:var(--col-primary-bg-1)}.col-accent-bg-1{background-color:var(--col-accent-bg-1)}.col-success-bg-1{background-color:var(--col-success-bg-1)}.col-warning-bg-1{background-color:var(--col-warning-bg-1)}.col-error-bg-1{background-color:var(--col-error-bg-1)}.col-bg-2-lighter{background-color:var(--col-bg-2-lighter)}.col-bg-2{background-color:var(--col-bg-2)}.col-bg-2-darker{background-color:var(--col-bg-2-darker)}.col-bg-2-button{background-color:var(--col-bg-2-button)}.col-bg-2-input{background-color:var(--col-bg-2-input)}.col-primary-bg-2{background-color:var(--col-primary-bg-2)}.col-accent-bg-2{background-color:var(--col-accent-bg-2)}.col-success-bg-2{background-color:var(--col-success-bg-2)}.col-warning-bg-2{background-color:var(--col-warning-bg-2)}.col-error-bg-2{background-color:var(--col-error-bg-2)}.col-bg-3-lighter{background-color:var(--col-bg-3-lighter)}.col-bg-3{background-color:var(--col-bg-3)}.col-bg-3-darker{background-color:var(--col-bg-3-darker)}.col-bg-3-button{background-color:var(--col-bg-3-button)}.col-bg-3-input{background-color:var(--col-bg-3-input)}.col-primary-bg-3{background-color:var(--col-primary-bg-3)}.col-accent-bg-3{background-color:var(--col-accent-bg-3)}.col-success-bg-3{background-color:var(--col-success-bg-3)}.col-warning-bg-3{background-color:var(--col-warning-bg-3)}.col-error-bg-3{background-color:var(--col-error-bg-3)}.col-bg-ack-lighter{background-color:var(--col-bg-ack-lighter)}.col-bg-ack{background-color:var(--col-bg-ack)}.col-bg-ack-darker{background-color:var(--col-bg-ack-darker)}.col-primary-bg-ack{background-color:var(--col-primary-bg-ack)}.col-accent-bg-ack{background-color:var(--col-accent-bg-ack)}.col-bg-att-lighter{background-color:var(--col-bg-att-lighter)}.col-bg-att{background-color:var(--col-bg-att)}.col-bg-att-darker{background-color:var(--col-bg-att-darker)}.col-primary-bg-att{background-color:var(--col-primary-bg-att)}.col-accent-bg-att{background-color:var(--col-accent-bg-att)}.col-bg-alert-lighter{background-color:var(--col-bg-alert-lighter)}.col-bg-alert{background-color:var(--col-bg-alert)}.col-bg-alert-darker{background-color:var(--col-bg-alert-darker)}.col-primary-bg-alert{background-color:var(--col-primary-bg-alert)}.col-accent-bg-alert{background-color:var(--col-accent-bg-alert)}.col-bg-btn-lighter{background-color:var(--col-bg-btn-lighter)}.col-bg-btn{background-color:var(--col-bg-btn)}.col-bg-btn-darker{background-color:var(--col-bg-btn-darker)}.col-primary-bg-btn{background-color:var(--col-primary-bg-btn)}.col-accent-bg-btn{background-color:var(--col-accent-bg-btn)}.pattern-diagonal-stripes-sm{background:repeating-linear-gradient(45deg,transparent,transparent 10px,currentColor 10px,currentColor 20px)}.pattern-dots-lg{background-image:radial-gradient(currentColor 1.5px,transparent 1.5px);background-size:15px 15px}.pattern-dots-md{background-image:radial-gradient(currentColor 1px,transparent 1px);background-size:8px 8px}.pattern-dots-medium-dense{background-image:radial-gradient(currentColor .5px,transparent .5px);background-size:3px 3px}.pattern-dots-sm{background-image:radial-gradient(currentColor .5px,transparent .5px);background-size:5px 5px}.pattern-cross-dots-md,.imagelist-background{background-image:radial-gradient(currentColor .7px,transparent 1px),radial-gradient(currentColor .7px,transparent 1px);background-size:6.5px 6.5px;background-position:0 0,3.5px 3.5px}.imagelist-background{background-color:#fff9;background-blend-mode:overlay}label{font-family:var(--monospace-font);font-size:.9em}input,select{-webkit-user-select:text;-moz-user-select:text;-ms-user-select:text;box-sizing:border-box;border-radius:0;user-select:text;font-family:var(--standard-text-font);background-color:var(--col-bg-1-input);border:none;color:var(--col-primary-bg-1);padding:2px;margin-bottom:2px;outline:none}textarea{outline:none}input:not([type=radio],[type=checkbox]),select,textarea{width:100%}input:not([type=radio],[type=checkbox]):focus,select:focus,textarea:focus{margin-bottom:0;border-bottom:2px solid rgb(0,0,0)}h1{font-size:var(--font-size-h1)}h2{font-size:var(--font-size-h2)}h3{font-size:var(--font-size-h3)}h4{font-size:var(--font-size-h4)}small,.font-small{font-size:var(--font-size-small)}button{width:60px;height:60px;border-radius:35px;border-style:solid;border-width:2px;background-color:var(--col-bg-btn);color:var(--col-primary-bg-btn);border-color:var(--col-bg-btn-darker);font-family:var(--headline-text-font);font-size:var(--font-size-h4);font-weight:700}button:hover,button:focus{outline:none;background-color:var(--col-bg-btn-lighter)}button:active{padding-top:3px;color:var(--col-primary-bg-btn);background-color:var(--col-bg-btn-darker);border-color:var(--col-bg-btn-darker)}.kiosk-btn-128{width:128px;height:128px}.kiosk-btn-32{width:32px;height:32px}.kiosk-dropdown-btn{box-sizing:content-box;border-radius:0;background-color:var(--col-bg-btn);border-color:var(--col-bg-btn-darker);color:var(--col-primary-bg-btn);height:30px;width:30px}.kiosk-dropdown-btn .drop-down-btn{float:left}.kiosk-dropdown-btn .caret{color:var(--col-primary-bg-btn);display:inline-block;width:0;height:0;margin-left:2px;vertical-align:middle;border-color:var(--col-primary-bg-btn);border-top:4px solid;border-right:4px solid transparent;border-left:4px solid transparent}button:disabled{opacity:.3}.modal-round-button,.modal-delete,.modal-close,.modal-cancel,.modal-back,.modal-next,.modal-ok,.modal-button{box-sizing:border-box;margin-left:25px;background-image:none;display:inline-block;font-style:normal;font-variant:normal;text-rendering:auto;-webkit-font-smoothing:antialiased;font-family:"Font Awesome 6 Free";font-weight:900;font-size:24px;line-height:24px;vertical-align:center;text-align:center}.modal-ok:after{content:var(--icon-bt-ok)}.modal-next:after{padding-left:2px;content:var(--icon-bt-next)}.modal-back:after{padding-right:2px;content:var(--icon-bt-back)}.modal-cancel:after{content:var(--icon-bt-cancel)}.modal-close:before{content:var(--icon-bt-close)}.modal-delete{background-color:var(--col-bg-alert);color:var(--col-primary-bg-alert)}.modal-delete:before{content:var(--icon-bt-trash)}.modal-delete:hover,.modal-delete:focus{border-color:var(--col-bg-alert);background-color:var(--col-bg-alert-lighter);background-size:75%}.modal-delete:active{border-color:var(--col-bg-alert);background-color:var(--col-bg-alert-darker);color:var(--col-primary-bg-alert)}.kiosk-rounded{border-radius:15px}.kiosk-shaded{box-shadow:2px 2px 10px #2e380394}.kiosk-margin-bottom{margin-bottom:1em}.flex-line-break{width:100%;height:0px}.kiosk-align-flex-end{align-items:flex-end}.kiosk-align-flex-start{align-items:flex-start}.full-background-bg-1{background:linear-gradient(to right bottom,var(--col-bg-1-darker),var(--col-bg-1-lighter));height:100%;width:100%}.small-list-button i{border-radius:25px;box-shadow:2px 2px 5px #2e380394}.small-list-button:hover{color:var(--col-bg-att)}.small-list-button:hover i{box-shadow:2px 2px 5px #2e380394}.small-list-button:active,.small-list-button:focus{color:var(--col-bg-ack);transform:translateY(5px)}.small-list-button:active i,.small-list-button:focus i{box-shadow:none}.dialog-radio-div{display:flex;flex-direction:row}.dialog-radio-div input[type=radio]{margin-right:.5em}.rainbow-loading{display:flex;justify-content:center;align-items:center;height:5px;width:100%;background-color:#000}.rainbow-loading.to-top{position:fixed;top:0;z-index:1000}.rainbow-loading-progress{height:5px;width:100%;border-radius:3px;background:linear-gradient(90deg,red,#ff0,#0f0 30%,#0ff 50%,#00f,#f0f 80%,red);background-size:200%;animation:move-gradient 2s ease-in infinite}@keyframes move-gradient{0%{background-position:0% 0%}to{background-position:-200% 0%}}.fa,.fas{font-family:"Font Awesome 6 Free";font-weight:900;font-style:normal}.fa-trash:before{content:""}.fa-view-grid:before{content:""}.fa-reload:before{content:""}.fa-view-list:before{content:""}.fa-camera:before{content:""}.fa-view-image:before{content:""}.fa-check:before{content:""}.fa-bug:before{content:""}.fa-lightbulb:before{content:""}.fa-query:before{content:""}.fa-footsteps{transform:rotate(270deg)}.fa-footsteps:before{content:""}.fa-next:before{content:""}.fa-prev:before{content:""}.fa-hide:before{content:""}.fa-circle-half-stroke:before{content:""}i{font-family:"Font Awesome 6 Free";font-style:normal;font-variant:normal;text-rendering:auto;-webkit-font-smoothing:antialiased;font-weight:900;font-size:.9em}div,p{font-family:var(--standard-text-font)}:host{--lumo-font-size-s: $font-size-standard;--lumo-font-family: $standard-text;--lumo-size-m: $font-size-standard;--lumo-contrast-10pct: rgba(0,0,0,0);--lumo-contrast-60pct: var(--col-accent-bg-1);--lumo-text-field-size: 1em;--lumo-font-size: var(--font-size-standard);--lumo-border-radius-l: 0;--lumo-border-radius-m: 0;--lumo-border-radius-s: 0}vaadin-combo-box{margin-left:calc(-1 * (.375em + var(--lumo-border-radius-m) / 4 - 1px));margin-right:calc(-1 * (.375em + var(--lumo-border-radius-m) / 4 - 1px));padding-top:0}vaadin-combo-box>input{--_lumo-text-field-overflow-mask-image: white;--lumo-text-field-size: 22px;background-color:#fff;max-height:var(--tz-combobox-max-height, 40);padding:var(--tz-combobox-horizontal-padding, 5px) var(--tz-combobox-vertical-padding, 5px)}vaadin-combo-box>input:disabled{background-color:var(--col-bg-1-lighter);--lumo-disabled-text-color: $col-primary-bg-1}vaadin-combo-box{font-family:var(--standard-text-font);font-size:var(--font-size-standard, 1rem);color:var(--col-primary-bg-1);background-color:var(--col-bg-2);width:100%;padding:0}vaadin-combo-box input:disabled,vaadin-combo-box textarea:disabled{background-color:var(--col-bg-1-lighter);color:var(--col-primary-bg-1);-webkit-text-fill-color:currentcolor;opacity:1}vaadin-combo-box::part(input-field){padding:0}';
var vg = Object.defineProperty, _g = Object.getOwnPropertyDescriptor, bg = Object.getPrototypeOf, yg = Reflect.get, Ui = (s, n, e, t) => {
  for (var i = t > 1 ? void 0 : t ? _g(n, e) : n, r = s.length - 1, o; r >= 0; r--)
    (o = s[r]) && (i = (t ? o(n, e, i) : o(i)) || i);
  return t && i && vg(n, e, i), i;
}, wg = (s, n, e) => yg(bg(s), e, n);
let bt = class extends Ln {
  // @property()
  // public timeZone: string;
  constructor() {
    super(), this.timeZones = [], this.value = null, this.text = "", this.disabled = !1, this.includeDeprecated = !1;
  }
  updated(s) {
    if (super.updated(s), s.has("apiContext") && this.apiConnected(), s.has("value")) {
      console.log(`value updated to ${this.value}`);
      const n = this.shadowRoot?.querySelector("vaadin-combo-box");
      n && !this.value && (n.value = "");
    }
  }
  // willUpdate(_changedProperties: any) {
  //     // if (_changedProperties.has("identifiers") || _changedProperties.has("recordTypeFilter")) {
  //     //     this.prepareIdentifiers();
  //     // }
  // }
  apiConnected() {
    console.log("fetching time zone information"), this.kioskTimeZones = new Yp(this.apiContext), this.fetchFavouriteTimeZones();
  }
  fetchFavouriteTimeZones() {
    this.kioskTimeZones && this.kioskTimeZones.getFavouriteTimeZones(!1, !1).then((s) => {
      console.log(`about to add ${s.length} favourites`), this.addTimeZones(s, !0), this.kioskTimeZones && this.kioskTimeZones.getAllTimeZones(this.includeDeprecated).then((n) => {
        n && this.addTimeZones(n, !1);
      });
    });
  }
  addTimeZones(s, n = !1) {
    const e = s.filter((t) => n || t.favourite == 1).map((t) => ({ label: t.tz_long, value: t.id }));
    console.log(`kiosktzcombobox: added ${e.length} favourite timezones`), n || (e.push({ label: "------", value: -1 }), e.push(...s.filter((t) => t.favourite != 1).map((t) => ({ label: t.tz_long, value: t.id }))), console.log(`now we have ${e.length} overall timezones`)), this.timeZones = e;
  }
  timeZoneChanged(s) {
    const n = s.target;
    console.log(n.selectedItem), n.selectedItem && n.selectedItem.value > -1 ? (this.value = n.selectedItem.value, this.text = n.selectedItem.label) : (this.value = null, this.text = "", this.requestUpdate("value", -1)), s.preventDefault();
    const e = new CustomEvent("change");
    this.dispatchEvent(e);
  }
  onKeyUp(s) {
    (s.key === "Escape" || s.key === "Enter") && s.stopPropagation();
  }
  apiRender() {
    return We`
            <vaadin-combo-box id="kiosk-tz-combo-box" ?disabled="${this.disabled || this.timeZones.length == 0}" .value=${this.value && this.value > -1 ? this.value : ""} @change=${this.timeZoneChanged} .items="${this.timeZones}" @keyup="${this.onKeyUp}"></vaadin-combo-box>
        `;
  }
};
bt.styles = yr(mg);
bt.properties = {
  ...wg(bt, bt, "properties")
};
Ui([
  Pt()
], bt.prototype, "timeZones", 2);
Ui([
  Xe({ type: Number, reflect: !0 })
], bt.prototype, "value", 2);
Ui([
  Xe({ type: String, reflect: !0 })
], bt.prototype, "text", 2);
Ui([
  Xe({ attribute: !0, type: Boolean })
], bt.prototype, "disabled", 2);
Ui([
  Xe({ attribute: !0, type: Boolean })
], bt.prototype, "includeDeprecated", 2);
bt = Ui([
  Mn("kiosk-tz-combo-box")
], bt);
const xg = '*{padding:0;margin:0;border:0px;-webkit-user-select:none;user-select:none}p,div{-webkit-user-select:text;user-select:text}select{-webkit-user-select:none;user-select:none}.col-bg-body-lighter{background-color:var(--col-bg-body-lighter)}.col-bg-body{background-color:var(--col-bg-body)}.col-bg-body-darker{background-color:var(--col-bg-body-darker)}.col-bg-1-lighter{background-color:var(--col-bg-1-lighter)}.col-bg-1{background-color:var(--col-bg-1)}.col-bg-1-darker{background-color:var(--col-bg-1-darker)}.col-bg-1-input{background-color:var(--col-bg-1-input)}.col-primary-bg-1{background-color:var(--col-primary-bg-1)}.col-accent-bg-1{background-color:var(--col-accent-bg-1)}.col-success-bg-1{background-color:var(--col-success-bg-1)}.col-warning-bg-1{background-color:var(--col-warning-bg-1)}.col-error-bg-1{background-color:var(--col-error-bg-1)}.col-bg-2-lighter{background-color:var(--col-bg-2-lighter)}.col-bg-2{background-color:var(--col-bg-2)}.col-bg-2-darker{background-color:var(--col-bg-2-darker)}.col-bg-2-button{background-color:var(--col-bg-2-button)}.col-bg-2-input{background-color:var(--col-bg-2-input)}.col-primary-bg-2{background-color:var(--col-primary-bg-2)}.col-accent-bg-2{background-color:var(--col-accent-bg-2)}.col-success-bg-2{background-color:var(--col-success-bg-2)}.col-warning-bg-2{background-color:var(--col-warning-bg-2)}.col-error-bg-2{background-color:var(--col-error-bg-2)}.col-bg-3-lighter{background-color:var(--col-bg-3-lighter)}.col-bg-3{background-color:var(--col-bg-3)}.col-bg-3-darker{background-color:var(--col-bg-3-darker)}.col-bg-3-button{background-color:var(--col-bg-3-button)}.col-bg-3-input{background-color:var(--col-bg-3-input)}.col-primary-bg-3{background-color:var(--col-primary-bg-3)}.col-accent-bg-3{background-color:var(--col-accent-bg-3)}.col-success-bg-3{background-color:var(--col-success-bg-3)}.col-warning-bg-3{background-color:var(--col-warning-bg-3)}.col-error-bg-3{background-color:var(--col-error-bg-3)}.col-bg-ack-lighter{background-color:var(--col-bg-ack-lighter)}.col-bg-ack{background-color:var(--col-bg-ack)}.col-bg-ack-darker{background-color:var(--col-bg-ack-darker)}.col-primary-bg-ack{background-color:var(--col-primary-bg-ack)}.col-accent-bg-ack{background-color:var(--col-accent-bg-ack)}.col-bg-att-lighter{background-color:var(--col-bg-att-lighter)}.col-bg-att{background-color:var(--col-bg-att)}.col-bg-att-darker{background-color:var(--col-bg-att-darker)}.col-primary-bg-att{background-color:var(--col-primary-bg-att)}.col-accent-bg-att{background-color:var(--col-accent-bg-att)}.col-bg-alert-lighter{background-color:var(--col-bg-alert-lighter)}.col-bg-alert{background-color:var(--col-bg-alert)}.col-bg-alert-darker{background-color:var(--col-bg-alert-darker)}.col-primary-bg-alert{background-color:var(--col-primary-bg-alert)}.col-accent-bg-alert{background-color:var(--col-accent-bg-alert)}.col-bg-btn-lighter{background-color:var(--col-bg-btn-lighter)}.col-bg-btn{background-color:var(--col-bg-btn)}.col-bg-btn-darker{background-color:var(--col-bg-btn-darker)}.col-primary-bg-btn{background-color:var(--col-primary-bg-btn)}.col-accent-bg-btn{background-color:var(--col-accent-bg-btn)}.pattern-diagonal-stripes-sm{background:repeating-linear-gradient(45deg,transparent,transparent 10px,currentColor 10px,currentColor 20px)}.pattern-dots-lg{background-image:radial-gradient(currentColor 1.5px,transparent 1.5px);background-size:15px 15px}.pattern-dots-md{background-image:radial-gradient(currentColor 1px,transparent 1px);background-size:8px 8px}.pattern-dots-medium-dense{background-image:radial-gradient(currentColor .5px,transparent .5px);background-size:3px 3px}.pattern-dots-sm{background-image:radial-gradient(currentColor .5px,transparent .5px);background-size:5px 5px}.pattern-cross-dots-md,.imagelist-background{background-image:radial-gradient(currentColor .7px,transparent 1px),radial-gradient(currentColor .7px,transparent 1px);background-size:6.5px 6.5px;background-position:0 0,3.5px 3.5px}.imagelist-background{background-color:#fff9;background-blend-mode:overlay}label{font-family:var(--monospace-font);font-size:.9em}input,select{-webkit-user-select:text;-moz-user-select:text;-ms-user-select:text;box-sizing:border-box;border-radius:0;user-select:text;font-family:var(--standard-text-font);background-color:var(--col-bg-1-input);border:none;color:var(--col-primary-bg-1);padding:2px;margin-bottom:2px;outline:none}textarea{outline:none}input:not([type=radio],[type=checkbox]),select,textarea{width:100%}input:not([type=radio],[type=checkbox]):focus,select:focus,textarea:focus{margin-bottom:0;border-bottom:2px solid rgb(0,0,0)}h1{font-size:var(--font-size-h1)}h2{font-size:var(--font-size-h2)}h3{font-size:var(--font-size-h3)}h4{font-size:var(--font-size-h4)}small,.font-small{font-size:var(--font-size-small)}button{width:60px;height:60px;border-radius:35px;border-style:solid;border-width:2px;background-color:var(--col-bg-btn);color:var(--col-primary-bg-btn);border-color:var(--col-bg-btn-darker);font-family:var(--headline-text-font);font-size:var(--font-size-h4);font-weight:700}button:hover,button:focus{outline:none;background-color:var(--col-bg-btn-lighter)}button:active{padding-top:3px;color:var(--col-primary-bg-btn);background-color:var(--col-bg-btn-darker);border-color:var(--col-bg-btn-darker)}.kiosk-btn-128{width:128px;height:128px}.kiosk-btn-32{width:32px;height:32px}.kiosk-dropdown-btn{box-sizing:content-box;border-radius:0;background-color:var(--col-bg-btn);border-color:var(--col-bg-btn-darker);color:var(--col-primary-bg-btn);height:30px;width:30px}.kiosk-dropdown-btn .drop-down-btn{float:left}.kiosk-dropdown-btn .caret{color:var(--col-primary-bg-btn);display:inline-block;width:0;height:0;margin-left:2px;vertical-align:middle;border-color:var(--col-primary-bg-btn);border-top:4px solid;border-right:4px solid transparent;border-left:4px solid transparent}button:disabled{opacity:.3}.modal-round-button,.modal-delete,.modal-close,.modal-cancel,.modal-back,.modal-next,.modal-ok,.modal-button{box-sizing:border-box;margin-left:25px;background-image:none;display:inline-block;font-style:normal;font-variant:normal;text-rendering:auto;-webkit-font-smoothing:antialiased;font-family:"Font Awesome 6 Free";font-weight:900;font-size:24px;line-height:24px;vertical-align:center;text-align:center}.modal-ok:after{content:var(--icon-bt-ok)}.modal-next:after{padding-left:2px;content:var(--icon-bt-next)}.modal-back:after{padding-right:2px;content:var(--icon-bt-back)}.modal-cancel:after{content:var(--icon-bt-cancel)}.modal-close:before{content:var(--icon-bt-close)}.modal-delete{background-color:var(--col-bg-alert);color:var(--col-primary-bg-alert)}.modal-delete:before{content:var(--icon-bt-trash)}.modal-delete:hover,.modal-delete:focus{border-color:var(--col-bg-alert);background-color:var(--col-bg-alert-lighter);background-size:75%}.modal-delete:active{border-color:var(--col-bg-alert);background-color:var(--col-bg-alert-darker);color:var(--col-primary-bg-alert)}.kiosk-rounded{border-radius:15px}.kiosk-shaded{box-shadow:2px 2px 10px #2e380394}.kiosk-margin-bottom{margin-bottom:1em}.flex-line-break{width:100%;height:0px}.kiosk-align-flex-end{align-items:flex-end}.kiosk-align-flex-start{align-items:flex-start}.full-background-bg-1{background:linear-gradient(to right bottom,var(--col-bg-1-darker),var(--col-bg-1-lighter));height:100%;width:100%}.small-list-button i{border-radius:25px;box-shadow:2px 2px 5px #2e380394}.small-list-button:hover{color:var(--col-bg-att)}.small-list-button:hover i{box-shadow:2px 2px 5px #2e380394}.small-list-button:active,.small-list-button:focus{color:var(--col-bg-ack);transform:translateY(5px)}.small-list-button:active i,.small-list-button:focus i{box-shadow:none}.dialog-radio-div{display:flex;flex-direction:row}.dialog-radio-div input[type=radio]{margin-right:.5em}.rainbow-loading{display:flex;justify-content:center;align-items:center;height:5px;width:100%;background-color:#000}.rainbow-loading.to-top{position:fixed;top:0;z-index:1000}.rainbow-loading-progress{height:5px;width:100%;border-radius:3px;background:linear-gradient(90deg,red,#ff0,#0f0 30%,#0ff 50%,#00f,#f0f 80%,red);background-size:200%;animation:move-gradient 2s ease-in infinite}@keyframes move-gradient{0%{background-position:0% 0%}to{background-position:-200% 0%}}.fa,.fas{font-family:"Font Awesome 6 Free";font-weight:900;font-style:normal}.fa-trash:before{content:""}.fa-view-grid:before{content:""}.fa-reload:before{content:""}.fa-view-list:before{content:""}.fa-camera:before{content:""}.fa-view-image:before{content:""}.fa-check:before{content:""}.fa-bug:before{content:""}.fa-lightbulb:before{content:""}.fa-query:before{content:""}.fa-footsteps{transform:rotate(270deg)}.fa-footsteps:before{content:""}.fa-next:before{content:""}.fa-prev:before{content:""}.fa-hide:before{content:""}.fa-circle-half-stroke:before{content:""}i{font-family:"Font Awesome 6 Free";font-style:normal;font-variant:normal;text-rendering:auto;-webkit-font-smoothing:antialiased;font-weight:900;font-size:.9em}:host{position:fixed;top:0;left:0;height:100dvh;max-width:100dvw;z-index:100;overflow-y:auto;overflow-x:hidden;background-color:var(--col-bg-body-dm)}.kiosk-lightbox-error{position:absolute;font-size:var(--font-size-standard);font-family:var(--standard-text) sans-serif;font-weight:700;color:var(--col-primary-bg-alert);display:grid;place-items:center;z-index:100;background:var(--col-bg-alert);top:50%;margin-left:50vw;width:400px;height:10em;transform:translate(-50%) translateY(-50%)}.kiosk-lightbox-outer{top:0;left:0}.kiosk-lightbox-outer.background-dark{background:var(--col-bg-body-dm)}.kiosk-lightbox-outer.background-light{background:var(--col-bg-body)}.kiosk-lightbox-inner{display:block;right:0;left:auto;width:calc(100dvw - 2rem)}.hide-ui{visibility:hidden}.kiosk-lightbox-viewer{width:100cqw}.kiosk-lightbox-viewer.expanded{height:75dvh}.kiosk-lightbox-viewer.collapsed{height:calc(100dvh - 1rem)}.kiosk-lightbox-viewer.collapsed.nodata{height:calc(100dvh - 2rem)}.kiosk-lightbox-data{position:relative;z-index:10;transform:translateY(-25px);background-color:#fff;width:100%;min-height:calc(25dvh - 2rem)}.kiosk-lightbox-splitter{display:flex;place-content:center;width:100%;background-color:var(--col-bg-body-dm);color:var(--col-primary-bg-body-dm)}.kiosk-lightbox-splitter i{font-size:25px}.kiosk-lightbox-buttons{display:flex;position:fixed;right:3rem;left:auto;top:1em;z-index:2}.kiosk-lightbox-button{border-radius:24px;height:2rem;width:2rem;background-color:var(--col-bg-btn);box-shadow:0 0 5px 2px var(--col-bg-att-lighter);color:var(--col-primary-bg-btn);text-align:center}.kiosk-lightbox-button i{line-height:2rem}.kiosk-lightbox-button:hover{background-color:var(--col-bg-att);box-shadow:0 0 5px 2px var(--col-bg-att-darker);color:var(--col-primary-bg-att)}.kiosk-lightbox-button:active{background-color:var(--col-bg-ack);box-shadow:0 0 5px 2px var(--col-bg-ack-darker);color:var(--col-primary-bg-ack)}.kiosk-lightbox-button+.kiosk-lightbox-button{margin-left:1rem}.kiosk-lightbox-button:last-child{margin-left:2rem}.kiosk-lightbox-button:first-child{margin-right:1rem}.nav-button-deactivated{opacity:25%;box-shadow:none}.nav-button-deactivated:hover,.nav-button-deactivated:active{background-color:var(--col-bg-btn);box-shadow:none;color:var(--col-primary-bg-btn)}.resolution-btn{font-family:var(--monospace-font);vertical-align:middle;font-size:12px;line-height:32px}.resolutions{position:absolute;background-color:var(--col-bg-btn);box-shadow:0 0 5px 2px var(--col-bg-att-lighter);border:1px solid;border-radius:5px;text-align:left;color:var(--col-primary-bg-btn);padding:.5rem}.res-item{-webkit-user-select:none;user-select:none;display:flex;flex-direction:row}.res-item:hover,.res-item:active{color:var(--col-accent-bg-btn)}.res-item .res-item-checker{width:1em;text-align:center;margin-right:.5em}';
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Cg = yc(class extends wc {
  constructor(s) {
    if (super(s), s.type !== Ss.ATTRIBUTE || s.name !== "class" || s.strings?.length > 2) throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.");
  }
  render(s) {
    return " " + Object.keys(s).filter(((n) => s[n])).join(" ") + " ";
  }
  update(s, [n]) {
    if (this.st === void 0) {
      this.st = /* @__PURE__ */ new Set(), s.strings !== void 0 && (this.nt = new Set(s.strings.join(" ").split(/\s/).filter(((t) => t !== ""))));
      for (const t in n) n[t] && !this.nt?.has(t) && this.st.add(t);
      return this.render(n);
    }
    const e = s.element.classList;
    for (const t of this.st) t in n || (e.remove(t), this.st.delete(t));
    for (const t in n) {
      const i = !!n[t];
      i === this.st.has(t) || this.nt?.has(t) || (i ? (e.add(t), this.st.add(t)) : (e.remove(t), this.st.delete(t)));
    }
    return fi;
  }
});
var fn = { exports: {} }, Tg = fn.exports, il;
function Eg() {
  return il || (il = 1, (function(s) {
    //! openseadragon 5.0.1
    //! Built on 2024-12-09
    //! Git commit: v5.0.1-0-480de92d
    //! http://openseadragon.github.io
    //! License: http://openseadragon.github.io/license/
    function n(e) {
      return new n.Viewer(e);
    }
    (function(e) {
      e.version = {
        versionStr: "5.0.1",
        major: parseInt("5", 10),
        minor: parseInt("0", 10),
        revision: parseInt("1", 10)
      };
      var t = {
        "[object Boolean]": "boolean",
        "[object Number]": "number",
        "[object String]": "string",
        "[object Function]": "function",
        "[object AsyncFunction]": "function",
        "[object Promise]": "promise",
        "[object Array]": "array",
        "[object Date]": "date",
        "[object RegExp]": "regexp",
        "[object Object]": "object"
      }, i = Object.prototype.toString, r = Object.prototype.hasOwnProperty;
      e.isFunction = function(o) {
        return e.type(o) === "function";
      }, e.isArray = Array.isArray || function(o) {
        return e.type(o) === "array";
      }, e.isWindow = function(o) {
        return o && typeof o == "object" && "setInterval" in o;
      }, e.type = function(o) {
        return o == null ? String(o) : t[i.call(o)] || "object";
      }, e.isPlainObject = function(o) {
        if (!o || n.type(o) !== "object" || o.nodeType || e.isWindow(o) || o.constructor && !r.call(o, "constructor") && !r.call(o.constructor.prototype, "isPrototypeOf"))
          return !1;
        var a;
        for (var c in o)
          a = c;
        return a === void 0 || r.call(o, a);
      }, e.isEmptyObject = function(o) {
        for (var a in o)
          return !1;
        return !0;
      }, e.freezeObject = function(o) {
        return Object.freeze ? e.freezeObject = Object.freeze : e.freezeObject = function(a) {
          return a;
        }, e.freezeObject(o);
      }, e.supportsCanvas = (function() {
        var o = document.createElement("canvas");
        return !!(e.isFunction(o.getContext) && o.getContext("2d"));
      })(), e.isCanvasTainted = function(o) {
        var a = !1;
        try {
          o.getContext("2d").getImageData(0, 0, 1, 1);
        } catch {
          a = !0;
        }
        return a;
      }, e.supportsAddEventListener = (function() {
        return !!(document.documentElement.addEventListener && document.addEventListener);
      })(), e.supportsRemoveEventListener = (function() {
        return !!(document.documentElement.removeEventListener && document.removeEventListener);
      })(), e.supportsEventListenerOptions = (function() {
        var o = 0;
        if (e.supportsAddEventListener)
          try {
            var a = {
              get capture() {
                return o++, !1;
              },
              get once() {
                return o++, !1;
              },
              get passive() {
                return o++, !1;
              }
            };
            window.addEventListener("test", null, a), window.removeEventListener("test", null, a);
          } catch {
            o = 0;
          }
        return o >= 3;
      })(), e.getCurrentPixelDensityRatio = function() {
        if (e.supportsCanvas) {
          var o = document.createElement("canvas").getContext("2d"), a = window.devicePixelRatio || 1, c = o.webkitBackingStorePixelRatio || o.mozBackingStorePixelRatio || o.msBackingStorePixelRatio || o.oBackingStorePixelRatio || o.backingStorePixelRatio || 1;
          return Math.max(a, 1) / c;
        } else
          return 1;
      }, e.pixelDensityRatio = e.getCurrentPixelDensityRatio();
    })(n), (function(e) {
      e.extend = function() {
        var c, u, h, f, g, x, C = arguments[0] || {}, E = arguments.length, R = !1, D = 1;
        for (typeof C == "boolean" && (R = C, C = arguments[1] || {}, D = 2), typeof C != "object" && !n.isFunction(C) && (C = {}), E === D && (C = this, --D); D < E; D++)
          if (c = arguments[D], c !== null || c !== void 0)
            for (u in c) {
              var U = Object.getOwnPropertyDescriptor(c, u);
              if (U !== void 0) {
                if (U.get || U.set) {
                  Object.defineProperty(C, u, U);
                  continue;
                }
                f = U.value;
              } else {
                e.console.warn('Could not copy inherited property "' + u + '".');
                continue;
              }
              C !== f && (R && f && (n.isPlainObject(f) || (g = n.isArray(f))) ? (h = C[u], g ? (g = !1, x = h && n.isArray(h) ? h : []) : x = h && n.isPlainObject(h) ? h : {}, C[u] = n.extend(R, x, f)) : f !== void 0 && (C[u] = f));
            }
        return C;
      };
      var t = function() {
        if (typeof navigator != "object")
          return !1;
        var c = navigator.userAgent;
        return typeof c != "string" ? !1 : c.indexOf("iPhone") !== -1 || c.indexOf("iPad") !== -1 || c.indexOf("iPod") !== -1;
      };
      e.extend(
        e,
        /** @lends OpenSeadragon */
        {
          /**
           * The default values for the optional settings documented at {@link OpenSeadragon.Options}.
           * @static
           * @type {Object}
           */
          DEFAULT_SETTINGS: {
            //DATA SOURCE DETAILS
            xmlPath: null,
            tileSources: null,
            tileHost: null,
            initialPage: 0,
            crossOriginPolicy: !1,
            ajaxWithCredentials: !1,
            loadTilesWithAjax: !1,
            ajaxHeaders: {},
            splitHashDataForPost: !1,
            //PAN AND ZOOM SETTINGS AND CONSTRAINTS
            panHorizontal: !0,
            panVertical: !0,
            constrainDuringPan: !1,
            wrapHorizontal: !1,
            wrapVertical: !1,
            visibilityRatio: 0.5,
            //-> how much of the viewer can be negative space
            minPixelRatio: 0.5,
            //->closer to 0 draws tiles meant for a higher zoom at this zoom
            defaultZoomLevel: 0,
            minZoomLevel: null,
            maxZoomLevel: null,
            homeFillsViewer: !1,
            //UI RESPONSIVENESS AND FEEL
            clickTimeThreshold: 300,
            clickDistThreshold: 5,
            dblClickTimeThreshold: 300,
            dblClickDistThreshold: 20,
            springStiffness: 6.5,
            animationTime: 1.2,
            gestureSettingsMouse: {
              dragToPan: !0,
              scrollToZoom: !0,
              clickToZoom: !0,
              dblClickToZoom: !1,
              dblClickDragToZoom: !1,
              pinchToZoom: !1,
              zoomToRefPoint: !0,
              flickEnabled: !1,
              flickMinSpeed: 120,
              flickMomentum: 0.25,
              pinchRotate: !1
            },
            gestureSettingsTouch: {
              dragToPan: !0,
              scrollToZoom: !1,
              clickToZoom: !1,
              dblClickToZoom: !0,
              dblClickDragToZoom: !0,
              pinchToZoom: !0,
              zoomToRefPoint: !0,
              flickEnabled: !0,
              flickMinSpeed: 120,
              flickMomentum: 0.25,
              pinchRotate: !1
            },
            gestureSettingsPen: {
              dragToPan: !0,
              scrollToZoom: !1,
              clickToZoom: !0,
              dblClickToZoom: !1,
              dblClickDragToZoom: !1,
              pinchToZoom: !1,
              zoomToRefPoint: !0,
              flickEnabled: !1,
              flickMinSpeed: 120,
              flickMomentum: 0.25,
              pinchRotate: !1
            },
            gestureSettingsUnknown: {
              dragToPan: !0,
              scrollToZoom: !1,
              clickToZoom: !1,
              dblClickToZoom: !0,
              dblClickDragToZoom: !1,
              pinchToZoom: !0,
              zoomToRefPoint: !0,
              flickEnabled: !0,
              flickMinSpeed: 120,
              flickMomentum: 0.25,
              pinchRotate: !1
            },
            zoomPerClick: 2,
            zoomPerScroll: 1.2,
            zoomPerDblClickDrag: 1.2,
            zoomPerSecond: 1,
            blendTime: 0,
            alwaysBlend: !1,
            autoHideControls: !0,
            immediateRender: !1,
            minZoomImageRatio: 0.9,
            //-> closer to 0 allows zoom out to infinity
            maxZoomPixelRatio: 1.1,
            //-> higher allows 'over zoom' into pixels
            smoothTileEdgesMinZoom: 1.1,
            //-> higher than maxZoomPixelRatio disables it
            iOSDevice: t(),
            pixelsPerWheelLine: 40,
            pixelsPerArrowPress: 40,
            autoResize: !0,
            preserveImageSizeOnResize: !1,
            // requires autoResize=true
            minScrollDeltaTime: 50,
            rotationIncrement: 90,
            maxTilesPerFrame: 1,
            //DEFAULT CONTROL SETTINGS
            showSequenceControl: !0,
            //SEQUENCE
            sequenceControlAnchor: null,
            //SEQUENCE
            preserveViewport: !1,
            //SEQUENCE
            preserveOverlays: !1,
            //SEQUENCE
            navPrevNextWrap: !1,
            //SEQUENCE
            showNavigationControl: !0,
            //ZOOM/HOME/FULL/ROTATION
            navigationControlAnchor: null,
            //ZOOM/HOME/FULL/ROTATION
            showZoomControl: !0,
            //ZOOM
            showHomeControl: !0,
            //HOME
            showFullPageControl: !0,
            //FULL
            showRotationControl: !1,
            //ROTATION
            showFlipControl: !1,
            //FLIP
            controlsFadeDelay: 2e3,
            //ZOOM/HOME/FULL/SEQUENCE
            controlsFadeLength: 1500,
            //ZOOM/HOME/FULL/SEQUENCE
            mouseNavEnabled: !0,
            //GENERAL MOUSE INTERACTIVITY
            //VIEWPORT NAVIGATOR SETTINGS
            showNavigator: !1,
            navigatorElement: null,
            navigatorId: null,
            navigatorPosition: null,
            navigatorSizeRatio: 0.2,
            navigatorMaintainSizeRatio: !1,
            navigatorTop: null,
            navigatorLeft: null,
            navigatorHeight: null,
            navigatorWidth: null,
            navigatorAutoResize: !0,
            navigatorAutoFade: !0,
            navigatorRotate: !0,
            navigatorBackground: "#000",
            navigatorOpacity: 0.8,
            navigatorBorderColor: "#555",
            navigatorDisplayRegionColor: "#900",
            // INITIAL ROTATION
            degrees: 0,
            // INITIAL FLIP STATE
            flipped: !1,
            overlayPreserveContentDirection: !0,
            // APPEARANCE
            opacity: 1,
            // to be passed into each TiledImage
            compositeOperation: null,
            // to be passed into each TiledImage
            // DRAWER SETTINGS
            drawer: ["webgl", "canvas", "html"],
            // prefer using webgl, then canvas (i.e. context2d), then fallback to html
            drawerOptions: {
              webgl: {},
              canvas: {},
              html: {},
              custom: {}
            },
            // TILED IMAGE SETTINGS
            preload: !1,
            // to be passed into each TiledImage
            imageSmoothingEnabled: !0,
            // to be passed into each TiledImage
            placeholderFillStyle: null,
            // to be passed into each TiledImage
            subPixelRoundingForTransparency: null,
            // to be passed into each TiledImage
            //REFERENCE STRIP SETTINGS
            showReferenceStrip: !1,
            referenceStripScroll: "horizontal",
            referenceStripElement: null,
            referenceStripHeight: null,
            referenceStripWidth: null,
            referenceStripPosition: "BOTTOM_LEFT",
            referenceStripSizeRatio: 0.2,
            //COLLECTION VISUALIZATION SETTINGS
            collectionRows: 3,
            //or columns depending on layout
            collectionColumns: 0,
            //columns in horizontal layout, rows in vertical layout
            collectionLayout: "horizontal",
            //vertical
            collectionMode: !1,
            collectionTileSize: 800,
            collectionTileMargin: 80,
            //PERFORMANCE SETTINGS
            imageLoaderLimit: 0,
            maxImageCacheCount: 200,
            timeout: 3e4,
            tileRetryMax: 0,
            tileRetryDelay: 2500,
            //INTERFACE RESOURCE SETTINGS
            prefixUrl: "/images/",
            navImages: {
              zoomIn: {
                REST: "zoomin_rest.png",
                GROUP: "zoomin_grouphover.png",
                HOVER: "zoomin_hover.png",
                DOWN: "zoomin_pressed.png"
              },
              zoomOut: {
                REST: "zoomout_rest.png",
                GROUP: "zoomout_grouphover.png",
                HOVER: "zoomout_hover.png",
                DOWN: "zoomout_pressed.png"
              },
              home: {
                REST: "home_rest.png",
                GROUP: "home_grouphover.png",
                HOVER: "home_hover.png",
                DOWN: "home_pressed.png"
              },
              fullpage: {
                REST: "fullpage_rest.png",
                GROUP: "fullpage_grouphover.png",
                HOVER: "fullpage_hover.png",
                DOWN: "fullpage_pressed.png"
              },
              rotateleft: {
                REST: "rotateleft_rest.png",
                GROUP: "rotateleft_grouphover.png",
                HOVER: "rotateleft_hover.png",
                DOWN: "rotateleft_pressed.png"
              },
              rotateright: {
                REST: "rotateright_rest.png",
                GROUP: "rotateright_grouphover.png",
                HOVER: "rotateright_hover.png",
                DOWN: "rotateright_pressed.png"
              },
              flip: {
                // Flip icon designed by Yaroslav Samoylov from the Noun Project and modified by Nelson Campos ncampos@criteriamarathon.com, https://thenounproject.com/term/flip/136289/
                REST: "flip_rest.png",
                GROUP: "flip_grouphover.png",
                HOVER: "flip_hover.png",
                DOWN: "flip_pressed.png"
              },
              previous: {
                REST: "previous_rest.png",
                GROUP: "previous_grouphover.png",
                HOVER: "previous_hover.png",
                DOWN: "previous_pressed.png"
              },
              next: {
                REST: "next_rest.png",
                GROUP: "next_grouphover.png",
                HOVER: "next_hover.png",
                DOWN: "next_pressed.png"
              }
            },
            //DEVELOPER SETTINGS
            debugMode: !1,
            debugGridColor: ["#437AB2", "#1B9E77", "#D95F02", "#7570B3", "#E7298A", "#66A61E", "#E6AB02", "#A6761D", "#666666"],
            silenceMultiImageWarnings: !1
          },
          /**
           * Returns a function which invokes the method as if it were a method belonging to the object.
           * @function
           * @param {Object} object
           * @param {Function} method
           * @returns {Function}
           */
          delegate: function(c, u) {
            return function() {
              var h = arguments;
              return h === void 0 && (h = []), u.apply(c, h);
            };
          },
          /**
           * An enumeration of Browser vendors.
           * @static
           * @type {Object}
           * @property {Number} UNKNOWN
           * @property {Number} IE
           * @property {Number} FIREFOX
           * @property {Number} SAFARI
           * @property {Number} CHROME
           * @property {Number} OPERA
           * @property {Number} EDGE
           * @property {Number} CHROMEEDGE
           */
          BROWSERS: {
            UNKNOWN: 0,
            IE: 1,
            FIREFOX: 2,
            SAFARI: 3,
            CHROME: 4,
            OPERA: 5,
            EDGE: 6,
            CHROMEEDGE: 7
          },
          /**
           * An enumeration of when subpixel rounding should occur.
           * @static
           * @type {Object}
           * @property {Number} NEVER Never apply subpixel rounding for transparency.
           * @property {Number} ONLY_AT_REST Do not apply subpixel rounding for transparency during animation (panning, zoom, rotation) and apply it once animation is over.
           * @property {Number} ALWAYS Apply subpixel rounding for transparency during animation and when animation is over.
           */
          SUBPIXEL_ROUNDING_OCCURRENCES: {
            NEVER: 0,
            ONLY_AT_REST: 1,
            ALWAYS: 2
          },
          /**
           * Keep track of which {@link Viewer}s have been created.
           * - Key: {@link Element} to which a Viewer is attached.
           * - Value: {@link Viewer} of the element defined by the key.
           * @private
           * @static
           * @type {Object}
           */
          _viewers: /* @__PURE__ */ new Map(),
          /**
            * Returns the {@link Viewer} attached to a given DOM element. If there is
            * no viewer attached to the provided element, undefined is returned.
            * @function
            * @param {String|Element} element Accepts an id or element.
            * @returns {Viewer} The viewer attached to the given element, or undefined.
            */
          getViewer: function(c) {
            return e._viewers.get(this.getElement(c));
          },
          /**
           * Returns a DOM Element for the given id or element.
           * @function
           * @param {String|Element} element Accepts an id or element.
           * @returns {Element} The element with the given id, null, or the element itself.
           */
          getElement: function(c) {
            return typeof c == "string" && (c = document.getElementById(c)), c;
          },
          /**
           * Determines the position of the upper-left corner of the element.
           * @function
           * @param {Element|String} element - the element we want the position for.
           * @returns {OpenSeadragon.Point} - the position of the upper left corner of the element.
           */
          getElementPosition: function(c) {
            var u = new e.Point(), h, f;
            for (c = e.getElement(c), h = e.getElementStyle(c).position === "fixed", f = a(c, h); f; )
              u.x += c.offsetLeft, u.y += c.offsetTop, h && (u = u.plus(e.getPageScroll())), c = f, h = e.getElementStyle(c).position === "fixed", f = a(c, h);
            return u;
          },
          /**
           * Determines the position of the upper-left corner of the element adjusted for current page and/or element scroll.
           * @function
           * @param {Element|String} element - the element we want the position for.
           * @returns {OpenSeadragon.Point} - the position of the upper left corner of the element adjusted for current page and/or element scroll.
           */
          getElementOffset: function(c) {
            c = e.getElement(c);
            var u = c && c.ownerDocument, h, f, g = { top: 0, left: 0 };
            return u ? (h = u.documentElement, typeof c.getBoundingClientRect < "u" && (g = c.getBoundingClientRect()), f = u === u.window ? u : u.nodeType === 9 ? u.defaultView || u.parentWindow : !1, new e.Point(
              g.left + (f.pageXOffset || h.scrollLeft) - (h.clientLeft || 0),
              g.top + (f.pageYOffset || h.scrollTop) - (h.clientTop || 0)
            )) : new e.Point();
          },
          /**
           * Determines the height and width of the given element.
           * @function
           * @param {Element|String} element
           * @returns {OpenSeadragon.Point}
           */
          getElementSize: function(c) {
            return c = e.getElement(c), new e.Point(
              c.clientWidth,
              c.clientHeight
            );
          },
          /**
           * Returns the CSSStyle object for the given element.
           * @function
           * @param {Element|String} element
           * @returns {CSSStyle}
           */
          getElementStyle: document.documentElement.currentStyle ? function(c) {
            return c = e.getElement(c), c.currentStyle;
          } : function(c) {
            return c = e.getElement(c), window.getComputedStyle(c, "");
          },
          /**
           * Returns the property with the correct vendor prefix appended.
           * @param {String} property the property name
           * @returns {String} the property with the correct prefix or null if not
           * supported.
           */
          getCssPropertyWithVendorPrefix: function(c) {
            var u = {};
            return e.getCssPropertyWithVendorPrefix = function(h) {
              if (u[h] !== void 0)
                return u[h];
              var f = document.createElement("div").style, g = null;
              if (f[h] !== void 0)
                g = h;
              else
                for (var x = [
                  "Webkit",
                  "Moz",
                  "MS",
                  "O",
                  "webkit",
                  "moz",
                  "ms",
                  "o"
                ], C = e.capitalizeFirstLetter(h), E = 0; E < x.length; E++) {
                  var R = x[E] + C;
                  if (f[R] !== void 0) {
                    g = R;
                    break;
                  }
                }
              return u[h] = g, g;
            }, e.getCssPropertyWithVendorPrefix(c);
          },
          /**
           * Capitalizes the first letter of a string
           * @param {String} string
           * @returns {String} The string with the first letter capitalized
           */
          capitalizeFirstLetter: function(c) {
            return c.charAt(0).toUpperCase() + c.slice(1);
          },
          /**
           * Compute the modulo of a number but makes sure to always return
           * a positive value (also known as Euclidean modulo).
           * @param {Number} number the number to compute the modulo of
           * @param {Number} modulo the modulo
           * @returns {Number} the result of the modulo of number
           */
          positiveModulo: function(c, u) {
            var h = c % u;
            return h < 0 && (h += u), h;
          },
          /**
           * Determines if a point is within the bounding rectangle of the given element (hit-test).
           * @function
           * @param {Element|String} element
           * @param {OpenSeadragon.Point} point
           * @returns {Boolean}
           */
          pointInElement: function(c, u) {
            c = e.getElement(c);
            var h = e.getElementOffset(c), f = e.getElementSize(c);
            return u.x >= h.x && u.x < h.x + f.x && u.y < h.y + f.y && u.y >= h.y;
          },
          /**
           * Gets the position of the mouse on the screen for a given event.
           * @function
           * @param {Event} [event]
           * @returns {OpenSeadragon.Point}
           */
          getMousePosition: function(c) {
            if (typeof c.pageX == "number")
              e.getMousePosition = function(u) {
                var h = new e.Point();
                return h.x = u.pageX, h.y = u.pageY, h;
              };
            else if (typeof c.clientX == "number")
              e.getMousePosition = function(u) {
                var h = new e.Point();
                return h.x = u.clientX + document.body.scrollLeft + document.documentElement.scrollLeft, h.y = u.clientY + document.body.scrollTop + document.documentElement.scrollTop, h;
              };
            else
              throw new Error(
                "Unknown event mouse position, no known technique."
              );
            return e.getMousePosition(c);
          },
          /**
           * Determines the page's current scroll position.
           * @function
           * @returns {OpenSeadragon.Point}
           */
          getPageScroll: function() {
            var c = document.documentElement || {}, u = document.body || {};
            if (typeof window.pageXOffset == "number")
              e.getPageScroll = function() {
                return new e.Point(
                  window.pageXOffset,
                  window.pageYOffset
                );
              };
            else if (u.scrollLeft || u.scrollTop)
              e.getPageScroll = function() {
                return new e.Point(
                  document.body.scrollLeft,
                  document.body.scrollTop
                );
              };
            else if (c.scrollLeft || c.scrollTop)
              e.getPageScroll = function() {
                return new e.Point(
                  document.documentElement.scrollLeft,
                  document.documentElement.scrollTop
                );
              };
            else
              return new e.Point(0, 0);
            return e.getPageScroll();
          },
          /**
           * Set the page scroll position.
           * @function
           * @returns {OpenSeadragon.Point}
           */
          setPageScroll: function(c) {
            if (typeof window.scrollTo < "u")
              e.setPageScroll = function(f) {
                window.scrollTo(f.x, f.y);
              };
            else {
              var u = e.getPageScroll();
              if (u.x === c.x && u.y === c.y)
                return;
              document.body.scrollLeft = c.x, document.body.scrollTop = c.y;
              var h = e.getPageScroll();
              if (h.x !== u.x && h.y !== u.y) {
                e.setPageScroll = function(f) {
                  document.body.scrollLeft = f.x, document.body.scrollTop = f.y;
                };
                return;
              }
              if (document.documentElement.scrollLeft = c.x, document.documentElement.scrollTop = c.y, h = e.getPageScroll(), h.x !== u.x && h.y !== u.y) {
                e.setPageScroll = function(f) {
                  document.documentElement.scrollLeft = f.x, document.documentElement.scrollTop = f.y;
                };
                return;
              }
              e.setPageScroll = function(f) {
              };
            }
            e.setPageScroll(c);
          },
          /**
           * Determines the size of the browsers window.
           * @function
           * @returns {OpenSeadragon.Point}
           */
          getWindowSize: function() {
            var c = document.documentElement || {}, u = document.body || {};
            if (typeof window.innerWidth == "number")
              e.getWindowSize = function() {
                return new e.Point(
                  window.innerWidth,
                  window.innerHeight
                );
              };
            else if (c.clientWidth || c.clientHeight)
              e.getWindowSize = function() {
                return new e.Point(
                  document.documentElement.clientWidth,
                  document.documentElement.clientHeight
                );
              };
            else if (u.clientWidth || u.clientHeight)
              e.getWindowSize = function() {
                return new e.Point(
                  document.body.clientWidth,
                  document.body.clientHeight
                );
              };
            else
              throw new Error("Unknown window size, no known technique.");
            return e.getWindowSize();
          },
          /**
           * Wraps the given element in a nest of divs so that the element can
           * be easily centered using CSS tables
           * @function
           * @param {Element|String} element
           * @returns {Element} outermost wrapper element
           */
          makeCenteredNode: function(c) {
            c = e.getElement(c);
            var u = [
              e.makeNeutralElement("div"),
              e.makeNeutralElement("div"),
              e.makeNeutralElement("div")
            ];
            return e.extend(u[0].style, {
              display: "table",
              height: "100%",
              width: "100%"
            }), e.extend(u[1].style, {
              display: "table-row"
            }), e.extend(u[2].style, {
              display: "table-cell",
              verticalAlign: "middle",
              textAlign: "center"
            }), u[0].appendChild(u[1]), u[1].appendChild(u[2]), u[2].appendChild(c), u[0];
          },
          /**
           * Creates an easily positionable element of the given type that therefor
           * serves as an excellent container element.
           * @function
           * @param {String} tagName
           * @returns {Element}
           */
          makeNeutralElement: function(c) {
            var u = document.createElement(c), h = u.style;
            return h.background = "transparent none", h.border = "none", h.margin = "0px", h.padding = "0px", h.position = "static", u;
          },
          /**
           * Returns the current milliseconds, using Date.now() if available
           * @function
           */
          now: function() {
            return Date.now ? e.now = Date.now : e.now = function() {
              return (/* @__PURE__ */ new Date()).getTime();
            }, e.now();
          },
          /**
           * Ensures an image is loaded correctly to support alpha transparency.
           * @function
           * @param {String} src
           * @returns {Element}
           */
          makeTransparentImage: function(c) {
            var u = e.makeNeutralElement("img");
            return u.src = c, u;
          },
          /**
           * Sets the opacity of the specified element.
           * @function
           * @param {Element|String} element
           * @param {Number} opacity
           * @param {Boolean} [usesAlpha]
           */
          setElementOpacity: function(c, u, h) {
            var f, g;
            c = e.getElement(c), h && !e.Browser.alpha && (u = Math.round(u)), e.Browser.opacity ? c.style.opacity = u < 1 ? u : "" : u < 1 ? (f = Math.round(100 * u), g = "alpha(opacity=" + f + ")", c.style.filter = g) : c.style.filter = "";
          },
          /**
           * Sets the specified element's touch-action style attribute to 'none'.
           * @function
           * @param {Element|String} element
           */
          setElementTouchActionNone: function(c) {
            c = e.getElement(c), typeof c.style.touchAction < "u" ? c.style.touchAction = "none" : typeof c.style.msTouchAction < "u" && (c.style.msTouchAction = "none");
          },
          /**
           * Sets the specified element's pointer-events style attribute to the passed value.
           * @function
           * @param {Element|String} element
           * @param {String} value
           */
          setElementPointerEvents: function(c, u) {
            c = e.getElement(c), typeof c.style < "u" && typeof c.style.pointerEvents < "u" && (c.style.pointerEvents = u);
          },
          /**
           * Sets the specified element's pointer-events style attribute to 'none'.
           * @function
           * @param {Element|String} element
           */
          setElementPointerEventsNone: function(c) {
            e.setElementPointerEvents(c, "none");
          },
          /**
           * Add the specified CSS class to the element if not present.
           * @function
           * @param {Element|String} element
           * @param {String} className
           */
          addClass: function(c, u) {
            c = e.getElement(c), c.className ? (" " + c.className + " ").indexOf(" " + u + " ") === -1 && (c.className += " " + u) : c.className = u;
          },
          /**
           * Find the first index at which an element is found in an array or -1
           * if not present.
           *
           * Code taken and adapted from
           * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf#Compatibility
           *
           * @function
           * @param {Array} array The array from which to find the element
           * @param {Object} searchElement The element to find
           * @param {Number} [fromIndex=0] Index to start research.
           * @returns {Number} The index of the element in the array.
           */
          indexOf: function(c, u, h) {
            return Array.prototype.indexOf ? this.indexOf = function(f, g, x) {
              return f.indexOf(g, x);
            } : this.indexOf = function(f, g, x) {
              var C, E = x || 0, R;
              if (!f)
                throw new TypeError();
              if (R = f.length, R === 0 || E >= R)
                return -1;
              for (E < 0 && (E = R - Math.abs(E)), C = E; C < R; C++)
                if (f[C] === g)
                  return C;
              return -1;
            }, this.indexOf(c, u, h);
          },
          /**
           * Remove the specified CSS class from the element.
           * @function
           * @param {Element|String} element
           * @param {String} className
           */
          removeClass: function(c, u) {
            var h, f = [], g;
            for (c = e.getElement(c), h = c.className.split(/\s+/), g = 0; g < h.length; g++)
              h[g] && h[g] !== u && f.push(h[g]);
            c.className = f.join(" ");
          },
          /**
           * Convert passed addEventListener() options to boolean or options object,
           * depending on browser support.
           * @function
           * @param {Boolean|Object} [options] Boolean useCapture, or if [supportsEventListenerOptions]{@link OpenSeadragon.supportsEventListenerOptions}, can be an object
           * @param {Boolean} [options.capture]
           * @param {Boolean} [options.passive]
           * @param {Boolean} [options.once]
           * @returns {String} The protocol (http:, https:, file:, ftp: ...)
           */
          normalizeEventListenerOptions: function(c) {
            var u;
            return typeof c < "u" ? typeof c == "boolean" ? u = e.supportsEventListenerOptions ? { capture: c } : c : u = e.supportsEventListenerOptions ? c : typeof c.capture < "u" ? c.capture : !1 : u = e.supportsEventListenerOptions ? { capture: !1 } : !1, u;
          },
          /**
           * Adds an event listener for the given element, eventName and handler.
           * @function
           * @param {Element|String} element
           * @param {String} eventName
           * @param {Function} handler
           * @param {Boolean|Object} [options] Boolean useCapture, or if [supportsEventListenerOptions]{@link OpenSeadragon.supportsEventListenerOptions}, can be an object
           * @param {Boolean} [options.capture]
           * @param {Boolean} [options.passive]
           * @param {Boolean} [options.once]
           */
          addEvent: (function() {
            if (e.supportsAddEventListener)
              return function(c, u, h, f) {
                f = e.normalizeEventListenerOptions(f), c = e.getElement(c), c.addEventListener(u, h, f);
              };
            if (document.documentElement.attachEvent && document.attachEvent)
              return function(c, u, h) {
                c = e.getElement(c), c.attachEvent("on" + u, h);
              };
            throw new Error("No known event model.");
          })(),
          /**
           * Remove a given event listener for the given element, event type and
           * handler.
           * @function
           * @param {Element|String} element
           * @param {String} eventName
           * @param {Function} handler
           * @param {Boolean|Object} [options] Boolean useCapture, or if [supportsEventListenerOptions]{@link OpenSeadragon.supportsEventListenerOptions}, can be an object
           * @param {Boolean} [options.capture]
           */
          removeEvent: (function() {
            if (e.supportsRemoveEventListener)
              return function(c, u, h, f) {
                f = e.normalizeEventListenerOptions(f), c = e.getElement(c), c.removeEventListener(u, h, f);
              };
            if (document.documentElement.detachEvent && document.detachEvent)
              return function(c, u, h) {
                c = e.getElement(c), c.detachEvent("on" + u, h);
              };
            throw new Error("No known event model.");
          })(),
          /**
           * Cancels the default browser behavior had the event propagated all
           * the way up the DOM to the window object.
           * @function
           * @param {Event} [event]
           */
          cancelEvent: function(c) {
            c.preventDefault();
          },
          /**
           * Returns true if {@link OpenSeadragon.cancelEvent|cancelEvent} has been called on
           * the event, otherwise returns false.
           * @function
           * @param {Event} [event]
           */
          eventIsCanceled: function(c) {
            return c.defaultPrevented;
          },
          /**
           * Stops the propagation of the event through the DOM in the capturing and bubbling phases.
           * @function
           * @param {Event} [event]
           */
          stopEvent: function(c) {
            c.stopPropagation();
          },
          // Deprecated
          createCallback: function(c, u) {
            console.error("The createCallback function is deprecated and will be removed in future versions. Please use alternativeFunction instead.");
            var h = [], f;
            for (f = 2; f < arguments.length; f++)
              h.push(arguments[f]);
            return function() {
              var g = h.concat([]), x;
              for (x = 0; x < arguments.length; x++)
                g.push(arguments[x]);
              return u.apply(c, g);
            };
          },
          /**
           * Retrieves the value of a url parameter from the window.location string.
           * @function
           * @param {String} key
           * @returns {String} The value of the url parameter or null if no param matches.
           */
          getUrlParameter: function(c) {
            var u = o[c];
            return u || null;
          },
          /**
           * Retrieves the protocol used by the url. The url can either be absolute
           * or relative.
           * @function
           * @private
           * @param {String} url The url to retrieve the protocol from.
           * @returns {String} The protocol (http:, https:, file:, ftp: ...)
           */
          getUrlProtocol: function(c) {
            var u = c.match(/^([a-z]+:)\/\//i);
            return u === null ? window.location.protocol : u[1].toLowerCase();
          },
          /**
           * Create an XHR object
           * @private
           * @param {type} [local] Deprecated. Ignored (IE/ActiveXObject file protocol no longer supported).
           * @returns {XMLHttpRequest}
           */
          createAjaxRequest: function() {
            if (window.XMLHttpRequest)
              return e.createAjaxRequest = function() {
                return new XMLHttpRequest();
              }, new XMLHttpRequest();
            throw new Error("Browser doesn't support XMLHttpRequest.");
          },
          /**
           * Makes an AJAX request.
           * @param {Object} options
           * @param {String} options.url - the url to request
           * @param {Function} options.success - a function to call on a successful response
           * @param {Function} options.error - a function to call on when an error occurs
           * @param {Object} options.headers - headers to add to the AJAX request
           * @param {String} options.responseType - the response type of the AJAX request
           * @param {String} options.postData - HTTP POST data (usually but not necessarily in k=v&k2=v2... form,
           *      see TileSource::getPostData), GET method used if null
           * @param {Boolean} [options.withCredentials=false] - whether to set the XHR's withCredentials
           * @throws {Error}
           * @returns {XMLHttpRequest}
           */
          makeAjaxRequest: function(c, u, h) {
            var f, g, x, C;
            e.isPlainObject(c) && (u = c.success, h = c.error, f = c.withCredentials, g = c.headers, x = c.responseType || null, C = c.postData || null, c = c.url);
            var E = e.getUrlProtocol(c), R = e.createAjaxRequest();
            if (!e.isFunction(u))
              throw new Error("makeAjaxRequest requires a success callback");
            R.onreadystatechange = function() {
              R.readyState === 4 && (R.onreadystatechange = function() {
              }, R.status >= 200 && R.status < 300 || R.status === 0 && E !== "http:" && E !== "https:" ? u(R) : e.isFunction(h) ? h(R) : e.console.error("AJAX request returned %d: %s", R.status, c));
            };
            var D = C ? "POST" : "GET";
            try {
              if (R.open(D, c, !0), x && (R.responseType = x), g)
                for (var U in g)
                  Object.prototype.hasOwnProperty.call(g, U) && g[U] && R.setRequestHeader(U, g[U]);
              f && (R.withCredentials = !0), R.send(C);
            } catch (Z) {
              e.console.error("%s while making AJAX request: %s", Z.name, Z.message), R.onreadystatechange = function() {
              }, e.isFunction(h) && h(R, Z);
            }
            return R;
          },
          /**
           * Taken from jQuery 1.6.1
           * @function
           * @param {Object} options
           * @param {String} options.url
           * @param {Function} options.callback
           * @param {String} [options.param='callback'] The name of the url parameter
           *      to request the jsonp provider with.
           * @param {String} [options.callbackName=] The name of the callback to
           *      request the jsonp provider with.
           */
          jsonp: function(c) {
            var u, h = c.url, f = document.head || document.getElementsByTagName("head")[0] || document.documentElement, g = c.callbackName || "openseadragon" + e.now(), x = window[g], C = "$1" + g + "$2", E = c.param || "callback", R = c.callback;
            h = h.replace(/(=)\?(&|$)|\?\?/i, C), h += (/\?/.test(h) ? "&" : "?") + E + "=" + g, window[g] = function(D) {
              if (x)
                window[g] = x;
              else
                try {
                  delete window[g];
                } catch {
                }
              R && e.isFunction(R) && R(D);
            }, u = document.createElement("script"), (c.async !== void 0 || c.async !== !1) && (u.async = "async"), c.scriptCharset && (u.charset = c.scriptCharset), u.src = h, u.onload = u.onreadystatechange = function(D, U) {
              (U || !u.readyState || /loaded|complete/.test(u.readyState)) && (u.onload = u.onreadystatechange = null, f && u.parentNode && f.removeChild(u), u = void 0);
            }, f.insertBefore(u, f.firstChild);
          },
          /**
           * Fully deprecated. Will throw an error.
           * @function
           * @deprecated use {@link OpenSeadragon.Viewer#open}
           */
          createFromDZI: function() {
            throw "OpenSeadragon.createFromDZI is deprecated, use Viewer.open.";
          },
          /**
           * Parses an XML string into a DOM Document.
           * @function
           * @param {String} string
           * @returns {Document}
           */
          parseXml: function(c) {
            if (window.DOMParser)
              e.parseXml = function(u) {
                var h = null, f;
                return f = new DOMParser(), h = f.parseFromString(u, "text/xml"), h;
              };
            else
              throw new Error("Browser doesn't support XML DOM.");
            return e.parseXml(c);
          },
          /**
           * Parses a JSON string into a Javascript object.
           * @function
           * @param {String} string
           * @returns {Object}
           */
          parseJSON: function(c) {
            return e.parseJSON = window.JSON.parse, e.parseJSON(c);
          },
          /**
           * Reports whether the image format is supported for tiling in this
           * version.
           * @function
           * @param {String} [extension]
           * @returns {Boolean}
           */
          imageFormatSupported: function(c) {
            return c = c || "", !!r[c.toLowerCase()];
          },
          /**
           * Updates supported image formats with user-specified values.
           * Preexisting formats that are not being updated are left unchanged.
           * By default, the defined formats are
           * <pre><code>{
           *      avif: true,
           *      bmp:  false,
           *      jpeg: true,
           *      jpg:  true,
           *      png:  true,
           *      tif:  false,
           *      wdp:  false,
           *      webp: true
           * }
           * </code></pre>
           * @function
           * @example
           * // sets bmp as supported and png as unsupported
           * setImageFormatsSupported({bmp: true, png: false});
           * @param {Object} formats An object containing format extensions as
           * keys and booleans as values.
           */
          setImageFormatsSupported: function(c) {
            e.extend(r, c);
          }
        }
      );
      var i = function(c) {
      };
      e.console = window.console || {
        log: i,
        debug: i,
        info: i,
        warn: i,
        error: i,
        assert: i
      }, e.Browser = {
        vendor: e.BROWSERS.UNKNOWN,
        version: 0,
        alpha: !0
      };
      var r = {
        avif: !0,
        bmp: !1,
        jpeg: !0,
        jpg: !0,
        png: !0,
        tif: !1,
        wdp: !1,
        webp: !0
      }, o = {};
      (function() {
        var c = navigator.appVersion, u = navigator.userAgent, h;
        switch (navigator.appName) {
          case "Microsoft Internet Explorer":
            window.attachEvent && window.ActiveXObject && (e.Browser.vendor = e.BROWSERS.IE, e.Browser.version = parseFloat(
              u.substring(
                u.indexOf("MSIE") + 5,
                u.indexOf(";", u.indexOf("MSIE"))
              )
            ));
            break;
          case "Netscape":
            window.addEventListener && (u.indexOf("Edge") >= 0 ? (e.Browser.vendor = e.BROWSERS.EDGE, e.Browser.version = parseFloat(
              u.substring(u.indexOf("Edge") + 5)
            )) : u.indexOf("Edg") >= 0 ? (e.Browser.vendor = e.BROWSERS.CHROMEEDGE, e.Browser.version = parseFloat(
              u.substring(u.indexOf("Edg") + 4)
            )) : u.indexOf("Firefox") >= 0 ? (e.Browser.vendor = e.BROWSERS.FIREFOX, e.Browser.version = parseFloat(
              u.substring(u.indexOf("Firefox") + 8)
            )) : u.indexOf("Safari") >= 0 ? (e.Browser.vendor = u.indexOf("Chrome") >= 0 ? e.BROWSERS.CHROME : e.BROWSERS.SAFARI, e.Browser.version = parseFloat(
              u.substring(
                u.substring(0, u.indexOf("Safari")).lastIndexOf("/") + 1,
                u.indexOf("Safari")
              )
            )) : (h = new RegExp("Trident/.*rv:([0-9]{1,}[.0-9]{0,})"), h.exec(u) !== null && (e.Browser.vendor = e.BROWSERS.IE, e.Browser.version = parseFloat(RegExp.$1))));
            break;
          case "Opera":
            e.Browser.vendor = e.BROWSERS.OPERA, e.Browser.version = parseFloat(c);
            break;
        }
        var f = window.location.search.substring(1), g = f.split("&"), x, C, E;
        for (E = 0; E < g.length; E++)
          if (x = g[E], C = x.indexOf("="), C > 0) {
            var R = x.substring(0, C), D = x.substring(C + 1);
            try {
              o[R] = decodeURIComponent(D);
            } catch {
              e.console.error("Ignoring malformed URL parameter: %s=%s", R, D);
            }
          }
        e.Browser.alpha = !(e.Browser.vendor === e.BROWSERS.CHROME && e.Browser.version < 2), e.Browser.opacity = !0, e.Browser.vendor === e.BROWSERS.IE && e.console.error("Internet Explorer is not supported by OpenSeadragon");
      })(), (function(c) {
        var u = c.requestAnimationFrame || c.mozRequestAnimationFrame || c.webkitRequestAnimationFrame || c.msRequestAnimationFrame, h = c.cancelAnimationFrame || c.mozCancelAnimationFrame || c.webkitCancelAnimationFrame || c.msCancelAnimationFrame;
        if (u && h)
          e.requestAnimationFrame = function() {
            return u.apply(c, arguments);
          }, e.cancelAnimationFrame = function() {
            return h.apply(c, arguments);
          };
        else {
          var f = [], g = [], x = 0, C;
          e.requestAnimationFrame = function(E) {
            return f.push([++x, E]), C || (C = setInterval(function() {
              if (f.length) {
                var R = e.now(), D = g;
                for (g = f, f = D; g.length; )
                  g.shift()[1](R);
              } else
                clearInterval(C), C = void 0;
            }, 1e3 / 50)), x;
          }, e.cancelAnimationFrame = function(E) {
            var R, D;
            for (R = 0, D = f.length; R < D; R += 1)
              if (f[R][0] === E) {
                f.splice(R, 1);
                return;
              }
            for (R = 0, D = g.length; R < D; R += 1)
              if (g[R][0] === E) {
                g.splice(R, 1);
                return;
              }
          };
        }
      })(window);
      function a(c, u) {
        return u && c !== document.body ? document.body : c.offsetParent;
      }
    })(n), (function(e, t) {
      s.exports ? s.exports = t() : e.OpenSeadragon = t();
    })(Tg, function() {
      return n;
    }), (function(e) {
      class t {
        constructor(r) {
          r || (r = [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
          ]), this.values = r;
        }
        /**
         * @function makeIdentity
         * @memberof OpenSeadragon.Mat3
         * @static
         * @returns {OpenSeadragon.Mat3} an identity matrix
         */
        static makeIdentity() {
          return new t([
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
          ]);
        }
        /**
         * @function makeTranslation
         * @memberof OpenSeadragon.Mat3
         * @static
         * @param {Number} tx The x value of the translation
         * @param {Number} ty The y value of the translation
         * @returns {OpenSeadragon.Mat3} A translation matrix
         */
        static makeTranslation(r, o) {
          return new t([
            1,
            0,
            0,
            0,
            1,
            0,
            r,
            o,
            1
          ]);
        }
        /**
         * @function makeRotation
         * @memberof OpenSeadragon.Mat3
         * @static
         * @param {Number} angleInRadians The desired rotation angle, in radians
         * @returns {OpenSeadragon.Mat3} A rotation matrix
         */
        static makeRotation(r) {
          var o = Math.cos(r), a = Math.sin(r);
          return new t([
            o,
            -a,
            0,
            a,
            o,
            0,
            0,
            0,
            1
          ]);
        }
        /**
         * @function makeScaling
         * @memberof OpenSeadragon.Mat3
         * @static
         * @param {Number} sx The x value of the scaling
         * @param {Number} sy The y value of the scaling
         * @returns {OpenSeadragon.Mat3} A scaling matrix
         */
        static makeScaling(r, o) {
          return new t([
            r,
            0,
            0,
            0,
            o,
            0,
            0,
            0,
            1
          ]);
        }
        /**
         * @alias multiply
         * @memberof! OpenSeadragon.Mat3
         * @param {OpenSeadragon.Mat3} other the matrix to multiply with
         * @returns {OpenSeadragon.Mat3} The result of matrix multiplication
         */
        multiply(r) {
          let o = this.values, a = r.values;
          var c = o[0], u = o[1], h = o[2], f = o[3], g = o[4], x = o[5], C = o[6], E = o[7], R = o[8], D = a[0], U = a[1], Z = a[2], ce = a[3], re = a[4], ue = a[5], me = a[6], Te = a[7], Re = a[8];
          return new t([
            D * c + U * f + Z * C,
            D * u + U * g + Z * E,
            D * h + U * x + Z * R,
            ce * c + re * f + ue * C,
            ce * u + re * g + ue * E,
            ce * h + re * x + ue * R,
            me * c + Te * f + Re * C,
            me * u + Te * g + Re * E,
            me * h + Te * x + Re * R
          ]);
        }
      }
      e.Mat3 = t;
    })(n), (function(e) {
      var t = {
        supportsFullScreen: !1,
        isFullScreen: function() {
          return !1;
        },
        getFullScreenElement: function() {
          return null;
        },
        requestFullScreen: function() {
        },
        exitFullScreen: function() {
        },
        cancelFullScreen: function() {
        },
        fullScreenEventName: "",
        fullScreenErrorEventName: ""
      };
      document.exitFullscreen ? (t.supportsFullScreen = !0, t.getFullScreenElement = function() {
        return document.fullscreenElement;
      }, t.requestFullScreen = function(i) {
        return i.requestFullscreen().catch(function(r) {
          e.console.error("Fullscreen request failed: ", r);
        });
      }, t.exitFullScreen = function() {
        document.exitFullscreen().catch(function(i) {
          e.console.error("Error while exiting fullscreen: ", i);
        });
      }, t.fullScreenEventName = "fullscreenchange", t.fullScreenErrorEventName = "fullscreenerror") : document.msExitFullscreen ? (t.supportsFullScreen = !0, t.getFullScreenElement = function() {
        return document.msFullscreenElement;
      }, t.requestFullScreen = function(i) {
        return i.msRequestFullscreen();
      }, t.exitFullScreen = function() {
        document.msExitFullscreen();
      }, t.fullScreenEventName = "MSFullscreenChange", t.fullScreenErrorEventName = "MSFullscreenError") : document.webkitExitFullscreen ? (t.supportsFullScreen = !0, t.getFullScreenElement = function() {
        return document.webkitFullscreenElement;
      }, t.requestFullScreen = function(i) {
        return i.webkitRequestFullscreen();
      }, t.exitFullScreen = function() {
        document.webkitExitFullscreen();
      }, t.fullScreenEventName = "webkitfullscreenchange", t.fullScreenErrorEventName = "webkitfullscreenerror") : document.webkitCancelFullScreen ? (t.supportsFullScreen = !0, t.getFullScreenElement = function() {
        return document.webkitCurrentFullScreenElement;
      }, t.requestFullScreen = function(i) {
        return i.webkitRequestFullScreen();
      }, t.exitFullScreen = function() {
        document.webkitCancelFullScreen();
      }, t.fullScreenEventName = "webkitfullscreenchange", t.fullScreenErrorEventName = "webkitfullscreenerror") : document.mozCancelFullScreen && (t.supportsFullScreen = !0, t.getFullScreenElement = function() {
        return document.mozFullScreenElement;
      }, t.requestFullScreen = function(i) {
        return i.mozRequestFullScreen();
      }, t.exitFullScreen = function() {
        document.mozCancelFullScreen();
      }, t.fullScreenEventName = "mozfullscreenchange", t.fullScreenErrorEventName = "mozfullscreenerror"), t.isFullScreen = function() {
        return t.getFullScreenElement() !== null;
      }, t.cancelFullScreen = function() {
        e.console.error("cancelFullScreen is deprecated. Use exitFullScreen instead."), t.exitFullScreen();
      }, e.extend(e, t);
    })(n), (function(e) {
      e.EventSource = function() {
        this.events = {}, this._rejectedEventList = {};
      }, e.EventSource.prototype = {
        /**
         * Add an event handler to be triggered only once (or a given number of times)
         * for a given event. It is not removable with removeHandler().
         * @function
         * @param {String} eventName - Name of event to register.
         * @param {OpenSeadragon.EventHandler} handler - Function to call when event
         * is triggered.
         * @param {Object} [userData=null] - Arbitrary object to be passed unchanged
         * to the handler.
         * @param {Number} [times=1] - The number of times to handle the event
         * before removing it.
         * @param {Number} [priority=0] - Handler priority. By default, all priorities are 0. Higher number = priority.
         * @returns {Boolean} - True if the handler was added, false if it was rejected
         */
        addOnceHandler: function(t, i, r, o, a) {
          var c = this;
          o = o || 1;
          var u = 0, h = function(f) {
            return u++, u === o && c.removeHandler(t, h), i(f);
          };
          return this.addHandler(t, h, r, a);
        },
        /**
         * Add an event handler for a given event.
         * @function
         * @param {String} eventName - Name of event to register.
         * @param {OpenSeadragon.EventHandler} handler - Function to call when event is triggered.
         * @param {Object} [userData=null] - Arbitrary object to be passed unchanged to the handler.
         * @param {Number} [priority=0] - Handler priority. By default, all priorities are 0. Higher number = priority.
         * @returns {Boolean} - True if the handler was added, false if it was rejected
         */
        addHandler: function(t, i, r, o) {
          if (Object.prototype.hasOwnProperty.call(this._rejectedEventList, t))
            return e.console.error(`Error adding handler for ${t}. ${this._rejectedEventList[t]}`), !1;
          var a = this.events[t];
          if (a || (this.events[t] = a = []), i && e.isFunction(i)) {
            var c = a.length, u = { handler: i, userData: r || null, priority: o || 0 };
            for (a[c] = u; c > 0 && a[c - 1].priority < a[c].priority; )
              a[c] = a[c - 1], a[c - 1] = u, c--;
          }
          return !0;
        },
        /**
         * Remove a specific event handler for a given event.
         * @function
         * @param {String} eventName - Name of event for which the handler is to be removed.
         * @param {OpenSeadragon.EventHandler} handler - Function to be removed.
         */
        removeHandler: function(t, i) {
          var r = this.events[t], o = [], a;
          if (r && e.isArray(r)) {
            for (a = 0; a < r.length; a++)
              r[a].handler !== i && o.push(r[a]);
            this.events[t] = o;
          }
        },
        /**
         * Get the amount of handlers registered for a given event.
         * @param {String} eventName - Name of event to inspect.
         * @returns {number} amount of events
         */
        numberOfHandlers: function(t) {
          var i = this.events[t];
          return i ? i.length : 0;
        },
        /**
         * Remove all event handlers for a given event type. If no type is given all
         * event handlers for every event type are removed.
         * @function
         * @param {String} eventName - Name of event for which all handlers are to be removed.
         */
        removeAllHandlers: function(t) {
          if (t)
            this.events[t] = [];
          else
            for (var i in this.events)
              this.events[i] = [];
        },
        /**
         * Get a function which iterates the list of all handlers registered for a given event, calling the handler for each.
         * @function
         * @param {String} eventName - Name of event to get handlers for.
         */
        getHandler: function(t) {
          var i = this.events[t];
          return !i || !i.length ? null : (i = i.length === 1 ? [i[0]] : Array.apply(null, i), function(r, o) {
            var a, c = i.length;
            for (a = 0; a < c; a++)
              i[a] && (o.eventSource = r, o.userData = i[a].userData, i[a].handler(o));
          });
        },
        /**
         * Trigger an event, optionally passing additional information.
         * @function
         * @param {String} eventName - Name of event to register.
         * @param {Object} eventArgs - Event-specific data.
         * @returns {Boolean} True if the event was fired, false if it was rejected because of rejectEventHandler(eventName)
         */
        raiseEvent: function(t, i) {
          if (Object.prototype.hasOwnProperty.call(this._rejectedEventList, t))
            return e.console.error(`Error adding handler for ${t}. ${this._rejectedEventList[t]}`), !1;
          var r = this.getHandler(t);
          return r && r(this, i || {}), !0;
        },
        /**
         * Set an event name as being disabled, and provide an optional error message
         * to be printed to the console
         * @param {String} eventName - Name of the event
         * @param {String} [errorMessage] - Optional string to print to the console
         * @private
         */
        rejectEventHandler(t, i = "") {
          this._rejectedEventList[t] = i;
        },
        /**
         * Explicitly allow an event handler to be added for this event type, undoing
         * the effects of rejectEventHandler
         * @param {String} eventName - Name of the event
         * @private
         */
        allowEventHandler(t) {
          delete this._rejectedEventList[t];
        }
      };
    })(n), (function(e) {
      var t = {};
      e.MouseTracker = function(y) {
        var _ = arguments;
        e.isPlainObject(y) || (y = {
          element: _[0],
          clickTimeThreshold: _[1],
          clickDistThreshold: _[2]
        }), this.hash = Math.random(), this.element = e.getElement(y.element), this.clickTimeThreshold = y.clickTimeThreshold || e.DEFAULT_SETTINGS.clickTimeThreshold, this.clickDistThreshold = y.clickDistThreshold || e.DEFAULT_SETTINGS.clickDistThreshold, this.dblClickTimeThreshold = y.dblClickTimeThreshold || e.DEFAULT_SETTINGS.dblClickTimeThreshold, this.dblClickDistThreshold = y.dblClickDistThreshold || e.DEFAULT_SETTINGS.dblClickDistThreshold, this.userData = y.userData || null, this.stopDelay = y.stopDelay || 50, this.preProcessEventHandler = y.preProcessEventHandler || null, this.contextMenuHandler = y.contextMenuHandler || null, this.enterHandler = y.enterHandler || null, this.leaveHandler = y.leaveHandler || null, this.exitHandler = y.exitHandler || null, this.overHandler = y.overHandler || null, this.outHandler = y.outHandler || null, this.pressHandler = y.pressHandler || null, this.nonPrimaryPressHandler = y.nonPrimaryPressHandler || null, this.releaseHandler = y.releaseHandler || null, this.nonPrimaryReleaseHandler = y.nonPrimaryReleaseHandler || null, this.moveHandler = y.moveHandler || null, this.scrollHandler = y.scrollHandler || null, this.clickHandler = y.clickHandler || null, this.dblClickHandler = y.dblClickHandler || null, this.dragHandler = y.dragHandler || null, this.dragEndHandler = y.dragEndHandler || null, this.pinchHandler = y.pinchHandler || null, this.stopHandler = y.stopHandler || null, this.keyDownHandler = y.keyDownHandler || null, this.keyUpHandler = y.keyUpHandler || null, this.keyHandler = y.keyHandler || null, this.focusHandler = y.focusHandler || null, this.blurHandler = y.blurHandler || null;
        var T = this;
        t[this.hash] = {
          click: function(S) {
            Z(T, S);
          },
          dblclick: function(S) {
            ce(T, S);
          },
          keydown: function(S) {
            re(T, S);
          },
          keyup: function(S) {
            ue(T, S);
          },
          keypress: function(S) {
            me(T, S);
          },
          focus: function(S) {
            Te(T, S);
          },
          blur: function(S) {
            Re(T, S);
          },
          contextmenu: function(S) {
            He(T, S);
          },
          wheel: function(S) {
            Fe(T, S);
          },
          mousewheel: function(S) {
            _e(T, S);
          },
          DOMMouseScroll: function(S) {
            _e(T, S);
          },
          MozMousePixelScroll: function(S) {
            _e(T, S);
          },
          losecapture: function(S) {
            Je(T, S);
          },
          mouseenter: function(S) {
            be(T, S);
          },
          mouseleave: function(S) {
            Xt(T, S);
          },
          mouseover: function(S) {
            St(T, S);
          },
          mouseout: function(S) {
            _t(T, S);
          },
          mousedown: function(S) {
            xt(T, S);
          },
          mouseup: function(S) {
            vi(T, S);
          },
          mousemove: function(S) {
            kt(T, S);
          },
          touchstart: function(S) {
            Ge(T, S);
          },
          touchend: function(S) {
            qe(T, S);
          },
          touchmove: function(S) {
            nt(T, S);
          },
          touchcancel: function(S) {
            Ve(T, S);
          },
          gesturestart: function(S) {
            ot(T, S);
          },
          // Safari/Safari iOS
          gesturechange: function(S) {
            $e(T, S);
          },
          // Safari/Safari iOS
          gotpointercapture: function(S) {
            Yt(T, S);
          },
          lostpointercapture: function(S) {
            Wi(T, S);
          },
          pointerenter: function(S) {
            be(T, S);
          },
          pointerleave: function(S) {
            Xt(T, S);
          },
          pointerover: function(S) {
            St(T, S);
          },
          pointerout: function(S) {
            _t(T, S);
          },
          pointerdown: function(S) {
            xt(T, S);
          },
          pointerup: function(S) {
            vi(T, S);
          },
          pointermove: function(S) {
            kt(T, S);
          },
          pointercancel: function(S) {
            ji(T, S);
          },
          pointerupcaptured: function(S) {
            fe(T, S);
          },
          pointermovecaptured: function(S) {
            Ie(T, S);
          },
          tracking: !1,
          // Active pointers lists. Array of GesturePointList objects, one for each pointer device type.
          // GesturePointList objects are added each time a pointer is tracked by a new pointer device type (see getActivePointersListByType()).
          // Active pointers are any pointer being tracked for this element which are in the hit-test area
          //     of the element (for hover-capable devices) and/or have contact or a button press initiated in the element.
          activePointersLists: [],
          // Tracking for double-click gesture
          lastClickPos: null,
          dblClickTimeOut: null,
          // Tracking for pinch gesture
          pinchGPoints: [],
          lastPinchDist: 0,
          currentPinchDist: 0,
          lastPinchCenter: null,
          currentPinchCenter: null,
          // Tracking for drag
          sentDragEvent: !1
        }, this.hasGestureHandlers = !!(this.pressHandler || this.nonPrimaryPressHandler || this.releaseHandler || this.nonPrimaryReleaseHandler || this.clickHandler || this.dblClickHandler || this.dragHandler || this.dragEndHandler || this.pinchHandler), this.hasScrollHandler = !!this.scrollHandler, e.MouseTracker.havePointerEvents && e.setElementPointerEvents(this.element, "auto"), this.exitHandler && e.console.error("MouseTracker.exitHandler is deprecated. Use MouseTracker.leaveHandler instead."), y.startDisabled || this.setTracking(!0);
      }, e.MouseTracker.prototype = {
        /**
         * Clean up any events or objects created by the tracker.
         * @function
         */
        destroy: function() {
          c(this), this.element = null, t[this.hash] = null, delete t[this.hash];
        },
        /**
         * Are we currently tracking events on this element.
         * @deprecated Just use this.tracking
         * @function
         * @returns {Boolean} Are we currently tracking events on this element.
         */
        isTracking: function() {
          return t[this.hash].tracking;
        },
        /**
         * Enable or disable whether or not we are tracking events on this element.
         * @function
         * @param {Boolean} track True to start tracking, false to stop tracking.
         * @returns {OpenSeadragon.MouseTracker} Chainable.
         */
        setTracking: function(y) {
          return y ? a(this) : c(this), this;
        },
        /**
         * Returns the {@link OpenSeadragon.MouseTracker.GesturePointList|GesturePointList} for the given pointer device type,
         * creating and caching a new {@link OpenSeadragon.MouseTracker.GesturePointList|GesturePointList} if one doesn't already exist for the type.
         * @function
         * @param {String} type - The pointer device type: "mouse", "touch", "pen", etc.
         * @returns {OpenSeadragon.MouseTracker.GesturePointList}
         */
        getActivePointersListByType: function(y) {
          var _ = t[this.hash], T, S = _ ? _.activePointersLists.length : 0, G;
          for (T = 0; T < S; T++)
            if (_.activePointersLists[T].type === y)
              return _.activePointersLists[T];
          return G = new e.MouseTracker.GesturePointList(y), _ && _.activePointersLists.push(G), G;
        },
        /**
         * Returns the total number of pointers currently active on the tracked element.
         * @function
         * @returns {Number}
         */
        getActivePointerCount: function() {
          var y = t[this.hash], _, T = y.activePointersLists.length, S = 0;
          for (_ = 0; _ < T; _++)
            S += y.activePointersLists[_].getLength();
          return S;
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {OpenSeadragon.MouseTracker.EventProcessInfo} eventInfo
         */
        preProcessEventHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {OpenSeadragon.Point} event.position
         *      The position of the event relative to the tracked element.
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Boolean} event.preventDefault
         *      Set to true to prevent the default user-agent's handling of the contextmenu event.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        contextMenuHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {String} event.pointerType
         *     "mouse", "touch", "pen", etc.
         * @param {OpenSeadragon.Point} event.position
         *      The position of the event relative to the tracked element.
         * @param {Number} event.buttons
         *      Current buttons pressed.
         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
         * @param {Number} event.pointers
         *      Number of pointers (all types) active in the tracked element.
         * @param {Boolean} event.insideElementPressed
         *      True if the left mouse button is currently being pressed and was
         *      initiated inside the tracked element, otherwise false.
         * @param {Boolean} event.buttonDownAny
         *      Was the button down anywhere in the screen during the event. <span style="color:red;">Deprecated. Use buttons instead.</span>
         * @param {Boolean} event.isTouchEvent
         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        enterHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @since v2.5.0
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {String} event.pointerType
         *     "mouse", "touch", "pen", etc.
         * @param {OpenSeadragon.Point} event.position
         *      The position of the event relative to the tracked element.
         * @param {Number} event.buttons
         *      Current buttons pressed.
         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
         * @param {Number} event.pointers
         *      Number of pointers (all types) active in the tracked element.
         * @param {Boolean} event.insideElementPressed
         *      True if the left mouse button is currently being pressed and was
         *      initiated inside the tracked element, otherwise false.
         * @param {Boolean} event.buttonDownAny
         *      Was the button down anywhere in the screen during the event. <span style="color:red;">Deprecated. Use buttons instead.</span>
         * @param {Boolean} event.isTouchEvent
         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        leaveHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @deprecated v2.5.0 Use leaveHandler instead
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {String} event.pointerType
         *     "mouse", "touch", "pen", etc.
         * @param {OpenSeadragon.Point} event.position
         *      The position of the event relative to the tracked element.
         * @param {Number} event.buttons
         *      Current buttons pressed.
         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
         * @param {Number} event.pointers
         *      Number of pointers (all types) active in the tracked element.
         * @param {Boolean} event.insideElementPressed
         *      True if the left mouse button is currently being pressed and was
         *      initiated inside the tracked element, otherwise false.
         * @param {Boolean} event.buttonDownAny
         *      Was the button down anywhere in the screen during the event. <span style="color:red;">Deprecated. Use buttons instead.</span>
         * @param {Boolean} event.isTouchEvent
         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        exitHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @since v2.5.0
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {String} event.pointerType
         *     "mouse", "touch", "pen", etc.
         * @param {OpenSeadragon.Point} event.position
         *      The position of the event relative to the tracked element.
         * @param {Number} event.buttons
         *      Current buttons pressed.
         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
         * @param {Number} event.pointers
         *      Number of pointers (all types) active in the tracked element.
         * @param {Boolean} event.insideElementPressed
         *      True if the left mouse button is currently being pressed and was
         *      initiated inside the tracked element, otherwise false.
         * @param {Boolean} event.buttonDownAny
         *      Was the button down anywhere in the screen during the event. <span style="color:red;">Deprecated. Use buttons instead.</span>
         * @param {Boolean} event.isTouchEvent
         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        overHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @since v2.5.0
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {String} event.pointerType
         *     "mouse", "touch", "pen", etc.
         * @param {OpenSeadragon.Point} event.position
         *      The position of the event relative to the tracked element.
         * @param {Number} event.buttons
         *      Current buttons pressed.
         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
         * @param {Number} event.pointers
         *      Number of pointers (all types) active in the tracked element.
         * @param {Boolean} event.insideElementPressed
         *      True if the left mouse button is currently being pressed and was
         *      initiated inside the tracked element, otherwise false.
         * @param {Boolean} event.buttonDownAny
         *      Was the button down anywhere in the screen during the event. <span style="color:red;">Deprecated. Use buttons instead.</span>
         * @param {Boolean} event.isTouchEvent
         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        outHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {String} event.pointerType
         *     "mouse", "touch", "pen", etc.
         * @param {OpenSeadragon.Point} event.position
         *      The position of the event relative to the tracked element.
         * @param {Number} event.buttons
         *      Current buttons pressed.
         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
         * @param {Boolean} event.isTouchEvent
         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        pressHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {String} event.pointerType
         *     "mouse", "touch", "pen", etc.
         * @param {OpenSeadragon.Point} event.position
         *      The position of the event relative to the tracked element.
         * @param {Number} event.button
         *      Button which caused the event.
         *      -1: none, 0: primary/left, 1: aux/middle, 2: secondary/right, 3: X1/back, 4: X2/forward, 5: pen eraser.
         * @param {Number} event.buttons
         *      Current buttons pressed.
         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
         * @param {Boolean} event.isTouchEvent
         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        nonPrimaryPressHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {String} event.pointerType
         *     "mouse", "touch", "pen", etc.
         * @param {OpenSeadragon.Point} event.position
         *      The position of the event relative to the tracked element.
         * @param {Number} event.buttons
         *      Current buttons pressed.
         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
         * @param {Boolean} event.insideElementPressed
         *      True if the left mouse button is currently being pressed and was
         *      initiated inside the tracked element, otherwise false.
         * @param {Boolean} event.insideElementReleased
         *      True if the cursor inside the tracked element when the button was released.
         * @param {Boolean} event.isTouchEvent
         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        releaseHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {String} event.pointerType
         *     "mouse", "touch", "pen", etc.
         * @param {OpenSeadragon.Point} event.position
         *      The position of the event relative to the tracked element.
         * @param {Number} event.button
         *      Button which caused the event.
         *      -1: none, 0: primary/left, 1: aux/middle, 2: secondary/right, 3: X1/back, 4: X2/forward, 5: pen eraser.
         * @param {Number} event.buttons
         *      Current buttons pressed.
         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
         * @param {Boolean} event.isTouchEvent
         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        nonPrimaryReleaseHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {String} event.pointerType
         *     "mouse", "touch", "pen", etc.
         * @param {OpenSeadragon.Point} event.position
         *      The position of the event relative to the tracked element.
         * @param {Number} event.buttons
         *      Current buttons pressed.
         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
         * @param {Boolean} event.isTouchEvent
         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        moveHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {String} event.pointerType
         *     "mouse", "touch", "pen", etc.
         * @param {OpenSeadragon.Point} event.position
         *      The position of the event relative to the tracked element.
         * @param {Number} event.scroll
         *      The scroll delta for the event.
         * @param {Boolean} event.shift
         *      True if the shift key was pressed during this event.
         * @param {Boolean} event.isTouchEvent
         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead. Touch devices no longer generate scroll event.</span>
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Boolean} event.preventDefault
         *      Set to true to prevent the default user-agent's handling of the wheel event.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        scrollHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {String} event.pointerType
         *     "mouse", "touch", "pen", etc.
         * @param {OpenSeadragon.Point} event.position
         *      The position of the event relative to the tracked element.
         * @param {Boolean} event.quick
         *      True only if the clickDistThreshold and clickTimeThreshold are both passed. Useful for ignoring drag events.
         * @param {Boolean} event.shift
         *      True if the shift key was pressed during this event.
         * @param {Boolean} event.isTouchEvent
         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Element} event.originalTarget
         *      The DOM element clicked on.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        clickHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {String} event.pointerType
         *     "mouse", "touch", "pen", etc.
         * @param {OpenSeadragon.Point} event.position
         *      The position of the event relative to the tracked element.
         * @param {Boolean} event.shift
         *      True if the shift key was pressed during this event.
         * @param {Boolean} event.isTouchEvent
         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        dblClickHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {String} event.pointerType
         *     "mouse", "touch", "pen", etc.
         * @param {OpenSeadragon.Point} event.position
         *      The position of the event relative to the tracked element.
         * @param {Number} event.buttons
         *      Current buttons pressed.
         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
         * @param {OpenSeadragon.Point} event.delta
         *      The x,y components of the difference between the current position and the last drag event position.  Useful for ignoring or weighting the events.
         * @param {Number} event.speed
         *     Current computed speed, in pixels per second.
         * @param {Number} event.direction
         *     Current computed direction, expressed as an angle counterclockwise relative to the positive X axis (-pi to pi, in radians). Only valid if speed > 0.
         * @param {Boolean} event.shift
         *      True if the shift key was pressed during this event.
         * @param {Boolean} event.isTouchEvent
         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        dragHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {String} event.pointerType
         *     "mouse", "touch", "pen", etc.
         * @param {OpenSeadragon.Point} event.position
         *      The position of the event relative to the tracked element.
         * @param {Number} event.speed
         *     Speed at the end of a drag gesture, in pixels per second.
         * @param {Number} event.direction
         *     Direction at the end of a drag gesture, expressed as an angle counterclockwise relative to the positive X axis (-pi to pi, in radians). Only valid if speed > 0.
         * @param {Boolean} event.shift
         *      True if the shift key was pressed during this event.
         * @param {Boolean} event.isTouchEvent
         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        dragEndHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {String} event.pointerType
         *     "mouse", "touch", "pen", etc.
         * @param {Array.<OpenSeadragon.MouseTracker.GesturePoint>} event.gesturePoints
         *      Gesture points associated with the gesture. Velocity data can be found here.
         * @param {OpenSeadragon.Point} event.lastCenter
         *      The previous center point of the two pinch contact points relative to the tracked element.
         * @param {OpenSeadragon.Point} event.center
         *      The center point of the two pinch contact points relative to the tracked element.
         * @param {Number} event.lastDistance
         *      The previous distance between the two pinch contact points in CSS pixels.
         * @param {Number} event.distance
         *      The distance between the two pinch contact points in CSS pixels.
         * @param {Boolean} event.shift
         *      True if the shift key was pressed during this event.
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        pinchHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {String} event.pointerType
         *     "mouse", "touch", "pen", etc.
         * @param {OpenSeadragon.Point} event.position
         *      The position of the event relative to the tracked element.
         * @param {Number} event.buttons
         *      Current buttons pressed.
         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
         * @param {Boolean} event.isTouchEvent
         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        stopHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {Number} event.keyCode
         *      The key code that was pressed.
         * @param {Boolean} event.ctrl
         *      True if the ctrl key was pressed during this event.
         * @param {Boolean} event.shift
         *      True if the shift key was pressed during this event.
         * @param {Boolean} event.alt
         *      True if the alt key was pressed during this event.
         * @param {Boolean} event.meta
         *      True if the meta key was pressed during this event.
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Boolean} event.preventDefault
         *      Set to true to prevent the default user-agent's handling of the keydown event.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        keyDownHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {Number} event.keyCode
         *      The key code that was pressed.
         * @param {Boolean} event.ctrl
         *      True if the ctrl key was pressed during this event.
         * @param {Boolean} event.shift
         *      True if the shift key was pressed during this event.
         * @param {Boolean} event.alt
         *      True if the alt key was pressed during this event.
         * @param {Boolean} event.meta
         *      True if the meta key was pressed during this event.
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Boolean} event.preventDefault
         *      Set to true to prevent the default user-agent's handling of the keyup event.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        keyUpHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {Number} event.keyCode
         *      The key code that was pressed.
         * @param {Boolean} event.ctrl
         *      True if the ctrl key was pressed during this event.
         * @param {Boolean} event.shift
         *      True if the shift key was pressed during this event.
         * @param {Boolean} event.alt
         *      True if the alt key was pressed during this event.
         * @param {Boolean} event.meta
         *      True if the meta key was pressed during this event.
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Boolean} event.preventDefault
         *      Set to true to prevent the default user-agent's handling of the keypress event.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        keyHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        focusHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        blurHandler: function() {
        }
      };
      var i = (function() {
        try {
          return window.self !== window.top;
        } catch {
          return !0;
        }
      })();
      function r(y) {
        try {
          return y.addEventListener && y.removeEventListener;
        } catch {
          return !1;
        }
      }
      e.MouseTracker.gesturePointVelocityTracker = /* @__PURE__ */ (function() {
        var y = [], _ = 0, T = 0, S = function(te, pe) {
          return te.hash.toString() + pe.type + pe.id.toString();
        }, G = function() {
          var te, pe = y.length, Ke, Ue, oe = e.now(), _i, Gi, bi;
          for (_i = oe - T, T = oe, te = 0; te < pe; te++)
            Ke = y[te], Ue = Ke.gPoint, Ue.direction = Math.atan2(Ue.currentPos.y - Ke.lastPos.y, Ue.currentPos.x - Ke.lastPos.x), Gi = Ke.lastPos.distanceTo(Ue.currentPos), Ke.lastPos = Ue.currentPos, bi = 1e3 * Gi / (_i + 1), Ue.speed = 0.75 * bi + 0.25 * Ue.speed;
        }, Q = function(te, pe) {
          var Ke = S(te, pe);
          y.push(
            {
              guid: Ke,
              gPoint: pe,
              lastPos: pe.currentPos
            }
          ), y.length === 1 && (T = e.now(), _ = window.setInterval(G, 50));
        }, de = function(te, pe) {
          var Ke = S(te, pe), Ue, oe = y.length;
          for (Ue = 0; Ue < oe; Ue++)
            if (y[Ue].guid === Ke) {
              y.splice(Ue, 1), oe--, oe === 0 && window.clearInterval(_);
              break;
            }
        };
        return {
          addPoint: Q,
          removePoint: de
        };
      })(), e.MouseTracker.captureElement = document, e.MouseTracker.wheelEventName = "onwheel" in document.createElement("div") ? "wheel" : (
        // Modern browsers support 'wheel'
        document.onmousewheel !== void 0 ? "mousewheel" : (
          // Webkit (and unsupported IE) support at least 'mousewheel'
          "DOMMouseScroll"
        )
      ), e.MouseTracker.subscribeEvents = ["click", "dblclick", "keydown", "keyup", "keypress", "focus", "blur", "contextmenu", e.MouseTracker.wheelEventName], e.MouseTracker.wheelEventName === "DOMMouseScroll" && e.MouseTracker.subscribeEvents.push("MozMousePixelScroll"), window.PointerEvent ? (e.MouseTracker.havePointerEvents = !0, e.MouseTracker.subscribeEvents.push("pointerenter", "pointerleave", "pointerover", "pointerout", "pointerdown", "pointerup", "pointermove", "pointercancel"), e.MouseTracker.havePointerCapture = (function() {
        var y = document.createElement("div");
        return e.isFunction(y.setPointerCapture) && e.isFunction(y.releasePointerCapture);
      })(), e.MouseTracker.havePointerCapture && e.MouseTracker.subscribeEvents.push("gotpointercapture", "lostpointercapture")) : (e.MouseTracker.havePointerEvents = !1, e.MouseTracker.subscribeEvents.push("mouseenter", "mouseleave", "mouseover", "mouseout", "mousedown", "mouseup", "mousemove"), e.MouseTracker.mousePointerId = "legacy-mouse", e.MouseTracker.havePointerCapture = (function() {
        var y = document.createElement("div");
        return e.isFunction(y.setCapture) && e.isFunction(y.releaseCapture);
      })(), e.MouseTracker.havePointerCapture && e.MouseTracker.subscribeEvents.push("losecapture"), "ontouchstart" in window && e.MouseTracker.subscribeEvents.push("touchstart", "touchend", "touchmove", "touchcancel"), "ongesturestart" in window && e.MouseTracker.subscribeEvents.push("gesturestart", "gesturechange")), e.MouseTracker.GesturePointList = function(y) {
        this._gPoints = [], this.type = y, this.buttons = 0, this.contacts = 0, this.clicks = 0, this.captureCount = 0;
      }, e.MouseTracker.GesturePointList.prototype = {
        /**
         * @function
         * @returns {Number} Number of gesture points in the list.
         */
        getLength: function() {
          return this._gPoints.length;
        },
        /**
         * @function
         * @returns {Array.<OpenSeadragon.MouseTracker.GesturePoint>} The list of gesture points in the list as an array (read-only).
         */
        asArray: function() {
          return this._gPoints;
        },
        /**
         * @function
         * @param {OpenSeadragon.MouseTracker.GesturePoint} gesturePoint - A gesture point to add to the list.
         * @returns {Number} Number of gesture points in the list.
         */
        add: function(y) {
          return this._gPoints.push(y);
        },
        /**
         * @function
         * @param {Number} id - The id of the gesture point to remove from the list.
         * @returns {Number} Number of gesture points in the list.
         */
        removeById: function(y) {
          var _, T = this._gPoints.length;
          for (_ = 0; _ < T; _++)
            if (this._gPoints[_].id === y) {
              this._gPoints.splice(_, 1);
              break;
            }
          return this._gPoints.length;
        },
        /**
         * @function
         * @param {Number} index - The index of the gesture point to retrieve from the list.
         * @returns {OpenSeadragon.MouseTracker.GesturePoint|null} The gesture point at the given index, or null if not found.
         */
        getByIndex: function(y) {
          return y < this._gPoints.length ? this._gPoints[y] : null;
        },
        /**
         * @function
         * @param {Number} id - The id of the gesture point to retrieve from the list.
         * @returns {OpenSeadragon.MouseTracker.GesturePoint|null} The gesture point with the given id, or null if not found.
         */
        getById: function(y) {
          var _, T = this._gPoints.length;
          for (_ = 0; _ < T; _++)
            if (this._gPoints[_].id === y)
              return this._gPoints[_];
          return null;
        },
        /**
         * @function
         * @returns {OpenSeadragon.MouseTracker.GesturePoint|null} The primary gesture point in the list, or null if not found.
         */
        getPrimary: function(y) {
          var _, T = this._gPoints.length;
          for (_ = 0; _ < T; _++)
            if (this._gPoints[_].isPrimary)
              return this._gPoints[_];
          return null;
        },
        /**
         * Increment this pointer list's contact count.
         * It will evaluate whether this pointer type is allowed to have multiple contacts.
         * @function
         */
        addContact: function() {
          ++this.contacts, this.contacts > 1 && (this.type === "mouse" || this.type === "pen") && (e.console.warn("GesturePointList.addContact() Implausible contacts value"), this.contacts = 1);
        },
        /**
         * Decrement this pointer list's contact count.
         * It will make sure the count does not go below 0.
         * @function
         */
        removeContact: function() {
          --this.contacts, this.contacts < 0 && (this.contacts = 0);
        }
      };
      function o(y) {
        var _ = t[y.hash], T, S, G, Q, de, te = _.activePointersLists.length;
        for (T = 0; T < te; T++)
          if (G = _.activePointersLists[T], G.getLength() > 0) {
            for (de = [], Q = G.asArray(), S = 0; S < Q.length; S++)
              de.push(Q[S]);
            for (S = 0; S < de.length; S++)
              Ft(y, G, de[S]);
          }
        for (T = 0; T < te; T++)
          _.activePointersLists.pop();
        _.sentDragEvent = !1;
      }
      function a(y) {
        var _ = t[y.hash], T, S;
        if (!_.tracking) {
          for (S = 0; S < e.MouseTracker.subscribeEvents.length; S++)
            T = e.MouseTracker.subscribeEvents[S], e.addEvent(
              y.element,
              T,
              _[T],
              T === e.MouseTracker.wheelEventName ? { passive: !1, capture: !1 } : !1
            );
          o(y), _.tracking = !0;
        }
      }
      function c(y) {
        var _ = t[y.hash], T, S;
        if (_.tracking) {
          for (S = 0; S < e.MouseTracker.subscribeEvents.length; S++)
            T = e.MouseTracker.subscribeEvents[S], e.removeEvent(
              y.element,
              T,
              _[T],
              !1
            );
          o(y), _.tracking = !1;
        }
      }
      function u(y, _) {
        var T = t[y.hash];
        if (_ === "pointerevent")
          return {
            upName: "pointerup",
            upHandler: T.pointerupcaptured,
            moveName: "pointermove",
            moveHandler: T.pointermovecaptured
          };
        if (_ === "mouse")
          return {
            upName: "pointerup",
            upHandler: T.pointerupcaptured,
            moveName: "pointermove",
            moveHandler: T.pointermovecaptured
          };
        if (_ === "touch")
          return {
            upName: "touchend",
            upHandler: T.touchendcaptured,
            moveName: "touchmove",
            moveHandler: T.touchmovecaptured
          };
        throw new Error("MouseTracker.getCaptureEventParams: Unknown pointer type.");
      }
      function h(y, _) {
        var T;
        if (e.MouseTracker.havePointerCapture)
          if (e.MouseTracker.havePointerEvents)
            try {
              y.element.setPointerCapture(_.id);
            } catch {
              e.console.warn("setPointerCapture() called on invalid pointer ID");
              return;
            }
          else
            y.element.setCapture(!0);
        else
          T = u(y, e.MouseTracker.havePointerEvents ? "pointerevent" : _.type), i && r(window.top) && e.addEvent(
            window.top,
            T.upName,
            T.upHandler,
            !0
          ), e.addEvent(
            e.MouseTracker.captureElement,
            T.upName,
            T.upHandler,
            !0
          ), e.addEvent(
            e.MouseTracker.captureElement,
            T.moveName,
            T.moveHandler,
            !0
          );
        W(y, _, !0);
      }
      function f(y, _) {
        var T, S, G;
        if (e.MouseTracker.havePointerCapture)
          if (e.MouseTracker.havePointerEvents) {
            if (S = y.getActivePointersListByType(_.type), G = S.getById(_.id), !G || !G.captured)
              return;
            try {
              y.element.releasePointerCapture(_.id);
            } catch {
            }
          } else
            y.element.releaseCapture();
        else
          T = u(y, e.MouseTracker.havePointerEvents ? "pointerevent" : _.type), i && r(window.top) && e.removeEvent(
            window.top,
            T.upName,
            T.upHandler,
            !0
          ), e.removeEvent(
            e.MouseTracker.captureElement,
            T.moveName,
            T.moveHandler,
            !0
          ), e.removeEvent(
            e.MouseTracker.captureElement,
            T.upName,
            T.upHandler,
            !0
          );
        W(y, _, !1);
      }
      function g(y) {
        return e.MouseTracker.havePointerEvents ? y.pointerId : e.MouseTracker.mousePointerId;
      }
      function x(y) {
        return e.MouseTracker.havePointerEvents && y.pointerType ? y.pointerType : "mouse";
      }
      function C(y) {
        return e.MouseTracker.havePointerEvents ? y.isPrimary : !0;
      }
      function E(y) {
        return e.getMousePosition(y);
      }
      function R(y, _) {
        return D(E(y), _);
      }
      function D(y, _) {
        var T = e.getElementOffset(_);
        return y.minus(T);
      }
      function U(y, _) {
        return new e.Point((y.x + _.x) / 2, (y.y + _.y) / 2);
      }
      function Z(y, _) {
        var T = {
          originalEvent: _,
          eventType: "click",
          pointerType: "mouse",
          isEmulated: !1
        };
        P(y, T), T.preventDefault && !T.defaultPrevented && e.cancelEvent(_), T.stopPropagation && e.stopEvent(_);
      }
      function ce(y, _) {
        var T = {
          originalEvent: _,
          eventType: "dblclick",
          pointerType: "mouse",
          isEmulated: !1
        };
        P(y, T), T.preventDefault && !T.defaultPrevented && e.cancelEvent(_), T.stopPropagation && e.stopEvent(_);
      }
      function re(y, _) {
        var T = null, S = {
          originalEvent: _,
          eventType: "keydown",
          pointerType: "",
          isEmulated: !1
        };
        P(y, S), y.keyDownHandler && !S.preventGesture && !S.defaultPrevented && (T = {
          eventSource: y,
          keyCode: _.keyCode ? _.keyCode : _.charCode,
          ctrl: _.ctrlKey,
          shift: _.shiftKey,
          alt: _.altKey,
          meta: _.metaKey,
          originalEvent: _,
          preventDefault: S.preventDefault || S.defaultPrevented,
          userData: y.userData
        }, y.keyDownHandler(T)), (T && T.preventDefault || S.preventDefault && !S.defaultPrevented) && e.cancelEvent(_), S.stopPropagation && e.stopEvent(_);
      }
      function ue(y, _) {
        var T = null, S = {
          originalEvent: _,
          eventType: "keyup",
          pointerType: "",
          isEmulated: !1
        };
        P(y, S), y.keyUpHandler && !S.preventGesture && !S.defaultPrevented && (T = {
          eventSource: y,
          keyCode: _.keyCode ? _.keyCode : _.charCode,
          ctrl: _.ctrlKey,
          shift: _.shiftKey,
          alt: _.altKey,
          meta: _.metaKey,
          originalEvent: _,
          preventDefault: S.preventDefault || S.defaultPrevented,
          userData: y.userData
        }, y.keyUpHandler(T)), (T && T.preventDefault || S.preventDefault && !S.defaultPrevented) && e.cancelEvent(_), S.stopPropagation && e.stopEvent(_);
      }
      function me(y, _) {
        var T = null, S = {
          originalEvent: _,
          eventType: "keypress",
          pointerType: "",
          isEmulated: !1
        };
        P(y, S), y.keyHandler && !S.preventGesture && !S.defaultPrevented && (T = {
          eventSource: y,
          keyCode: _.keyCode ? _.keyCode : _.charCode,
          ctrl: _.ctrlKey,
          shift: _.shiftKey,
          alt: _.altKey,
          meta: _.metaKey,
          originalEvent: _,
          preventDefault: S.preventDefault || S.defaultPrevented,
          userData: y.userData
        }, y.keyHandler(T)), (T && T.preventDefault || S.preventDefault && !S.defaultPrevented) && e.cancelEvent(_), S.stopPropagation && e.stopEvent(_);
      }
      function Te(y, _) {
        var T = {
          originalEvent: _,
          eventType: "focus",
          pointerType: "",
          isEmulated: !1
        };
        P(y, T), y.focusHandler && !T.preventGesture && y.focusHandler(
          {
            eventSource: y,
            originalEvent: _,
            userData: y.userData
          }
        );
      }
      function Re(y, _) {
        var T = {
          originalEvent: _,
          eventType: "blur",
          pointerType: "",
          isEmulated: !1
        };
        P(y, T), y.blurHandler && !T.preventGesture && y.blurHandler(
          {
            eventSource: y,
            originalEvent: _,
            userData: y.userData
          }
        );
      }
      function He(y, _) {
        var T = null, S = {
          originalEvent: _,
          eventType: "contextmenu",
          pointerType: "mouse",
          isEmulated: !1
        };
        P(y, S), y.contextMenuHandler && !S.preventGesture && !S.defaultPrevented && (T = {
          eventSource: y,
          position: D(E(_), y.element),
          originalEvent: S.originalEvent,
          preventDefault: S.preventDefault || S.defaultPrevented,
          userData: y.userData
        }, y.contextMenuHandler(T)), (T && T.preventDefault || S.preventDefault && !S.defaultPrevented) && e.cancelEvent(_), S.stopPropagation && e.stopEvent(_);
      }
      function Fe(y, _) {
        Ae(y, _, _);
      }
      function _e(y, _) {
        var T = {
          target: _.target || _.srcElement,
          type: "wheel",
          shiftKey: _.shiftKey || !1,
          clientX: _.clientX,
          clientY: _.clientY,
          pageX: _.pageX ? _.pageX : _.clientX,
          pageY: _.pageY ? _.pageY : _.clientY,
          deltaMode: _.type === "MozMousePixelScroll" ? 0 : 1,
          // 0=pixel, 1=line, 2=page
          deltaX: 0,
          deltaZ: 0
        };
        e.MouseTracker.wheelEventName === "mousewheel" ? T.deltaY = -_.wheelDelta / e.DEFAULT_SETTINGS.pixelsPerWheelLine : T.deltaY = _.detail, Ae(y, T, _);
      }
      function Ae(y, _, T) {
        var S = 0, G, Q = null;
        S = _.deltaY ? _.deltaY < 0 ? 1 : -1 : 0, G = {
          originalEvent: _,
          eventType: "wheel",
          pointerType: "mouse",
          isEmulated: _ !== T
        }, P(y, G), y.scrollHandler && !G.preventGesture && !G.defaultPrevented && (Q = {
          eventSource: y,
          pointerType: "mouse",
          position: R(_, y.element),
          scroll: S,
          shift: _.shiftKey,
          isTouchEvent: !1,
          originalEvent: T,
          preventDefault: G.preventDefault || G.defaultPrevented,
          userData: y.userData
        }, y.scrollHandler(Q)), G.stopPropagation && e.stopEvent(T), (Q && Q.preventDefault || G.preventDefault && !G.defaultPrevented) && e.cancelEvent(T);
      }
      function Je(y, _) {
        var T = {
          id: e.MouseTracker.mousePointerId,
          type: "mouse"
        }, S = {
          originalEvent: _,
          eventType: "lostpointercapture",
          pointerType: "mouse",
          isEmulated: !1
        };
        P(y, S), _.target === y.element && W(y, T, !1), S.stopPropagation && e.stopEvent(_);
      }
      function Ge(y, _) {
        var T, S, G = _.changedTouches.length, Q, de = y.getActivePointersListByType("touch");
        T = e.now(), de.getLength() > _.touches.length - G && e.console.warn("Tracked touch contact count doesn't match event.touches.length");
        var te = {
          originalEvent: _,
          eventType: "pointerdown",
          pointerType: "touch",
          isEmulated: !1
        };
        for (P(y, te), S = 0; S < G; S++)
          Q = {
            id: _.changedTouches[S].identifier,
            type: "touch",
            // Simulate isPrimary
            isPrimary: de.getLength() === 0,
            currentPos: E(_.changedTouches[S]),
            currentTime: T
          }, X(y, te, Q), ve(y, te, Q, 0), W(y, Q, !0);
        te.preventDefault && !te.defaultPrevented && e.cancelEvent(_), te.stopPropagation && e.stopEvent(_);
      }
      function qe(y, _) {
        var T, S, G = _.changedTouches.length, Q;
        T = e.now();
        var de = {
          originalEvent: _,
          eventType: "pointerup",
          pointerType: "touch",
          isEmulated: !1
        };
        for (P(y, de), S = 0; S < G; S++)
          Q = {
            id: _.changedTouches[S].identifier,
            type: "touch",
            currentPos: E(_.changedTouches[S]),
            currentTime: T
          }, Ce(y, de, Q, 0), W(y, Q, !1), $(y, de, Q);
        de.preventDefault && !de.defaultPrevented && e.cancelEvent(_), de.stopPropagation && e.stopEvent(_);
      }
      function nt(y, _) {
        var T, S, G = _.changedTouches.length, Q;
        T = e.now();
        var de = {
          originalEvent: _,
          eventType: "pointermove",
          pointerType: "touch",
          isEmulated: !1
        };
        for (P(y, de), S = 0; S < G; S++)
          Q = {
            id: _.changedTouches[S].identifier,
            type: "touch",
            currentPos: E(_.changedTouches[S]),
            currentTime: T
          }, Se(y, de, Q);
        de.preventDefault && !de.defaultPrevented && e.cancelEvent(_), de.stopPropagation && e.stopEvent(_);
      }
      function Ve(y, _) {
        var T = _.changedTouches.length, S, G, Q = {
          originalEvent: _,
          eventType: "pointercancel",
          pointerType: "touch",
          isEmulated: !1
        };
        for (P(y, Q), S = 0; S < T; S++)
          G = {
            id: _.changedTouches[S].identifier,
            type: "touch"
          }, ge(y, Q, G);
        Q.stopPropagation && e.stopEvent(_);
      }
      function ot(y, _) {
        return e.eventIsCanceled(_) || _.preventDefault(), !1;
      }
      function $e(y, _) {
        return e.eventIsCanceled(_) || _.preventDefault(), !1;
      }
      function Yt(y, _) {
        var T = {
          originalEvent: _,
          eventType: "gotpointercapture",
          pointerType: x(_),
          isEmulated: !1
        };
        P(y, T), _.target === y.element && W(y, {
          id: _.pointerId,
          type: x(_)
        }, !0), T.stopPropagation && e.stopEvent(_);
      }
      function Wi(y, _) {
        var T = {
          originalEvent: _,
          eventType: "lostpointercapture",
          pointerType: x(_),
          isEmulated: !1
        };
        P(y, T), _.target === y.element && W(y, {
          id: _.pointerId,
          type: x(_)
        }, !1), T.stopPropagation && e.stopEvent(_);
      }
      function be(y, _) {
        var T = {
          id: g(_),
          type: x(_),
          isPrimary: C(_),
          currentPos: E(_),
          currentTime: e.now()
        }, S = {
          originalEvent: _,
          eventType: "pointerenter",
          pointerType: T.type,
          isEmulated: !1
        };
        P(y, S), X(y, S, T);
      }
      function Xt(y, _) {
        var T = {
          id: g(_),
          type: x(_),
          isPrimary: C(_),
          currentPos: E(_),
          currentTime: e.now()
        }, S = {
          originalEvent: _,
          eventType: "pointerleave",
          pointerType: T.type,
          isEmulated: !1
        };
        P(y, S), $(y, S, T);
      }
      function St(y, _) {
        var T = {
          id: g(_),
          type: x(_),
          isPrimary: C(_),
          currentPos: E(_),
          currentTime: e.now()
        }, S = {
          originalEvent: _,
          eventType: "pointerover",
          pointerType: T.type,
          isEmulated: !1
        };
        P(y, S), he(y, S, T), S.preventDefault && !S.defaultPrevented && e.cancelEvent(_), S.stopPropagation && e.stopEvent(_);
      }
      function _t(y, _) {
        var T = {
          id: g(_),
          type: x(_),
          isPrimary: C(_),
          currentPos: E(_),
          currentTime: e.now()
        }, S = {
          originalEvent: _,
          eventType: "pointerout",
          pointerType: T.type,
          isEmulated: !1
        };
        P(y, S), Y(y, S, T), S.preventDefault && !S.defaultPrevented && e.cancelEvent(_), S.stopPropagation && e.stopEvent(_);
      }
      function xt(y, _) {
        var T = {
          id: g(_),
          type: x(_),
          isPrimary: C(_),
          currentPos: E(_),
          currentTime: e.now()
        }, S = e.MouseTracker.havePointerEvents && T.type === "touch", G = {
          originalEvent: _,
          eventType: "pointerdown",
          pointerType: T.type,
          isEmulated: !1
        };
        P(y, G), ve(y, G, T, _.button), G.preventDefault && !G.defaultPrevented && e.cancelEvent(_), G.stopPropagation && e.stopEvent(_), G.shouldCapture && (S ? W(y, T, !0) : h(y, T));
      }
      function vi(y, _) {
        Qt(y, _);
      }
      function fe(y, _) {
        var T = y.getActivePointersListByType(x(_));
        T.getById(_.pointerId) && Qt(y, _), e.stopEvent(_);
      }
      function Qt(y, _) {
        var T;
        T = {
          id: g(_),
          type: x(_),
          isPrimary: C(_),
          currentPos: E(_),
          currentTime: e.now()
        };
        var S = {
          originalEvent: _,
          eventType: "pointerup",
          pointerType: T.type,
          isEmulated: !1
        };
        P(y, S), Ce(y, S, T, _.button), S.preventDefault && !S.defaultPrevented && e.cancelEvent(_), S.stopPropagation && e.stopEvent(_), S.shouldReleaseCapture && (_.target === y.element ? f(y, T) : W(y, T, !1));
      }
      function kt(y, _) {
        Ct(y, _);
      }
      function Ie(y, _) {
        var T = y.getActivePointersListByType(x(_));
        T.getById(_.pointerId) && Ct(y, _), e.stopEvent(_);
      }
      function Ct(y, _) {
        var T = {
          id: g(_),
          type: x(_),
          isPrimary: C(_),
          currentPos: E(_),
          currentTime: e.now()
        }, S = {
          originalEvent: _,
          eventType: "pointermove",
          pointerType: T.type,
          isEmulated: !1
        };
        P(y, S), Se(y, S, T), S.preventDefault && !S.defaultPrevented && e.cancelEvent(_), S.stopPropagation && e.stopEvent(_);
      }
      function ji(y, _) {
        var T = {
          id: _.pointerId,
          type: x(_)
        }, S = {
          originalEvent: _,
          eventType: "pointercancel",
          pointerType: T.type,
          isEmulated: !1
        };
        P(y, S), ge(y, S, T), S.stopPropagation && e.stopEvent(_);
      }
      function ft(y, _) {
        return _.speed = 0, _.direction = 0, _.contactPos = _.currentPos, _.contactTime = _.currentTime, _.lastPos = _.currentPos, _.lastTime = _.currentTime, y.add(_);
      }
      function Ft(y, _, T) {
        var S, G = _.getById(T.id);
        return G ? (G.captured && (e.console.warn("stopTrackingPointer() called on captured pointer"), f(y, G)), _.removeContact(), S = _.removeById(T.id)) : S = _.getLength(), S;
      }
      function v(y, _) {
        switch (_.eventType) {
          case "pointermove":
            _.isStoppable = !0, _.isCancelable = !0, _.preventDefault = !1, _.preventGesture = !y.hasGestureHandlers, _.stopPropagation = !1;
            break;
          case "pointerover":
          case "pointerout":
          case "contextmenu":
          case "keydown":
          case "keyup":
          case "keypress":
            _.isStoppable = !0, _.isCancelable = !0, _.preventDefault = !1, _.preventGesture = !1, _.stopPropagation = !1;
            break;
          case "pointerdown":
            _.isStoppable = !0, _.isCancelable = !0, _.preventDefault = !1, _.preventGesture = !y.hasGestureHandlers, _.stopPropagation = !1;
            break;
          case "pointerup":
            _.isStoppable = !0, _.isCancelable = !0, _.preventDefault = !1, _.preventGesture = !y.hasGestureHandlers, _.stopPropagation = !1;
            break;
          case "wheel":
            _.isStoppable = !0, _.isCancelable = !0, _.preventDefault = !1, _.preventGesture = !y.hasScrollHandler, _.stopPropagation = !1;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
            _.isStoppable = !0, _.isCancelable = !1, _.preventDefault = !1, _.preventGesture = !1, _.stopPropagation = !1;
            break;
          case "click":
            _.isStoppable = !0, _.isCancelable = !0, _.preventDefault = !!y.clickHandler, _.preventGesture = !1, _.stopPropagation = !1;
            break;
          case "dblclick":
            _.isStoppable = !0, _.isCancelable = !0, _.preventDefault = !!y.dblClickHandler, _.preventGesture = !1, _.stopPropagation = !1;
            break;
          case "focus":
          case "blur":
          case "pointerenter":
          case "pointerleave":
          default:
            _.isStoppable = !1, _.isCancelable = !1, _.preventDefault = !1, _.preventGesture = !1, _.stopPropagation = !1;
            break;
        }
      }
      function P(y, _) {
        _.eventSource = y, _.eventPhase = _.originalEvent && typeof _.originalEvent.eventPhase < "u" ? _.originalEvent.eventPhase : 0, _.defaultPrevented = e.eventIsCanceled(_.originalEvent), _.shouldCapture = !1, _.shouldReleaseCapture = !1, _.userData = y.userData, v(y, _), y.preProcessEventHandler && y.preProcessEventHandler(_);
      }
      function W(y, _, T) {
        var S = y.getActivePointersListByType(_.type), G = S.getById(_.id);
        G ? T && !G.captured ? (G.captured = !0, S.captureCount++) : !T && G.captured && (G.captured = !1, S.captureCount--, S.captureCount < 0 && (S.captureCount = 0, e.console.warn("updatePointerCaptured() - pointsList.captureCount went negative"))) : e.console.warn("updatePointerCaptured() called on untracked pointer");
      }
      function X(y, _, T) {
        var S = y.getActivePointersListByType(T.type), G;
        G = S.getById(T.id), G ? (G.insideElement = !0, G.lastPos = G.currentPos, G.lastTime = G.currentTime, G.currentPos = T.currentPos, G.currentTime = T.currentTime, T = G) : (T.captured = !1, T.insideElementPressed = !1, T.insideElement = !0, ft(S, T)), y.enterHandler && y.enterHandler(
          {
            eventSource: y,
            pointerType: T.type,
            position: D(T.currentPos, y.element),
            buttons: S.buttons,
            pointers: y.getActivePointerCount(),
            insideElementPressed: T.insideElementPressed,
            buttonDownAny: S.buttons !== 0,
            isTouchEvent: T.type === "touch",
            originalEvent: _.originalEvent,
            userData: y.userData
          }
        );
      }
      function $(y, _, T) {
        var S = y.getActivePointersListByType(T.type), G, Q;
        G = S.getById(T.id), G ? (G.captured ? (G.insideElement = !1, G.lastPos = G.currentPos, G.lastTime = G.currentTime, G.currentPos = T.currentPos, G.currentTime = T.currentTime) : Ft(y, S, G), T = G) : (T.captured = !1, T.insideElementPressed = !1), (y.leaveHandler || y.exitHandler) && (Q = {
          eventSource: y,
          pointerType: T.type,
          // GitHub PR: https://github.com/openseadragon/openseadragon/pull/1754 (gPoint.currentPos && )
          position: T.currentPos && D(T.currentPos, y.element),
          buttons: S.buttons,
          pointers: y.getActivePointerCount(),
          insideElementPressed: T.insideElementPressed,
          buttonDownAny: S.buttons !== 0,
          isTouchEvent: T.type === "touch",
          originalEvent: _.originalEvent,
          userData: y.userData
        }, y.leaveHandler && y.leaveHandler(Q), y.exitHandler && y.exitHandler(Q));
      }
      function he(y, _, T) {
        var S, G;
        S = y.getActivePointersListByType(T.type), G = S.getById(T.id), G ? T = G : (T.captured = !1, T.insideElementPressed = !1), y.overHandler && y.overHandler(
          {
            eventSource: y,
            pointerType: T.type,
            position: D(T.currentPos, y.element),
            buttons: S.buttons,
            pointers: y.getActivePointerCount(),
            insideElementPressed: T.insideElementPressed,
            buttonDownAny: S.buttons !== 0,
            isTouchEvent: T.type === "touch",
            originalEvent: _.originalEvent,
            userData: y.userData
          }
        );
      }
      function Y(y, _, T) {
        var S, G;
        S = y.getActivePointersListByType(T.type), G = S.getById(T.id), G ? T = G : (T.captured = !1, T.insideElementPressed = !1), y.outHandler && y.outHandler({
          eventSource: y,
          pointerType: T.type,
          position: T.currentPos && D(T.currentPos, y.element),
          buttons: S.buttons,
          pointers: y.getActivePointerCount(),
          insideElementPressed: T.insideElementPressed,
          buttonDownAny: S.buttons !== 0,
          isTouchEvent: T.type === "touch",
          originalEvent: _.originalEvent,
          userData: y.userData
        });
      }
      function ve(y, _, T, S) {
        var G = t[y.hash], Q = y.getActivePointersListByType(T.type), de;
        if (typeof _.originalEvent.buttons < "u" ? Q.buttons = _.originalEvent.buttons : S === 0 ? Q.buttons |= 1 : S === 1 ? Q.buttons |= 4 : S === 2 ? Q.buttons |= 2 : S === 3 ? Q.buttons |= 8 : S === 4 ? Q.buttons |= 16 : S === 5 && (Q.buttons |= 32), S !== 0) {
          _.shouldCapture = !1, _.shouldReleaseCapture = !1, y.nonPrimaryPressHandler && !_.preventGesture && !_.defaultPrevented && (_.preventDefault = !0, y.nonPrimaryPressHandler(
            {
              eventSource: y,
              pointerType: T.type,
              position: D(T.currentPos, y.element),
              button: S,
              buttons: Q.buttons,
              isTouchEvent: T.type === "touch",
              originalEvent: _.originalEvent,
              userData: y.userData
            }
          ));
          return;
        }
        de = Q.getById(T.id), de ? (de.insideElementPressed = !0, de.insideElement = !0, de.originalTarget = _.originalEvent.target, de.contactPos = T.currentPos, de.contactTime = T.currentTime, de.lastPos = de.currentPos, de.lastTime = de.currentTime, de.currentPos = T.currentPos, de.currentTime = T.currentTime, T = de) : (T.captured = !1, T.insideElementPressed = !0, T.insideElement = !0, T.originalTarget = _.originalEvent.target, ft(Q, T)), Q.addContact(), !_.preventGesture && !_.defaultPrevented ? (_.shouldCapture = !0, _.shouldReleaseCapture = !1, _.preventDefault = !0, (y.dragHandler || y.dragEndHandler || y.pinchHandler) && e.MouseTracker.gesturePointVelocityTracker.addPoint(y, T), Q.contacts === 1 ? y.pressHandler && !_.preventGesture && y.pressHandler(
          {
            eventSource: y,
            pointerType: T.type,
            position: D(T.contactPos, y.element),
            buttons: Q.buttons,
            isTouchEvent: T.type === "touch",
            originalEvent: _.originalEvent,
            userData: y.userData
          }
        ) : Q.contacts === 2 && y.pinchHandler && T.type === "touch" && (G.pinchGPoints = Q.asArray(), G.lastPinchDist = G.currentPinchDist = G.pinchGPoints[0].currentPos.distanceTo(G.pinchGPoints[1].currentPos), G.lastPinchCenter = G.currentPinchCenter = U(G.pinchGPoints[0].currentPos, G.pinchGPoints[1].currentPos))) : (_.shouldCapture = !1, _.shouldReleaseCapture = !1);
      }
      function Ce(y, _, T, S) {
        var G = t[y.hash], Q = y.getActivePointersListByType(T.type), de, te, pe, Ke = !1, Ue;
        if (typeof _.originalEvent.buttons < "u" ? Q.buttons = _.originalEvent.buttons : S === 0 ? Q.buttons ^= -2 : S === 1 ? Q.buttons ^= -5 : S === 2 ? Q.buttons ^= -3 : S === 3 ? Q.buttons ^= -9 : S === 4 ? Q.buttons ^= -17 : S === 5 && (Q.buttons ^= -33), _.shouldCapture = !1, S !== 0) {
          _.shouldReleaseCapture = !1, y.nonPrimaryReleaseHandler && !_.preventGesture && !_.defaultPrevented && (_.preventDefault = !0, y.nonPrimaryReleaseHandler(
            {
              eventSource: y,
              pointerType: T.type,
              position: D(T.currentPos, y.element),
              button: S,
              buttons: Q.buttons,
              isTouchEvent: T.type === "touch",
              originalEvent: _.originalEvent,
              userData: y.userData
            }
          ));
          return;
        }
        pe = Q.getById(T.id), pe ? (Q.removeContact(), pe.captured && (Ke = !0), pe.lastPos = pe.currentPos, pe.lastTime = pe.currentTime, pe.currentPos = T.currentPos, pe.currentTime = T.currentTime, pe.insideElement || Ft(y, Q, pe), de = pe.currentPos, te = pe.currentTime) : (T.captured = !1, T.insideElementPressed = !1, T.insideElement = !0, ft(Q, T), pe = T), !_.preventGesture && !_.defaultPrevented && (Ke ? (_.shouldReleaseCapture = !0, _.preventDefault = !0, (y.dragHandler || y.dragEndHandler || y.pinchHandler) && e.MouseTracker.gesturePointVelocityTracker.removePoint(y, pe), Q.contacts === 0 ? (y.releaseHandler && de && y.releaseHandler(
          {
            eventSource: y,
            pointerType: pe.type,
            position: D(de, y.element),
            buttons: Q.buttons,
            insideElementPressed: pe.insideElementPressed,
            insideElementReleased: pe.insideElement,
            isTouchEvent: pe.type === "touch",
            originalEvent: _.originalEvent,
            userData: y.userData
          }
        ), y.dragEndHandler && G.sentDragEvent && y.dragEndHandler(
          {
            eventSource: y,
            pointerType: pe.type,
            position: D(pe.currentPos, y.element),
            speed: pe.speed,
            direction: pe.direction,
            shift: _.originalEvent.shiftKey,
            isTouchEvent: pe.type === "touch",
            originalEvent: _.originalEvent,
            userData: y.userData
          }
        ), G.sentDragEvent = !1, (y.clickHandler || y.dblClickHandler) && pe.insideElement && (Ue = te - pe.contactTime <= y.clickTimeThreshold && pe.contactPos.distanceTo(de) <= y.clickDistThreshold, y.clickHandler && y.clickHandler(
          {
            eventSource: y,
            pointerType: pe.type,
            position: D(pe.currentPos, y.element),
            quick: Ue,
            shift: _.originalEvent.shiftKey,
            isTouchEvent: pe.type === "touch",
            originalEvent: _.originalEvent,
            originalTarget: pe.originalTarget,
            userData: y.userData
          }
        ), y.dblClickHandler && Ue && (Q.clicks++, Q.clicks === 1 ? (G.lastClickPos = de, G.dblClickTimeOut = setTimeout(function() {
          Q.clicks = 0;
        }, y.dblClickTimeThreshold)) : Q.clicks === 2 && (clearTimeout(G.dblClickTimeOut), Q.clicks = 0, G.lastClickPos.distanceTo(de) <= y.dblClickDistThreshold && y.dblClickHandler(
          {
            eventSource: y,
            pointerType: pe.type,
            position: D(pe.currentPos, y.element),
            shift: _.originalEvent.shiftKey,
            isTouchEvent: pe.type === "touch",
            originalEvent: _.originalEvent,
            userData: y.userData
          }
        ), G.lastClickPos = null)))) : Q.contacts === 2 && y.pinchHandler && pe.type === "touch" && (G.pinchGPoints = Q.asArray(), G.lastPinchDist = G.currentPinchDist = G.pinchGPoints[0].currentPos.distanceTo(G.pinchGPoints[1].currentPos), G.lastPinchCenter = G.currentPinchCenter = U(G.pinchGPoints[0].currentPos, G.pinchGPoints[1].currentPos))) : (_.shouldReleaseCapture = !1, y.releaseHandler && de && (y.releaseHandler(
          {
            eventSource: y,
            pointerType: pe.type,
            position: D(de, y.element),
            buttons: Q.buttons,
            insideElementPressed: pe.insideElementPressed,
            insideElementReleased: pe.insideElement,
            isTouchEvent: pe.type === "touch",
            originalEvent: _.originalEvent,
            userData: y.userData
          }
        ), _.preventDefault = !0)));
      }
      function Se(y, _, T) {
        var S = t[y.hash], G = y.getActivePointersListByType(T.type), Q, de, te;
        if (typeof _.originalEvent.buttons < "u" && (G.buttons = _.originalEvent.buttons), Q = G.getById(T.id), Q)
          Q.lastPos = Q.currentPos, Q.lastTime = Q.currentTime, Q.currentPos = T.currentPos, Q.currentTime = T.currentTime;
        else
          return;
        _.shouldCapture = !1, _.shouldReleaseCapture = !1, y.stopHandler && T.type === "mouse" && (clearTimeout(y.stopTimeOut), y.stopTimeOut = setTimeout(function() {
          Le(y, _.originalEvent, T.type);
        }, y.stopDelay)), G.contacts === 0 ? y.moveHandler && y.moveHandler(
          {
            eventSource: y,
            pointerType: T.type,
            position: D(T.currentPos, y.element),
            buttons: G.buttons,
            isTouchEvent: T.type === "touch",
            originalEvent: _.originalEvent,
            userData: y.userData
          }
        ) : G.contacts === 1 ? (y.moveHandler && (Q = G.asArray()[0], y.moveHandler(
          {
            eventSource: y,
            pointerType: Q.type,
            position: D(Q.currentPos, y.element),
            buttons: G.buttons,
            isTouchEvent: Q.type === "touch",
            originalEvent: _.originalEvent,
            userData: y.userData
          }
        )), y.dragHandler && !_.preventGesture && !_.defaultPrevented && (Q = G.asArray()[0], te = Q.currentPos.minus(Q.lastPos), y.dragHandler(
          {
            eventSource: y,
            pointerType: Q.type,
            position: D(Q.currentPos, y.element),
            buttons: G.buttons,
            delta: te,
            speed: Q.speed,
            direction: Q.direction,
            shift: _.originalEvent.shiftKey,
            isTouchEvent: Q.type === "touch",
            originalEvent: _.originalEvent,
            userData: y.userData
          }
        ), _.preventDefault = !0, S.sentDragEvent = !0)) : G.contacts === 2 && (y.moveHandler && (de = G.asArray(), y.moveHandler(
          {
            eventSource: y,
            pointerType: de[0].type,
            position: D(U(de[0].currentPos, de[1].currentPos), y.element),
            buttons: G.buttons,
            isTouchEvent: de[0].type === "touch",
            originalEvent: _.originalEvent,
            userData: y.userData
          }
        )), y.pinchHandler && T.type === "touch" && !_.preventGesture && !_.defaultPrevented && (te = S.pinchGPoints[0].currentPos.distanceTo(S.pinchGPoints[1].currentPos), te !== S.currentPinchDist && (S.lastPinchDist = S.currentPinchDist, S.currentPinchDist = te, S.lastPinchCenter = S.currentPinchCenter, S.currentPinchCenter = U(S.pinchGPoints[0].currentPos, S.pinchGPoints[1].currentPos), y.pinchHandler(
          {
            eventSource: y,
            pointerType: "touch",
            gesturePoints: S.pinchGPoints,
            lastCenter: D(S.lastPinchCenter, y.element),
            center: D(S.currentPinchCenter, y.element),
            lastDistance: S.lastPinchDist,
            distance: S.currentPinchDist,
            shift: _.originalEvent.shiftKey,
            originalEvent: _.originalEvent,
            userData: y.userData
          }
        ), _.preventDefault = !0)));
      }
      function ge(y, _, T) {
        var S = y.getActivePointersListByType(T.type), G;
        G = S.getById(T.id), G && Ft(y, S, G);
      }
      function Le(y, _, T) {
        y.stopHandler && y.stopHandler({
          eventSource: y,
          pointerType: T,
          position: R(_, y.element),
          buttons: y.getActivePointersListByType(T).buttons,
          isTouchEvent: T === "touch",
          originalEvent: _,
          userData: y.userData
        });
      }
    })(n), (function(e) {
      e.ControlAnchor = {
        NONE: 0,
        TOP_LEFT: 1,
        TOP_RIGHT: 2,
        BOTTOM_RIGHT: 3,
        BOTTOM_LEFT: 4,
        ABSOLUTE: 5
      }, e.Control = function(t, i, r) {
        var o = t.parentNode;
        typeof i == "number" && (e.console.error("Passing an anchor directly into the OpenSeadragon.Control constructor is deprecated; please use an options object instead.  Support for this deprecated variant is scheduled for removal in December 2013"), i = { anchor: i }), i.attachToViewer = typeof i.attachToViewer > "u" ? !0 : i.attachToViewer, this.autoFade = typeof i.autoFade > "u" ? !0 : i.autoFade, this.element = t, this.anchor = i.anchor, this.container = r, this.anchor === e.ControlAnchor.ABSOLUTE ? (this.wrapper = e.makeNeutralElement("div"), this.wrapper.style.position = "absolute", this.wrapper.style.top = typeof i.top == "number" ? i.top + "px" : i.top, this.wrapper.style.left = typeof i.left == "number" ? i.left + "px" : i.left, this.wrapper.style.height = typeof i.height == "number" ? i.height + "px" : i.height, this.wrapper.style.width = typeof i.width == "number" ? i.width + "px" : i.width, this.wrapper.style.margin = "0px", this.wrapper.style.padding = "0px", this.element.style.position = "relative", this.element.style.top = "0px", this.element.style.left = "0px", this.element.style.height = "100%", this.element.style.width = "100%") : (this.wrapper = e.makeNeutralElement("div"), this.wrapper.style.display = "inline-block", this.anchor === e.ControlAnchor.NONE && (this.wrapper.style.width = this.wrapper.style.height = "100%")), this.wrapper.appendChild(this.element), i.attachToViewer ? this.anchor === e.ControlAnchor.TOP_RIGHT || this.anchor === e.ControlAnchor.BOTTOM_RIGHT ? this.container.insertBefore(
          this.wrapper,
          this.container.firstChild
        ) : this.container.appendChild(this.wrapper) : o.appendChild(this.wrapper);
      }, e.Control.prototype = {
        /**
         * Removes the control from the container.
         * @function
         */
        destroy: function() {
          this.wrapper.removeChild(this.element), this.anchor !== e.ControlAnchor.NONE && this.container.removeChild(this.wrapper);
        },
        /**
         * Determines if the control is currently visible.
         * @function
         * @returns {Boolean} true if currently visible, false otherwise.
         */
        isVisible: function() {
          return this.wrapper.style.display !== "none";
        },
        /**
         * Toggles the visibility of the control.
         * @function
         * @param {Boolean} visible - true to make visible, false to hide.
         */
        setVisible: function(t) {
          this.wrapper.style.display = t ? this.anchor === e.ControlAnchor.ABSOLUTE ? "block" : "inline-block" : "none";
        },
        /**
         * Sets the opacity level for the control.
         * @function
         * @param {Number} opactiy - a value between 1 and 0 inclusively.
         */
        setOpacity: function(t) {
          e.setElementOpacity(this.wrapper, t, !0);
        }
      };
    })(n), (function(e) {
      e.ControlDock = function(i) {
        var r = ["topleft", "topright", "bottomright", "bottomleft"], o, a;
        for (e.extend(!0, this, {
          id: "controldock-" + e.now() + "-" + Math.floor(Math.random() * 1e6),
          container: e.makeNeutralElement("div"),
          controls: []
        }, i), this.container.onsubmit = function() {
          return !1;
        }, this.element && (this.element = e.getElement(this.element), this.element.appendChild(this.container), e.getElementStyle(this.element).position === "static" && (this.element.style.position = "relative"), this.container.style.width = "100%", this.container.style.height = "100%"), a = 0; a < r.length; a++)
          o = r[a], this.controls[o] = e.makeNeutralElement("div"), this.controls[o].style.position = "absolute", o.match("left") && (this.controls[o].style.left = "0px"), o.match("right") && (this.controls[o].style.right = "0px"), o.match("top") && (this.controls[o].style.top = "0px"), o.match("bottom") && (this.controls[o].style.bottom = "0px");
        this.container.appendChild(this.controls.topleft), this.container.appendChild(this.controls.topright), this.container.appendChild(this.controls.bottomright), this.container.appendChild(this.controls.bottomleft);
      }, e.ControlDock.prototype = {
        /**
         * @function
         */
        addControl: function(i, r) {
          i = e.getElement(i);
          var o = null;
          if (!(t(this, i) >= 0)) {
            switch (r.anchor) {
              case e.ControlAnchor.TOP_RIGHT:
                o = this.controls.topright, i.style.position = "relative", i.style.paddingRight = "0px", i.style.paddingTop = "0px";
                break;
              case e.ControlAnchor.BOTTOM_RIGHT:
                o = this.controls.bottomright, i.style.position = "relative", i.style.paddingRight = "0px", i.style.paddingBottom = "0px";
                break;
              case e.ControlAnchor.BOTTOM_LEFT:
                o = this.controls.bottomleft, i.style.position = "relative", i.style.paddingLeft = "0px", i.style.paddingBottom = "0px";
                break;
              case e.ControlAnchor.TOP_LEFT:
                o = this.controls.topleft, i.style.position = "relative", i.style.paddingLeft = "0px", i.style.paddingTop = "0px";
                break;
              case e.ControlAnchor.ABSOLUTE:
                o = this.container, i.style.margin = "0px", i.style.padding = "0px";
                break;
              default:
              case e.ControlAnchor.NONE:
                o = this.container, i.style.margin = "0px", i.style.padding = "0px";
                break;
            }
            this.controls.push(
              new e.Control(i, r, o)
            ), i.style.display = "inline-block";
          }
        },
        /**
         * @function
         * @returns {OpenSeadragon.ControlDock} Chainable.
         */
        removeControl: function(i) {
          i = e.getElement(i);
          var r = t(this, i);
          return r >= 0 && (this.controls[r].destroy(), this.controls.splice(r, 1)), this;
        },
        /**
         * @function
         * @returns {OpenSeadragon.ControlDock} Chainable.
         */
        clearControls: function() {
          for (; this.controls.length > 0; )
            this.controls.pop().destroy();
          return this;
        },
        /**
         * @function
         * @returns {Boolean}
         */
        areControlsEnabled: function() {
          var i;
          for (i = this.controls.length - 1; i >= 0; i--)
            if (this.controls[i].isVisible())
              return !0;
          return !1;
        },
        /**
         * @function
         * @returns {OpenSeadragon.ControlDock} Chainable.
         */
        setControlsEnabled: function(i) {
          var r;
          for (r = this.controls.length - 1; r >= 0; r--)
            this.controls[r].setVisible(i);
          return this;
        }
      };
      function t(i, r) {
        var o = i.controls, a;
        for (a = o.length - 1; a >= 0; a--)
          if (o[a].element === r)
            return a;
        return -1;
      }
    })(n), (function(e) {
      e.Placement = e.freezeObject({
        CENTER: 0,
        TOP_LEFT: 1,
        TOP: 2,
        TOP_RIGHT: 3,
        RIGHT: 4,
        BOTTOM_RIGHT: 5,
        BOTTOM: 6,
        BOTTOM_LEFT: 7,
        LEFT: 8,
        properties: {
          0: {
            isLeft: !1,
            isHorizontallyCentered: !0,
            isRight: !1,
            isTop: !1,
            isVerticallyCentered: !0,
            isBottom: !1
          },
          1: {
            isLeft: !0,
            isHorizontallyCentered: !1,
            isRight: !1,
            isTop: !0,
            isVerticallyCentered: !1,
            isBottom: !1
          },
          2: {
            isLeft: !1,
            isHorizontallyCentered: !0,
            isRight: !1,
            isTop: !0,
            isVerticallyCentered: !1,
            isBottom: !1
          },
          3: {
            isLeft: !1,
            isHorizontallyCentered: !1,
            isRight: !0,
            isTop: !0,
            isVerticallyCentered: !1,
            isBottom: !1
          },
          4: {
            isLeft: !1,
            isHorizontallyCentered: !1,
            isRight: !0,
            isTop: !1,
            isVerticallyCentered: !0,
            isBottom: !1
          },
          5: {
            isLeft: !1,
            isHorizontallyCentered: !1,
            isRight: !0,
            isTop: !1,
            isVerticallyCentered: !1,
            isBottom: !0
          },
          6: {
            isLeft: !1,
            isHorizontallyCentered: !0,
            isRight: !1,
            isTop: !1,
            isVerticallyCentered: !1,
            isBottom: !0
          },
          7: {
            isLeft: !0,
            isHorizontallyCentered: !1,
            isRight: !1,
            isTop: !1,
            isVerticallyCentered: !1,
            isBottom: !0
          },
          8: {
            isLeft: !0,
            isHorizontallyCentered: !1,
            isRight: !1,
            isTop: !1,
            isVerticallyCentered: !0,
            isBottom: !1
          }
        }
      });
    })(n), (function(e) {
      var t = {}, i = 1;
      e.Viewer = function(v) {
        var P = arguments, W = this, X;
        e.isPlainObject(v) || (v = {
          id: P[0],
          xmlPath: P.length > 1 ? P[1] : void 0,
          prefixUrl: P.length > 2 ? P[2] : void 0,
          controls: P.length > 3 ? P[3] : void 0,
          overlays: P.length > 4 ? P[4] : void 0
        }), v.config && (e.extend(!0, v, v.config), delete v.config);
        let $ = [
          "useCanvas"
          // deprecated
        ];
        if (v.drawerOptions = Object.assign(
          {},
          $.reduce((Y, ve) => (Y[ve] = v[ve], delete v[ve], Y), {}),
          v.drawerOptions
        ), e.extend(!0, this, {
          //internal state and dom identifiers
          id: v.id,
          hash: v.hash || i++,
          /**
           * Index for page to be shown first next time open() is called (only used in sequenceMode).
           * @member {Number} initialPage
           * @memberof OpenSeadragon.Viewer#
           */
          initialPage: 0,
          //dom nodes
          /**
           * The parent element of this Viewer instance, passed in when the Viewer was created.
           * @member {Element} element
           * @memberof OpenSeadragon.Viewer#
           */
          element: null,
          /**
           * A &lt;div&gt; element (provided by {@link OpenSeadragon.ControlDock}), the base element of this Viewer instance.<br><br>
           * Child element of {@link OpenSeadragon.Viewer#element}.
           * @member {Element} container
           * @memberof OpenSeadragon.Viewer#
           */
          container: null,
          /**
           * A &lt;div&gt; element, the element where user-input events are handled for panning and zooming.<br><br>
           * Child element of {@link OpenSeadragon.Viewer#container},
           * positioned on top of {@link OpenSeadragon.Viewer#keyboardCommandArea}.<br><br>
           * The parent of {@link OpenSeadragon.Drawer#canvas} instances.
           * @member {Element} canvas
           * @memberof OpenSeadragon.Viewer#
           */
          canvas: null,
          // Overlays list. An overlay allows to add html on top of the viewer.
          overlays: [],
          // Container inside the canvas where overlays are drawn.
          overlaysContainer: null,
          //private state properties
          previousBody: [],
          //This was originally initialized in the constructor and so could never
          //have anything in it.  now it can because we allow it to be specified
          //in the options and is only empty by default if not specified. Also
          //this array was returned from get_controls which I find confusing
          //since this object has a controls property which is treated in other
          //functions like clearControls.  I'm removing the accessors.
          customControls: [],
          //These are originally not part options but declared as members
          //in initialize.  It's still considered idiomatic to put them here
          //source is here for backwards compatibility. It is not an official
          //part of the API and should not be relied upon.
          source: null,
          /**
           * Handles rendering of tiles in the viewer. Created for each TileSource opened.
           * @member {OpenSeadragon.Drawer} drawer
           * @memberof OpenSeadragon.Viewer#
           */
          drawer: null,
          /**
           * Keeps track of all of the tiled images in the scene.
           * @member {OpenSeadragon.World} world
           * @memberof OpenSeadragon.Viewer#
           */
          world: null,
          /**
           * Handles coordinate-related functionality - zoom, pan, rotation, etc. Created for each TileSource opened.
           * @member {OpenSeadragon.Viewport} viewport
           * @memberof OpenSeadragon.Viewer#
           */
          viewport: null,
          /**
           * @member {OpenSeadragon.Navigator} navigator
           * @memberof OpenSeadragon.Viewer#
           */
          navigator: null,
          //A collection viewport is a separate viewport used to provide
          //simultaneous rendering of sets of tiles
          collectionViewport: null,
          collectionDrawer: null,
          //UI image resources
          //TODO: rename navImages to uiImages
          navImages: null,
          //interface button controls
          buttonGroup: null,
          //TODO: this is defunct so safely remove it
          profiler: null
        }, e.DEFAULT_SETTINGS, v), typeof this.hash > "u")
          throw new Error("A hash must be defined, either by specifying options.id or options.hash.");
        typeof t[this.hash] < "u" && e.console.warn("Hash " + this.hash + " has already been used."), t[this.hash] = {
          fsBoundsDelta: new e.Point(1, 1),
          prevContainerSize: null,
          animating: !1,
          forceRedraw: !1,
          needsResize: !1,
          forceResize: !1,
          mouseInside: !1,
          group: null,
          // whether we should be continuously zooming
          zooming: !1,
          // how much we should be continuously zooming by
          zoomFactor: null,
          lastZoomTime: null,
          fullPage: !1,
          onfullscreenchange: null,
          lastClickTime: null,
          draggingToZoom: !1
        }, this._sequenceIndex = 0, this._firstOpen = !0, this._updateRequestId = null, this._loadQueue = [], this.currentOverlays = [], this._updatePixelDensityRatioBind = null, this._lastScrollTime = e.now(), e.EventSource.call(this), this.addHandler("open-failed", function(Y) {
          var ve = e.getString("Errors.OpenFailed", Y.eventSource, Y.message);
          W._showMessage(ve);
        }), e.ControlDock.call(this, v), this.xmlPath && (this.tileSources = [this.xmlPath]), this.element = this.element || document.getElementById(this.id), this.canvas = e.makeNeutralElement("div"), this.canvas.className = "openseadragon-canvas", (function(Y) {
          Y.width = "100%", Y.height = "100%", Y.overflow = "hidden", Y.position = "absolute", Y.top = "0px", Y.left = "0px";
        })(this.canvas.style), e.setElementTouchActionNone(this.canvas), v.tabIndex !== "" && (this.canvas.tabIndex = v.tabIndex === void 0 ? 0 : v.tabIndex), this.container.className = "openseadragon-container", (function(Y) {
          Y.width = "100%", Y.height = "100%", Y.position = "relative", Y.overflow = "hidden", Y.left = "0px", Y.top = "0px", Y.textAlign = "left";
        })(this.container.style), e.setElementTouchActionNone(this.container), this.container.insertBefore(this.canvas, this.container.firstChild), this.element.appendChild(this.container), this.bodyWidth = document.body.style.width, this.bodyHeight = document.body.style.height, this.bodyOverflow = document.body.style.overflow, this.docOverflow = document.documentElement.style.overflow, this.innerTracker = new e.MouseTracker({
          userData: "Viewer.innerTracker",
          element: this.canvas,
          startDisabled: !this.mouseNavEnabled,
          clickTimeThreshold: this.clickTimeThreshold,
          clickDistThreshold: this.clickDistThreshold,
          dblClickTimeThreshold: this.dblClickTimeThreshold,
          dblClickDistThreshold: this.dblClickDistThreshold,
          contextMenuHandler: e.delegate(this, R),
          keyDownHandler: e.delegate(this, D),
          keyHandler: e.delegate(this, U),
          clickHandler: e.delegate(this, Z),
          dblClickHandler: e.delegate(this, ce),
          dragHandler: e.delegate(this, re),
          dragEndHandler: e.delegate(this, ue),
          enterHandler: e.delegate(this, me),
          leaveHandler: e.delegate(this, Te),
          pressHandler: e.delegate(this, Re),
          releaseHandler: e.delegate(this, He),
          nonPrimaryPressHandler: e.delegate(this, Fe),
          nonPrimaryReleaseHandler: e.delegate(this, _e),
          scrollHandler: e.delegate(this, qe),
          pinchHandler: e.delegate(this, Ae),
          focusHandler: e.delegate(this, Je),
          blurHandler: e.delegate(this, Ge)
        }), this.outerTracker = new e.MouseTracker({
          userData: "Viewer.outerTracker",
          element: this.container,
          startDisabled: !this.mouseNavEnabled,
          clickTimeThreshold: this.clickTimeThreshold,
          clickDistThreshold: this.clickDistThreshold,
          dblClickTimeThreshold: this.dblClickTimeThreshold,
          dblClickDistThreshold: this.dblClickDistThreshold,
          enterHandler: e.delegate(this, nt),
          leaveHandler: e.delegate(this, Ve)
        }), this.toolbar && (this.toolbar = new e.ControlDock({ element: this.toolbar })), this.bindStandardControls(), t[this.hash].prevContainerSize = r(this.container), window.ResizeObserver ? (this._autoResizePolling = !1, this._resizeObserver = new ResizeObserver(function() {
          t[W.hash].needsResize = !0;
        }), this._resizeObserver.observe(this.container, {})) : this._autoResizePolling = !0, this.world = new e.World({
          viewer: this
        }), this.world.addHandler("add-item", function(Y) {
          W.source = W.world.getItemAt(0).source, t[W.hash].forceRedraw = !0, W._updateRequestId || (W._updateRequestId = u(W, ot));
        }), this.world.addHandler("remove-item", function(Y) {
          W.world.getItemCount() ? W.source = W.world.getItemAt(0).source : W.source = null, t[W.hash].forceRedraw = !0;
        }), this.world.addHandler("metrics-change", function(Y) {
          W.viewport && W.viewport._setContentBounds(W.world.getHomeBounds(), W.world.getContentFactor());
        }), this.world.addHandler("item-index-change", function(Y) {
          W.source = W.world.getItemAt(0).source;
        }), this.viewport = new e.Viewport({
          containerSize: t[this.hash].prevContainerSize,
          springStiffness: this.springStiffness,
          animationTime: this.animationTime,
          minZoomImageRatio: this.minZoomImageRatio,
          maxZoomPixelRatio: this.maxZoomPixelRatio,
          visibilityRatio: this.visibilityRatio,
          wrapHorizontal: this.wrapHorizontal,
          wrapVertical: this.wrapVertical,
          defaultZoomLevel: this.defaultZoomLevel,
          minZoomLevel: this.minZoomLevel,
          maxZoomLevel: this.maxZoomLevel,
          viewer: this,
          degrees: this.degrees,
          flipped: this.flipped,
          overlayPreserveContentDirection: this.overlayPreserveContentDirection,
          navigatorRotate: this.navigatorRotate,
          homeFillsViewer: this.homeFillsViewer,
          margins: this.viewportMargins,
          silenceMultiImageWarnings: this.silenceMultiImageWarnings
        }), this.viewport._setContentBounds(this.world.getHomeBounds(), this.world.getContentFactor()), this.imageLoader = new e.ImageLoader({
          jobLimit: this.imageLoaderLimit,
          timeout: v.timeout,
          tileRetryMax: this.tileRetryMax,
          tileRetryDelay: this.tileRetryDelay
        }), this.tileCache = new e.TileCache({
          maxImageCacheCount: this.maxImageCacheCount
        }), Object.prototype.hasOwnProperty.call(this.drawerOptions, "useCanvas") && (e.console.error('useCanvas is deprecated, use the "drawer" option to indicate preferred drawer(s)'), this.drawerOptions.useCanvas || (this.drawer = e.HTMLDrawer), delete this.drawerOptions.useCanvas);
        let he = Array.isArray(this.drawer) ? this.drawer : [this.drawer];
        he.length === 0 && (he = [e.DEFAULT_SETTINGS.drawer].flat(), e.console.warn("No valid drawers were selected. Using the default value.")), this.drawer = null;
        for (const Y of he)
          if (this.requestDrawer(Y, { mainDrawer: !0, redrawImmediately: !1 }))
            break;
        if (!this.drawer)
          throw e.console.error("No drawer could be created!"), "Error with creating the selected drawer(s)";
        for (this.drawer.setImageSmoothingEnabled(this.imageSmoothingEnabled), this.overlaysContainer = e.makeNeutralElement("div"), this.canvas.appendChild(this.overlaysContainer), this.drawer.canRotate() || (this.rotateLeft && (X = this.buttonGroup.buttons.indexOf(this.rotateLeft), this.buttonGroup.buttons.splice(X, 1), this.buttonGroup.element.removeChild(this.rotateLeft.element)), this.rotateRight && (X = this.buttonGroup.buttons.indexOf(this.rotateRight), this.buttonGroup.buttons.splice(X, 1), this.buttonGroup.element.removeChild(this.rotateRight.element))), this._addUpdatePixelDensityRatioEvent(), this.showNavigator && (this.navigator = new e.Navigator({
          element: this.navigatorElement,
          id: this.navigatorId,
          position: this.navigatorPosition,
          sizeRatio: this.navigatorSizeRatio,
          maintainSizeRatio: this.navigatorMaintainSizeRatio,
          top: this.navigatorTop,
          left: this.navigatorLeft,
          width: this.navigatorWidth,
          height: this.navigatorHeight,
          autoResize: this.navigatorAutoResize,
          autoFade: this.navigatorAutoFade,
          prefixUrl: this.prefixUrl,
          viewer: this,
          navigatorRotate: this.navigatorRotate,
          background: this.navigatorBackground,
          opacity: this.navigatorOpacity,
          borderColor: this.navigatorBorderColor,
          displayRegionColor: this.navigatorDisplayRegionColor,
          crossOriginPolicy: this.crossOriginPolicy,
          animationTime: this.animationTime,
          drawer: this.drawer.getType(),
          loadTilesWithAjax: this.loadTilesWithAjax,
          ajaxHeaders: this.ajaxHeaders,
          ajaxWithCredentials: this.ajaxWithCredentials
        })), this.sequenceMode && this.bindSequenceControls(), this.tileSources && this.open(this.tileSources), X = 0; X < this.customControls.length; X++)
          this.addControl(
            this.customControls[X].id,
            { anchor: this.customControls[X].anchor }
          );
        e.requestAnimationFrame(function() {
          f(W);
        }), e._viewers.set(this.element, this);
      }, e.extend(
        e.Viewer.prototype,
        e.EventSource.prototype,
        e.ControlDock.prototype,
        /** @lends OpenSeadragon.Viewer.prototype */
        {
          /**
           * @function
           * @returns {Boolean}
           */
          isOpen: function() {
            return !!this.world.getItemCount();
          },
          // deprecated
          openDzi: function(v) {
            return e.console.error("[Viewer.openDzi] this function is deprecated; use Viewer.open() instead."), this.open(v);
          },
          // deprecated
          openTileSource: function(v) {
            return e.console.error("[Viewer.openTileSource] this function is deprecated; use Viewer.open() instead."), this.open(v);
          },
          //deprecated
          get buttons() {
            return e.console.warn("Viewer.buttons is deprecated; Please use Viewer.buttonGroup"), this.buttonGroup;
          },
          /**
           * Open tiled images into the viewer, closing any others.
           * To get the TiledImage instance created by open, add an event listener for
           * {@link OpenSeadragon.Viewer.html#.event:open}, which when fired can be used to get access
           * to the instance, i.e., viewer.world.getItemAt(0).
           * @function
           * @param {Array|String|Object|Function} tileSources - This can be a TiledImage
           * specifier, a TileSource specifier, or an array of either. A TiledImage specifier
           * is the same as the options parameter for {@link OpenSeadragon.Viewer#addTiledImage},
           * except for the index property; images are added in sequence.
           * A TileSource specifier is anything you could pass as the tileSource property
           * of the options parameter for {@link OpenSeadragon.Viewer#addTiledImage}.
           * @param {Number} initialPage - If sequenceMode is true, display this page initially
           * for the given tileSources. If specified, will overwrite the Viewer's existing initialPage property.
           * @returns {OpenSeadragon.Viewer} Chainable.
           * @fires OpenSeadragon.Viewer.event:open
           * @fires OpenSeadragon.Viewer.event:open-failed
           */
          open: function(v, P) {
            var W = this;
            if (this.close(), !v)
              return this;
            if (this.sequenceMode && e.isArray(v))
              return this.referenceStrip && (this.referenceStrip.destroy(), this.referenceStrip = null), typeof P < "u" && !isNaN(P) && (this.initialPage = P), this.tileSources = v, this._sequenceIndex = Math.max(0, Math.min(this.tileSources.length - 1, this.initialPage)), this.tileSources.length && (this.open(this.tileSources[this._sequenceIndex]), this.showReferenceStrip && this.addReferenceStrip()), this._updateSequenceButtons(this._sequenceIndex), this;
            if (e.isArray(v) || (v = [v]), !v.length)
              return this;
            this._opening = !0;
            for (var X = v.length, $ = 0, he = 0, Y, ve = function() {
              if ($ + he === X)
                if ($) {
                  (W._firstOpen || !W.preserveViewport) && (W.viewport.goHome(!0), W.viewport.update()), W._firstOpen = !1;
                  var ge = v[0];
                  if (ge.tileSource && (ge = ge.tileSource), W.overlays && !W.preserveOverlays)
                    for (var Le = 0; Le < W.overlays.length; Le++)
                      W.currentOverlays[Le] = a(W, W.overlays[Le]);
                  W._drawOverlays(), W._opening = !1, W.raiseEvent("open", { source: ge });
                } else
                  W._opening = !1, W.raiseEvent("open-failed", Y);
            }, Ce = function(ge) {
              (!e.isPlainObject(ge) || !ge.tileSource) && (ge = {
                tileSource: ge
              }), ge.index !== void 0 && (e.console.error("[Viewer.open] setting indexes here is not supported; use addTiledImage instead"), delete ge.index), ge.collectionImmediately === void 0 && (ge.collectionImmediately = !0);
              var Le = ge.success;
              ge.success = function(_) {
                if ($++, ge.tileSource.overlays)
                  for (var T = 0; T < ge.tileSource.overlays.length; T++)
                    W.addOverlay(ge.tileSource.overlays[T]);
                Le && Le(_), ve();
              };
              var y = ge.error;
              ge.error = function(_) {
                he++, Y || (Y = _), y && y(_), ve();
              }, W.addTiledImage(ge);
            }, Se = 0; Se < v.length; Se++)
              Ce(v[Se]);
            return this;
          },
          /**
           * @function
           * @returns {OpenSeadragon.Viewer} Chainable.
           * @fires OpenSeadragon.Viewer.event:close
           */
          close: function() {
            return t[this.hash] ? (this._opening = !1, this.navigator && this.navigator.close(), this.preserveOverlays || (this.clearOverlays(), this.overlaysContainer.innerHTML = ""), t[this.hash].animating = !1, this.world.removeAll(), this.imageLoader.clear(), this.raiseEvent("close"), this) : this;
          },
          /**
           * Function to destroy the viewer and clean up everything created by OpenSeadragon.
           *
           * Example:
           * var viewer = OpenSeadragon({
           *   [...]
           * });
           *
           * //when you are done with the viewer:
           * viewer.destroy();
           * viewer = null; //important
           *
           * @function
           * @fires OpenSeadragon.Viewer.event:before-destroy
           * @fires OpenSeadragon.Viewer.event:destroy
           */
          destroy: function() {
            if (t[this.hash]) {
              if (this.raiseEvent("before-destroy"), this._removeUpdatePixelDensityRatioEvent(), this.close(), this.clearOverlays(), this.overlaysContainer.innerHTML = "", this._resizeObserver && this._resizeObserver.disconnect(), this.referenceStrip && (this.referenceStrip.destroy(), this.referenceStrip = null), this._updateRequestId !== null && (e.cancelAnimationFrame(this._updateRequestId), this._updateRequestId = null), this.drawer && this.drawer.destroy(), this.navigator && (this.navigator.destroy(), t[this.navigator.hash] = null, delete t[this.navigator.hash], this.navigator = null), this.buttonGroup)
                this.buttonGroup.destroy();
              else if (this.customButtons)
                for (; this.customButtons.length; )
                  this.customButtons.pop().destroy();
              if (this.paging && this.paging.destroy(), this.element)
                for (; this.element.firstChild; )
                  this.element.removeChild(this.element.firstChild);
              this.container.onsubmit = null, this.clearControls(), this.innerTracker && this.innerTracker.destroy(), this.outerTracker && this.outerTracker.destroy(), t[this.hash] = null, delete t[this.hash], this.canvas = null, this.container = null, e._viewers.delete(this.element), this.element = null, this.raiseEvent("destroy"), this.removeAllHandlers();
            }
          },
          /**
           * Request a drawer for this viewer, as a supported string or drawer constructor.
           * @param {String | OpenSeadragon.DrawerBase} drawerCandidate The type of drawer to try to construct.
           * @param { Object } options
           * @param { Boolean } [options.mainDrawer] Whether to use this as the viewer's main drawer. Default = true.
           * @param { Boolean } [options.redrawImmediately] Whether to immediately draw a new frame. Only used if options.mainDrawer = true. Default = true.
           * @param { Object } [options.drawerOptions] Options for this drawer. Defaults to viewer.drawerOptions.
           * for this viewer type. See {@link OpenSeadragon.Options}.
           * @returns {Object | Boolean} The drawer that was created, or false if the requested drawer is not supported
           */
          requestDrawer(v, P) {
            const W = {
              mainDrawer: !0,
              redrawImmediately: !0,
              drawerOptions: null
            };
            P = e.extend(!0, W, P);
            const X = P.mainDrawer, $ = P.redrawImmediately, he = P.drawerOptions, Y = this.drawer;
            let ve = null;
            if (v && v.prototype instanceof e.DrawerBase ? (ve = v, v = "custom") : typeof v == "string" && (ve = e.determineDrawer(v)), ve || e.console.warn("Unsupported drawer! Drawer must be an existing string type, or a class that extends OpenSeadragon.DrawerBase."), ve && ve.isSupported()) {
              Y && X && Y.destroy();
              const Ce = new ve({
                viewer: this,
                viewport: this.viewport,
                element: this.canvas,
                debugGridColor: this.debugGridColor,
                options: he || this.drawerOptions[v]
              });
              return X && (this.drawer = Ce, $ && this.forceRedraw()), Ce;
            }
            return !1;
          },
          /**
           * @function
           * @returns {Boolean}
           */
          isMouseNavEnabled: function() {
            return this.innerTracker.isTracking();
          },
          /**
           * @function
           * @param {Boolean} enabled - true to enable, false to disable
           * @returns {OpenSeadragon.Viewer} Chainable.
           * @fires OpenSeadragon.Viewer.event:mouse-enabled
           */
          setMouseNavEnabled: function(v) {
            return this.innerTracker.setTracking(v), this.outerTracker.setTracking(v), this.raiseEvent("mouse-enabled", { enabled: v }), this;
          },
          /**
           * @function
           * @returns {Boolean}
           */
          areControlsEnabled: function() {
            var v = this.controls.length, P;
            for (P = 0; P < this.controls.length; P++)
              v = v && this.controls[P].isVisible();
            return v;
          },
          /**
           * Shows or hides the controls (e.g. the default navigation buttons).
           *
           * @function
           * @param {Boolean} true to show, false to hide.
           * @returns {OpenSeadragon.Viewer} Chainable.
           * @fires OpenSeadragon.Viewer.event:controls-enabled
           */
          setControlsEnabled: function(v) {
            return v ? x(this) : f(this), this.raiseEvent("controls-enabled", { enabled: v }), this;
          },
          /**
           * Turns debugging mode on or off for this viewer.
           *
           * @function
           * @param {Boolean} debugMode true to turn debug on, false to turn debug off.
           */
          setDebugMode: function(v) {
            for (var P = 0; P < this.world.getItemCount(); P++)
              this.world.getItemAt(P).debugMode = v;
            this.debugMode = v, this.forceRedraw();
          },
          /**
           * Update headers to include when making AJAX requests.
           *
           * Unless `propagate` is set to false (which is likely only useful in rare circumstances),
           * the updated headers are propagated to all tiled images, each of which will subsequently
           * propagate the changed headers to all their tiles.
           * If applicable, the headers of the viewer's navigator and reference strip will also be updated.
           *
           * Note that the rules for merging headers still apply, i.e. headers returned by
           * {@link OpenSeadragon.TileSource#getTileAjaxHeaders} take precedence over
           * `TiledImage.ajaxHeaders`, which take precedence over the headers here in the viewer.
           *
           * @function
           * @param {Object} ajaxHeaders Updated AJAX headers.
           * @param {Boolean} [propagate=true] Whether to propagate updated headers to tiled images, etc.
           */
          setAjaxHeaders: function(v, P) {
            if (v === null && (v = {}), !e.isPlainObject(v)) {
              console.error("[Viewer.setAjaxHeaders] Ignoring invalid headers, must be a plain object");
              return;
            }
            if (P === void 0 && (P = !0), this.ajaxHeaders = v, P) {
              for (var W = 0; W < this.world.getItemCount(); W++)
                this.world.getItemAt(W)._updateAjaxHeaders(!0);
              if (this.navigator && this.navigator.setAjaxHeaders(this.ajaxHeaders, !0), this.referenceStrip && this.referenceStrip.miniViewers)
                for (var X in this.referenceStrip.miniViewers)
                  this.referenceStrip.miniViewers[X].setAjaxHeaders(this.ajaxHeaders, !0);
            }
          },
          /**
           * Adds the given button to this viewer.
           *
           * @function
           * @param {OpenSeadragon.Button} button
           */
          addButton: function(v) {
            this.buttonGroup.addButton(v);
          },
          /**
           * @function
           * @returns {Boolean}
           */
          isFullPage: function() {
            return t[this.hash] && t[this.hash].fullPage;
          },
          /**
           * Toggle full page mode.
           * @function
           * @param {Boolean} fullPage
           *      If true, enter full page mode.  If false, exit full page mode.
           * @returns {OpenSeadragon.Viewer} Chainable.
           * @fires OpenSeadragon.Viewer.event:pre-full-page
           * @fires OpenSeadragon.Viewer.event:full-page
           */
          setFullPage: function(v) {
            var P = document.body, W = P.style, X = document.documentElement.style, $ = this, he, Y;
            if (v === this.isFullPage())
              return this;
            var ve = {
              fullPage: v,
              preventDefaultAction: !1
            };
            if (this.raiseEvent("pre-full-page", ve), ve.preventDefaultAction)
              return this;
            if (v && this.element) {
              for (this.elementSize = e.getElementSize(this.element), this.pageScroll = e.getPageScroll(), this.elementMargin = this.element.style.margin, this.element.style.margin = "0", this.elementPadding = this.element.style.padding, this.element.style.padding = "0", this.bodyMargin = W.margin, this.docMargin = X.margin, W.margin = "0", X.margin = "0", this.bodyPadding = W.padding, this.docPadding = X.padding, W.padding = "0", X.padding = "0", this.bodyWidth = W.width, this.docWidth = X.width, W.width = "100%", X.width = "100%", this.bodyHeight = W.height, this.docHeight = X.height, W.height = "100%", X.height = "100%", this.bodyDisplay = W.display, W.display = "block", this.previousBody = [], t[this.hash].prevElementParent = this.element.parentNode, t[this.hash].prevNextSibling = this.element.nextSibling, t[this.hash].prevElementWidth = this.element.style.width, t[this.hash].prevElementHeight = this.element.style.height, he = P.childNodes.length, Y = 0; Y < he; Y++)
                this.previousBody.push(P.childNodes[0]), P.removeChild(P.childNodes[0]);
              this.toolbar && this.toolbar.element && (this.toolbar.parentNode = this.toolbar.element.parentNode, this.toolbar.nextSibling = this.toolbar.element.nextSibling, P.appendChild(this.toolbar.element), e.addClass(this.toolbar.element, "fullpage")), e.addClass(this.element, "fullpage"), P.appendChild(this.element), this.element.style.height = "100vh", this.element.style.width = "100vw", this.toolbar && this.toolbar.element && (this.element.style.height = e.getElementSize(this.element).y - e.getElementSize(this.toolbar.element).y + "px"), t[this.hash].fullPage = !0, e.delegate(this, nt)({});
            } else {
              for (this.element.style.margin = this.elementMargin, this.element.style.padding = this.elementPadding, W.margin = this.bodyMargin, X.margin = this.docMargin, W.padding = this.bodyPadding, X.padding = this.docPadding, W.width = this.bodyWidth, X.width = this.docWidth, W.height = this.bodyHeight, X.height = this.docHeight, W.display = this.bodyDisplay, P.removeChild(this.element), he = this.previousBody.length, Y = 0; Y < he; Y++)
                P.appendChild(this.previousBody.shift());
              e.removeClass(this.element, "fullpage"), t[this.hash].prevElementParent.insertBefore(
                this.element,
                t[this.hash].prevNextSibling
              ), this.toolbar && this.toolbar.element && (P.removeChild(this.toolbar.element), e.removeClass(this.toolbar.element, "fullpage"), this.toolbar.parentNode.insertBefore(
                this.toolbar.element,
                this.toolbar.nextSibling
              ), delete this.toolbar.parentNode, delete this.toolbar.nextSibling), this.element.style.width = t[this.hash].prevElementWidth, this.element.style.height = t[this.hash].prevElementHeight;
              var Ce = 0, Se = function() {
                e.setPageScroll($.pageScroll);
                var ge = e.getPageScroll();
                Ce++, Ce < 10 && (ge.x !== $.pageScroll.x || ge.y !== $.pageScroll.y) && e.requestAnimationFrame(Se);
              };
              e.requestAnimationFrame(Se), t[this.hash].fullPage = !1, e.delegate(this, Ve)({});
            }
            return this.navigator && this.viewport && this.navigator.update(this.viewport), this.raiseEvent("full-page", { fullPage: v }), this;
          },
          /**
           * Toggle full screen mode if supported. Toggle full page mode otherwise.
           * @function
           * @param {Boolean} fullScreen
           *      If true, enter full screen mode.  If false, exit full screen mode.
           * @returns {OpenSeadragon.Viewer} Chainable.
           * @fires OpenSeadragon.Viewer.event:pre-full-screen
           * @fires OpenSeadragon.Viewer.event:full-screen
           */
          setFullScreen: function(v) {
            var P = this;
            if (!e.supportsFullScreen)
              return this.setFullPage(v);
            if (e.isFullScreen() === v)
              return this;
            var W = {
              fullScreen: v,
              preventDefaultAction: !1
            };
            if (this.raiseEvent("pre-full-screen", W), W.preventDefaultAction)
              return this;
            if (v) {
              if (this.setFullPage(!0), !this.isFullPage())
                return this;
              this.fullPageStyleWidth = this.element.style.width, this.fullPageStyleHeight = this.element.style.height, this.element.style.width = "100%", this.element.style.height = "100%";
              var X = function() {
                var $ = e.isFullScreen();
                $ || (e.removeEvent(document, e.fullScreenEventName, X), e.removeEvent(document, e.fullScreenErrorEventName, X), P.setFullPage(!1), P.isFullPage() && (P.element.style.width = P.fullPageStyleWidth, P.element.style.height = P.fullPageStyleHeight)), P.navigator && P.viewport && setTimeout(function() {
                  P.navigator.update(P.viewport);
                }), P.raiseEvent("full-screen", { fullScreen: $ });
              };
              e.addEvent(document, e.fullScreenEventName, X), e.addEvent(document, e.fullScreenErrorEventName, X), e.requestFullScreen(document.body);
            } else
              e.exitFullScreen();
            return this;
          },
          /**
           * @function
           * @returns {Boolean}
           */
          isVisible: function() {
            return this.container.style.visibility !== "hidden";
          },
          //
          /**
           * @function
           * @returns {Boolean} returns true if the viewer is in fullscreen
           */
          isFullScreen: function() {
            return e.isFullScreen() && this.isFullPage();
          },
          /**
           * @function
           * @param {Boolean} visible
           * @returns {OpenSeadragon.Viewer} Chainable.
           * @fires OpenSeadragon.Viewer.event:visible
           */
          setVisible: function(v) {
            return this.container.style.visibility = v ? "" : "hidden", this.raiseEvent("visible", { visible: v }), this;
          },
          /**
           * Add a tiled image to the viewer.
           * options.tileSource can be anything that {@link OpenSeadragon.Viewer#open}
           *  supports except arrays of images.
           * Note that you can specify options.width or options.height, but not both.
           * The other dimension will be calculated according to the item's aspect ratio.
           * If collectionMode is on (see {@link OpenSeadragon.Options}), the new image is
           * automatically arranged with the others.
           * @function
           * @param {Object} options
           * @param {String|Object|Function} options.tileSource - The TileSource specifier.
           * A String implies a url used to determine the tileSource implementation
           *      based on the file extension of url. JSONP is implied by *.js,
           *      otherwise the url is retrieved as text and the resulting text is
           *      introspected to determine if its json, xml, or text and parsed.
           * An Object implies an inline configuration which has a single
           *      property sufficient for being able to determine tileSource
           *      implementation. If the object has a property which is a function
           *      named 'getTileUrl', it is treated as a custom TileSource.
           * @param {Number} [options.index] The index of the item. Added on top of
           * all other items if not specified.
           * @param {Boolean} [options.replace=false] If true, the item at options.index will be
           * removed and the new item is added in its place. options.tileSource will be
           * interpreted and fetched if necessary before the old item is removed to avoid leaving
           * a gap in the world.
           * @param {Number} [options.x=0] The X position for the image in viewport coordinates.
           * @param {Number} [options.y=0] The Y position for the image in viewport coordinates.
           * @param {Number} [options.width=1] The width for the image in viewport coordinates.
           * @param {Number} [options.height] The height for the image in viewport coordinates.
           * @param {OpenSeadragon.Rect} [options.fitBounds] The bounds in viewport coordinates
           * to fit the image into. If specified, x, y, width and height get ignored.
           * @param {OpenSeadragon.Placement} [options.fitBoundsPlacement=OpenSeadragon.Placement.CENTER]
           * How to anchor the image in the bounds if options.fitBounds is set.
           * @param {OpenSeadragon.Rect} [options.clip] - An area, in image pixels, to clip to
           * (portions of the image outside of this area will not be visible). Only works on
           * browsers that support the HTML5 canvas.
           * @param {Number} [options.opacity=1] Proportional opacity of the tiled images (1=opaque, 0=hidden)
           * @param {Boolean} [options.preload=false]  Default switch for loading hidden images (true loads, false blocks)
           * @param {Number} [options.degrees=0] Initial rotation of the tiled image around
           * its top left corner in degrees.
           * @param {Boolean} [options.flipped=false] Whether to horizontally flip the image.
           * @param {String} [options.compositeOperation] How the image is composited onto other images.
           * @param {String} [options.crossOriginPolicy] The crossOriginPolicy for this specific image,
           * overriding viewer.crossOriginPolicy.
           * @param {Boolean} [options.ajaxWithCredentials] Whether to set withCredentials on tile AJAX
           * @param {Boolean} [options.loadTilesWithAjax]
           *      Whether to load tile data using AJAX requests.
           *      Defaults to the setting in {@link OpenSeadragon.Options}.
           * @param {Object} [options.ajaxHeaders]
           *      A set of headers to include when making tile AJAX requests.
           *      Note that these headers will be merged over any headers specified in {@link OpenSeadragon.Options}.
           *      Specifying a falsy value for a header will clear its existing value set at the Viewer level (if any).
           * @param {Function} [options.success] A function that gets called when the image is
           * successfully added. It's passed the event object which contains a single property:
           * "item", which is the resulting instance of TiledImage.
           * @param {Function} [options.error] A function that gets called if the image is
           * unable to be added. It's passed the error event object, which contains "message"
           * and "source" properties.
           * @param {Boolean} [options.collectionImmediately=false] If collectionMode is on,
           * specifies whether to snap to the new arrangement immediately or to animate to it.
           * @param {String|CanvasGradient|CanvasPattern|Function} [options.placeholderFillStyle] - See {@link OpenSeadragon.Options}.
           * @fires OpenSeadragon.World.event:add-item
           * @fires OpenSeadragon.Viewer.event:add-item-failed
           */
          addTiledImage: function(v) {
            e.console.assert(v, "[Viewer.addTiledImage] options is required"), e.console.assert(v.tileSource, "[Viewer.addTiledImage] options.tileSource is required"), e.console.assert(
              !v.replace || v.index > -1 && v.index < this.world.getItemCount(),
              "[Viewer.addTiledImage] if options.replace is used, options.index must be a valid index in Viewer.world"
            );
            var P = this;
            v.replace && (v.replaceItem = P.world.getItemAt(v.index)), this._hideMessage(), v.placeholderFillStyle === void 0 && (v.placeholderFillStyle = this.placeholderFillStyle), v.opacity === void 0 && (v.opacity = this.opacity), v.preload === void 0 && (v.preload = this.preload), v.compositeOperation === void 0 && (v.compositeOperation = this.compositeOperation), v.crossOriginPolicy === void 0 && (v.crossOriginPolicy = v.tileSource.crossOriginPolicy !== void 0 ? v.tileSource.crossOriginPolicy : this.crossOriginPolicy), v.ajaxWithCredentials === void 0 && (v.ajaxWithCredentials = this.ajaxWithCredentials), v.loadTilesWithAjax === void 0 && (v.loadTilesWithAjax = this.loadTilesWithAjax), e.isPlainObject(v.ajaxHeaders) || (v.ajaxHeaders = {});
            var W = {
              options: v
            };
            function X(Y) {
              for (var ve = 0; ve < P._loadQueue.length; ve++)
                if (P._loadQueue[ve] === W) {
                  P._loadQueue.splice(ve, 1);
                  break;
                }
              P._loadQueue.length === 0 && $(W), P.raiseEvent("add-item-failed", Y), v.error && v.error(Y);
            }
            function $(Y) {
              P.collectionMode && (P.world.arrange({
                immediately: Y.options.collectionImmediately,
                rows: P.collectionRows,
                columns: P.collectionColumns,
                layout: P.collectionLayout,
                tileSize: P.collectionTileSize,
                tileMargin: P.collectionTileMargin
              }), P.world.setAutoRefigureSizes(!0));
            }
            if (e.isArray(v.tileSource)) {
              setTimeout(function() {
                X({
                  message: "[Viewer.addTiledImage] Sequences can not be added; add them one at a time instead.",
                  source: v.tileSource,
                  options: v
                });
              });
              return;
            }
            this._loadQueue.push(W);
            function he() {
              for (var Y, ve, Ce; P._loadQueue.length && (Y = P._loadQueue[0], !!Y.tileSource); ) {
                if (P._loadQueue.splice(0, 1), Y.options.replace) {
                  var Se = P.world.getIndexOfItem(Y.options.replaceItem);
                  Se !== -1 && (Y.options.index = Se), P.world.removeItem(Y.options.replaceItem);
                }
                ve = new e.TiledImage({
                  viewer: P,
                  source: Y.tileSource,
                  viewport: P.viewport,
                  drawer: P.drawer,
                  tileCache: P.tileCache,
                  imageLoader: P.imageLoader,
                  x: Y.options.x,
                  y: Y.options.y,
                  width: Y.options.width,
                  height: Y.options.height,
                  fitBounds: Y.options.fitBounds,
                  fitBoundsPlacement: Y.options.fitBoundsPlacement,
                  clip: Y.options.clip,
                  placeholderFillStyle: Y.options.placeholderFillStyle,
                  opacity: Y.options.opacity,
                  preload: Y.options.preload,
                  degrees: Y.options.degrees,
                  flipped: Y.options.flipped,
                  compositeOperation: Y.options.compositeOperation,
                  springStiffness: P.springStiffness,
                  animationTime: P.animationTime,
                  minZoomImageRatio: P.minZoomImageRatio,
                  wrapHorizontal: P.wrapHorizontal,
                  wrapVertical: P.wrapVertical,
                  maxTilesPerFrame: P.maxTilesPerFrame,
                  immediateRender: P.immediateRender,
                  blendTime: P.blendTime,
                  alwaysBlend: P.alwaysBlend,
                  minPixelRatio: P.minPixelRatio,
                  smoothTileEdgesMinZoom: P.smoothTileEdgesMinZoom,
                  iOSDevice: P.iOSDevice,
                  crossOriginPolicy: Y.options.crossOriginPolicy,
                  ajaxWithCredentials: Y.options.ajaxWithCredentials,
                  loadTilesWithAjax: Y.options.loadTilesWithAjax,
                  ajaxHeaders: Y.options.ajaxHeaders,
                  debugMode: P.debugMode,
                  subPixelRoundingForTransparency: P.subPixelRoundingForTransparency
                }), P.collectionMode && P.world.setAutoRefigureSizes(!1), P.navigator && (Ce = e.extend({}, Y.options, {
                  replace: !1,
                  // navigator already removed the layer, nothing to replace
                  originalTiledImage: ve,
                  tileSource: Y.tileSource
                }), P.navigator.addTiledImage(Ce)), P.world.addItem(ve, {
                  index: Y.options.index
                }), P._loadQueue.length === 0 && $(Y), P.world.getItemCount() === 1 && !P.preserveViewport && P.viewport.goHome(!0), Y.options.success && Y.options.success({
                  item: ve
                });
              }
            }
            o(this, v.tileSource, v, function(Y) {
              W.tileSource = Y, he();
            }, function(Y) {
              Y.options = v, X(Y), he();
            });
          },
          /**
           * Add a simple image to the viewer.
           * The options are the same as the ones in {@link OpenSeadragon.Viewer#addTiledImage}
           * except for options.tileSource which is replaced by options.url.
           * @function
           * @param {Object} options - See {@link OpenSeadragon.Viewer#addTiledImage}
           * for all the options
           * @param {String} options.url - The URL of the image to add.
           * @fires OpenSeadragon.World.event:add-item
           * @fires OpenSeadragon.Viewer.event:add-item-failed
           */
          addSimpleImage: function(v) {
            e.console.assert(v, "[Viewer.addSimpleImage] options is required"), e.console.assert(v.url, "[Viewer.addSimpleImage] options.url is required");
            var P = e.extend({}, v, {
              tileSource: {
                type: "image",
                url: v.url
              }
            });
            delete P.url, this.addTiledImage(P);
          },
          // deprecated
          addLayer: function(v) {
            var P = this;
            e.console.error("[Viewer.addLayer] this function is deprecated; use Viewer.addTiledImage() instead.");
            var W = e.extend({}, v, {
              success: function(X) {
                P.raiseEvent("add-layer", {
                  options: v,
                  drawer: X.item
                });
              },
              error: function(X) {
                P.raiseEvent("add-layer-failed", X);
              }
            });
            return this.addTiledImage(W), this;
          },
          // deprecated
          getLayerAtLevel: function(v) {
            return e.console.error("[Viewer.getLayerAtLevel] this function is deprecated; use World.getItemAt() instead."), this.world.getItemAt(v);
          },
          // deprecated
          getLevelOfLayer: function(v) {
            return e.console.error("[Viewer.getLevelOfLayer] this function is deprecated; use World.getIndexOfItem() instead."), this.world.getIndexOfItem(v);
          },
          // deprecated
          getLayersCount: function() {
            return e.console.error("[Viewer.getLayersCount] this function is deprecated; use World.getItemCount() instead."), this.world.getItemCount();
          },
          // deprecated
          setLayerLevel: function(v, P) {
            return e.console.error("[Viewer.setLayerLevel] this function is deprecated; use World.setItemIndex() instead."), this.world.setItemIndex(v, P);
          },
          // deprecated
          removeLayer: function(v) {
            return e.console.error("[Viewer.removeLayer] this function is deprecated; use World.removeItem() instead."), this.world.removeItem(v);
          },
          /**
           * Force the viewer to redraw its contents.
           * @returns {OpenSeadragon.Viewer} Chainable.
           */
          forceRedraw: function() {
            return t[this.hash].forceRedraw = !0, this;
          },
          /**
           * Force the viewer to reset its size to match its container.
           */
          forceResize: function() {
            t[this.hash].needsResize = !0, t[this.hash].forceResize = !0;
          },
          /**
           * @function
           * @returns {OpenSeadragon.Viewer} Chainable.
           */
          bindSequenceControls: function() {
            var v = e.delegate(this, C), P = e.delegate(this, E), W = e.delegate(this, this.goToNextPage), X = e.delegate(this, this.goToPreviousPage), $ = this.navImages, he = !0;
            return this.showSequenceControl && ((this.previousButton || this.nextButton) && (he = !1), this.previousButton = new e.Button({
              element: this.previousButton ? e.getElement(this.previousButton) : null,
              clickTimeThreshold: this.clickTimeThreshold,
              clickDistThreshold: this.clickDistThreshold,
              tooltip: e.getString("Tooltips.PreviousPage"),
              srcRest: be(this.prefixUrl, $.previous.REST),
              srcGroup: be(this.prefixUrl, $.previous.GROUP),
              srcHover: be(this.prefixUrl, $.previous.HOVER),
              srcDown: be(this.prefixUrl, $.previous.DOWN),
              onRelease: X,
              onFocus: v,
              onBlur: P
            }), this.nextButton = new e.Button({
              element: this.nextButton ? e.getElement(this.nextButton) : null,
              clickTimeThreshold: this.clickTimeThreshold,
              clickDistThreshold: this.clickDistThreshold,
              tooltip: e.getString("Tooltips.NextPage"),
              srcRest: be(this.prefixUrl, $.next.REST),
              srcGroup: be(this.prefixUrl, $.next.GROUP),
              srcHover: be(this.prefixUrl, $.next.HOVER),
              srcDown: be(this.prefixUrl, $.next.DOWN),
              onRelease: W,
              onFocus: v,
              onBlur: P
            }), this.navPrevNextWrap || this.previousButton.disable(), (!this.tileSources || !this.tileSources.length) && this.nextButton.disable(), he && (this.paging = new e.ButtonGroup({
              buttons: [
                this.previousButton,
                this.nextButton
              ],
              clickTimeThreshold: this.clickTimeThreshold,
              clickDistThreshold: this.clickDistThreshold
            }), this.pagingControl = this.paging.element, this.toolbar ? this.toolbar.addControl(
              this.pagingControl,
              { anchor: e.ControlAnchor.BOTTOM_RIGHT }
            ) : this.addControl(
              this.pagingControl,
              { anchor: this.sequenceControlAnchor || e.ControlAnchor.TOP_LEFT }
            ))), this;
          },
          /**
           * @function
           * @returns {OpenSeadragon.Viewer} Chainable.
           */
          bindStandardControls: function() {
            var v = e.delegate(this, Xt), P = e.delegate(this, _t), W = e.delegate(this, fe), X = e.delegate(this, St), $ = e.delegate(this, Qt), he = e.delegate(this, Ie), Y = e.delegate(this, Ct), ve = e.delegate(this, ji), Ce = e.delegate(this, ft), Se = e.delegate(this, Ft), ge = e.delegate(this, C), Le = e.delegate(this, E), y = this.navImages, _ = [], T = !0;
            return this.showNavigationControl && ((this.zoomInButton || this.zoomOutButton || this.homeButton || this.fullPageButton || this.rotateLeftButton || this.rotateRightButton || this.flipButton) && (T = !1), this.showZoomControl && (_.push(this.zoomInButton = new e.Button({
              element: this.zoomInButton ? e.getElement(this.zoomInButton) : null,
              clickTimeThreshold: this.clickTimeThreshold,
              clickDistThreshold: this.clickDistThreshold,
              tooltip: e.getString("Tooltips.ZoomIn"),
              srcRest: be(this.prefixUrl, y.zoomIn.REST),
              srcGroup: be(this.prefixUrl, y.zoomIn.GROUP),
              srcHover: be(this.prefixUrl, y.zoomIn.HOVER),
              srcDown: be(this.prefixUrl, y.zoomIn.DOWN),
              onPress: v,
              onRelease: P,
              onClick: W,
              onEnter: v,
              onExit: P,
              onFocus: ge,
              onBlur: Le
            })), _.push(this.zoomOutButton = new e.Button({
              element: this.zoomOutButton ? e.getElement(this.zoomOutButton) : null,
              clickTimeThreshold: this.clickTimeThreshold,
              clickDistThreshold: this.clickDistThreshold,
              tooltip: e.getString("Tooltips.ZoomOut"),
              srcRest: be(this.prefixUrl, y.zoomOut.REST),
              srcGroup: be(this.prefixUrl, y.zoomOut.GROUP),
              srcHover: be(this.prefixUrl, y.zoomOut.HOVER),
              srcDown: be(this.prefixUrl, y.zoomOut.DOWN),
              onPress: X,
              onRelease: P,
              onClick: $,
              onEnter: X,
              onExit: P,
              onFocus: ge,
              onBlur: Le
            }))), this.showHomeControl && _.push(this.homeButton = new e.Button({
              element: this.homeButton ? e.getElement(this.homeButton) : null,
              clickTimeThreshold: this.clickTimeThreshold,
              clickDistThreshold: this.clickDistThreshold,
              tooltip: e.getString("Tooltips.Home"),
              srcRest: be(this.prefixUrl, y.home.REST),
              srcGroup: be(this.prefixUrl, y.home.GROUP),
              srcHover: be(this.prefixUrl, y.home.HOVER),
              srcDown: be(this.prefixUrl, y.home.DOWN),
              onRelease: he,
              onFocus: ge,
              onBlur: Le
            })), this.showFullPageControl && _.push(this.fullPageButton = new e.Button({
              element: this.fullPageButton ? e.getElement(this.fullPageButton) : null,
              clickTimeThreshold: this.clickTimeThreshold,
              clickDistThreshold: this.clickDistThreshold,
              tooltip: e.getString("Tooltips.FullPage"),
              srcRest: be(this.prefixUrl, y.fullpage.REST),
              srcGroup: be(this.prefixUrl, y.fullpage.GROUP),
              srcHover: be(this.prefixUrl, y.fullpage.HOVER),
              srcDown: be(this.prefixUrl, y.fullpage.DOWN),
              onRelease: Y,
              onFocus: ge,
              onBlur: Le
            })), this.showRotationControl && (_.push(this.rotateLeftButton = new e.Button({
              element: this.rotateLeftButton ? e.getElement(this.rotateLeftButton) : null,
              clickTimeThreshold: this.clickTimeThreshold,
              clickDistThreshold: this.clickDistThreshold,
              tooltip: e.getString("Tooltips.RotateLeft"),
              srcRest: be(this.prefixUrl, y.rotateleft.REST),
              srcGroup: be(this.prefixUrl, y.rotateleft.GROUP),
              srcHover: be(this.prefixUrl, y.rotateleft.HOVER),
              srcDown: be(this.prefixUrl, y.rotateleft.DOWN),
              onRelease: ve,
              onFocus: ge,
              onBlur: Le
            })), _.push(this.rotateRightButton = new e.Button({
              element: this.rotateRightButton ? e.getElement(this.rotateRightButton) : null,
              clickTimeThreshold: this.clickTimeThreshold,
              clickDistThreshold: this.clickDistThreshold,
              tooltip: e.getString("Tooltips.RotateRight"),
              srcRest: be(this.prefixUrl, y.rotateright.REST),
              srcGroup: be(this.prefixUrl, y.rotateright.GROUP),
              srcHover: be(this.prefixUrl, y.rotateright.HOVER),
              srcDown: be(this.prefixUrl, y.rotateright.DOWN),
              onRelease: Ce,
              onFocus: ge,
              onBlur: Le
            }))), this.showFlipControl && _.push(this.flipButton = new e.Button({
              element: this.flipButton ? e.getElement(this.flipButton) : null,
              clickTimeThreshold: this.clickTimeThreshold,
              clickDistThreshold: this.clickDistThreshold,
              tooltip: e.getString("Tooltips.Flip"),
              srcRest: be(this.prefixUrl, y.flip.REST),
              srcGroup: be(this.prefixUrl, y.flip.GROUP),
              srcHover: be(this.prefixUrl, y.flip.HOVER),
              srcDown: be(this.prefixUrl, y.flip.DOWN),
              onRelease: Se,
              onFocus: ge,
              onBlur: Le
            })), T ? (this.buttonGroup = new e.ButtonGroup({
              buttons: _,
              clickTimeThreshold: this.clickTimeThreshold,
              clickDistThreshold: this.clickDistThreshold
            }), this.navControl = this.buttonGroup.element, this.addHandler("open", e.delegate(this, kt)), this.toolbar ? this.toolbar.addControl(
              this.navControl,
              { anchor: this.navigationControlAnchor || e.ControlAnchor.TOP_LEFT }
            ) : this.addControl(
              this.navControl,
              { anchor: this.navigationControlAnchor || e.ControlAnchor.TOP_LEFT }
            )) : this.customButtons = _), this;
          },
          /**
           * Gets the active page of a sequence
           * @function
           * @returns {Number}
           */
          currentPage: function() {
            return this._sequenceIndex;
          },
          /**
           * @function
           * @returns {OpenSeadragon.Viewer} Chainable.
           * @fires OpenSeadragon.Viewer.event:page
           */
          goToPage: function(v) {
            return this.tileSources && v >= 0 && v < this.tileSources.length && (this._sequenceIndex = v, this._updateSequenceButtons(v), this.open(this.tileSources[v]), this.referenceStrip && this.referenceStrip.setFocus(v), this.raiseEvent("page", { page: v })), this;
          },
          /**
            * Adds an html element as an overlay to the current viewport.  Useful for
            * highlighting words or areas of interest on an image or other zoomable
            * interface. The overlays added via this method are removed when the viewport
            * is closed which include when changing page.
            * @method
            * @param {Element|String|Object} element - A reference to an element or an id for
            *      the element which will be overlaid. Or an Object specifying the configuration for the overlay.
            *      If using an object, see {@link OpenSeadragon.Overlay} for a list of
            *      all available options.
            * @param {OpenSeadragon.Point|OpenSeadragon.Rect} location - The point or
            *      rectangle which will be overlaid. This is a viewport relative location.
            * @param {OpenSeadragon.Placement} [placement=OpenSeadragon.Placement.TOP_LEFT] - The position of the
            *      viewport which the location coordinates will be treated as relative
            *      to.
            * @param {function} [onDraw] - If supplied the callback is called when the overlay
            *      needs to be drawn. It is the responsibility of the callback to do any drawing/positioning.
            *      It is passed position, size and element.
            * @returns {OpenSeadragon.Viewer} Chainable.
            * @fires OpenSeadragon.Viewer.event:add-overlay
            */
          addOverlay: function(v, P, W, X) {
            var $;
            if (e.isPlainObject(v) ? $ = v : $ = {
              element: v,
              location: P,
              placement: W,
              onDraw: X
            }, v = e.getElement($.element), c(this.currentOverlays, v) >= 0)
              return this;
            var he = a(this, $);
            return this.currentOverlays.push(he), he.drawHTML(this.overlaysContainer, this.viewport), this.raiseEvent("add-overlay", {
              element: v,
              location: $.location,
              placement: $.placement
            }), this;
          },
          /**
           * Updates the overlay represented by the reference to the element or
           * element id moving it to the new location, relative to the new placement.
           * @method
           * @param {Element|String} element - A reference to an element or an id for
           *      the element which is overlaid.
           * @param {OpenSeadragon.Point|OpenSeadragon.Rect} location - The point or
           *      rectangle which will be overlaid. This is a viewport relative location.
           * @param {OpenSeadragon.Placement} [placement=OpenSeadragon.Placement.TOP_LEFT] - The position of the
           *      viewport which the location coordinates will be treated as relative
           *      to.
           * @returns {OpenSeadragon.Viewer} Chainable.
           * @fires OpenSeadragon.Viewer.event:update-overlay
           */
          updateOverlay: function(v, P, W) {
            var X;
            return v = e.getElement(v), X = c(this.currentOverlays, v), X >= 0 && (this.currentOverlays[X].update(P, W), t[this.hash].forceRedraw = !0, this.raiseEvent("update-overlay", {
              element: v,
              location: P,
              placement: W
            })), this;
          },
          /**
           * Removes an overlay identified by the reference element or element id
           * and schedules an update.
           * @method
           * @param {Element|String} element - A reference to the element or an
           *      element id which represent the ovelay content to be removed.
           * @returns {OpenSeadragon.Viewer} Chainable.
           * @fires OpenSeadragon.Viewer.event:remove-overlay
           */
          removeOverlay: function(v) {
            var P;
            return v = e.getElement(v), P = c(this.currentOverlays, v), P >= 0 && (this.currentOverlays[P].destroy(), this.currentOverlays.splice(P, 1), t[this.hash].forceRedraw = !0, this.raiseEvent("remove-overlay", {
              element: v
            })), this;
          },
          /**
           * Removes all currently configured Overlays from this Viewer and schedules
           * an update.
           * @method
           * @returns {OpenSeadragon.Viewer} Chainable.
           * @fires OpenSeadragon.Viewer.event:clear-overlay
           */
          clearOverlays: function() {
            for (; this.currentOverlays.length > 0; )
              this.currentOverlays.pop().destroy();
            return t[this.hash].forceRedraw = !0, this.raiseEvent("clear-overlay", {}), this;
          },
          /**
          * Finds an overlay identified by the reference element or element id
          * and returns it as an object, return null if not found.
          * @method
          * @param {Element|String} element - A reference to the element or an
          *      element id which represents the overlay content.
          * @returns {OpenSeadragon.Overlay} the matching overlay or null if none found.
          */
          getOverlayById: function(v) {
            var P;
            return v = e.getElement(v), P = c(this.currentOverlays, v), P >= 0 ? this.currentOverlays[P] : null;
          },
          /**
           * Updates the sequence buttons.
           * @function OpenSeadragon.Viewer.prototype._updateSequenceButtons
           * @private
           * @param {Number} Sequence Value
           */
          _updateSequenceButtons: function(v) {
            this.nextButton && (!this.tileSources || this.tileSources.length - 1 === v ? this.navPrevNextWrap || this.nextButton.disable() : this.nextButton.enable()), this.previousButton && (v > 0 ? this.previousButton.enable() : this.navPrevNextWrap || this.previousButton.disable());
          },
          /**
           * Display a message in the viewport
           * @function OpenSeadragon.Viewer.prototype._showMessage
           * @private
           * @param {String} text message
           */
          _showMessage: function(v) {
            this._hideMessage();
            var P = e.makeNeutralElement("div");
            P.appendChild(document.createTextNode(v)), this.messageDiv = e.makeCenteredNode(P), e.addClass(this.messageDiv, "openseadragon-message"), this.container.appendChild(this.messageDiv);
          },
          /**
           * Hide any currently displayed viewport message
           * @function OpenSeadragon.Viewer.prototype._hideMessage
           * @private
           */
          _hideMessage: function() {
            var v = this.messageDiv;
            v && (v.parentNode.removeChild(v), delete this.messageDiv);
          },
          /**
           * Gets this viewer's gesture settings for the given pointer device type.
           * @method
           * @param {String} type - The pointer device type to get the gesture settings for ("mouse", "touch", "pen", etc.).
           * @returns {OpenSeadragon.GestureSettings}
           */
          gestureSettingsByDeviceType: function(v) {
            switch (v) {
              case "mouse":
                return this.gestureSettingsMouse;
              case "touch":
                return this.gestureSettingsTouch;
              case "pen":
                return this.gestureSettingsPen;
              default:
                return this.gestureSettingsUnknown;
            }
          },
          // private
          _drawOverlays: function() {
            var v, P = this.currentOverlays.length;
            for (v = 0; v < P; v++)
              this.currentOverlays[v].drawHTML(this.overlaysContainer, this.viewport);
          },
          /**
           * Cancel the "in flight" images.
           */
          _cancelPendingImages: function() {
            this._loadQueue = [];
          },
          /**
           * Removes the reference strip and disables displaying it.
           * @function
           */
          removeReferenceStrip: function() {
            this.showReferenceStrip = !1, this.referenceStrip && (this.referenceStrip.destroy(), this.referenceStrip = null);
          },
          /**
           * Enables and displays the reference strip based on the currently set tileSources.
           * Works only when the Viewer has sequenceMode set to true.
           * @function
           */
          addReferenceStrip: function() {
            if (this.showReferenceStrip = !0, this.sequenceMode) {
              if (this.referenceStrip)
                return;
              this.tileSources.length && this.tileSources.length > 1 && (this.referenceStrip = new e.ReferenceStrip({
                id: this.referenceStripElement,
                position: this.referenceStripPosition,
                sizeRatio: this.referenceStripSizeRatio,
                scroll: this.referenceStripScroll,
                height: this.referenceStripHeight,
                width: this.referenceStripWidth,
                tileSources: this.tileSources,
                prefixUrl: this.prefixUrl,
                viewer: this
              }), this.referenceStrip.setFocus(this._sequenceIndex));
            } else
              e.console.warn('Attempting to display a reference strip while "sequenceMode" is off.');
          },
          /**
           * Adds _updatePixelDensityRatio to the window resize event.
           * @private
           */
          _addUpdatePixelDensityRatioEvent: function() {
            this._updatePixelDensityRatioBind = this._updatePixelDensityRatio.bind(this), e.addEvent(window, "resize", this._updatePixelDensityRatioBind);
          },
          /**
           * Removes _updatePixelDensityRatio from the window resize event.
           * @private
           */
          _removeUpdatePixelDensityRatioEvent: function() {
            e.removeEvent(window, "resize", this._updatePixelDensityRatioBind);
          },
          /**
           * Update pixel density ratio and forces a resize operation.
           * @private
           */
          _updatePixelDensityRatio: function() {
            var v = e.pixelDensityRatio, P = e.getCurrentPixelDensityRatio();
            v !== P && (e.pixelDensityRatio = P, this.forceResize());
          },
          /**
           * Sets the image source to the source with index equal to
           * currentIndex - 1. Changes current image in sequence mode.
           * If specified, wraps around (see navPrevNextWrap in
           * {@link OpenSeadragon.Options})
           *
           * @method
           */
          goToPreviousPage: function() {
            var v = this._sequenceIndex - 1;
            this.navPrevNextWrap && v < 0 && (v += this.tileSources.length), this.goToPage(v);
          },
          /**
           * Sets the image source to the source with index equal to
           * currentIndex + 1. Changes current image in sequence mode.
           * If specified, wraps around (see navPrevNextWrap in
           * {@link OpenSeadragon.Options})
           *
           * @method
           */
          goToNextPage: function() {
            var v = this._sequenceIndex + 1;
            this.navPrevNextWrap && v >= this.tileSources.length && (v = 0), this.goToPage(v);
          },
          isAnimating: function() {
            return t[this.hash].animating;
          }
        }
      );
      function r(v) {
        return v = e.getElement(v), new e.Point(
          v.clientWidth === 0 ? 1 : v.clientWidth,
          v.clientHeight === 0 ? 1 : v.clientHeight
        );
      }
      function o(v, P, W, X, $) {
        var he = v;
        if (e.type(P) === "string") {
          if (P.match(/^\s*<.*>\s*$/))
            P = e.parseXml(P);
          else if (P.match(/^\s*[{[].*[}\]]\s*$/))
            try {
              var Y = e.parseJSON(P);
              P = Y;
            } catch {
            }
        }
        function ve(Ce, Se) {
          Ce.ready ? X(Ce) : (Ce.addHandler("ready", function() {
            X(Ce);
          }), Ce.addHandler("open-failed", function(ge) {
            $({
              message: ge.message,
              source: Se
            });
          }));
        }
        setTimeout(function() {
          if (e.type(P) === "string")
            P = new e.TileSource({
              url: P,
              crossOriginPolicy: W.crossOriginPolicy !== void 0 ? W.crossOriginPolicy : v.crossOriginPolicy,
              ajaxWithCredentials: v.ajaxWithCredentials,
              ajaxHeaders: W.ajaxHeaders ? W.ajaxHeaders : v.ajaxHeaders,
              splitHashDataForPost: v.splitHashDataForPost,
              success: function(Le) {
                X(Le.tileSource);
              }
            }), P.addHandler("open-failed", function(Le) {
              $(Le);
            });
          else if (e.isPlainObject(P) || P.nodeType)
            if (P.crossOriginPolicy === void 0 && (W.crossOriginPolicy !== void 0 || v.crossOriginPolicy !== void 0) && (P.crossOriginPolicy = W.crossOriginPolicy !== void 0 ? W.crossOriginPolicy : v.crossOriginPolicy), P.ajaxWithCredentials === void 0 && (P.ajaxWithCredentials = v.ajaxWithCredentials), e.isFunction(P.getTileUrl)) {
              var Ce = new e.TileSource(P);
              Ce.getTileUrl = P.getTileUrl, X(Ce);
            } else {
              var Se = e.TileSource.determineType(he, P);
              if (!Se) {
                $({
                  message: "Unable to load TileSource",
                  source: P
                });
                return;
              }
              var ge = Se.prototype.configure.apply(he, [P]);
              ve(new Se(ge), P);
            }
          else
            ve(P, P);
        });
      }
      function a(v, P) {
        if (P instanceof e.Overlay)
          return P;
        var W = null;
        if (P.element)
          W = e.getElement(P.element);
        else {
          var X = P.id ? P.id : "openseadragon-overlay-" + Math.floor(Math.random() * 1e7);
          W = e.getElement(P.id), W || (W = document.createElement("a"), W.href = "#/overlay/" + X), W.id = X, e.addClass(
            W,
            P.className ? P.className : "openseadragon-overlay"
          );
        }
        var $ = P.location, he = P.width, Y = P.height;
        if (!$) {
          var ve = P.x, Ce = P.y;
          if (P.px !== void 0) {
            var Se = v.viewport.imageToViewportRectangle(new e.Rect(
              P.px,
              P.py,
              he || 0,
              Y || 0
            ));
            ve = Se.x, Ce = Se.y, he = he !== void 0 ? Se.width : void 0, Y = Y !== void 0 ? Se.height : void 0;
          }
          $ = new e.Point(ve, Ce);
        }
        var ge = P.placement;
        return ge && e.type(ge) === "string" && (ge = e.Placement[P.placement.toUpperCase()]), new e.Overlay({
          element: W,
          location: $,
          placement: ge,
          onDraw: P.onDraw,
          checkResize: P.checkResize,
          width: he,
          height: Y,
          rotationMode: P.rotationMode
        });
      }
      function c(v, P) {
        var W;
        for (W = v.length - 1; W >= 0; W--)
          if (v[W].element === P)
            return W;
        return -1;
      }
      function u(v, P) {
        return e.requestAnimationFrame(function() {
          P(v);
        });
      }
      function h(v) {
        e.requestAnimationFrame(function() {
          g(v);
        });
      }
      function f(v) {
        v.autoHideControls && (v.controlsShouldFade = !0, v.controlsFadeBeginTime = e.now() + v.controlsFadeDelay, window.setTimeout(function() {
          h(v);
        }, v.controlsFadeDelay));
      }
      function g(v) {
        var P, W, X, $;
        if (v.controlsShouldFade) {
          for (P = e.now(), W = P - v.controlsFadeBeginTime, X = 1 - W / v.controlsFadeLength, X = Math.min(1, X), X = Math.max(0, X), $ = v.controls.length - 1; $ >= 0; $--)
            v.controls[$].autoFade && v.controls[$].setOpacity(X);
          X > 0 && h(v);
        }
      }
      function x(v) {
        var P;
        for (v.controlsShouldFade = !1, P = v.controls.length - 1; P >= 0; P--)
          v.controls[P].setOpacity(1);
      }
      function C() {
        x(this);
      }
      function E() {
        f(this);
      }
      function R(v) {
        var P = {
          tracker: v.eventSource,
          position: v.position,
          originalEvent: v.originalEvent,
          preventDefault: v.preventDefault
        };
        this.raiseEvent("canvas-contextmenu", P), v.preventDefault = P.preventDefault;
      }
      function D(v) {
        var P = {
          originalEvent: v.originalEvent,
          preventDefaultAction: !1,
          preventVerticalPan: v.preventVerticalPan || !this.panVertical,
          preventHorizontalPan: v.preventHorizontalPan || !this.panHorizontal
        };
        if (this.raiseEvent("canvas-key", P), !P.preventDefaultAction && !v.ctrl && !v.alt && !v.meta)
          switch (v.keyCode) {
            case 38:
              P.preventVerticalPan || (v.shift ? this.viewport.zoomBy(1.1) : this.viewport.panBy(this.viewport.deltaPointsFromPixels(new e.Point(0, -this.pixelsPerArrowPress))), this.viewport.applyConstraints()), v.preventDefault = !0;
              break;
            case 40:
              P.preventVerticalPan || (v.shift ? this.viewport.zoomBy(0.9) : this.viewport.panBy(this.viewport.deltaPointsFromPixels(new e.Point(0, this.pixelsPerArrowPress))), this.viewport.applyConstraints()), v.preventDefault = !0;
              break;
            case 37:
              P.preventHorizontalPan || (this.viewport.panBy(this.viewport.deltaPointsFromPixels(new e.Point(-this.pixelsPerArrowPress, 0))), this.viewport.applyConstraints()), v.preventDefault = !0;
              break;
            case 39:
              P.preventHorizontalPan || (this.viewport.panBy(this.viewport.deltaPointsFromPixels(new e.Point(this.pixelsPerArrowPress, 0))), this.viewport.applyConstraints()), v.preventDefault = !0;
              break;
            case 187:
              this.viewport.zoomBy(1.1), this.viewport.applyConstraints(), v.preventDefault = !0;
              break;
            case 189:
              this.viewport.zoomBy(0.9), this.viewport.applyConstraints(), v.preventDefault = !0;
              break;
            case 48:
              this.viewport.goHome(), this.viewport.applyConstraints(), v.preventDefault = !0;
              break;
            case 87:
              P.preventVerticalPan || (v.shift ? this.viewport.zoomBy(1.1) : this.viewport.panBy(this.viewport.deltaPointsFromPixels(new e.Point(0, -40))), this.viewport.applyConstraints()), v.preventDefault = !0;
              break;
            case 83:
              P.preventVerticalPan || (v.shift ? this.viewport.zoomBy(0.9) : this.viewport.panBy(this.viewport.deltaPointsFromPixels(new e.Point(0, 40))), this.viewport.applyConstraints()), v.preventDefault = !0;
              break;
            case 65:
              P.preventHorizontalPan || (this.viewport.panBy(this.viewport.deltaPointsFromPixels(new e.Point(-40, 0))), this.viewport.applyConstraints()), v.preventDefault = !0;
              break;
            case 68:
              P.preventHorizontalPan || (this.viewport.panBy(this.viewport.deltaPointsFromPixels(new e.Point(40, 0))), this.viewport.applyConstraints()), v.preventDefault = !0;
              break;
            case 82:
              v.shift ? this.viewport.flipped ? this.viewport.setRotation(this.viewport.getRotation() + this.rotationIncrement) : this.viewport.setRotation(this.viewport.getRotation() - this.rotationIncrement) : this.viewport.flipped ? this.viewport.setRotation(this.viewport.getRotation() - this.rotationIncrement) : this.viewport.setRotation(this.viewport.getRotation() + this.rotationIncrement), this.viewport.applyConstraints(), v.preventDefault = !0;
              break;
            case 70:
              this.viewport.toggleFlip(), v.preventDefault = !0;
              break;
            case 74:
              this.goToPreviousPage();
              break;
            case 75:
              this.goToNextPage();
              break;
            default:
              v.preventDefault = !1;
              break;
          }
        else
          v.preventDefault = !1;
      }
      function U(v) {
        var P = {
          originalEvent: v.originalEvent
        };
        this.raiseEvent("canvas-key-press", P);
      }
      function Z(v) {
        var P, W = document.activeElement === this.canvas;
        W || this.canvas.focus(), this.viewport.flipped && (v.position.x = this.viewport.getContainerSize().x - v.position.x);
        var X = {
          tracker: v.eventSource,
          position: v.position,
          quick: v.quick,
          shift: v.shift,
          originalEvent: v.originalEvent,
          originalTarget: v.originalTarget,
          preventDefaultAction: !1
        };
        this.raiseEvent("canvas-click", X), !X.preventDefaultAction && this.viewport && v.quick && (P = this.gestureSettingsByDeviceType(v.pointerType), P.clickToZoom === !0 && (this.viewport.zoomBy(
          v.shift ? 1 / this.zoomPerClick : this.zoomPerClick,
          P.zoomToRefPoint ? this.viewport.pointFromPixel(v.position, !0) : null
        ), this.viewport.applyConstraints()), P.dblClickDragToZoom && (t[this.hash].draggingToZoom === !0 ? (t[this.hash].lastClickTime = null, t[this.hash].draggingToZoom = !1) : t[this.hash].lastClickTime = e.now()));
      }
      function ce(v) {
        var P, W = {
          tracker: v.eventSource,
          position: v.position,
          shift: v.shift,
          originalEvent: v.originalEvent,
          preventDefaultAction: !1
        };
        this.raiseEvent("canvas-double-click", W), !W.preventDefaultAction && this.viewport && (P = this.gestureSettingsByDeviceType(v.pointerType), P.dblClickToZoom && (this.viewport.zoomBy(
          v.shift ? 1 / this.zoomPerClick : this.zoomPerClick,
          P.zoomToRefPoint ? this.viewport.pointFromPixel(v.position, !0) : null
        ), this.viewport.applyConstraints()));
      }
      function re(v) {
        var P, W = {
          tracker: v.eventSource,
          pointerType: v.pointerType,
          position: v.position,
          delta: v.delta,
          speed: v.speed,
          direction: v.direction,
          shift: v.shift,
          originalEvent: v.originalEvent,
          preventDefaultAction: !1
        };
        if (this.raiseEvent("canvas-drag", W), P = this.gestureSettingsByDeviceType(v.pointerType), !W.preventDefaultAction && this.viewport) {
          if (P.dblClickDragToZoom && t[this.hash].draggingToZoom) {
            var X = Math.pow(this.zoomPerDblClickDrag, v.delta.y / 50);
            this.viewport.zoomBy(X);
          } else if (P.dragToPan && !t[this.hash].draggingToZoom) {
            if (this.panHorizontal || (v.delta.x = 0), this.panVertical || (v.delta.y = 0), this.viewport.flipped && (v.delta.x = -v.delta.x), this.constrainDuringPan) {
              var $ = this.viewport.deltaPointsFromPixels(v.delta.negate());
              this.viewport.centerSpringX.target.value += $.x, this.viewport.centerSpringY.target.value += $.y;
              var he = this.viewport.getConstrainedBounds();
              this.viewport.centerSpringX.target.value -= $.x, this.viewport.centerSpringY.target.value -= $.y, he.xConstrained && (v.delta.x = 0), he.yConstrained && (v.delta.y = 0);
            }
            this.viewport.panBy(this.viewport.deltaPointsFromPixels(v.delta.negate()), P.flickEnabled && !this.constrainDuringPan);
          }
        }
      }
      function ue(v) {
        var P, W = {
          tracker: v.eventSource,
          pointerType: v.pointerType,
          position: v.position,
          speed: v.speed,
          direction: v.direction,
          shift: v.shift,
          originalEvent: v.originalEvent,
          preventDefaultAction: !1
        };
        if (this.raiseEvent("canvas-drag-end", W), P = this.gestureSettingsByDeviceType(v.pointerType), !W.preventDefaultAction && this.viewport) {
          if (!t[this.hash].draggingToZoom && P.dragToPan && P.flickEnabled && v.speed >= P.flickMinSpeed) {
            var X = 0;
            this.panHorizontal && (X = P.flickMomentum * v.speed * Math.cos(v.direction));
            var $ = 0;
            this.panVertical && ($ = P.flickMomentum * v.speed * Math.sin(v.direction));
            var he = this.viewport.pixelFromPoint(
              this.viewport.getCenter(!0)
            ), Y = this.viewport.pointFromPixel(
              new e.Point(he.x - X, he.y - $)
            );
            this.viewport.panTo(Y, !1);
          }
          this.viewport.applyConstraints();
        }
        P.dblClickDragToZoom && t[this.hash].draggingToZoom === !0 && (t[this.hash].draggingToZoom = !1);
      }
      function me(v) {
        this.raiseEvent("canvas-enter", {
          tracker: v.eventSource,
          pointerType: v.pointerType,
          position: v.position,
          buttons: v.buttons,
          pointers: v.pointers,
          insideElementPressed: v.insideElementPressed,
          buttonDownAny: v.buttonDownAny,
          originalEvent: v.originalEvent
        });
      }
      function Te(v) {
        this.raiseEvent("canvas-exit", {
          tracker: v.eventSource,
          pointerType: v.pointerType,
          position: v.position,
          buttons: v.buttons,
          pointers: v.pointers,
          insideElementPressed: v.insideElementPressed,
          buttonDownAny: v.buttonDownAny,
          originalEvent: v.originalEvent
        });
      }
      function Re(v) {
        var P;
        if (this.raiseEvent("canvas-press", {
          tracker: v.eventSource,
          pointerType: v.pointerType,
          position: v.position,
          insideElementPressed: v.insideElementPressed,
          insideElementReleased: v.insideElementReleased,
          originalEvent: v.originalEvent
        }), P = this.gestureSettingsByDeviceType(v.pointerType), P.dblClickDragToZoom) {
          var W = t[this.hash].lastClickTime, X = e.now();
          if (W === null)
            return;
          X - W < this.dblClickTimeThreshold && (t[this.hash].draggingToZoom = !0), t[this.hash].lastClickTime = null;
        }
      }
      function He(v) {
        this.raiseEvent("canvas-release", {
          tracker: v.eventSource,
          pointerType: v.pointerType,
          position: v.position,
          insideElementPressed: v.insideElementPressed,
          insideElementReleased: v.insideElementReleased,
          originalEvent: v.originalEvent
        });
      }
      function Fe(v) {
        this.raiseEvent("canvas-nonprimary-press", {
          tracker: v.eventSource,
          position: v.position,
          pointerType: v.pointerType,
          button: v.button,
          buttons: v.buttons,
          originalEvent: v.originalEvent
        });
      }
      function _e(v) {
        this.raiseEvent("canvas-nonprimary-release", {
          tracker: v.eventSource,
          position: v.position,
          pointerType: v.pointerType,
          button: v.button,
          buttons: v.buttons,
          originalEvent: v.originalEvent
        });
      }
      function Ae(v) {
        var P, W, X, $, he = {
          tracker: v.eventSource,
          pointerType: v.pointerType,
          gesturePoints: v.gesturePoints,
          lastCenter: v.lastCenter,
          center: v.center,
          lastDistance: v.lastDistance,
          distance: v.distance,
          shift: v.shift,
          originalEvent: v.originalEvent,
          preventDefaultPanAction: !1,
          preventDefaultZoomAction: !1,
          preventDefaultRotateAction: !1
        };
        if (this.raiseEvent("canvas-pinch", he), this.viewport && (P = this.gestureSettingsByDeviceType(v.pointerType), P.pinchToZoom && (!he.preventDefaultPanAction || !he.preventDefaultZoomAction) && (W = this.viewport.pointFromPixel(v.center, !0), P.zoomToRefPoint && !he.preventDefaultPanAction && (X = this.viewport.pointFromPixel(v.lastCenter, !0), $ = X.minus(W), this.panHorizontal || ($.x = 0), this.panVertical || ($.y = 0), this.viewport.panBy($, !0)), he.preventDefaultZoomAction || this.viewport.zoomBy(v.distance / v.lastDistance, W, !0), this.viewport.applyConstraints()), P.pinchRotate && !he.preventDefaultRotateAction)) {
          var Y = Math.atan2(
            v.gesturePoints[0].currentPos.y - v.gesturePoints[1].currentPos.y,
            v.gesturePoints[0].currentPos.x - v.gesturePoints[1].currentPos.x
          ), ve = Math.atan2(
            v.gesturePoints[0].lastPos.y - v.gesturePoints[1].lastPos.y,
            v.gesturePoints[0].lastPos.x - v.gesturePoints[1].lastPos.x
          );
          W = this.viewport.pointFromPixel(v.center, !0), this.viewport.rotateTo(this.viewport.getRotation(!0) + (Y - ve) * (180 / Math.PI), W, !0);
        }
      }
      function Je(v) {
        this.raiseEvent("canvas-focus", {
          tracker: v.eventSource,
          originalEvent: v.originalEvent
        });
      }
      function Ge(v) {
        this.raiseEvent("canvas-blur", {
          tracker: v.eventSource,
          originalEvent: v.originalEvent
        });
      }
      function qe(v) {
        var P, W, X, $, he;
        $ = e.now(), he = $ - this._lastScrollTime, he > this.minScrollDeltaTime ? (this._lastScrollTime = $, P = {
          tracker: v.eventSource,
          position: v.position,
          scroll: v.scroll,
          shift: v.shift,
          originalEvent: v.originalEvent,
          preventDefaultAction: !1,
          preventDefault: !0
        }, this.raiseEvent("canvas-scroll", P), !P.preventDefaultAction && this.viewport && (this.viewport.flipped && (v.position.x = this.viewport.getContainerSize().x - v.position.x), W = this.gestureSettingsByDeviceType(v.pointerType), W.scrollToZoom && (X = Math.pow(this.zoomPerScroll, v.scroll), this.viewport.zoomBy(
          X,
          W.zoomToRefPoint ? this.viewport.pointFromPixel(v.position, !0) : null
        ), this.viewport.applyConstraints())), v.preventDefault = P.preventDefault) : v.preventDefault = !0;
      }
      function nt(v) {
        t[this.hash].mouseInside = !0, x(this), this.raiseEvent("container-enter", {
          tracker: v.eventSource,
          pointerType: v.pointerType,
          position: v.position,
          buttons: v.buttons,
          pointers: v.pointers,
          insideElementPressed: v.insideElementPressed,
          buttonDownAny: v.buttonDownAny,
          originalEvent: v.originalEvent
        });
      }
      function Ve(v) {
        v.pointers < 1 && (t[this.hash].mouseInside = !1, t[this.hash].animating || f(this)), this.raiseEvent("container-exit", {
          tracker: v.eventSource,
          pointerType: v.pointerType,
          position: v.position,
          buttons: v.buttons,
          pointers: v.pointers,
          insideElementPressed: v.insideElementPressed,
          buttonDownAny: v.buttonDownAny,
          originalEvent: v.originalEvent
        });
      }
      function ot(v) {
        Yt(v), v.isOpen() ? v._updateRequestId = u(v, ot) : v._updateRequestId = !1;
      }
      function $e(v, P) {
        var W = v.viewport, X = W.getZoom(), $ = W.getCenter();
        W.resize(P, v.preserveImageSizeOnResize), W.panTo($, !0);
        var he;
        if (v.preserveImageSizeOnResize)
          he = t[v.hash].prevContainerSize.x / P.x;
        else {
          var Y = new e.Point(0, 0), ve = new e.Point(t[v.hash].prevContainerSize.x, t[v.hash].prevContainerSize.y).distanceTo(Y), Ce = new e.Point(P.x, P.y).distanceTo(Y);
          he = Ce / ve * t[v.hash].prevContainerSize.x / P.x;
        }
        W.zoomTo(X * he, null, !0), t[v.hash].prevContainerSize = P, t[v.hash].forceRedraw = !0, t[v.hash].needsResize = !1, t[v.hash].forceResize = !1;
      }
      function Yt(v) {
        if (!(v._opening || !t[v.hash])) {
          if (v.autoResize || t[v.hash].forceResize) {
            var P;
            if (v._autoResizePolling) {
              P = r(v.container);
              var W = t[v.hash].prevContainerSize;
              P.equals(W) || (t[v.hash].needsResize = !0);
            }
            t[v.hash].needsResize && $e(v, P || r(v.container));
          }
          var X = v.viewport.update(), $ = v.world.update(X) || X;
          X && v.raiseEvent("viewport-change"), v.referenceStrip && ($ = v.referenceStrip.update(v.viewport) || $);
          var he = t[v.hash].animating;
          !he && $ && (v.raiseEvent("animation-start"), x(v));
          var Y = he && !$;
          Y && (t[v.hash].animating = !1), ($ || Y || t[v.hash].forceRedraw || v.world.needsDraw()) && (Wi(v), v._drawOverlays(), v.navigator && v.navigator.update(v.viewport), t[v.hash].forceRedraw = !1, $ && v.raiseEvent("animation")), Y && (v.raiseEvent("animation-finish"), t[v.hash].mouseInside || f(v)), t[v.hash].animating = $;
        }
      }
      function Wi(v) {
        v.imageLoader.clear(), v.world.draw(), v.raiseEvent("update-viewport", {});
      }
      function be(v, P) {
        return v ? v + P : P;
      }
      function Xt() {
        t[this.hash].lastZoomTime = e.now(), t[this.hash].zoomFactor = this.zoomPerSecond, t[this.hash].zooming = !0, xt(this);
      }
      function St() {
        t[this.hash].lastZoomTime = e.now(), t[this.hash].zoomFactor = 1 / this.zoomPerSecond, t[this.hash].zooming = !0, xt(this);
      }
      function _t() {
        t[this.hash].zooming = !1;
      }
      function xt(v) {
        e.requestAnimationFrame(e.delegate(v, vi));
      }
      function vi() {
        var v, P, W;
        t[this.hash].zooming && this.viewport && (v = e.now(), P = v - t[this.hash].lastZoomTime, W = Math.pow(t[this.hash].zoomFactor, P / 1e3), this.viewport.zoomBy(W), this.viewport.applyConstraints(), t[this.hash].lastZoomTime = v, xt(this));
      }
      function fe() {
        this.viewport && (t[this.hash].zooming = !1, this.viewport.zoomBy(
          this.zoomPerClick / 1
        ), this.viewport.applyConstraints());
      }
      function Qt() {
        this.viewport && (t[this.hash].zooming = !1, this.viewport.zoomBy(
          1 / this.zoomPerClick
        ), this.viewport.applyConstraints());
      }
      function kt() {
        this.buttonGroup && (this.buttonGroup.emulateEnter(), this.buttonGroup.emulateLeave());
      }
      function Ie() {
        this.viewport && this.viewport.goHome();
      }
      function Ct() {
        this.isFullPage() && !e.isFullScreen() ? this.setFullPage(!1) : this.setFullScreen(!this.isFullPage()), this.buttonGroup && this.buttonGroup.emulateLeave(), this.fullPageButton.element.focus(), this.viewport && this.viewport.applyConstraints();
      }
      function ji() {
        if (this.viewport) {
          var v = this.viewport.getRotation();
          this.viewport.flipped ? v += this.rotationIncrement : v -= this.rotationIncrement, this.viewport.setRotation(v);
        }
      }
      function ft() {
        if (this.viewport) {
          var v = this.viewport.getRotation();
          this.viewport.flipped ? v -= this.rotationIncrement : v += this.rotationIncrement, this.viewport.setRotation(v);
        }
      }
      function Ft() {
        this.viewport.toggleFlip();
      }
      e.determineDrawer = function(v) {
        for (let P in n) {
          const W = n[P], X = W.prototype;
          if (X && X instanceof n.DrawerBase && e.isFunction(X.getType) && X.getType.call(W) === v)
            return W;
        }
        return null;
      };
    })(n), (function(e) {
      e.Navigator = function(u) {
        var h = u.viewer, f = this, g, x;
        u.element || u.id ? (u.element ? (u.id && e.console.warn("Given option.id for Navigator was ignored since option.element was provided and is being used instead."), u.element.id ? u.id = u.element.id : u.id = "navigator-" + e.now(), this.element = u.element) : this.element = document.getElementById(u.id), u.controlOptions = {
          anchor: e.ControlAnchor.NONE,
          attachToViewer: !1,
          autoFade: !1
        }) : (u.id = "navigator-" + e.now(), this.element = e.makeNeutralElement("div"), u.controlOptions = {
          anchor: e.ControlAnchor.TOP_RIGHT,
          attachToViewer: !0,
          autoFade: u.autoFade
        }, u.position && (u.position === "BOTTOM_RIGHT" ? u.controlOptions.anchor = e.ControlAnchor.BOTTOM_RIGHT : u.position === "BOTTOM_LEFT" ? u.controlOptions.anchor = e.ControlAnchor.BOTTOM_LEFT : u.position === "TOP_RIGHT" ? u.controlOptions.anchor = e.ControlAnchor.TOP_RIGHT : u.position === "TOP_LEFT" ? u.controlOptions.anchor = e.ControlAnchor.TOP_LEFT : u.position === "ABSOLUTE" && (u.controlOptions.anchor = e.ControlAnchor.ABSOLUTE, u.controlOptions.top = u.top, u.controlOptions.left = u.left, u.controlOptions.height = u.height, u.controlOptions.width = u.width))), this.element.id = u.id, this.element.className += " navigator", u = e.extend(!0, {
          sizeRatio: e.DEFAULT_SETTINGS.navigatorSizeRatio
        }, u, {
          element: this.element,
          tabIndex: -1,
          // No keyboard navigation, omit from tab order
          //These need to be overridden to prevent recursion since
          //the navigator is a viewer and a viewer has a navigator
          showNavigator: !1,
          mouseNavEnabled: !1,
          showNavigationControl: !1,
          showSequenceControl: !1,
          immediateRender: !0,
          blendTime: 0,
          animationTime: u.animationTime,
          // disable autoResize since resize behavior is implemented differently by the navigator
          autoResize: !1,
          // prevent resizing the navigator from adding unwanted space around the image
          minZoomImageRatio: 1,
          background: u.background,
          opacity: u.opacity,
          borderColor: u.borderColor,
          displayRegionColor: u.displayRegionColor
        }), u.minPixelRatio = this.minPixelRatio = h.minPixelRatio, e.setElementTouchActionNone(this.element), this.borderWidth = 2, this.fudge = new e.Point(1, 1), this.totalBorderWidths = new e.Point(this.borderWidth * 2, this.borderWidth * 2).minus(this.fudge), u.controlOptions.anchor !== e.ControlAnchor.NONE && (function(R, D) {
          R.margin = "0px", R.border = D + "px solid " + u.borderColor, R.padding = "0px", R.background = u.background, R.opacity = u.opacity, R.overflow = "hidden";
        })(this.element.style, this.borderWidth), this.displayRegion = e.makeNeutralElement("div"), this.displayRegion.id = this.element.id + "-displayregion", this.displayRegion.className = "displayregion", (function(R, D) {
          R.position = "relative", R.top = "0px", R.left = "0px", R.fontSize = "0px", R.overflow = "hidden", R.border = D + "px solid " + u.displayRegionColor, R.margin = "0px", R.padding = "0px", R.background = "transparent", R.float = "left", R.cssFloat = "left", R.zIndex = 999999999, R.cursor = "default", R.boxSizing = "content-box";
        })(this.displayRegion.style, this.borderWidth), e.setElementPointerEventsNone(this.displayRegion), e.setElementTouchActionNone(this.displayRegion), this.displayRegionContainer = e.makeNeutralElement("div"), this.displayRegionContainer.id = this.element.id + "-displayregioncontainer", this.displayRegionContainer.className = "displayregioncontainer", this.displayRegionContainer.style.width = "100%", this.displayRegionContainer.style.height = "100%", e.setElementPointerEventsNone(this.displayRegionContainer), e.setElementTouchActionNone(this.displayRegionContainer), h.addControl(
          this.element,
          u.controlOptions
        ), this._resizeWithViewer = u.controlOptions.anchor !== e.ControlAnchor.ABSOLUTE && u.controlOptions.anchor !== e.ControlAnchor.NONE, u.width && u.height ? (this.setWidth(u.width), this.setHeight(u.height)) : this._resizeWithViewer && (g = e.getElementSize(h.element), this.element.style.height = Math.round(g.y * u.sizeRatio) + "px", this.element.style.width = Math.round(g.x * u.sizeRatio) + "px", this.oldViewerSize = g, x = e.getElementSize(this.element), this.elementArea = x.x * x.y), this.oldContainerSize = new e.Point(0, 0), e.Viewer.apply(this, [u]), this.displayRegionContainer.appendChild(this.displayRegion), this.element.getElementsByTagName("div")[0].appendChild(this.displayRegionContainer);
        function C(R, D) {
          a(f.displayRegionContainer, R), a(f.displayRegion, -R), f.viewport.setRotation(R, D);
        }
        if (u.navigatorRotate) {
          var E = u.viewer.viewport ? u.viewer.viewport.getRotation() : u.viewer.degrees || 0;
          C(E, !0), u.viewer.addHandler("rotate", function(R) {
            C(R.degrees, R.immediately);
          });
        }
        this.innerTracker.destroy(), this.innerTracker = new e.MouseTracker({
          userData: "Navigator.innerTracker",
          element: this.element,
          //this.canvas,
          dragHandler: e.delegate(this, i),
          clickHandler: e.delegate(this, t),
          releaseHandler: e.delegate(this, r),
          scrollHandler: e.delegate(this, o),
          preProcessEventHandler: function(R) {
            R.eventType === "wheel" && (R.preventDefault = !0);
          }
        }), this.outerTracker.userData = "Navigator.outerTracker", e.setElementPointerEventsNone(this.canvas), e.setElementPointerEventsNone(this.container), this.addHandler("reset-size", function() {
          f.viewport && f.viewport.goHome(!0);
        }), h.world.addHandler("item-index-change", function(R) {
          window.setTimeout(function() {
            var D = f.world.getItemAt(R.previousIndex);
            f.world.setItemIndex(D, R.newIndex);
          }, 1);
        }), h.world.addHandler("remove-item", function(R) {
          var D = R.item, U = f._getMatchingItem(D);
          U && f.world.removeItem(U);
        }), this.update(h.viewport);
      }, e.extend(
        e.Navigator.prototype,
        e.EventSource.prototype,
        e.Viewer.prototype,
        /** @lends OpenSeadragon.Navigator.prototype */
        {
          /**
           * Used to notify the navigator when its size has changed.
           * Especially useful when {@link OpenSeadragon.Options}.navigatorAutoResize is set to false and the navigator is resizable.
           * @function
           */
          updateSize: function() {
            if (this.viewport) {
              var u = new e.Point(
                this.container.clientWidth === 0 ? 1 : this.container.clientWidth,
                this.container.clientHeight === 0 ? 1 : this.container.clientHeight
              );
              u.equals(this.oldContainerSize) || (this.viewport.resize(u, !0), this.viewport.goHome(!0), this.oldContainerSize = u, this.world.update(), this.world.draw(), this.update(this.viewer.viewport));
            }
          },
          /**
           * Explicitly sets the width of the navigator, in web coordinates. Disables automatic resizing.
           * @param {Number|String} width - the new width, either a number of pixels or a CSS string, such as "100%"
           */
          setWidth: function(u) {
            this.width = u, this.element.style.width = typeof u == "number" ? u + "px" : u, this._resizeWithViewer = !1, this.updateSize();
          },
          /**
           * Explicitly sets the height of the navigator, in web coordinates. Disables automatic resizing.
           * @param {Number|String} height - the new height, either a number of pixels or a CSS string, such as "100%"
           */
          setHeight: function(u) {
            this.height = u, this.element.style.height = typeof u == "number" ? u + "px" : u, this._resizeWithViewer = !1, this.updateSize();
          },
          /**
            * Flip navigator element
            * @param {Boolean} state - Flip state to set.
            */
          setFlip: function(u) {
            return this.viewport.setFlip(u), this.setDisplayTransform(this.viewer.viewport.getFlip() ? "scale(-1,1)" : "scale(1,1)"), this;
          },
          setDisplayTransform: function(u) {
            c(this.canvas, u), c(this.element, u);
          },
          /**
           * Used to update the navigator minimap's viewport rectangle when a change in the viewer's viewport occurs.
           * @function
           * @param {OpenSeadragon.Viewport} [viewport] The viewport to display. Default: the viewport this navigator is tracking.
           */
          update: function(u) {
            var h, f, g, x, C, E;
            if (u || (u = this.viewer.viewport), h = e.getElementSize(this.viewer.element), this._resizeWithViewer && h.x && h.y && !h.equals(this.oldViewerSize) && (this.oldViewerSize = h, this.maintainSizeRatio || !this.elementArea ? (f = h.x * this.sizeRatio, g = h.y * this.sizeRatio) : (f = Math.sqrt(this.elementArea * (h.x / h.y)), g = this.elementArea / f), this.element.style.width = Math.round(f) + "px", this.element.style.height = Math.round(g) + "px", this.elementArea || (this.elementArea = f * g), this.updateSize()), u && this.viewport) {
              if (x = u.getBoundsNoRotate(!0), C = this.viewport.pixelFromPointNoRotate(x.getTopLeft(), !1), E = this.viewport.pixelFromPointNoRotate(x.getBottomRight(), !1).minus(this.totalBorderWidths), !this.navigatorRotate) {
                var R = u.getRotation(!0);
                a(this.displayRegion, -R);
              }
              var D = this.displayRegion.style;
              D.display = this.world.getItemCount() ? "block" : "none", D.top = C.y.toFixed(2) + "px", D.left = C.x.toFixed(2) + "px";
              var U = E.x - C.x, Z = E.y - C.y;
              D.width = Math.round(Math.max(U, 0)) + "px", D.height = Math.round(Math.max(Z, 0)) + "px";
            }
          },
          // overrides Viewer.addTiledImage
          addTiledImage: function(u) {
            var h = this, f = u.originalTiledImage;
            delete u.original;
            var g = e.extend({}, u, {
              success: function(x) {
                var C = x.item;
                C._originalForNavigator = f, h._matchBounds(C, f, !0), h._matchOpacity(C, f), h._matchCompositeOperation(C, f);
                function E() {
                  h._matchBounds(C, f);
                }
                function R() {
                  h._matchOpacity(C, f);
                }
                function D() {
                  h._matchCompositeOperation(C, f);
                }
                f.addHandler("bounds-change", E), f.addHandler("clip-change", E), f.addHandler("opacity-change", R), f.addHandler("composite-operation-change", D);
              }
            });
            return e.Viewer.prototype.addTiledImage.apply(this, [g]);
          },
          destroy: function() {
            return e.Viewer.prototype.destroy.apply(this);
          },
          // private
          _getMatchingItem: function(u) {
            for (var h = this.world.getItemCount(), f, g = 0; g < h; g++)
              if (f = this.world.getItemAt(g), f._originalForNavigator === u)
                return f;
            return null;
          },
          // private
          _matchBounds: function(u, h, f) {
            var g = h.getBoundsNoRotate();
            u.setPosition(g.getTopLeft(), f), u.setWidth(g.width, f), u.setRotation(h.getRotation(), f), u.setClip(h.getClip()), u.setFlip(h.getFlip());
          },
          // private
          _matchOpacity: function(u, h) {
            u.setOpacity(h.opacity);
          },
          // private
          _matchCompositeOperation: function(u, h) {
            u.setCompositeOperation(h.compositeOperation);
          }
        }
      );
      function t(u) {
        var h = {
          tracker: u.eventSource,
          position: u.position,
          quick: u.quick,
          shift: u.shift,
          originalEvent: u.originalEvent,
          preventDefaultAction: !1
        };
        if (this.viewer.raiseEvent("navigator-click", h), !h.preventDefaultAction && u.quick && this.viewer.viewport && (this.panVertical || this.panHorizontal)) {
          this.viewer.viewport.flipped && (u.position.x = this.viewport.getContainerSize().x - u.position.x);
          var f = this.viewport.pointFromPixel(u.position);
          this.panVertical ? this.panHorizontal || (f.x = this.viewer.viewport.getCenter(!0).x) : f.y = this.viewer.viewport.getCenter(!0).y, this.viewer.viewport.panTo(f), this.viewer.viewport.applyConstraints();
        }
      }
      function i(u) {
        var h = {
          tracker: u.eventSource,
          position: u.position,
          delta: u.delta,
          speed: u.speed,
          direction: u.direction,
          shift: u.shift,
          originalEvent: u.originalEvent,
          preventDefaultAction: !1
        };
        this.viewer.raiseEvent("navigator-drag", h), !h.preventDefaultAction && this.viewer.viewport && (this.panHorizontal || (u.delta.x = 0), this.panVertical || (u.delta.y = 0), this.viewer.viewport.flipped && (u.delta.x = -u.delta.x), this.viewer.viewport.panBy(
          this.viewport.deltaPointsFromPixels(
            u.delta
          )
        ), this.viewer.constrainDuringPan && this.viewer.viewport.applyConstraints());
      }
      function r(u) {
        u.insideElementPressed && this.viewer.viewport && this.viewer.viewport.applyConstraints();
      }
      function o(u) {
        var h = {
          tracker: u.eventSource,
          position: u.position,
          scroll: u.scroll,
          shift: u.shift,
          originalEvent: u.originalEvent,
          preventDefault: u.preventDefault
        };
        this.viewer.raiseEvent("navigator-scroll", h), u.preventDefault = h.preventDefault;
      }
      function a(u, h) {
        c(u, "rotate(" + h + "deg)");
      }
      function c(u, h) {
        u.style.webkitTransform = h, u.style.mozTransform = h, u.style.msTransform = h, u.style.oTransform = h, u.style.transform = h;
      }
    })(n), (function(e) {
      var t = {
        Errors: {
          Dzc: "Sorry, we don't support Deep Zoom Collections!",
          Dzi: "Hmm, this doesn't appear to be a valid Deep Zoom Image.",
          Xml: "Hmm, this doesn't appear to be a valid Deep Zoom Image.",
          ImageFormat: "Sorry, we don't support {0}-based Deep Zoom Images.",
          Security: "It looks like a security restriction stopped us from loading this Deep Zoom Image.",
          Status: "This space unintentionally left blank ({0} {1}).",
          OpenFailed: "Unable to open {0}: {1}"
        },
        Tooltips: {
          FullPage: "Toggle full page",
          Home: "Go home",
          ZoomIn: "Zoom in",
          ZoomOut: "Zoom out",
          NextPage: "Next page",
          PreviousPage: "Previous page",
          RotateLeft: "Rotate left",
          RotateRight: "Rotate right",
          Flip: "Flip Horizontally"
        }
      };
      e.extend(
        e,
        /** @lends OpenSeadragon */
        {
          /**
           * @function
           * @param {String} property
           */
          getString: function(i) {
            var r = i.split("."), o = null, a = arguments, c = t, u;
            for (u = 0; u < r.length - 1; u++)
              c = c[r[u]] || {};
            return o = c[r[u]], typeof o != "string" && (e.console.error("Untranslated source string:", i), o = ""), o.replace(/\{\d+\}/g, function(h) {
              var f = parseInt(h.match(/\d+/), 10) + 1;
              return f < a.length ? a[f] : "";
            });
          },
          /**
           * @function
           * @param {String} property
           * @param {*} value
           */
          setString: function(i, r) {
            var o = i.split("."), a = t, c;
            for (c = 0; c < o.length - 1; c++)
              a[o[c]] || (a[o[c]] = {}), a = a[o[c]];
            a[o[c]] = r;
          }
        }
      );
    })(n), (function(e) {
      e.Point = function(t, i) {
        this.x = typeof t == "number" ? t : 0, this.y = typeof i == "number" ? i : 0;
      }, e.Point.prototype = {
        /**
         * @function
         * @returns {OpenSeadragon.Point} a duplicate of this Point
         */
        clone: function() {
          return new e.Point(this.x, this.y);
        },
        /**
         * Add another Point to this point and return a new Point.
         * @function
         * @param {OpenSeadragon.Point} point The point to add vector components.
         * @returns {OpenSeadragon.Point} A new point representing the sum of the
         *  vector components
         */
        plus: function(t) {
          return new e.Point(
            this.x + t.x,
            this.y + t.y
          );
        },
        /**
         * Subtract another Point to this point and return a new Point.
         * @function
         * @param {OpenSeadragon.Point} point The point to subtract vector components.
         * @returns {OpenSeadragon.Point} A new point representing the subtraction of the
         *  vector components
         */
        minus: function(t) {
          return new e.Point(
            this.x - t.x,
            this.y - t.y
          );
        },
        /**
         * Multiply this point by a factor and return a new Point.
         * @function
         * @param {Number} factor The factor to multiply vector components.
         * @returns {OpenSeadragon.Point} A new point representing the multiplication
         *  of the vector components by the factor
         */
        times: function(t) {
          return new e.Point(
            this.x * t,
            this.y * t
          );
        },
        /**
         * Divide this point by a factor and return a new Point.
         * @function
         * @param {Number} factor The factor to divide vector components.
         * @returns {OpenSeadragon.Point} A new point representing the division of the
         *  vector components by the factor
         */
        divide: function(t) {
          return new e.Point(
            this.x / t,
            this.y / t
          );
        },
        /**
         * Compute the opposite of this point and return a new Point.
         * @function
         * @returns {OpenSeadragon.Point} A new point representing the opposite of the
         *  vector components
         */
        negate: function() {
          return new e.Point(-this.x, -this.y);
        },
        /**
         * Compute the distance between this point and another point.
         * @function
         * @param {OpenSeadragon.Point} point The point to compute the distance with.
         * @returns {Number} The distance between the 2 points
         */
        distanceTo: function(t) {
          return Math.sqrt(
            Math.pow(this.x - t.x, 2) + Math.pow(this.y - t.y, 2)
          );
        },
        /**
         * Compute the squared distance between this point and another point.
         * Useful for optimizing things like comparing distances.
         * @function
         * @param {OpenSeadragon.Point} point The point to compute the squared distance with.
         * @returns {Number} The squared distance between the 2 points
         */
        squaredDistanceTo: function(t) {
          return Math.pow(this.x - t.x, 2) + Math.pow(this.y - t.y, 2);
        },
        /**
         * Apply a function to each coordinate of this point and return a new point.
         * @function
         * @param {function} func The function to apply to each coordinate.
         * @returns {OpenSeadragon.Point} A new point with the coordinates computed
         * by the specified function
         */
        apply: function(t) {
          return new e.Point(t(this.x), t(this.y));
        },
        /**
         * Check if this point is equal to another one.
         * @function
         * @param {OpenSeadragon.Point} point The point to compare this point with.
         * @returns {Boolean} true if they are equal, false otherwise.
         */
        equals: function(t) {
          return t instanceof e.Point && this.x === t.x && this.y === t.y;
        },
        /**
         * Rotates the point around the specified pivot
         * From http://stackoverflow.com/questions/4465931/rotate-rectangle-around-a-point
         * @function
         * @param {Number} degress to rotate around the pivot.
         * @param {OpenSeadragon.Point} [pivot=(0,0)] Point around which to rotate.
         * Defaults to the origin.
         * @returns {OpenSeadragon.Point}. A new point representing the point rotated around the specified pivot
         */
        rotate: function(t, i) {
          i = i || new e.Point(0, 0);
          var r, o;
          if (t % 90 === 0) {
            var a = e.positiveModulo(t, 360);
            switch (a) {
              case 0:
                r = 1, o = 0;
                break;
              case 90:
                r = 0, o = 1;
                break;
              case 180:
                r = -1, o = 0;
                break;
              case 270:
                r = 0, o = -1;
                break;
            }
          } else {
            var c = t * Math.PI / 180;
            r = Math.cos(c), o = Math.sin(c);
          }
          var u = r * (this.x - i.x) - o * (this.y - i.y) + i.x, h = o * (this.x - i.x) + r * (this.y - i.y) + i.y;
          return new e.Point(u, h);
        },
        /**
         * Convert this point to a string in the format (x,y) where x and y are
         * rounded to the nearest integer.
         * @function
         * @returns {String} A string representation of this point.
         */
        toString: function() {
          return "(" + Math.round(this.x * 100) / 100 + "," + Math.round(this.y * 100) / 100 + ")";
        }
      };
    })(n), (function(e) {
      e.TileSource = function(i, r, o, a, c, u) {
        var h = this, f = arguments, g, x;
        if (e.isPlainObject(i) ? g = i : g = {
          width: f[0],
          height: f[1],
          tileSize: f[2],
          tileOverlap: f[3],
          minLevel: f[4],
          maxLevel: f[5]
        }, e.EventSource.call(this), e.extend(!0, this, g), !this.success) {
          for (x = 0; x < arguments.length; x++)
            if (e.isFunction(arguments[x])) {
              this.success = arguments[x];
              break;
            }
        }
        this.success && this.addHandler("ready", function(C) {
          h.success(C);
        }), e.type(arguments[0]) === "string" && (this.url = arguments[0]), this.url ? (this.aspectRatio = 1, this.dimensions = new e.Point(10, 10), this._tileWidth = 0, this._tileHeight = 0, this.tileOverlap = 0, this.minLevel = 0, this.maxLevel = 0, this.ready = !1, this.getImageInfo(this.url)) : (this.ready = !0, this.aspectRatio = g.width && g.height ? g.width / g.height : 1, this.dimensions = new e.Point(g.width, g.height), this.tileSize ? (this._tileWidth = this._tileHeight = this.tileSize, delete this.tileSize) : (this.tileWidth ? (this._tileWidth = this.tileWidth, delete this.tileWidth) : this._tileWidth = 0, this.tileHeight ? (this._tileHeight = this.tileHeight, delete this.tileHeight) : this._tileHeight = 0), this.tileOverlap = g.tileOverlap ? g.tileOverlap : 0, this.minLevel = g.minLevel ? g.minLevel : 0, this.maxLevel = g.maxLevel !== void 0 && g.maxLevel !== null ? g.maxLevel : g.width && g.height ? Math.ceil(
          Math.log(Math.max(g.width, g.height)) / Math.log(2)
        ) : 0, this.success && e.isFunction(this.success) && this.success(this));
      }, e.TileSource.prototype = {
        getTileSize: function(i) {
          return e.console.error(
            "[TileSource.getTileSize] is deprecated. Use TileSource.getTileWidth() and TileSource.getTileHeight() instead"
          ), this._tileWidth;
        },
        /**
         * Return the tileWidth for a given level.
         * Subclasses should override this if tileWidth can be different at different levels
         *   such as in IIIFTileSource.  Code should use this function rather than reading
         *   from ._tileWidth directly.
         * @function
         * @param {Number} level
         */
        getTileWidth: function(i) {
          return this._tileWidth ? this._tileWidth : this.getTileSize(i);
        },
        /**
         * Return the tileHeight for a given level.
         * Subclasses should override this if tileHeight can be different at different levels
         *   such as in IIIFTileSource.  Code should use this function rather than reading
         *   from ._tileHeight directly.
         * @function
         * @param {Number} level
         */
        getTileHeight: function(i) {
          return this._tileHeight ? this._tileHeight : this.getTileSize(i);
        },
        /**
         * Set the maxLevel to the given level, and perform the memoization of
         * getLevelScale with the new maxLevel. This function can be useful if the
         * memoization is required before the first call of getLevelScale, or both
         * memoized getLevelScale and maxLevel should be changed accordingly.
         * @function
         * @param {Number} level
         */
        setMaxLevel: function(i) {
          this.maxLevel = i, this._memoizeLevelScale();
        },
        /**
         * @function
         * @param {Number} level
         */
        getLevelScale: function(i) {
          return this._memoizeLevelScale(), this.getLevelScale(i);
        },
        // private
        _memoizeLevelScale: function() {
          var i = {}, r;
          for (r = 0; r <= this.maxLevel; r++)
            i[r] = 1 / Math.pow(2, this.maxLevel - r);
          this.getLevelScale = function(o) {
            return i[o];
          };
        },
        /**
         * @function
         * @param {Number} level
         */
        getNumTiles: function(i) {
          var r = this.getLevelScale(i), o = Math.ceil(r * this.dimensions.x / this.getTileWidth(i)), a = Math.ceil(r * this.dimensions.y / this.getTileHeight(i));
          return new e.Point(o, a);
        },
        /**
         * @function
         * @param {Number} level
         */
        getPixelRatio: function(i) {
          var r = this.dimensions.times(this.getLevelScale(i)), o = 1 / r.x * e.pixelDensityRatio, a = 1 / r.y * e.pixelDensityRatio;
          return new e.Point(o, a);
        },
        /**
         * @function
         * @returns {Number} The highest level in this tile source that can be contained in a single tile.
         */
        getClosestLevel: function() {
          var i, r;
          for (i = this.minLevel + 1; i <= this.maxLevel && (r = this.getNumTiles(i), !(r.x > 1 || r.y > 1)); i++)
            ;
          return i - 1;
        },
        /**
         * @function
         * @param {Number} level
         * @param {OpenSeadragon.Point} point
         */
        getTileAtPoint: function(i, r) {
          var o = r.x >= 0 && r.x <= 1 && r.y >= 0 && r.y <= 1 / this.aspectRatio;
          e.console.assert(o, "[TileSource.getTileAtPoint] must be called with a valid point.");
          var a = this.dimensions.x * this.getLevelScale(i), c = r.x * a, u = r.y * a, h = Math.floor(c / this.getTileWidth(i)), f = Math.floor(u / this.getTileHeight(i));
          r.x >= 1 && (h = this.getNumTiles(i).x - 1);
          var g = 1e-15;
          return r.y >= 1 / this.aspectRatio - g && (f = this.getNumTiles(i).y - 1), new e.Point(h, f);
        },
        /**
         * @function
         * @param {Number} level
         * @param {Number} x
         * @param {Number} y
         * @param {Boolean} [isSource=false] Whether to return the source bounds of the tile.
         * @returns {OpenSeadragon.Rect} Either where this tile fits (in normalized coordinates) or the
         * portion of the tile to use as the source of the drawing operation (in pixels), depending on
         * the isSource parameter.
         */
        getTileBounds: function(i, r, o, a) {
          var c = this.dimensions.times(this.getLevelScale(i)), u = this.getTileWidth(i), h = this.getTileHeight(i), f = r === 0 ? 0 : u * r - this.tileOverlap, g = o === 0 ? 0 : h * o - this.tileOverlap, x = u + (r === 0 ? 1 : 2) * this.tileOverlap, C = h + (o === 0 ? 1 : 2) * this.tileOverlap, E = 1 / c.x;
          return x = Math.min(x, c.x - f), C = Math.min(C, c.y - g), a ? new e.Rect(0, 0, x, C) : new e.Rect(f * E, g * E, x * E, C * E);
        },
        /**
         * Responsible for retrieving, and caching the
         * image metadata pertinent to this TileSources implementation.
         * @function
         * @param {String} url
         * @throws {Error}
         */
        getImageInfo: function(i) {
          var r = this, o, a, c, u, h, f, g;
          i && (h = i.split("/"), f = h[h.length - 1], g = f.lastIndexOf("."), g > -1 && (h[h.length - 1] = f.slice(0, g)));
          var x = null;
          if (this.splitHashDataForPost) {
            var C = i.indexOf("#");
            C !== -1 && (x = i.substring(C + 1), i = i.substr(0, C));
          }
          a = function(E) {
            typeof E == "string" && (E = e.parseXml(E));
            var R = e.TileSource.determineType(r, E, i);
            if (!R) {
              r.raiseEvent("open-failed", { message: "Unable to load TileSource", source: i });
              return;
            }
            u = R.prototype.configure.apply(r, [E, i, x]), u.ajaxWithCredentials === void 0 && (u.ajaxWithCredentials = r.ajaxWithCredentials), c = new R(u), r.ready = !0, r.raiseEvent("ready", { tileSource: c });
          }, i.match(/\.js$/) ? (o = i.split("/").pop().replace(".js", ""), e.jsonp({
            url: i,
            async: !1,
            callbackName: o,
            callback: a
          })) : e.makeAjaxRequest({
            url: i,
            postData: x,
            withCredentials: this.ajaxWithCredentials,
            headers: this.ajaxHeaders,
            success: function(E) {
              var R = t(E);
              a(R);
            },
            error: function(E, R) {
              var D;
              try {
                D = "HTTP " + E.status + " attempting to load TileSource: " + i;
              } catch {
                var U;
                typeof R > "u" || !R.toString ? U = "Unknown error" : U = R.toString(), D = U + " attempting to load TileSource: " + i;
              }
              e.console.error(D), r.raiseEvent("open-failed", {
                message: D,
                source: i,
                postData: x
              });
            }
          });
        },
        /**
         * Responsible for determining if the particular TileSource supports the
         * data format ( and allowed to apply logic against the url the data was
         * loaded from, if any ). Overriding implementations are expected to do
         * something smart with data and / or url to determine support.  Also
         * understand that iteration order of TileSources is not guaranteed so
         * please make sure your data or url is expressive enough to ensure a simple
         * and sufficient mechanism for clear determination.
         * @function
         * @param {String|Object|Array|Document} data
         * @param {String} url - the url the data was loaded
         *      from if any.
         * @returns {Boolean}
         */
        supports: function(i, r) {
          return !1;
        },
        /**
         * Responsible for parsing and configuring the
         * image metadata pertinent to this TileSources implementation.
         * This method is not implemented by this class other than to throw an Error
         * announcing you have to implement it.  Because of the variety of tile
         * server technologies, and various specifications for building image
         * pyramids, this method is here to allow easy integration.
         * @function
         * @param {String|Object|Array|Document} data
         * @param {String} url - the url the data was loaded
         *      from if any.
         * @param {String} postData - HTTP POST data in k=v&k2=v2... form or null value obtained from
         *      the protocol URL after '#' sign if flag splitHashDataForPost set to 'true'
         * @returns {Object} options - A dictionary of keyword arguments sufficient
         *      to configure the tile source constructor (include all values you want to
         *      instantiate the TileSource subclass with - what _options_ object should contain).
         * @throws {Error}
         */
        configure: function(i, r, o) {
          throw new Error("Method not implemented.");
        },
        /**
         * Responsible for retrieving the url which will return an image for the
         * region specified by the given x, y, and level components.
         * This method is not implemented by this class other than to throw an Error
         * announcing you have to implement it.  Because of the variety of tile
         * server technologies, and various specifications for building image
         * pyramids, this method is here to allow easy integration.
         * @function
         * @param {Number} level
         * @param {Number} x
         * @param {Number} y
         * @returns {String|Function} url - A string for the url or a function that returns a url string.
         * @throws {Error}
         */
        getTileUrl: function(i, r, o) {
          throw new Error("Method not implemented.");
        },
        /**
         * Must use AJAX in order to work, i.e. loadTilesWithAjax = true is set.
         * If a value is returned, ajax issues POST request to the tile url.
         * If null is returned, ajax issues GET request.
         * The return value must comply to the header 'content type'.
         *
         * Examples (USED HEADER --> getTilePostData CODE):
         * 'Content-type': 'application/x-www-form-urlencoded' -->
         *   return "key1=value=1&key2=value2";
         *
         * 'Content-type': 'application/x-www-form-urlencoded' -->
         *   return JSON.stringify({key: "value", number: 5});
         *
         * 'Content-type': 'multipart/form-data' -->
         *   let result = new FormData();
         *   result.append("data", myData);
         *   return result;
         *
         * IMPORTANT: in case you move all the logic on image fetching
         * to post data, you must re-define 'getTileHashKey(...)' to
         * stay unique for different tile images.
         *
         * @param {Number} level
         * @param {Number} x
         * @param {Number} y
         * @returns {*|null} post data to send with tile configuration request
         */
        getTilePostData: function(i, r, o) {
          return null;
        },
        /**
         * Responsible for retrieving the headers which will be attached to the image request for the
         * region specified by the given x, y, and level components.
         * This option is only relevant if {@link OpenSeadragon.Options}.loadTilesWithAjax is set to true.
         * The headers returned here will override headers specified at the Viewer or TiledImage level.
         * Specifying a falsy value for a header will clear its existing value set at the Viewer or
         * TiledImage level (if any).
         *
         * Note that the headers of existing tiles don't automatically change when this function
         * returns updated headers. To do that, you need to call {@link OpenSeadragon.Viewer#setAjaxHeaders}
         * and propagate the changes.
         *
         * @function
         * @param {Number} level
         * @param {Number} x
         * @param {Number} y
         * @returns {Object}
         */
        getTileAjaxHeaders: function(i, r, o) {
          return {};
        },
        /**
         * The tile cache object is uniquely determined by this key and used to lookup
         * the image data in cache: keys should be different if images are different.
         *
         * In case a tile has context2D property defined (TileSource.prototype.getContext2D)
         * or its context2D is set manually; the cache is not used and this function
         * is irrelevant.
         * Note: default behaviour does not take into account post data.
         * @param {Number} level tile level it was fetched with
         * @param {Number} x x-coordinate in the pyramid level
         * @param {Number} y y-coordinate in the pyramid level
         * @param {String} url the tile was fetched with
         * @param {Object} ajaxHeaders the tile was fetched with
         * @param {*} postData data the tile was fetched with (type depends on getTilePostData(..) return type)
         */
        getTileHashKey: function(i, r, o, a, c, u) {
          function h(f) {
            return c ? f + "+" + JSON.stringify(c) : f;
          }
          return h(typeof a != "string" ? i + "/" + r + "_" + o : a);
        },
        /**
         * @function
         * @param {Number} level
         * @param {Number} x
         * @param {Number} y
         */
        tileExists: function(i, r, o) {
          var a = this.getNumTiles(i);
          return i >= this.minLevel && i <= this.maxLevel && r >= 0 && o >= 0 && r < a.x && o < a.y;
        },
        /**
         * Decide whether tiles have transparency: this is crucial for correct images blending.
         * @returns {boolean} true if the image has transparency
         */
        hasTransparency: function(i, r, o, a) {
          return !!i || r.match(".png");
        },
        /**
         * Download tile data.
         * Note that if you override this function, you should override also downloadTileAbort().
         * @param {ImageJob} context job context that you have to call finish(...) on.
         * @param {String} [context.src] - URL of image to download.
         * @param {String} [context.loadWithAjax] - Whether to load this image with AJAX.
         * @param {String} [context.ajaxHeaders] - Headers to add to the image request if using AJAX.
         * @param {Boolean} [context.ajaxWithCredentials] - Whether to set withCredentials on AJAX requests.
         * @param {String} [context.crossOriginPolicy] - CORS policy to use for downloads
         * @param {String} [context.postData] - HTTP POST data (usually but not necessarily in k=v&k2=v2... form,
         *   see TileSource::getPostData) or null
         * @param {*} [context.userData] - Empty object to attach your own data and helper variables to.
         * @param {Function} [context.finish] - Should be called unless abort() was executed, e.g. on all occasions,
         *   be it successful or unsuccessful request.
         *   Usage: context.finish(data, request, errMessage). Pass the downloaded data object or null upon failure.
         *   Add also reference to an ajax request if used. Provide error message in case of failure.
         * @param {Function} [context.abort] - Called automatically when the job times out.
         *   Usage: context.abort().
         * @param {Function} [context.callback] @private - Called automatically once image has been downloaded
         *   (triggered by finish).
         * @param {Number} [context.timeout] @private - The max number of milliseconds that
         *   this image job may take to complete.
         * @param {string} [context.errorMsg] @private - The final error message, default null (set by finish).
         */
        downloadTileStart: function(i) {
          var r = i.userData, o = new Image();
          r.image = o, r.request = null;
          var a = function(c) {
            if (!o) {
              i.finish(null, r.request, "Image load failed: undefined Image instance.");
              return;
            }
            o.onload = o.onerror = o.onabort = null, i.finish(c ? null : o, r.request, c);
          };
          o.onload = function() {
            a();
          }, o.onabort = o.onerror = function() {
            a("Image load aborted.");
          }, i.loadWithAjax ? r.request = e.makeAjaxRequest({
            url: i.src,
            withCredentials: i.ajaxWithCredentials,
            headers: i.ajaxHeaders,
            responseType: "arraybuffer",
            postData: i.postData,
            success: function(c) {
              var u;
              try {
                u = new window.Blob([c.response]);
              } catch (g) {
                var h = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
                if (g.name === "TypeError" && h) {
                  var f = new h();
                  f.append(c.response), u = f.getBlob();
                }
              }
              u.size === 0 ? a("Empty image response.") : o.src = (window.URL || window.webkitURL).createObjectURL(u);
            },
            error: function(c) {
              a("Image load aborted - XHR error");
            }
          }) : (i.crossOriginPolicy !== !1 && (o.crossOrigin = i.crossOriginPolicy), o.src = i.src);
        },
        /**
         * Provide means of aborting the execution.
         * Note that if you override this function, you should override also downloadTileStart().
         * @param {ImageJob} context job, the same object as with downloadTileStart(..)
         * @param {*} [context.userData] - Empty object to attach (and mainly read) your own data.
         */
        downloadTileAbort: function(i) {
          i.userData.request && i.userData.request.abort();
          var r = i.userData.image;
          i.userData.image && (r.onload = r.onerror = r.onabort = null);
        },
        /**
         * Create cache object from the result of the download process. The
         * cacheObject parameter should be used to attach the data to, there are no
         * conventions on how it should be stored - all the logic is implemented within *TileCache() functions.
         *
         * Note that if you override any of *TileCache() functions, you should override all of them.
         * @param {object} cacheObject context cache object
         * @param {*} data image data, the data sent to ImageJob.prototype.finish(), by default an Image object
         * @param {Tile} tile instance the cache was created with
         */
        createTileCache: function(i, r, o) {
          i._data = r;
        },
        /**
         * Cache object destructor, unset all properties you created to allow GC collection.
         * Note that if you override any of *TileCache() functions, you should override all of them.
         * @param {object} cacheObject context cache object
         */
        destroyTileCache: function(i) {
          i._data = null, i._renderedContext = null;
        },
        /**
         * Raw data getter
         * Note that if you override any of *TileCache() functions, you should override all of them.
         * @param {object} cacheObject context cache object
         * @returns {*} cache data
         */
        getTileCacheData: function(i) {
          return i._data;
        },
        /**
         * Compatibility image element getter
         *  - plugins might need image representation of the data
         *  - div HTML rendering relies on image element presence
         * Note that if you override any of *TileCache() functions, you should override all of them.
         *  @param {object} cacheObject context cache object
         *  @returns {Image} cache data as an Image
         */
        getTileCacheDataAsImage: function(i) {
          return i._data;
        },
        /**
         * Compatibility context 2D getter
         *  - most heavily used rendering method is a canvas-based approach,
         *    convert the data to a canvas and return it's 2D context
         * Note that if you override any of *TileCache() functions, you should override all of them.
         * @param {object} cacheObject context cache object
         * @returns {CanvasRenderingContext2D} context of the canvas representation of the cache data
         */
        getTileCacheDataAsContext2D: function(i) {
          if (!i._renderedContext) {
            var r = document.createElement("canvas");
            r.width = i._data.width, r.height = i._data.height, i._renderedContext = r.getContext("2d"), i._renderedContext.drawImage(i._data, 0, 0), i._data = null;
          }
          return i._renderedContext;
        }
      }, e.extend(!0, e.TileSource.prototype, e.EventSource.prototype);
      function t(i) {
        var r = i.responseText, o = i.status, a, c;
        if (i) {
          if (i.status !== 200 && i.status !== 0)
            throw o = i.status, a = o === 404 ? "Not Found" : i.statusText, new Error(e.getString("Errors.Status", o, a));
        } else throw new Error(e.getString("Errors.Security"));
        if (r.match(/^\s*<.*/))
          try {
            c = i.responseXML && i.responseXML.documentElement ? i.responseXML : e.parseXml(r);
          } catch {
            c = i.responseText;
          }
        else if (r.match(/\s*[{[].*/))
          try {
            c = e.parseJSON(r);
          } catch {
            c = r;
          }
        else
          c = r;
        return c;
      }
      e.TileSource.determineType = function(i, r, o) {
        var a;
        for (a in n)
          if (a.match(/.+TileSource$/) && e.isFunction(n[a]) && e.isFunction(n[a].prototype.supports) && n[a].prototype.supports.call(i, r, o))
            return n[a];
        return e.console.error("No TileSource was able to open %s %s", o, r), null;
      };
    })(n), (function(e) {
      e.DziTileSource = function(r, o, a, c, u, h, f, g, x) {
        var C, E, R, D;
        if (e.isPlainObject(r) ? D = r : D = {
          width: arguments[0],
          height: arguments[1],
          tileSize: arguments[2],
          tileOverlap: arguments[3],
          tilesUrl: arguments[4],
          fileFormat: arguments[5],
          displayRects: arguments[6],
          minLevel: arguments[7],
          maxLevel: arguments[8]
        }, this._levelRects = {}, this.tilesUrl = D.tilesUrl, this.fileFormat = D.fileFormat, this.displayRects = D.displayRects, this.displayRects)
          for (C = this.displayRects.length - 1; C >= 0; C--)
            for (E = this.displayRects[C], R = E.minLevel; R <= E.maxLevel; R++)
              this._levelRects[R] || (this._levelRects[R] = []), this._levelRects[R].push(E);
        e.TileSource.apply(this, [D]);
      }, e.extend(
        e.DziTileSource.prototype,
        e.TileSource.prototype,
        /** @lends OpenSeadragon.DziTileSource.prototype */
        {
          /**
           * Determine if the data and/or url imply the image service is supported by
           * this tile source.
           * @function
           * @param {Object|Array} data
           * @param {String} optional - url
           */
          supports: function(r, o) {
            var a;
            return r.Image ? a = r.Image.xmlns : r.documentElement && (r.documentElement.localName === "Image" || r.documentElement.tagName === "Image") && (a = r.documentElement.namespaceURI), a = (a || "").toLowerCase(), a.indexOf("schemas.microsoft.com/deepzoom/2008") !== -1 || a.indexOf("schemas.microsoft.com/deepzoom/2009") !== -1;
          },
          /**
           *
           * @function
           * @param {Object|XMLDocument} data - the raw configuration
           * @param {String} url - the url the data was retrieved from if any.
           * @param {String} postData - HTTP POST data in k=v&k2=v2... form or null
           * @returns {Object} options - A dictionary of keyword arguments sufficient
           *      to configure this tile sources constructor.
           */
          configure: function(r, o, a) {
            var c;
            return e.isPlainObject(r) ? c = i(this, r) : c = t(this, r), o && !c.tilesUrl && (c.tilesUrl = o.replace(
              /([^/]+?)(\.(dzi|xml|js)?(\?[^/]*)?)?\/?$/,
              "$1_files/"
            ), o.search(/\.(dzi|xml|js)\?/) !== -1 ? c.queryParams = o.match(/\?.*/) : c.queryParams = ""), c;
          },
          /**
           * @function
           * @param {Number} level
           * @param {Number} x
           * @param {Number} y
           */
          getTileUrl: function(r, o, a) {
            return [this.tilesUrl, r, "/", o, "_", a, ".", this.fileFormat, this.queryParams].join("");
          },
          /**
           * @function
           * @param {Number} level
           * @param {Number} x
           * @param {Number} y
           */
          tileExists: function(r, o, a) {
            var c = this._levelRects[r], u, h, f, g, x, C, E;
            if (this.minLevel && r < this.minLevel || this.maxLevel && r > this.maxLevel)
              return !1;
            if (!c || !c.length)
              return !0;
            for (E = c.length - 1; E >= 0; E--)
              if (u = c[E], !(r < u.minLevel || r > u.maxLevel) && (h = this.getLevelScale(r), f = u.x * h, g = u.y * h, x = f + u.width * h, C = g + u.height * h, f = Math.floor(f / this._tileWidth), g = Math.floor(g / this._tileWidth), x = Math.ceil(x / this._tileWidth), C = Math.ceil(C / this._tileWidth), f <= o && o < x && g <= a && a < C))
                return !0;
            return !1;
          }
        }
      );
      function t(r, o) {
        if (!o || !o.documentElement)
          throw new Error(e.getString("Errors.Xml"));
        var a = o.documentElement, c = a.localName || a.tagName, u = o.documentElement.namespaceURI, h = null, f = [], g, x, C, E, R;
        if (c === "Image")
          try {
            if (E = a.getElementsByTagName("Size")[0], E === void 0 && (E = a.getElementsByTagNameNS(u, "Size")[0]), h = {
              Image: {
                xmlns: "http://schemas.microsoft.com/deepzoom/2008",
                Url: a.getAttribute("Url"),
                Format: a.getAttribute("Format"),
                DisplayRect: null,
                Overlap: parseInt(a.getAttribute("Overlap"), 10),
                TileSize: parseInt(a.getAttribute("TileSize"), 10),
                Size: {
                  Height: parseInt(E.getAttribute("Height"), 10),
                  Width: parseInt(E.getAttribute("Width"), 10)
                }
              }
            }, !e.imageFormatSupported(h.Image.Format))
              throw new Error(
                e.getString("Errors.ImageFormat", h.Image.Format.toUpperCase())
              );
            for (g = a.getElementsByTagName("DisplayRect"), g === void 0 && (g = a.getElementsByTagNameNS(u, "DisplayRect")[0]), R = 0; R < g.length; R++)
              x = g[R], C = x.getElementsByTagName("Rect")[0], C === void 0 && (C = x.getElementsByTagNameNS(u, "Rect")[0]), f.push({
                Rect: {
                  X: parseInt(C.getAttribute("X"), 10),
                  Y: parseInt(C.getAttribute("Y"), 10),
                  Width: parseInt(C.getAttribute("Width"), 10),
                  Height: parseInt(C.getAttribute("Height"), 10),
                  MinLevel: parseInt(x.getAttribute("MinLevel"), 10),
                  MaxLevel: parseInt(x.getAttribute("MaxLevel"), 10)
                }
              });
            return f.length && (h.Image.DisplayRect = f), i(r, h);
          } catch (Z) {
            throw Z instanceof Error ? Z : new Error(e.getString("Errors.Dzi"));
          }
        else {
          if (c === "Collection")
            throw new Error(e.getString("Errors.Dzc"));
          if (c === "Error") {
            var D = a.getElementsByTagName("Message")[0], U = D.firstChild.nodeValue;
            throw new Error(U);
          }
        }
        throw new Error(e.getString("Errors.Dzi"));
      }
      function i(r, o) {
        var a = o.Image, c = a.Url, u = a.Format, h = a.Size, f = a.DisplayRect || [], g = parseInt(h.Width, 10), x = parseInt(h.Height, 10), C = parseInt(a.TileSize, 10), E = parseInt(a.Overlap, 10), R = [], D, U;
        for (U = 0; U < f.length; U++)
          D = f[U].Rect, R.push(new e.DisplayRect(
            parseInt(D.X, 10),
            parseInt(D.Y, 10),
            parseInt(D.Width, 10),
            parseInt(D.Height, 10),
            parseInt(D.MinLevel, 10),
            parseInt(D.MaxLevel, 10)
          ));
        return e.extend(!0, {
          width: g,
          /* width *required */
          height: x,
          /* height *required */
          tileSize: C,
          /* tileSize *required */
          tileOverlap: E,
          /* tileOverlap *required */
          minLevel: null,
          /* minLevel */
          maxLevel: null,
          /* maxLevel */
          tilesUrl: c,
          /* tilesUrl */
          fileFormat: u,
          /* fileFormat */
          displayRects: R
          /* displayRects */
        }, o);
      }
    })(n), (function(e) {
      e.IIIFTileSource = function(a) {
        if (e.extend(!0, this, a), this._id = this["@id"] || this.id || this.identifier || null, !(this.height && this.width && this._id))
          throw new Error("IIIF required parameters (width, height, or id) not provided.");
        if (a.tileSizePerScaleFactor = {}, this.tileFormat = this.tileFormat || "jpg", this.version = a.version, this.tile_width && this.tile_height)
          a.tileWidth = this.tile_width, a.tileHeight = this.tile_height;
        else if (this.tile_width)
          a.tileSize = this.tile_width;
        else if (this.tile_height)
          a.tileSize = this.tile_height;
        else if (this.tiles)
          if (this.tiles.length === 1)
            a.tileWidth = this.tiles[0].width, a.tileHeight = this.tiles[0].height || this.tiles[0].width, this.scale_factors = this.tiles[0].scaleFactors;
          else {
            this.scale_factors = [];
            for (var c = 0; c < this.tiles.length; c++)
              for (var u = 0; u < this.tiles[c].scaleFactors.length; u++) {
                var h = this.tiles[c].scaleFactors[u];
                this.scale_factors.push(h), a.tileSizePerScaleFactor[h] = {
                  width: this.tiles[c].width,
                  height: this.tiles[c].height || this.tiles[c].width
                };
              }
          }
        else if (t(a)) {
          for (var f = Math.min(this.height, this.width), g = [256, 512, 1024], x = [], C = 0; C < g.length; C++)
            g[C] <= f && x.push(g[C]);
          x.length > 0 ? a.tileSize = Math.max.apply(null, x) : a.tileSize = f;
        } else this.sizes && this.sizes.length > 0 ? (this.emulateLegacyImagePyramid = !0, a.levels = i(this), e.extend(!0, a, {
          width: a.levels[a.levels.length - 1].width,
          height: a.levels[a.levels.length - 1].height,
          tileSize: Math.max(a.height, a.width),
          tileOverlap: 0,
          minLevel: 0,
          maxLevel: a.levels.length - 1
        }), this.levels = a.levels) : e.console.error("Nothing in the info.json to construct image pyramids from");
        if (!a.maxLevel && !this.emulateLegacyImagePyramid)
          if (!this.scale_factors)
            a.maxLevel = Number(Math.round(Math.log(Math.max(this.width, this.height), 2)));
          else {
            var E = Math.max.apply(null, this.scale_factors);
            a.maxLevel = Math.round(Math.log(E) * Math.LOG2E);
          }
        if (this.sizes) {
          var R = this.sizes.length;
          (R === a.maxLevel || R === a.maxLevel + 1) && (this.levelSizes = this.sizes.slice().sort((D, U) => D.width - U.width), R === a.maxLevel && this.levelSizes.push({ width: this.width, height: this.height }));
        }
        e.TileSource.apply(this, [a]);
      }, e.extend(
        e.IIIFTileSource.prototype,
        e.TileSource.prototype,
        /** @lends OpenSeadragon.IIIFTileSource.prototype */
        {
          /**
           * Determine if the data and/or url imply the image service is supported by
           * this tile source.
           * @function
           * @param {Object|Array} data
           * @param {String} [url] - url
           */
          supports: function(a, c) {
            return a.protocol && a.protocol === "http://iiif.io/api/image" || a["@context"] && (a["@context"] === "http://library.stanford.edu/iiif/image-api/1.1/context.json" || a["@context"] === "http://iiif.io/api/image/1/context.json") || a.profile && a.profile.indexOf("http://library.stanford.edu/iiif/image-api/compliance.html") === 0 || a.identifier && a.width && a.height ? !0 : !!(a.documentElement && a.documentElement.tagName === "info" && a.documentElement.namespaceURI === "http://library.stanford.edu/iiif/image-api/ns/");
          },
          /**
           * A static function used to prepare an incoming IIIF Image API info.json
           * response for processing by the tile handler. Normalizes data for all
           * versions of IIIF (1.0, 1.1, 2.x, 3.x) and returns a data object that
           * may be passed to the IIIFTileSource.
           *
           * @function
           * @static
           * @param {Object} data - the raw configuration
           * @param {String} url - the url configuration was retrieved from
           * @param {String} postData - HTTP POST data in k=v&k2=v2... form or null
           * @returns {Object} A normalized IIIF data object
           * @example <caption>IIIF 2.x Info Looks like this</caption>
           * {
           * "@context": "http://iiif.io/api/image/2/context.json",
           * "@id": "http://iiif.example.com/prefix/1E34750D-38DB-4825-A38A-B60A345E591C",
           * "protocol": "http://iiif.io/api/image",
           * "height": 1024,
           * "width": 775,
           * "tiles" : [{"width":256, "scaleFactors":[1,2,4,8]}],
           *  "profile": ["http://iiif.io/api/image/2/level1.json", {
           *    "qualities": [ "native", "bitonal", "grey", "color" ],
           *    "formats": [ "jpg", "png", "gif" ]
           *   }]
           * }
           */
          configure: function(a, c, u) {
            if (e.isPlainObject(a)) {
              if (!a["@context"])
                a["@context"] = "http://iiif.io/api/image/1.0/context.json", a["@id"] = c.replace("/info.json", ""), a.version = 1;
              else {
                var f = a["@context"];
                if (Array.isArray(f)) {
                  for (var g = 0; g < f.length; g++)
                    if (typeof f[g] == "string" && (/^http:\/\/iiif\.io\/api\/image\/[1-3]\/context\.json$/.test(f[g]) || f[g] === "http://library.stanford.edu/iiif/image-api/1.1/context.json")) {
                      f = f[g];
                      break;
                    }
                }
                switch (f) {
                  case "http://iiif.io/api/image/1/context.json":
                  case "http://library.stanford.edu/iiif/image-api/1.1/context.json":
                    a.version = 1;
                    break;
                  case "http://iiif.io/api/image/2/context.json":
                    a.version = 2;
                    break;
                  case "http://iiif.io/api/image/3/context.json":
                    a.version = 3;
                    break;
                  default:
                    e.console.error("Data has a @context property which contains no known IIIF context URI.");
                }
              }
              if (a.preferredFormats) {
                for (var x = 0; x < a.preferredFormats.length; x++)
                  if (n.imageFormatSupported(a.preferredFormats[x])) {
                    a.tileFormat = a.preferredFormats[x];
                    break;
                  }
              }
              return a;
            } else {
              var h = r(a);
              return h["@context"] = "http://iiif.io/api/image/1.0/context.json", h["@id"] = c.replace("/info.xml", ""), h.version = 1, h;
            }
          },
          /**
           * Return the tileWidth for the given level.
           * @function
           * @param {Number} level
           */
          getTileWidth: function(a) {
            if (this.emulateLegacyImagePyramid)
              return e.TileSource.prototype.getTileWidth.call(this, a);
            var c = Math.pow(2, this.maxLevel - a);
            return this.tileSizePerScaleFactor && this.tileSizePerScaleFactor[c] ? this.tileSizePerScaleFactor[c].width : this._tileWidth;
          },
          /**
           * Return the tileHeight for the given level.
           * @function
           * @param {Number} level
           */
          getTileHeight: function(a) {
            if (this.emulateLegacyImagePyramid)
              return e.TileSource.prototype.getTileHeight.call(this, a);
            var c = Math.pow(2, this.maxLevel - a);
            return this.tileSizePerScaleFactor && this.tileSizePerScaleFactor[c] ? this.tileSizePerScaleFactor[c].height : this._tileHeight;
          },
          /**
           * @function
           * @param {Number} level
           */
          getLevelScale: function(a) {
            if (this.emulateLegacyImagePyramid) {
              var c = NaN;
              return this.levels.length > 0 && a >= this.minLevel && a <= this.maxLevel && (c = this.levels[a].width / this.levels[this.maxLevel].width), c;
            }
            return e.TileSource.prototype.getLevelScale.call(this, a);
          },
          /**
           * @function
           * @param {Number} level
           */
          getNumTiles: function(a) {
            if (this.emulateLegacyImagePyramid) {
              var c = this.getLevelScale(a);
              return c ? new e.Point(1, 1) : new e.Point(0, 0);
            }
            if (this.levelSizes) {
              var u = this.levelSizes[a], h = Math.ceil(u.width / this.getTileWidth(a)), f = Math.ceil(u.height / this.getTileHeight(a));
              return new e.Point(h, f);
            } else
              return e.TileSource.prototype.getNumTiles.call(this, a);
          },
          /**
           * @function
           * @param {Number} level
           * @param {OpenSeadragon.Point} point
           */
          getTileAtPoint: function(a, c) {
            if (this.emulateLegacyImagePyramid)
              return new e.Point(0, 0);
            if (this.levelSizes) {
              var u = c.x >= 0 && c.x <= 1 && c.y >= 0 && c.y <= 1 / this.aspectRatio;
              e.console.assert(u, "[TileSource.getTileAtPoint] must be called with a valid point.");
              var h = this.levelSizes[a].width, f = c.x * h, g = c.y * h, x = Math.floor(f / this.getTileWidth(a)), C = Math.floor(g / this.getTileHeight(a));
              c.x >= 1 && (x = this.getNumTiles(a).x - 1);
              var E = 1e-15;
              return c.y >= 1 / this.aspectRatio - E && (C = this.getNumTiles(a).y - 1), new e.Point(x, C);
            }
            return e.TileSource.prototype.getTileAtPoint.call(this, a, c);
          },
          /**
           * Responsible for retrieving the url which will return an image for the
           * region specified by the given x, y, and level components.
           * @function
           * @param {Number} level - z index
           * @param {Number} x
           * @param {Number} y
           * @throws {Error}
           */
          getTileUrl: function(a, c, u) {
            if (this.emulateLegacyImagePyramid) {
              var h = null;
              return this.levels.length > 0 && a >= this.minLevel && a <= this.maxLevel && (h = this.levels[a].url), h;
            }
            var f = "0", g = Math.pow(0.5, this.maxLevel - a), x, C, E, R, D, U, Z, ce, re, ue, me, Te, Re, He, Fe, _e;
            return this.levelSizes ? (x = this.levelSizes[a].width, C = this.levelSizes[a].height) : (x = Math.ceil(this.width * g), C = Math.ceil(this.height * g)), E = this.getTileWidth(a), R = this.getTileHeight(a), D = Math.round(E / g), U = Math.round(R / g), this.version === 1 ? Fe = "native." + this.tileFormat : Fe = "default." + this.tileFormat, x < E && C < R ? (this.version === 2 && x === this.width ? Te = "full" : this.version === 3 && x === this.width && C === this.height ? Te = "max" : this.version === 3 ? Te = x + "," + C : Te = x + ",", Z = "full") : (ce = c * D, re = u * U, ue = Math.min(D, this.width - ce), me = Math.min(U, this.height - re), c === 0 && u === 0 && ue === this.width && me === this.height ? Z = "full" : Z = [ce, re, ue, me].join(","), Re = Math.min(E, x - c * E), He = Math.min(R, C - u * R), this.version === 2 && Re === this.width ? Te = "full" : this.version === 3 && Re === this.width && He === this.height ? Te = "max" : this.version === 3 ? Te = Re + "," + He : Te = Re + ","), _e = [this._id, Z, Te, f, Fe].join("/"), _e;
          },
          __testonly__: {
            canBeTiled: t,
            constructLevels: i
          }
        }
      );
      function t(a) {
        var c = [
          "http://library.stanford.edu/iiif/image-api/compliance.html#level0",
          "http://library.stanford.edu/iiif/image-api/1.1/compliance.html#level0",
          "http://iiif.io/api/image/2/level0.json",
          "level0",
          "https://iiif.io/api/image/3/level0.json"
        ], u = Array.isArray(a.profile) ? a.profile[0] : a.profile, h = c.indexOf(u) !== -1, f = !1;
        return a.version === 2 && a.profile.length > 1 && a.profile[1].supports && (f = a.profile[1].supports.indexOf("sizeByW") !== -1), a.version === 3 && a.extraFeatures && (f = a.extraFeatures.indexOf("sizeByWh") !== -1), !h || f;
      }
      function i(a) {
        for (var c = [], u = 0; u < a.sizes.length; u++)
          c.push({
            url: a._id + "/full/" + a.sizes[u].width + "," + (a.version === 3 ? a.sizes[u].height : "") + "/0/default." + a.tileFormat,
            width: a.sizes[u].width,
            height: a.sizes[u].height
          });
        return c.sort(function(h, f) {
          return h.width - f.width;
        });
      }
      function r(a) {
        if (!a || !a.documentElement)
          throw new Error(e.getString("Errors.Xml"));
        var c = a.documentElement, u = c.tagName, h = null;
        if (u === "info")
          try {
            return h = {}, o(c, h), h;
          } catch (f) {
            throw f instanceof Error ? f : new Error(e.getString("Errors.IIIF"));
          }
        throw new Error(e.getString("Errors.IIIF"));
      }
      function o(a, c, u) {
        var h, f;
        if (a.nodeType === 3 && u)
          f = a.nodeValue.trim(), f.match(/^\d*$/) && (f = Number(f)), c[u] ? (e.isArray(c[u]) || (c[u] = [c[u]]), c[u].push(f)) : c[u] = f;
        else if (a.nodeType === 1)
          for (h = 0; h < a.childNodes.length; h++)
            o(a.childNodes[h], c, a.nodeName);
      }
    })(n), (function(e) {
      e.OsmTileSource = function(t, i, r, o, a) {
        var c;
        e.isPlainObject(t) ? c = t : c = {
          width: arguments[0],
          height: arguments[1],
          tileSize: arguments[2],
          tileOverlap: arguments[3],
          tilesUrl: arguments[4]
        }, (!c.width || !c.height) && (c.width = 65572864, c.height = 65572864), c.tileSize || (c.tileSize = 256, c.tileOverlap = 0), c.tilesUrl || (c.tilesUrl = "http://tile.openstreetmap.org/"), c.minLevel = 8, e.TileSource.apply(this, [c]);
      }, e.extend(
        e.OsmTileSource.prototype,
        e.TileSource.prototype,
        /** @lends OpenSeadragon.OsmTileSource.prototype */
        {
          /**
           * Determine if the data and/or url imply the image service is supported by
           * this tile source.
           * @function
           * @param {Object|Array} data
           * @param {String} optional - url
           */
          supports: function(t, i) {
            return t.type && t.type === "openstreetmaps";
          },
          /**
           *
           * @function
           * @param {Object} data - the raw configuration
           * @param {String} url - the url the data was retrieved from if any.
           * @param {String} postData - HTTP POST data in k=v&k2=v2... form or null
           * @returns {Object} options - A dictionary of keyword arguments sufficient
           *      to configure this tile sources constructor.
           */
          configure: function(t, i, r) {
            return t;
          },
          /**
           * @function
           * @param {Number} level
           * @param {Number} x
           * @param {Number} y
           */
          getTileUrl: function(t, i, r) {
            return this.tilesUrl + (t - 8) + "/" + i + "/" + r + ".png";
          }
        }
      );
    })(n), (function(e) {
      e.TmsTileSource = function(t, i, r, o, a) {
        var c;
        e.isPlainObject(t) ? c = t : c = {
          width: arguments[0],
          height: arguments[1],
          tileSize: arguments[2],
          tileOverlap: arguments[3],
          tilesUrl: arguments[4]
        };
        var u = Math.ceil(c.width / 256) * 256, h = Math.ceil(c.height / 256) * 256, f;
        u > h ? f = u / 256 : f = h / 256, c.maxLevel = Math.ceil(Math.log(f) / Math.log(2)) - 1, c.tileSize = 256, c.width = u, c.height = h, e.TileSource.apply(this, [c]);
      }, e.extend(
        e.TmsTileSource.prototype,
        e.TileSource.prototype,
        /** @lends OpenSeadragon.TmsTileSource.prototype */
        {
          /**
           * Determine if the data and/or url imply the image service is supported by
           * this tile source.
           * @function
           * @param {Object|Array} data
           * @param {String} optional - url
           */
          supports: function(t, i) {
            return t.type && t.type === "tiledmapservice";
          },
          /**
           *
           * @function
           * @param {Object} data - the raw configuration
           * @param {String} url - the url the data was retrieved from if any.
           * @param {String} postData - HTTP POST data in k=v&k2=v2... form or null
           * @returns {Object} options - A dictionary of keyword arguments sufficient
           *      to configure this tile sources constructor.
           */
          configure: function(t, i, r) {
            return t;
          },
          /**
           * @function
           * @param {Number} level
           * @param {Number} x
           * @param {Number} y
           */
          getTileUrl: function(t, i, r) {
            var o = this.getNumTiles(t).y - 1;
            return this.tilesUrl + t + "/" + i + "/" + (o - r) + ".png";
          }
        }
      );
    })(n), (function(e) {
      e.ZoomifyTileSource = function(t) {
        typeof t.tileSize > "u" && (t.tileSize = 256), typeof t.fileFormat > "u" && (t.fileFormat = "jpg", this.fileFormat = t.fileFormat);
        var i = {
          x: t.width,
          y: t.height
        };
        for (t.imageSizes = [{
          x: t.width,
          y: t.height
        }], t.gridSize = [this._getGridSize(t.width, t.height, t.tileSize)]; parseInt(i.x, 10) > t.tileSize || parseInt(i.y, 10) > t.tileSize; )
          i.x = Math.floor(i.x / 2), i.y = Math.floor(i.y / 2), t.imageSizes.push({
            x: i.x,
            y: i.y
          }), t.gridSize.push(this._getGridSize(i.x, i.y, t.tileSize));
        t.imageSizes.reverse(), t.gridSize.reverse(), t.minLevel = 0, t.maxLevel = t.gridSize.length - 1, n.TileSource.apply(this, [t]);
      }, e.extend(
        e.ZoomifyTileSource.prototype,
        e.TileSource.prototype,
        /** @lends OpenSeadragon.ZoomifyTileSource.prototype */
        {
          //private
          _getGridSize: function(t, i, r) {
            return {
              x: Math.ceil(t / r),
              y: Math.ceil(i / r)
            };
          },
          //private
          _calculateAbsoluteTileNumber: function(t, i, r) {
            for (var o = 0, a = {}, c = 0; c < t; c++)
              a = this.gridSize[c], o += a.x * a.y;
            return a = this.gridSize[t], o += a.x * r + i, o;
          },
          /**
           * Determine if the data and/or url imply the image service is supported by
           * this tile source.
           * @function
           * @param {Object|Array} data
           * @param {String} optional - url
           */
          supports: function(t, i) {
            return t.type && t.type === "zoomifytileservice";
          },
          /**
           *
           * @function
           * @param {Object} data - the raw configuration
           * @param {String} url - the url the data was retrieved from if any.
           * @param {String} postData - HTTP POST data in k=v&k2=v2... form or null
           * @returns {Object} options - A dictionary of keyword arguments sufficient
           *      to configure this tile sources constructor.
           */
          configure: function(t, i, r) {
            return t;
          },
          /**
           * @function
           * @param {Number} level
           * @param {Number} x
           * @param {Number} y
           */
          getTileUrl: function(t, i, r) {
            var o = 0, a = this._calculateAbsoluteTileNumber(t, i, r);
            return o = Math.floor(a / 256), this.tilesUrl + "TileGroup" + o + "/" + t + "-" + i + "-" + r + "." + this.fileFormat;
          }
        }
      );
    })(n), (function(e) {
      e.LegacyTileSource = function(o) {
        var a, c, u;
        e.isArray(o) && (a = {
          type: "legacy-image-pyramid",
          levels: o
        }), a.levels = t(a.levels), a.levels.length > 0 ? (c = a.levels[a.levels.length - 1].width, u = a.levels[a.levels.length - 1].height) : (c = 0, u = 0, e.console.error("No supported image formats found")), e.extend(!0, a, {
          width: c,
          height: u,
          tileSize: Math.max(u, c),
          tileOverlap: 0,
          minLevel: 0,
          maxLevel: a.levels.length > 0 ? a.levels.length - 1 : 0
        }), e.TileSource.apply(this, [a]), this.levels = a.levels;
      }, e.extend(
        e.LegacyTileSource.prototype,
        e.TileSource.prototype,
        /** @lends OpenSeadragon.LegacyTileSource.prototype */
        {
          /**
           * Determine if the data and/or url imply the image service is supported by
           * this tile source.
           * @function
           * @param {Object|Array} data
           * @param {String} optional - url
           */
          supports: function(o, a) {
            return o.type && o.type === "legacy-image-pyramid" || o.documentElement && o.documentElement.getAttribute("type") === "legacy-image-pyramid";
          },
          /**
           *
           * @function
           * @param {Object|XMLDocument} configuration - the raw configuration
           * @param {String} dataUrl - the url the data was retrieved from if any.
           * @param {String} postData - HTTP POST data in k=v&k2=v2... form or null
           * @returns {Object} options - A dictionary of keyword arguments sufficient
           *      to configure this tile sources constructor.
           */
          configure: function(o, a, c) {
            var u;
            return e.isPlainObject(o) ? u = r(this, o) : u = i(this, o), u;
          },
          /**
           * @function
           * @param {Number} level
           */
          getLevelScale: function(o) {
            var a = NaN;
            return this.levels.length > 0 && o >= this.minLevel && o <= this.maxLevel && (a = this.levels[o].width / this.levels[this.maxLevel].width), a;
          },
          /**
           * @function
           * @param {Number} level
           */
          getNumTiles: function(o) {
            var a = this.getLevelScale(o);
            return a ? new e.Point(1, 1) : new e.Point(0, 0);
          },
          /**
           * This method is not implemented by this class other than to throw an Error
           * announcing you have to implement it.  Because of the variety of tile
           * server technologies, and various specifications for building image
           * pyramids, this method is here to allow easy integration.
           * @function
           * @param {Number} level
           * @param {Number} x
           * @param {Number} y
           * @throws {Error}
           */
          getTileUrl: function(o, a, c) {
            var u = null;
            return this.levels.length > 0 && o >= this.minLevel && o <= this.maxLevel && (u = this.levels[o].url), u;
          }
        }
      );
      function t(o) {
        var a = [], c, u;
        for (u = 0; u < o.length; u++)
          c = o[u], c.height && c.width && c.url ? a.push({
            url: c.url,
            width: Number(c.width),
            height: Number(c.height)
          }) : e.console.error("Unsupported image format: %s", c.url ? c.url : "<no URL>");
        return a.sort(function(h, f) {
          return h.height - f.height;
        });
      }
      function i(o, a) {
        if (!a || !a.documentElement)
          throw new Error(e.getString("Errors.Xml"));
        var c = a.documentElement, u = c.tagName, h = null, f = [], g, x;
        if (u === "image")
          try {
            for (h = {
              type: c.getAttribute("type"),
              levels: []
            }, f = c.getElementsByTagName("level"), x = 0; x < f.length; x++)
              g = f[x], h.levels.push({
                url: g.getAttribute("url"),
                width: parseInt(g.getAttribute("width"), 10),
                height: parseInt(g.getAttribute("height"), 10)
              });
            return r(o, h);
          } catch (C) {
            throw C instanceof Error ? C : new Error("Unknown error parsing Legacy Image Pyramid XML.");
          }
        else {
          if (u === "collection")
            throw new Error("Legacy Image Pyramid Collections not yet supported.");
          if (u === "error")
            throw new Error("Error: " + a);
        }
        throw new Error("Unknown element " + u);
      }
      function r(o, a) {
        return a.levels;
      }
    })(n), (function(e) {
      e.ImageTileSource = function(t) {
        t = e.extend({
          buildPyramid: !0,
          crossOriginPolicy: !1,
          ajaxWithCredentials: !1
        }, t), e.TileSource.apply(this, [t]);
      }, e.extend(
        e.ImageTileSource.prototype,
        e.TileSource.prototype,
        /** @lends OpenSeadragon.ImageTileSource.prototype */
        {
          /**
           * Determine if the data and/or url imply the image service is supported by
           * this tile source.
           * @function
           * @param {Object|Array} data
           * @param {String} optional - url
           */
          supports: function(t, i) {
            return t.type && t.type === "image";
          },
          /**
           *
           * @function
           * @param {Object} options - the options
           * @param {String} dataUrl - the url the image was retrieved from, if any.
           * @param {String} postData - HTTP POST data in k=v&k2=v2... form or null
           * @returns {Object} options - A dictionary of keyword arguments sufficient
           *      to configure this tile sources constructor.
           */
          configure: function(t, i, r) {
            return t;
          },
          /**
           * Responsible for retrieving, and caching the
           * image metadata pertinent to this TileSources implementation.
           * @function
           * @param {String} url
           * @throws {Error}
           */
          getImageInfo: function(t) {
            var i = this._image = new Image(), r = this;
            this.crossOriginPolicy && (i.crossOrigin = this.crossOriginPolicy), this.ajaxWithCredentials && (i.useCredentials = this.ajaxWithCredentials), e.addEvent(i, "load", function() {
              r.width = i.naturalWidth, r.height = i.naturalHeight, r.aspectRatio = r.width / r.height, r.dimensions = new e.Point(r.width, r.height), r._tileWidth = r.width, r._tileHeight = r.height, r.tileOverlap = 0, r.minLevel = 0, r.levels = r._buildLevels(), r.maxLevel = r.levels.length - 1, r.ready = !0, r.raiseEvent("ready", { tileSource: r });
            }), e.addEvent(i, "error", function() {
              r.raiseEvent("open-failed", {
                message: "Error loading image at " + t,
                source: t
              });
            }), i.src = t;
          },
          /**
           * @function
           * @param {Number} level
           */
          getLevelScale: function(t) {
            var i = NaN;
            return t >= this.minLevel && t <= this.maxLevel && (i = this.levels[t].width / this.levels[this.maxLevel].width), i;
          },
          /**
           * @function
           * @param {Number} level
           */
          getNumTiles: function(t) {
            var i = this.getLevelScale(t);
            return i ? new e.Point(1, 1) : new e.Point(0, 0);
          },
          /**
           * Retrieves a tile url
           * @function
           * @param {Number} level Level of the tile
           * @param {Number} x x coordinate of the tile
           * @param {Number} y y coordinate of the tile
           */
          getTileUrl: function(t, i, r) {
            var o = null;
            return t >= this.minLevel && t <= this.maxLevel && (o = this.levels[t].url), o;
          },
          /**
           * Retrieves a tile context 2D
           * @function
           * @param {Number} level Level of the tile
           * @param {Number} x x coordinate of the tile
           * @param {Number} y y coordinate of the tile
           */
          getContext2D: function(t, i, r) {
            var o = null;
            return t >= this.minLevel && t <= this.maxLevel && (o = this.levels[t].context2D), o;
          },
          /**
           * Destroys ImageTileSource
           * @function
           * @param {OpenSeadragon.Viewer} viewer the viewer that is calling
           * destroy on the ImageTileSource
           */
          destroy: function(t) {
            this._freeupCanvasMemory(t);
          },
          // private
          //
          // Builds the different levels of the pyramid if possible
          // (i.e. if canvas API enabled and no canvas tainting issue).
          _buildLevels: function() {
            var t = [{
              url: this._image.src,
              width: this._image.naturalWidth,
              height: this._image.naturalHeight
            }];
            if (!this.buildPyramid || !e.supportsCanvas)
              return delete this._image, t;
            var i = this._image.naturalWidth, r = this._image.naturalHeight, o = document.createElement("canvas"), a = o.getContext("2d");
            if (o.width = i, o.height = r, a.drawImage(this._image, 0, 0, i, r), t[0].context2D = a, delete this._image, e.isCanvasTainted(o))
              return t;
            for (; i >= 2 && r >= 2; ) {
              i = Math.floor(i / 2), r = Math.floor(r / 2);
              var c = document.createElement("canvas"), u = c.getContext("2d");
              c.width = i, c.height = r, u.drawImage(o, 0, 0, i, r), t.splice(0, 0, {
                context2D: u,
                width: i,
                height: r
              }), o = c, a = u;
            }
            return t;
          },
          /**
           * Free up canvas memory
           * (iOS 12 or higher on 2GB RAM device has only 224MB canvas memory,
           * and Safari keeps canvas until its height and width will be set to 0).
           * @function
           */
          _freeupCanvasMemory: function(t) {
            for (var i = 0; i < this.levels.length; i++)
              this.levels[i].context2D && (this.levels[i].context2D.canvas.height = 0, this.levels[i].context2D.canvas.width = 0, t && t.raiseEvent("image-unloaded", {
                context2D: this.levels[i].context2D
              }));
          }
        }
      );
    })(n), (function(e) {
      e.TileSourceCollection = function(t, i, r, o) {
        e.console.error("TileSourceCollection is deprecated; use World instead");
      };
    })(n), (function(e) {
      e.ButtonState = {
        REST: 0,
        GROUP: 1,
        HOVER: 2,
        DOWN: 3
      }, e.Button = function(u) {
        var h = this;
        e.EventSource.call(this), e.extend(!0, this, {
          tooltip: null,
          srcRest: null,
          srcGroup: null,
          srcHover: null,
          srcDown: null,
          clickTimeThreshold: e.DEFAULT_SETTINGS.clickTimeThreshold,
          clickDistThreshold: e.DEFAULT_SETTINGS.clickDistThreshold,
          /**
           * How long to wait before fading.
           * @member {Number} fadeDelay
           * @memberof OpenSeadragon.Button#
           */
          fadeDelay: 0,
          /**
           * How long should it take to fade the button.
           * @member {Number} fadeLength
           * @memberof OpenSeadragon.Button#
           */
          fadeLength: 2e3,
          onPress: null,
          onRelease: null,
          onClick: null,
          onEnter: null,
          onExit: null,
          onFocus: null,
          onBlur: null,
          userData: null
        }, u), this.element = u.element || e.makeNeutralElement("div"), u.element || (this.imgRest = e.makeTransparentImage(this.srcRest), this.imgGroup = e.makeTransparentImage(this.srcGroup), this.imgHover = e.makeTransparentImage(this.srcHover), this.imgDown = e.makeTransparentImage(this.srcDown), this.imgRest.alt = this.imgGroup.alt = this.imgHover.alt = this.imgDown.alt = this.tooltip, e.setElementPointerEventsNone(this.imgRest), e.setElementPointerEventsNone(this.imgGroup), e.setElementPointerEventsNone(this.imgHover), e.setElementPointerEventsNone(this.imgDown), this.element.style.position = "relative", e.setElementTouchActionNone(this.element), this.imgGroup.style.position = this.imgHover.style.position = this.imgDown.style.position = "absolute", this.imgGroup.style.top = this.imgHover.style.top = this.imgDown.style.top = "0px", this.imgGroup.style.left = this.imgHover.style.left = this.imgDown.style.left = "0px", this.imgHover.style.visibility = this.imgDown.style.visibility = "hidden", this.element.appendChild(this.imgRest), this.element.appendChild(this.imgGroup), this.element.appendChild(this.imgHover), this.element.appendChild(this.imgDown)), this.addHandler("press", this.onPress), this.addHandler("release", this.onRelease), this.addHandler("click", this.onClick), this.addHandler("enter", this.onEnter), this.addHandler("exit", this.onExit), this.addHandler("focus", this.onFocus), this.addHandler("blur", this.onBlur), this.currentState = e.ButtonState.GROUP, this.fadeBeginTime = null, this.shouldFade = !1, this.element.style.display = "inline-block", this.element.style.position = "relative", this.element.title = this.tooltip, this.tracker = new e.MouseTracker({
          userData: "Button.tracker",
          element: this.element,
          clickTimeThreshold: this.clickTimeThreshold,
          clickDistThreshold: this.clickDistThreshold,
          enterHandler: function(f) {
            f.insideElementPressed ? (a(h, e.ButtonState.DOWN), h.raiseEvent("enter", { originalEvent: f.originalEvent })) : f.buttonDownAny || a(h, e.ButtonState.HOVER);
          },
          focusHandler: function(f) {
            h.tracker.enterHandler(f), h.raiseEvent("focus", { originalEvent: f.originalEvent });
          },
          leaveHandler: function(f) {
            c(h, e.ButtonState.GROUP), f.insideElementPressed && h.raiseEvent("exit", { originalEvent: f.originalEvent });
          },
          blurHandler: function(f) {
            h.tracker.leaveHandler(f), h.raiseEvent("blur", { originalEvent: f.originalEvent });
          },
          pressHandler: function(f) {
            a(h, e.ButtonState.DOWN), h.raiseEvent("press", { originalEvent: f.originalEvent });
          },
          releaseHandler: function(f) {
            f.insideElementPressed && f.insideElementReleased ? (c(h, e.ButtonState.HOVER), h.raiseEvent("release", { originalEvent: f.originalEvent })) : f.insideElementPressed ? c(h, e.ButtonState.GROUP) : a(h, e.ButtonState.HOVER);
          },
          clickHandler: function(f) {
            f.quick && h.raiseEvent("click", { originalEvent: f.originalEvent });
          },
          keyHandler: function(f) {
            f.keyCode === 13 ? (h.raiseEvent("click", { originalEvent: f.originalEvent }), h.raiseEvent("release", { originalEvent: f.originalEvent }), f.preventDefault = !0) : f.preventDefault = !1;
          }
        }), c(this, e.ButtonState.REST);
      }, e.extend(
        e.Button.prototype,
        e.EventSource.prototype,
        /** @lends OpenSeadragon.Button.prototype */
        {
          /**
           * Used by a button container element (e.g. a ButtonGroup) to transition the button state
           * to ButtonState.GROUP.
           * @function
           */
          notifyGroupEnter: function() {
            a(this, e.ButtonState.GROUP);
          },
          /**
           * Used by a button container element (e.g. a ButtonGroup) to transition the button state
           * to ButtonState.REST.
           * @function
           */
          notifyGroupExit: function() {
            c(this, e.ButtonState.REST);
          },
          /**
           * @function
           */
          disable: function() {
            this.notifyGroupExit(), this.element.disabled = !0, this.tracker.setTracking(!1), e.setElementOpacity(this.element, 0.2, !0);
          },
          /**
           * @function
           */
          enable: function() {
            this.element.disabled = !1, this.tracker.setTracking(!0), e.setElementOpacity(this.element, 1, !0), this.notifyGroupEnter();
          },
          destroy: function() {
            this.imgRest && (this.element.removeChild(this.imgRest), this.imgRest = null), this.imgGroup && (this.element.removeChild(this.imgGroup), this.imgGroup = null), this.imgHover && (this.element.removeChild(this.imgHover), this.imgHover = null), this.imgDown && (this.element.removeChild(this.imgDown), this.imgDown = null), this.removeAllHandlers(), this.tracker.destroy(), this.element = null;
          }
        }
      );
      function t(u) {
        e.requestAnimationFrame(function() {
          i(u);
        });
      }
      function i(u) {
        var h, f, g;
        u.shouldFade && (h = e.now(), f = h - u.fadeBeginTime, g = 1 - f / u.fadeLength, g = Math.min(1, g), g = Math.max(0, g), u.imgGroup && e.setElementOpacity(u.imgGroup, g, !0), g > 0 && t(u));
      }
      function r(u) {
        u.shouldFade = !0, u.fadeBeginTime = e.now() + u.fadeDelay, window.setTimeout(function() {
          t(u);
        }, u.fadeDelay);
      }
      function o(u) {
        u.shouldFade = !1, u.imgGroup && e.setElementOpacity(u.imgGroup, 1, !0);
      }
      function a(u, h) {
        u.element.disabled || (h >= e.ButtonState.GROUP && u.currentState === e.ButtonState.REST && (o(u), u.currentState = e.ButtonState.GROUP), h >= e.ButtonState.HOVER && u.currentState === e.ButtonState.GROUP && (u.imgHover && (u.imgHover.style.visibility = ""), u.currentState = e.ButtonState.HOVER), h >= e.ButtonState.DOWN && u.currentState === e.ButtonState.HOVER && (u.imgDown && (u.imgDown.style.visibility = ""), u.currentState = e.ButtonState.DOWN));
      }
      function c(u, h) {
        u.element.disabled || (h <= e.ButtonState.HOVER && u.currentState === e.ButtonState.DOWN && (u.imgDown && (u.imgDown.style.visibility = "hidden"), u.currentState = e.ButtonState.HOVER), h <= e.ButtonState.GROUP && u.currentState === e.ButtonState.HOVER && (u.imgHover && (u.imgHover.style.visibility = "hidden"), u.currentState = e.ButtonState.GROUP), h <= e.ButtonState.REST && u.currentState === e.ButtonState.GROUP && (r(u), u.currentState = e.ButtonState.REST));
      }
    })(n), (function(e) {
      e.ButtonGroup = function(t) {
        e.extend(!0, this, {
          /**
           * An array containing the buttons themselves.
           * @member {Array} buttons
           * @memberof OpenSeadragon.ButtonGroup#
           */
          buttons: [],
          clickTimeThreshold: e.DEFAULT_SETTINGS.clickTimeThreshold,
          clickDistThreshold: e.DEFAULT_SETTINGS.clickDistThreshold,
          labelText: ""
        }, t);
        var i = this.buttons.concat([]), r = this, o;
        if (this.element = t.element || e.makeNeutralElement("div"), !t.group)
          for (this.element.style.display = "inline-block", o = 0; o < i.length; o++)
            this.element.appendChild(i[o].element);
        e.setElementTouchActionNone(this.element), this.tracker = new e.MouseTracker({
          userData: "ButtonGroup.tracker",
          element: this.element,
          clickTimeThreshold: this.clickTimeThreshold,
          clickDistThreshold: this.clickDistThreshold,
          enterHandler: function(a) {
            var c;
            for (c = 0; c < r.buttons.length; c++)
              r.buttons[c].notifyGroupEnter();
          },
          leaveHandler: function(a) {
            var c;
            if (!a.insideElementPressed)
              for (c = 0; c < r.buttons.length; c++)
                r.buttons[c].notifyGroupExit();
          }
        });
      }, e.ButtonGroup.prototype = {
        /**
         * Adds the given button to this button group.
         *
         * @function
         * @param {OpenSeadragon.Button} button
         */
        addButton: function(t) {
          this.buttons.push(t), this.element.appendChild(t.element);
        },
        /**
         * TODO: Figure out why this is used on the public API and if a more useful
         * api can be created.
         * @function
         * @private
         */
        emulateEnter: function() {
          this.tracker.enterHandler({ eventSource: this.tracker });
        },
        /**
         * TODO: Figure out why this is used on the public API and if a more useful
         * api can be created.
         * @function
         * @private
         */
        emulateLeave: function() {
          this.tracker.leaveHandler({ eventSource: this.tracker });
        },
        destroy: function() {
          for (; this.buttons.length; ) {
            var t = this.buttons.pop();
            this.element.removeChild(t.element), t.destroy();
          }
          this.tracker.destroy(), this.element = null;
        }
      };
    })(n), (function(e) {
      e.Rect = function(t, i, r, o, a) {
        this.x = typeof t == "number" ? t : 0, this.y = typeof i == "number" ? i : 0, this.width = typeof r == "number" ? r : 0, this.height = typeof o == "number" ? o : 0, this.degrees = typeof a == "number" ? a : 0, this.degrees = e.positiveModulo(this.degrees, 360);
        var c, u;
        this.degrees >= 270 ? (c = this.getTopRight(), this.x = c.x, this.y = c.y, u = this.height, this.height = this.width, this.width = u, this.degrees -= 270) : this.degrees >= 180 ? (c = this.getBottomRight(), this.x = c.x, this.y = c.y, this.degrees -= 180) : this.degrees >= 90 && (c = this.getBottomLeft(), this.x = c.x, this.y = c.y, u = this.height, this.height = this.width, this.width = u, this.degrees -= 90);
      }, e.Rect.fromSummits = function(t, i, r) {
        var o = t.distanceTo(i), a = t.distanceTo(r), c = i.minus(t), u = Math.atan(c.y / c.x);
        return c.x < 0 ? u += Math.PI : c.y < 0 && (u += 2 * Math.PI), new e.Rect(
          t.x,
          t.y,
          o,
          a,
          u / Math.PI * 180
        );
      }, e.Rect.prototype = {
        /**
         * @function
         * @returns {OpenSeadragon.Rect} a duplicate of this Rect
         */
        clone: function() {
          return new e.Rect(
            this.x,
            this.y,
            this.width,
            this.height,
            this.degrees
          );
        },
        /**
         * The aspect ratio is simply the ratio of width to height.
         * @function
         * @returns {Number} The ratio of width to height.
         */
        getAspectRatio: function() {
          return this.width / this.height;
        },
        /**
         * Provides the coordinates of the upper-left corner of the rectangle as a
         * point.
         * @function
         * @returns {OpenSeadragon.Point} The coordinate of the upper-left corner of
         *  the rectangle.
         */
        getTopLeft: function() {
          return new e.Point(
            this.x,
            this.y
          );
        },
        /**
         * Provides the coordinates of the bottom-right corner of the rectangle as a
         * point.
         * @function
         * @returns {OpenSeadragon.Point} The coordinate of the bottom-right corner of
         *  the rectangle.
         */
        getBottomRight: function() {
          return new e.Point(this.x + this.width, this.y + this.height).rotate(this.degrees, this.getTopLeft());
        },
        /**
         * Provides the coordinates of the top-right corner of the rectangle as a
         * point.
         * @function
         * @returns {OpenSeadragon.Point} The coordinate of the top-right corner of
         *  the rectangle.
         */
        getTopRight: function() {
          return new e.Point(this.x + this.width, this.y).rotate(this.degrees, this.getTopLeft());
        },
        /**
         * Provides the coordinates of the bottom-left corner of the rectangle as a
         * point.
         * @function
         * @returns {OpenSeadragon.Point} The coordinate of the bottom-left corner of
         *  the rectangle.
         */
        getBottomLeft: function() {
          return new e.Point(this.x, this.y + this.height).rotate(this.degrees, this.getTopLeft());
        },
        /**
         * Computes the center of the rectangle.
         * @function
         * @returns {OpenSeadragon.Point} The center of the rectangle as represented
         *  as represented by a 2-dimensional vector (x,y)
         */
        getCenter: function() {
          return new e.Point(
            this.x + this.width / 2,
            this.y + this.height / 2
          ).rotate(this.degrees, this.getTopLeft());
        },
        /**
         * Returns the width and height component as a vector OpenSeadragon.Point
         * @function
         * @returns {OpenSeadragon.Point} The 2 dimensional vector representing the
         *  width and height of the rectangle.
         */
        getSize: function() {
          return new e.Point(this.width, this.height);
        },
        /**
         * Determines if two Rectangles have equivalent components.
         * @function
         * @param {OpenSeadragon.Rect} rectangle The Rectangle to compare to.
         * @returns {Boolean} 'true' if all components are equal, otherwise 'false'.
         */
        equals: function(t) {
          return t instanceof e.Rect && this.x === t.x && this.y === t.y && this.width === t.width && this.height === t.height && this.degrees === t.degrees;
        },
        /**
        * Multiply all dimensions (except degrees) in this Rect by a factor and
        * return a new Rect.
        * @function
        * @param {Number} factor The factor to multiply vector components.
        * @returns {OpenSeadragon.Rect} A new rect representing the multiplication
        *  of the vector components by the factor
        */
        times: function(t) {
          return new e.Rect(
            this.x * t,
            this.y * t,
            this.width * t,
            this.height * t,
            this.degrees
          );
        },
        /**
        * Translate/move this Rect by a vector and return new Rect.
        * @function
        * @param {OpenSeadragon.Point} delta The translation vector.
        * @returns {OpenSeadragon.Rect} A new rect with altered position
        */
        translate: function(t) {
          return new e.Rect(
            this.x + t.x,
            this.y + t.y,
            this.width,
            this.height,
            this.degrees
          );
        },
        /**
         * Returns the smallest rectangle that will contain this and the given
         * rectangle bounding boxes.
         * @param {OpenSeadragon.Rect} rect
         * @returns {OpenSeadragon.Rect} The new rectangle.
         */
        union: function(t) {
          var i = this.getBoundingBox(), r = t.getBoundingBox(), o = Math.min(i.x, r.x), a = Math.min(i.y, r.y), c = Math.max(
            i.x + i.width,
            r.x + r.width
          ), u = Math.max(
            i.y + i.height,
            r.y + r.height
          );
          return new e.Rect(
            o,
            a,
            c - o,
            u - a
          );
        },
        /**
         * Returns the bounding box of the intersection of this rectangle with the
         * given rectangle.
         * @param {OpenSeadragon.Rect} rect
         * @returns {OpenSeadragon.Rect} the bounding box of the intersection
         * or null if the rectangles don't intersect.
         */
        intersection: function(t) {
          var i = 1e-10, r = [], o = this.getTopLeft();
          t.containsPoint(o, i) && r.push(o);
          var a = this.getTopRight();
          t.containsPoint(a, i) && r.push(a);
          var c = this.getBottomLeft();
          t.containsPoint(c, i) && r.push(c);
          var u = this.getBottomRight();
          t.containsPoint(u, i) && r.push(u);
          var h = t.getTopLeft();
          this.containsPoint(h, i) && r.push(h);
          var f = t.getTopRight();
          this.containsPoint(f, i) && r.push(f);
          var g = t.getBottomLeft();
          this.containsPoint(g, i) && r.push(g);
          var x = t.getBottomRight();
          this.containsPoint(x, i) && r.push(x);
          for (var C = this._getSegments(), E = t._getSegments(), R = 0; R < C.length; R++)
            for (var D = C[R], U = 0; U < E.length; U++) {
              var Z = E[U], ce = re(
                D[0],
                D[1],
                Z[0],
                Z[1]
              );
              ce && r.push(ce);
            }
          function re(_e, Ae, Je, Ge) {
            var qe = Ae.minus(_e), nt = Ge.minus(Je), Ve = -nt.x * qe.y + qe.x * nt.y;
            if (Ve === 0)
              return null;
            var ot = (qe.x * (_e.y - Je.y) - qe.y * (_e.x - Je.x)) / Ve, $e = (nt.x * (_e.y - Je.y) - nt.y * (_e.x - Je.x)) / Ve;
            return -i <= ot && ot <= 1 - i && -i <= $e && $e <= 1 - i ? new e.Point(_e.x + $e * qe.x, _e.y + $e * qe.y) : null;
          }
          if (r.length === 0)
            return null;
          for (var ue = r[0].x, me = r[0].x, Te = r[0].y, Re = r[0].y, He = 1; He < r.length; He++) {
            var Fe = r[He];
            Fe.x < ue && (ue = Fe.x), Fe.x > me && (me = Fe.x), Fe.y < Te && (Te = Fe.y), Fe.y > Re && (Re = Fe.y);
          }
          return new e.Rect(ue, Te, me - ue, Re - Te);
        },
        // private
        _getSegments: function() {
          var t = this.getTopLeft(), i = this.getTopRight(), r = this.getBottomLeft(), o = this.getBottomRight();
          return [
            [t, i],
            [i, o],
            [o, r],
            [r, t]
          ];
        },
        /**
         * Rotates a rectangle around a point.
         * @function
         * @param {Number} degrees The angle in degrees to rotate.
         * @param {OpenSeadragon.Point} [pivot] The point about which to rotate.
         * Defaults to the center of the rectangle.
         * @returns {OpenSeadragon.Rect}
         */
        rotate: function(t, i) {
          if (t = e.positiveModulo(t, 360), t === 0)
            return this.clone();
          i = i || this.getCenter();
          var r = this.getTopLeft().rotate(t, i), o = this.getTopRight().rotate(t, i), a = o.minus(r);
          a = a.apply(function(u) {
            var h = 1e-15;
            return Math.abs(u) < h ? 0 : u;
          });
          var c = Math.atan(a.y / a.x);
          return a.x < 0 ? c += Math.PI : a.y < 0 && (c += 2 * Math.PI), new e.Rect(
            r.x,
            r.y,
            this.width,
            this.height,
            c / Math.PI * 180
          );
        },
        /**
         * Retrieves the smallest horizontal (degrees=0) rectangle which contains
         * this rectangle.
         * @returns {OpenSeadragon.Rect}
         */
        getBoundingBox: function() {
          if (this.degrees === 0)
            return this.clone();
          var t = this.getTopLeft(), i = this.getTopRight(), r = this.getBottomLeft(), o = this.getBottomRight(), a = Math.min(t.x, i.x, r.x, o.x), c = Math.max(t.x, i.x, r.x, o.x), u = Math.min(t.y, i.y, r.y, o.y), h = Math.max(t.y, i.y, r.y, o.y);
          return new e.Rect(
            a,
            u,
            c - a,
            h - u
          );
        },
        /**
         * Retrieves the smallest horizontal (degrees=0) rectangle which contains
         * this rectangle and has integers x, y, width and height
         * @returns {OpenSeadragon.Rect}
         */
        getIntegerBoundingBox: function() {
          var t = this.getBoundingBox(), i = Math.floor(t.x), r = Math.floor(t.y), o = Math.ceil(t.width + t.x - i), a = Math.ceil(t.height + t.y - r);
          return new e.Rect(i, r, o, a);
        },
        /**
         * Determines whether a point is inside this rectangle (edge included).
         * @function
         * @param {OpenSeadragon.Point} point
         * @param {Number} [epsilon=0] the margin of error allowed
         * @returns {Boolean} true if the point is inside this rectangle, false
         * otherwise.
         */
        containsPoint: function(t, i) {
          i = i || 0;
          var r = this.getTopLeft(), o = this.getTopRight(), a = this.getBottomLeft(), c = o.minus(r), u = a.minus(r);
          return (t.x - r.x) * c.x + (t.y - r.y) * c.y >= -i && (t.x - o.x) * c.x + (t.y - o.y) * c.y <= i && (t.x - r.x) * u.x + (t.y - r.y) * u.y >= -i && (t.x - a.x) * u.x + (t.y - a.y) * u.y <= i;
        },
        /**
         * Provides a string representation of the rectangle which is useful for
         * debugging.
         * @function
         * @returns {String} A string representation of the rectangle.
         */
        toString: function() {
          return "[" + Math.round(this.x * 100) / 100 + ", " + Math.round(this.y * 100) / 100 + ", " + Math.round(this.width * 100) / 100 + "x" + Math.round(this.height * 100) / 100 + ", " + Math.round(this.degrees * 100) / 100 + "deg]";
        }
      };
    })(n), (function(e) {
      var t = {};
      e.ReferenceStrip = function(g) {
        var x = this, C = g.viewer, E = e.getElementSize(C.element), R, D, U;
        for (g.id || (g.id = "referencestrip-" + e.now(), this.element = e.makeNeutralElement("div"), this.element.id = g.id, this.element.className = "referencestrip"), g = e.extend(!0, {
          sizeRatio: e.DEFAULT_SETTINGS.referenceStripSizeRatio,
          position: e.DEFAULT_SETTINGS.referenceStripPosition,
          scroll: e.DEFAULT_SETTINGS.referenceStripScroll,
          clickTimeThreshold: e.DEFAULT_SETTINGS.clickTimeThreshold
        }, g, {
          element: this.element
        }), e.extend(this, g), t[this.id] = {
          animating: !1
        }, this.minPixelRatio = this.viewer.minPixelRatio, this.element.tabIndex = 0, D = this.element.style, D.marginTop = "0px", D.marginRight = "0px", D.marginBottom = "0px", D.marginLeft = "0px", D.left = "0px", D.bottom = "0px", D.border = "0px", D.background = "#000", D.position = "relative", e.setElementTouchActionNone(this.element), e.setElementOpacity(this.element, 0.8), this.viewer = C, this.tracker = new e.MouseTracker({
          userData: "ReferenceStrip.tracker",
          element: this.element,
          clickHandler: e.delegate(this, i),
          dragHandler: e.delegate(this, r),
          scrollHandler: e.delegate(this, o),
          enterHandler: e.delegate(this, c),
          leaveHandler: e.delegate(this, u),
          keyDownHandler: e.delegate(this, h),
          keyHandler: e.delegate(this, f),
          preProcessEventHandler: function(Z) {
            Z.eventType === "wheel" && (Z.preventDefault = !0);
          }
        }), g.width && g.height ? (this.element.style.width = g.width + "px", this.element.style.height = g.height + "px", C.addControl(
          this.element,
          { anchor: e.ControlAnchor.BOTTOM_LEFT }
        )) : g.scroll === "horizontal" ? (this.element.style.width = E.x * g.sizeRatio * C.tileSources.length + 12 * C.tileSources.length + "px", this.element.style.height = E.y * g.sizeRatio + "px", C.addControl(
          this.element,
          { anchor: e.ControlAnchor.BOTTOM_LEFT }
        )) : (this.element.style.height = E.y * g.sizeRatio * C.tileSources.length + 12 * C.tileSources.length + "px", this.element.style.width = E.x * g.sizeRatio + "px", C.addControl(
          this.element,
          { anchor: e.ControlAnchor.TOP_LEFT }
        )), this.panelWidth = E.x * this.sizeRatio + 8, this.panelHeight = E.y * this.sizeRatio + 8, this.panels = [], this.miniViewers = {}, U = 0; U < C.tileSources.length; U++)
          R = e.makeNeutralElement("div"), R.id = this.element.id + "-" + U, R.style.width = x.panelWidth + "px", R.style.height = x.panelHeight + "px", R.style.display = "inline", R.style.float = "left", R.style.cssFloat = "left", R.style.padding = "2px", e.setElementTouchActionNone(R), e.setElementPointerEventsNone(R), this.element.appendChild(R), R.activePanel = !1, this.panels.push(R);
        a(this, this.scroll === "vertical" ? E.y : E.x, 0), this.setFocus(0);
      }, e.ReferenceStrip.prototype = {
        /**
         * @function
         */
        setFocus: function(g) {
          var x = this.element.querySelector("#" + this.element.id + "-" + g), C = e.getElementSize(this.viewer.canvas), E = Number(this.element.style.width.replace("px", "")), R = Number(this.element.style.height.replace("px", "")), D = -Number(this.element.style.marginLeft.replace("px", "")), U = -Number(this.element.style.marginTop.replace("px", "")), Z;
          this.currentSelected !== x && (this.currentSelected && (this.currentSelected.style.background = "#000"), this.currentSelected = x, this.currentSelected.style.background = "#999", this.scroll === "horizontal" ? (Z = Number(g) * (this.panelWidth + 3), Z > D + C.x - this.panelWidth ? (Z = Math.min(Z, E - C.x), this.element.style.marginLeft = -Z + "px", a(this, C.x, -Z)) : Z < D && (Z = Math.max(0, Z - C.x / 2), this.element.style.marginLeft = -Z + "px", a(this, C.x, -Z))) : (Z = Number(g) * (this.panelHeight + 3), Z > U + C.y - this.panelHeight ? (Z = Math.min(Z, R - C.y), this.element.style.marginTop = -Z + "px", a(this, C.y, -Z)) : Z < U && (Z = Math.max(0, Z - C.y / 2), this.element.style.marginTop = -Z + "px", a(this, C.y, -Z))), this.currentPage = g, c.call(this, { eventSource: this.tracker }));
        },
        /**
         * @function
         */
        update: function() {
          return !!t[this.id].animating;
        },
        destroy: function() {
          if (this.miniViewers)
            for (var g in this.miniViewers)
              this.miniViewers[g].destroy();
          this.tracker.destroy(), this.element && this.viewer.removeControl(this.element);
        }
      };
      function i(g) {
        if (g.quick) {
          var x;
          this.scroll === "horizontal" ? x = Math.floor(g.position.x / (this.panelWidth + 4)) : x = Math.floor(g.position.y / this.panelHeight), this.viewer.goToPage(x);
        }
        this.element.focus();
      }
      function r(g) {
        if (this.dragging = !0, this.element) {
          var x = Number(this.element.style.marginLeft.replace("px", "")), C = Number(this.element.style.marginTop.replace("px", "")), E = Number(this.element.style.width.replace("px", "")), R = Number(this.element.style.height.replace("px", "")), D = e.getElementSize(this.viewer.canvas);
          this.scroll === "horizontal" ? -g.delta.x > 0 ? x > -(E - D.x) && (this.element.style.marginLeft = x + g.delta.x * 2 + "px", a(this, D.x, x + g.delta.x * 2)) : -g.delta.x < 0 && x < 0 && (this.element.style.marginLeft = x + g.delta.x * 2 + "px", a(this, D.x, x + g.delta.x * 2)) : -g.delta.y > 0 ? C > -(R - D.y) && (this.element.style.marginTop = C + g.delta.y * 2 + "px", a(this, D.y, C + g.delta.y * 2)) : -g.delta.y < 0 && C < 0 && (this.element.style.marginTop = C + g.delta.y * 2 + "px", a(this, D.y, C + g.delta.y * 2));
        }
      }
      function o(g) {
        if (this.element) {
          var x = Number(this.element.style.marginLeft.replace("px", "")), C = Number(this.element.style.marginTop.replace("px", "")), E = Number(this.element.style.width.replace("px", "")), R = Number(this.element.style.height.replace("px", "")), D = e.getElementSize(this.viewer.canvas);
          this.scroll === "horizontal" ? g.scroll > 0 ? x > -(E - D.x) && (this.element.style.marginLeft = x - g.scroll * 60 + "px", a(this, D.x, x - g.scroll * 60)) : g.scroll < 0 && x < 0 && (this.element.style.marginLeft = x - g.scroll * 60 + "px", a(this, D.x, x - g.scroll * 60)) : g.scroll < 0 ? C > D.y - R && (this.element.style.marginTop = C + g.scroll * 60 + "px", a(this, D.y, C + g.scroll * 60)) : g.scroll > 0 && C < 0 && (this.element.style.marginTop = C + g.scroll * 60 + "px", a(this, D.y, C + g.scroll * 60)), g.preventDefault = !0;
        }
      }
      function a(g, x, C) {
        var E, R, D, U, Z, ce;
        for (g.scroll === "horizontal" ? E = g.panelWidth : E = g.panelHeight, R = Math.ceil(x / E) + 5, D = Math.ceil((Math.abs(C) + x) / E) + 1, R = D - R, R = R < 0 ? 0 : R, Z = R; Z < D && Z < g.panels.length; Z++)
          if (ce = g.panels[Z], !ce.activePanel) {
            var re, ue = g.viewer.tileSources[Z];
            ue.referenceStripThumbnailUrl ? re = {
              type: "image",
              url: ue.referenceStripThumbnailUrl
            } : re = ue, U = new e.Viewer({
              id: ce.id,
              tileSources: [re],
              element: ce,
              navigatorSizeRatio: g.sizeRatio,
              showNavigator: !1,
              mouseNavEnabled: !1,
              showNavigationControl: !1,
              showSequenceControl: !1,
              immediateRender: !0,
              blendTime: 0,
              animationTime: 0,
              loadTilesWithAjax: g.viewer.loadTilesWithAjax,
              ajaxHeaders: g.viewer.ajaxHeaders,
              drawer: "canvas"
              //always use canvas for the reference strip
            }), e.setElementPointerEventsNone(U.canvas), e.setElementPointerEventsNone(U.container), U.innerTracker.setTracking(!1), U.outerTracker.setTracking(!1), g.miniViewers[ce.id] = U, ce.activePanel = !0;
          }
      }
      function c(g) {
        var x = g.eventSource.element;
        this.scroll === "horizontal" ? x.style.marginBottom = "0px" : x.style.marginLeft = "0px";
      }
      function u(g) {
        var x = g.eventSource.element;
        this.scroll === "horizontal" ? x.style.marginBottom = "-" + e.getElementSize(x).y / 2 + "px" : x.style.marginLeft = "-" + e.getElementSize(x).x / 2 + "px";
      }
      function h(g) {
        if (!g.ctrl && !g.alt && !g.meta)
          switch (g.keyCode) {
            case 38:
              o.call(this, { eventSource: this.tracker, position: null, scroll: 1, shift: null }), g.preventDefault = !0;
              break;
            case 40:
              o.call(this, { eventSource: this.tracker, position: null, scroll: -1, shift: null }), g.preventDefault = !0;
              break;
            case 37:
              o.call(this, { eventSource: this.tracker, position: null, scroll: -1, shift: null }), g.preventDefault = !0;
              break;
            case 39:
              o.call(this, { eventSource: this.tracker, position: null, scroll: 1, shift: null }), g.preventDefault = !0;
              break;
            default:
              g.preventDefault = !1;
              break;
          }
        else
          g.preventDefault = !1;
      }
      function f(g) {
        if (!g.ctrl && !g.alt && !g.meta)
          switch (g.keyCode) {
            case 61:
              o.call(this, { eventSource: this.tracker, position: null, scroll: 1, shift: null }), g.preventDefault = !0;
              break;
            case 45:
              o.call(this, { eventSource: this.tracker, position: null, scroll: -1, shift: null }), g.preventDefault = !0;
              break;
            case 48:
            //0|)
            case 119:
            //w
            case 87:
              o.call(this, { eventSource: this.tracker, position: null, scroll: 1, shift: null }), g.preventDefault = !0;
              break;
            case 115:
            //s
            case 83:
              o.call(this, { eventSource: this.tracker, position: null, scroll: -1, shift: null }), g.preventDefault = !0;
              break;
            case 97:
              o.call(this, { eventSource: this.tracker, position: null, scroll: -1, shift: null }), g.preventDefault = !0;
              break;
            case 100:
              o.call(this, { eventSource: this.tracker, position: null, scroll: 1, shift: null }), g.preventDefault = !0;
              break;
            default:
              g.preventDefault = !1;
              break;
          }
        else
          g.preventDefault = !1;
      }
    })(n), (function(e) {
      e.DisplayRect = function(t, i, r, o, a, c) {
        e.Rect.apply(this, [t, i, r, o]), this.minLevel = a, this.maxLevel = c;
      }, e.extend(e.DisplayRect.prototype, e.Rect.prototype);
    })(n), (function(e) {
      e.Spring = function(i) {
        var r = arguments;
        typeof i != "object" && (i = {
          initial: r.length && typeof r[0] == "number" ? r[0] : void 0,
          /**
           * Spring stiffness.
           * @member {Number} springStiffness
           * @memberof OpenSeadragon.Spring#
           */
          springStiffness: r.length > 1 ? r[1].springStiffness : 5,
          /**
           * Animation duration per spring.
           * @member {Number} animationTime
           * @memberof OpenSeadragon.Spring#
           */
          animationTime: r.length > 1 ? r[1].animationTime : 1.5
        }), e.console.assert(
          typeof i.springStiffness == "number" && i.springStiffness !== 0,
          "[OpenSeadragon.Spring] options.springStiffness must be a non-zero number"
        ), e.console.assert(
          typeof i.animationTime == "number" && i.animationTime >= 0,
          "[OpenSeadragon.Spring] options.animationTime must be a number greater than or equal to 0"
        ), i.exponential && (this._exponential = !0, delete i.exponential), e.extend(!0, this, i), this.current = {
          value: typeof this.initial == "number" ? this.initial : this._exponential ? 0 : 1,
          time: e.now()
          // always work in milliseconds
        }, e.console.assert(
          !this._exponential || this.current.value !== 0,
          "[OpenSeadragon.Spring] value must be non-zero for exponential springs"
        ), this.start = {
          value: this.current.value,
          time: this.current.time
        }, this.target = {
          value: this.current.value,
          time: this.current.time
        }, this._exponential && (this.start._logValue = Math.log(this.start.value), this.target._logValue = Math.log(this.target.value), this.current._logValue = Math.log(this.current.value));
      }, e.Spring.prototype = {
        /**
         * @function
         * @param {Number} target
         */
        resetTo: function(i) {
          e.console.assert(
            !this._exponential || i !== 0,
            "[OpenSeadragon.Spring.resetTo] target must be non-zero for exponential springs"
          ), this.start.value = this.target.value = this.current.value = i, this.start.time = this.target.time = this.current.time = e.now(), this._exponential && (this.start._logValue = Math.log(this.start.value), this.target._logValue = Math.log(this.target.value), this.current._logValue = Math.log(this.current.value));
        },
        /**
         * @function
         * @param {Number} target
         */
        springTo: function(i) {
          e.console.assert(
            !this._exponential || i !== 0,
            "[OpenSeadragon.Spring.springTo] target must be non-zero for exponential springs"
          ), this.start.value = this.current.value, this.start.time = this.current.time, this.target.value = i, this.target.time = this.start.time + 1e3 * this.animationTime, this._exponential && (this.start._logValue = Math.log(this.start.value), this.target._logValue = Math.log(this.target.value));
        },
        /**
         * @function
         * @param {Number} delta
         */
        shiftBy: function(i) {
          this.start.value += i, this.target.value += i, this._exponential && (e.console.assert(
            this.target.value !== 0 && this.start.value !== 0,
            "[OpenSeadragon.Spring.shiftBy] spring value must be non-zero for exponential springs"
          ), this.start._logValue = Math.log(this.start.value), this.target._logValue = Math.log(this.target.value));
        },
        setExponential: function(i) {
          this._exponential = i, this._exponential && (e.console.assert(
            this.current.value !== 0 && this.target.value !== 0 && this.start.value !== 0,
            "[OpenSeadragon.Spring.setExponential] spring value must be non-zero for exponential springs"
          ), this.start._logValue = Math.log(this.start.value), this.target._logValue = Math.log(this.target.value), this.current._logValue = Math.log(this.current.value));
        },
        /**
         * @function
         * @returns true if the spring is still updating its value, false if it is
         * already at the target value.
         */
        update: function() {
          this.current.time = e.now();
          let i, r;
          if (this._exponential ? (i = this.start._logValue, r = this.target._logValue) : (i = this.start.value, r = this.target.value), this.current.time >= this.target.time)
            this.current.value = this.target.value;
          else {
            let o = i + (r - i) * t(
              this.springStiffness,
              (this.current.time - this.start.time) / (this.target.time - this.start.time)
            );
            this._exponential ? this.current.value = Math.exp(o) : this.current.value = o;
          }
          return this.current.value !== this.target.value;
        },
        /**
         * Returns whether the spring is at the target value
         * @function
         * @returns {Boolean} True if at target value, false otherwise
         */
        isAtTargetValue: function() {
          return this.current.value === this.target.value;
        }
      };
      function t(i, r) {
        return (1 - Math.exp(i * -r)) / (1 - Math.exp(-i));
      }
    })(n), (function(e) {
      e.ImageJob = function(i) {
        e.extend(!0, this, {
          timeout: e.DEFAULT_SETTINGS.timeout,
          jobId: null,
          tries: 0
        }, i), this.data = null, this.userData = {}, this.errorMsg = null;
      }, e.ImageJob.prototype = {
        /**
         * Starts the image job.
         * @method
         * @memberof OpenSeadragon.ImageJob#
         */
        start: function() {
          this.tries++;
          var i = this, r = this.abort;
          this.jobId = window.setTimeout(function() {
            i.finish(null, null, "Image load exceeded timeout (" + i.timeout + " ms)");
          }, this.timeout), this.abort = function() {
            i.source.downloadTileAbort(i), typeof r == "function" && r();
          }, this.source.downloadTileStart(this);
        },
        /**
         * Finish this job.
         * @param {*} data data that has been downloaded
         * @param {XMLHttpRequest} request reference to the request if used
         * @param {string} errorMessage description upon failure
         * @memberof OpenSeadragon.ImageJob#
         */
        finish: function(i, r, o) {
          this.data = i, this.request = r, this.errorMsg = o, this.jobId && window.clearTimeout(this.jobId), this.callback(this);
        }
      }, e.ImageLoader = function(i) {
        e.extend(!0, this, {
          jobLimit: e.DEFAULT_SETTINGS.imageLoaderLimit,
          timeout: e.DEFAULT_SETTINGS.timeout,
          jobQueue: [],
          failedTiles: [],
          jobsInProgress: 0
        }, i);
      }, e.ImageLoader.prototype = {
        /**
         * Add an unloaded image to the loader queue.
         * @method
         * @param {Object} options - Options for this job.
         * @param {String} [options.src] - URL of image to download.
         * @param {Tile} [options.tile] - Tile that belongs the data to. The tile instance
         *      is not internally used and serves for custom TileSources implementations.
         * @param {TileSource} [options.source] - Image loading strategy
         * @param {String} [options.loadWithAjax] - Whether to load this image with AJAX.
         * @param {String} [options.ajaxHeaders] - Headers to add to the image request if using AJAX.
         * @param {String|Boolean} [options.crossOriginPolicy] - CORS policy to use for downloads
         * @param {String} [options.postData] - POST parameters (usually but not necessarily in k=v&k2=v2... form,
         *      see TileSource::getPostData) or null
         * @param {Boolean} [options.ajaxWithCredentials] - Whether to set withCredentials on AJAX
         *      requests.
         * @param {Function} [options.callback] - Called once image has been downloaded.
         * @param {Function} [options.abort] - Called when this image job is aborted.
         */
        addJob: function(i) {
          if (!i.source) {
            e.console.error("ImageLoader.prototype.addJob() requires [options.source]. TileSource since new API defines how images are fetched. Creating a dummy TileSource.");
            var r = e.TileSource.prototype;
            i.source = {
              downloadTileStart: r.downloadTileStart,
              downloadTileAbort: r.downloadTileAbort
            };
          }
          var o = this, a = function(h) {
            t(o, h, i.callback);
          }, c = {
            src: i.src,
            tile: i.tile || {},
            source: i.source,
            loadWithAjax: i.loadWithAjax,
            ajaxHeaders: i.loadWithAjax ? i.ajaxHeaders : null,
            crossOriginPolicy: i.crossOriginPolicy,
            ajaxWithCredentials: i.ajaxWithCredentials,
            postData: i.postData,
            callback: a,
            abort: i.abort,
            timeout: this.timeout
          }, u = new e.ImageJob(c);
          !this.jobLimit || this.jobsInProgress < this.jobLimit ? (u.start(), this.jobsInProgress++) : this.jobQueue.push(u);
        },
        /**
         * Clear any unstarted image loading jobs from the queue.
         * @method
         */
        clear: function() {
          for (var i = 0; i < this.jobQueue.length; i++) {
            var r = this.jobQueue[i];
            typeof r.abort == "function" && r.abort();
          }
          this.jobQueue = [];
        }
      };
      function t(i, r, o) {
        r.errorMsg !== "" && (r.data === null || r.data === void 0) && r.tries < 1 + i.tileRetryMax && i.failedTiles.push(r);
        var a;
        i.jobsInProgress--, (!i.jobLimit || i.jobsInProgress < i.jobLimit) && i.jobQueue.length > 0 && (a = i.jobQueue.shift(), a.start(), i.jobsInProgress++), i.tileRetryMax > 0 && i.jobQueue.length === 0 && (!i.jobLimit || i.jobsInProgress < i.jobLimit) && i.failedTiles.length > 0 && (a = i.failedTiles.shift(), setTimeout(function() {
          a.start();
        }, i.tileRetryDelay), i.jobsInProgress++), o(r.data, r.errorMsg, r.request);
      }
    })(n), (function(e) {
      e.Tile = function(t, i, r, o, a, c, u, h, f, g, x, C) {
        this.level = t, this.x = i, this.y = r, this.bounds = o, this.positionedBounds = new n.Rect(o.x, o.y, o.width, o.height), this.sourceBounds = g, this.exists = a, this._url = c, this.postData = x, this.context2D = u, this.loadWithAjax = h, this.ajaxHeaders = f, C === void 0 && (e.console.warn("Tile constructor needs 'cacheKey' variable: creation tile cache in Tile class is deprecated. TileSource.prototype.getTileHashKey will be used."), C = e.TileSource.prototype.getTileHashKey(t, i, r, c, f, x)), this.cacheKey = C, this.loaded = !1, this.loading = !1, this.element = null, this.imgElement = null, this.style = null, this.position = null, this.size = null, this.flipped = !1, this.blendStart = null, this.opacity = null, this.squaredDistance = null, this.visibility = null, this.hasTransparency = !1, this.beingDrawn = !1, this.lastTouchTime = 0, this.isRightMost = !1, this.isBottomMost = !1;
      }, e.Tile.prototype = {
        /**
         * Provides a string representation of this tiles level and (x,y)
         * components.
         * @function
         * @returns {String}
         */
        toString: function() {
          return this.level + "/" + this.x + "_" + this.y;
        },
        // private
        _hasTransparencyChannel: function() {
          return console.warn("Tile.prototype._hasTransparencyChannel() has been deprecated and will be removed in the future. Use TileSource.prototype.hasTransparency() instead."), !!this.context2D || this.getUrl().match(".png");
        },
        /**
         * The Image object for this tile.
         * @member {Object} image
         * @memberof OpenSeadragon.Tile#
         * @deprecated
         * @returns {Image}
         */
        get image() {
          return e.console.error("[Tile.image] property has been deprecated. Use [Tile.prototype.getImage] instead."), this.getImage();
        },
        /**
         * The URL of this tile's image.
         * @member {String} url
         * @memberof OpenSeadragon.Tile#
         * @deprecated
         * @returns {String}
         */
        get url() {
          return e.console.error("[Tile.url] property has been deprecated. Use [Tile.prototype.getUrl] instead."), this.getUrl();
        },
        /**
         * Get the Image object for this tile.
         * @returns {Image}
         */
        getImage: function() {
          return this.cacheImageRecord.getImage();
        },
        /**
         * Get the url string for this tile.
         * @returns {String}
         */
        getUrl: function() {
          return typeof this._url == "function" ? this._url() : this._url;
        },
        /**
         * Get the CanvasRenderingContext2D instance for tile image data drawn
         * onto Canvas if enabled and available
         * @returns {CanvasRenderingContext2D}
         */
        getCanvasContext: function() {
          return this.context2D || this.cacheImageRecord && this.cacheImageRecord.getRenderedContext();
        },
        /**
         * Get the ratio between current and original size.
         * @function
         * @returns {Float}
         */
        getScaleForEdgeSmoothing: function() {
          var t;
          if (this.cacheImageRecord)
            t = this.cacheImageRecord.getRenderedContext();
          else if (this.context2D)
            t = this.context2D;
          else
            return e.console.warn(
              "[Tile.drawCanvas] attempting to get tile scale %s when tile's not cached",
              this.toString()
            ), 1;
          return t.canvas.width / (this.size.x * e.pixelDensityRatio);
        },
        /**
         * Get a translation vector that when applied to the tile position produces integer coordinates.
         * Needed to avoid swimming and twitching.
         * @function
         * @param {Number} [scale=1] - Scale to be applied to position.
         * @returns {OpenSeadragon.Point}
         */
        getTranslationForEdgeSmoothing: function(t, i, r) {
          var o = Math.max(1, Math.ceil((r.x - i.x) / 2)), a = Math.max(1, Math.ceil((r.y - i.y) / 2));
          return new e.Point(o, a).minus(
            this.position.times(e.pixelDensityRatio).times(t || 1).apply(function(c) {
              return c % 1;
            })
          );
        },
        /**
         * Removes tile from its container.
         * @function
         */
        unload: function() {
          this.imgElement && this.imgElement.parentNode && this.imgElement.parentNode.removeChild(this.imgElement), this.element && this.element.parentNode && this.element.parentNode.removeChild(this.element), this.element = null, this.imgElement = null, this.loaded = !1, this.loading = !1;
        }
      };
    })(n), (function(e) {
      e.OverlayPlacement = e.Placement, e.OverlayRotationMode = e.freezeObject({
        NO_ROTATION: 1,
        EXACT: 2,
        BOUNDING_BOX: 3
      }), e.Overlay = function(t, i, r) {
        var o;
        e.isPlainObject(t) ? o = t : o = {
          element: t,
          location: i,
          placement: r
        }, this.elementWrapper = document.createElement("div"), this.element = o.element, this.elementWrapper.appendChild(this.element), this.element.id ? this.elementWrapper.id = "overlay-wrapper-" + this.element.id : this.elementWrapper.id = "overlay-wrapper", this.style = this.elementWrapper.style, this._init(o);
      }, e.Overlay.prototype = {
        // private
        _init: function(t) {
          this.location = t.location, this.placement = t.placement === void 0 ? e.Placement.TOP_LEFT : t.placement, this.onDraw = t.onDraw, this.checkResize = t.checkResize === void 0 ? !0 : t.checkResize, this.width = t.width === void 0 ? null : t.width, this.height = t.height === void 0 ? null : t.height, this.rotationMode = t.rotationMode || e.OverlayRotationMode.EXACT, this.location instanceof e.Rect && (this.width = this.location.width, this.height = this.location.height, this.location = this.location.getTopLeft(), this.placement = e.Placement.TOP_LEFT), this.scales = this.width !== null && this.height !== null, this.bounds = new e.Rect(
            this.location.x,
            this.location.y,
            this.width,
            this.height
          ), this.position = this.location;
        },
        /**
         * Internal function to adjust the position of an overlay
         * depending on it size and placement.
         * @function
         * @param {OpenSeadragon.Point} position
         * @param {OpenSeadragon.Point} size
         */
        adjust: function(t, i) {
          var r = e.Placement.properties[this.placement];
          r && (r.isHorizontallyCentered ? t.x -= i.x / 2 : r.isRight && (t.x -= i.x), r.isVerticallyCentered ? t.y -= i.y / 2 : r.isBottom && (t.y -= i.y));
        },
        /**
         * @function
         */
        destroy: function() {
          var t = this.elementWrapper, i = this.style;
          t.parentNode && (t.parentNode.removeChild(t), t.prevElementParent && (i.display = "none", document.body.appendChild(t))), this.onDraw = null, i.top = "", i.left = "", i.position = "", this.width !== null && (i.width = ""), this.height !== null && (i.height = "");
          var r = e.getCssPropertyWithVendorPrefix(
            "transformOrigin"
          ), o = e.getCssPropertyWithVendorPrefix(
            "transform"
          );
          r && o && (i[r] = "", i[o] = "");
        },
        /**
         * @function
         * @param {Element} container
         */
        drawHTML: function(t, i) {
          var r = this.elementWrapper;
          r.parentNode !== t && (r.prevElementParent = r.parentNode, r.prevNextSibling = r.nextSibling, t.appendChild(r), this.style.position = "absolute", this.size = e.getElementSize(this.elementWrapper));
          var o = this._getOverlayPositionAndSize(i), a = o.position, c = this.size = o.size, u = "";
          i.overlayPreserveContentDirection && (u = i.flipped ? " scaleX(-1)" : " scaleX(1)");
          var h = i.flipped ? -o.rotate : o.rotate, f = i.flipped ? " scaleX(-1)" : "";
          if (this.onDraw)
            this.onDraw(a, c, this.element);
          else {
            var g = this.style, x = this.element.style;
            x.display = "block", g.left = a.x + "px", g.top = a.y + "px", this.width !== null && (x.width = c.x + "px"), this.height !== null && (x.height = c.y + "px");
            var C = e.getCssPropertyWithVendorPrefix(
              "transformOrigin"
            ), E = e.getCssPropertyWithVendorPrefix(
              "transform"
            );
            C && E && (h && !i.flipped ? (x[E] = "", g[C] = this._getTransformOrigin(), g[E] = "rotate(" + h + "deg)") : !h && i.flipped ? (x[E] = u, g[C] = this._getTransformOrigin(), g[E] = f) : h && i.flipped ? (x[E] = u, g[C] = this._getTransformOrigin(), g[E] = "rotate(" + h + "deg)" + f) : (x[E] = "", g[C] = "", g[E] = "")), g.display = "flex";
          }
        },
        // private
        _getOverlayPositionAndSize: function(t) {
          var i = t.pixelFromPoint(this.location, !0), r = this._getSizeInPixels(t);
          this.adjust(i, r);
          var o = 0;
          if (t.getRotation(!0) && this.rotationMode !== e.OverlayRotationMode.NO_ROTATION)
            if (this.rotationMode === e.OverlayRotationMode.BOUNDING_BOX && this.width !== null && this.height !== null) {
              var a = new e.Rect(i.x, i.y, r.x, r.y), c = this._getBoundingBox(a, t.getRotation(!0));
              i = c.getTopLeft(), r = c.getSize();
            } else
              o = t.getRotation(!0);
          return t.flipped && (i.x = t.getContainerSize().x - i.x), {
            position: i,
            size: r,
            rotate: o
          };
        },
        // private
        _getSizeInPixels: function(t) {
          var i = this.size.x, r = this.size.y;
          if (this.width !== null || this.height !== null) {
            var o = t.deltaPixelsFromPointsNoRotate(
              new e.Point(this.width || 0, this.height || 0),
              !0
            );
            this.width !== null && (i = o.x), this.height !== null && (r = o.y);
          }
          if (this.checkResize && (this.width === null || this.height === null)) {
            var a = this.size = e.getElementSize(this.elementWrapper);
            this.width === null && (i = a.x), this.height === null && (r = a.y);
          }
          return new e.Point(i, r);
        },
        // private
        _getBoundingBox: function(t, i) {
          var r = this._getPlacementPoint(t);
          return t.rotate(i, r).getBoundingBox();
        },
        // private
        _getPlacementPoint: function(t) {
          var i = new e.Point(t.x, t.y), r = e.Placement.properties[this.placement];
          return r && (r.isHorizontallyCentered ? i.x += t.width / 2 : r.isRight && (i.x += t.width), r.isVerticallyCentered ? i.y += t.height / 2 : r.isBottom && (i.y += t.height)), i;
        },
        // private
        _getTransformOrigin: function() {
          var t = "", i = e.Placement.properties[this.placement];
          return i && (i.isLeft ? t = "left" : i.isRight && (t = "right"), i.isTop ? t += " top" : i.isBottom && (t += " bottom")), t;
        },
        /**
         * Changes the overlay settings.
         * @function
         * @param {OpenSeadragon.Point|OpenSeadragon.Rect|Object} location
         * If an object is specified, the options are the same than the constructor
         * except for the element which can not be changed.
         * @param {OpenSeadragon.Placement} placement
         */
        update: function(t, i) {
          var r = e.isPlainObject(t) ? t : {
            location: t,
            placement: i
          };
          this._init({
            location: r.location || this.location,
            placement: r.placement !== void 0 ? r.placement : this.placement,
            onDraw: r.onDraw || this.onDraw,
            checkResize: r.checkResize || this.checkResize,
            width: r.width !== void 0 ? r.width : this.width,
            height: r.height !== void 0 ? r.height : this.height,
            rotationMode: r.rotationMode || this.rotationMode
          });
        },
        /**
         * Returns the current bounds of the overlay in viewport coordinates
         * @function
         * @param {OpenSeadragon.Viewport} viewport the viewport
         * @returns {OpenSeadragon.Rect} overlay bounds
         */
        getBounds: function(t) {
          e.console.assert(
            t,
            "A viewport must now be passed to Overlay.getBounds."
          );
          var i = this.width, r = this.height;
          if (i === null || r === null) {
            var o = t.deltaPointsFromPixelsNoRotate(this.size, !0);
            i === null && (i = o.x), r === null && (r = o.y);
          }
          var a = this.location.clone();
          return this.adjust(a, new e.Point(i, r)), this._adjustBoundsForRotation(
            t,
            new e.Rect(a.x, a.y, i, r)
          );
        },
        // private
        _adjustBoundsForRotation: function(t, i) {
          if (!t || t.getRotation(!0) === 0 || this.rotationMode === e.OverlayRotationMode.EXACT)
            return i;
          if (this.rotationMode === e.OverlayRotationMode.BOUNDING_BOX) {
            if (this.width === null || this.height === null)
              return i;
            var r = this._getOverlayPositionAndSize(t);
            return t.viewerElementToViewportRectangle(new e.Rect(
              r.position.x,
              r.position.y,
              r.size.x,
              r.size.y
            ));
          }
          return i.rotate(
            -t.getRotation(!0),
            this._getPlacementPoint(i)
          );
        }
      };
    })(n), (function(e) {
      const t = e;
      t.DrawerBase = class {
        constructor(r) {
          e.console.assert(r.viewer, "[Drawer] options.viewer is required"), e.console.assert(r.viewport, "[Drawer] options.viewport is required"), e.console.assert(r.element, "[Drawer] options.element is required"), this.viewer = r.viewer, this.viewport = r.viewport, this.debugGridColor = typeof r.debugGridColor == "string" ? [r.debugGridColor] : r.debugGridColor || e.DEFAULT_SETTINGS.debugGridColor, this.options = r.options || {}, this.container = e.getElement(r.element), this._renderingTarget = this._createDrawingElement(), this.canvas.style.width = "100%", this.canvas.style.height = "100%", this.canvas.style.position = "absolute", this.canvas.style.left = "0", e.setElementOpacity(this.canvas, this.viewer.opacity, !0), e.setElementPointerEventsNone(this.canvas), e.setElementTouchActionNone(this.canvas), this.container.style.textAlign = "left", this.container.appendChild(this.canvas), this._checkForAPIOverrides();
        }
        // protect the canvas member with a getter
        get canvas() {
          return this._renderingTarget;
        }
        get element() {
          return e.console.error("Drawer.element is deprecated. Use Drawer.container instead."), this.container;
        }
        /**
         * @abstract
         * @returns {String | undefined} What type of drawer this is. Must be overridden by extending classes.
         */
        getType() {
          e.console.error("Drawer.getType must be implemented by child class");
        }
        /**
         * @abstract
         * @returns {Boolean} Whether the drawer implementation is supported by the browser. Must be overridden by extending classes.
         */
        static isSupported() {
          e.console.error("Drawer.isSupported must be implemented by child class");
        }
        /**
         * @abstract
         * @returns {Element} the element to draw into
         * @private
         */
        _createDrawingElement() {
          return e.console.error("Drawer._createDrawingElement must be implemented by child class"), null;
        }
        /**
         * @abstract
         * @param {Array} tiledImages - An array of TiledImages that are ready to be drawn.
         * @private
         */
        draw(r) {
          e.console.error("Drawer.draw must be implemented by child class");
        }
        /**
         * @abstract
         * @returns {Boolean} True if rotation is supported.
         */
        canRotate() {
          e.console.error("Drawer.canRotate must be implemented by child class");
        }
        /**
         * @abstract
         */
        destroy() {
          e.console.error("Drawer.destroy must be implemented by child class");
        }
        /**
         * @param {TiledImage} tiledImage the tiled image that is calling the function
         * @returns {Boolean} Whether this drawer requires enforcing minimum tile overlap to avoid showing seams.
         * @private
         */
        minimumOverlapRequired(r) {
          return !1;
        }
        /**
         * @abstract
         * @param {Boolean} [imageSmoothingEnabled] - Whether or not the image is
         * drawn smoothly on the canvas; see imageSmoothingEnabled in
         * {@link OpenSeadragon.Options} for more explanation.
         */
        setImageSmoothingEnabled(r) {
          e.console.error("Drawer.setImageSmoothingEnabled must be implemented by child class");
        }
        /**
         * Optional public API to draw a rectangle (e.g. for debugging purposes)
         * Child classes can override this method if they wish to support this
         * @param {OpenSeadragon.Rect} rect
         */
        drawDebuggingRect(r) {
          e.console.warn("[drawer].drawDebuggingRect is not implemented by this drawer");
        }
        // Deprecated functions
        clear() {
          e.console.warn("[drawer].clear() is deprecated. The drawer is responsible for clearing itself as needed before drawing tiles.");
        }
        // Private functions
        /**
         * Ensures that child classes have provided implementations for public API methods
         * draw, canRotate, destroy, and setImageSmoothinEnabled. Throws an exception if the original
         * placeholder methods are still in place.
         * @private
         *
         */
        _checkForAPIOverrides() {
          if (this._createDrawingElement === e.DrawerBase.prototype._createDrawingElement)
            throw new Error("[drawer]._createDrawingElement must be implemented by child class");
          if (this.draw === e.DrawerBase.prototype.draw)
            throw new Error("[drawer].draw must be implemented by child class");
          if (this.canRotate === e.DrawerBase.prototype.canRotate)
            throw new Error("[drawer].canRotate must be implemented by child class");
          if (this.destroy === e.DrawerBase.prototype.destroy)
            throw new Error("[drawer].destroy must be implemented by child class");
          if (this.setImageSmoothingEnabled === e.DrawerBase.prototype.setImageSmoothingEnabled)
            throw new Error("[drawer].setImageSmoothingEnabled must be implemented by child class");
        }
        // Utility functions
        /**
         * Scale from OpenSeadragon viewer rectangle to drawer rectangle
         * (ignoring rotation)
         * @param {OpenSeadragon.Rect} rectangle - The rectangle in viewport coordinate system.
         * @returns {OpenSeadragon.Rect} Rectangle in drawer coordinate system.
         */
        viewportToDrawerRectangle(r) {
          var o = this.viewport.pixelFromPointNoRotate(r.getTopLeft(), !0), a = this.viewport.deltaPixelsFromPointsNoRotate(r.getSize(), !0);
          return new e.Rect(
            o.x * e.pixelDensityRatio,
            o.y * e.pixelDensityRatio,
            a.x * e.pixelDensityRatio,
            a.y * e.pixelDensityRatio
          );
        }
        /**
         * This function converts the given point from to the drawer coordinate by
         * multiplying it with the pixel density.
         * This function does not take rotation into account, thus assuming provided
         * point is at 0 degree.
         * @param {OpenSeadragon.Point} point - the pixel point to convert
         * @returns {OpenSeadragon.Point} Point in drawer coordinate system.
         */
        viewportCoordToDrawerCoord(r) {
          var o = this.viewport.pixelFromPointNoRotate(r, !0);
          return new e.Point(
            o.x * e.pixelDensityRatio,
            o.y * e.pixelDensityRatio
          );
        }
        // Internal utility functions
        /**
         * Calculate width and height of the canvas based on viewport dimensions
         * and pixelDensityRatio
         * @private
         * @returns {OpenSeadragon.Point} {x, y} size of the canvas
         */
        _calculateCanvasSize() {
          var r = e.pixelDensityRatio, o = this.viewport.getContainerSize();
          return new t.Point(Math.round(o.x * r), Math.round(o.y * r));
        }
        /**
         * Called by implementations to fire the tiled-image-drawn event (used by tests)
         * @private
         */
        _raiseTiledImageDrawnEvent(r, o) {
          this.viewer && this.viewer.raiseEvent("tiled-image-drawn", {
            tiledImage: r,
            tiles: o
          });
        }
        /**
         * Called by implementations to fire the drawer-error event
         * @private
         */
        _raiseDrawerErrorEvent(r, o) {
          this.viewer && this.viewer.raiseEvent("drawer-error", {
            tiledImage: r,
            drawer: this,
            error: o
          });
        }
      };
    })(n), (function(e) {
      const t = e;
      class i extends t.DrawerBase {
        constructor(o) {
          super(o), this.viewer.rejectEventHandler("tile-drawing", "The HTMLDrawer does not raise the tile-drawing event"), this.viewer.allowEventHandler("tile-drawn");
        }
        /**
         * @returns {Boolean} always true
         */
        static isSupported() {
          return !0;
        }
        /**
         *
         * @returns 'html'
         */
        getType() {
          return "html";
        }
        /**
         * @param {TiledImage} tiledImage the tiled image that is calling the function
         * @returns {Boolean} Whether this drawer requires enforcing minimum tile overlap to avoid showing seams.
         * @private
         */
        minimumOverlapRequired(o) {
          return !0;
        }
        /**
         * create the HTML element (e.g. canvas, div) that the image will be drawn into
         * @returns {Element} the div to draw into
         */
        _createDrawingElement() {
          return e.makeNeutralElement("div");
        }
        /**
         * Draws the TiledImages
         */
        draw(o) {
          var a = this;
          this._prepareNewFrame(), o.forEach(function(c) {
            c.opacity !== 0 && a._drawTiles(c);
          });
        }
        /**
         * @returns {Boolean} False - rotation is not supported.
         */
        canRotate() {
          return !1;
        }
        /**
         * Destroy the drawer (unload current loaded tiles)
         */
        destroy() {
          this.container.removeChild(this.canvas);
        }
        /**
         * This function is ignored by the HTML Drawer. Implementing it is required by DrawerBase.
         * @param {Boolean} [imageSmoothingEnabled] - Whether or not the image is
         * drawn smoothly on the canvas; see imageSmoothingEnabled in
         * {@link OpenSeadragon.Options} for more explanation.
         */
        setImageSmoothingEnabled() {
        }
        /**
         * Clears the Drawer so it's ready to draw another frame.
         * @private
         *
         */
        _prepareNewFrame() {
          this.canvas.innerHTML = "";
        }
        /**
         * Draws a TiledImage.
         * @private
         *
         */
        _drawTiles(o) {
          var a = o.getTilesToDraw().map((h) => h.tile);
          if (!(o.opacity === 0 || a.length === 0 && !o.placeholderFillStyle))
            for (var c = a.length - 1; c >= 0; c--) {
              var u = a[c];
              this._drawTile(u), this.viewer && this.viewer.raiseEvent("tile-drawn", {
                tiledImage: o,
                tile: u
              });
            }
        }
        /**
         * Draws the given tile.
         * @private
         * @param {OpenSeadragon.Tile} tile - The tile to draw.
         * @param {Function} drawingHandler - Method for firing the drawing event if using canvas.
         * drawingHandler({context, tile, rendered})
         */
        _drawTile(o) {
          e.console.assert(o, "[Drawer._drawTile] tile is required");
          let a = this.canvas;
          if (!o.cacheImageRecord) {
            e.console.warn(
              "[Drawer._drawTileToHTML] attempting to draw tile %s when it's not cached",
              o.toString()
            );
            return;
          }
          if (!o.loaded) {
            e.console.warn(
              "Attempting to draw tile %s when it's not yet loaded.",
              o.toString()
            );
            return;
          }
          if (!o.element) {
            var c = o.getImage();
            if (!c)
              return;
            o.element = e.makeNeutralElement("div"), o.imgElement = c.cloneNode(), o.imgElement.style.msInterpolationMode = "nearest-neighbor", o.imgElement.style.width = "100%", o.imgElement.style.height = "100%", o.style = o.element.style, o.style.position = "absolute";
          }
          o.element.parentNode !== a && a.appendChild(o.element), o.imgElement.parentNode !== o.element && o.element.appendChild(o.imgElement), o.style.top = o.position.y + "px", o.style.left = o.position.x + "px", o.style.height = o.size.y + "px", o.style.width = o.size.x + "px", o.flipped && (o.style.transform = "scaleX(-1)"), e.setElementOpacity(o.element, o.opacity);
        }
      }
      e.HTMLDrawer = i;
    })(n), (function(e) {
      const t = e;
      class i extends t.DrawerBase {
        constructor(h) {
          super(h), this.context = this.canvas.getContext("2d"), this.sketchCanvas = null, this.sketchContext = null, this._imageSmoothingEnabled = !0, this.viewer.allowEventHandler("tile-drawn"), this.viewer.allowEventHandler("tile-drawing");
        }
        /**
         * @returns {Boolean} true if canvas is supported by the browser, otherwise false
         */
        static isSupported() {
          return e.supportsCanvas;
        }
        getType() {
          return "canvas";
        }
        /**
         * create the HTML element (e.g. canvas, div) that the image will be drawn into
         * @returns {Element} the canvas to draw into
         */
        _createDrawingElement() {
          let h = e.makeNeutralElement("canvas"), f = this._calculateCanvasSize();
          return h.width = f.x, h.height = f.y, h;
        }
        /**
         * Draws the TiledImages
         */
        draw(h) {
          this._prepareNewFrame(), this.viewer.viewport.getFlip() !== this._viewportFlipped && this._flip();
          for (const f of h)
            f.opacity !== 0 && this._drawTiles(f);
        }
        /**
         * @returns {Boolean} True - rotation is supported.
         */
        canRotate() {
          return !0;
        }
        /**
         * Destroy the drawer (unload current loaded tiles)
         */
        destroy() {
          this.canvas.width = 1, this.canvas.height = 1, this.sketchCanvas = null, this.sketchContext = null, this.container.removeChild(this.canvas);
        }
        /**
         * @param {TiledImage} tiledImage the tiled image that is calling the function
         * @returns {Boolean} Whether this drawer requires enforcing minimum tile overlap to avoid showing seams.
         * @private
         */
        minimumOverlapRequired(h) {
          return !0;
        }
        /**
         * Turns image smoothing on or off for this viewer. Note: Ignored in some (especially older) browsers that do not support this property.
         *
         * @function
         * @param {Boolean} [imageSmoothingEnabled] - Whether or not the image is
         * drawn smoothly on the canvas; see imageSmoothingEnabled in
         * {@link OpenSeadragon.Options} for more explanation.
         */
        setImageSmoothingEnabled(h) {
          this._imageSmoothingEnabled = !!h, this._updateImageSmoothingEnabled(this.context), this.viewer.forceRedraw();
        }
        /**
         * Draw a rectangle onto the canvas
         * @param {OpenSeadragon.Rect} rect
         */
        drawDebuggingRect(h) {
          var f = this.context;
          f.save(), f.lineWidth = 2 * e.pixelDensityRatio, f.strokeStyle = this.debugGridColor[0], f.fillStyle = this.debugGridColor[0], f.strokeRect(
            h.x * e.pixelDensityRatio,
            h.y * e.pixelDensityRatio,
            h.width * e.pixelDensityRatio,
            h.height * e.pixelDensityRatio
          ), f.restore();
        }
        /**
         * Test whether the current context is flipped or not
         * @private
         */
        get _viewportFlipped() {
          return this.context.getTransform().a < 0;
        }
        /**
         * Fires the tile-drawing event.
         * @private
         */
        _raiseTileDrawingEvent(h, f, g, x) {
          this.viewer.raiseEvent("tile-drawing", {
            tiledImage: h,
            context: f,
            tile: g,
            rendered: x
          });
        }
        /**
         * Clears the Drawer so it's ready to draw another frame.
         * @private
         *
         */
        _prepareNewFrame() {
          var h = this._calculateCanvasSize();
          if ((this.canvas.width !== h.x || this.canvas.height !== h.y) && (this.canvas.width = h.x, this.canvas.height = h.y, this._updateImageSmoothingEnabled(this.context), this.sketchCanvas !== null)) {
            var f = this._calculateSketchCanvasSize();
            this.sketchCanvas.width = f.x, this.sketchCanvas.height = f.y, this._updateImageSmoothingEnabled(this.sketchContext);
          }
          this._clear();
        }
        /**
         * @private
         * @param {Boolean} useSketch Whether to clear sketch canvas or main canvas
         * @param {OpenSeadragon.Rect} [bounds] The rectangle to clear
         */
        _clear(h, f) {
          var g = this._getContext(h);
          if (f)
            g.clearRect(f.x, f.y, f.width, f.height);
          else {
            var x = g.canvas;
            g.clearRect(0, 0, x.width, x.height);
          }
        }
        /**
         * Draws a TiledImage.
         * @private
         *
         */
        _drawTiles(h) {
          var f = h.getTilesToDraw().map((_e) => _e.tile);
          if (!(h.opacity === 0 || f.length === 0 && !h.placeholderFillStyle)) {
            var g = f[0], x;
            g && (x = h.opacity < 1 || h.compositeOperation && h.compositeOperation !== "source-over" || !h._isBottomItem() && h.source.hasTransparency(g.context2D, g.getUrl(), g.ajaxHeaders, g.postData));
            var C, E, R = this.viewport.getZoom(!0), D = h.viewportToImageZoom(R);
            f.length > 1 && D > h.smoothTileEdgesMinZoom && !h.iOSDevice && h.getRotation(!0) % 360 === 0 && (x = !0, C = g.getScaleForEdgeSmoothing(), E = g.getTranslationForEdgeSmoothing(
              C,
              this._getCanvasSize(!1),
              this._getCanvasSize(!0)
            ));
            var U;
            x && (C || (U = this.viewport.viewportToViewerElementRectangle(
              h.getClippedBounds(!0)
            ).getIntegerBoundingBox(), U = U.times(e.pixelDensityRatio)), this._clear(!0, U)), C || this._setRotations(h, x);
            var Z = !1;
            if (h._clip) {
              this._saveContext(x);
              var ce = h.imageToViewportRectangle(h._clip, !0);
              ce = ce.rotate(-h.getRotation(!0), h._getRotationPoint(!0));
              var re = this.viewportToDrawerRectangle(ce);
              C && (re = re.times(C)), E && (re = re.translate(E)), this._setClip(re, x), Z = !0;
            }
            if (h._croppingPolygons) {
              var ue = this;
              Z || this._saveContext(x);
              try {
                var me = h._croppingPolygons.map(function(_e) {
                  return _e.map(function(Ae) {
                    var Je = h.imageToViewportCoordinates(Ae.x, Ae.y, !0).rotate(-h.getRotation(!0), h._getRotationPoint(!0)), Ge = ue.viewportCoordToDrawerCoord(Je);
                    return C && (Ge = Ge.times(C)), E && (Ge = Ge.plus(E)), Ge;
                  });
                });
                this._clipWithPolygons(me, x);
              } catch (_e) {
                e.console.error(_e);
              }
              Z = !0;
            }
            if (h._hasOpaqueTile = !1, h.placeholderFillStyle && h._hasOpaqueTile === !1) {
              let _e = this.viewportToDrawerRectangle(h.getBoundsNoRotate(!0));
              C && (_e = _e.times(C)), E && (_e = _e.translate(E));
              let Ae = null;
              typeof h.placeholderFillStyle == "function" ? Ae = h.placeholderFillStyle(h, this.context) : Ae = h.placeholderFillStyle, this._drawRectangle(_e, Ae, x);
            }
            var Te = c(h.subPixelRoundingForTransparency), Re = !1;
            if (Te === e.SUBPIXEL_ROUNDING_OCCURRENCES.ALWAYS)
              Re = !0;
            else if (Te === e.SUBPIXEL_ROUNDING_OCCURRENCES.ONLY_AT_REST) {
              var He = this.viewer && this.viewer.isAnimating();
              Re = !He;
            }
            for (var Fe = 0; Fe < f.length; Fe++)
              g = f[Fe], this._drawTile(
                g,
                h,
                x,
                C,
                E,
                Re,
                h.source
              ), this.viewer && this.viewer.raiseEvent("tile-drawn", {
                tiledImage: h,
                tile: g
              });
            Z && this._restoreContext(x), C || (h.getRotation(!0) % 360 !== 0 && this._restoreRotationChanges(x), this.viewport.getRotation(!0) % 360 !== 0 && this._restoreRotationChanges(x)), x && (C && this._setRotations(h), this.blendSketch({
              opacity: h.opacity,
              scale: C,
              translate: E,
              compositeOperation: h.compositeOperation,
              bounds: U
            }), C && (h.getRotation(!0) % 360 !== 0 && this._restoreRotationChanges(!1), this.viewport.getRotation(!0) % 360 !== 0 && this._restoreRotationChanges(!1))), this._drawDebugInfo(h, f), this._raiseTiledImageDrawnEvent(h, f);
          }
        }
        /**
         * Draws special debug information for a TiledImage if in debug mode.
         * @private
         * @param {OpenSeadragon.Tile[]} lastDrawn - An unordered list of Tiles drawn last frame.
         */
        _drawDebugInfo(h, f) {
          if (h.debugMode)
            for (var g = f.length - 1; g >= 0; g--) {
              var x = f[g];
              try {
                this._drawDebugInfoOnTile(x, f.length, g, h);
              } catch (C) {
                e.console.error(C);
              }
            }
        }
        /**
         * This function will create multiple polygon paths on the drawing context by provided polygons,
         * then clip the context to the paths.
         * @private
         * @param {OpenSeadragon.Point[][]} polygons - an array of polygons. A polygon is an array of OpenSeadragon.Point
         * @param {Boolean} useSketch - Whether to use the sketch canvas or not.
         */
        _clipWithPolygons(h, f) {
          var g = this._getContext(f);
          g.beginPath();
          for (const x of h)
            for (const [C, E] of x.entries())
              g[C === 0 ? "moveTo" : "lineTo"](E.x, E.y);
          g.clip();
        }
        /**
         * Draws the given tile.
         * @private
         * @param {OpenSeadragon.Tile} tile - The tile to draw.
         * @param {OpenSeadragon.TiledImage} tiledImage - The tiled image being drawn.
         * @param {Boolean} useSketch - Whether to use the sketch canvas or not.
         * where <code>rendered</code> is the context with the pre-drawn image.
         * @param {Float} [scale=1] - Apply a scale to tile position and size. Defaults to 1.
         * @param {OpenSeadragon.Point} [translate] A translation vector to offset tile position
         * @param {Boolean} [shouldRoundPositionAndSize] - Tells whether to round
         * position and size of tiles supporting alpha channel in non-transparency
         * context.
         * @param {OpenSeadragon.TileSource} source - The source specification of the tile.
         */
        _drawTile(h, f, g, x, C, E, R) {
          e.console.assert(h, "[Drawer._drawTile] tile is required"), e.console.assert(f, "[Drawer._drawTile] drawingHandler is required");
          var D = this._getContext(g);
          x = x || 1, this._drawTileToCanvas(h, D, f, x, C, E, R);
        }
        /**
         * Renders the tile in a canvas-based context.
         * @private
         * @function
         * @param {OpenSeadragon.Tile} tile - the tile to draw to the canvas
         * @param {Canvas} context
         * @param {OpenSeadragon.TiledImage} tiledImage - Method for firing the drawing event.
         * drawingHandler({context, tile, rendered})
         * where <code>rendered</code> is the context with the pre-drawn image.
         * @param {Number} [scale=1] - Apply a scale to position and size
         * @param {OpenSeadragon.Point} [translate] - A translation vector
         * @param {Boolean} [shouldRoundPositionAndSize] - Tells whether to round
         * position and size of tiles supporting alpha channel in non-transparency
         * context.
         * @param {OpenSeadragon.TileSource} source - The source specification of the tile.
         */
        _drawTileToCanvas(h, f, g, x, C, E, R) {
          var D = h.position.times(e.pixelDensityRatio), U = h.size.times(e.pixelDensityRatio), Z;
          if (!h.context2D && !h.cacheImageRecord) {
            e.console.warn(
              "[Drawer._drawTileToCanvas] attempting to draw tile %s when it's not cached",
              h.toString()
            );
            return;
          }
          if (Z = h.getCanvasContext(), !h.loaded || !Z) {
            e.console.warn(
              "Attempting to draw tile %s when it's not yet loaded.",
              h.toString()
            );
            return;
          }
          f.save(), typeof x == "number" && x !== 1 && (D = D.times(x), U = U.times(x)), C instanceof e.Point && (D = D.plus(C)), f.globalAlpha === 1 && h.hasTransparency && (E && (D.x = Math.round(D.x), D.y = Math.round(D.y), U.x = Math.round(U.x), U.y = Math.round(U.y)), f.clearRect(
            D.x,
            D.y,
            U.x,
            U.y
          )), this._raiseTileDrawingEvent(g, f, h, Z);
          var ce, re;
          h.sourceBounds ? (ce = Math.min(h.sourceBounds.width, Z.canvas.width), re = Math.min(h.sourceBounds.height, Z.canvas.height)) : (ce = Z.canvas.width, re = Z.canvas.height), f.translate(D.x + U.x / 2, 0), h.flipped && f.scale(-1, 1), f.drawImage(
            Z.canvas,
            0,
            0,
            ce,
            re,
            -U.x / 2,
            D.y,
            U.x,
            U.y
          ), f.restore();
        }
        /**
         * Get the context of the main or sketch canvas
         * @private
         * @param {Boolean} useSketch
         * @returns {CanvasRenderingContext2D}
         */
        _getContext(h) {
          var f = this.context;
          if (h) {
            if (this.sketchCanvas === null) {
              this.sketchCanvas = document.createElement("canvas");
              var g = this._calculateSketchCanvasSize();
              if (this.sketchCanvas.width = g.x, this.sketchCanvas.height = g.y, this.sketchContext = this.sketchCanvas.getContext("2d"), this.viewport.getRotation() === 0) {
                var x = this;
                this.viewer.addHandler("rotate", function C() {
                  if (x.viewport.getRotation() !== 0) {
                    x.viewer.removeHandler("rotate", C);
                    var E = x._calculateSketchCanvasSize();
                    x.sketchCanvas.width = E.x, x.sketchCanvas.height = E.y;
                  }
                });
              }
              this._updateImageSmoothingEnabled(this.sketchContext);
            }
            f = this.sketchContext;
          }
          return f;
        }
        /**
         * Save the context of the main or sketch canvas
         * @private
         * @param {Boolean} useSketch
         */
        _saveContext(h) {
          this._getContext(h).save();
        }
        /**
         * Restore the context of the main or sketch canvas
         * @private
         * @param {Boolean} useSketch
         */
        _restoreContext(h) {
          this._getContext(h).restore();
        }
        // private
        _setClip(h, f) {
          var g = this._getContext(f);
          g.beginPath(), g.rect(h.x, h.y, h.width, h.height), g.clip();
        }
        // private
        // used to draw a placeholder rectangle
        _drawRectangle(h, f, g) {
          var x = this._getContext(g);
          x.save(), x.fillStyle = f, x.fillRect(h.x, h.y, h.width, h.height), x.restore();
        }
        /**
         * Blends the sketch canvas in the main canvas.
         * @param {Object} options The options
         * @param {Float} options.opacity The opacity of the blending.
         * @param {Float} [options.scale=1] The scale at which tiles were drawn on
         * the sketch. Default is 1.
         * Use scale to draw at a lower scale and then enlarge onto the main canvas.
         * @param {OpenSeadragon.Point} [options.translate] A translation vector
         * that was used to draw the tiles
         * @param {String} [options.compositeOperation] - How the image is
         * composited onto other images; see compositeOperation in
         * {@link OpenSeadragon.Options} for possible values.
         * @param {OpenSeadragon.Rect} [options.bounds] The part of the sketch
         * canvas to blend in the main canvas. If specified, options.scale and
         * options.translate get ignored.
         */
        blendSketch(h, f, g, x) {
          var C = h;
          e.isPlainObject(C) || (C = {
            opacity: h,
            scale: f,
            translate: g,
            compositeOperation: x
          }), h = C.opacity, x = C.compositeOperation;
          var E = C.bounds;
          if (this.context.save(), this.context.globalAlpha = h, x && (this.context.globalCompositeOperation = x), E)
            E.x < 0 && (E.width += E.x, E.x = 0), E.x + E.width > this.canvas.width && (E.width = this.canvas.width - E.x), E.y < 0 && (E.height += E.y, E.y = 0), E.y + E.height > this.canvas.height && (E.height = this.canvas.height - E.y), this.context.drawImage(
              this.sketchCanvas,
              E.x,
              E.y,
              E.width,
              E.height,
              E.x,
              E.y,
              E.width,
              E.height
            );
          else {
            f = C.scale || 1, g = C.translate;
            var R = g instanceof e.Point ? g : new e.Point(0, 0), D = 0, U = 0;
            if (g) {
              var Z = this.sketchCanvas.width - this.canvas.width, ce = this.sketchCanvas.height - this.canvas.height;
              D = Math.round(Z / 2), U = Math.round(ce / 2);
            }
            this.context.drawImage(
              this.sketchCanvas,
              R.x - D * f,
              R.y - U * f,
              (this.canvas.width + 2 * D) * f,
              (this.canvas.height + 2 * U) * f,
              -D,
              -U,
              this.canvas.width + 2 * D,
              this.canvas.height + 2 * U
            );
          }
          this.context.restore();
        }
        // private
        _drawDebugInfoOnTile(h, f, g, x) {
          var C = this.viewer.world.getIndexOfItem(x) % this.debugGridColor.length, E = this.context;
          E.save(), E.lineWidth = 2 * e.pixelDensityRatio, E.font = "small-caps bold " + 13 * e.pixelDensityRatio + "px arial", E.strokeStyle = this.debugGridColor[C], E.fillStyle = this.debugGridColor[C], this._setRotations(x), this._viewportFlipped && this._flip({ point: h.position.plus(h.size.divide(2)) }), E.strokeRect(
            h.position.x * e.pixelDensityRatio,
            h.position.y * e.pixelDensityRatio,
            h.size.x * e.pixelDensityRatio,
            h.size.y * e.pixelDensityRatio
          );
          var R = (h.position.x + h.size.x / 2) * e.pixelDensityRatio, D = (h.position.y + h.size.y / 2) * e.pixelDensityRatio;
          E.translate(R, D);
          const U = this.viewport.getRotation(!0);
          E.rotate(Math.PI / 180 * -U), E.translate(-R, -D), h.x === 0 && h.y === 0 && (E.fillText(
            "Zoom: " + this.viewport.getZoom(),
            h.position.x * e.pixelDensityRatio,
            (h.position.y - 30) * e.pixelDensityRatio
          ), E.fillText(
            "Pan: " + this.viewport.getBounds().toString(),
            h.position.x * e.pixelDensityRatio,
            (h.position.y - 20) * e.pixelDensityRatio
          )), E.fillText(
            "Level: " + h.level,
            (h.position.x + 10) * e.pixelDensityRatio,
            (h.position.y + 20) * e.pixelDensityRatio
          ), E.fillText(
            "Column: " + h.x,
            (h.position.x + 10) * e.pixelDensityRatio,
            (h.position.y + 30) * e.pixelDensityRatio
          ), E.fillText(
            "Row: " + h.y,
            (h.position.x + 10) * e.pixelDensityRatio,
            (h.position.y + 40) * e.pixelDensityRatio
          ), E.fillText(
            "Order: " + g + " of " + f,
            (h.position.x + 10) * e.pixelDensityRatio,
            (h.position.y + 50) * e.pixelDensityRatio
          ), E.fillText(
            "Size: " + h.size.toString(),
            (h.position.x + 10) * e.pixelDensityRatio,
            (h.position.y + 60) * e.pixelDensityRatio
          ), E.fillText(
            "Position: " + h.position.toString(),
            (h.position.x + 10) * e.pixelDensityRatio,
            (h.position.y + 70) * e.pixelDensityRatio
          ), this.viewport.getRotation(!0) % 360 !== 0 && this._restoreRotationChanges(), x.getRotation(!0) % 360 !== 0 && this._restoreRotationChanges(), E.restore();
        }
        // private
        _updateImageSmoothingEnabled(h) {
          h.msImageSmoothingEnabled = this._imageSmoothingEnabled, h.imageSmoothingEnabled = this._imageSmoothingEnabled;
        }
        /**
         * Get the canvas size
         * @private
         * @param {Boolean} sketch If set to true return the size of the sketch canvas
         * @returns {OpenSeadragon.Point} The size of the canvas
         */
        _getCanvasSize(h) {
          var f = this._getContext(h).canvas;
          return new e.Point(f.width, f.height);
        }
        /**
         * Get the canvas center
         * @private
         * @param {Boolean} sketch If set to true return the center point of the sketch canvas
         * @returns {OpenSeadragon.Point} The center point of the canvas
         */
        _getCanvasCenter() {
          return new e.Point(this.canvas.width / 2, this.canvas.height / 2);
        }
        /**
         * Set rotations for viewport & tiledImage
         * @private
         * @param {OpenSeadragon.TiledImage} tiledImage
         * @param {Boolean} [useSketch=false]
         */
        _setRotations(h, f = !1) {
          var g = !1;
          this.viewport.getRotation(!0) % 360 !== 0 && (this._offsetForRotation({
            degrees: this.viewport.getRotation(!0),
            useSketch: f,
            saveContext: g
          }), g = !1), h.getRotation(!0) % 360 !== 0 && this._offsetForRotation({
            degrees: h.getRotation(!0),
            point: this.viewport.pixelFromPointNoRotate(
              h._getRotationPoint(!0),
              !0
            ),
            useSketch: f,
            saveContext: g
          });
        }
        // private
        _offsetForRotation(h) {
          var f = h.point ? h.point.times(e.pixelDensityRatio) : this._getCanvasCenter(), g = this._getContext(h.useSketch);
          g.save(), g.translate(f.x, f.y), g.rotate(Math.PI / 180 * h.degrees), g.translate(-f.x, -f.y);
        }
        // private
        _flip(h) {
          h = h || {};
          var f = h.point ? h.point.times(e.pixelDensityRatio) : this._getCanvasCenter(), g = this._getContext(h.useSketch);
          g.translate(f.x, 0), g.scale(-1, 1), g.translate(-f.x, 0);
        }
        // private
        _restoreRotationChanges(h) {
          var f = this._getContext(h);
          f.restore();
        }
        // private
        _calculateCanvasSize() {
          var h = e.pixelDensityRatio, f = this.viewport.getContainerSize();
          return {
            // canvas width and height are integers
            x: Math.round(f.x * h),
            y: Math.round(f.y * h)
          };
        }
        // private
        _calculateSketchCanvasSize() {
          var h = this._calculateCanvasSize();
          if (this.viewport.getRotation() === 0)
            return h;
          var f = Math.ceil(Math.sqrt(
            h.x * h.x + h.y * h.y
          ));
          return {
            x: f,
            y: f
          };
        }
      }
      e.CanvasDrawer = i;
      var r = e.SUBPIXEL_ROUNDING_OCCURRENCES.NEVER;
      function o(u) {
        return u !== e.SUBPIXEL_ROUNDING_OCCURRENCES.ALWAYS && u !== e.SUBPIXEL_ROUNDING_OCCURRENCES.ONLY_AT_REST && u !== e.SUBPIXEL_ROUNDING_OCCURRENCES.NEVER;
      }
      function a(u) {
        return o(u) ? r : u;
      }
      function c(u) {
        if (typeof u == "number")
          return a(u);
        if (!u || !e.Browser)
          return r;
        var h = u[e.Browser.vendor];
        return o(h) && (h = u["*"]), a(h);
      }
    })(n), (function(e) {
      const t = e;
      t.WebGLDrawer = class extends t.DrawerBase {
        constructor(r) {
          super(r), this._destroyed = !1, this._TextureMap = /* @__PURE__ */ new Map(), this._TileMap = /* @__PURE__ */ new Map(), this._gl = null, this._firstPass = null, this._secondPass = null, this._glFrameBuffer = null, this._renderToTexture = null, this._glFramebufferToCanvasTransform = null, this._outputCanvas = null, this._outputContext = null, this._clippingCanvas = null, this._clippingContext = null, this._renderingCanvas = null, this._backupCanvasDrawer = null, this._imageSmoothingEnabled = !0, this._boundToTileReady = (o) => this._tileReadyHandler(o), this._boundToImageUnloaded = (o) => this._imageUnloadedHandler(o), this.viewer.addHandler("tile-ready", this._boundToTileReady), this.viewer.addHandler("image-unloaded", this._boundToImageUnloaded), this.viewer.rejectEventHandler("tile-drawn", "The WebGLDrawer does not raise the tile-drawn event"), this.viewer.rejectEventHandler("tile-drawing", "The WebGLDrawer does not raise the tile-drawing event"), this._setupCanvases(), this._setupRenderer(), this.context = this._outputContext;
        }
        // Public API required by all Drawer implementations
        /**
        * Clean up the renderer, removing all resources
        */
        destroy() {
          if (this._destroyed)
            return;
          let r = this._gl;
          var o = r.getParameter(r.MAX_TEXTURE_IMAGE_UNITS);
          for (let c = 0; c < o; ++c)
            r.activeTexture(r.TEXTURE0 + c), r.bindTexture(r.TEXTURE_2D, null), r.bindTexture(r.TEXTURE_CUBE_MAP, null);
          r.bindBuffer(r.ARRAY_BUFFER, null), r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, null), r.bindRenderbuffer(r.RENDERBUFFER, null), r.bindFramebuffer(r.FRAMEBUFFER, null), this._unloadTextures(), r.deleteBuffer(this._secondPass.bufferOutputPosition), r.deleteFramebuffer(this._glFrameBuffer), this._renderingCanvas.width = this._renderingCanvas.height = 1, this._clippingCanvas.width = this._clippingCanvas.height = 1, this._outputCanvas.width = this._outputCanvas.height = 1, this._renderingCanvas = null, this._clippingCanvas = this._clippingContext = null, this._outputCanvas = this._outputContext = null;
          let a = r.getExtension("WEBGL_lose_context");
          a && a.loseContext(), this.viewer.removeHandler("tile-ready", this._boundToTileReady), this.viewer.removeHandler("image-unloaded", this._boundToImageUnloaded), this.viewer.removeHandler("resize", this._resizeHandler), this._gl = null, this._backupCanvasDrawer && (this._backupCanvasDrawer.destroy(), this._backupCanvasDrawer = null), this.container.removeChild(this.canvas), this.viewer.drawer === this && (this.viewer.drawer = null), this._destroyed = !0;
        }
        // Public API required by all Drawer implementations
        /**
        *
        * @returns {Boolean} true
        */
        canRotate() {
          return !0;
        }
        // Public API required by all Drawer implementations
        /**
        * @returns {Boolean} true if canvas and webgl are supported
        */
        static isSupported() {
          let r = document.createElement("canvas"), o = e.isFunction(r.getContext) && r.getContext("webgl"), a = o && o.getExtension("WEBGL_lose_context");
          return a && a.loseContext(), !!o;
        }
        /**
         *
         * @returns 'webgl'
         */
        getType() {
          return "webgl";
        }
        /**
         * @param {TiledImage} tiledImage the tiled image that is calling the function
         * @returns {Boolean} Whether this drawer requires enforcing minimum tile overlap to avoid showing seams.
         * @private
         */
        minimumOverlapRequired(r) {
          return r.isTainted();
        }
        /**
        * create the HTML element (canvas in this case) that the image will be drawn into
        * @private
        * @returns {Element} the canvas to draw into
        */
        _createDrawingElement() {
          let r = e.makeNeutralElement("canvas"), o = this._calculateCanvasSize();
          return r.width = o.x, r.height = o.y, r;
        }
        /**
         * Get the backup renderer (CanvasDrawer) to use if data cannot be used by webgl
         * Lazy loaded
         * @private
         * @returns {CanvasDrawer}
         */
        _getBackupCanvasDrawer() {
          return this._backupCanvasDrawer || (this._backupCanvasDrawer = this.viewer.requestDrawer("canvas", { mainDrawer: !1 }), this._backupCanvasDrawer.canvas.style.setProperty("visibility", "hidden")), this._backupCanvasDrawer;
        }
        /**
        *
        * @param {Array} tiledImages Array of TiledImage objects to draw
        */
        draw(r) {
          let o = this._gl;
          const a = this.viewport.getBoundsNoRotateWithMargins(!0);
          let c = {
            bounds: a,
            center: new t.Point(a.x + a.width / 2, a.y + a.height / 2),
            rotation: this.viewport.getRotation(!0) * Math.PI / 180
          }, u = this.viewport.flipped ? -1 : 1, h = e.Mat3.makeTranslation(-c.center.x, -c.center.y), f = e.Mat3.makeScaling(2 / c.bounds.width * u, -2 / c.bounds.height), g = e.Mat3.makeRotation(-c.rotation), x = f.multiply(g).multiply(h);
          o.bindFramebuffer(o.FRAMEBUFFER, null), o.clear(o.COLOR_BUFFER_BIT), this._outputContext.clearRect(0, 0, this._outputCanvas.width, this._outputCanvas.height);
          let C = !1;
          r.forEach((E, R) => {
            if (E.isTainted()) {
              C && (this._outputContext.drawImage(this._renderingCanvas, 0, 0), o.bindFramebuffer(o.FRAMEBUFFER, null), o.clear(o.COLOR_BUFFER_BIT), C = !1);
              const D = this._getBackupCanvasDrawer();
              D.draw([E]), this._outputContext.drawImage(D.canvas, 0, 0);
            } else {
              let D = E.getTilesToDraw();
              if (E.placeholderFillStyle && E._hasOpaqueTile === !1 && this._drawPlaceholder(E), D.length === 0 || E.getOpacity() === 0)
                return;
              let U = D[0], Z = E.compositeOperation || this.viewer.compositeOperation || E._clip || E._croppingPolygons || E.debugMode, ce = Z || E.opacity < 1 || U.hasTransparency;
              Z && (C && this._outputContext.drawImage(this._renderingCanvas, 0, 0), o.bindFramebuffer(o.FRAMEBUFFER, null), o.clear(o.COLOR_BUFFER_BIT)), o.useProgram(this._firstPass.shaderProgram), ce ? (o.bindFramebuffer(o.FRAMEBUFFER, this._glFrameBuffer), o.clear(o.COLOR_BUFFER_BIT)) : o.bindFramebuffer(o.FRAMEBUFFER, null);
              let re = x, ue = E.getRotation(!0);
              if (ue % 360 !== 0) {
                let _e = e.Mat3.makeRotation(-ue * Math.PI / 180), Ae = E.getBoundsNoRotate(!0).getCenter(), Je = e.Mat3.makeTranslation(Ae.x, Ae.y), Ge = e.Mat3.makeTranslation(-Ae.x, -Ae.y), qe = Je.multiply(_e).multiply(Ge);
                re = x.multiply(qe);
              }
              let me = this._gl.getParameter(this._gl.MAX_TEXTURE_IMAGE_UNITS);
              if (me <= 0)
                throw new Error(`WegGL error: bad value for gl parameter MAX_TEXTURE_IMAGE_UNITS (${me}). This could happen
                        if too many contexts have been created and not released, or there is another problem with the graphics card.`);
              let Te = new Float32Array(me * 12), Re = new Array(me), He = new Array(me), Fe = new Array(me);
              for (let _e = 0; _e < D.length; _e++) {
                let Ae = D[_e].tile, Je = _e % me, Ge = Je + 1, qe = Ae.getCanvasContext(), nt = qe ? this._TextureMap.get(qe.canvas) : null;
                if (nt || (this._tileReadyHandler({ tile: Ae, tiledImage: E }), nt = qe ? this._TextureMap.get(qe.canvas) : null), nt && this._getTileData(Ae, E, nt, re, Je, Te, Re, He, Fe), Ge === me || _e === D.length - 1) {
                  for (let Ve = 0; Ve <= Ge; Ve++)
                    o.activeTexture(o.TEXTURE0 + Ve), o.bindTexture(o.TEXTURE_2D, Re[Ve]);
                  o.bindBuffer(o.ARRAY_BUFFER, this._firstPass.bufferTexturePosition), o.bufferData(o.ARRAY_BUFFER, Te, o.DYNAMIC_DRAW), He.forEach((Ve, ot) => {
                    o.uniformMatrix3fv(this._firstPass.uTransformMatrices[ot], !1, Ve);
                  }), o.uniform1fv(this._firstPass.uOpacities, new Float32Array(Fe)), o.bindBuffer(o.ARRAY_BUFFER, this._firstPass.bufferOutputPosition), o.vertexAttribPointer(this._firstPass.aOutputPosition, 2, o.FLOAT, !1, 0, 0), o.bindBuffer(o.ARRAY_BUFFER, this._firstPass.bufferTexturePosition), o.vertexAttribPointer(this._firstPass.aTexturePosition, 2, o.FLOAT, !1, 0, 0), o.bindBuffer(o.ARRAY_BUFFER, this._firstPass.bufferIndex), o.vertexAttribPointer(this._firstPass.aIndex, 1, o.FLOAT, !1, 0, 0), o.drawArrays(o.TRIANGLES, 0, 6 * Ge);
                }
              }
              ce && (o.useProgram(this._secondPass.shaderProgram), o.bindFramebuffer(o.FRAMEBUFFER, null), o.activeTexture(o.TEXTURE0), o.bindTexture(o.TEXTURE_2D, this._renderToTexture), this._gl.uniform1f(this._secondPass.uOpacityMultiplier, E.opacity), o.bindBuffer(o.ARRAY_BUFFER, this._secondPass.bufferTexturePosition), o.vertexAttribPointer(this._secondPass.aTexturePosition, 2, o.FLOAT, !1, 0, 0), o.bindBuffer(o.ARRAY_BUFFER, this._secondPass.bufferOutputPosition), o.vertexAttribPointer(this._secondPass.aOutputPosition, 2, o.FLOAT, !1, 0, 0), o.drawArrays(o.TRIANGLES, 0, 6)), C = !0, Z && (this._applyContext2dPipeline(E, D, R), C = !1, o.bindFramebuffer(o.FRAMEBUFFER, null), o.clear(o.COLOR_BUFFER_BIT)), R === 0 && this._raiseTiledImageDrawnEvent(E, D.map((_e) => _e.tile));
            }
          }), C && this._outputContext.drawImage(this._renderingCanvas, 0, 0);
        }
        // Public API required by all Drawer implementations
        /**
        * Sets whether image smoothing is enabled or disabled
        * @param {Boolean} enabled If true, uses gl.LINEAR as the TEXTURE_MIN_FILTER and TEXTURE_MAX_FILTER, otherwise gl.NEAREST.
        */
        setImageSmoothingEnabled(r) {
          this._imageSmoothingEnabled !== r && (this._imageSmoothingEnabled = r, this._unloadTextures(), this.viewer.world.draw());
        }
        /**
        * Draw a rect onto the output canvas for debugging purposes
        * @param {OpenSeadragon.Rect} rect
        */
        drawDebuggingRect(r) {
          let o = this._outputContext;
          o.save(), o.lineWidth = 2 * e.pixelDensityRatio, o.strokeStyle = this.debugGridColor[0], o.fillStyle = this.debugGridColor[0], o.strokeRect(
            r.x * e.pixelDensityRatio,
            r.y * e.pixelDensityRatio,
            r.width * e.pixelDensityRatio,
            r.height * e.pixelDensityRatio
          ), o.restore();
        }
        // private
        _getTextureDataFromTile(r) {
          return r.getCanvasContext().canvas;
        }
        /**
        * Draw data from the rendering canvas onto the output canvas, with clipping,
        * cropping and/or debug info as requested.
        * @private
        * @param {OpenSeadragon.TiledImage} tiledImage - the tiledImage to draw
        * @param {Array} tilesToDraw - array of objects containing tiles that were drawn
        */
        _applyContext2dPipeline(r, o, a) {
          if (this._outputContext.save(), this._outputContext.globalCompositeOperation = a === 0 ? null : r.compositeOperation || this.viewer.compositeOperation, r._croppingPolygons || r._clip ? (this._renderToClippingCanvas(r), this._outputContext.drawImage(this._clippingCanvas, 0, 0)) : this._outputContext.drawImage(this._renderingCanvas, 0, 0), this._outputContext.restore(), r.debugMode) {
            const c = this.viewer.viewport.getFlip();
            c && this._flip(), this._drawDebugInfo(o, r, c), c && this._flip();
          }
        }
        // private
        _getTileData(r, o, a, c, u, h, f, g, x) {
          let C = a.texture, E = a.position;
          h.set(E, u * 12);
          let R = this._calculateOverlapFraction(r, o), D = r.positionedBounds.width * R.x, U = r.positionedBounds.height * R.y, Z = r.positionedBounds.x + (r.x === 0 ? 0 : D), ce = r.positionedBounds.y + (r.y === 0 ? 0 : U), re = r.positionedBounds.x + r.positionedBounds.width - (r.isRightMost ? 0 : D), ue = r.positionedBounds.y + r.positionedBounds.height - (r.isBottomMost ? 0 : U), me = re - Z, Te = ue - ce, Re = new e.Mat3([
            me,
            0,
            0,
            0,
            Te,
            0,
            Z,
            ce,
            1
          ]);
          if (r.flipped) {
            let Fe = e.Mat3.makeTranslation(0.5, 0), _e = e.Mat3.makeTranslation(-0.5, 0), Ae = Fe.multiply(e.Mat3.makeScaling(-1, 1)).multiply(_e);
            Re = Re.multiply(Ae);
          }
          let He = c.multiply(Re);
          x[u] = r.opacity, f[u] = C, g[u] = He.values;
        }
        // private
        _textureFilter() {
          return this._imageSmoothingEnabled ? this._gl.LINEAR : this._gl.NEAREST;
        }
        // private
        _setupRenderer() {
          let r = this._gl;
          r || e.console.error("_setupCanvases must be called before _setupRenderer"), this._unitQuad = this._makeQuadVertexBuffer(0, 1, 0, 1), this._makeFirstPassShaderProgram(), this._makeSecondPassShaderProgram(), this._renderToTexture = r.createTexture(), r.activeTexture(r.TEXTURE0), r.bindTexture(r.TEXTURE_2D, this._renderToTexture), r.texImage2D(r.TEXTURE_2D, 0, r.RGBA, this._renderingCanvas.width, this._renderingCanvas.height, 0, r.RGBA, r.UNSIGNED_BYTE, null), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MIN_FILTER, this._textureFilter()), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_S, r.CLAMP_TO_EDGE), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_T, r.CLAMP_TO_EDGE), this._glFrameBuffer = r.createFramebuffer(), r.bindFramebuffer(r.FRAMEBUFFER, this._glFrameBuffer), r.framebufferTexture2D(
            r.FRAMEBUFFER,
            r.COLOR_ATTACHMENT0,
            // attach texture as COLOR_ATTACHMENT0
            r.TEXTURE_2D,
            // attach a 2D texture
            this._renderToTexture,
            // the texture to attach
            0
          ), r.enable(r.BLEND), r.blendFunc(r.ONE, r.ONE_MINUS_SRC_ALPHA);
        }
        //private
        _makeFirstPassShaderProgram() {
          let r = this._glNumTextures = this._gl.getParameter(this._gl.MAX_TEXTURE_IMAGE_UNITS), o = () => [...Array(r).keys()].map((C) => `uniform mat3 u_matrix_${C};`).join(`
`), a = () => [...Array(r).keys()].map((C) => `${C > 0 ? "else " : ""}if(int(a_index) == ${C}) { transform_matrix = u_matrix_${C}; }`).join(`
`);
          const c = `
            attribute vec2 a_output_position;
            attribute vec2 a_texture_position;
            attribute float a_index;

            ${o()} // create a uniform mat3 for each potential tile to draw

            varying vec2 v_texture_position;
            varying float v_image_index;

            void main() {

                mat3 transform_matrix; // value will be set by the if/elses in makeConditional()

                ${a()}

                gl_Position = vec4(transform_matrix * vec3(a_output_position, 1), 1);

                v_texture_position = a_texture_position;
                v_image_index = a_index;
            }
            `, u = `
            precision mediump float;

            // our textures
            uniform sampler2D u_images[${r}];
            // our opacities
            uniform float u_opacities[${r}];

            // the varyings passed in from the vertex shader.
            varying vec2 v_texture_position;
            varying float v_image_index;

            void main() {
                // can't index directly with a variable, need to use a loop iterator hack
                for(int i = 0; i < ${r}; ++i){
                    if(i == int(v_image_index)){
                        gl_FragColor = texture2D(u_images[i], v_texture_position) * u_opacities[i];
                    }
                }
            }
            `;
          let h = this._gl, f = this.constructor.initShaderProgram(h, c, u);
          h.useProgram(f), this._firstPass = {
            shaderProgram: f,
            aOutputPosition: h.getAttribLocation(f, "a_output_position"),
            aTexturePosition: h.getAttribLocation(f, "a_texture_position"),
            aIndex: h.getAttribLocation(f, "a_index"),
            uTransformMatrices: [...Array(this._glNumTextures).keys()].map((C) => h.getUniformLocation(f, `u_matrix_${C}`)),
            uImages: h.getUniformLocation(f, "u_images"),
            uOpacities: h.getUniformLocation(f, "u_opacities"),
            bufferOutputPosition: h.createBuffer(),
            bufferTexturePosition: h.createBuffer(),
            bufferIndex: h.createBuffer()
          }, h.uniform1iv(this._firstPass.uImages, [...Array(r).keys()]);
          let g = new Float32Array(r * 12);
          for (let C = 0; C < r; ++C)
            g.set(Float32Array.from(this._unitQuad), C * 12);
          h.bindBuffer(h.ARRAY_BUFFER, this._firstPass.bufferOutputPosition), h.bufferData(h.ARRAY_BUFFER, g, h.STATIC_DRAW), h.enableVertexAttribArray(this._firstPass.aOutputPosition), h.bindBuffer(h.ARRAY_BUFFER, this._firstPass.bufferTexturePosition), h.enableVertexAttribArray(this._firstPass.aTexturePosition), h.bindBuffer(h.ARRAY_BUFFER, this._firstPass.bufferIndex);
          let x = [...Array(this._glNumTextures).keys()].map((C) => Array(6).fill(C)).flat();
          h.bufferData(h.ARRAY_BUFFER, new Float32Array(x), h.STATIC_DRAW), h.enableVertexAttribArray(this._firstPass.aIndex);
        }
        // private
        _makeSecondPassShaderProgram() {
          const r = `
            attribute vec2 a_output_position;
            attribute vec2 a_texture_position;

            uniform mat3 u_matrix;

            varying vec2 v_texture_position;

            void main() {
                gl_Position = vec4(u_matrix * vec3(a_output_position, 1), 1);

                v_texture_position = a_texture_position;
            }
            `, o = `
            precision mediump float;

            // our texture
            uniform sampler2D u_image;

            // the texCoords passed in from the vertex shader.
            varying vec2 v_texture_position;

            // the opacity multiplier for the image
            uniform float u_opacity_multiplier;

            void main() {
                gl_FragColor = texture2D(u_image, v_texture_position);
                gl_FragColor *= u_opacity_multiplier;
            }
            `;
          let a = this._gl, c = this.constructor.initShaderProgram(a, r, o);
          a.useProgram(c), this._secondPass = {
            shaderProgram: c,
            aOutputPosition: a.getAttribLocation(c, "a_output_position"),
            aTexturePosition: a.getAttribLocation(c, "a_texture_position"),
            uMatrix: a.getUniformLocation(c, "u_matrix"),
            uImage: a.getUniformLocation(c, "u_image"),
            uOpacityMultiplier: a.getUniformLocation(c, "u_opacity_multiplier"),
            bufferOutputPosition: a.createBuffer(),
            bufferTexturePosition: a.createBuffer()
          }, a.bindBuffer(a.ARRAY_BUFFER, this._secondPass.bufferOutputPosition), a.bufferData(a.ARRAY_BUFFER, this._unitQuad, a.STATIC_DRAW), a.enableVertexAttribArray(this._secondPass.aOutputPosition), a.bindBuffer(a.ARRAY_BUFFER, this._secondPass.bufferTexturePosition), a.bufferData(a.ARRAY_BUFFER, this._unitQuad, a.DYNAMIC_DRAW), a.enableVertexAttribArray(this._secondPass.aTexturePosition);
          let u = e.Mat3.makeScaling(2, 2).multiply(e.Mat3.makeTranslation(-0.5, -0.5));
          a.uniformMatrix3fv(this._secondPass.uMatrix, !1, u.values);
        }
        // private
        _resizeRenderer() {
          let r = this._gl, o = this._renderingCanvas.width, a = this._renderingCanvas.height;
          r.viewport(0, 0, o, a), r.deleteTexture(this._renderToTexture), this._renderToTexture = r.createTexture(), r.activeTexture(r.TEXTURE0), r.bindTexture(r.TEXTURE_2D, this._renderToTexture), r.texImage2D(r.TEXTURE_2D, 0, r.RGBA, o, a, 0, r.RGBA, r.UNSIGNED_BYTE, null), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MIN_FILTER, this._textureFilter()), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_S, r.CLAMP_TO_EDGE), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_T, r.CLAMP_TO_EDGE), r.bindFramebuffer(r.FRAMEBUFFER, this._glFrameBuffer), r.framebufferTexture2D(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, this._renderToTexture, 0);
        }
        // private
        _setupCanvases() {
          let r = this;
          this._outputCanvas = this.canvas, this._outputContext = this._outputCanvas.getContext("2d"), this._renderingCanvas = document.createElement("canvas"), this._clippingCanvas = document.createElement("canvas"), this._clippingContext = this._clippingCanvas.getContext("2d"), this._renderingCanvas.width = this._clippingCanvas.width = this._outputCanvas.width, this._renderingCanvas.height = this._clippingCanvas.height = this._outputCanvas.height, this._gl = this._renderingCanvas.getContext("webgl"), this._resizeHandler = function() {
            r._outputCanvas !== r.viewer.drawer.canvas && (r._outputCanvas.style.width = r.viewer.drawer.canvas.clientWidth + "px", r._outputCanvas.style.height = r.viewer.drawer.canvas.clientHeight + "px");
            let o = r._calculateCanvasSize();
            (r._outputCanvas.width !== o.x || r._outputCanvas.height !== o.y) && (r._outputCanvas.width = o.x, r._outputCanvas.height = o.y), r._renderingCanvas.style.width = r._outputCanvas.clientWidth + "px", r._renderingCanvas.style.height = r._outputCanvas.clientHeight + "px", r._renderingCanvas.width = r._clippingCanvas.width = r._outputCanvas.width, r._renderingCanvas.height = r._clippingCanvas.height = r._outputCanvas.height, r._resizeRenderer();
          }, this.viewer.addHandler("resize", this._resizeHandler);
        }
        // private
        _makeQuadVertexBuffer(r, o, a, c) {
          return new Float32Array([
            r,
            c,
            o,
            c,
            r,
            a,
            r,
            a,
            o,
            c,
            o,
            a
          ]);
        }
        // private
        _tileReadyHandler(r) {
          let o = r.tile, a = r.tiledImage;
          if (a.isTainted())
            return;
          let c = o.getCanvasContext(), u = c && c.canvas;
          if (!u || e.isCanvasTainted(u)) {
            a.isTainted() || (a.setTainted(!0), e.console.warn("WebGL cannot be used to draw this TiledImage because it has tainted data. Does crossOriginPolicy need to be set?"), this._raiseDrawerErrorEvent(a, "Tainted data cannot be used by the WebGLDrawer. Falling back to CanvasDrawer for this TiledImage."));
            return;
          }
          if (!this._TextureMap.get(u)) {
            let f = this._gl, g = f.createTexture(), x, C = a.source.tileOverlap, E, R;
            if (o.sourceBounds ? (E = Math.min(o.sourceBounds.width, u.width) / u.width, R = Math.min(o.sourceBounds.height, u.height) / u.height) : (E = 1, R = 1), C > 0) {
              let U = this._calculateOverlapFraction(o, a), Z = (o.x === 0 ? 0 : U.x) * E, ce = (o.y === 0 ? 0 : U.y) * R, re = (o.isRightMost ? 1 : 1 - U.x) * E, ue = (o.isBottomMost ? 1 : 1 - U.y) * R;
              x = this._makeQuadVertexBuffer(Z, re, ce, ue);
            } else E === 1 && R === 1 ? x = this._unitQuad : x = this._makeQuadVertexBuffer(0, E, 0, R);
            let D = {
              texture: g,
              position: x
            };
            this._TextureMap.set(u, D), f.activeTexture(f.TEXTURE0), f.bindTexture(f.TEXTURE_2D, g), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_S, f.CLAMP_TO_EDGE), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_T, f.CLAMP_TO_EDGE), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MIN_FILTER, this._textureFilter()), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MAG_FILTER, this._textureFilter()), this._uploadImageData(c);
          }
        }
        // private
        _calculateOverlapFraction(r, o) {
          let a = o.source.tileOverlap, c = r.sourceBounds.width, u = r.sourceBounds.height, h = (r.x === 0 ? 0 : a) + (r.isRightMost ? 0 : a), f = (r.y === 0 ? 0 : a) + (r.isBottomMost ? 0 : a), g = a / (c + h), x = a / (u + f);
          return {
            x: g,
            y: x
          };
        }
        // private
        _unloadTextures() {
          Array.from(this._TextureMap.keys()).forEach((o) => {
            this._cleanupImageData(o);
          });
        }
        // private
        _uploadImageData(r) {
          let o = this._gl, a = r.canvas;
          try {
            if (!a)
              throw r;
            o.texImage2D(o.TEXTURE_2D, 0, o.RGBA, o.RGBA, o.UNSIGNED_BYTE, a);
          } catch (c) {
            e.console.error("Error uploading image data to WebGL", c);
          }
        }
        // private
        _imageUnloadedHandler(r) {
          let o = r.context2D.canvas;
          this._cleanupImageData(o);
        }
        // private
        _cleanupImageData(r) {
          let o = this._TextureMap.get(r);
          this._TextureMap.delete(r), o && this._gl.deleteTexture(o.texture);
        }
        // private
        _setClip() {
        }
        // private
        _renderToClippingCanvas(r) {
          if (this._clippingContext.clearRect(0, 0, this._clippingCanvas.width, this._clippingCanvas.height), this._clippingContext.save(), this.viewer.viewport.getFlip()) {
            const o = new e.Point(this.canvas.width / 2, this.canvas.height / 2);
            this._clippingContext.translate(o.x, 0), this._clippingContext.scale(-1, 1), this._clippingContext.translate(-o.x, 0);
          }
          if (r._clip) {
            let a = [
              { x: r._clip.x, y: r._clip.y },
              { x: r._clip.x + r._clip.width, y: r._clip.y },
              { x: r._clip.x + r._clip.width, y: r._clip.y + r._clip.height },
              { x: r._clip.x, y: r._clip.y + r._clip.height }
            ].map((c) => {
              let u = r.imageToViewportCoordinates(c.x, c.y, !0).rotate(this.viewer.viewport.getRotation(!0), this.viewer.viewport.getCenter(!0));
              return this.viewportCoordToDrawerCoord(u);
            });
            this._clippingContext.beginPath(), a.forEach((c, u) => {
              this._clippingContext[u === 0 ? "moveTo" : "lineTo"](c.x, c.y);
            }), this._clippingContext.clip(), this._setClip();
          }
          if (r._croppingPolygons) {
            let o = r._croppingPolygons.map((a) => a.map((c) => {
              let u = r.imageToViewportCoordinates(c.x, c.y, !0).rotate(this.viewer.viewport.getRotation(!0), this.viewer.viewport.getCenter(!0));
              return this.viewportCoordToDrawerCoord(u);
            }));
            this._clippingContext.beginPath(), o.forEach((a) => {
              a.forEach((c, u) => {
                this._clippingContext[u === 0 ? "moveTo" : "lineTo"](c.x, c.y);
              });
            }), this._clippingContext.clip();
          }
          if (this.viewer.viewport.getFlip()) {
            const o = new e.Point(this.canvas.width / 2, this.canvas.height / 2);
            this._clippingContext.translate(o.x, 0), this._clippingContext.scale(-1, 1), this._clippingContext.translate(-o.x, 0);
          }
          this._clippingContext.drawImage(this._renderingCanvas, 0, 0), this._clippingContext.restore();
        }
        /**
         * Set rotations for viewport & tiledImage
         * @private
         * @param {OpenSeadragon.TiledImage} tiledImage
         */
        _setRotations(r) {
          var o = !1;
          this.viewport.getRotation(!0) % 360 !== 0 && (this._offsetForRotation({
            degrees: this.viewport.getRotation(!0),
            saveContext: o
          }), o = !1), r.getRotation(!0) % 360 !== 0 && this._offsetForRotation({
            degrees: r.getRotation(!0),
            point: this.viewport.pixelFromPointNoRotate(
              r._getRotationPoint(!0),
              !0
            ),
            saveContext: o
          });
        }
        // private
        _offsetForRotation(r) {
          var o = r.point ? r.point.times(e.pixelDensityRatio) : this._getCanvasCenter(), a = this._outputContext;
          a.save(), a.translate(o.x, o.y), a.rotate(Math.PI / 180 * r.degrees), a.translate(-o.x, -o.y);
        }
        // private
        _flip(r) {
          r = r || {};
          var o = r.point ? r.point.times(e.pixelDensityRatio) : this._getCanvasCenter(), a = this._outputContext;
          a.translate(o.x, 0), a.scale(-1, 1), a.translate(-o.x, 0);
        }
        // private
        _drawDebugInfo(r, o, a) {
          for (var c = r.length - 1; c >= 0; c--) {
            var u = r[c].tile;
            try {
              this._drawDebugInfoOnTile(u, r.length, c, o, a);
            } catch (h) {
              e.console.error(h);
            }
          }
        }
        // private
        _drawDebugInfoOnTile(r, o, a, c, u) {
          var h = this.viewer.world.getIndexOfItem(c) % this.debugGridColor.length, f = this.context;
          f.save(), f.lineWidth = 2 * e.pixelDensityRatio, f.font = "small-caps bold " + 13 * e.pixelDensityRatio + "px arial", f.strokeStyle = this.debugGridColor[h], f.fillStyle = this.debugGridColor[h], this._setRotations(c), u && this._flip({ point: r.position.plus(r.size.divide(2)) }), f.strokeRect(
            r.position.x * e.pixelDensityRatio,
            r.position.y * e.pixelDensityRatio,
            r.size.x * e.pixelDensityRatio,
            r.size.y * e.pixelDensityRatio
          );
          var g = (r.position.x + r.size.x / 2) * e.pixelDensityRatio, x = (r.position.y + r.size.y / 2) * e.pixelDensityRatio;
          f.translate(g, x);
          const C = this.viewport.getRotation(!0);
          f.rotate(Math.PI / 180 * -C), f.translate(-g, -x), r.x === 0 && r.y === 0 && (f.fillText(
            "Zoom: " + this.viewport.getZoom(),
            r.position.x * e.pixelDensityRatio,
            (r.position.y - 30) * e.pixelDensityRatio
          ), f.fillText(
            "Pan: " + this.viewport.getBounds().toString(),
            r.position.x * e.pixelDensityRatio,
            (r.position.y - 20) * e.pixelDensityRatio
          )), f.fillText(
            "Level: " + r.level,
            (r.position.x + 10) * e.pixelDensityRatio,
            (r.position.y + 20) * e.pixelDensityRatio
          ), f.fillText(
            "Column: " + r.x,
            (r.position.x + 10) * e.pixelDensityRatio,
            (r.position.y + 30) * e.pixelDensityRatio
          ), f.fillText(
            "Row: " + r.y,
            (r.position.x + 10) * e.pixelDensityRatio,
            (r.position.y + 40) * e.pixelDensityRatio
          ), f.fillText(
            "Order: " + a + " of " + o,
            (r.position.x + 10) * e.pixelDensityRatio,
            (r.position.y + 50) * e.pixelDensityRatio
          ), f.fillText(
            "Size: " + r.size.toString(),
            (r.position.x + 10) * e.pixelDensityRatio,
            (r.position.y + 60) * e.pixelDensityRatio
          ), f.fillText(
            "Position: " + r.position.toString(),
            (r.position.x + 10) * e.pixelDensityRatio,
            (r.position.y + 70) * e.pixelDensityRatio
          ), this.viewport.getRotation(!0) % 360 !== 0 && this._restoreRotationChanges(), c.getRotation(!0) % 360 !== 0 && this._restoreRotationChanges(), f.restore();
        }
        _drawPlaceholder(r) {
          const o = r.getBounds(!0), a = this.viewportToDrawerRectangle(r.getBounds(!0)), c = this._outputContext;
          let u;
          typeof r.placeholderFillStyle == "function" ? u = r.placeholderFillStyle(r, c) : u = r.placeholderFillStyle, this._offsetForRotation({ degrees: this.viewer.viewport.getRotation(!0) }), c.fillStyle = u, c.translate(a.x, a.y), c.rotate(Math.PI / 180 * o.degrees), c.translate(-a.x, -a.y), c.fillRect(a.x, a.y, a.width, a.height), this._restoreRotationChanges();
        }
        /**
         * Get the canvas center
         * @private
         * @returns {OpenSeadragon.Point} The center point of the canvas
         */
        _getCanvasCenter() {
          return new e.Point(this.canvas.width / 2, this.canvas.height / 2);
        }
        // private
        _restoreRotationChanges() {
          var r = this._outputContext;
          r.restore();
        }
        // modified from https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Tutorial/Adding_2D_content_to_a_WebGL_context
        static initShaderProgram(r, o, a) {
          function c(g, x, C) {
            const E = g.createShader(x);
            return g.shaderSource(E, C), g.compileShader(E), g.getShaderParameter(E, g.COMPILE_STATUS) ? E : (e.console.error(
              `An error occurred compiling the shaders: ${g.getShaderInfoLog(E)}`
            ), g.deleteShader(E), null);
          }
          const u = c(r, r.VERTEX_SHADER, o), h = c(r, r.FRAGMENT_SHADER, a), f = r.createProgram();
          return r.attachShader(f, u), r.attachShader(f, h), r.linkProgram(f), r.getProgramParameter(f, r.LINK_STATUS) ? f : (e.console.error(
            `Unable to initialize the shader program: ${r.getProgramInfoLog(
              f
            )}`
          ), null);
        }
      };
    })(n), (function(e) {
      e.Viewport = function(t) {
        var i = arguments;
        i.length && i[0] instanceof e.Point && (t = {
          containerSize: i[0],
          contentSize: i[1],
          config: i[2]
        }), t.config && (e.extend(!0, t, t.config), delete t.config), this._margins = e.extend({
          left: 0,
          top: 0,
          right: 0,
          bottom: 0
        }, t.margins || {}), delete t.margins, t.initialDegrees = t.degrees, delete t.degrees, e.extend(!0, this, {
          //required settings
          containerSize: null,
          contentSize: null,
          //internal state properties
          zoomPoint: null,
          rotationPivot: null,
          viewer: null,
          //configurable options
          springStiffness: e.DEFAULT_SETTINGS.springStiffness,
          animationTime: e.DEFAULT_SETTINGS.animationTime,
          minZoomImageRatio: e.DEFAULT_SETTINGS.minZoomImageRatio,
          maxZoomPixelRatio: e.DEFAULT_SETTINGS.maxZoomPixelRatio,
          visibilityRatio: e.DEFAULT_SETTINGS.visibilityRatio,
          wrapHorizontal: e.DEFAULT_SETTINGS.wrapHorizontal,
          wrapVertical: e.DEFAULT_SETTINGS.wrapVertical,
          defaultZoomLevel: e.DEFAULT_SETTINGS.defaultZoomLevel,
          minZoomLevel: e.DEFAULT_SETTINGS.minZoomLevel,
          maxZoomLevel: e.DEFAULT_SETTINGS.maxZoomLevel,
          initialDegrees: e.DEFAULT_SETTINGS.degrees,
          flipped: e.DEFAULT_SETTINGS.flipped,
          homeFillsViewer: e.DEFAULT_SETTINGS.homeFillsViewer,
          silenceMultiImageWarnings: e.DEFAULT_SETTINGS.silenceMultiImageWarnings
        }, t), this._updateContainerInnerSize(), this.centerSpringX = new e.Spring({
          initial: 0,
          springStiffness: this.springStiffness,
          animationTime: this.animationTime
        }), this.centerSpringY = new e.Spring({
          initial: 0,
          springStiffness: this.springStiffness,
          animationTime: this.animationTime
        }), this.zoomSpring = new e.Spring({
          exponential: !0,
          initial: 1,
          springStiffness: this.springStiffness,
          animationTime: this.animationTime
        }), this.degreesSpring = new e.Spring({
          initial: t.initialDegrees,
          springStiffness: this.springStiffness,
          animationTime: this.animationTime
        }), this._oldCenterX = this.centerSpringX.current.value, this._oldCenterY = this.centerSpringY.current.value, this._oldZoom = this.zoomSpring.current.value, this._oldDegrees = this.degreesSpring.current.value, this._setContentBounds(new e.Rect(0, 0, 1, 1), 1), this.goHome(!0), this.update();
      }, e.Viewport.prototype = {
        // deprecated
        get degrees() {
          return e.console.warn("Accessing [Viewport.degrees] is deprecated. Use viewport.getRotation instead."), this.getRotation();
        },
        // deprecated
        set degrees(t) {
          e.console.warn("Setting [Viewport.degrees] is deprecated. Use viewport.rotateTo, viewport.rotateBy, or viewport.setRotation instead."), this.rotateTo(t);
        },
        /**
         * Updates the viewport's home bounds and constraints for the given content size.
         * @function
         * @param {OpenSeadragon.Point} contentSize - size of the content in content units
         * @returns {OpenSeadragon.Viewport} Chainable.
         * @fires OpenSeadragon.Viewer.event:reset-size
         */
        resetContentSize: function(t) {
          return e.console.assert(t, "[Viewport.resetContentSize] contentSize is required"), e.console.assert(t instanceof e.Point, "[Viewport.resetContentSize] contentSize must be an OpenSeadragon.Point"), e.console.assert(t.x > 0, "[Viewport.resetContentSize] contentSize.x must be greater than 0"), e.console.assert(t.y > 0, "[Viewport.resetContentSize] contentSize.y must be greater than 0"), this._setContentBounds(new e.Rect(0, 0, 1, t.y / t.x), t.x), this;
        },
        // deprecated
        setHomeBounds: function(t, i) {
          e.console.error("[Viewport.setHomeBounds] this function is deprecated; The content bounds should not be set manually."), this._setContentBounds(t, i);
        },
        // Set the viewport's content bounds
        // @param {OpenSeadragon.Rect} bounds - the new bounds in viewport coordinates
        // without rotation
        // @param {Number} contentFactor - how many content units per viewport unit
        // @fires OpenSeadragon.Viewer.event:reset-size
        // @private
        _setContentBounds: function(t, i) {
          e.console.assert(t, "[Viewport._setContentBounds] bounds is required"), e.console.assert(t instanceof e.Rect, "[Viewport._setContentBounds] bounds must be an OpenSeadragon.Rect"), e.console.assert(t.width > 0, "[Viewport._setContentBounds] bounds.width must be greater than 0"), e.console.assert(t.height > 0, "[Viewport._setContentBounds] bounds.height must be greater than 0"), this._contentBoundsNoRotate = t.clone(), this._contentSizeNoRotate = this._contentBoundsNoRotate.getSize().times(
            i
          ), this._contentBounds = t.rotate(this.getRotation()).getBoundingBox(), this._contentSize = this._contentBounds.getSize().times(i), this._contentAspectRatio = this._contentSize.x / this._contentSize.y, this.viewer && this.viewer.raiseEvent("reset-size", {
            contentSize: this._contentSizeNoRotate.clone(),
            contentFactor: i,
            homeBounds: this._contentBoundsNoRotate.clone(),
            contentBounds: this._contentBounds.clone()
          });
        },
        /**
         * Returns the home zoom in "viewport zoom" value.
         * @function
         * @returns {Number} The home zoom in "viewport zoom".
         */
        getHomeZoom: function() {
          if (this.defaultZoomLevel)
            return this.defaultZoomLevel;
          var t = this._contentAspectRatio / this.getAspectRatio(), i;
          return this.homeFillsViewer ? i = t >= 1 ? t : 1 : i = t >= 1 ? 1 : t, i / this._contentBounds.width;
        },
        /**
         * Returns the home bounds in viewport coordinates.
         * @function
         * @returns {OpenSeadragon.Rect} The home bounds in vewport coordinates.
         */
        getHomeBounds: function() {
          return this.getHomeBoundsNoRotate().rotate(-this.getRotation());
        },
        /**
         * Returns the home bounds in viewport coordinates.
         * This method ignores the viewport rotation. Use
         * {@link OpenSeadragon.Viewport#getHomeBounds} to take it into account.
         * @function
         * @returns {OpenSeadragon.Rect} The home bounds in vewport coordinates.
         */
        getHomeBoundsNoRotate: function() {
          var t = this._contentBounds.getCenter(), i = 1 / this.getHomeZoom(), r = i / this.getAspectRatio();
          return new e.Rect(
            t.x - i / 2,
            t.y - r / 2,
            i,
            r
          );
        },
        /**
         * @function
         * @param {Boolean} immediately
         * @fires OpenSeadragon.Viewer.event:home
         */
        goHome: function(t) {
          return this.viewer && this.viewer.raiseEvent("home", {
            immediately: t
          }), this.fitBounds(this.getHomeBounds(), t);
        },
        /**
         * @function
         */
        getMinZoom: function() {
          var t = this.getHomeZoom(), i = this.minZoomLevel ? this.minZoomLevel : this.minZoomImageRatio * t;
          return i;
        },
        /**
         * @function
         */
        getMaxZoom: function() {
          var t = this.maxZoomLevel;
          return t || (t = this._contentSize.x * this.maxZoomPixelRatio / this._containerInnerSize.x, t /= this._contentBounds.width), Math.max(t, this.getHomeZoom());
        },
        /**
         * @function
         */
        getAspectRatio: function() {
          return this._containerInnerSize.x / this._containerInnerSize.y;
        },
        /**
         * @function
         * @returns {OpenSeadragon.Point} The size of the container, in screen coordinates.
         */
        getContainerSize: function() {
          return new e.Point(
            this.containerSize.x,
            this.containerSize.y
          );
        },
        /**
         * The margins push the "home" region in from the sides by the specified amounts.
         * @function
         * @returns {Object} Properties (Numbers, in screen coordinates): left, top, right, bottom.
         */
        getMargins: function() {
          return e.extend({}, this._margins);
        },
        /**
         * The margins push the "home" region in from the sides by the specified amounts.
         * @function
         * @param {Object} margins - Properties (Numbers, in screen coordinates): left, top, right, bottom.
         */
        setMargins: function(t) {
          e.console.assert(e.type(t) === "object", "[Viewport.setMargins] margins must be an object"), this._margins = e.extend({
            left: 0,
            top: 0,
            right: 0,
            bottom: 0
          }, t), this._updateContainerInnerSize(), this.viewer && this.viewer.forceRedraw();
        },
        /**
         * Returns the bounds of the visible area in viewport coordinates.
         * @function
         * @param {Boolean} current - Pass true for the current location; defaults to false (target location).
         * @returns {OpenSeadragon.Rect} The location you are zoomed/panned to, in viewport coordinates.
         */
        getBounds: function(t) {
          return this.getBoundsNoRotate(t).rotate(-this.getRotation(t));
        },
        /**
         * Returns the bounds of the visible area in viewport coordinates.
         * This method ignores the viewport rotation. Use
         * {@link OpenSeadragon.Viewport#getBounds} to take it into account.
         * @function
         * @param {Boolean} current - Pass true for the current location; defaults to false (target location).
         * @returns {OpenSeadragon.Rect} The location you are zoomed/panned to, in viewport coordinates.
         */
        getBoundsNoRotate: function(t) {
          var i = this.getCenter(t), r = 1 / this.getZoom(t), o = r / this.getAspectRatio();
          return new e.Rect(
            i.x - r / 2,
            i.y - o / 2,
            r,
            o
          );
        },
        /**
         * @function
         * @param {Boolean} current - Pass true for the current location; defaults to false (target location).
         * @returns {OpenSeadragon.Rect} The location you are zoomed/panned to,
         * including the space taken by margins, in viewport coordinates.
         */
        getBoundsWithMargins: function(t) {
          return this.getBoundsNoRotateWithMargins(t).rotate(
            -this.getRotation(t),
            this.getCenter(t)
          );
        },
        /**
         * @function
         * @param {Boolean} current - Pass true for the current location; defaults to false (target location).
         * @returns {OpenSeadragon.Rect} The location you are zoomed/panned to,
         * including the space taken by margins, in viewport coordinates.
         */
        getBoundsNoRotateWithMargins: function(t) {
          var i = this.getBoundsNoRotate(t), r = this._containerInnerSize.x * this.getZoom(t);
          return i.x -= this._margins.left / r, i.y -= this._margins.top / r, i.width += (this._margins.left + this._margins.right) / r, i.height += (this._margins.top + this._margins.bottom) / r, i;
        },
        /**
         * @function
         * @param {Boolean} current - Pass true for the current location; defaults to false (target location).
         */
        getCenter: function(t) {
          var i = new e.Point(
            this.centerSpringX.current.value,
            this.centerSpringY.current.value
          ), r = new e.Point(
            this.centerSpringX.target.value,
            this.centerSpringY.target.value
          ), o, a, c, u, h, f, g, x;
          return t ? i : this.zoomPoint ? (o = this.pixelFromPoint(this.zoomPoint, !0), a = this.getZoom(), c = 1 / a, u = c / this.getAspectRatio(), h = new e.Rect(
            i.x - c / 2,
            i.y - u / 2,
            c,
            u
          ), f = this._pixelFromPoint(this.zoomPoint, h), g = f.minus(o).rotate(-this.getRotation(!0)), x = g.divide(this._containerInnerSize.x * a), r.plus(x)) : r;
        },
        /**
         * @function
         * @param {Boolean} current - Pass true for the current location; defaults to false (target location).
         */
        getZoom: function(t) {
          return t ? this.zoomSpring.current.value : this.zoomSpring.target.value;
        },
        // private
        _applyZoomConstraints: function(t) {
          return Math.max(
            Math.min(t, this.getMaxZoom()),
            this.getMinZoom()
          );
        },
        /**
         * @function
         * @private
         * @param {OpenSeadragon.Rect} bounds
         * @returns {OpenSeadragon.Rect} constrained bounds.
         */
        _applyBoundaryConstraints: function(t) {
          var i = this.viewportToViewerElementRectangle(t).getBoundingBox(), r = this.viewportToViewerElementRectangle(this._contentBoundsNoRotate).getBoundingBox(), o = !1, a = !1;
          if (!this.wrapHorizontal) {
            var c = i.x + i.width, u = r.x + r.width, h, f, g;
            i.width > r.width ? h = this.visibilityRatio * r.width : h = this.visibilityRatio * i.width, f = r.x - c + h, g = u - i.x - h, h > r.width ? (i.x += (f + g) / 2, o = !0) : g < 0 ? (i.x += g, o = !0) : f > 0 && (i.x += f, o = !0);
          }
          if (!this.wrapVertical) {
            var x = i.y + i.height, C = r.y + r.height, E, R, D;
            i.height > r.height ? E = this.visibilityRatio * r.height : E = this.visibilityRatio * i.height, R = r.y - x + E, D = C - i.y - E, E > r.height ? (i.y += (R + D) / 2, a = !0) : D < 0 ? (i.y += D, a = !0) : R > 0 && (i.y += R, a = !0);
          }
          var U = o || a, Z = U ? this.viewerElementToViewportRectangle(i) : t.clone();
          return Z.xConstrained = o, Z.yConstrained = a, Z.constraintApplied = U, Z;
        },
        /**
         * @function
         * @private
         * @param {Boolean} [immediately=false] - whether the function that triggered this event was
         * called with the "immediately" flag
         */
        _raiseConstraintsEvent: function(t) {
          this.viewer && this.viewer.raiseEvent("constrain", {
            immediately: t
          });
        },
        /**
         * Enforces the minZoom, maxZoom and visibilityRatio constraints by
         * zooming and panning to the closest acceptable zoom and location.
         * @function
         * @param {Boolean} [immediately=false]
         * @returns {OpenSeadragon.Viewport} Chainable.
         * @fires OpenSeadragon.Viewer.event:constrain if constraints were applied
         */
        applyConstraints: function(t) {
          var i = this.getZoom(), r = this._applyZoomConstraints(i);
          i !== r && this.zoomTo(r, this.zoomPoint, t);
          var o = this.getConstrainedBounds(!1);
          return o.constraintApplied && (this.fitBounds(o, t), this._raiseConstraintsEvent(t)), this;
        },
        /**
         * Equivalent to {@link OpenSeadragon.Viewport#applyConstraints}
         * @function
         * @param {Boolean} [immediately=false]
         * @returns {OpenSeadragon.Viewport} Chainable.
         * @fires OpenSeadragon.Viewer.event:constrain
         */
        ensureVisible: function(t) {
          return this.applyConstraints(t);
        },
        /**
         * @function
         * @private
         * @param {OpenSeadragon.Rect} bounds
         * @param {Object} options (immediately=false, constraints=false)
         * @returns {OpenSeadragon.Viewport} Chainable.
         */
        _fitBounds: function(t, i) {
          i = i || {};
          var r = i.immediately || !1, o = i.constraints || !1, a = this.getAspectRatio(), c = t.getCenter(), u = new e.Rect(
            t.x,
            t.y,
            t.width,
            t.height,
            t.degrees + this.getRotation()
          ).getBoundingBox();
          u.getAspectRatio() >= a ? u.height = u.width / a : u.width = u.height * a, u.x = c.x - u.width / 2, u.y = c.y - u.height / 2;
          var h = 1 / u.width;
          if (r)
            return this.panTo(c, !0), this.zoomTo(h, null, !0), o && this.applyConstraints(!0), this;
          var f = this.getCenter(!0), g = this.getZoom(!0);
          this.panTo(f, !0), this.zoomTo(g, null, !0);
          var x = this.getBounds(), C = this.getZoom();
          if (C === 0 || Math.abs(h / C - 1) < 1e-8)
            return this.zoomTo(h, null, !0), this.panTo(c, r), o && this.applyConstraints(!1), this;
          if (o) {
            this.panTo(c, !1), h = this._applyZoomConstraints(h), this.zoomTo(h, null, !1);
            var E = this.getConstrainedBounds();
            this.panTo(f, !0), this.zoomTo(g, null, !0), this.fitBounds(E);
          } else {
            var R = u.rotate(-this.getRotation()), D = R.getTopLeft().times(h).minus(x.getTopLeft().times(C)).divide(h - C);
            this.zoomTo(h, D, r);
          }
          return this;
        },
        /**
         * Makes the viewport zoom and pan so that the specified bounds take
         * as much space as possible in the viewport.
         * Note: this method ignores the constraints (minZoom, maxZoom and
         * visibilityRatio).
         * Use {@link OpenSeadragon.Viewport#fitBoundsWithConstraints} to enforce
         * them.
         * @function
         * @param {OpenSeadragon.Rect} bounds
         * @param {Boolean} [immediately=false]
         * @returns {OpenSeadragon.Viewport} Chainable.
         */
        fitBounds: function(t, i) {
          return this._fitBounds(t, {
            immediately: i,
            constraints: !1
          });
        },
        /**
         * Makes the viewport zoom and pan so that the specified bounds take
         * as much space as possible in the viewport while enforcing the constraints
         * (minZoom, maxZoom and visibilityRatio).
         * Note: because this method enforces the constraints, part of the
         * provided bounds may end up outside of the viewport.
         * Use {@link OpenSeadragon.Viewport#fitBounds} to ignore them.
         * @function
         * @param {OpenSeadragon.Rect} bounds
         * @param {Boolean} [immediately=false]
         * @returns {OpenSeadragon.Viewport} Chainable.
         */
        fitBoundsWithConstraints: function(t, i) {
          return this._fitBounds(t, {
            immediately: i,
            constraints: !0
          });
        },
        /**
         * Zooms so the image just fills the viewer vertically.
         * @param {Boolean} immediately
         * @returns {OpenSeadragon.Viewport} Chainable.
         */
        fitVertically: function(t) {
          var i = new e.Rect(
            this._contentBounds.x + this._contentBounds.width / 2,
            this._contentBounds.y,
            0,
            this._contentBounds.height
          );
          return this.fitBounds(i, t);
        },
        /**
         * Zooms so the image just fills the viewer horizontally.
         * @param {Boolean} immediately
         * @returns {OpenSeadragon.Viewport} Chainable.
         */
        fitHorizontally: function(t) {
          var i = new e.Rect(
            this._contentBounds.x,
            this._contentBounds.y + this._contentBounds.height / 2,
            this._contentBounds.width,
            0
          );
          return this.fitBounds(i, t);
        },
        /**
         * Returns bounds taking constraints into account
         * Added to improve constrained panning
         * @param {Boolean} current - Pass true for the current location; defaults to false (target location).
         * @returns {OpenSeadragon.Rect} The bounds in viewport coordinates after applying constraints. The returned $.Rect
         *                               contains additional properties constraintsApplied, xConstrained and yConstrained.
         *                               These flags indicate whether the viewport bounds were modified by the constraints
         *                               of the viewer rectangle, and in which dimension(s).
         */
        getConstrainedBounds: function(t) {
          var i, r;
          return i = this.getBounds(t), r = this._applyBoundaryConstraints(i), r;
        },
        /**
         * @function
         * @param {OpenSeadragon.Point} delta
         * @param {Boolean} immediately
         * @returns {OpenSeadragon.Viewport} Chainable.
         * @fires OpenSeadragon.Viewer.event:pan
         */
        panBy: function(t, i) {
          var r = new e.Point(
            this.centerSpringX.target.value,
            this.centerSpringY.target.value
          );
          return this.panTo(r.plus(t), i);
        },
        /**
         * @function
         * @param {OpenSeadragon.Point} center
         * @param {Boolean} immediately
         * @returns {OpenSeadragon.Viewport} Chainable.
         * @fires OpenSeadragon.Viewer.event:pan
         */
        panTo: function(t, i) {
          return i ? (this.centerSpringX.resetTo(t.x), this.centerSpringY.resetTo(t.y)) : (this.centerSpringX.springTo(t.x), this.centerSpringY.springTo(t.y)), this.viewer && this.viewer.raiseEvent("pan", {
            center: t,
            immediately: i
          }), this;
        },
        /**
         * @function
         * @returns {OpenSeadragon.Viewport} Chainable.
         * @fires OpenSeadragon.Viewer.event:zoom
         */
        zoomBy: function(t, i, r) {
          return this.zoomTo(
            this.zoomSpring.target.value * t,
            i,
            r
          );
        },
        /**
         * Zooms to the specified zoom level
         * @function
         * @param {Number} zoom The zoom level to zoom to.
         * @param {OpenSeadragon.Point} [refPoint] The point which will stay at
         * the same screen location. Defaults to the viewport center.
         * @param {Boolean} [immediately=false]
         * @returns {OpenSeadragon.Viewport} Chainable.
         * @fires OpenSeadragon.Viewer.event:zoom
         */
        zoomTo: function(t, i, r) {
          var o = this;
          return this.zoomPoint = i instanceof e.Point && !isNaN(i.x) && !isNaN(i.y) ? i : null, r ? this._adjustCenterSpringsForZoomPoint(function() {
            o.zoomSpring.resetTo(t);
          }) : this.zoomSpring.springTo(t), this.viewer && this.viewer.raiseEvent("zoom", {
            zoom: t,
            refPoint: i,
            immediately: r
          }), this;
        },
        /**
         * Rotates this viewport to the angle specified.
         * @function
         * @param {Number} degrees The degrees to set the rotation to.
         * @param {Boolean} [immediately=false] Whether to animate to the new angle
         * or rotate immediately.
         * * @returns {OpenSeadragon.Viewport} Chainable.
         */
        setRotation: function(t, i) {
          return this.rotateTo(t, null, i);
        },
        /**
         * Gets the current rotation in degrees.
         * @function
         * @param {Boolean} [current=false] True for current rotation, false for target.
         * @returns {Number} The current rotation in degrees.
         */
        getRotation: function(t) {
          return t ? this.degreesSpring.current.value : this.degreesSpring.target.value;
        },
        /**
         * Rotates this viewport to the angle specified around a pivot point. Alias for rotateTo.
         * @function
         * @param {Number} degrees The degrees to set the rotation to.
         * @param {OpenSeadragon.Point} [pivot] (Optional) point in viewport coordinates
         * around which the rotation should be performed. Defaults to the center of the viewport.
         * @param {Boolean} [immediately=false] Whether to animate to the new angle
         * or rotate immediately.
         * * @returns {OpenSeadragon.Viewport} Chainable.
         */
        setRotationWithPivot: function(t, i, r) {
          return this.rotateTo(t, i, r);
        },
        /**
         * Rotates this viewport to the angle specified.
         * @function
         * @param {Number} degrees The degrees to set the rotation to.
         * @param {OpenSeadragon.Point} [pivot] (Optional) point in viewport coordinates
         * around which the rotation should be performed. Defaults to the center of the viewport.
         * @param {Boolean} [immediately=false] Whether to animate to the new angle
         * or rotate immediately.
         * @returns {OpenSeadragon.Viewport} Chainable.
         */
        rotateTo: function(t, i, r) {
          if (!this.viewer || !this.viewer.drawer.canRotate())
            return this;
          if (this.degreesSpring.target.value === t && this.degreesSpring.isAtTargetValue())
            return this;
          if (this.rotationPivot = i instanceof e.Point && !isNaN(i.x) && !isNaN(i.y) ? i : null, r)
            if (this.rotationPivot) {
              var o = t - this._oldDegrees;
              if (!o)
                return this.rotationPivot = null, this;
              this._rotateAboutPivot(t);
            } else
              this.degreesSpring.resetTo(t);
          else {
            var a = e.positiveModulo(this.degreesSpring.current.value, 360), c = e.positiveModulo(t, 360), u = c - a;
            u > 180 ? c -= 360 : u < -180 && (c += 360);
            var h = a - c;
            this.degreesSpring.resetTo(t + h), this.degreesSpring.springTo(t);
          }
          return this._setContentBounds(
            this.viewer.world.getHomeBounds(),
            this.viewer.world.getContentFactor()
          ), this.viewer.forceRedraw(), this.viewer.raiseEvent("rotate", { degrees: t, immediately: !!r, pivot: this.rotationPivot || this.getCenter() }), this;
        },
        /**
         * Rotates this viewport by the angle specified.
         * @function
         * @param {Number} degrees The degrees by which to rotate the viewport.
         * @param {OpenSeadragon.Point} [pivot] (Optional) point in viewport coordinates
         * around which the rotation should be performed. Defaults to the center of the viewport.
         * * @param {Boolean} [immediately=false] Whether to animate to the new angle
         * or rotate immediately.
         * @returns {OpenSeadragon.Viewport} Chainable.
         */
        rotateBy: function(t, i, r) {
          return this.rotateTo(this.degreesSpring.target.value + t, i, r);
        },
        /**
         * @function
         * @returns {OpenSeadragon.Viewport} Chainable.
         * @fires OpenSeadragon.Viewer.event:resize
         */
        resize: function(t, i) {
          var r = this.getBoundsNoRotate(), o = r, a;
          this.containerSize.x = t.x, this.containerSize.y = t.y, this._updateContainerInnerSize(), i && (a = t.x / this.containerSize.x, o.width = r.width * a, o.height = o.width / this.getAspectRatio()), this.viewer && this.viewer.raiseEvent("resize", {
            newContainerSize: t,
            maintain: i
          });
          var c = this.fitBounds(o, !0);
          return this.viewer && this.viewer.raiseEvent("after-resize", {
            newContainerSize: t,
            maintain: i
          }), c;
        },
        // private
        _updateContainerInnerSize: function() {
          this._containerInnerSize = new e.Point(
            Math.max(1, this.containerSize.x - (this._margins.left + this._margins.right)),
            Math.max(1, this.containerSize.y - (this._margins.top + this._margins.bottom))
          );
        },
        /**
         * Update the zoom, degrees, and center (X and Y) springs.
         * @function
         * @returns {Boolean} True if the viewport is still animating, false otherwise.
         */
        update: function() {
          var t = this;
          this._adjustCenterSpringsForZoomPoint(function() {
            t.zoomSpring.update();
          }), this.degreesSpring.isAtTargetValue() && (this.rotationPivot = null), this.centerSpringX.update(), this.centerSpringY.update(), this.rotationPivot ? this._rotateAboutPivot(!0) : this.degreesSpring.update();
          var i = this.centerSpringX.current.value !== this._oldCenterX || this.centerSpringY.current.value !== this._oldCenterY || this.zoomSpring.current.value !== this._oldZoom || this.degreesSpring.current.value !== this._oldDegrees;
          this._oldCenterX = this.centerSpringX.current.value, this._oldCenterY = this.centerSpringY.current.value, this._oldZoom = this.zoomSpring.current.value, this._oldDegrees = this.degreesSpring.current.value;
          var r = i || !this.zoomSpring.isAtTargetValue() || !this.centerSpringX.isAtTargetValue() || !this.centerSpringY.isAtTargetValue() || !this.degreesSpring.isAtTargetValue();
          return r;
        },
        // private - pass true to use spring, or a number for degrees for immediate rotation
        _rotateAboutPivot: function(t) {
          var i = t === !0, r = this.rotationPivot.minus(this.getCenter());
          this.centerSpringX.shiftBy(r.x), this.centerSpringY.shiftBy(r.y), i ? this.degreesSpring.update() : this.degreesSpring.resetTo(t);
          var o = this.degreesSpring.current.value - this._oldDegrees, a = r.rotate(o * -1).times(-1);
          this.centerSpringX.shiftBy(a.x), this.centerSpringY.shiftBy(a.y);
        },
        // private
        _adjustCenterSpringsForZoomPoint: function(t) {
          if (this.zoomPoint) {
            var i = this.pixelFromPoint(this.zoomPoint, !0);
            t();
            var r = this.pixelFromPoint(this.zoomPoint, !0), o = r.minus(i), a = this.deltaPointsFromPixels(
              o,
              !0
            );
            this.centerSpringX.shiftBy(a.x), this.centerSpringY.shiftBy(a.y), this.zoomSpring.isAtTargetValue() && (this.zoomPoint = null);
          } else
            t();
        },
        /**
         * Convert a delta (translation vector) from viewport coordinates to pixels
         * coordinates. This method does not take rotation into account.
         * Consider using deltaPixelsFromPoints if you need to account for rotation.
         * @param {OpenSeadragon.Point} deltaPoints - The translation vector to convert.
         * @param {Boolean} [current=false] - Pass true for the current location;
         * defaults to false (target location).
         * @returns {OpenSeadragon.Point}
         */
        deltaPixelsFromPointsNoRotate: function(t, i) {
          return t.times(
            this._containerInnerSize.x * this.getZoom(i)
          );
        },
        /**
         * Convert a delta (translation vector) from viewport coordinates to pixels
         * coordinates.
         * @param {OpenSeadragon.Point} deltaPoints - The translation vector to convert.
         * @param {Boolean} [current=false] - Pass true for the current location;
         * defaults to false (target location).
         * @returns {OpenSeadragon.Point}
         */
        deltaPixelsFromPoints: function(t, i) {
          return this.deltaPixelsFromPointsNoRotate(
            t.rotate(this.getRotation(i)),
            i
          );
        },
        /**
         * Convert a delta (translation vector) from pixels coordinates to viewport
         * coordinates. This method does not take rotation into account.
         * Consider using deltaPointsFromPixels if you need to account for rotation.
         * @param {OpenSeadragon.Point} deltaPixels - The translation vector to convert.
         * @param {Boolean} [current=false] - Pass true for the current location;
         * defaults to false (target location).
         * @returns {OpenSeadragon.Point}
         */
        deltaPointsFromPixelsNoRotate: function(t, i) {
          return t.divide(
            this._containerInnerSize.x * this.getZoom(i)
          );
        },
        /**
         * Convert a delta (translation vector) from pixels coordinates to viewport
         * coordinates.
         * @param {OpenSeadragon.Point} deltaPixels - The translation vector to convert.
         * @param {Boolean} [current=false] - Pass true for the current location;
         * defaults to false (target location).
         * @returns {OpenSeadragon.Point}
         */
        deltaPointsFromPixels: function(t, i) {
          return this.deltaPointsFromPixelsNoRotate(t, i).rotate(-this.getRotation(i));
        },
        /**
         * Convert viewport coordinates to pixels coordinates.
         * This method does not take rotation into account.
         * Consider using pixelFromPoint if you need to account for rotation.
         * @param {OpenSeadragon.Point} point the viewport coordinates
         * @param {Boolean} [current=false] - Pass true for the current location;
         * defaults to false (target location).
         * @returns {OpenSeadragon.Point}
         */
        pixelFromPointNoRotate: function(t, i) {
          return this._pixelFromPointNoRotate(
            t,
            this.getBoundsNoRotate(i)
          );
        },
        /**
         * Convert viewport coordinates to pixel coordinates.
         * @param {OpenSeadragon.Point} point the viewport coordinates
         * @param {Boolean} [current=false] - Pass true for the current location;
         * defaults to false (target location).
         * @returns {OpenSeadragon.Point}
         */
        pixelFromPoint: function(t, i) {
          return this._pixelFromPoint(t, this.getBoundsNoRotate(i));
        },
        // private
        _pixelFromPointNoRotate: function(t, i) {
          return t.minus(
            i.getTopLeft()
          ).times(
            this._containerInnerSize.x / i.width
          ).plus(
            new e.Point(this._margins.left, this._margins.top)
          );
        },
        // private
        _pixelFromPoint: function(t, i) {
          return this._pixelFromPointNoRotate(
            t.rotate(this.getRotation(!0), this.getCenter(!0)),
            i
          );
        },
        /**
         * Convert pixel coordinates to viewport coordinates.
         * This method does not take rotation into account.
         * Consider using pointFromPixel if you need to account for rotation.
         * @param {OpenSeadragon.Point} pixel Pixel coordinates
         * @param {Boolean} [current=false] - Pass true for the current location;
         * defaults to false (target location).
         * @returns {OpenSeadragon.Point}
         */
        pointFromPixelNoRotate: function(t, i) {
          var r = this.getBoundsNoRotate(i);
          return t.minus(
            new e.Point(this._margins.left, this._margins.top)
          ).divide(
            this._containerInnerSize.x / r.width
          ).plus(
            r.getTopLeft()
          );
        },
        /**
         * Convert pixel coordinates to viewport coordinates.
         * @param {OpenSeadragon.Point} pixel Pixel coordinates
         * @param {Boolean} [current=false] - Pass true for the current location;
         * defaults to false (target location).
         * @returns {OpenSeadragon.Point}
         */
        pointFromPixel: function(t, i) {
          return this.pointFromPixelNoRotate(t, i).rotate(
            -this.getRotation(i),
            this.getCenter(i)
          );
        },
        // private
        _viewportToImageDelta: function(t, i) {
          var r = this._contentBoundsNoRotate.width;
          return new e.Point(
            t * this._contentSizeNoRotate.x / r,
            i * this._contentSizeNoRotate.x / r
          );
        },
        /**
         * Translates from OpenSeadragon viewer coordinate system to image coordinate system.
         * This method can be called either by passing X,Y coordinates or an
         * OpenSeadragon.Point
         * Note: not accurate with multi-image; use TiledImage.viewportToImageCoordinates instead.
         * @function
         * @param {(OpenSeadragon.Point|Number)} viewerX either a point or the X
         * coordinate in viewport coordinate system.
         * @param {Number} [viewerY] Y coordinate in viewport coordinate system.
         * @returns {OpenSeadragon.Point} a point representing the coordinates in the image.
         */
        viewportToImageCoordinates: function(t, i) {
          if (t instanceof e.Point)
            return this.viewportToImageCoordinates(t.x, t.y);
          if (this.viewer) {
            var r = this.viewer.world.getItemCount();
            if (r > 1)
              this.silenceMultiImageWarnings || e.console.error("[Viewport.viewportToImageCoordinates] is not accurate with multi-image; use TiledImage.viewportToImageCoordinates instead.");
            else if (r === 1) {
              var o = this.viewer.world.getItemAt(0);
              return o.viewportToImageCoordinates(t, i, !0);
            }
          }
          return this._viewportToImageDelta(
            t - this._contentBoundsNoRotate.x,
            i - this._contentBoundsNoRotate.y
          );
        },
        // private
        _imageToViewportDelta: function(t, i) {
          var r = this._contentBoundsNoRotate.width;
          return new e.Point(
            t / this._contentSizeNoRotate.x * r,
            i / this._contentSizeNoRotate.x * r
          );
        },
        /**
         * Translates from image coordinate system to OpenSeadragon viewer coordinate system
         * This method can be called either by passing X,Y coordinates or an
         * OpenSeadragon.Point
         * Note: not accurate with multi-image; use TiledImage.imageToViewportCoordinates instead.
         * @function
         * @param {(OpenSeadragon.Point | Number)} imageX the point or the
         * X coordinate in image coordinate system.
         * @param {Number} [imageY] Y coordinate in image coordinate system.
         * @returns {OpenSeadragon.Point} a point representing the coordinates in the viewport.
         */
        imageToViewportCoordinates: function(t, i) {
          if (t instanceof e.Point)
            return this.imageToViewportCoordinates(t.x, t.y);
          if (this.viewer) {
            var r = this.viewer.world.getItemCount();
            if (r > 1)
              this.silenceMultiImageWarnings || e.console.error("[Viewport.imageToViewportCoordinates] is not accurate with multi-image; use TiledImage.imageToViewportCoordinates instead.");
            else if (r === 1) {
              var o = this.viewer.world.getItemAt(0);
              return o.imageToViewportCoordinates(t, i, !0);
            }
          }
          var a = this._imageToViewportDelta(t, i);
          return a.x += this._contentBoundsNoRotate.x, a.y += this._contentBoundsNoRotate.y, a;
        },
        /**
         * Translates from a rectangle which describes a portion of the image in
         * pixel coordinates to OpenSeadragon viewport rectangle coordinates.
         * This method can be called either by passing X,Y,width,height or an
         * OpenSeadragon.Rect
         * Note: not accurate with multi-image; use TiledImage.imageToViewportRectangle instead.
         * @function
         * @param {(OpenSeadragon.Rect | Number)} imageX the rectangle or the X
         * coordinate of the top left corner of the rectangle in image coordinate system.
         * @param {Number} [imageY] the Y coordinate of the top left corner of the rectangle
         * in image coordinate system.
         * @param {Number} [pixelWidth] the width in pixel of the rectangle.
         * @param {Number} [pixelHeight] the height in pixel of the rectangle.
         * @returns {OpenSeadragon.Rect} This image's bounds in viewport coordinates
         */
        imageToViewportRectangle: function(t, i, r, o) {
          var a = t;
          if (a instanceof e.Rect || (a = new e.Rect(t, i, r, o)), this.viewer) {
            var c = this.viewer.world.getItemCount();
            if (c > 1)
              this.silenceMultiImageWarnings || e.console.error("[Viewport.imageToViewportRectangle] is not accurate with multi-image; use TiledImage.imageToViewportRectangle instead.");
            else if (c === 1) {
              var u = this.viewer.world.getItemAt(0);
              return u.imageToViewportRectangle(
                t,
                i,
                r,
                o,
                !0
              );
            }
          }
          var h = this.imageToViewportCoordinates(a.x, a.y), f = this._imageToViewportDelta(a.width, a.height);
          return new e.Rect(
            h.x,
            h.y,
            f.x,
            f.y,
            a.degrees
          );
        },
        /**
         * Translates from a rectangle which describes a portion of
         * the viewport in point coordinates to image rectangle coordinates.
         * This method can be called either by passing X,Y,width,height or an
         * OpenSeadragon.Rect
         * Note: not accurate with multi-image; use TiledImage.viewportToImageRectangle instead.
         * @function
         * @param {(OpenSeadragon.Rect | Number)} viewerX either a rectangle or
         * the X coordinate of the top left corner of the rectangle in viewport
         * coordinate system.
         * @param {Number} [viewerY] the Y coordinate of the top left corner of the rectangle
         * in viewport coordinate system.
         * @param {Number} [pointWidth] the width of the rectangle in viewport coordinate system.
         * @param {Number} [pointHeight] the height of the rectangle in viewport coordinate system.
         */
        viewportToImageRectangle: function(t, i, r, o) {
          var a = t;
          if (a instanceof e.Rect || (a = new e.Rect(t, i, r, o)), this.viewer) {
            var c = this.viewer.world.getItemCount();
            if (c > 1)
              this.silenceMultiImageWarnings || e.console.error("[Viewport.viewportToImageRectangle] is not accurate with multi-image; use TiledImage.viewportToImageRectangle instead.");
            else if (c === 1) {
              var u = this.viewer.world.getItemAt(0);
              return u.viewportToImageRectangle(
                t,
                i,
                r,
                o,
                !0
              );
            }
          }
          var h = this.viewportToImageCoordinates(a.x, a.y), f = this._viewportToImageDelta(a.width, a.height);
          return new e.Rect(
            h.x,
            h.y,
            f.x,
            f.y,
            a.degrees
          );
        },
        /**
         * Convert pixel coordinates relative to the viewer element to image
         * coordinates.
         * Note: not accurate with multi-image.
         * @param {OpenSeadragon.Point} pixel
         * @returns {OpenSeadragon.Point}
         */
        viewerElementToImageCoordinates: function(t) {
          var i = this.pointFromPixel(t, !0);
          return this.viewportToImageCoordinates(i);
        },
        /**
         * Convert pixel coordinates relative to the image to
         * viewer element coordinates.
         * Note: not accurate with multi-image.
         * @param {OpenSeadragon.Point} pixel
         * @returns {OpenSeadragon.Point}
         */
        imageToViewerElementCoordinates: function(t) {
          var i = this.imageToViewportCoordinates(t);
          return this.pixelFromPoint(i, !0);
        },
        /**
         * Convert pixel coordinates relative to the window to image coordinates.
         * Note: not accurate with multi-image.
         * @param {OpenSeadragon.Point} pixel
         * @returns {OpenSeadragon.Point}
         */
        windowToImageCoordinates: function(t) {
          e.console.assert(
            this.viewer,
            "[Viewport.windowToImageCoordinates] the viewport must have a viewer."
          );
          var i = t.minus(
            e.getElementPosition(this.viewer.element)
          );
          return this.viewerElementToImageCoordinates(i);
        },
        /**
         * Convert image coordinates to pixel coordinates relative to the window.
         * Note: not accurate with multi-image.
         * @param {OpenSeadragon.Point} pixel
         * @returns {OpenSeadragon.Point}
         */
        imageToWindowCoordinates: function(t) {
          e.console.assert(
            this.viewer,
            "[Viewport.imageToWindowCoordinates] the viewport must have a viewer."
          );
          var i = this.imageToViewerElementCoordinates(t);
          return i.plus(
            e.getElementPosition(this.viewer.element)
          );
        },
        /**
         * Convert pixel coordinates relative to the viewer element to viewport
         * coordinates.
         * @param {OpenSeadragon.Point} pixel
         * @returns {OpenSeadragon.Point}
         */
        viewerElementToViewportCoordinates: function(t) {
          return this.pointFromPixel(t, !0);
        },
        /**
         * Convert viewport coordinates to pixel coordinates relative to the
         * viewer element.
         * @param {OpenSeadragon.Point} point
         * @returns {OpenSeadragon.Point}
         */
        viewportToViewerElementCoordinates: function(t) {
          return this.pixelFromPoint(t, !0);
        },
        /**
         * Convert a rectangle in pixel coordinates relative to the viewer element
         * to viewport coordinates.
         * @param {OpenSeadragon.Rect} rectangle the rectangle to convert
         * @returns {OpenSeadragon.Rect} the converted rectangle
         */
        viewerElementToViewportRectangle: function(t) {
          return e.Rect.fromSummits(
            this.pointFromPixel(t.getTopLeft(), !0),
            this.pointFromPixel(t.getTopRight(), !0),
            this.pointFromPixel(t.getBottomLeft(), !0)
          );
        },
        /**
         * Convert a rectangle in viewport coordinates to pixel coordinates relative
         * to the viewer element.
         * @param {OpenSeadragon.Rect} rectangle the rectangle to convert
         * @returns {OpenSeadragon.Rect} the converted rectangle
         */
        viewportToViewerElementRectangle: function(t) {
          return e.Rect.fromSummits(
            this.pixelFromPoint(t.getTopLeft(), !0),
            this.pixelFromPoint(t.getTopRight(), !0),
            this.pixelFromPoint(t.getBottomLeft(), !0)
          );
        },
        /**
         * Convert pixel coordinates relative to the window to viewport coordinates.
         * @param {OpenSeadragon.Point} pixel
         * @returns {OpenSeadragon.Point}
         */
        windowToViewportCoordinates: function(t) {
          e.console.assert(
            this.viewer,
            "[Viewport.windowToViewportCoordinates] the viewport must have a viewer."
          );
          var i = t.minus(
            e.getElementPosition(this.viewer.element)
          );
          return this.viewerElementToViewportCoordinates(i);
        },
        /**
         * Convert viewport coordinates to pixel coordinates relative to the window.
         * @param {OpenSeadragon.Point} point
         * @returns {OpenSeadragon.Point}
         */
        viewportToWindowCoordinates: function(t) {
          e.console.assert(
            this.viewer,
            "[Viewport.viewportToWindowCoordinates] the viewport must have a viewer."
          );
          var i = this.viewportToViewerElementCoordinates(t);
          return i.plus(
            e.getElementPosition(this.viewer.element)
          );
        },
        /**
         * Convert a viewport zoom to an image zoom.
         * Image zoom: ratio of the original image size to displayed image size.
         * 1 means original image size, 0.5 half size...
         * Viewport zoom: ratio of the displayed image's width to viewport's width.
         * 1 means identical width, 2 means image's width is twice the viewport's width...
         * Note: not accurate with multi-image.
         * @function
         * @param {Number} viewportZoom The viewport zoom
         * target zoom.
         * @returns {Number} imageZoom The image zoom
         */
        viewportToImageZoom: function(t) {
          if (this.viewer) {
            var i = this.viewer.world.getItemCount();
            if (i > 1)
              this.silenceMultiImageWarnings || e.console.error("[Viewport.viewportToImageZoom] is not accurate with multi-image.");
            else if (i === 1) {
              var r = this.viewer.world.getItemAt(0);
              return r.viewportToImageZoom(t);
            }
          }
          var o = this._contentSizeNoRotate.x, a = this._containerInnerSize.x, c = this._contentBoundsNoRotate.width, u = a / o * c;
          return t * u;
        },
        /**
         * Convert an image zoom to a viewport zoom.
         * Image zoom: ratio of the original image size to displayed image size.
         * 1 means original image size, 0.5 half size...
         * Viewport zoom: ratio of the displayed image's width to viewport's width.
         * 1 means identical width, 2 means image's width is twice the viewport's width...
         * Note: not accurate with multi-image; use [TiledImage.imageToViewportZoom] for the specific image of interest.
         * @function
         * @param {Number} imageZoom The image zoom
         * target zoom.
         * @returns {Number} viewportZoom The viewport zoom
         */
        imageToViewportZoom: function(t) {
          if (this.viewer) {
            var i = this.viewer.world.getItemCount();
            if (i > 1)
              this.silenceMultiImageWarnings || e.console.error("[Viewport.imageToViewportZoom] is not accurate with multi-image. Instead, use [TiledImage.imageToViewportZoom] for the specific image of interest");
            else if (i === 1) {
              var r = this.viewer.world.getItemAt(0);
              return r.imageToViewportZoom(t);
            }
          }
          var o = this._contentSizeNoRotate.x, a = this._containerInnerSize.x, c = this._contentBoundsNoRotate.width, u = o / a / c;
          return t * u;
        },
        /**
         * Toggles flip state and demands a new drawing on navigator and viewer objects.
         * @function
         * @returns {OpenSeadragon.Viewport} Chainable.
         */
        toggleFlip: function() {
          return this.setFlip(!this.getFlip()), this;
        },
        /**
         * Get flip state stored on viewport.
         * @function
         * @returns {Boolean} Flip state.
         */
        getFlip: function() {
          return this.flipped;
        },
        /**
         * Sets flip state according to the state input argument.
         * @function
         * @param {Boolean} state - Flip state to set.
         * @returns {OpenSeadragon.Viewport} Chainable.
         */
        setFlip: function(t) {
          return this.flipped === t ? this : (this.flipped = t, this.viewer.navigator && this.viewer.navigator.setFlip(this.getFlip()), this.viewer.forceRedraw(), this.viewer.raiseEvent("flip", { flipped: t }), this);
        },
        /**
         * Gets current max zoom pixel ratio
         * @function
         * @returns {Number} Max zoom pixel ratio
         */
        getMaxZoomPixelRatio: function() {
          return this.maxZoomPixelRatio;
        },
        /**
         * Sets max zoom pixel ratio
         * @function
         * @param {Number} ratio - Max zoom pixel ratio
         * @param {Boolean} [applyConstraints=true] - Apply constraints after setting ratio;
         * Takes effect only if current zoom is greater than set max zoom pixel ratio
         * @param {Boolean} [immediately=false] - Whether to animate to new zoom
         */
        setMaxZoomPixelRatio: function(t, i = !0, r = !1) {
          e.console.assert(!isNaN(t), "[Viewport.setMaxZoomPixelRatio] ratio must be a number"), !isNaN(t) && (this.maxZoomPixelRatio = t, i && this.getZoom() > this.getMaxZoom() && this.applyConstraints(r));
        }
      };
    })(n), (function(e) {
      e.TiledImage = function(t) {
        this._initialized = !1, e.console.assert(t.tileCache, "[TiledImage] options.tileCache is required"), e.console.assert(t.drawer, "[TiledImage] options.drawer is required"), e.console.assert(t.viewer, "[TiledImage] options.viewer is required"), e.console.assert(t.imageLoader, "[TiledImage] options.imageLoader is required"), e.console.assert(t.source, "[TiledImage] options.source is required"), e.console.assert(
          !t.clip || t.clip instanceof e.Rect,
          "[TiledImage] options.clip must be an OpenSeadragon.Rect if present"
        ), e.EventSource.call(this), this._tileCache = t.tileCache, delete t.tileCache, this._drawer = t.drawer, delete t.drawer, this._imageLoader = t.imageLoader, delete t.imageLoader, t.clip instanceof e.Rect && (this._clip = t.clip.clone()), delete t.clip;
        var i = t.x || 0;
        delete t.x;
        var r = t.y || 0;
        delete t.y, this.normHeight = t.source.dimensions.y / t.source.dimensions.x, this.contentAspectX = t.source.dimensions.x / t.source.dimensions.y;
        var o = 1;
        t.width ? (o = t.width, delete t.width, t.height && (e.console.error("specifying both width and height to a tiledImage is not supported"), delete t.height)) : t.height && (o = t.height / this.normHeight, delete t.height);
        var a = t.fitBounds;
        delete t.fitBounds;
        var c = t.fitBoundsPlacement || n.Placement.CENTER;
        delete t.fitBoundsPlacement;
        var u = t.degrees || 0;
        delete t.degrees;
        var h = t.ajaxHeaders;
        delete t.ajaxHeaders, e.extend(!0, this, {
          //internal state properties
          viewer: null,
          tilesMatrix: {},
          // A '3d' dictionary [level][x][y] --> Tile.
          coverage: {},
          // A '3d' dictionary [level][x][y] --> Boolean; shows what areas have been drawn.
          loadingCoverage: {},
          // A '3d' dictionary [level][x][y] --> Boolean; shows what areas are loaded or are being loaded/blended.
          lastDrawn: [],
          // An unordered list of Tiles drawn last frame.
          lastResetTime: 0,
          // Last time for which the tiledImage was reset.
          _needsDraw: !0,
          // Does the tiledImage need to be drawn again?
          _needsUpdate: !0,
          // Does the tiledImage need to update the viewport again?
          _hasOpaqueTile: !1,
          // Do we have even one fully opaque tile?
          _tilesLoading: 0,
          // The number of pending tile requests.
          _tilesToDraw: [],
          // info about the tiles currently in the viewport, two deep: array[level][tile]
          _lastDrawn: [],
          // array of tiles that were last fetched by the drawer
          _isBlending: !1,
          // Are any tiles still being blended?
          _wasBlending: !1,
          // Were any tiles blending before the last draw?
          _isTainted: !1,
          // Has a Tile been found with tainted data?
          //configurable settings
          springStiffness: e.DEFAULT_SETTINGS.springStiffness,
          animationTime: e.DEFAULT_SETTINGS.animationTime,
          minZoomImageRatio: e.DEFAULT_SETTINGS.minZoomImageRatio,
          wrapHorizontal: e.DEFAULT_SETTINGS.wrapHorizontal,
          wrapVertical: e.DEFAULT_SETTINGS.wrapVertical,
          immediateRender: e.DEFAULT_SETTINGS.immediateRender,
          blendTime: e.DEFAULT_SETTINGS.blendTime,
          alwaysBlend: e.DEFAULT_SETTINGS.alwaysBlend,
          minPixelRatio: e.DEFAULT_SETTINGS.minPixelRatio,
          smoothTileEdgesMinZoom: e.DEFAULT_SETTINGS.smoothTileEdgesMinZoom,
          iOSDevice: e.DEFAULT_SETTINGS.iOSDevice,
          debugMode: e.DEFAULT_SETTINGS.debugMode,
          crossOriginPolicy: e.DEFAULT_SETTINGS.crossOriginPolicy,
          ajaxWithCredentials: e.DEFAULT_SETTINGS.ajaxWithCredentials,
          placeholderFillStyle: e.DEFAULT_SETTINGS.placeholderFillStyle,
          opacity: e.DEFAULT_SETTINGS.opacity,
          preload: e.DEFAULT_SETTINGS.preload,
          compositeOperation: e.DEFAULT_SETTINGS.compositeOperation,
          subPixelRoundingForTransparency: e.DEFAULT_SETTINGS.subPixelRoundingForTransparency,
          maxTilesPerFrame: e.DEFAULT_SETTINGS.maxTilesPerFrame
        }, t), this._preload = this.preload, delete this.preload, this._fullyLoaded = !1, this._xSpring = new e.Spring({
          initial: i,
          springStiffness: this.springStiffness,
          animationTime: this.animationTime
        }), this._ySpring = new e.Spring({
          initial: r,
          springStiffness: this.springStiffness,
          animationTime: this.animationTime
        }), this._scaleSpring = new e.Spring({
          initial: o,
          springStiffness: this.springStiffness,
          animationTime: this.animationTime
        }), this._degreesSpring = new e.Spring({
          initial: u,
          springStiffness: this.springStiffness,
          animationTime: this.animationTime
        }), this._updateForScale(), a && this.fitBounds(a, c, !0), this._ownAjaxHeaders = {}, this.setAjaxHeaders(h, !1), this._initialized = !0;
      }, e.extend(
        e.TiledImage.prototype,
        e.EventSource.prototype,
        /** @lends OpenSeadragon.TiledImage.prototype */
        {
          /**
           * @returns {Boolean} Whether the TiledImage needs to be drawn.
           */
          needsDraw: function() {
            return this._needsDraw;
          },
          /**
           * Mark the tiled image as needing to be (re)drawn
           */
          redraw: function() {
            this._needsDraw = !0;
          },
          /**
           * @returns {Boolean} Whether all tiles necessary for this TiledImage to draw at the current view have been loaded.
           */
          getFullyLoaded: function() {
            return this._fullyLoaded;
          },
          // private
          _setFullyLoaded: function(t) {
            t !== this._fullyLoaded && (this._fullyLoaded = t, this.raiseEvent("fully-loaded-change", {
              fullyLoaded: this._fullyLoaded
            }));
          },
          /**
           * Clears all tiles and triggers an update on the next call to
           * {@link OpenSeadragon.TiledImage#update}.
           */
          reset: function() {
            this._tileCache.clearTilesFor(this), this.lastResetTime = e.now(), this._needsDraw = !0;
          },
          /**
           * Updates the TiledImage's bounds, animating if needed. Based on the new
           * bounds, updates the levels and tiles to be drawn into the viewport.
           * @param viewportChanged Whether the viewport changed meaning tiles need to be updated.
           * @returns {Boolean} Whether the TiledImage needs to be drawn.
           */
          update: function(t) {
            let i = this._xSpring.update(), r = this._ySpring.update(), o = this._scaleSpring.update(), a = this._degreesSpring.update(), c = i || r || o || a || this._needsUpdate;
            if (c || t || !this._fullyLoaded) {
              let u = this._updateLevelsForViewport();
              this._setFullyLoaded(u);
            }
            return this._needsUpdate = !1, c ? (this._updateForScale(), this._raiseBoundsChange(), this._needsDraw = !0, !0) : !1;
          },
          /**
           * Mark this TiledImage as having been drawn, so that it will only be drawn
           * again if something changes about the image. If the image is still blending,
           * this will have no effect.
           * @returns {Boolean} whether the item still needs to be drawn due to blending
           */
          setDrawn: function() {
            return this._needsDraw = this._isBlending || this._wasBlending, this._needsDraw;
          },
          /**
           * Set the internal _isTainted flag for this TiledImage. Lazy loaded - not
           * checked each time a Tile is loaded, but can be set if a consumer of the
           * tiles (e.g. a Drawer) discovers a Tile to have tainted data so that further
           * checks are not needed and alternative rendering strategies can be used.
           * @private
           */
          setTainted(t) {
            this._isTainted = t;
          },
          /**
           * @private
           * @returns {Boolean} whether the TiledImage has been marked as tainted
           */
          isTainted() {
            return this._isTainted;
          },
          /**
           * Destroy the TiledImage (unload current loaded tiles).
           */
          destroy: function() {
            this.reset(), this.source.destroy && this.source.destroy(this.viewer);
          },
          /**
           * Get this TiledImage's bounds in viewport coordinates.
           * @param {Boolean} [current=false] - Pass true for the current location;
           * false for target location.
           * @returns {OpenSeadragon.Rect} This TiledImage's bounds in viewport coordinates.
           */
          getBounds: function(t) {
            return this.getBoundsNoRotate(t).rotate(this.getRotation(t), this._getRotationPoint(t));
          },
          /**
           * Get this TiledImage's bounds in viewport coordinates without taking
           * rotation into account.
           * @param {Boolean} [current=false] - Pass true for the current location;
           * false for target location.
           * @returns {OpenSeadragon.Rect} This TiledImage's bounds in viewport coordinates.
           */
          getBoundsNoRotate: function(t) {
            return t ? new e.Rect(
              this._xSpring.current.value,
              this._ySpring.current.value,
              this._worldWidthCurrent,
              this._worldHeightCurrent
            ) : new e.Rect(
              this._xSpring.target.value,
              this._ySpring.target.value,
              this._worldWidthTarget,
              this._worldHeightTarget
            );
          },
          // deprecated
          getWorldBounds: function() {
            return e.console.error("[TiledImage.getWorldBounds] is deprecated; use TiledImage.getBounds instead"), this.getBounds();
          },
          /**
           * Get the bounds of the displayed part of the tiled image.
           * @param {Boolean} [current=false] Pass true for the current location,
           * false for the target location.
           * @returns {$.Rect} The clipped bounds in viewport coordinates.
           */
          getClippedBounds: function(t) {
            var i = this.getBoundsNoRotate(t);
            if (this._clip) {
              var r = t ? this._worldWidthCurrent : this._worldWidthTarget, o = r / this.source.dimensions.x, a = this._clip.times(o);
              i = new e.Rect(
                i.x + a.x,
                i.y + a.y,
                a.width,
                a.height
              );
            }
            return i.rotate(this.getRotation(t), this._getRotationPoint(t));
          },
          /**
           * @function
           * @param {Number} level
           * @param {Number} x
           * @param {Number} y
           * @returns {OpenSeadragon.Rect} Where this tile fits (in normalized coordinates).
           */
          getTileBounds: function(t, i, r) {
            var o = this.source.getNumTiles(t), a = (o.x + i % o.x) % o.x, c = (o.y + r % o.y) % o.y, u = this.source.getTileBounds(t, a, c);
            return this.getFlip() && (u.x = Math.max(0, 1 - u.x - u.width)), u.x += (i - a) / o.x, u.y += this._worldHeightCurrent / this._worldWidthCurrent * ((r - c) / o.y), u;
          },
          /**
           * @returns {OpenSeadragon.Point} This TiledImage's content size, in original pixels.
           */
          getContentSize: function() {
            return new e.Point(this.source.dimensions.x, this.source.dimensions.y);
          },
          /**
           * @returns {OpenSeadragon.Point} The TiledImage's content size, in window coordinates.
           */
          getSizeInWindowCoordinates: function() {
            var t = this.imageToWindowCoordinates(new e.Point(0, 0)), i = this.imageToWindowCoordinates(this.getContentSize());
            return new e.Point(i.x - t.x, i.y - t.y);
          },
          // private
          _viewportToImageDelta: function(t, i, r) {
            var o = r ? this._scaleSpring.current.value : this._scaleSpring.target.value;
            return new e.Point(
              t * (this.source.dimensions.x / o),
              i * (this.source.dimensions.y * this.contentAspectX / o)
            );
          },
          /**
           * Translates from OpenSeadragon viewer coordinate system to image coordinate system.
           * This method can be called either by passing X,Y coordinates or an {@link OpenSeadragon.Point}.
           * @param {Number|OpenSeadragon.Point} viewerX - The X coordinate or point in viewport coordinate system.
           * @param {Number} [viewerY] - The Y coordinate in viewport coordinate system.
           * @param {Boolean} [current=false] - Pass true to use the current location; false for target location.
           * @returns {OpenSeadragon.Point} A point representing the coordinates in the image.
           */
          viewportToImageCoordinates: function(t, i, r) {
            var o;
            return t instanceof e.Point ? (r = i, o = t) : o = new e.Point(t, i), o = o.rotate(-this.getRotation(r), this._getRotationPoint(r)), r ? this._viewportToImageDelta(
              o.x - this._xSpring.current.value,
              o.y - this._ySpring.current.value
            ) : this._viewportToImageDelta(
              o.x - this._xSpring.target.value,
              o.y - this._ySpring.target.value
            );
          },
          // private
          _imageToViewportDelta: function(t, i, r) {
            var o = r ? this._scaleSpring.current.value : this._scaleSpring.target.value;
            return new e.Point(
              t / this.source.dimensions.x * o,
              i / this.source.dimensions.y / this.contentAspectX * o
            );
          },
          /**
           * Translates from image coordinate system to OpenSeadragon viewer coordinate system
           * This method can be called either by passing X,Y coordinates or an {@link OpenSeadragon.Point}.
           * @param {Number|OpenSeadragon.Point} imageX - The X coordinate or point in image coordinate system.
           * @param {Number} [imageY] - The Y coordinate in image coordinate system.
           * @param {Boolean} [current=false] - Pass true to use the current location; false for target location.
           * @returns {OpenSeadragon.Point} A point representing the coordinates in the viewport.
           */
          imageToViewportCoordinates: function(t, i, r) {
            t instanceof e.Point && (r = i, i = t.y, t = t.x);
            var o = this._imageToViewportDelta(t, i, r);
            return r ? (o.x += this._xSpring.current.value, o.y += this._ySpring.current.value) : (o.x += this._xSpring.target.value, o.y += this._ySpring.target.value), o.rotate(this.getRotation(r), this._getRotationPoint(r));
          },
          /**
           * Translates from a rectangle which describes a portion of the image in
           * pixel coordinates to OpenSeadragon viewport rectangle coordinates.
           * This method can be called either by passing X,Y,width,height or an {@link OpenSeadragon.Rect}.
           * @param {Number|OpenSeadragon.Rect} imageX - The left coordinate or rectangle in image coordinate system.
           * @param {Number} [imageY] - The top coordinate in image coordinate system.
           * @param {Number} [pixelWidth] - The width in pixel of the rectangle.
           * @param {Number} [pixelHeight] - The height in pixel of the rectangle.
           * @param {Boolean} [current=false] - Pass true to use the current location; false for target location.
           * @returns {OpenSeadragon.Rect} A rect representing the coordinates in the viewport.
           */
          imageToViewportRectangle: function(t, i, r, o, a) {
            var c = t;
            c instanceof e.Rect ? a = i : c = new e.Rect(t, i, r, o);
            var u = this.imageToViewportCoordinates(c.getTopLeft(), a), h = this._imageToViewportDelta(c.width, c.height, a);
            return new e.Rect(
              u.x,
              u.y,
              h.x,
              h.y,
              c.degrees + this.getRotation(a)
            );
          },
          /**
           * Translates from a rectangle which describes a portion of
           * the viewport in point coordinates to image rectangle coordinates.
           * This method can be called either by passing X,Y,width,height or an {@link OpenSeadragon.Rect}.
           * @param {Number|OpenSeadragon.Rect} viewerX - The left coordinate or rectangle in viewport coordinate system.
           * @param {Number} [viewerY] - The top coordinate in viewport coordinate system.
           * @param {Number} [pointWidth] - The width in viewport coordinate system.
           * @param {Number} [pointHeight] - The height in viewport coordinate system.
           * @param {Boolean} [current=false] - Pass true to use the current location; false for target location.
           * @returns {OpenSeadragon.Rect} A rect representing the coordinates in the image.
           */
          viewportToImageRectangle: function(t, i, r, o, a) {
            var c = t;
            t instanceof e.Rect ? a = i : c = new e.Rect(t, i, r, o);
            var u = this.viewportToImageCoordinates(c.getTopLeft(), a), h = this._viewportToImageDelta(c.width, c.height, a);
            return new e.Rect(
              u.x,
              u.y,
              h.x,
              h.y,
              c.degrees - this.getRotation(a)
            );
          },
          /**
           * Convert pixel coordinates relative to the viewer element to image
           * coordinates.
           * @param {OpenSeadragon.Point} pixel
           * @returns {OpenSeadragon.Point}
           */
          viewerElementToImageCoordinates: function(t) {
            var i = this.viewport.pointFromPixel(t, !0);
            return this.viewportToImageCoordinates(i);
          },
          /**
           * Convert pixel coordinates relative to the image to
           * viewer element coordinates.
           * @param {OpenSeadragon.Point} pixel
           * @returns {OpenSeadragon.Point}
           */
          imageToViewerElementCoordinates: function(t) {
            var i = this.imageToViewportCoordinates(t);
            return this.viewport.pixelFromPoint(i, !0);
          },
          /**
           * Convert pixel coordinates relative to the window to image coordinates.
           * @param {OpenSeadragon.Point} pixel
           * @returns {OpenSeadragon.Point}
           */
          windowToImageCoordinates: function(t) {
            var i = t.minus(
              n.getElementPosition(this.viewer.element)
            );
            return this.viewerElementToImageCoordinates(i);
          },
          /**
           * Convert image coordinates to pixel coordinates relative to the window.
           * @param {OpenSeadragon.Point} pixel
           * @returns {OpenSeadragon.Point}
           */
          imageToWindowCoordinates: function(t) {
            var i = this.imageToViewerElementCoordinates(t);
            return i.plus(
              n.getElementPosition(this.viewer.element)
            );
          },
          // private
          // Convert rectangle in viewport coordinates to this tiled image point
          // coordinates (x in [0, 1] and y in [0, aspectRatio])
          _viewportToTiledImageRectangle: function(t) {
            var i = this._scaleSpring.current.value;
            return t = t.rotate(-this.getRotation(!0), this._getRotationPoint(!0)), new e.Rect(
              (t.x - this._xSpring.current.value) / i,
              (t.y - this._ySpring.current.value) / i,
              t.width / i,
              t.height / i,
              t.degrees
            );
          },
          /**
           * Convert a viewport zoom to an image zoom.
           * Image zoom: ratio of the original image size to displayed image size.
           * 1 means original image size, 0.5 half size...
           * Viewport zoom: ratio of the displayed image's width to viewport's width.
           * 1 means identical width, 2 means image's width is twice the viewport's width...
           * @function
           * @param {Number} viewportZoom The viewport zoom
           * @returns {Number} imageZoom The image zoom
           */
          viewportToImageZoom: function(t) {
            var i = this._scaleSpring.current.value * this.viewport._containerInnerSize.x / this.source.dimensions.x;
            return i * t;
          },
          /**
           * Convert an image zoom to a viewport zoom.
           * Image zoom: ratio of the original image size to displayed image size.
           * 1 means original image size, 0.5 half size...
           * Viewport zoom: ratio of the displayed image's width to viewport's width.
           * 1 means identical width, 2 means image's width is twice the viewport's width...
           * Note: not accurate with multi-image.
           * @function
           * @param {Number} imageZoom The image zoom
           * @returns {Number} viewportZoom The viewport zoom
           */
          imageToViewportZoom: function(t) {
            var i = this._scaleSpring.current.value * this.viewport._containerInnerSize.x / this.source.dimensions.x;
            return t / i;
          },
          /**
           * Sets the TiledImage's position in the world.
           * @param {OpenSeadragon.Point} position - The new position, in viewport coordinates.
           * @param {Boolean} [immediately=false] - Whether to animate to the new position or snap immediately.
           * @fires OpenSeadragon.TiledImage.event:bounds-change
           */
          setPosition: function(t, i) {
            var r = this._xSpring.target.value === t.x && this._ySpring.target.value === t.y;
            if (i) {
              if (r && this._xSpring.current.value === t.x && this._ySpring.current.value === t.y)
                return;
              this._xSpring.resetTo(t.x), this._ySpring.resetTo(t.y), this._needsDraw = !0, this._needsUpdate = !0;
            } else {
              if (r)
                return;
              this._xSpring.springTo(t.x), this._ySpring.springTo(t.y), this._needsDraw = !0, this._needsUpdate = !0;
            }
            r || this._raiseBoundsChange();
          },
          /**
           * Sets the TiledImage's width in the world, adjusting the height to match based on aspect ratio.
           * @param {Number} width - The new width, in viewport coordinates.
           * @param {Boolean} [immediately=false] - Whether to animate to the new size or snap immediately.
           * @fires OpenSeadragon.TiledImage.event:bounds-change
           */
          setWidth: function(t, i) {
            this._setScale(t, i);
          },
          /**
           * Sets the TiledImage's height in the world, adjusting the width to match based on aspect ratio.
           * @param {Number} height - The new height, in viewport coordinates.
           * @param {Boolean} [immediately=false] - Whether to animate to the new size or snap immediately.
           * @fires OpenSeadragon.TiledImage.event:bounds-change
           */
          setHeight: function(t, i) {
            this._setScale(t / this.normHeight, i);
          },
          /**
           * Sets an array of polygons to crop the TiledImage during draw tiles.
           * The render function will use the default non-zero winding rule.
           * @param {OpenSeadragon.Point[][]} polygons - represented in an array of point object in image coordinates.
           * Example format: [
           *  [{x: 197, y:172}, {x: 226, y:172}, {x: 226, y:198}, {x: 197, y:198}], // First polygon
           *  [{x: 328, y:200}, {x: 330, y:199}, {x: 332, y:201}, {x: 329, y:202}]  // Second polygon
           *  [{x: 321, y:201}, {x: 356, y:205}, {x: 341, y:250}] // Third polygon
           * ]
           */
          setCroppingPolygons: function(t) {
            var i = function(o) {
              return o instanceof e.Point || typeof o.x == "number" && typeof o.y == "number";
            }, r = function(o) {
              return o.map(function(a) {
                try {
                  if (i(a))
                    return { x: a.x, y: a.y };
                  throw new Error();
                } catch {
                  throw new Error("A Provided cropping polygon point is not supported");
                }
              });
            };
            try {
              if (!e.isArray(t))
                throw new Error("Provided cropping polygon is not an array");
              this._croppingPolygons = t.map(function(o) {
                return r(o);
              }), this._needsDraw = !0;
            } catch (o) {
              e.console.error("[TiledImage.setCroppingPolygons] Cropping polygon format not supported"), e.console.error(o), this.resetCroppingPolygons();
            }
          },
          /**
           * Resets the cropping polygons, thus next render will remove all cropping
           * polygon effects.
           */
          resetCroppingPolygons: function() {
            this._croppingPolygons = null, this._needsDraw = !0;
          },
          /**
           * Positions and scales the TiledImage to fit in the specified bounds.
           * Note: this method fires OpenSeadragon.TiledImage.event:bounds-change
           * twice
           * @param {OpenSeadragon.Rect} bounds The bounds to fit the image into.
           * @param {OpenSeadragon.Placement} [anchor=OpenSeadragon.Placement.CENTER]
           * How to anchor the image in the bounds.
           * @param {Boolean} [immediately=false] Whether to animate to the new size
           * or snap immediately.
           * @fires OpenSeadragon.TiledImage.event:bounds-change
           */
          fitBounds: function(t, i, r) {
            i = i || e.Placement.CENTER;
            var o = e.Placement.properties[i], a = this.contentAspectX, c = 0, u = 0, h = 1, f = 1;
            if (this._clip && (a = this._clip.getAspectRatio(), h = this._clip.width / this.source.dimensions.x, f = this._clip.height / this.source.dimensions.y, t.getAspectRatio() > a ? (c = this._clip.x / this._clip.height * t.height, u = this._clip.y / this._clip.height * t.height) : (c = this._clip.x / this._clip.width * t.width, u = this._clip.y / this._clip.width * t.width)), t.getAspectRatio() > a) {
              var g = t.height / f, x = 0;
              o.isHorizontallyCentered ? x = (t.width - t.height * a) / 2 : o.isRight && (x = t.width - t.height * a), this.setPosition(
                new e.Point(t.x - c + x, t.y - u),
                r
              ), this.setHeight(g, r);
            } else {
              var C = t.width / h, E = 0;
              o.isVerticallyCentered ? E = (t.height - t.width / a) / 2 : o.isBottom && (E = t.height - t.width / a), this.setPosition(
                new e.Point(t.x - c, t.y - u + E),
                r
              ), this.setWidth(C, r);
            }
          },
          /**
           * @returns {OpenSeadragon.Rect|null} The TiledImage's current clip rectangle,
           * in image pixels, or null if none.
           */
          getClip: function() {
            return this._clip ? this._clip.clone() : null;
          },
          /**
           * @param {OpenSeadragon.Rect|null} newClip - An area, in image pixels, to clip to
           * (portions of the image outside of this area will not be visible). Only works on
           * browsers that support the HTML5 canvas.
           * @fires OpenSeadragon.TiledImage.event:clip-change
           */
          setClip: function(t) {
            e.console.assert(
              !t || t instanceof e.Rect,
              "[TiledImage.setClip] newClip must be an OpenSeadragon.Rect or null"
            ), t instanceof e.Rect ? this._clip = t.clone() : this._clip = null, this._needsUpdate = !0, this._needsDraw = !0, this.raiseEvent("clip-change");
          },
          /**
           * @returns {Boolean} Whether the TiledImage should be flipped before rendering.
           */
          getFlip: function() {
            return this.flipped;
          },
          /**
           * @param {Boolean} flip Whether the TiledImage should be flipped before rendering.
           * @fires OpenSeadragon.TiledImage.event:bounds-change
           */
          setFlip: function(t) {
            this.flipped = t;
          },
          get flipped() {
            return this._flipped;
          },
          set flipped(t) {
            let i = this._flipped !== !!t;
            this._flipped = !!t, i && (this.update(!0), this._needsDraw = !0, this._raiseBoundsChange());
          },
          get wrapHorizontal() {
            return this._wrapHorizontal;
          },
          set wrapHorizontal(t) {
            let i = this._wrapHorizontal !== !!t;
            this._wrapHorizontal = !!t, this._initialized && i && (this.update(!0), this._needsDraw = !0);
          },
          get wrapVertical() {
            return this._wrapVertical;
          },
          set wrapVertical(t) {
            let i = this._wrapVertical !== !!t;
            this._wrapVertical = !!t, this._initialized && i && (this.update(!0), this._needsDraw = !0);
          },
          get debugMode() {
            return this._debugMode;
          },
          set debugMode(t) {
            this._debugMode = !!t, this._needsDraw = !0;
          },
          /**
           * @returns {Number} The TiledImage's current opacity.
           */
          getOpacity: function() {
            return this.opacity;
          },
          /**
           * @param {Number} opacity Opacity the tiled image should be drawn at.
           * @fires OpenSeadragon.TiledImage.event:opacity-change
           */
          setOpacity: function(t) {
            this.opacity = t;
          },
          get opacity() {
            return this._opacity;
          },
          set opacity(t) {
            t !== this.opacity && (this._opacity = t, this._needsDraw = !0, this.raiseEvent("opacity-change", {
              opacity: this.opacity
            }));
          },
          /**
           * @returns {Boolean} whether the tiledImage can load its tiles even when it has zero opacity.
           */
          getPreload: function() {
            return this._preload;
          },
          /**
           * Set true to load even when hidden. Set false to block loading when hidden.
           */
          setPreload: function(t) {
            this._preload = !!t, this._needsDraw = !0;
          },
          /**
           * Get the rotation of this tiled image in degrees.
           * @param {Boolean} [current=false] True for current rotation, false for target.
           * @returns {Number} the rotation of this tiled image in degrees.
           */
          getRotation: function(t) {
            return t ? this._degreesSpring.current.value : this._degreesSpring.target.value;
          },
          /**
           * Set the current rotation of this tiled image in degrees.
           * @param {Number} degrees the rotation in degrees.
           * @param {Boolean} [immediately=false] Whether to animate to the new angle
           * or rotate immediately.
           * @fires OpenSeadragon.TiledImage.event:bounds-change
           */
          setRotation: function(t, i) {
            this._degreesSpring.target.value === t && this._degreesSpring.isAtTargetValue() || (i ? this._degreesSpring.resetTo(t) : this._degreesSpring.springTo(t), this._needsDraw = !0, this._needsUpdate = !0, this._raiseBoundsChange());
          },
          /**
           * Get the region of this tiled image that falls within the viewport.
           * @returns {OpenSeadragon.Rect} the region of this tiled image that falls within the viewport.
           * Returns false for images with opacity==0 unless preload==true
           */
          getDrawArea: function() {
            if (this._opacity === 0 && !this._preload)
              return !1;
            var t = this._viewportToTiledImageRectangle(
              this.viewport.getBoundsWithMargins(!0)
            );
            if (!this.wrapHorizontal && !this.wrapVertical) {
              var i = this._viewportToTiledImageRectangle(
                this.getClippedBounds(!0)
              );
              t = t.intersection(i);
            }
            return t;
          },
          /**
           *
           * @returns {Array} Array of Tiles that make up the current view
           */
          getTilesToDraw: function() {
            let t = this._tilesToDraw.flat();
            return this._updateTilesInViewport(t), t = this._tilesToDraw.flat(), t.forEach((i) => {
              i.tile.beingDrawn = !0;
            }), this._lastDrawn = t, t;
          },
          /**
           * Get the point around which this tiled image is rotated
           * @private
           * @param {Boolean} current True for current rotation point, false for target.
           * @returns {OpenSeadragon.Point}
           */
          _getRotationPoint: function(t) {
            return this.getBoundsNoRotate(t).getCenter();
          },
          get compositeOperation() {
            return this._compositeOperation;
          },
          set compositeOperation(t) {
            t !== this._compositeOperation && (this._compositeOperation = t, this._needsDraw = !0, this.raiseEvent("composite-operation-change", {
              compositeOperation: this._compositeOperation
            }));
          },
          /**
           * @returns {String} The TiledImage's current compositeOperation.
           */
          getCompositeOperation: function() {
            return this._compositeOperation;
          },
          /**
           * @param {String} compositeOperation the tiled image should be drawn with this globalCompositeOperation.
           * @fires OpenSeadragon.TiledImage.event:composite-operation-change
           */
          setCompositeOperation: function(t) {
            this.compositeOperation = t;
          },
          /**
           * Update headers to include when making AJAX requests.
           *
           * Unless `propagate` is set to false (which is likely only useful in rare circumstances),
           * the updated headers are propagated to all tiles and queued image loader jobs.
           *
           * Note that the rules for merging headers still apply, i.e. headers returned by
           * {@link OpenSeadragon.TileSource#getTileAjaxHeaders} take precedence over
           * the headers here in the tiled image (`TiledImage.ajaxHeaders`).
           *
           * @function
           * @param {Object} ajaxHeaders Updated AJAX headers, which will be merged over any headers specified in {@link OpenSeadragon.Options}.
           * @param {Boolean} [propagate=true] Whether to propagate updated headers to existing tiles and queued image loader jobs.
           */
          setAjaxHeaders: function(t, i) {
            if (t === null && (t = {}), !e.isPlainObject(t)) {
              console.error("[TiledImage.setAjaxHeaders] Ignoring invalid headers, must be a plain object");
              return;
            }
            this._ownAjaxHeaders = t, this._updateAjaxHeaders(i);
          },
          /**
           * Update headers to include when making AJAX requests.
           *
           * This function has the same effect as calling {@link OpenSeadragon.TiledImage#setAjaxHeaders},
           * except that the headers for this tiled image do not change. This is especially useful
           * for propagating updated headers from {@link OpenSeadragon.TileSource#getTileAjaxHeaders}
           * to existing tiles.
           *
           * @private
           * @function
           * @param {Boolean} [propagate=true] Whether to propagate updated headers to existing tiles and queued image loader jobs.
           */
          _updateAjaxHeaders: function(t) {
            if (t === void 0 && (t = !0), e.isPlainObject(this.viewer.ajaxHeaders) ? this.ajaxHeaders = e.extend({}, this.viewer.ajaxHeaders, this._ownAjaxHeaders) : this.ajaxHeaders = this._ownAjaxHeaders, t) {
              var i, r, o, a;
              for (var c in this.tilesMatrix) {
                i = this.source.getNumTiles(c);
                for (var u in this.tilesMatrix[c]) {
                  r = (i.x + u % i.x) % i.x;
                  for (var h in this.tilesMatrix[c][u])
                    if (o = (i.y + h % i.y) % i.y, a = this.tilesMatrix[c][u][h], a.loadWithAjax = this.loadTilesWithAjax, a.loadWithAjax) {
                      var f = this.source.getTileAjaxHeaders(c, r, o);
                      a.ajaxHeaders = e.extend({}, this.ajaxHeaders, f);
                    } else
                      a.ajaxHeaders = null;
                }
              }
              for (var g = 0; g < this._imageLoader.jobQueue.length; g++) {
                var x = this._imageLoader.jobQueue[g];
                x.loadWithAjax = x.tile.loadWithAjax, x.ajaxHeaders = x.tile.loadWithAjax ? x.tile.ajaxHeaders : null;
              }
            }
          },
          // private
          _setScale: function(t, i) {
            var r = this._scaleSpring.target.value === t;
            if (i) {
              if (r && this._scaleSpring.current.value === t)
                return;
              this._scaleSpring.resetTo(t), this._updateForScale(), this._needsDraw = !0, this._needsUpdate = !0;
            } else {
              if (r)
                return;
              this._scaleSpring.springTo(t), this._updateForScale(), this._needsDraw = !0, this._needsUpdate = !0;
            }
            r || this._raiseBoundsChange();
          },
          // private
          _updateForScale: function() {
            this._worldWidthTarget = this._scaleSpring.target.value, this._worldHeightTarget = this.normHeight * this._scaleSpring.target.value, this._worldWidthCurrent = this._scaleSpring.current.value, this._worldHeightCurrent = this.normHeight * this._scaleSpring.current.value;
          },
          // private
          _raiseBoundsChange: function() {
            this.raiseEvent("bounds-change");
          },
          // private
          _isBottomItem: function() {
            return this.viewer.world.getItemAt(0) === this;
          },
          // private
          _getLevelsInterval: function() {
            var t = Math.max(
              this.source.minLevel,
              Math.floor(Math.log(this.minZoomImageRatio) / Math.log(2))
            ), i = this.viewport.deltaPixelsFromPointsNoRotate(
              this.source.getPixelRatio(0),
              !0
            ).x * this._scaleSpring.current.value, r = Math.min(
              Math.abs(this.source.maxLevel),
              Math.abs(Math.floor(
                Math.log(i / this.minPixelRatio) / Math.log(2)
              ))
            );
            return r = Math.max(r, this.source.minLevel || 0), t = Math.min(t, r), {
              lowestLevel: t,
              highestLevel: r
            };
          },
          // returns boolean flag of whether the image should be marked as fully loaded
          _updateLevelsForViewport: function() {
            var t = this._getLevelsInterval(), i = t.lowestLevel, r = t.highestLevel, o = [], a = this.getDrawArea(), c = e.now();
            if (this._lastDrawn.forEach((re) => {
              re.tile.beingDrawn = !1;
            }), this._tilesToDraw = [], this._tilesLoading = 0, this.loadingCoverage = {}, !a)
              return this._needsDraw = !1, this._fullyLoaded;
            var u = new Array(r - i + 1);
            for (let re = 0, ue = r; ue >= i; ue--, re++)
              u[re] = ue;
            for (let re = r + 1; re <= this.source.maxLevel; re++) {
              var h = this.tilesMatrix[re] && this.tilesMatrix[re][0] && this.tilesMatrix[re][0][0];
              if (h && h.isBottomMost && h.isRightMost && h.loaded) {
                u.push(re);
                break;
              }
            }
            let f = !1;
            for (let re = 0; re < u.length; re++) {
              let ue = u[re];
              var g = this.viewport.deltaPixelsFromPointsNoRotate(
                this.source.getPixelRatio(ue),
                !0
              ).x * this._scaleSpring.current.value;
              if (re === u.length - 1 || g >= this.minPixelRatio)
                f = !0;
              else if (!f)
                continue;
              var x = this.viewport.deltaPixelsFromPointsNoRotate(
                this.source.getPixelRatio(ue),
                !1
              ).x * this._scaleSpring.current.value, C = this.viewport.deltaPixelsFromPointsNoRotate(
                this.source.getPixelRatio(
                  Math.max(
                    this.source.getClosestLevel(),
                    0
                  )
                ),
                !1
              ).x * this._scaleSpring.current.value, E = this.immediateRender ? 1 : C, R = Math.min(1, (g - 0.5) / 0.5), D = E / Math.abs(
                E - x
              ), U = this._updateLevel(
                ue,
                R,
                D,
                a,
                c,
                o
              );
              o = U.bestTiles;
              var Z = U.updatedTiles.filter((me) => me.loaded), ce = /* @__PURE__ */ (function(me, Te, Re) {
                return function(He) {
                  return {
                    tile: He,
                    level: me,
                    levelOpacity: Te,
                    currentTime: Re
                  };
                };
              })(ue, R, c);
              if (this._tilesToDraw[ue] = Z.map(ce), this._providesCoverage(this.coverage, ue))
                break;
            }
            return o && o.length > 0 ? (o.forEach(function(re) {
              re && !re.context2D && this._loadTile(re, c);
            }, this), this._needsDraw = !0, !1) : this._tilesLoading === 0;
          },
          /**
           * Update all tiles that contribute to the current view
           * @private
           *
           */
          _updateTilesInViewport: function(t) {
            let i = e.now(), r = this;
            this._tilesLoading = 0, this._wasBlending = this._isBlending, this._isBlending = !1, this.loadingCoverage = {};
            let o = t.length ? t[0].level : 0;
            if (!this.getDrawArea())
              return;
            function c(h) {
              let f = h.tile;
              if (f && f.loaded) {
                let g = r._blendTile(
                  f,
                  f.x,
                  f.y,
                  h.level,
                  h.levelOpacity,
                  i,
                  o
                );
                r._isBlending = r._isBlending || g, r._needsDraw = r._needsDraw || g || r._wasBlending;
              }
            }
            let u = 0;
            for (let h = 0; h < t.length; h++) {
              let f = t[h];
              c(f), this._providesCoverage(this.coverage, f.level) && (u = Math.max(u, f.level));
            }
            if (u > 0)
              for (let h in this._tilesToDraw)
                h < u && delete this._tilesToDraw[h];
          },
          /**
           * Updates the opacity of a tile according to the time it has been on screen
           * to perform a fade-in.
           * Updates coverage once a tile is fully opaque.
           * Returns whether the fade-in has completed.
           * @private
           *
           * @param {OpenSeadragon.Tile} tile
           * @param {Number} x
           * @param {Number} y
           * @param {Number} level
           * @param {Number} levelOpacity
           * @param {Number} currentTime
           * @param {Boolean} lowestLevel
           * @returns {Boolean} true if blending did not yet finish
           */
          _blendTile: function(t, i, r, o, a, c, u) {
            let h = 1e3 * this.blendTime, f, g;
            return t.blendStart || (t.blendStart = c), f = c - t.blendStart, g = h ? Math.min(1, f / h) : 1, o === u && (g = 1, f = h), this.alwaysBlend && (g *= a), t.opacity = g, g === 1 && (this._setCoverage(this.coverage, o, i, r, !0), this._hasOpaqueTile = !0), f < h;
          },
          /**
           * Updates all tiles at a given resolution level.
           * @private
           * @param {Number} level
           * @param {Number} levelOpacity
           * @param {Number} levelVisibility
           * @param {OpenSeadragon.Rect} drawArea
           * @param {Number} currentTime
           * @param {OpenSeadragon.Tile[]} best Array of the current best tiles
           * @returns {Object} Dictionary {bestTiles: OpenSeadragon.Tile - the current "best" tiles to draw, updatedTiles: OpenSeadragon.Tile) - the updated tiles}.
           */
          _updateLevel: function(t, i, r, o, a, c) {
            var u = o.getBoundingBox().getTopLeft(), h = o.getBoundingBox().getBottomRight();
            this.viewer && this.viewer.raiseEvent("update-level", {
              tiledImage: this,
              havedrawn: !0,
              // deprecated, kept for backwards compatibility
              level: t,
              opacity: i,
              visibility: r,
              drawArea: o,
              topleft: u,
              bottomright: h,
              currenttime: a,
              best: c
            }), this._resetCoverage(this.coverage, t), this._resetCoverage(this.loadingCoverage, t);
            var f = this._getCornerTiles(t, u, h), g = f.topLeft, x = f.bottomRight, C = this.source.getNumTiles(t), E = this.viewport.pixelFromPoint(this.viewport.getCenter());
            this.getFlip() && (x.x += 1, this.wrapHorizontal || (x.x = Math.min(x.x, C.x - 1)));
            for (var R = Math.max(0, (x.x - g.x) * (x.y - g.y)), D = new Array(R), U = 0, Z = g.x; Z <= x.x; Z++)
              for (var ce = g.y; ce <= x.y; ce++) {
                var re;
                if (this.getFlip()) {
                  var ue = (C.x + Z % C.x) % C.x;
                  re = Z + C.x - ue - ue - 1;
                } else
                  re = Z;
                if (o.intersection(this.getTileBounds(t, re, ce)) !== null) {
                  var me = this._updateTile(
                    re,
                    ce,
                    t,
                    r,
                    E,
                    C,
                    a,
                    c
                  );
                  c = me.bestTiles, D[U] = me.tile, U += 1;
                }
              }
            return {
              bestTiles: c,
              updatedTiles: D
            };
          },
          /**
           * @private
           * @param {OpenSeadragon.Tile} tile
           * @param {Boolean} overlap
           * @param {OpenSeadragon.Viewport} viewport
           * @param {OpenSeadragon.Point} viewportCenter
           * @param {Number} levelVisibility
           */
          _positionTile: function(t, i, r, o, a) {
            var c = t.bounds.getTopLeft();
            c.x *= this._scaleSpring.current.value, c.y *= this._scaleSpring.current.value, c.x += this._xSpring.current.value, c.y += this._ySpring.current.value;
            var u = t.bounds.getSize();
            u.x *= this._scaleSpring.current.value, u.y *= this._scaleSpring.current.value, t.positionedBounds.x = c.x, t.positionedBounds.y = c.y, t.positionedBounds.width = u.x, t.positionedBounds.height = u.y;
            var h = r.pixelFromPointNoRotate(c, !0), f = r.pixelFromPointNoRotate(c, !1), g = r.deltaPixelsFromPointsNoRotate(u, !0), x = r.deltaPixelsFromPointsNoRotate(u, !1), C = f.plus(x.divide(2)), E = o.squaredDistanceTo(C);
            this.viewer.drawer.minimumOverlapRequired(this) && (i || (g = g.plus(new e.Point(1, 1))), t.isRightMost && this.wrapHorizontal && (g.x += 0.75), t.isBottomMost && this.wrapVertical && (g.y += 0.75)), t.position = h, t.size = g, t.squaredDistance = E, t.visibility = a;
          },
          /**
           * Update a single tile at a particular resolution level.
           * @private
           * @param {Number} x
           * @param {Number} y
           * @param {Number} level
           * @param {Number} levelVisibility
           * @param {OpenSeadragon.Point} viewportCenter
           * @param {Number} numberOfTiles
           * @param {Number} currentTime
           * @param {OpenSeadragon.Tile} best - The current "best" tile to draw.
           * @returns {Object} Dictionary {bestTiles: OpenSeadragon.Tile[] - the current best tiles, tile: OpenSeadragon.Tile the current tile}
           */
          _updateTile: function(t, i, r, o, a, c, u, h) {
            var f = this._getTile(
              t,
              i,
              r,
              u,
              c
            );
            this.viewer && this.viewer.raiseEvent("update-tile", {
              tiledImage: this,
              tile: f
            }), this._setCoverage(this.coverage, r, t, i, !1);
            var g = f.loaded || f.loading || this._isCovered(this.loadingCoverage, r, t, i);
            if (this._setCoverage(this.loadingCoverage, r, t, i, g), !f.exists)
              return {
                bestTiles: h,
                tile: f
              };
            if (f.loaded && f.opacity === 1 && this._setCoverage(this.coverage, r, t, i, !0), this._positionTile(
              f,
              this.source.tileOverlap,
              this.viewport,
              a,
              o
            ), !f.loaded)
              if (f.context2D)
                this._setTileLoaded(f);
              else {
                var x = this._tileCache.getImageRecord(f.cacheKey);
                x && this._setTileLoaded(f, x.getData());
              }
            return f.loading ? this._tilesLoading++ : g || (h = this._compareTiles(h, f, this.maxTilesPerFrame)), {
              bestTiles: h,
              tile: f
            };
          },
          // private
          _getCornerTiles: function(t, i, r) {
            var o, a;
            this.wrapHorizontal ? (o = e.positiveModulo(i.x, 1), a = e.positiveModulo(r.x, 1)) : (o = Math.max(0, i.x), a = Math.min(1, r.x));
            var c, u, h = 1 / this.source.aspectRatio;
            this.wrapVertical ? (c = e.positiveModulo(i.y, h), u = e.positiveModulo(r.y, h)) : (c = Math.max(0, i.y), u = Math.min(h, r.y));
            var f = this.source.getTileAtPoint(t, new e.Point(o, c)), g = this.source.getTileAtPoint(t, new e.Point(a, u)), x = this.source.getNumTiles(t);
            return this.wrapHorizontal && (f.x += x.x * Math.floor(i.x), g.x += x.x * Math.floor(r.x)), this.wrapVertical && (f.y += x.y * Math.floor(i.y / h), g.y += x.y * Math.floor(r.y / h)), {
              topLeft: f,
              bottomRight: g
            };
          },
          /**
           * Obtains a tile at the given location.
           * @private
           * @param {Number} x
           * @param {Number} y
           * @param {Number} level
           * @param {Number} time
           * @param {Number} numTiles
           * @returns {OpenSeadragon.Tile}
           */
          _getTile: function(t, i, r, o, a) {
            var c, u, h, f, g, x, C, E, R, D, U = this.tilesMatrix, Z = this.source;
            return U[r] || (U[r] = {}), U[r][t] || (U[r][t] = {}), (!U[r][t][i] || !U[r][t][i].flipped != !this.flipped) && (c = (a.x + t % a.x) % a.x, u = (a.y + i % a.y) % a.y, h = this.getTileBounds(r, t, i), f = Z.getTileBounds(r, c, u, !0), g = Z.tileExists(r, c, u), x = Z.getTileUrl(r, c, u), C = Z.getTilePostData(r, c, u), this.loadTilesWithAjax ? (E = Z.getTileAjaxHeaders(r, c, u), e.isPlainObject(this.ajaxHeaders) && (E = e.extend({}, this.ajaxHeaders, E))) : E = null, R = Z.getContext2D ? Z.getContext2D(r, c, u) : void 0, D = new e.Tile(
              r,
              t,
              i,
              h,
              g,
              x,
              R,
              this.loadTilesWithAjax,
              E,
              f,
              C,
              Z.getTileHashKey(r, c, u, x, E, C)
            ), this.getFlip() ? c === 0 && (D.isRightMost = !0) : c === a.x - 1 && (D.isRightMost = !0), u === a.y - 1 && (D.isBottomMost = !0), D.flipped = this.flipped, U[r][t][i] = D), D = U[r][t][i], D.lastTouchTime = o, D;
          },
          /**
           * Dispatch a job to the ImageLoader to load the Image for a Tile.
           * @private
           * @param {OpenSeadragon.Tile} tile
           * @param {Number} time
           */
          _loadTile: function(t, i) {
            var r = this;
            t.loading = !0, this._imageLoader.addJob({
              src: t.getUrl(),
              tile: t,
              source: this.source,
              postData: t.postData,
              loadWithAjax: t.loadWithAjax,
              ajaxHeaders: t.ajaxHeaders,
              crossOriginPolicy: this.crossOriginPolicy,
              ajaxWithCredentials: this.ajaxWithCredentials,
              callback: function(o, a, c) {
                r._onTileLoad(t, i, o, a, c);
              },
              abort: function() {
                t.loading = !1;
              }
            });
          },
          /**
           * Callback fired when a Tile's Image finished downloading.
           * @private
           * @param {OpenSeadragon.Tile} tile
           * @param {Number} time
           * @param {*} data image data
           * @param {String} errorMsg
           * @param {XMLHttpRequest} tileRequest
           */
          _onTileLoad: function(t, i, r, o, a) {
            if (r)
              t.exists = !0;
            else {
              e.console.error("Tile %s failed to load: %s - error: %s", t, t.getUrl(), o), this.viewer.raiseEvent("tile-load-failed", {
                tile: t,
                tiledImage: this,
                time: i,
                message: o,
                tileRequest: a
              }), t.loading = !1, t.exists = !1;
              return;
            }
            if (i < this.lastResetTime) {
              e.console.warn("Ignoring tile %s loaded before reset: %s", t, t.getUrl()), t.loading = !1;
              return;
            }
            var c = this, u = function() {
              var h = c.source, f = h.getClosestLevel();
              c._setTileLoaded(t, r, f, a);
            };
            u();
          },
          /**
           * @private
           * @param {OpenSeadragon.Tile} tile
           * @param {*} data image data, the data sent to ImageJob.prototype.finish(), by default an Image object
           * @param {Number|undefined} cutoff
           * @param {XMLHttpRequest|undefined} tileRequest
           */
          _setTileLoaded: function(t, i, r, o) {
            var a = 0, c = !1, u = this;
            function h() {
              return c && e.console.error("Event 'tile-loaded' argument getCompletionCallback must be called synchronously. Its return value should be called asynchronously."), a++, f;
            }
            function f() {
              a--, a === 0 && (t.loading = !1, t.loaded = !0, t.hasTransparency = u.source.hasTransparency(
                t.context2D,
                t.getUrl(),
                t.ajaxHeaders,
                t.postData
              ), t.context2D || u._tileCache.cacheTile({
                data: i,
                tile: t,
                cutoff: r,
                tiledImage: u
              }), u.viewer.raiseEvent("tile-ready", {
                tile: t,
                tiledImage: u,
                tileRequest: o
              }), u._needsDraw = !0);
            }
            var g = h();
            this.viewer.raiseEvent("tile-loaded", {
              tile: t,
              tiledImage: this,
              tileRequest: o,
              get image() {
                return e.console.error("[tile-loaded] event 'image' has been deprecated. Use 'data' property instead."), i;
              },
              data: i,
              getCompletionCallback: h
            }), c = !0, g();
          },
          /**
           * Determines the 'best tiles' from the given 'last best' tiles and the
           * tile in question.
           * @private
           *
           * @param {OpenSeadragon.Tile[]} previousBest The best tiles so far.
           * @param {OpenSeadragon.Tile} tile The new tile to consider.
           * @param {Number} maxNTiles The max number of best tiles.
           * @returns {OpenSeadragon.Tile[]} The new best tiles.
           */
          _compareTiles: function(t, i, r) {
            return t ? (t.push(i), this._sortTiles(t), t.length > r && t.pop(), t) : [i];
          },
          /**
           * Sorts tiles in an array according to distance and visibility.
           * @private
           *
           * @param {OpenSeadragon.Tile[]} tiles The tiles.
           */
          _sortTiles: function(t) {
            t.sort(function(i, r) {
              return i === null ? 1 : r === null ? -1 : i.visibility === r.visibility ? i.squaredDistance - r.squaredDistance : r.visibility - i.visibility;
            });
          },
          /**
           * Returns true if the given tile provides coverage to lower-level tiles of
           * lower resolution representing the same content. If neither x nor y is
           * given, returns true if the entire visible level provides coverage.
           *
           * Note that out-of-bounds tiles provide coverage in this sense, since
           * there's no content that they would need to cover. Tiles at non-existent
           * levels that are within the image bounds, however, do not.
           * @private
           *
           * @param {Object} coverage - A '3d' dictionary [level][x][y] --> Boolean.
           * @param {Number} level - The resolution level of the tile.
           * @param {Number} x - The X position of the tile.
           * @param {Number} y - The Y position of the tile.
           * @returns {Boolean}
           */
          _providesCoverage: function(t, i, r, o) {
            var a, c, u, h;
            if (!t[i])
              return !1;
            if (r === void 0 || o === void 0) {
              a = t[i];
              for (u in a)
                if (Object.prototype.hasOwnProperty.call(a, u)) {
                  c = a[u];
                  for (h in c)
                    if (Object.prototype.hasOwnProperty.call(c, h) && !c[h])
                      return !1;
                }
              return !0;
            }
            return t[i][r] === void 0 || t[i][r][o] === void 0 || t[i][r][o] === !0;
          },
          /**
           * Returns true if the given tile is completely covered by higher-level
           * tiles of higher resolution representing the same content. If neither x
           * nor y is given, returns true if the entire visible level is covered.
           * @private
           *
           * @param {Object} coverage - A '3d' dictionary [level][x][y] --> Boolean.
           * @param {Number} level - The resolution level of the tile.
           * @param {Number} x - The X position of the tile.
           * @param {Number} y - The Y position of the tile.
           * @returns {Boolean}
           */
          _isCovered: function(t, i, r, o) {
            return r === void 0 || o === void 0 ? this._providesCoverage(t, i + 1) : this._providesCoverage(t, i + 1, 2 * r, 2 * o) && this._providesCoverage(t, i + 1, 2 * r, 2 * o + 1) && this._providesCoverage(t, i + 1, 2 * r + 1, 2 * o) && this._providesCoverage(t, i + 1, 2 * r + 1, 2 * o + 1);
          },
          /**
           * Sets whether the given tile provides coverage or not.
           * @private
           *
           * @param {Object} coverage - A '3d' dictionary [level][x][y] --> Boolean.
           * @param {Number} level - The resolution level of the tile.
           * @param {Number} x - The X position of the tile.
           * @param {Number} y - The Y position of the tile.
           * @param {Boolean} covers - Whether the tile provides coverage.
           */
          _setCoverage: function(t, i, r, o, a) {
            if (!t[i]) {
              e.console.warn(
                "Setting coverage for a tile before its level's coverage has been reset: %s",
                i
              );
              return;
            }
            t[i][r] || (t[i][r] = {}), t[i][r][o] = a;
          },
          /**
           * Resets coverage information for the given level. This should be called
           * after every draw routine. Note that at the beginning of the next draw
           * routine, coverage for every visible tile should be explicitly set.
           * @private
           *
           * @param {Object} coverage - A '3d' dictionary [level][x][y] --> Boolean.
           * @param {Number} level - The resolution level of tiles to completely reset.
           */
          _resetCoverage: function(t, i) {
            t[i] = {};
          }
        }
      );
    })(n), (function(e) {
      var t = function(r) {
        e.console.assert(r, "[TileCache.cacheTile] options is required"), e.console.assert(r.tile, "[TileCache.cacheTile] options.tile is required"), e.console.assert(r.tiledImage, "[TileCache.cacheTile] options.tiledImage is required"), this.tile = r.tile, this.tiledImage = r.tiledImage;
      }, i = function(r) {
        e.console.assert(r, "[ImageRecord] options is required"), e.console.assert(r.data, "[ImageRecord] options.data is required"), this._tiles = [], r.create.apply(null, [this, r.data, r.ownerTile]), this._destroyImplementation = r.destroy.bind(null, this), this.getImage = r.getImage.bind(null, this), this.getData = r.getData.bind(null, this), this.getRenderedContext = r.getRenderedContext.bind(null, this);
      };
      i.prototype = {
        destroy: function() {
          this._destroyImplementation(), this._tiles = null;
        },
        addTile: function(r) {
          e.console.assert(r, "[ImageRecord.addTile] tile is required"), this._tiles.push(r);
        },
        removeTile: function(r) {
          for (var o = 0; o < this._tiles.length; o++)
            if (this._tiles[o] === r) {
              this._tiles.splice(o, 1);
              return;
            }
          e.console.warn("[ImageRecord.removeTile] trying to remove unknown tile", r);
        },
        getTileCount: function() {
          return this._tiles.length;
        }
      }, e.TileCache = function(r) {
        r = r || {}, this._maxImageCacheCount = r.maxImageCacheCount || e.DEFAULT_SETTINGS.maxImageCacheCount, this._tilesLoaded = [], this._imagesLoaded = [], this._imagesLoadedCount = 0;
      }, e.TileCache.prototype = {
        /**
         * @returns {Number} The total number of tiles that have been loaded by
         * this TileCache.
         */
        numTilesLoaded: function() {
          return this._tilesLoaded.length;
        },
        /**
         * Caches the specified tile, removing an old tile if necessary to stay under the
         * maxImageCacheCount specified on construction. Note that if multiple tiles reference
         * the same image, there may be more tiles than maxImageCacheCount; the goal is to keep
         * the number of images below that number. Note, as well, that even the number of images
         * may temporarily surpass that number, but should eventually come back down to the max specified.
         * @param {Object} options - Tile info.
         * @param {OpenSeadragon.Tile} options.tile - The tile to cache.
         * @param {String} options.tile.cacheKey - The unique key used to identify this tile in the cache.
         * @param {Image} options.image - The image of the tile to cache.
         * @param {OpenSeadragon.TiledImage} options.tiledImage - The TiledImage that owns that tile.
         * @param {Number} [options.cutoff=0] - If adding this tile goes over the cache max count, this
         * function will release an old tile. The cutoff option specifies a tile level at or below which
         * tiles will not be released.
         */
        cacheTile: function(r) {
          e.console.assert(r, "[TileCache.cacheTile] options is required"), e.console.assert(r.tile, "[TileCache.cacheTile] options.tile is required"), e.console.assert(r.tile.cacheKey, "[TileCache.cacheTile] options.tile.cacheKey is required"), e.console.assert(r.tiledImage, "[TileCache.cacheTile] options.tiledImage is required");
          var o = r.cutoff || 0, a = this._tilesLoaded.length, c = this._imagesLoaded[r.tile.cacheKey];
          if (c || (r.data || (e.console.error("[TileCache.cacheTile] options.image was renamed to options.data. '.image' attribute has been deprecated and will be removed in the future."), r.data = r.image), e.console.assert(r.data, "[TileCache.cacheTile] options.data is required to create an ImageRecord"), c = this._imagesLoaded[r.tile.cacheKey] = new i({
            data: r.data,
            ownerTile: r.tile,
            create: r.tiledImage.source.createTileCache,
            destroy: r.tiledImage.source.destroyTileCache,
            getImage: r.tiledImage.source.getTileCacheDataAsImage,
            getData: r.tiledImage.source.getTileCacheData,
            getRenderedContext: r.tiledImage.source.getTileCacheDataAsContext2D
          }), this._imagesLoadedCount++), c.addTile(r.tile), r.tile.cacheImageRecord = c, this._imagesLoadedCount > this._maxImageCacheCount) {
            for (var u = null, h = -1, f = null, g, x, C, E, R, D, U = this._tilesLoaded.length - 1; U >= 0; U--)
              if (D = this._tilesLoaded[U], g = D.tile, !(g.level <= o || g.beingDrawn)) {
                if (!u) {
                  u = g, h = U, f = D;
                  continue;
                }
                E = g.lastTouchTime, x = u.lastTouchTime, R = g.level, C = u.level, (E < x || E === x && R > C) && (u = g, h = U, f = D);
              }
            u && h >= 0 && (this._unloadTile(f), a = h);
          }
          this._tilesLoaded[a] = new t({
            tile: r.tile,
            tiledImage: r.tiledImage
          });
        },
        /**
         * Clears all tiles associated with the specified tiledImage.
         * @param {OpenSeadragon.TiledImage} tiledImage
         */
        clearTilesFor: function(r) {
          e.console.assert(r, "[TileCache.clearTilesFor] tiledImage is required");
          for (var o, a = 0; a < this._tilesLoaded.length; ++a)
            o = this._tilesLoaded[a], o.tiledImage === r && (this._unloadTile(o), this._tilesLoaded.splice(a, 1), a--);
        },
        // private
        getImageRecord: function(r) {
          return e.console.assert(r, "[TileCache.getImageRecord] cacheKey is required"), this._imagesLoaded[r];
        },
        // private
        _unloadTile: function(r) {
          e.console.assert(r, "[TileCache._unloadTile] tileRecord is required");
          var o = r.tile, a = r.tiledImage;
          let c = o.getCanvasContext && o.getCanvasContext();
          o.unload(), o.cacheImageRecord = null;
          var u = this._imagesLoaded[o.cacheKey];
          u && (u.removeTile(o), u.getTileCount() || (u.destroy(), delete this._imagesLoaded[o.cacheKey], this._imagesLoadedCount--, c && (c.canvas.width = 0, c.canvas.height = 0, a.viewer.raiseEvent("image-unloaded", {
            context2D: c,
            tile: o
          }))), a.viewer.raiseEvent("tile-unloaded", {
            tile: o,
            tiledImage: a
          }));
        }
      };
    })(n), (function(e) {
      e.World = function(t) {
        var i = this;
        e.console.assert(t.viewer, "[World] options.viewer is required"), e.EventSource.call(this), this.viewer = t.viewer, this._items = [], this._needsDraw = !1, this._autoRefigureSizes = !0, this._needsSizesFigured = !1, this._delegatedFigureSizes = function(r) {
          i._autoRefigureSizes ? i._figureSizes() : i._needsSizesFigured = !0;
        }, this._figureSizes();
      }, e.extend(
        e.World.prototype,
        e.EventSource.prototype,
        /** @lends OpenSeadragon.World.prototype */
        {
          /**
           * Add the specified item.
           * @param {OpenSeadragon.TiledImage} item - The item to add.
           * @param {Number} [options.index] - Index for the item. If not specified, goes at the top.
           * @fires OpenSeadragon.World.event:add-item
           * @fires OpenSeadragon.World.event:metrics-change
           */
          addItem: function(t, i) {
            if (e.console.assert(t, "[World.addItem] item is required"), e.console.assert(t instanceof e.TiledImage, "[World.addItem] only TiledImages supported at this time"), i = i || {}, i.index !== void 0) {
              var r = Math.max(0, Math.min(this._items.length, i.index));
              this._items.splice(r, 0, t);
            } else
              this._items.push(t);
            this._autoRefigureSizes ? this._figureSizes() : this._needsSizesFigured = !0, this._needsDraw = !0, t.addHandler("bounds-change", this._delegatedFigureSizes), t.addHandler("clip-change", this._delegatedFigureSizes), this.raiseEvent("add-item", {
              item: t
            });
          },
          /**
           * Get the item at the specified index.
           * @param {Number} index - The item's index.
           * @returns {OpenSeadragon.TiledImage} The item at the specified index.
           */
          getItemAt: function(t) {
            return e.console.assert(t !== void 0, "[World.getItemAt] index is required"), this._items[t];
          },
          /**
           * Get the index of the given item or -1 if not present.
           * @param {OpenSeadragon.TiledImage} item - The item.
           * @returns {Number} The index of the item or -1 if not present.
           */
          getIndexOfItem: function(t) {
            return e.console.assert(t, "[World.getIndexOfItem] item is required"), e.indexOf(this._items, t);
          },
          /**
           * @returns {Number} The number of items used.
           */
          getItemCount: function() {
            return this._items.length;
          },
          /**
           * Change the index of a item so that it appears over or under others.
           * @param {OpenSeadragon.TiledImage} item - The item to move.
           * @param {Number} index - The new index.
           * @fires OpenSeadragon.World.event:item-index-change
           */
          setItemIndex: function(t, i) {
            e.console.assert(t, "[World.setItemIndex] item is required"), e.console.assert(i !== void 0, "[World.setItemIndex] index is required");
            var r = this.getIndexOfItem(t);
            if (i >= this._items.length)
              throw new Error("Index bigger than number of layers.");
            i === r || r === -1 || (this._items.splice(r, 1), this._items.splice(i, 0, t), this._needsDraw = !0, this.raiseEvent("item-index-change", {
              item: t,
              previousIndex: r,
              newIndex: i
            }));
          },
          /**
           * Remove an item.
           * @param {OpenSeadragon.TiledImage} item - The item to remove.
           * @fires OpenSeadragon.World.event:remove-item
           * @fires OpenSeadragon.World.event:metrics-change
           */
          removeItem: function(t) {
            e.console.assert(t, "[World.removeItem] item is required");
            var i = e.indexOf(this._items, t);
            i !== -1 && (t.removeHandler("bounds-change", this._delegatedFigureSizes), t.removeHandler("clip-change", this._delegatedFigureSizes), t.destroy(), this._items.splice(i, 1), this._figureSizes(), this._needsDraw = !0, this._raiseRemoveItem(t));
          },
          /**
           * Remove all items.
           * @fires OpenSeadragon.World.event:remove-item
           * @fires OpenSeadragon.World.event:metrics-change
           */
          removeAll: function() {
            this.viewer._cancelPendingImages();
            var t, i;
            for (i = 0; i < this._items.length; i++)
              t = this._items[i], t.removeHandler("bounds-change", this._delegatedFigureSizes), t.removeHandler("clip-change", this._delegatedFigureSizes), t.destroy();
            var r = this._items;
            for (this._items = [], this._figureSizes(), this._needsDraw = !0, i = 0; i < r.length; i++)
              t = r[i], this._raiseRemoveItem(t);
          },
          /**
           * Clears all tiles and triggers updates for all items.
           */
          resetItems: function() {
            for (var t = 0; t < this._items.length; t++)
              this._items[t].reset();
          },
          /**
           * Updates (i.e. animates bounds of) all items.
           * @function
           * @param viewportChanged Whether the viewport changed, which indicates that
           * all TiledImages need to be updated.
           */
          update: function(t) {
            for (var i = !1, r = 0; r < this._items.length; r++)
              i = this._items[r].update(t) || i;
            return i;
          },
          /**
           * Draws all items.
           */
          draw: function() {
            this.viewer.drawer.draw(this._items), this._needsDraw = !1, this._items.forEach((t) => {
              this._needsDraw = t.setDrawn() || this._needsDraw;
            });
          },
          /**
           * @returns {Boolean} true if any items need updating.
           */
          needsDraw: function() {
            for (var t = 0; t < this._items.length; t++)
              if (this._items[t].needsDraw())
                return !0;
            return this._needsDraw;
          },
          /**
           * @returns {OpenSeadragon.Rect} The smallest rectangle that encloses all items, in viewport coordinates.
           */
          getHomeBounds: function() {
            return this._homeBounds.clone();
          },
          /**
           * To facilitate zoom constraints, we keep track of the pixel density of the
           * densest item in the World (i.e. the item whose content size to viewport size
           * ratio is the highest) and save it as this "content factor".
           * @returns {Number} the number of content units per viewport unit.
           */
          getContentFactor: function() {
            return this._contentFactor;
          },
          /**
           * As a performance optimization, setting this flag to false allows the bounds-change event handler
           * on tiledImages to skip calculations on the world bounds. If a lot of images are going to be positioned in
           * rapid succession, this is a good idea. When finished, setAutoRefigureSizes should be called with true
           * or the system may behave oddly.
           * @param {Boolean} [value] The value to which to set the flag.
           */
          setAutoRefigureSizes: function(t) {
            this._autoRefigureSizes = t, t & this._needsSizesFigured && (this._figureSizes(), this._needsSizesFigured = !1);
          },
          /**
           * Arranges all of the TiledImages with the specified settings.
           * @param {Object} options - Specifies how to arrange.
           * @param {Boolean} [options.immediately=false] - Whether to animate to the new arrangement.
           * @param {String} [options.layout] - See collectionLayout in {@link OpenSeadragon.Options}.
           * @param {Number} [options.rows] - See collectionRows in {@link OpenSeadragon.Options}.
           * @param {Number} [options.columns] - See collectionColumns in {@link OpenSeadragon.Options}.
           * @param {Number} [options.tileSize] - See collectionTileSize in {@link OpenSeadragon.Options}.
           * @param {Number} [options.tileMargin] - See collectionTileMargin in {@link OpenSeadragon.Options}.
           * @fires OpenSeadragon.World.event:metrics-change
           */
          arrange: function(t) {
            t = t || {};
            var i = t.immediately || !1, r = t.layout || e.DEFAULT_SETTINGS.collectionLayout, o = t.rows || e.DEFAULT_SETTINGS.collectionRows, a = t.columns || e.DEFAULT_SETTINGS.collectionColumns, c = t.tileSize || e.DEFAULT_SETTINGS.collectionTileSize, u = t.tileMargin || e.DEFAULT_SETTINGS.collectionTileMargin, h = c + u, f;
            !t.rows && a ? f = a : f = Math.ceil(this._items.length / o);
            var g = 0, x = 0, C, E, R, D, U;
            this.setAutoRefigureSizes(!1);
            for (var Z = 0; Z < this._items.length; Z++)
              Z && Z % f === 0 && (r === "horizontal" ? (x += h, g = 0) : (g += h, x = 0)), C = this._items[Z], E = C.getBounds(), E.width > E.height ? R = c : R = c * (E.width / E.height), D = R * (E.height / E.width), U = new e.Point(
                g + (c - R) / 2,
                x + (c - D) / 2
              ), C.setPosition(U, i), C.setWidth(R, i), r === "horizontal" ? g += h : x += h;
            this.setAutoRefigureSizes(!0);
          },
          // private
          _figureSizes: function() {
            var t = this._homeBounds ? this._homeBounds.clone() : null, i = this._contentSize ? this._contentSize.clone() : null, r = this._contentFactor || 0;
            if (!this._items.length)
              this._homeBounds = new e.Rect(0, 0, 1, 1), this._contentSize = new e.Point(1, 1), this._contentFactor = 1;
            else {
              var o = this._items[0], a = o.getBounds();
              this._contentFactor = o.getContentSize().x / a.width;
              for (var c = o.getClippedBounds().getBoundingBox(), u = c.x, h = c.y, f = c.x + c.width, g = c.y + c.height, x = 1; x < this._items.length; x++)
                o = this._items[x], a = o.getBounds(), this._contentFactor = Math.max(
                  this._contentFactor,
                  o.getContentSize().x / a.width
                ), c = o.getClippedBounds().getBoundingBox(), u = Math.min(u, c.x), h = Math.min(h, c.y), f = Math.max(f, c.x + c.width), g = Math.max(g, c.y + c.height);
              this._homeBounds = new e.Rect(u, h, f - u, g - h), this._contentSize = new e.Point(
                this._homeBounds.width * this._contentFactor,
                this._homeBounds.height * this._contentFactor
              );
            }
            (this._contentFactor !== r || !this._homeBounds.equals(t) || !this._contentSize.equals(i)) && this.raiseEvent("metrics-change", {});
          },
          // private
          _raiseRemoveItem: function(t) {
            this.raiseEvent("remove-item", { item: t });
          }
        }
      );
    })(n);
  })(fn)), fn.exports;
}
var Pg = Eg();
const Sg = /* @__PURE__ */ mc(Pg);
var kg = Object.defineProperty, Rg = Object.getOwnPropertyDescriptor, Ag = Object.getPrototypeOf, Ig = Reflect.get, mt = (s, n, e, t) => {
  for (var i = t > 1 ? void 0 : t ? Rg(n, e) : n, r = s.length - 1, o; r >= 0; r--)
    (o = s[r]) && (i = (t ? o(n, e, i) : o(i)) || i);
  return t && i && kg(n, e, i), i;
}, Dg = (s, n, e) => Ig(Ag(s), e, n);
let it = class extends Ln {
  constructor() {
    super(...arguments), this.rotationValues = /* @__PURE__ */ new Map(), this.firstTile = !1, this.viewer = void 0, this.openseadragonImagePath = "/static/assets/images/lightbox/", this.eof = !1, this.bof = !1, this.hideUI = !1, this.navDeferred = !1, this.darkMode = !0, this.open = !1, this.currentResolution = "", this.resolutions = [], this.dataVisible = !1, this.hasData = !1, this.resOpened = !1;
  }
  // private disableRotationCacheOnce = false
  setURLProvider(s) {
    this.urlProvider = s;
  }
  initOpenSeaDragon() {
    this.viewer && this.viewer.destroy(), this.navDeferred = !1;
    const s = this.shadowRoot?.getElementById("open-sea-dragon"), n = this.apiContext.getHeaders("application/json");
    let e = {};
    n.forEach((t, i) => {
      e[i] = t;
    }), s && (this.firstTile = !1, this.viewer = Sg({
      element: s,
      id: "open-sea-dragon",
      prefixUrl: this.openseadragonImagePath,
      showFullPageControl: !1,
      showRotationControl: !0,
      loadTilesWithAjax: !0,
      ajaxHeaders: e,
      crossOriginPolicy: "Anonymous"
    }), this.viewer.addHandler("open", () => {
      console.log("success");
    }), this.viewer.addHandler("open-failed", (t) => {
      this.opened(!1, t.message);
    }), this.viewer.addHandler("tile-load-failed", (t) => {
      console.log("tile load failure"), this.firstTile && this.opened(!1, t.message), this.firstTile = !1;
    }), this.viewer.addHandler("tile-loaded", () => {
      console.log("tile loaded successfully"), this.firstTile && this.opened(!0, ""), this.firstTile = !1;
    }), this.viewer.addHandler("rotate", (t) => {
      this.urlProvider?.url && (t.degrees % 360 === 0 ? this.rotationValues.delete(this.urlProvider.url) : this.rotationValues.set(this.urlProvider.url, t.degrees % 360));
    }));
  }
  nextFile(s) {
    let n;
    if (this.viewerError = void 0, !this.viewer) {
      this.viewerError = "The viewer instance was not successfully initialized, so I can't show anything.";
      return;
    }
    if (!this.urlProvider) {
      this.viewerError = "The urlProvider is missing. That's a programming error.";
      return;
    }
    try {
      s == "next" ? n = this.urlProvider.next() : n = this.urlProvider.prev();
    } catch (e) {
      this.viewerError = `An error occurred, so I don't know what file to fetch: ${e}`;
      return;
    }
    n ? this._openFile() : this.viewerError = "there is nowhere to go";
  }
  reloadFile() {
    this._openFile();
  }
  showHideUI(s = null) {
    this.hideUI = s === null ? !this.hideUI : s;
  }
  _openFile() {
    this.tryOpen(() => {
      if (this.urlProvider?.url && this.viewer) {
        this.eof = this.urlProvider.eof(), this.bof = this.urlProvider.bof();
        let s = 0, n = 0;
        try {
          s = this.urlProvider.height, n = this.urlProvider.width;
        } catch {
        }
        (s === 0 || n === 0) && (s = 5e3, n = 5e3);
        try {
          console.log(this.rotationValues);
          const e = this.rotationValues.get(this.urlProvider.url) ?? 0;
          console.log(`will set to ${e} degrees`), this.viewer.viewport.getRotation() != e && this.viewer.viewport.setRotation(e), this.firstTile = !0, this.viewer.open(
            {
              tileSource: {
                type: "legacy-image-pyramid",
                levels: [
                  {
                    url: this.urlProvider.url,
                    height: s,
                    width: n
                  }
                ]
              },
              // degrees: degrees, //this could be used to set the EXIF degrees!
              collectionImmediately: !0
            }
          );
        } catch (e) {
          this.viewerError = `An error occurred: ${e}`;
        }
      } else
        this.viewerError = "An error occurred: no url provider or no viewer in _openFile.";
    });
  }
  disconnectedCallback() {
    this.viewer && this.viewer.destroy();
  }
  updated(s) {
    s.has("open") && (this.open ? (this.initOpenSeaDragon(), this.nextFile("next")) : this.viewer && (this.viewer.destroy(), setTimeout(() => {
      const n = new CustomEvent("closed", {
        bubbles: !0,
        cancelable: !0,
        detail: this
      });
      this.dispatchEvent(n);
    }, 10))), s.has("dataVisible") && (this.dataVisible || this.scroll(0, 0));
  }
  willUpdate(s) {
  }
  apiConnected() {
  }
  openDialog() {
    this.open = !0;
  }
  tryOpen(s) {
    this.emitBeforeEvent(
      "beforeOpen",
      {},
      () => {
        this.navDeferred = !1;
      },
      () => {
        this.navDeferred = !1, s();
      }
    ) || (this.navDeferred = !0);
  }
  opened(s, n) {
    setTimeout(() => {
      const e = new CustomEvent("opened", {
        bubbles: !0,
        cancelable: !1,
        detail: {
          component: this,
          result: s,
          errMsg: n
        }
      });
      this.dispatchEvent(e);
    }, 10);
  }
  splitterClicked() {
    this.dataVisible = !this.dataVisible;
  }
  renderError() {
    return this.viewerError ? We`
            <div class="kiosk-lightbox-error">
                <p>${this.viewerError}</p>
            </div>` : ze;
  }
  doClose() {
    this.open = !1, this.navDeferred = !1;
  }
  doNext() {
    try {
      this.nextFile("next");
    } catch (s) {
      console.log(s);
    }
    this.navDeferred = !1;
  }
  doPrev() {
    try {
      this.nextFile("prev");
    } catch (s) {
      console.log(s);
    }
    this.navDeferred = !1;
  }
  tryClose() {
    this.emitBeforeEvent(
      "beforeClose",
      {},
      () => {
        this.navDeferred = !1;
      },
      () => {
        this.doClose();
      }
    ) || (this.navDeferred = !0);
  }
  tryNext() {
    this.urlProvider?.eof() || this.emitBeforeEvent(
      "beforeNext",
      {},
      () => {
        this.navDeferred = !1;
      },
      () => {
        this.doNext();
      }
    ) || (this.navDeferred = !0);
  }
  tryPrev() {
    this.urlProvider?.bof() || this.emitBeforeEvent(
      "beforePrev",
      {},
      () => {
        this.navDeferred = !1;
      },
      () => {
        this.doPrev();
      }
    ) || (this.navDeferred = !0);
  }
  close(s = !1) {
    this.navDeferred = !1, s ? this.tryClose() : this.doClose();
  }
  toggleBackground() {
    this.darkMode = !this.darkMode;
  }
  toggleResolution() {
    this.resOpened = !this.resOpened;
  }
  switchResolution(s) {
    const n = s.currentTarget?.dataset.resolution;
    if (n && n != this.currentResolution) {
      this.currentResolution = n;
      const e = new CustomEvent("ResolutionChanged", {
        bubbles: !0,
        composed: !0,
        cancelable: !1
      });
      this.dispatchEvent(e);
    }
    s.stopPropagation(), this.resOpened = !1;
  }
  renderResolutionButton() {
    return this.resolutions.length > 1 ? We`
                <div class="kiosk-lightbox-button resolution-btn" @click="${this.toggleResolution}">
                    <span>RES</span>
                    ${this.resOpened ? We`
                                <div class="resolutions">
                                    ${this.resolutions.map((s) => We`
                                        <div class="res-item" data-resolution=${s} @click="${this.switchResolution}">
                                            <div class="res-item-checker">
                                                ${s.toLowerCase() === this.currentResolution.toLowerCase() ? We`<i class = "fas fa-check" > </i>` : ze}
                                            </div>
                                            <div>${s}</div>
                                        </div>                                        
                                    `)}

                                </div>` : ze}
                </div>
            ` : ze;
  }
  renderNavButtons() {
    return We`<div class="kiosk-lightbox-buttons ${this.hideUI ? "hide-ui" : ""}">
                        ${this.renderResolutionButton()}
                        <div class="kiosk-lightbox-button" @click="${this.toggleBackground}"><i class="fa-circle-half-stroke"></i></div>
                        <div class = "kiosk-lightbox-button ${this.bof ? "nav-button-deactivated" : ""}" @click="${this.tryPrev}"><i class="fa-prev"></i> </div>
                        <div class = "kiosk-lightbox-button ${this.eof ? "nav-button-deactivated" : ""}" @click="${this.tryNext}"> <i class="fa-next"></i></div>
                        <div class="kiosk-lightbox-button" @click="${this.tryClose}"><i class="fa-close"></i></div>
                    </div>
                `;
  }
  renderOpenSeaDragon() {
    const s = { expanded: this.dataVisible, collapsed: !this.dataVisible, nodata: !this.hasData };
    return We`
            <div class="kiosk-lightbox-outer ${this.darkMode ? "background-dark" : "background-light"}">
                ${this.navDeferred ? ze : this.renderNavButtons()}
                ${this.renderError()}
                <div class="kiosk-lightbox-inner ${this.hideUI ? "hide-ui" : ze}" 
                     style="${this.viewerError ? "visibility: hidden" : ze}">
                    <div id="open-sea-dragon"
                         class="kiosk-lightbox-viewer ${Cg(s)}">
                    </div>
                </div>
                ${this.hasData ? We`
                    <div class="kiosk-lightbox-data" style="${this.viewerError ? "visibility: hidden" : ze}">
                        <div class="kiosk-lightbox-splitter" @click="${this.splitterClicked}">
                            <i class="fa-view-list"></i>
                        </div>
                        <slot></slot>
                    </div>` : ze}
            </div>`;
  }
  apiRender() {
    return this.open ? We`${this.renderOpenSeaDragon()}` : We``;
  }
};
it.styles = yr(xg);
it.properties = {
  ...Dg(it, it, "properties")
};
mt([
  Pt()
], it.prototype, "viewerError", 2);
mt([
  Pt()
], it.prototype, "eof", 2);
mt([
  Pt()
], it.prototype, "bof", 2);
mt([
  Pt()
], it.prototype, "hideUI", 2);
mt([
  Pt()
], it.prototype, "navDeferred", 2);
mt([
  Pt()
], it.prototype, "darkMode", 2);
mt([
  Xe({ type: Boolean, reflect: !0 })
], it.prototype, "open", 2);
mt([
  Xe({ type: String, reflect: !0 })
], it.prototype, "currentResolution", 2);
mt([
  Xe()
], it.prototype, "resolutions", 2);
mt([
  Xe()
], it.prototype, "dataVisible", 2);
mt([
  Xe({ type: Boolean })
], it.prototype, "hasData", 2);
mt([
  Pt()
], it.prototype, "resOpened", 2);
it = mt([
  Mn("kiosk-lightbox")
], it);
export {
  Fp as ComboBox,
  If as Grid,
  ct as KioskContextSelector,
  di as KioskDialog,
  it as KioskLightbox,
  bt as KioskTZComboBox
};
