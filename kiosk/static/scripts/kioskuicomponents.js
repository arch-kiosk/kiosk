var Yh = Object.defineProperty;
var Xh = (s, r, e) => r in s ? Yh(s, r, { enumerable: !0, configurable: !0, writable: !0, value: e }) : s[r] = e;
var tt = (s, r, e) => Xh(s, typeof r != "symbol" ? r + "" : r, e);
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function $t(s, r = "24.5.5") {
  Object.defineProperty(s, "version", {
    get() {
      return r;
    }
  });
  const e = customElements.get(s.is);
  if (!e)
    customElements.define(s.is, s);
  else {
    const t = e.version;
    t && s.version && t === s.version ? console.warn(`The component ${s.is} has been loaded twice`) : console.error(
      `Tried to define ${s.is} version ${s.version} when version ${e.version} is already in use. Something will probably break.`
    );
  }
}
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class Jh extends HTMLElement {
  static get is() {
    return "vaadin-lumo-styles";
  }
}
$t(Jh);
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const En = globalThis, ks = En.ShadowRoot && (En.ShadyCSS === void 0 || En.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, As = Symbol(), Na = /* @__PURE__ */ new WeakMap();
let Rs = class {
  constructor(r, e, t) {
    if (this._$cssResult$ = !0, t !== As) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = r, this.t = e;
  }
  get styleSheet() {
    let r = this.o;
    const e = this.t;
    if (ks && r === void 0) {
      const t = e !== void 0 && e.length === 1;
      t && (r = Na.get(e)), r === void 0 && ((this.o = r = new CSSStyleSheet()).replaceSync(this.cssText), t && Na.set(e, r));
    }
    return r;
  }
  toString() {
    return this.cssText;
  }
};
const Hr = (s) => new Rs(typeof s == "string" ? s : s + "", void 0, As), ke = (s, ...r) => {
  const e = s.length === 1 ? s[0] : r.reduce((t, i, n) => t + ((o) => {
    if (o._$cssResult$ === !0) return o.cssText;
    if (typeof o == "number") return o;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + o + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(i) + s[n + 1], s[0]);
  return new Rs(e, s, As);
}, Xl = (s, r) => {
  if (ks) s.adoptedStyleSheets = r.map((e) => e instanceof CSSStyleSheet ? e : e.styleSheet);
  else for (const e of r) {
    const t = document.createElement("style"), i = En.litNonce;
    i !== void 0 && t.setAttribute("nonce", i), t.textContent = e.cssText, s.appendChild(t);
  }
}, Ha = ks ? (s) => s : (s) => s instanceof CSSStyleSheet ? ((r) => {
  let e = "";
  for (const t of r.cssRules) e += t.cssText;
  return Hr(e);
})(s) : s;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const { is: Qh, defineProperty: $h, getOwnPropertyDescriptor: ed, getOwnPropertyNames: td, getOwnPropertySymbols: id, getPrototypeOf: rd } = Object, Zt = globalThis, Va = Zt.trustedTypes, nd = Va ? Va.emptyScript : "", Mo = Zt.reactiveElementPolyfillSupport, Tr = (s, r) => s, Fn = { toAttribute(s, r) {
  switch (r) {
    case Boolean:
      s = s ? nd : null;
      break;
    case Object:
    case Array:
      s = s == null ? s : JSON.stringify(s);
  }
  return s;
}, fromAttribute(s, r) {
  let e = s;
  switch (r) {
    case Boolean:
      e = s !== null;
      break;
    case Number:
      e = s === null ? null : Number(s);
      break;
    case Object:
    case Array:
      try {
        e = JSON.parse(s);
      } catch {
        e = null;
      }
  }
  return e;
} }, Is = (s, r) => !Qh(s, r), Ua = { attribute: !0, type: String, converter: Fn, reflect: !1, hasChanged: Is };
Symbol.metadata ?? (Symbol.metadata = Symbol("metadata")), Zt.litPropertyMetadata ?? (Zt.litPropertyMetadata = /* @__PURE__ */ new WeakMap());
let Li = class extends HTMLElement {
  static addInitializer(r) {
    this._$Ei(), (this.l ?? (this.l = [])).push(r);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(r, e = Ua) {
    if (e.state && (e.attribute = !1), this._$Ei(), this.elementProperties.set(r, e), !e.noAccessor) {
      const t = Symbol(), i = this.getPropertyDescriptor(r, t, e);
      i !== void 0 && $h(this.prototype, r, i);
    }
  }
  static getPropertyDescriptor(r, e, t) {
    const { get: i, set: n } = ed(this.prototype, r) ?? { get() {
      return this[e];
    }, set(o) {
      this[e] = o;
    } };
    return { get() {
      return i == null ? void 0 : i.call(this);
    }, set(o) {
      const a = i == null ? void 0 : i.call(this);
      n.call(this, o), this.requestUpdate(r, a, t);
    }, configurable: !0, enumerable: !0 };
  }
  static getPropertyOptions(r) {
    return this.elementProperties.get(r) ?? Ua;
  }
  static _$Ei() {
    if (this.hasOwnProperty(Tr("elementProperties"))) return;
    const r = rd(this);
    r.finalize(), r.l !== void 0 && (this.l = [...r.l]), this.elementProperties = new Map(r.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(Tr("finalized"))) return;
    if (this.finalized = !0, this._$Ei(), this.hasOwnProperty(Tr("properties"))) {
      const e = this.properties, t = [...td(e), ...id(e)];
      for (const i of t) this.createProperty(i, e[i]);
    }
    const r = this[Symbol.metadata];
    if (r !== null) {
      const e = litPropertyMetadata.get(r);
      if (e !== void 0) for (const [t, i] of e) this.elementProperties.set(t, i);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [e, t] of this.elementProperties) {
      const i = this._$Eu(e, t);
      i !== void 0 && this._$Eh.set(i, e);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(r) {
    const e = [];
    if (Array.isArray(r)) {
      const t = new Set(r.flat(1 / 0).reverse());
      for (const i of t) e.unshift(Ha(i));
    } else r !== void 0 && e.push(Ha(r));
    return e;
  }
  static _$Eu(r, e) {
    const t = e.attribute;
    return t === !1 ? void 0 : typeof t == "string" ? t : typeof r == "string" ? r.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = !1, this.hasUpdated = !1, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    var r;
    this._$ES = new Promise((e) => this.enableUpdating = e), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), (r = this.constructor.l) == null || r.forEach((e) => e(this));
  }
  addController(r) {
    var e;
    (this._$EO ?? (this._$EO = /* @__PURE__ */ new Set())).add(r), this.renderRoot !== void 0 && this.isConnected && ((e = r.hostConnected) == null || e.call(r));
  }
  removeController(r) {
    var e;
    (e = this._$EO) == null || e.delete(r);
  }
  _$E_() {
    const r = /* @__PURE__ */ new Map(), e = this.constructor.elementProperties;
    for (const t of e.keys()) this.hasOwnProperty(t) && (r.set(t, this[t]), delete this[t]);
    r.size > 0 && (this._$Ep = r);
  }
  createRenderRoot() {
    const r = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return Xl(r, this.constructor.elementStyles), r;
  }
  connectedCallback() {
    var r;
    this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this.enableUpdating(!0), (r = this._$EO) == null || r.forEach((e) => {
      var t;
      return (t = e.hostConnected) == null ? void 0 : t.call(e);
    });
  }
  enableUpdating(r) {
  }
  disconnectedCallback() {
    var r;
    (r = this._$EO) == null || r.forEach((e) => {
      var t;
      return (t = e.hostDisconnected) == null ? void 0 : t.call(e);
    });
  }
  attributeChangedCallback(r, e, t) {
    this._$AK(r, t);
  }
  _$EC(r, e) {
    var n;
    const t = this.constructor.elementProperties.get(r), i = this.constructor._$Eu(r, t);
    if (i !== void 0 && t.reflect === !0) {
      const o = (((n = t.converter) == null ? void 0 : n.toAttribute) !== void 0 ? t.converter : Fn).toAttribute(e, t.type);
      this._$Em = r, o == null ? this.removeAttribute(i) : this.setAttribute(i, o), this._$Em = null;
    }
  }
  _$AK(r, e) {
    var n;
    const t = this.constructor, i = t._$Eh.get(r);
    if (i !== void 0 && this._$Em !== i) {
      const o = t.getPropertyOptions(i), a = typeof o.converter == "function" ? { fromAttribute: o.converter } : ((n = o.converter) == null ? void 0 : n.fromAttribute) !== void 0 ? o.converter : Fn;
      this._$Em = i, this[i] = a.fromAttribute(e, o.type), this._$Em = null;
    }
  }
  requestUpdate(r, e, t) {
    if (r !== void 0) {
      if (t ?? (t = this.constructor.getPropertyOptions(r)), !(t.hasChanged ?? Is)(this[r], e)) return;
      this.P(r, e, t);
    }
    this.isUpdatePending === !1 && (this._$ES = this._$ET());
  }
  P(r, e, t) {
    this._$AL.has(r) || this._$AL.set(r, e), t.reflect === !0 && this._$Em !== r && (this._$Ej ?? (this._$Ej = /* @__PURE__ */ new Set())).add(r);
  }
  async _$ET() {
    this.isUpdatePending = !0;
    try {
      await this._$ES;
    } catch (e) {
      Promise.reject(e);
    }
    const r = this.scheduleUpdate();
    return r != null && await r, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var t;
    if (!this.isUpdatePending) return;
    if (!this.hasUpdated) {
      if (this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this._$Ep) {
        for (const [n, o] of this._$Ep) this[n] = o;
        this._$Ep = void 0;
      }
      const i = this.constructor.elementProperties;
      if (i.size > 0) for (const [n, o] of i) o.wrapped !== !0 || this._$AL.has(n) || this[n] === void 0 || this.P(n, this[n], o);
    }
    let r = !1;
    const e = this._$AL;
    try {
      r = this.shouldUpdate(e), r ? (this.willUpdate(e), (t = this._$EO) == null || t.forEach((i) => {
        var n;
        return (n = i.hostUpdate) == null ? void 0 : n.call(i);
      }), this.update(e)) : this._$EU();
    } catch (i) {
      throw r = !1, this._$EU(), i;
    }
    r && this._$AE(e);
  }
  willUpdate(r) {
  }
  _$AE(r) {
    var e;
    (e = this._$EO) == null || e.forEach((t) => {
      var i;
      return (i = t.hostUpdated) == null ? void 0 : i.call(t);
    }), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(r)), this.updated(r);
  }
  _$EU() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = !1;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(r) {
    return !0;
  }
  update(r) {
    this._$Ej && (this._$Ej = this._$Ej.forEach((e) => this._$EC(e, this[e]))), this._$EU();
  }
  updated(r) {
  }
  firstUpdated(r) {
  }
};
Li.elementStyles = [], Li.shadowRootOptions = { mode: "open" }, Li[Tr("elementProperties")] = /* @__PURE__ */ new Map(), Li[Tr("finalized")] = /* @__PURE__ */ new Map(), Mo == null || Mo({ ReactiveElement: Li }), (Zt.reactiveElementVersions ?? (Zt.reactiveElementVersions = [])).push("2.0.4");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Er = globalThis, Mn = Er.trustedTypes, Wa = Mn ? Mn.createPolicy("lit-html", { createHTML: (s) => s }) : void 0, Jl = "$lit$", jt = `lit$${Math.random().toFixed(9).slice(2)}$`, Ql = "?" + jt, od = `<${Ql}>`, wi = document, Rr = () => wi.createComment(""), Ir = (s) => s === null || typeof s != "object" && typeof s != "function", Ds = Array.isArray, sd = (s) => Ds(s) || typeof (s == null ? void 0 : s[Symbol.iterator]) == "function", Lo = `[ 	
\f\r]`, gr = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, ja = /-->/g, Ga = />/g, hi = RegExp(`>|${Lo}(?:([^\\s"'>=/]+)(${Lo}*=${Lo}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), qa = /'/g, Ka = /"/g, $l = /^(?:script|style|textarea|title)$/i, ad = (s) => (r, ...e) => ({ _$litType$: s, strings: r, values: e }), mt = ad(1), xi = Symbol.for("lit-noChange"), ze = Symbol.for("lit-nothing"), Za = /* @__PURE__ */ new WeakMap(), pi = wi.createTreeWalker(wi, 129);
function ec(s, r) {
  if (!Ds(s) || !s.hasOwnProperty("raw")) throw Error("invalid template strings array");
  return Wa !== void 0 ? Wa.createHTML(r) : r;
}
const ld = (s, r) => {
  const e = s.length - 1, t = [];
  let i, n = r === 2 ? "<svg>" : r === 3 ? "<math>" : "", o = gr;
  for (let a = 0; a < e; a++) {
    const l = s[a];
    let h, d, f = -1, g = 0;
    for (; g < l.length && (o.lastIndex = g, d = o.exec(l), d !== null); ) g = o.lastIndex, o === gr ? d[1] === "!--" ? o = ja : d[1] !== void 0 ? o = Ga : d[2] !== void 0 ? ($l.test(d[2]) && (i = RegExp("</" + d[2], "g")), o = hi) : d[3] !== void 0 && (o = hi) : o === hi ? d[0] === ">" ? (o = i ?? gr, f = -1) : d[1] === void 0 ? f = -2 : (f = o.lastIndex - d[2].length, h = d[1], o = d[3] === void 0 ? hi : d[3] === '"' ? Ka : qa) : o === Ka || o === qa ? o = hi : o === ja || o === Ga ? o = gr : (o = hi, i = void 0);
    const w = o === hi && s[a + 1].startsWith("/>") ? " " : "";
    n += o === gr ? l + od : f >= 0 ? (t.push(h), l.slice(0, f) + Jl + l.slice(f) + jt + w) : l + jt + (f === -2 ? a : w);
  }
  return [ec(s, n + (s[e] || "<?>") + (r === 2 ? "</svg>" : r === 3 ? "</math>" : "")), t];
};
let as = class tc {
  constructor({ strings: r, _$litType$: e }, t) {
    let i;
    this.parts = [];
    let n = 0, o = 0;
    const a = r.length - 1, l = this.parts, [h, d] = ld(r, e);
    if (this.el = tc.createElement(h, t), pi.currentNode = this.el.content, e === 2 || e === 3) {
      const f = this.el.content.firstChild;
      f.replaceWith(...f.childNodes);
    }
    for (; (i = pi.nextNode()) !== null && l.length < a; ) {
      if (i.nodeType === 1) {
        if (i.hasAttributes()) for (const f of i.getAttributeNames()) if (f.endsWith(Jl)) {
          const g = d[o++], w = i.getAttribute(f).split(jt), C = /([.?@])?(.*)/.exec(g);
          l.push({ type: 1, index: n, name: C[2], strings: w, ctor: C[1] === "." ? hd : C[1] === "?" ? dd : C[1] === "@" ? ud : Yn }), i.removeAttribute(f);
        } else f.startsWith(jt) && (l.push({ type: 6, index: n }), i.removeAttribute(f));
        if ($l.test(i.tagName)) {
          const f = i.textContent.split(jt), g = f.length - 1;
          if (g > 0) {
            i.textContent = Mn ? Mn.emptyScript : "";
            for (let w = 0; w < g; w++) i.append(f[w], Rr()), pi.nextNode(), l.push({ type: 2, index: ++n });
            i.append(f[g], Rr());
          }
        }
      } else if (i.nodeType === 8) if (i.data === Ql) l.push({ type: 2, index: n });
      else {
        let f = -1;
        for (; (f = i.data.indexOf(jt, f + 1)) !== -1; ) l.push({ type: 7, index: n }), f += jt.length - 1;
      }
      n++;
    }
  }
  static createElement(r, e) {
    const t = wi.createElement("template");
    return t.innerHTML = r, t;
  }
};
function qi(s, r, e = s, t) {
  var o, a;
  if (r === xi) return r;
  let i = t !== void 0 ? (o = e._$Co) == null ? void 0 : o[t] : e._$Cl;
  const n = Ir(r) ? void 0 : r._$litDirective$;
  return (i == null ? void 0 : i.constructor) !== n && ((a = i == null ? void 0 : i._$AO) == null || a.call(i, !1), n === void 0 ? i = void 0 : (i = new n(s), i._$AT(s, e, t)), t !== void 0 ? (e._$Co ?? (e._$Co = []))[t] = i : e._$Cl = i), i !== void 0 && (r = qi(s, i._$AS(s, r.values), i, t)), r;
}
let cd = class {
  constructor(r, e) {
    this._$AV = [], this._$AN = void 0, this._$AD = r, this._$AM = e;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(r) {
    const { el: { content: e }, parts: t } = this._$AD, i = ((r == null ? void 0 : r.creationScope) ?? wi).importNode(e, !0);
    pi.currentNode = i;
    let n = pi.nextNode(), o = 0, a = 0, l = t[0];
    for (; l !== void 0; ) {
      if (o === l.index) {
        let h;
        l.type === 2 ? h = new Os(n, n.nextSibling, this, r) : l.type === 1 ? h = new l.ctor(n, l.name, l.strings, this, r) : l.type === 6 && (h = new fd(n, this, r)), this._$AV.push(h), l = t[++a];
      }
      o !== (l == null ? void 0 : l.index) && (n = pi.nextNode(), o++);
    }
    return pi.currentNode = wi, i;
  }
  p(r) {
    let e = 0;
    for (const t of this._$AV) t !== void 0 && (t.strings !== void 0 ? (t._$AI(r, t, e), e += t.strings.length - 2) : t._$AI(r[e])), e++;
  }
}, Os = class ic {
  get _$AU() {
    var r;
    return ((r = this._$AM) == null ? void 0 : r._$AU) ?? this._$Cv;
  }
  constructor(r, e, t, i) {
    this.type = 2, this._$AH = ze, this._$AN = void 0, this._$AA = r, this._$AB = e, this._$AM = t, this.options = i, this._$Cv = (i == null ? void 0 : i.isConnected) ?? !0;
  }
  get parentNode() {
    let r = this._$AA.parentNode;
    const e = this._$AM;
    return e !== void 0 && (r == null ? void 0 : r.nodeType) === 11 && (r = e.parentNode), r;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(r, e = this) {
    r = qi(this, r, e), Ir(r) ? r === ze || r == null || r === "" ? (this._$AH !== ze && this._$AR(), this._$AH = ze) : r !== this._$AH && r !== xi && this._(r) : r._$litType$ !== void 0 ? this.$(r) : r.nodeType !== void 0 ? this.T(r) : sd(r) ? this.k(r) : this._(r);
  }
  O(r) {
    return this._$AA.parentNode.insertBefore(r, this._$AB);
  }
  T(r) {
    this._$AH !== r && (this._$AR(), this._$AH = this.O(r));
  }
  _(r) {
    this._$AH !== ze && Ir(this._$AH) ? this._$AA.nextSibling.data = r : this.T(wi.createTextNode(r)), this._$AH = r;
  }
  $(r) {
    var n;
    const { values: e, _$litType$: t } = r, i = typeof t == "number" ? this._$AC(r) : (t.el === void 0 && (t.el = as.createElement(ec(t.h, t.h[0]), this.options)), t);
    if (((n = this._$AH) == null ? void 0 : n._$AD) === i) this._$AH.p(e);
    else {
      const o = new cd(i, this), a = o.u(this.options);
      o.p(e), this.T(a), this._$AH = o;
    }
  }
  _$AC(r) {
    let e = Za.get(r.strings);
    return e === void 0 && Za.set(r.strings, e = new as(r)), e;
  }
  k(r) {
    Ds(this._$AH) || (this._$AH = [], this._$AR());
    const e = this._$AH;
    let t, i = 0;
    for (const n of r) i === e.length ? e.push(t = new ic(this.O(Rr()), this.O(Rr()), this, this.options)) : t = e[i], t._$AI(n), i++;
    i < e.length && (this._$AR(t && t._$AB.nextSibling, i), e.length = i);
  }
  _$AR(r = this._$AA.nextSibling, e) {
    var t;
    for ((t = this._$AP) == null ? void 0 : t.call(this, !1, !0, e); r && r !== this._$AB; ) {
      const i = r.nextSibling;
      r.remove(), r = i;
    }
  }
  setConnected(r) {
    var e;
    this._$AM === void 0 && (this._$Cv = r, (e = this._$AP) == null || e.call(this, r));
  }
}, Yn = class {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(r, e, t, i, n) {
    this.type = 1, this._$AH = ze, this._$AN = void 0, this.element = r, this.name = e, this._$AM = i, this.options = n, t.length > 2 || t[0] !== "" || t[1] !== "" ? (this._$AH = Array(t.length - 1).fill(new String()), this.strings = t) : this._$AH = ze;
  }
  _$AI(r, e = this, t, i) {
    const n = this.strings;
    let o = !1;
    if (n === void 0) r = qi(this, r, e, 0), o = !Ir(r) || r !== this._$AH && r !== xi, o && (this._$AH = r);
    else {
      const a = r;
      let l, h;
      for (r = n[0], l = 0; l < n.length - 1; l++) h = qi(this, a[t + l], e, l), h === xi && (h = this._$AH[l]), o || (o = !Ir(h) || h !== this._$AH[l]), h === ze ? r = ze : r !== ze && (r += (h ?? "") + n[l + 1]), this._$AH[l] = h;
    }
    o && !i && this.j(r);
  }
  j(r) {
    r === ze ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, r ?? "");
  }
}, hd = class extends Yn {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(r) {
    this.element[this.name] = r === ze ? void 0 : r;
  }
}, dd = class extends Yn {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(r) {
    this.element.toggleAttribute(this.name, !!r && r !== ze);
  }
}, ud = class extends Yn {
  constructor(r, e, t, i, n) {
    super(r, e, t, i, n), this.type = 5;
  }
  _$AI(r, e = this) {
    if ((r = qi(this, r, e, 0) ?? ze) === xi) return;
    const t = this._$AH, i = r === ze && t !== ze || r.capture !== t.capture || r.once !== t.once || r.passive !== t.passive, n = r !== ze && (t === ze || i);
    i && this.element.removeEventListener(this.name, this, t), n && this.element.addEventListener(this.name, this, r), this._$AH = r;
  }
  handleEvent(r) {
    var e;
    typeof this._$AH == "function" ? this._$AH.call(((e = this.options) == null ? void 0 : e.host) ?? this.element, r) : this._$AH.handleEvent(r);
  }
}, fd = class {
  constructor(r, e, t) {
    this.element = r, this.type = 6, this._$AN = void 0, this._$AM = e, this.options = t;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(r) {
    qi(this, r);
  }
};
const Bo = Er.litHtmlPolyfillSupport;
Bo == null || Bo(as, Os), (Er.litHtmlVersions ?? (Er.litHtmlVersions = [])).push("3.2.1");
const rc = (s, r, e) => {
  const t = (e == null ? void 0 : e.renderBefore) ?? r;
  let i = t._$litPart$;
  if (i === void 0) {
    const n = (e == null ? void 0 : e.renderBefore) ?? null;
    t._$litPart$ = i = new Os(r.insertBefore(Rr(), n), n, void 0, e ?? {});
  }
  return i._$AI(s), i;
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
let vi = class extends Li {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    var e;
    const r = super.createRenderRoot();
    return (e = this.renderOptions).renderBefore ?? (e.renderBefore = r.firstChild), r;
  }
  update(r) {
    const e = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(r), this._$Do = rc(e, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    var r;
    super.connectedCallback(), (r = this._$Do) == null || r.setConnected(!0);
  }
  disconnectedCallback() {
    var r;
    super.disconnectedCallback(), (r = this._$Do) == null || r.setConnected(!1);
  }
  render() {
    return xi;
  }
};
var Zl;
vi._$litElement$ = !0, vi.finalized = !0, (Zl = globalThis.litElementHydrateSupport) == null || Zl.call(globalThis, { LitElement: vi });
const No = globalThis.litElementPolyfillSupport;
No == null || No({ LitElement: vi });
(globalThis.litElementVersions ?? (globalThis.litElementVersions = [])).push("4.1.1");
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const pd = (s) => class extends s {
  static get properties() {
    return {
      /**
       * Helper property with theme attribute value facilitating propagation
       * in shadow DOM.
       *
       * Enables the component implementation to propagate the `theme`
       * attribute value to the sub-components in Shadow DOM by binding
       * the sub-component's "theme" attribute to the `theme` property of
       * the host.
       *
       * **NOTE:** Extending the mixin only provides the property for binding,
       * and does not make the propagation alone.
       *
       * See [Styling Components: Sub-components](https://vaadin.com/docs/latest/styling/styling-components/#sub-components).
       * page for more information.
       *
       * @protected
       */
      _theme: {
        type: String,
        readOnly: !0
      }
    };
  }
  static get observedAttributes() {
    return [...super.observedAttributes, "theme"];
  }
  /** @protected */
  attributeChangedCallback(e, t, i) {
    super.attributeChangedCallback(e, t, i), e === "theme" && this._set_theme(i);
  }
};
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const nc = [], ls = /* @__PURE__ */ new Set(), zs = /* @__PURE__ */ new Set();
function oc(s) {
  return s && Object.prototype.hasOwnProperty.call(s, "__themes");
}
function gd(s) {
  return oc(customElements.get(s));
}
function md(s = []) {
  return [s].flat(1 / 0).filter((r) => r instanceof Rs ? !0 : (console.warn("An item in styles is not of type CSSResult. Use `unsafeCSS` or `css`."), !1));
}
function sc(s, r) {
  return (s || "").split(" ").some((e) => new RegExp(`^${e.split("*").join(".*")}$`, "u").test(r));
}
function ac(s) {
  return s.map((r) => r.cssText).join(`
`);
}
const Ln = "vaadin-themable-mixin-style";
function vd(s, r) {
  const e = document.createElement("style");
  e.id = Ln, e.textContent = ac(s), r.content.appendChild(e);
}
function _d(s) {
  if (!s.shadowRoot)
    return;
  const r = s.constructor;
  if (s instanceof vi)
    [...s.shadowRoot.querySelectorAll("style")].forEach((e) => e.remove()), Xl(s.shadowRoot, r.elementStyles);
  else {
    const e = s.shadowRoot.getElementById(Ln), t = r.prototype._template;
    e.textContent = t.content.getElementById(Ln).textContent;
  }
}
function bd(s) {
  ls.forEach((r) => {
    const e = r.deref();
    e instanceof s ? _d(e) : e || ls.delete(r);
  });
}
function lc(s) {
  if (s.prototype instanceof vi)
    s.elementStyles = s.finalizeStyles(s.styles);
  else {
    const r = s.prototype._template;
    r.content.getElementById(Ln).textContent = ac(s.getStylesForThis());
  }
  zs.forEach((r) => {
    const e = customElements.get(r);
    e !== s && e.prototype instanceof s && lc(e);
  });
}
function yd(s, r) {
  const e = s.__themes;
  return !e || !r ? !1 : e.some(
    (t) => t.styles.some((i) => r.some((n) => n.cssText === i.cssText))
  );
}
function Ke(s, r, e = {}) {
  r = md(r), window.Vaadin && window.Vaadin.styleModules ? window.Vaadin.styleModules.registerStyles(s, r, e) : nc.push({
    themeFor: s,
    styles: r,
    include: e.include,
    moduleId: e.moduleId
  }), s && zs.forEach((t) => {
    if (sc(s, t) && gd(t)) {
      const i = customElements.get(t);
      yd(i, r) ? console.warn(`Registering styles that already exist for ${t}`) : (!window.Vaadin || !window.Vaadin.suppressPostFinalizeStylesWarning) && console.warn(
        `The custom element definition for "${t}" was finalized before a style module was registered. Ideally, import component specific style modules before importing the corresponding custom element. This warning can be suppressed by setting "window.Vaadin.suppressPostFinalizeStylesWarning = true".`
      ), lc(i), bd(i);
    }
  });
}
function cs() {
  return window.Vaadin && window.Vaadin.styleModules ? window.Vaadin.styleModules.getAllThemes() : nc;
}
function wd(s = "") {
  let r = 0;
  return s.startsWith("lumo-") || s.startsWith("material-") ? r = 1 : s.startsWith("vaadin-") && (r = 2), r;
}
function cc(s) {
  const r = [];
  return s.include && [].concat(s.include).forEach((e) => {
    const t = cs().find((i) => i.moduleId === e);
    t ? r.push(...cc(t), ...t.styles) : console.warn(`Included moduleId ${e} not found in style registry`);
  }, s.styles), r;
}
function xd(s) {
  const r = `${s}-default-theme`, e = cs().filter((t) => t.moduleId !== r && sc(t.themeFor, s)).map((t) => ({
    ...t,
    // Prepend styles from included themes
    styles: [...cc(t), ...t.styles],
    // Map moduleId to includePriority
    includePriority: wd(t.moduleId)
  })).sort((t, i) => i.includePriority - t.includePriority);
  return e.length > 0 ? e : cs().filter((t) => t.moduleId === r);
}
const Vr = (s) => class extends pd(s) {
  constructor() {
    super(), ls.add(new WeakRef(this));
  }
  /**
   * Covers PolymerElement based component styling
   * @protected
   */
  static finalize() {
    if (super.finalize(), this.is && zs.add(this.is), this.elementStyles)
      return;
    const e = this.prototype._template;
    !e || oc(this) || vd(this.getStylesForThis(), e);
  }
  /**
   * Covers LitElement based component styling
   *
   * @protected
   */
  static finalizeStyles(e) {
    const t = this.getStylesForThis();
    return e ? [...[e].flat(1 / 0), ...t] : t;
  }
  /**
   * Get styles for the component type
   *
   * @private
   */
  static getStylesForThis() {
    const e = s.__themes || [], t = Object.getPrototypeOf(this.prototype), i = (t ? t.constructor.__themes : []) || [];
    this.__themes = [...e, ...i, ...xd(this.is)];
    const n = this.__themes.flatMap((o) => o.styles);
    return n.filter((o, a) => a === n.lastIndexOf(o));
  }
};
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Cd = (s, ...r) => {
  const e = document.createElement("style");
  e.id = s, e.textContent = r.map((t) => t.toString()).join(`
`).replace(":host", "html"), document.head.insertAdjacentElement("afterbegin", e);
}, $i = (s, ...r) => {
  Cd(`lumo-${s}`, r);
};
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Td = ke`
  :host {
    /* Base (background) */
    --lumo-base-color: #fff;

    /* Tint */
    --lumo-tint-5pct: hsla(0, 0%, 100%, 0.3);
    --lumo-tint-10pct: hsla(0, 0%, 100%, 0.37);
    --lumo-tint-20pct: hsla(0, 0%, 100%, 0.44);
    --lumo-tint-30pct: hsla(0, 0%, 100%, 0.5);
    --lumo-tint-40pct: hsla(0, 0%, 100%, 0.57);
    --lumo-tint-50pct: hsla(0, 0%, 100%, 0.64);
    --lumo-tint-60pct: hsla(0, 0%, 100%, 0.7);
    --lumo-tint-70pct: hsla(0, 0%, 100%, 0.77);
    --lumo-tint-80pct: hsla(0, 0%, 100%, 0.84);
    --lumo-tint-90pct: hsla(0, 0%, 100%, 0.9);
    --lumo-tint: #fff;

    /* Shade */
    --lumo-shade-5pct: hsla(214, 61%, 25%, 0.05);
    --lumo-shade-10pct: hsla(214, 57%, 24%, 0.1);
    --lumo-shade-20pct: hsla(214, 53%, 23%, 0.16);
    --lumo-shade-30pct: hsla(214, 50%, 22%, 0.26);
    --lumo-shade-40pct: hsla(214, 47%, 21%, 0.38);
    --lumo-shade-50pct: hsla(214, 45%, 20%, 0.52);
    --lumo-shade-60pct: hsla(214, 43%, 19%, 0.6);
    --lumo-shade-70pct: hsla(214, 42%, 18%, 0.69);
    --lumo-shade-80pct: hsla(214, 41%, 17%, 0.83);
    --lumo-shade-90pct: hsla(214, 40%, 16%, 0.94);
    --lumo-shade: hsl(214, 35%, 15%);

    /* Contrast */
    --lumo-contrast-5pct: var(--lumo-shade-5pct);
    --lumo-contrast-10pct: var(--lumo-shade-10pct);
    --lumo-contrast-20pct: var(--lumo-shade-20pct);
    --lumo-contrast-30pct: var(--lumo-shade-30pct);
    --lumo-contrast-40pct: var(--lumo-shade-40pct);
    --lumo-contrast-50pct: var(--lumo-shade-50pct);
    --lumo-contrast-60pct: var(--lumo-shade-60pct);
    --lumo-contrast-70pct: var(--lumo-shade-70pct);
    --lumo-contrast-80pct: var(--lumo-shade-80pct);
    --lumo-contrast-90pct: var(--lumo-shade-90pct);
    --lumo-contrast: var(--lumo-shade);

    /* Text */
    --lumo-header-text-color: var(--lumo-contrast);
    --lumo-body-text-color: var(--lumo-contrast-90pct);
    --lumo-secondary-text-color: var(--lumo-contrast-70pct);
    --lumo-tertiary-text-color: var(--lumo-contrast-50pct);
    --lumo-disabled-text-color: var(--lumo-contrast-30pct);

    /* Primary */
    --lumo-primary-color: hsl(214, 100%, 48%);
    --lumo-primary-color-50pct: hsla(214, 100%, 49%, 0.76);
    --lumo-primary-color-10pct: hsla(214, 100%, 60%, 0.13);
    --lumo-primary-text-color: hsl(214, 100%, 43%);
    --lumo-primary-contrast-color: #fff;

    /* Error */
    --lumo-error-color: hsl(3, 85%, 48%);
    --lumo-error-color-50pct: hsla(3, 85%, 49%, 0.5);
    --lumo-error-color-10pct: hsla(3, 85%, 49%, 0.1);
    --lumo-error-text-color: hsl(3, 89%, 42%);
    --lumo-error-contrast-color: #fff;

    /* Success */
    --lumo-success-color: hsl(145, 72%, 30%);
    --lumo-success-color-50pct: hsla(145, 72%, 31%, 0.5);
    --lumo-success-color-10pct: hsla(145, 72%, 31%, 0.1);
    --lumo-success-text-color: hsl(145, 85%, 25%);
    --lumo-success-contrast-color: #fff;

    /* Warning */
    --lumo-warning-color: hsl(48, 100%, 50%);
    --lumo-warning-color-10pct: hsla(48, 100%, 50%, 0.25);
    --lumo-warning-text-color: hsl(32, 100%, 30%);
    --lumo-warning-contrast-color: var(--lumo-shade-90pct);
  }

  /* forced-colors mode adjustments */
  @media (forced-colors: active) {
    html {
      --lumo-disabled-text-color: GrayText;
    }
  }
`;
$i("color-props", Td);
const Ed = ke`
  [theme~='dark'] {
    /* Base (background) */
    --lumo-base-color: hsl(214, 35%, 21%);

    /* Tint */
    --lumo-tint-5pct: hsla(214, 65%, 85%, 0.06);
    --lumo-tint-10pct: hsla(214, 60%, 80%, 0.14);
    --lumo-tint-20pct: hsla(214, 64%, 82%, 0.23);
    --lumo-tint-30pct: hsla(214, 69%, 84%, 0.32);
    --lumo-tint-40pct: hsla(214, 73%, 86%, 0.41);
    --lumo-tint-50pct: hsla(214, 78%, 88%, 0.5);
    --lumo-tint-60pct: hsla(214, 82%, 90%, 0.58);
    --lumo-tint-70pct: hsla(214, 87%, 92%, 0.69);
    --lumo-tint-80pct: hsla(214, 91%, 94%, 0.8);
    --lumo-tint-90pct: hsla(214, 96%, 96%, 0.9);
    --lumo-tint: hsl(214, 100%, 98%);

    /* Shade */
    --lumo-shade-5pct: hsla(214, 0%, 0%, 0.07);
    --lumo-shade-10pct: hsla(214, 4%, 2%, 0.15);
    --lumo-shade-20pct: hsla(214, 8%, 4%, 0.23);
    --lumo-shade-30pct: hsla(214, 12%, 6%, 0.32);
    --lumo-shade-40pct: hsla(214, 16%, 8%, 0.41);
    --lumo-shade-50pct: hsla(214, 20%, 10%, 0.5);
    --lumo-shade-60pct: hsla(214, 24%, 12%, 0.6);
    --lumo-shade-70pct: hsla(214, 28%, 13%, 0.7);
    --lumo-shade-80pct: hsla(214, 32%, 13%, 0.8);
    --lumo-shade-90pct: hsla(214, 33%, 13%, 0.9);
    --lumo-shade: hsl(214, 33%, 13%);

    /* Contrast */
    --lumo-contrast-5pct: var(--lumo-tint-5pct);
    --lumo-contrast-10pct: var(--lumo-tint-10pct);
    --lumo-contrast-20pct: var(--lumo-tint-20pct);
    --lumo-contrast-30pct: var(--lumo-tint-30pct);
    --lumo-contrast-40pct: var(--lumo-tint-40pct);
    --lumo-contrast-50pct: var(--lumo-tint-50pct);
    --lumo-contrast-60pct: var(--lumo-tint-60pct);
    --lumo-contrast-70pct: var(--lumo-tint-70pct);
    --lumo-contrast-80pct: var(--lumo-tint-80pct);
    --lumo-contrast-90pct: var(--lumo-tint-90pct);
    --lumo-contrast: var(--lumo-tint);

    /* Text */
    --lumo-header-text-color: var(--lumo-contrast);
    --lumo-body-text-color: var(--lumo-contrast-90pct);
    --lumo-secondary-text-color: var(--lumo-contrast-70pct);
    --lumo-tertiary-text-color: var(--lumo-contrast-50pct);
    --lumo-disabled-text-color: var(--lumo-contrast-30pct);

    /* Primary */
    --lumo-primary-color: hsl(214, 90%, 48%);
    --lumo-primary-color-50pct: hsla(214, 90%, 70%, 0.69);
    --lumo-primary-color-10pct: hsla(214, 90%, 55%, 0.13);
    --lumo-primary-text-color: hsl(214, 90%, 77%);
    --lumo-primary-contrast-color: #fff;

    /* Error */
    --lumo-error-color: hsl(3, 79%, 49%);
    --lumo-error-color-50pct: hsla(3, 75%, 62%, 0.5);
    --lumo-error-color-10pct: hsla(3, 75%, 62%, 0.14);
    --lumo-error-text-color: hsl(3, 100%, 80%);

    /* Success */
    --lumo-success-color: hsl(145, 72%, 30%);
    --lumo-success-color-50pct: hsla(145, 92%, 51%, 0.5);
    --lumo-success-color-10pct: hsla(145, 92%, 51%, 0.1);
    --lumo-success-text-color: hsl(145, 85%, 46%);

    /* Warning */
    --lumo-warning-color: hsl(43, 100%, 48%);
    --lumo-warning-color-10pct: hsla(40, 100%, 50%, 0.2);
    --lumo-warning-text-color: hsl(45, 100%, 60%);
    --lumo-warning-contrast-color: var(--lumo-shade-90pct);
  }

  html {
    color: var(--lumo-body-text-color);
    background-color: var(--lumo-base-color);
    color-scheme: light;
  }

  [theme~='dark'] {
    color: var(--lumo-body-text-color);
    background-color: var(--lumo-base-color);
    color-scheme: dark;
  }

  h1,
  h2,
  h3,
  h4,
  h5,
  h6 {
    color: var(--lumo-header-text-color);
  }

  a:where(:any-link) {
    color: var(--lumo-primary-text-color);
  }

  a:not(:any-link) {
    color: var(--lumo-disabled-text-color);
  }

  blockquote {
    color: var(--lumo-secondary-text-color);
  }

  code,
  pre {
    background-color: var(--lumo-contrast-10pct);
    border-radius: var(--lumo-border-radius-m);
  }
  pre code {
    background: transparent;
  }
`;
Ke("", Ed, { moduleId: "lumo-color" });
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Pd = ke`
  @font-face {
    font-family: 'lumo-icons';
    src: url(data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAABEgAAsAAAAAIjQAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABCAAAADsAAABUIIslek9TLzIAAAFEAAAAQwAAAFZAIUuKY21hcAAAAYgAAAD4AAADrsCU8d5nbHlmAAACgAAAC2cAABeAWri7U2hlYWQAAA3oAAAAMAAAADZa/6SsaGhlYQAADhgAAAAdAAAAJAbpA35obXR4AAAOOAAAABAAAACspBAAAGxvY2EAAA5IAAAAWAAAAFh57oA4bWF4cAAADqAAAAAfAAAAIAFKAXBuYW1lAAAOwAAAATEAAAIuUUJZCHBvc3QAAA/0AAABKwAAAelm8SzVeJxjYGRgYOBiMGCwY2BycfMJYeDLSSzJY5BiYGGAAJA8MpsxJzM9kYEDxgPKsYBpDiBmg4gCACY7BUgAeJxjYGS+yDiBgZWBgamKaQ8DA0MPhGZ8wGDIyAQUZWBlZsAKAtJcUxgcXjG+0mIO+p/FEMUcxDANKMwIkgMABn8MLQB4nO3SWW6DMABF0UtwCEnIPM/zhLK8LqhfXRybSP14XUYtHV9hGYQwQBNIo3cUIPkhQeM7rib1ekqnXg981XuC1qvy84lzojleh3puxL0hPjGjRU473teloEefAUNGjJkwZcacBUtWrNmwZceeA0dOnLlw5cadB09elPGhGf+j0NTI/65KfXerT6JhqKnpRKtgOpuqaTrtKjPUlqHmhto21I7pL6i6hlqY3q7qGWrfUAeGOjTUkaGODXViqFNDnRnq3FAXhro01JWhrg11Y6hbQ90Z6t5QD4Z6NNSToZ4N9WKoV0O9GerdUB+G+jTUl6GWRvkL24BkEXictVh9bFvVFb/nxvbz+7Rf/N6zHcd2bCfP+Wic1Z9N0jpNHCD9SNqqoVBgbQoMjY+pjA4hNnWa2pV1rHSIif0DGkyT2k10Kmu1Cag6huj4ZpqYBHSqJsTEJgZCG3TaVBFv595nO3ZIv4RIrPPuvefe884599zzO/cRF8G/tgn6CFFImNgkR0ggX8wlspbhSSWSdrC5ozd30s2dw5afzvgtyz9/zG9t1hV4RtF1pXolowvtzc2z6L2aYUQM45jKH9WDTvd1LRDoDASYWhfTzTyvboXz6uZX4ARX5wrF39y+HM2+CJ8d0pkyqBIqoze3D12ez4DrFoYzxI8dWwMrDlZ2DMqQAR9AROsJU+2smlTPaTTco52BVxXa2a2+I8vvqd2dVHm1LoPeTn/AZPRYGthDYOeZjBjKoFsVGulR3lGU95SeCK44oHU7MhWUGUKZDT3oSUcG2GWuh+EDDfUYA/jhIhl0TOsJNYSEu7mQmi3UzfXwZKA4BsVsHLXQYGgJW95qEtpJ1VcW9HiTriZBlFEqxsDjA09yCNUoQxxwd7KWSTt2y3GTKifkqHRCoWZc3m11Wa/dKdFgXD4kSYfkeJBKd8KMz7J8dZn/cGRCcLGDnA2Ge3bKzcvlnTDNthFWLH7Xt80ua5FMjA4WKelWv5Xo16vHuYzpRbJhhdVlftuRK0VlR27D9lu5TF0DPBi60OrHNO0AfP/uRWvhn/U3LXICE+nh+3IHPUJ8JE6GyBjZQLbjGchlrSgYngF8zyrIF4NJD3atUcgWsWunGN/UHX5B5/yg7uF87Nqp4Gf52F3gH73DjEZNRoqCKAr9giQJp5rGJABpiVE2htNhW9R8nw0jqYjCYcY4LIjwYNScf4WN06IZnZCEqsI4cFaQbo4Z1TsZBx40YhXkHOecaYE5oY37IIQ+iJJ+UsDYSun5MuRSBRZRUUhlY2DqOGajOR6zrSU/5My6l2DnusH1GQgnw5BZP7iuYM/ahcfQ7Z8y51ddfutvuwNqWQ0cBYr8fj0U0vsHpwerVaB2sWhXT2NExi2r1KUE2tUuVMnkepVQrxTmpQrZTG4iu8he8iPyM3KcPE/+RP5KPoE2CEAKclCBzXATxkYOtUY/o961PWRqsj0chRrHFBbtrjP9/P0ven5pcbRdpL94vfsy33e5+izuwz3nFLFPVNayPZx/jdG1fOChflFRvYzsW6L18efgLrSWIgvcqnGJYi4skO4xREURjbDuxKke5v0T3Mrzkt2fi31uyZlLLrqIpEuXXsMlgw442Jb0GAxjS1DM20kBoCzHLXm/jEm0IltdcvU0fEW24jgiwwRjVd9u4NJHcIyoHJcwvyVqgqj5hqBJ1ZWSJryh9p56UWhX1XbhRbW2ZopuZWsQd5y8mEQ8M+C6xjRYxZbDKWf5AgY+Qq/l6wSPk16zDFjowYuu+wjx13mfkxbyDDxadYT/LijZyI0THB+6yfLaWsRcO82zo9mWTNtpO18qlorZoIVMwSN40tky5DOQ1MCIAe24mvlsuwIIxPb10+uXDQ4uWz/9m3rj+ql7p6bufZARuPVq5tXtsn6KwfP8Jy0TeWOyNhUJN6mhX5rkUTtUppQWEMNTqEdaCGKFYKJaQrCE4JtDLYOlNEKmO5kBTPGY2A0N2sY3+dVlo1N9ycBsIGtOjQ2p/tlZvzo0ur4v6cOh8NTospB7U/X40KahoU3bGIH97dnwmtHlYffVG3R1YOwKM2vNhrPhCT5zk64sG53oS4b31aYjqe/B7+kQiXBN+b6h21hNUPMq29B8CU4elINdygMPKF1B+WBTG7Z9ZshpN/xwEuuDQZR+nuoo4CDaAiiwXmLpmukMQyPf/JMclqgL1ixZQ/nnP2VbdUODFGt2fgBvL123rlLYu/6A9ckb7F3K0/CyBMEu6aQoPscroCcacVehvyQyCZAsizsWWBkoLC+WAiWnOksLKaeuQDzGuqSk42aiYTiJ4zf9afl17SrqaTO1f+XlZAfIuYcq7/IqYMaMrksOJ6vHkOCPDq943xcCnHqVD9pHFRpMqSPXrIua1WNs+tOz1U+ciTCDpPk+c4QYJIHnYhxP/kVPAq+ahFpVhPcHp8qyarhiF+HsBU9Hrl+UZa876fbKipL0KqB6OdUveErgtOI97fZ63ae9SvWU6k2w1JfwqnUbHsYcFCJFrC/W12zIMMirWYEHxMPs6LGYSdkSZ5TsNP9PCpwnWC3HKZ1lydNjWHC2Mn3l6vL0dHn1ldP3LTSrX+vKrBqv7KmMr8p0SR6P1NqF63or6XRlIyO90f7+kf7+myOhvt4tq7f09oUiTc2/dycGgqFQcCDRLYmi1NL7fk0CknVMxEg/cdfs/TnpJMNkgqwj17B8beVazSrVbU4lG67IZYOCnWrYy3yBR9cyWcChywos3LJBEdhhFoAdYjiw0rLGm0xU5OzoGm5/ZfmHjVZpNNg6SznzGKDdwv2cCtVn6Eaxo12cfxLprpVtTcZ6hVx6dow7Yq7e8LXO8PY9Jgjoze9yCtU5FNbegcKkQMdCbt9au/te4Ebe0jkc0ukUL32eYnTpNs20h0KpUOhZPYwVcfhZnfdqeCvDfXiuCbAoYWcXERPc/mDQD3/hdF+wK4i/xv3kYfprIpAuMkk2kW3kdtS0kBIKpZwp8KxmsCyfM1MFzAss9LBkDxRyThiaqTLwKYKJVTwmWTudMyz+yks09346MDh4m72yOxCKrt1XMlQ1qPVlTEVVQ1ofdK/sCWjtZu9qGwZ8YZ9PPWlo1IV3eW3+U0aXblP39zrt+JPf6UhEQ1rUjNBULN+utyuaDNW34kpAVuSOeMTyWbSNWnooFu+QFNWQ4d/Ox4IPWx41fP/fB/Rjeoz08ezPA9TysMtmnOXfGN7Ui3xIYLDALrlDLOP09qtJuY2OeL0+QZXdRnR1nxRVBF/SOyKKPpcrn9mWzH4rH9IidE+PTNU2182+hOgSItrE1slByS24vaLvJpxOqe4Pduf3HJkZ+jLqUz9rRzB7p8gKcgWZwV1L8JtUS5Z2JxZSOCuBoMTQihMzLbCPA0KqGMAljRQjONklW/wjnXKy8vxT/Elvm3/KiMUMOoV0/vnDYlhec0SMKtt3/kKMyOt33tj2bqxQLsTjSGLl+EAsNhCnTyRGktW55EgCn/A4PlnWn+Mg8bgZrWqHxTbPwMuyy1u5YeZF2SUM7JRhddwRgiRuxpmgJmxn9ZW7XpcF3ViX/ar6ptRpGJ0S9Adg4qhb9sI3vbL7qNJV/y4i07t5TZBiho1imFoMz3gED+CtjYUxvP4SOxov4bFoNPg5aR1e+G4UgDPoedJTpogyCJ7oYvRqoVS0MQAy+CoNEdTDUjok5ZHZL/WtjV7rFj3PKQE3iKp7ou+rIxN3b9LB1dGjeT4cvKo3FrnWpYpuaFd/h3dtV8UeKN1Y9hpR3dt4p0H/zKuPQq0kZQUIIpuDfoiETsnIk+gCWMJZUXHtE8V9LkUc2TE8vOMbO4ax/MACabzyaGXc7u3FBr11ThBdB8SIeMAlCntG2KThHSPsaj2Dc9KNyY2a0KZ7ODaTHoRiFkeYz+shZBpCS4X6471KKKnuHd84edfk5F37d1XO5bbkcltu2ZLNbvnPXiUVAnVvprJrP+NObryjxrllS65md6Tm6wzFHRR4dY3QUUjb7MgxaIixU8hspi98fl/Xc+IB4iU66eCVL9YfAfahiSUt4TONS8x0D8W7u8vd3fGWx6OXlM/U1IoU/s61PGhpyXRFa3eReq2qG56lvmYtXavCC1iN7lbiBpWxXHU+cSlztVLVz0tVN600fVsLxaVDknhYioeoXP3t4lqV1r79MAw0GCI1FTL1YIGzPL1MMlJ9ZsN9P7lvA2yr9ZFUzwzPrVgxN/x/SS+chwB4nGNgZGBgAOLPrYdY4vltvjJwM78AijDUqG5oRND/XzNPZboF5HIwMIFEAU/lC+J4nGNgZGBgDvqfBSRfMAAB81QGRgZUoA0AVvYDbwAAAHicY2BgYGB+MTQwAM8EJo8AAAAAAE4AmgDoAQoBLAFOAXABmgHEAe4CGgKcAugEmgS8BNYE8gUOBSoFegXQBf4GRAZmBrYHGAeQCBgIUghqCP4JRgm+CdoKBAo+CoQKugr0C1QLmgvAeJxjYGRgYNBmTGEQZQABJiDmAkIGhv9gPgMAGJQBvAB4nG2RPU7DMBiG3/QP0UoIBGJh8QILavozdmRo9w7d09RpUzlx5LgVvQMn4BAcgoEzcAgOwVvzSZVQbcnf48fvFysJgGt8IcJxROiG9TgauODuj5ukG+EW+UG4jR4ehTv0Q+EunjER7uEWmk+IWpc0d3gVbuAKb8JN+nfhFvlDuI17fAp36L+Fu1jgR7iHp+jF7Arbz1Nb1nO93pnEncSJFtrVuS3VKB6e5EyX2iVer9TyoOr9eux9pjJnCzW1pdfGWFU5u9WpjzfeV5PBIBMfp7aAwQ4FLPrIkbKWqDHn+67pDRK4s4lzbsEux5qHvcIIMb/nueSMyTKkE3jWFdNLHLjW2PPmMa1Hxn3GjGW/wjT0HtOG09JU4WxLk9LH2ISuiv9twJn9y8fh9uIXI+BknAAAAHicbY7ZboMwEEW5CVBCSLrv+76kfJRjTwHFsdGAG+Xvy5JUfehIHp0rnxmNN/D6ir3/a4YBhvARIMQOIowQY4wEE0yxiz3s4wCHOMIxTnCKM5zjApe4wjVucIs73OMBj3jCM17wije84wMzfHqJ0EVmUkmmJo77oOmrHvfIRZbXsTCZplTZldlgb3TYGVHProwFs11t1A57tcON2rErR3PBqcwF1/6ctI6k0GSU4JHMSS6WghdJQ99sTbfuN7QLJ9vQ37dNrgyktnIxlDYLJNuqitpRbYWKFNuyDT6pog6oOYKHtKakeakqKjHXpPwlGRcsC+OqxLIiJpXqoqqDMreG2l5bv9Ri3TRX+c23DZna9WFFgmXuO6Ps1Jm/w6ErW8N3FbHn/QC444j0AA==)
      format('woff');
    font-weight: normal;
    font-style: normal;
  }

  html {
    --lumo-icons-align-center: '\\ea01';
    --lumo-icons-align-left: '\\ea02';
    --lumo-icons-align-right: '\\ea03';
    --lumo-icons-angle-down: '\\ea04';
    --lumo-icons-angle-left: '\\ea05';
    --lumo-icons-angle-right: '\\ea06';
    --lumo-icons-angle-up: '\\ea07';
    --lumo-icons-arrow-down: '\\ea08';
    --lumo-icons-arrow-left: '\\ea09';
    --lumo-icons-arrow-right: '\\ea0a';
    --lumo-icons-arrow-up: '\\ea0b';
    --lumo-icons-bar-chart: '\\ea0c';
    --lumo-icons-bell: '\\ea0d';
    --lumo-icons-calendar: '\\ea0e';
    --lumo-icons-checkmark: '\\ea0f';
    --lumo-icons-chevron-down: '\\ea10';
    --lumo-icons-chevron-left: '\\ea11';
    --lumo-icons-chevron-right: '\\ea12';
    --lumo-icons-chevron-up: '\\ea13';
    --lumo-icons-clock: '\\ea14';
    --lumo-icons-cog: '\\ea15';
    --lumo-icons-cross: '\\ea16';
    --lumo-icons-download: '\\ea17';
    --lumo-icons-dropdown: '\\ea18';
    --lumo-icons-edit: '\\ea19';
    --lumo-icons-error: '\\ea1a';
    --lumo-icons-eye: '\\ea1b';
    --lumo-icons-eye-disabled: '\\ea1c';
    --lumo-icons-menu: '\\ea1d';
    --lumo-icons-minus: '\\ea1e';
    --lumo-icons-ordered-list: '\\ea1f';
    --lumo-icons-phone: '\\ea20';
    --lumo-icons-photo: '\\ea21';
    --lumo-icons-play: '\\ea22';
    --lumo-icons-plus: '\\ea23';
    --lumo-icons-redo: '\\ea24';
    --lumo-icons-reload: '\\ea25';
    --lumo-icons-search: '\\ea26';
    --lumo-icons-undo: '\\ea27';
    --lumo-icons-unordered-list: '\\ea28';
    --lumo-icons-upload: '\\ea29';
    --lumo-icons-user: '\\ea2a';
  }
`;
$i("font-icons", Pd);
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Sd = ke`
  :host {
    --lumo-size-xs: 1.625rem;
    --lumo-size-s: 1.875rem;
    --lumo-size-m: 2.25rem;
    --lumo-size-l: 2.75rem;
    --lumo-size-xl: 3.5rem;

    /* Icons */
    --lumo-icon-size-s: 1.25em;
    --lumo-icon-size-m: 1.5em;
    --lumo-icon-size-l: 2.25em;
    /* For backwards compatibility */
    --lumo-icon-size: var(--lumo-icon-size-m);
  }
`;
$i("sizing-props", Sd);
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const kd = ke`
  :host {
    /* Square */
    --lumo-space-xs: 0.25rem;
    --lumo-space-s: 0.5rem;
    --lumo-space-m: 1rem;
    --lumo-space-l: 1.5rem;
    --lumo-space-xl: 2.5rem;

    /* Wide */
    --lumo-space-wide-xs: calc(var(--lumo-space-xs) / 2) var(--lumo-space-xs);
    --lumo-space-wide-s: calc(var(--lumo-space-s) / 2) var(--lumo-space-s);
    --lumo-space-wide-m: calc(var(--lumo-space-m) / 2) var(--lumo-space-m);
    --lumo-space-wide-l: calc(var(--lumo-space-l) / 2) var(--lumo-space-l);
    --lumo-space-wide-xl: calc(var(--lumo-space-xl) / 2) var(--lumo-space-xl);

    /* Tall */
    --lumo-space-tall-xs: var(--lumo-space-xs) calc(var(--lumo-space-xs) / 2);
    --lumo-space-tall-s: var(--lumo-space-s) calc(var(--lumo-space-s) / 2);
    --lumo-space-tall-m: var(--lumo-space-m) calc(var(--lumo-space-m) / 2);
    --lumo-space-tall-l: var(--lumo-space-l) calc(var(--lumo-space-l) / 2);
    --lumo-space-tall-xl: var(--lumo-space-xl) calc(var(--lumo-space-xl) / 2);
  }
`;
$i("spacing-props", kd);
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Ad = ke`
  :host {
    /* Border radius */
    --lumo-border-radius-s: 0.25em; /* Checkbox, badge, date-picker year indicator, etc */
    --lumo-border-radius-m: var(--lumo-border-radius, 0.25em); /* Button, text field, menu overlay, etc */
    --lumo-border-radius-l: 0.5em; /* Dialog, notification, etc */

    /* Shadow */
    --lumo-box-shadow-xs: 0 1px 4px -1px var(--lumo-shade-50pct);
    --lumo-box-shadow-s: 0 2px 4px -1px var(--lumo-shade-20pct), 0 3px 12px -1px var(--lumo-shade-30pct);
    --lumo-box-shadow-m: 0 2px 6px -1px var(--lumo-shade-20pct), 0 8px 24px -4px var(--lumo-shade-40pct);
    --lumo-box-shadow-l: 0 3px 18px -2px var(--lumo-shade-20pct), 0 12px 48px -6px var(--lumo-shade-40pct);
    --lumo-box-shadow-xl: 0 4px 24px -3px var(--lumo-shade-20pct), 0 18px 64px -8px var(--lumo-shade-40pct);

    /* Clickable element cursor */
    --lumo-clickable-cursor: default;
  }
`;
ke`
  html {
    /* Button */
    --vaadin-button-background: var(--lumo-contrast-5pct);
    --vaadin-button-border: none;
    --vaadin-button-border-radius: var(--lumo-border-radius-m);
    --vaadin-button-font-size: var(--lumo-font-size-m);
    --vaadin-button-font-weight: 500;
    --vaadin-button-height: var(--lumo-size-m);
    --vaadin-button-margin: var(--lumo-space-xs) 0;
    --vaadin-button-min-width: calc(var(--vaadin-button-height) * 2);
    --vaadin-button-padding: 0 calc(var(--vaadin-button-height) / 3 + var(--lumo-border-radius-m) / 2);
    --vaadin-button-text-color: var(--lumo-primary-text-color);
    --vaadin-button-primary-background: var(--lumo-primary-color);
    --vaadin-button-primary-border: none;
    --vaadin-button-primary-font-weight: 600;
    --vaadin-button-primary-text-color: var(--lumo-primary-contrast-color);
    --vaadin-button-tertiary-background: transparent !important;
    --vaadin-button-tertiary-text-color: var(--lumo-primary-text-color);
    --vaadin-button-tertiary-font-weight: 500;
    --vaadin-button-tertiary-padding: 0 calc(var(--vaadin-button-height) / 6);
    /* Checkbox */
    --vaadin-checkbox-background: var(--lumo-contrast-20pct);
    --vaadin-checkbox-background-hover: var(--lumo-contrast-30pct);
    --vaadin-checkbox-border-radius: var(--lumo-border-radius-s);
    --vaadin-checkbox-checkmark-char: var(--lumo-icons-checkmark);
    --vaadin-checkbox-checkmark-char-indeterminate: '';
    --vaadin-checkbox-checkmark-color: var(--lumo-primary-contrast-color);
    --vaadin-checkbox-checkmark-size: calc(var(--vaadin-checkbox-size) + 2px);
    --vaadin-checkbox-label-color: var(--lumo-body-text-color);
    --vaadin-checkbox-label-font-size: var(--lumo-font-size-m);
    --vaadin-checkbox-label-padding: var(--lumo-space-xs) var(--lumo-space-s) var(--lumo-space-xs) var(--lumo-space-xs);
    --vaadin-checkbox-size: calc(var(--lumo-size-m) / 2);
    --vaadin-checkbox-disabled-checkmark-color: var(--lumo-contrast-30pct);
    --vaadin-checkbox-disabled-background: var(--lumo-contrast-10pct);
    /* Radio button */
    --vaadin-radio-button-background: var(--lumo-contrast-20pct);
    --vaadin-radio-button-background-hover: var(--lumo-contrast-30pct);
    --vaadin-radio-button-dot-color: var(--lumo-primary-contrast-color);
    --vaadin-radio-button-dot-size: 3px;
    --vaadin-radio-button-label-color: var(--lumo-body-text-color);
    --vaadin-radio-button-label-font-size: var(--lumo-font-size-m);
    --vaadin-radio-button-label-padding: var(--lumo-space-xs) var(--lumo-space-s) var(--lumo-space-xs)
      var(--lumo-space-xs);
    --vaadin-radio-button-size: calc(var(--lumo-size-m) / 2);
    --vaadin-radio-button-disabled-background: var(--lumo-contrast-10pct);
    --vaadin-radio-button-disabled-dot-color: var(--lumo-contrast-30pct);
    --vaadin-selection-color: var(--lumo-primary-color);
    --vaadin-selection-color-text: var(--lumo-primary-text-color);
    --vaadin-input-field-border-radius: var(--lumo-border-radius-m);
    --vaadin-focus-ring-color: var(--lumo-primary-color-50pct);
    --vaadin-focus-ring-width: 2px;
    /* Label */
    --vaadin-input-field-label-color: var(--lumo-secondary-text-color);
    --vaadin-input-field-focused-label-color: var(--lumo-primary-text-color);
    --vaadin-input-field-hovered-label-color: var(--lumo-body-text-color);
    --vaadin-input-field-label-font-size: var(--lumo-font-size-s);
    --vaadin-input-field-label-font-weight: 500;
    /* Helper */
    --vaadin-input-field-helper-color: var(--lumo-secondary-text-color);
    --vaadin-input-field-helper-font-size: var(--lumo-font-size-xs);
    --vaadin-input-field-helper-font-weight: 400;
    --vaadin-input-field-helper-spacing: 0.4em;
    /* Error message */
    --vaadin-input-field-error-color: var(--lumo-error-text-color);
    --vaadin-input-field-error-font-size: var(--lumo-font-size-xs);
    --vaadin-input-field-error-font-weight: 400;
    /* Input field */
    --vaadin-input-field-background: var(--lumo-contrast-10pct);
    --vaadin-input-field-icon-color: var(--lumo-contrast-60pct);
    --vaadin-input-field-icon-size: var(--lumo-icon-size-m);
    --vaadin-input-field-invalid-background: var(--lumo-error-color-10pct);
    --vaadin-input-field-invalid-hover-highlight: var(--lumo-error-color-50pct);
    --vaadin-input-field-disabled-background: var(--lumo-contrast-5pct);
    --vaadin-input-field-disabled-value-color: var(--lumo-disabled-text-color);
    --vaadin-input-field-height: var(--lumo-size-m);
    --vaadin-input-field-hover-highlight: var(--lumo-contrast-50pct);
    --vaadin-input-field-placeholder-color: var(--lumo-secondary-text-color);
    --vaadin-input-field-readonly-border: 1px dashed var(--lumo-contrast-30pct);
    --vaadin-input-field-value-color: var(--lumo-body-text-color);
    --vaadin-input-field-value-font-size: var(--lumo-font-size-m);
    --vaadin-input-field-value-font-weight: 500;
  }
`;
$i("style-props", Ad);
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Rd = ke`
  :host {
    /* prettier-ignore */
    --lumo-font-family: -apple-system, BlinkMacSystemFont, 'Roboto', 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';

    /* Font sizes */
    --lumo-font-size-xxs: 0.75rem;
    --lumo-font-size-xs: 0.8125rem;
    --lumo-font-size-s: 0.875rem;
    --lumo-font-size-m: 1rem;
    --lumo-font-size-l: 1.125rem;
    --lumo-font-size-xl: 1.375rem;
    --lumo-font-size-xxl: 1.75rem;
    --lumo-font-size-xxxl: 2.5rem;

    /* Line heights */
    --lumo-line-height-xs: 1.25;
    --lumo-line-height-s: 1.375;
    --lumo-line-height-m: 1.625;
  }
`, Id = ke`
  body,
  :host {
    font-family: var(--lumo-font-family);
    font-size: var(--lumo-font-size-m);
    line-height: var(--lumo-line-height-m);
    -webkit-text-size-adjust: 100%;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }

  small,
  [theme~='font-size-s'] {
    font-size: var(--lumo-font-size-s);
    line-height: var(--lumo-line-height-s);
  }

  [theme~='font-size-xs'] {
    font-size: var(--lumo-font-size-xs);
    line-height: var(--lumo-line-height-xs);
  }

  :where(h1, h2, h3, h4, h5, h6) {
    font-weight: 600;
    line-height: var(--lumo-line-height-xs);
    margin-block: 0;
  }

  :where(h1) {
    font-size: var(--lumo-font-size-xxxl);
  }

  :where(h2) {
    font-size: var(--lumo-font-size-xxl);
  }

  :where(h3) {
    font-size: var(--lumo-font-size-xl);
  }

  :where(h4) {
    font-size: var(--lumo-font-size-l);
  }

  :where(h5) {
    font-size: var(--lumo-font-size-m);
  }

  :where(h6) {
    font-size: var(--lumo-font-size-xs);
    text-transform: uppercase;
    letter-spacing: 0.03em;
  }

  p,
  blockquote {
    margin-top: 0.5em;
    margin-bottom: 0.75em;
  }

  a {
    text-decoration: none;
  }

  a:where(:any-link):hover {
    text-decoration: underline;
  }

  hr {
    display: block;
    align-self: stretch;
    height: 1px;
    border: 0;
    padding: 0;
    margin: var(--lumo-space-s) calc(var(--lumo-border-radius-m) / 2);
    background-color: var(--lumo-contrast-10pct);
  }

  blockquote {
    border-left: 2px solid var(--lumo-contrast-30pct);
  }

  b,
  strong {
    font-weight: 600;
  }

  /* RTL specific styles */
  blockquote[dir='rtl'] {
    border-left: none;
    border-right: 2px solid var(--lumo-contrast-30pct);
  }
`;
Ke("", Id, { moduleId: "lumo-typography" });
$i("typography-props", Rd);
Ke(
  "vaadin-grid",
  ke`
    :host {
      font-family: var(--lumo-font-family);
      font-size: var(--lumo-font-size-m);
      line-height: var(--lumo-line-height-s);
      color: var(--lumo-body-text-color);
      background-color: var(--lumo-base-color);
      box-sizing: border-box;
      -webkit-text-size-adjust: 100%;
      -webkit-tap-highlight-color: transparent;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      --_focus-ring-color: var(--vaadin-focus-ring-color, var(--lumo-primary-color-50pct));
      --_focus-ring-width: var(--vaadin-focus-ring-width, 2px);
      /* For internal use only */
      --_lumo-grid-border-color: var(--lumo-contrast-20pct);
      --_lumo-grid-secondary-border-color: var(--lumo-contrast-10pct);
      --_lumo-grid-border-width: 1px;
      --_lumo-grid-selected-row-color: var(--lumo-primary-color-10pct);
    }

    /* No (outer) border */

    :host(:not([theme~='no-border'])) {
      border: var(--_lumo-grid-border-width) solid var(--_lumo-grid-border-color);
    }

    :host([disabled]) {
      opacity: 0.7;
    }

    /* Cell styles */

    [part~='cell'] {
      min-height: var(--lumo-size-m);
      background-color: var(--vaadin-grid-cell-background, var(--lumo-base-color));
      cursor: default;
      --_cell-padding: var(--vaadin-grid-cell-padding, var(--_cell-default-padding));
      --_cell-default-padding: var(--lumo-space-xs) var(--lumo-space-m);
    }

    [part~='cell'] ::slotted(vaadin-grid-cell-content) {
      cursor: inherit;
      padding: var(--_cell-padding);
    }

    /* Apply row borders by default and introduce the "no-row-borders" variant */
    :host(:not([theme~='no-row-borders'])) [part~='cell']:not([part~='details-cell']) {
      border-top: var(--_lumo-grid-border-width) solid var(--_lumo-grid-secondary-border-color);
    }

    /* Hide first body row top border */
    :host(:not([theme~='no-row-borders'])) [part~='first-row'] [part~='cell']:not([part~='details-cell']) {
      border-top: 0;
      min-height: calc(var(--lumo-size-m) - var(--_lumo-grid-border-width));
    }

    /* Focus-ring */

    [part~='row'] {
      position: relative;
    }

    [part~='row']:focus,
    [part~='focused-cell']:focus {
      outline: none;
    }

    :host([navigating]) [part~='row']:focus::before,
    :host([navigating]) [part~='focused-cell']:focus::before {
      content: '';
      position: absolute;
      inset: 0;
      pointer-events: none;
      box-shadow: inset 0 0 0 var(--_focus-ring-width) var(--_focus-ring-color);
    }

    :host([navigating]) [part~='row']:focus::before {
      transform: translateX(calc(-1 * var(--_grid-horizontal-scroll-position)));
      z-index: 3;
    }

    /* Empty state */
    [part~='empty-state'] {
      padding: var(--lumo-space-m);
      color: var(--lumo-secondary-text-color);
    }

    /* Drag and Drop styles */
    :host([dragover])::after {
      content: '';
      position: absolute;
      z-index: 100;
      inset: 0;
      pointer-events: none;
      box-shadow: inset 0 0 0 var(--_focus-ring-width) var(--_focus-ring-color);
    }

    [part~='row'][dragover] {
      z-index: 100 !important;
    }

    [part~='row'][dragover] [part~='cell'] {
      overflow: visible;
    }

    [part~='row'][dragover] [part~='cell']::after {
      content: '';
      position: absolute;
      inset: 0;
      height: calc(var(--_lumo-grid-border-width) + 2px);
      pointer-events: none;
      background: var(--lumo-primary-color-50pct);
    }

    [part~='row'][dragover] [part~='cell'][last-frozen]::after {
      right: -1px;
    }

    :host([theme~='no-row-borders']) [dragover] [part~='cell']::after {
      height: 2px;
    }

    [part~='row'][dragover='below'] [part~='cell']::after {
      top: 100%;
      bottom: auto;
      margin-top: -1px;
    }

    :host([all-rows-visible]) [part~='last-row'][dragover='below'] [part~='cell']::after {
      height: 1px;
    }

    [part~='row'][dragover='above'] [part~='cell']::after {
      top: auto;
      bottom: 100%;
      margin-bottom: -1px;
    }

    [part~='row'][details-opened][dragover='below'] [part~='cell']:not([part~='details-cell'])::after,
    [part~='row'][details-opened][dragover='above'] [part~='details-cell']::after {
      display: none;
    }

    [part~='row'][dragover][dragover='on-top'] [part~='cell']::after {
      height: 100%;
      opacity: 0.5;
    }

    [part~='row'][dragstart] [part~='cell'] {
      border: none !important;
      box-shadow: none !important;
    }

    [part~='row'][dragstart] [part~='cell'][last-column] {
      border-radius: 0 var(--lumo-border-radius-s) var(--lumo-border-radius-s) 0;
    }

    [part~='row'][dragstart] [part~='cell'][first-column] {
      border-radius: var(--lumo-border-radius-s) 0 0 var(--lumo-border-radius-s);
    }

    #scroller [part~='row'][dragstart]:not([dragstart=''])::after {
      display: block;
      position: absolute;
      left: var(--_grid-drag-start-x);
      top: var(--_grid-drag-start-y);
      z-index: 100;
      content: attr(dragstart);
      align-items: center;
      justify-content: center;
      box-sizing: border-box;
      padding: calc(var(--lumo-space-xs) * 0.8);
      color: var(--lumo-error-contrast-color);
      background-color: var(--lumo-error-color);
      border-radius: var(--lumo-border-radius-m);
      font-family: var(--lumo-font-family);
      font-size: var(--lumo-font-size-xxs);
      line-height: 1;
      font-weight: 500;
      text-transform: initial;
      letter-spacing: initial;
      min-width: calc(var(--lumo-size-s) * 0.7);
      text-align: center;
    }

    /* Headers and footers */

    [part~='header-cell'],
    [part~='footer-cell'],
    [part~='reorder-ghost'] {
      font-size: var(--lumo-font-size-s);
      font-weight: 500;
    }

    [part~='footer-cell'] {
      font-weight: 400;
    }

    [part~='row']:only-child [part~='header-cell'] {
      min-height: var(--lumo-size-xl);
    }

    /* Header borders */

    /* Hide first header row top border */
    :host(:not([theme~='no-row-borders'])) [part~='row']:first-child [part~='header-cell'] {
      border-top: 0;
    }

    /* Hide header row top border if previous row is hidden */
    [part~='row'][hidden] + [part~='row'] [part~='header-cell'] {
      border-top: 0;
    }

    [part~='row']:last-child [part~='header-cell'] {
      border-bottom: var(--_lumo-grid-border-width) solid transparent;
    }

    :host(:not([theme~='no-row-borders'])) [part~='row']:last-child [part~='header-cell'] {
      border-bottom-color: var(--_lumo-grid-secondary-border-color);
    }

    /* Overflow uses a stronger border color */
    :host([overflow~='top']) [part~='row']:last-child [part~='header-cell'] {
      border-bottom-color: var(--_lumo-grid-border-color);
    }

    /* Footer borders */

    [part~='row']:first-child [part~='footer-cell'] {
      border-top: var(--_lumo-grid-border-width) solid transparent;
    }

    :host(:not([theme~='no-row-borders'])) [part~='row']:first-child [part~='footer-cell'] {
      border-top-color: var(--_lumo-grid-secondary-border-color);
    }

    /* Overflow uses a stronger border color */
    :host([overflow~='bottom']) [part~='row']:first-child [part~='footer-cell'] {
      border-top-color: var(--_lumo-grid-border-color);
    }

    /* Column reordering */

    :host([reordering]) [part~='cell'] {
      background: linear-gradient(var(--lumo-shade-20pct), var(--lumo-shade-20pct)) var(--lumo-base-color);
    }

    :host([reordering]) [part~='cell'][reorder-status='allowed'] {
      background: var(--lumo-base-color);
    }

    :host([reordering]) [part~='cell'][reorder-status='dragging'] {
      background: linear-gradient(var(--lumo-contrast-5pct), var(--lumo-contrast-5pct)) var(--lumo-base-color);
    }

    [part~='reorder-ghost'] {
      opacity: 0.85;
      box-shadow: var(--lumo-box-shadow-s);
      /* TODO Use the same styles as for the cell element (reorder-ghost copies styles from the cell element) */
      padding: var(--lumo-space-s) var(--lumo-space-m) !important;
    }

    /* Column resizing */

    [part='resize-handle'] {
      --_resize-handle-width: 3px;
      width: var(--_resize-handle-width);
      background-color: var(--lumo-primary-color-50pct);
      opacity: 0;
      transition: opacity 0.2s;
    }

    [part='resize-handle']::before {
      transform: translateX(calc(-50% + var(--_resize-handle-width) / 2));
      width: var(--lumo-size-s);
    }

    :host(:not([reordering])) *:not([column-resizing]) [part~='cell']:hover [part='resize-handle'],
    [part='resize-handle']:active {
      opacity: 1;
      transition-delay: 0.15s;
    }

    /* Column borders */

    :host([theme~='column-borders']) [part~='cell']:not([last-column]):not([part~='details-cell']) {
      border-right: var(--_lumo-grid-border-width) solid var(--_lumo-grid-secondary-border-color);
    }

    /* Frozen columns */

    [last-frozen] {
      border-right: var(--_lumo-grid-border-width) solid transparent;
      overflow: hidden;
    }

    :host([overflow~='start']) [part~='cell'][last-frozen]:not([part~='details-cell']) {
      border-right-color: var(--_lumo-grid-border-color);
    }

    [first-frozen-to-end] {
      border-left: var(--_lumo-grid-border-width) solid transparent;
    }

    :host([overflow~='end']) [part~='cell'][first-frozen-to-end]:not([part~='details-cell']) {
      border-left-color: var(--_lumo-grid-border-color);
    }

    /* Row stripes */

    :host([theme~='row-stripes']) [part~='even-row'] [part~='body-cell'],
    :host([theme~='row-stripes']) [part~='even-row'] [part~='details-cell'] {
      background-image: linear-gradient(var(--lumo-contrast-5pct), var(--lumo-contrast-5pct));
      background-repeat: repeat-x;
    }

    /* Selected row */

    /* Raise the selected rows above unselected rows (so that box-shadow can cover unselected rows) */
    :host(:not([reordering])) [part~='row'][selected] {
      z-index: 1;
    }

    :host(:not([reordering])) [part~='row'][selected] [part~='body-cell']:not([part~='details-cell']) {
      background-image: linear-gradient(var(--_lumo-grid-selected-row-color), var(--_lumo-grid-selected-row-color));
      background-repeat: repeat;
    }

    /* Cover the border of an unselected row */
    :host(:not([theme~='no-row-borders'])) [part~='row'][selected] [part~='cell']:not([part~='details-cell']) {
      box-shadow: 0 var(--_lumo-grid-border-width) 0 0 var(--_lumo-grid-selected-row-color);
    }

    /* Compact */

    :host([theme~='compact']) [part~='row']:only-child [part~='header-cell'] {
      min-height: var(--lumo-size-m);
    }

    :host([theme~='compact']) [part~='cell'] {
      min-height: var(--lumo-size-s);
      --_cell-default-padding: var(--lumo-space-xs) var(--lumo-space-s);
    }

    :host([theme~='compact']) [part~='first-row'] [part~='cell']:not([part~='details-cell']) {
      min-height: calc(var(--lumo-size-s) - var(--_lumo-grid-border-width));
    }

    :host([theme~='compact']) [part~='empty-state'] {
      padding: var(--lumo-space-s);
    }

    /* Wrap cell contents */

    :host([theme~='wrap-cell-content']) [part~='cell'] ::slotted(vaadin-grid-cell-content) {
      white-space: normal;
    }

    /* RTL specific styles */

    :host([dir='rtl']) [part~='row'][dragstart] [part~='cell'][last-column] {
      border-radius: var(--lumo-border-radius-s) 0 0 var(--lumo-border-radius-s);
    }

    :host([dir='rtl']) [part~='row'][dragstart] [part~='cell'][first-column] {
      border-radius: 0 var(--lumo-border-radius-s) var(--lumo-border-radius-s) 0;
    }

    :host([dir='rtl'][theme~='column-borders']) [part~='cell']:not([last-column]):not([part~='details-cell']) {
      border-right: none;
      border-left: var(--_lumo-grid-border-width) solid var(--_lumo-grid-secondary-border-color);
    }

    :host([dir='rtl']) [last-frozen] {
      border-right: none;
      border-left: var(--_lumo-grid-border-width) solid transparent;
    }

    :host([dir='rtl']) [first-frozen-to-end] {
      border-left: none;
      border-right: var(--_lumo-grid-border-width) solid transparent;
    }

    :host([dir='rtl'][overflow~='start']) [part~='cell'][last-frozen]:not([part~='details-cell']) {
      border-left-color: var(--_lumo-grid-border-color);
    }

    :host([dir='rtl'][overflow~='end']) [part~='cell'][first-frozen-to-end]:not([part~='details-cell']) {
      border-right-color: var(--_lumo-grid-border-color);
    }
  `,
  { moduleId: "lumo-grid" }
);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
window.JSCompiler_renameProperty = function(s, r) {
  return s;
};
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
let Dd = /(url\()([^)]*)(\))/g, Od = /(^\/[^\/])|(^#)|(^[\w-\d]*:)/, gn, gt;
function Pr(s, r) {
  if (s && Od.test(s) || s === "//")
    return s;
  if (gn === void 0) {
    gn = !1;
    try {
      const e = new URL("b", "http://a");
      e.pathname = "c%20d", gn = e.href === "http://a/c%20d";
    } catch {
    }
  }
  if (r || (r = document.baseURI || window.location.href), gn)
    try {
      return new URL(s, r).href;
    } catch {
      return s;
    }
  return gt || (gt = document.implementation.createHTMLDocument("temp"), gt.base = gt.createElement("base"), gt.head.appendChild(gt.base), gt.anchor = gt.createElement("a"), gt.body.appendChild(gt.anchor)), gt.base.href = r, gt.anchor.href = s, gt.anchor.href || s;
}
function Fs(s, r) {
  return s.replace(Dd, function(e, t, i, n) {
    return t + "'" + Pr(i.replace(/["']/g, ""), r) + "'" + n;
  });
}
function Ms(s) {
  return s.substring(0, s.lastIndexOf("/") + 1);
}
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const zd = !window.ShadyDOM || !window.ShadyDOM.inUse;
!window.ShadyCSS || window.ShadyCSS.nativeCss;
const Fd = zd && "adoptedStyleSheets" in Document.prototype && "replaceSync" in CSSStyleSheet.prototype && // Since spec may change, feature detect exact API we need
(() => {
  try {
    const s = new CSSStyleSheet();
    s.replaceSync("");
    const r = document.createElement("div");
    return r.attachShadow({ mode: "open" }), r.shadowRoot.adoptedStyleSheets = [s], r.shadowRoot.adoptedStyleSheets[0] === s;
  } catch {
    return !1;
  }
})();
let Md = window.Polymer && window.Polymer.rootPath || Ms(document.baseURI || window.location.href), Bn = window.Polymer && window.Polymer.sanitizeDOMValue || void 0;
window.Polymer && window.Polymer.setPassiveTouchGestures;
let hs = window.Polymer && window.Polymer.strictTemplatePolicy || !1, Ld = window.Polymer && window.Polymer.allowTemplateFromDomModule || !1, Bd = window.Polymer && window.Polymer.legacyOptimizations || !1, Nd = window.Polymer && window.Polymer.legacyWarnings || !1, Hd = window.Polymer && window.Polymer.syncInitialRender || !1, ds = window.Polymer && window.Polymer.legacyUndefined || !1, Vd = window.Polymer && window.Polymer.orderedComputed || !1, Ya = window.Polymer && window.Polymer.removeNestedTemplates || !1, Ud = window.Polymer && window.Polymer.fastDomIf || !1;
window.Polymer && window.Polymer.suppressTemplateNotifications;
window.Polymer && window.Polymer.legacyNoObservedAttributes;
let Wd = window.Polymer && window.Polymer.useAdoptedStyleSheetsWithBuiltCSS || !1;
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
let jd = 0;
const $e = function(s) {
  let r = (
    /** @type {!MixinFunction} */
    s.__mixinApplications
  );
  r || (r = /* @__PURE__ */ new WeakMap(), s.__mixinApplications = r);
  let e = jd++;
  function t(i) {
    let n = (
      /** @type {!MixinFunction} */
      i.__mixinSet
    );
    if (n && n[e])
      return i;
    let o = r, a = o.get(i);
    if (!a) {
      a = /** @type {!Function} */
      s(i), o.set(i, a);
      let l = Object.create(
        /** @type {!MixinFunction} */
        a.__mixinSet || n || null
      );
      l[e] = !0, a.__mixinSet = l;
    }
    return a;
  }
  return t;
};
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
let Ls = {}, hc = {};
function Xa(s, r) {
  Ls[s] = hc[s.toLowerCase()] = r;
}
function Ja(s) {
  return Ls[s] || hc[s.toLowerCase()];
}
function Gd(s) {
  s.querySelector("style") && console.warn("dom-module %s has style outside template", s.id);
}
class Dr extends HTMLElement {
  /** @override */
  static get observedAttributes() {
    return ["id"];
  }
  /**
   * Retrieves the element specified by the css `selector` in the module
   * registered by `id`. For example, this.import('foo', 'img');
   * @param {string} id The id of the dom-module in which to search.
   * @param {string=} selector The css selector by which to find the element.
   * @return {Element} Returns the element which matches `selector` in the
   * module registered at the specified `id`.
   *
   * @export
   * @nocollapse Referred to indirectly in style-gather.js
   */
  static import(r, e) {
    if (r) {
      let t = Ja(r);
      return t && e ? t.querySelector(e) : t;
    }
    return null;
  }
  /* eslint-disable no-unused-vars */
  /**
   * @param {string} name Name of attribute.
   * @param {?string} old Old value of attribute.
   * @param {?string} value Current value of attribute.
   * @param {?string} namespace Attribute namespace.
   * @return {void}
   * @override
   */
  attributeChangedCallback(r, e, t, i) {
    e !== t && this.register();
  }
  /* eslint-enable no-unused-args */
  /**
   * The absolute URL of the original location of this `dom-module`.
   *
   * This value will differ from this element's `ownerDocument` in the
   * following ways:
   * - Takes into account any `assetpath` attribute added during bundling
   *   to indicate the original location relative to the bundled location
   * - Uses the HTMLImports polyfill's `importForElement` API to ensure
   *   the path is relative to the import document's location since
   *   `ownerDocument` is not currently polyfilled
   */
  get assetpath() {
    if (!this.__assetpath) {
      const r = window.HTMLImports && HTMLImports.importForElement ? HTMLImports.importForElement(this) || document : this.ownerDocument, e = Pr(
        this.getAttribute("assetpath") || "",
        r.baseURI
      );
      this.__assetpath = Ms(e);
    }
    return this.__assetpath;
  }
  /**
   * Registers the dom-module at a given id. This method should only be called
   * when a dom-module is imperatively created. For
   * example, `document.createElement('dom-module').register('foo')`.
   * @param {string=} id The id at which to register the dom-module.
   * @return {void}
   */
  register(r) {
    if (r = r || this.id, r) {
      if (hs && Ja(r) !== void 0)
        throw Xa(r, null), new Error(`strictTemplatePolicy: dom-module ${r} re-registered`);
      this.id = r, Xa(r, this), Gd(this);
    }
  }
}
Dr.prototype.modules = Ls;
customElements.define("dom-module", Dr);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const qd = "link[rel=import][type~=css]", Kd = "include", Qa = "shady-unscoped";
function dc(s) {
  return (
    /** @type {?DomModule} */
    Dr.import(s)
  );
}
function $a(s) {
  let r = s.body ? s.body : s;
  const e = Fs(
    r.textContent,
    s.baseURI
  ), t = document.createElement("style");
  return t.textContent = e, t;
}
function Zd(s) {
  const r = s.trim().split(/\s+/), e = [];
  for (let t = 0; t < r.length; t++)
    e.push(...Yd(r[t]));
  return e;
}
function Yd(s) {
  const r = dc(s);
  if (!r)
    return console.warn("Could not find style data in module named", s), [];
  if (r._styles === void 0) {
    const e = [];
    e.push(...fc(r));
    const t = (
      /** @type {?HTMLTemplateElement} */
      r.querySelector("template")
    );
    t && e.push(...uc(
      t,
      /** @type {templateWithAssetPath} */
      r.assetpath
    )), r._styles = e;
  }
  return r._styles;
}
function uc(s, r) {
  if (!s._styles) {
    const e = [], t = s.content.querySelectorAll("style");
    for (let i = 0; i < t.length; i++) {
      let n = t[i], o = n.getAttribute(Kd);
      o && e.push(...Zd(o).filter(function(a, l, h) {
        return h.indexOf(a) === l;
      })), r && (n.textContent = Fs(
        n.textContent,
        /** @type {string} */
        r
      )), e.push(n);
    }
    s._styles = e;
  }
  return s._styles;
}
function Xd(s) {
  let r = dc(s);
  return r ? fc(r) : [];
}
function fc(s) {
  const r = [], e = s.querySelectorAll(qd);
  for (let t = 0; t < e.length; t++) {
    let i = e[t];
    if (i.import) {
      const n = i.import, o = i.hasAttribute(Qa);
      if (o && !n._unscopedStyle) {
        const a = $a(n);
        a.setAttribute(Qa, ""), n._unscopedStyle = a;
      } else n._style || (n._style = $a(n));
      r.push(o ? n._unscopedStyle : n._style);
    }
  }
  return r;
}
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const _i = window.ShadyDOM && window.ShadyDOM.noPatch && window.ShadyDOM.wrap ? window.ShadyDOM.wrap : window.ShadyDOM ? (s) => ShadyDOM.patch(s) : (s) => s;
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
function us(s) {
  return s.indexOf(".") >= 0;
}
function Ei(s) {
  let r = s.indexOf(".");
  return r === -1 ? s : s.slice(0, r);
}
function Jd(s, r) {
  return s.indexOf(r + ".") === 0;
}
function Nn(s, r) {
  return r.indexOf(s + ".") === 0;
}
function Hn(s, r, e) {
  return r + e.slice(s.length);
}
function wr(s) {
  if (Array.isArray(s)) {
    let r = [];
    for (let e = 0; e < s.length; e++) {
      let t = s[e].toString().split(".");
      for (let i = 0; i < t.length; i++)
        r.push(t[i]);
    }
    return r.join(".");
  } else
    return s;
}
function pc(s) {
  return Array.isArray(s) ? wr(s).split(".") : s.toString().split(".");
}
function ht(s, r, e) {
  let t = s, i = pc(r);
  for (let n = 0; n < i.length; n++) {
    if (!t)
      return;
    let o = i[n];
    t = t[o];
  }
  return e && (e.path = i.join(".")), t;
}
function el(s, r, e) {
  let t = s, i = pc(r), n = i[i.length - 1];
  if (i.length > 1) {
    for (let o = 0; o < i.length - 1; o++) {
      let a = i[o];
      if (t = t[a], !t)
        return;
    }
    t[n] = e;
  } else
    t[r] = e;
  return i.join(".");
}
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const Vn = {}, Qd = /-[a-z]/g, $d = /([A-Z])/g;
function gc(s) {
  return Vn[s] || (Vn[s] = s.indexOf("-") < 0 ? s : s.replace(
    Qd,
    (r) => r[1].toUpperCase()
  ));
}
function Xn(s) {
  return Vn[s] || (Vn[s] = s.replace($d, "-$1").toLowerCase());
}
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
let eu = 0, mc = 0, Vi = [], tu = 0, fs = !1, vc = document.createTextNode("");
new window.MutationObserver(iu).observe(vc, { characterData: !0 });
function iu() {
  fs = !1;
  const s = Vi.length;
  for (let r = 0; r < s; r++) {
    let e = Vi[r];
    if (e)
      try {
        e();
      } catch (t) {
        setTimeout(() => {
          throw t;
        });
      }
  }
  Vi.splice(0, s), mc += s;
}
const ru = {
  /**
   * Enqueues a function called at microtask timing.
   *
   * @memberof microTask
   * @param {!Function=} callback Callback to run
   * @return {number} Handle used for canceling task
   */
  run(s) {
    return fs || (fs = !0, vc.textContent = tu++), Vi.push(s), eu++;
  },
  /**
   * Cancels a previously enqueued `microTask` callback.
   *
   * @memberof microTask
   * @param {number} handle Handle returned from `run` of callback to cancel
   * @return {void}
   */
  cancel(s) {
    const r = s - mc;
    if (r >= 0) {
      if (!Vi[r])
        throw new Error("invalid async handle: " + s);
      Vi[r] = null;
    }
  }
};
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const nu = ru, _c = $e(
  /**
   * @template T
   * @param {function(new:T)} superClass Class to apply mixin to.
   * @return {function(new:T)} superClass with mixin applied.
   */
  (s) => {
    class r extends s {
      /**
       * Creates property accessors for the given property names.
       * @param {!Object} props Object whose keys are names of accessors.
       * @return {void}
       * @protected
       * @nocollapse
       */
      static createProperties(t) {
        const i = this.prototype;
        for (let n in t)
          n in i || i._createPropertyAccessor(n);
      }
      /**
       * Returns an attribute name that corresponds to the given property.
       * The attribute name is the lowercased property name. Override to
       * customize this mapping.
       * @param {string} property Property to convert
       * @return {string} Attribute name corresponding to the given property.
       *
       * @protected
       * @nocollapse
       */
      static attributeNameForProperty(t) {
        return t.toLowerCase();
      }
      /**
       * Override point to provide a type to which to deserialize a value to
       * a given property.
       * @param {string} name Name of property
       *
       * @protected
       * @nocollapse
       */
      static typeForProperty(t) {
      }
      //eslint-disable-line no-unused-vars
      /**
       * Creates a setter/getter pair for the named property with its own
       * local storage.  The getter returns the value in the local storage,
       * and the setter calls `_setProperty`, which updates the local storage
       * for the property and enqueues a `_propertiesChanged` callback.
       *
       * This method may be called on a prototype or an instance.  Calling
       * this method may overwrite a property value that already exists on
       * the prototype/instance by creating the accessor.
       *
       * @param {string} property Name of the property
       * @param {boolean=} readOnly When true, no setter is created; the
       *   protected `_setProperty` function must be used to set the property
       * @return {void}
       * @protected
       * @override
       */
      _createPropertyAccessor(t, i) {
        this._addPropertyToAttributeMap(t), this.hasOwnProperty(JSCompiler_renameProperty("__dataHasAccessor", this)) || (this.__dataHasAccessor = Object.assign({}, this.__dataHasAccessor)), this.__dataHasAccessor[t] || (this.__dataHasAccessor[t] = !0, this._definePropertyAccessor(t, i));
      }
      /**
       * Adds the given `property` to a map matching attribute names
       * to property names, using `attributeNameForProperty`. This map is
       * used when deserializing attribute values to properties.
       *
       * @param {string} property Name of the property
       * @override
       */
      _addPropertyToAttributeMap(t) {
        this.hasOwnProperty(JSCompiler_renameProperty("__dataAttributes", this)) || (this.__dataAttributes = Object.assign({}, this.__dataAttributes));
        let i = this.__dataAttributes[t];
        return i || (i = this.constructor.attributeNameForProperty(t), this.__dataAttributes[i] = t), i;
      }
      /**
       * Defines a property accessor for the given property.
       * @param {string} property Name of the property
       * @param {boolean=} readOnly When true, no setter is created
       * @return {void}
       * @override
       */
      _definePropertyAccessor(t, i) {
        Object.defineProperty(this, t, {
          /* eslint-disable valid-jsdoc */
          /** @this {PropertiesChanged} */
          get() {
            return this.__data[t];
          },
          /** @this {PropertiesChanged} */
          set: i ? function() {
          } : function(n) {
            this._setPendingProperty(t, n, !0) && this._invalidateProperties();
          }
          /* eslint-enable */
        });
      }
      constructor() {
        super(), this.__dataEnabled = !1, this.__dataReady = !1, this.__dataInvalid = !1, this.__data = {}, this.__dataPending = null, this.__dataOld = null, this.__dataInstanceProps = null, this.__dataCounter = 0, this.__serializing = !1, this._initializeProperties();
      }
      /**
       * Lifecycle callback called when properties are enabled via
       * `_enableProperties`.
       *
       * Users may override this function to implement behavior that is
       * dependent on the element having its property data initialized, e.g.
       * from defaults (initialized from `constructor`, `_initializeProperties`),
       * `attributeChangedCallback`, or values propagated from host e.g. via
       * bindings.  `super.ready()` must be called to ensure the data system
       * becomes enabled.
       *
       * @return {void}
       * @public
       * @override
       */
      ready() {
        this.__dataReady = !0, this._flushProperties();
      }
      /**
       * Initializes the local storage for property accessors.
       *
       * Provided as an override point for performing any setup work prior
       * to initializing the property accessor system.
       *
       * @return {void}
       * @protected
       * @override
       */
      _initializeProperties() {
        for (let t in this.__dataHasAccessor)
          this.hasOwnProperty(t) && (this.__dataInstanceProps = this.__dataInstanceProps || {}, this.__dataInstanceProps[t] = this[t], delete this[t]);
      }
      /**
       * Called at ready time with bag of instance properties that overwrote
       * accessors when the element upgraded.
       *
       * The default implementation sets these properties back into the
       * setter at ready time.  This method is provided as an override
       * point for customizing or providing more efficient initialization.
       *
       * @param {Object} props Bag of property values that were overwritten
       *   when creating property accessors.
       * @return {void}
       * @protected
       * @override
       */
      _initializeInstanceProperties(t) {
        Object.assign(this, t);
      }
      /**
       * Updates the local storage for a property (via `_setPendingProperty`)
       * and enqueues a `_proeprtiesChanged` callback.
       *
       * @param {string} property Name of the property
       * @param {*} value Value to set
       * @return {void}
       * @protected
       * @override
       */
      _setProperty(t, i) {
        this._setPendingProperty(t, i) && this._invalidateProperties();
      }
      /**
       * Returns the value for the given property.
       * @param {string} property Name of property
       * @return {*} Value for the given property
       * @protected
       * @override
       */
      _getProperty(t) {
        return this.__data[t];
      }
      /* eslint-disable no-unused-vars */
      /**
       * Updates the local storage for a property, records the previous value,
       * and adds it to the set of "pending changes" that will be passed to the
       * `_propertiesChanged` callback.  This method does not enqueue the
       * `_propertiesChanged` callback.
       *
       * @param {string} property Name of the property
       * @param {*} value Value to set
       * @param {boolean=} ext Not used here; affordance for closure
       * @return {boolean} Returns true if the property changed
       * @protected
       * @override
       */
      _setPendingProperty(t, i, n) {
        let o = this.__data[t], a = this._shouldPropertyChange(t, i, o);
        return a && (this.__dataPending || (this.__dataPending = {}, this.__dataOld = {}), this.__dataOld && !(t in this.__dataOld) && (this.__dataOld[t] = o), this.__data[t] = i, this.__dataPending[t] = i), a;
      }
      /* eslint-enable */
      /**
       * @param {string} property Name of the property
       * @return {boolean} Returns true if the property is pending.
       */
      _isPropertyPending(t) {
        return !!(this.__dataPending && this.__dataPending.hasOwnProperty(t));
      }
      /**
       * Marks the properties as invalid, and enqueues an async
       * `_propertiesChanged` callback.
       *
       * @return {void}
       * @protected
       * @override
       */
      _invalidateProperties() {
        !this.__dataInvalid && this.__dataReady && (this.__dataInvalid = !0, nu.run(() => {
          this.__dataInvalid && (this.__dataInvalid = !1, this._flushProperties());
        }));
      }
      /**
       * Call to enable property accessor processing. Before this method is
       * called accessor values will be set but side effects are
       * queued. When called, any pending side effects occur immediately.
       * For elements, generally `connectedCallback` is a normal spot to do so.
       * It is safe to call this method multiple times as it only turns on
       * property accessors once.
       *
       * @return {void}
       * @protected
       * @override
       */
      _enableProperties() {
        this.__dataEnabled || (this.__dataEnabled = !0, this.__dataInstanceProps && (this._initializeInstanceProperties(this.__dataInstanceProps), this.__dataInstanceProps = null), this.ready());
      }
      /**
       * Calls the `_propertiesChanged` callback with the current set of
       * pending changes (and old values recorded when pending changes were
       * set), and resets the pending set of changes. Generally, this method
       * should not be called in user code.
       *
       * @return {void}
       * @protected
       * @override
       */
      _flushProperties() {
        this.__dataCounter++;
        const t = this.__data, i = this.__dataPending, n = this.__dataOld;
        this._shouldPropertiesChange(t, i, n) && (this.__dataPending = null, this.__dataOld = null, this._propertiesChanged(t, i, n)), this.__dataCounter--;
      }
      /**
       * Called in `_flushProperties` to determine if `_propertiesChanged`
       * should be called. The default implementation returns true if
       * properties are pending. Override to customize when
       * `_propertiesChanged` is called.
       * @param {!Object} currentProps Bag of all current accessor values
       * @param {?Object} changedProps Bag of properties changed since the last
       *   call to `_propertiesChanged`
       * @param {?Object} oldProps Bag of previous values for each property
       *   in `changedProps`
       * @return {boolean} true if changedProps is truthy
       * @override
       */
      _shouldPropertiesChange(t, i, n) {
        return !!i;
      }
      /**
       * Callback called when any properties with accessors created via
       * `_createPropertyAccessor` have been set.
       *
       * @param {!Object} currentProps Bag of all current accessor values
       * @param {?Object} changedProps Bag of properties changed since the last
       *   call to `_propertiesChanged`
       * @param {?Object} oldProps Bag of previous values for each property
       *   in `changedProps`
       * @return {void}
       * @protected
       * @override
       */
      _propertiesChanged(t, i, n) {
      }
      /**
       * Method called to determine whether a property value should be
       * considered as a change and cause the `_propertiesChanged` callback
       * to be enqueued.
       *
       * The default implementation returns `true` if a strict equality
       * check fails. The method always returns false for `NaN`.
       *
       * Override this method to e.g. provide stricter checking for
       * Objects/Arrays when using immutable patterns.
       *
       * @param {string} property Property name
       * @param {*} value New property value
       * @param {*} old Previous property value
       * @return {boolean} Whether the property should be considered a change
       *   and enqueue a `_proeprtiesChanged` callback
       * @protected
       * @override
       */
      _shouldPropertyChange(t, i, n) {
        return (
          // Strict equality check
          n !== i && // This ensures (old==NaN, value==NaN) always returns false
          (n === n || i === i)
        );
      }
      /**
       * Implements native Custom Elements `attributeChangedCallback` to
       * set an attribute value to a property via `_attributeToProperty`.
       *
       * @param {string} name Name of attribute that changed
       * @param {?string} old Old attribute value
       * @param {?string} value New attribute value
       * @param {?string} namespace Attribute namespace.
       * @return {void}
       * @suppress {missingProperties} Super may or may not implement the callback
       * @override
       */
      attributeChangedCallback(t, i, n, o) {
        i !== n && this._attributeToProperty(t, n), super.attributeChangedCallback && super.attributeChangedCallback(t, i, n, o);
      }
      /**
       * Deserializes an attribute to its associated property.
       *
       * This method calls the `_deserializeValue` method to convert the string to
       * a typed value.
       *
       * @param {string} attribute Name of attribute to deserialize.
       * @param {?string} value of the attribute.
       * @param {*=} type type to deserialize to, defaults to the value
       * returned from `typeForProperty`
       * @return {void}
       * @override
       */
      _attributeToProperty(t, i, n) {
        if (!this.__serializing) {
          const o = this.__dataAttributes, a = o && o[t] || t;
          this[a] = this._deserializeValue(i, n || this.constructor.typeForProperty(a));
        }
      }
      /**
       * Serializes a property to its associated attribute.
       *
       * @suppress {invalidCasts} Closure can't figure out `this` is an element.
       *
       * @param {string} property Property name to reflect.
       * @param {string=} attribute Attribute name to reflect to.
       * @param {*=} value Property value to refect.
       * @return {void}
       * @override
       */
      _propertyToAttribute(t, i, n) {
        this.__serializing = !0, n = arguments.length < 3 ? this[t] : n, this._valueToNodeAttribute(
          /** @type {!HTMLElement} */
          this,
          n,
          i || this.constructor.attributeNameForProperty(t)
        ), this.__serializing = !1;
      }
      /**
       * Sets a typed value to an HTML attribute on a node.
       *
       * This method calls the `_serializeValue` method to convert the typed
       * value to a string.  If the `_serializeValue` method returns `undefined`,
       * the attribute will be removed (this is the default for boolean
       * type `false`).
       *
       * @param {Element} node Element to set attribute to.
       * @param {*} value Value to serialize.
       * @param {string} attribute Attribute name to serialize to.
       * @return {void}
       * @override
       */
      _valueToNodeAttribute(t, i, n) {
        const o = this._serializeValue(i);
        (n === "class" || n === "name" || n === "slot") && (t = /** @type {?Element} */
        _i(t)), o === void 0 ? t.removeAttribute(n) : t.setAttribute(
          n,
          // Closure's type for `setAttribute`'s second parameter incorrectly
          // excludes `TrustedScript`.
          o === "" && window.trustedTypes ? (
            /** @type {?} */
            window.trustedTypes.emptyScript
          ) : o
        );
      }
      /**
       * Converts a typed JavaScript value to a string.
       *
       * This method is called when setting JS property values to
       * HTML attributes.  Users may override this method to provide
       * serialization for custom types.
       *
       * @param {*} value Property value to serialize.
       * @return {string | undefined} String serialized from the provided
       * property  value.
       * @override
       */
      _serializeValue(t) {
        switch (typeof t) {
          case "boolean":
            return t ? "" : void 0;
          default:
            return t != null ? t.toString() : void 0;
        }
      }
      /**
       * Converts a string to a typed JavaScript value.
       *
       * This method is called when reading HTML attribute values to
       * JS properties.  Users may override this method to provide
       * deserialization for custom `type`s. Types for `Boolean`, `String`,
       * and `Number` convert attributes to the expected types.
       *
       * @param {?string} value Value to deserialize.
       * @param {*=} type Type to deserialize the string to.
       * @return {*} Typed value deserialized from the provided string.
       * @override
       */
      _deserializeValue(t, i) {
        switch (i) {
          case Boolean:
            return t !== null;
          case Number:
            return Number(t);
          default:
            return t;
        }
      }
    }
    return r;
  }
);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const bc = {};
let mn = HTMLElement.prototype;
for (; mn; ) {
  let s = Object.getOwnPropertyNames(mn);
  for (let r = 0; r < s.length; r++)
    bc[s[r]] = !0;
  mn = Object.getPrototypeOf(mn);
}
const ou = window.trustedTypes ? (s) => trustedTypes.isHTML(s) || trustedTypes.isScript(s) || trustedTypes.isScriptURL(s) : () => !1;
function su(s, r) {
  if (!bc[r]) {
    let e = s[r];
    e !== void 0 && (s.__data ? s._setPendingProperty(r, e) : (s.__dataProto ? s.hasOwnProperty(JSCompiler_renameProperty("__dataProto", s)) || (s.__dataProto = Object.create(s.__dataProto)) : s.__dataProto = {}, s.__dataProto[r] = e));
  }
}
const au = $e((s) => {
  const r = _c(s);
  class e extends r {
    /**
     * Generates property accessors for all attributes in the standard
     * static `observedAttributes` array.
     *
     * Attribute names are mapped to property names using the `dash-case` to
     * `camelCase` convention
     *
     * @return {void}
     * @nocollapse
     */
    static createPropertiesForAttributes() {
      let i = (
        /** @type {?} */
        this.observedAttributes
      );
      for (let n = 0; n < i.length; n++)
        this.prototype._createPropertyAccessor(gc(i[n]));
    }
    /**
     * Returns an attribute name that corresponds to the given property.
     * By default, converts camel to dash case, e.g. `fooBar` to `foo-bar`.
     * @param {string} property Property to convert
     * @return {string} Attribute name corresponding to the given property.
     *
     * @protected
     * @nocollapse
     */
    static attributeNameForProperty(i) {
      return Xn(i);
    }
    /**
     * Overrides PropertiesChanged implementation to initialize values for
     * accessors created for values that already existed on the element
     * prototype.
     *
     * @return {void}
     * @protected
     * @override
     */
    _initializeProperties() {
      this.__dataProto && (this._initializeProtoProperties(this.__dataProto), this.__dataProto = null), super._initializeProperties();
    }
    /**
     * Called at instance time with bag of properties that were overwritten
     * by accessors on the prototype when accessors were created.
     *
     * The default implementation sets these properties back into the
     * setter at instance time.  This method is provided as an override
     * point for customizing or providing more efficient initialization.
     *
     * @param {Object} props Bag of property values that were overwritten
     *   when creating property accessors.
     * @return {void}
     * @protected
     * @override
     */
    _initializeProtoProperties(i) {
      for (let n in i)
        this._setProperty(n, i[n]);
    }
    /**
     * Ensures the element has the given attribute. If it does not,
     * assigns the given value to the attribute.
     *
     * @suppress {invalidCasts} Closure can't figure out `this` is infact an
     *     element
     *
     * @param {string} attribute Name of attribute to ensure is set.
     * @param {string} value of the attribute.
     * @return {void}
     * @override
     */
    _ensureAttribute(i, n) {
      const o = (
        /** @type {!HTMLElement} */
        this
      );
      o.hasAttribute(i) || this._valueToNodeAttribute(o, n, i);
    }
    /**
     * Overrides PropertiesChanged implemention to serialize objects as JSON.
     *
     * @param {*} value Property value to serialize.
     * @return {string | undefined} String serialized from the provided property
     *     value.
     * @override
     */
    _serializeValue(i) {
      switch (typeof i) {
        case "object":
          if (i instanceof Date)
            return i.toString();
          if (i) {
            if (ou(i))
              return (
                /** @type {?} */
                i
              );
            try {
              return JSON.stringify(i);
            } catch {
              return "";
            }
          }
        default:
          return super._serializeValue(i);
      }
    }
    /**
     * Converts a string to a typed JavaScript value.
     *
     * This method is called by Polymer when reading HTML attribute values to
     * JS properties.  Users may override this method on Polymer element
     * prototypes to provide deserialization for custom `type`s.  Note,
     * the `type` argument is the value of the `type` field provided in the
     * `properties` configuration object for a given property, and is
     * by convention the constructor for the type to deserialize.
     *
     *
     * @param {?string} value Attribute value to deserialize.
     * @param {*=} type Type to deserialize the string to.
     * @return {*} Typed value deserialized from the provided string.
     * @override
     */
    _deserializeValue(i, n) {
      let o;
      switch (n) {
        case Object:
          try {
            o = JSON.parse(
              /** @type {string} */
              i
            );
          } catch {
            o = i;
          }
          break;
        case Array:
          try {
            o = JSON.parse(
              /** @type {string} */
              i
            );
          } catch {
            o = null, console.warn(`Polymer::Attributes: couldn't decode Array as JSON: ${i}`);
          }
          break;
        case Date:
          o = isNaN(i) ? String(i) : Number(i), o = new Date(o);
          break;
        default:
          o = super._deserializeValue(i, n);
          break;
      }
      return o;
    }
    /* eslint-enable no-fallthrough */
    /**
     * Overrides PropertiesChanged implementation to save existing prototype
     * property value so that it can be reset.
     * @param {string} property Name of the property
     * @param {boolean=} readOnly When true, no setter is created
     *
     * When calling on a prototype, any overwritten values are saved in
     * `__dataProto`, and it is up to the subclasser to decide how/when
     * to set those properties back into the accessor.  When calling on an
     * instance, the overwritten value is set via `_setPendingProperty`,
     * and the user should call `_invalidateProperties` or `_flushProperties`
     * for the values to take effect.
     * @protected
     * @return {void}
     * @override
     */
    _definePropertyAccessor(i, n) {
      su(this, i), super._definePropertyAccessor(i, n);
    }
    /**
     * Returns true if this library created an accessor for the given property.
     *
     * @param {string} property Property name
     * @return {boolean} True if an accessor was created
     * @override
     */
    _hasAccessor(i) {
      return this.__dataHasAccessor && this.__dataHasAccessor[i];
    }
    /**
     * Returns true if the specified property has a pending change.
     *
     * @param {string} prop Property name
     * @return {boolean} True if property has a pending change
     * @protected
     * @override
     */
    _isPropertyPending(i) {
      return !!(this.__dataPending && i in this.__dataPending);
    }
  }
  return e;
});
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const lu = {
  "dom-if": !0,
  "dom-repeat": !0
};
let tl = !1, il = !1;
function cu() {
  if (!tl) {
    tl = !0;
    const s = document.createElement("textarea");
    s.placeholder = "a", il = s.placeholder === s.textContent;
  }
  return il;
}
function hu(s) {
  cu() && s.localName === "textarea" && s.placeholder && s.placeholder === s.textContent && (s.textContent = null);
}
const du = (() => {
  const s = window.trustedTypes && window.trustedTypes.createPolicy(
    "polymer-template-event-attribute-policy",
    {
      createScript: (r) => r
    }
  );
  return (r, e, t) => {
    const i = e.getAttribute(t);
    if (s && t.startsWith("on-")) {
      r.setAttribute(
        t,
        s.createScript(i, t)
      );
      return;
    }
    r.setAttribute(t, i);
  };
})();
function uu(s) {
  let r = s.getAttribute("is");
  if (r && lu[r]) {
    let e = s;
    for (e.removeAttribute("is"), s = e.ownerDocument.createElement(r), e.parentNode.replaceChild(s, e), s.appendChild(e); e.attributes.length; ) {
      const { name: t } = e.attributes[0];
      du(s, e, t), e.removeAttribute(t);
    }
  }
  return s;
}
function yc(s, r) {
  let e = r.parentInfo && yc(s, r.parentInfo);
  if (e) {
    for (let t = e.firstChild, i = 0; t; t = t.nextSibling)
      if (r.parentIndex === i++)
        return t;
  } else
    return s;
}
function fu(s, r, e, t) {
  t.id && (r[t.id] = e);
}
function pu(s, r, e) {
  if (e.events && e.events.length)
    for (let t = 0, i = e.events, n; t < i.length && (n = i[t]); t++)
      s._addMethodEventListenerToNode(r, n.name, n.value, s);
}
function gu(s, r, e, t) {
  e.templateInfo && (r._templateInfo = e.templateInfo, r._parentTemplateInfo = t);
}
function mu(s, r, e) {
  return s = s._methodHost || s, function(i) {
    s[e] ? s[e](i, i.detail) : console.warn("listener method `" + e + "` not defined");
  };
}
const vu = $e(
  /**
   * @template T
   * @param {function(new:T)} superClass Class to apply mixin to.
   * @return {function(new:T)} superClass with mixin applied.
   */
  (s) => {
    class r extends s {
      /**
       * Scans a template to produce template metadata.
       *
       * Template-specific metadata are stored in the object returned, and node-
       * specific metadata are stored in objects in its flattened `nodeInfoList`
       * array.  Only nodes in the template that were parsed as nodes of
       * interest contain an object in `nodeInfoList`.  Each `nodeInfo` object
       * contains an `index` (`childNodes` index in parent) and optionally
       * `parent`, which points to node info of its parent (including its index).
       *
       * The template metadata object returned from this method has the following
       * structure (many fields optional):
       *
       * ```js
       *   {
       *     // Flattened list of node metadata (for nodes that generated metadata)
       *     nodeInfoList: [
       *       {
       *         // `id` attribute for any nodes with id's for generating `$` map
       *         id: {string},
       *         // `on-event="handler"` metadata
       *         events: [
       *           {
       *             name: {string},   // event name
       *             value: {string},  // handler method name
       *           }, ...
       *         ],
       *         // Notes when the template contained a `<slot>` for shady DOM
       *         // optimization purposes
       *         hasInsertionPoint: {boolean},
       *         // For nested `<template>`` nodes, nested template metadata
       *         templateInfo: {object}, // nested template metadata
       *         // Metadata to allow efficient retrieval of instanced node
       *         // corresponding to this metadata
       *         parentInfo: {number},   // reference to parent nodeInfo>
       *         parentIndex: {number},  // index in parent's `childNodes` collection
       *         infoIndex: {number},    // index of this `nodeInfo` in `templateInfo.nodeInfoList`
       *       },
       *       ...
       *     ],
       *     // When true, the template had the `strip-whitespace` attribute
       *     // or was nested in a template with that setting
       *     stripWhitespace: {boolean},
       *     // For nested templates, nested template content is moved into
       *     // a document fragment stored here; this is an optimization to
       *     // avoid the cost of nested template cloning
       *     content: {DocumentFragment}
       *   }
       * ```
       *
       * This method kicks off a recursive treewalk as follows:
       *
       * ```
       *    _parseTemplate <---------------------+
       *      _parseTemplateContent              |
       *        _parseTemplateNode  <------------|--+
       *          _parseTemplateNestedTemplate --+  |
       *          _parseTemplateChildNodes ---------+
       *          _parseTemplateNodeAttributes
       *            _parseTemplateNodeAttribute
       *
       * ```
       *
       * These methods may be overridden to add custom metadata about templates
       * to either `templateInfo` or `nodeInfo`.
       *
       * Note that this method may be destructive to the template, in that
       * e.g. event annotations may be removed after being noted in the
       * template metadata.
       *
       * @param {!HTMLTemplateElement} template Template to parse
       * @param {TemplateInfo=} outerTemplateInfo Template metadata from the outer
       *   template, for parsing nested templates
       * @return {!TemplateInfo} Parsed template metadata
       * @nocollapse
       */
      static _parseTemplate(t, i) {
        if (!t._templateInfo) {
          let n = t._templateInfo = {};
          n.nodeInfoList = [], n.nestedTemplate = !!i, n.stripWhiteSpace = i && i.stripWhiteSpace || t.hasAttribute && t.hasAttribute("strip-whitespace"), this._parseTemplateContent(
            t,
            n,
            /** @type {?} */
            { parent: null }
          );
        }
        return t._templateInfo;
      }
      /**
       * See docs for _parseTemplateNode.
       *
       * @param {!HTMLTemplateElement} template .
       * @param {!TemplateInfo} templateInfo .
       * @param {!NodeInfo} nodeInfo .
       * @return {boolean} .
       * @nocollapse
       */
      static _parseTemplateContent(t, i, n) {
        return this._parseTemplateNode(t.content, i, n);
      }
      /**
       * Parses template node and adds template and node metadata based on
       * the current node, and its `childNodes` and `attributes`.
       *
       * This method may be overridden to add custom node or template specific
       * metadata based on this node.
       *
       * @param {Node} node Node to parse
       * @param {!TemplateInfo} templateInfo Template metadata for current template
       * @param {!NodeInfo} nodeInfo Node metadata for current template.
       * @return {boolean} `true` if the visited node added node-specific
       *   metadata to `nodeInfo`
       * @nocollapse
       */
      static _parseTemplateNode(t, i, n) {
        let o = !1, a = (
          /** @type {!HTMLTemplateElement} */
          t
        );
        return a.localName == "template" && !a.hasAttribute("preserve-content") ? o = this._parseTemplateNestedTemplate(a, i, n) || o : a.localName === "slot" && (i.hasInsertionPoint = !0), hu(a), a.firstChild && this._parseTemplateChildNodes(a, i, n), a.hasAttributes && a.hasAttributes() && (o = this._parseTemplateNodeAttributes(a, i, n) || o), o || n.noted;
      }
      /**
       * Parses template child nodes for the given root node.
       *
       * This method also wraps whitelisted legacy template extensions
       * (`is="dom-if"` and `is="dom-repeat"`) with their equivalent element
       * wrappers, collapses text nodes, and strips whitespace from the template
       * if the `templateInfo.stripWhitespace` setting was provided.
       *
       * @param {Node} root Root node whose `childNodes` will be parsed
       * @param {!TemplateInfo} templateInfo Template metadata for current template
       * @param {!NodeInfo} nodeInfo Node metadata for current template.
       * @return {void}
       */
      static _parseTemplateChildNodes(t, i, n) {
        if (!(t.localName === "script" || t.localName === "style"))
          for (let o = t.firstChild, a = 0, l; o; o = l) {
            if (o.localName == "template" && (o = uu(o)), l = o.nextSibling, o.nodeType === Node.TEXT_NODE) {
              let d = l;
              for (; d && d.nodeType === Node.TEXT_NODE; )
                o.textContent += d.textContent, l = d.nextSibling, t.removeChild(d), d = l;
              if (i.stripWhiteSpace && !o.textContent.trim()) {
                t.removeChild(o);
                continue;
              }
            }
            let h = (
              /** @type {!NodeInfo} */
              { parentIndex: a, parentInfo: n }
            );
            this._parseTemplateNode(o, i, h) && (h.infoIndex = i.nodeInfoList.push(h) - 1), o.parentNode && a++;
          }
      }
      /**
       * Parses template content for the given nested `<template>`.
       *
       * Nested template info is stored as `templateInfo` in the current node's
       * `nodeInfo`. `template.content` is removed and stored in `templateInfo`.
       * It will then be the responsibility of the host to set it back to the
       * template and for users stamping nested templates to use the
       * `_contentForTemplate` method to retrieve the content for this template
       * (an optimization to avoid the cost of cloning nested template content).
       *
       * @param {HTMLTemplateElement} node Node to parse (a <template>)
       * @param {TemplateInfo} outerTemplateInfo Template metadata for current template
       *   that includes the template `node`
       * @param {!NodeInfo} nodeInfo Node metadata for current template.
       * @return {boolean} `true` if the visited node added node-specific
       *   metadata to `nodeInfo`
       * @nocollapse
       */
      static _parseTemplateNestedTemplate(t, i, n) {
        let o = (
          /** @type {!HTMLTemplateElement} */
          t
        ), a = this._parseTemplate(o, i);
        return (a.content = o.content.ownerDocument.createDocumentFragment()).appendChild(o.content), n.templateInfo = a, !0;
      }
      /**
       * Parses template node attributes and adds node metadata to `nodeInfo`
       * for nodes of interest.
       *
       * @param {Element} node Node to parse
       * @param {!TemplateInfo} templateInfo Template metadata for current
       *     template
       * @param {!NodeInfo} nodeInfo Node metadata for current template.
       * @return {boolean} `true` if the visited node added node-specific
       *   metadata to `nodeInfo`
       * @nocollapse
       */
      static _parseTemplateNodeAttributes(t, i, n) {
        let o = !1, a = Array.from(t.attributes);
        for (let l = a.length - 1, h; h = a[l]; l--)
          o = this._parseTemplateNodeAttribute(t, i, n, h.name, h.value) || o;
        return o;
      }
      /**
       * Parses a single template node attribute and adds node metadata to
       * `nodeInfo` for attributes of interest.
       *
       * This implementation adds metadata for `on-event="handler"` attributes
       * and `id` attributes.
       *
       * @param {Element} node Node to parse
       * @param {!TemplateInfo} templateInfo Template metadata for current template
       * @param {!NodeInfo} nodeInfo Node metadata for current template.
       * @param {string} name Attribute name
       * @param {string} value Attribute value
       * @return {boolean} `true` if the visited node added node-specific
       *   metadata to `nodeInfo`
       * @nocollapse
       */
      static _parseTemplateNodeAttribute(t, i, n, o, a) {
        return o.slice(0, 3) === "on-" ? (t.removeAttribute(o), n.events = n.events || [], n.events.push({
          name: o.slice(3),
          value: a
        }), !0) : o === "id" ? (n.id = a, !0) : !1;
      }
      /**
       * Returns the `content` document fragment for a given template.
       *
       * For nested templates, Polymer performs an optimization to cache nested
       * template content to avoid the cost of cloning deeply nested templates.
       * This method retrieves the cached content for a given template.
       *
       * @param {HTMLTemplateElement} template Template to retrieve `content` for
       * @return {DocumentFragment} Content fragment
       * @nocollapse
       */
      static _contentForTemplate(t) {
        let i = (
          /** @type {HTMLTemplateElementWithInfo} */
          t._templateInfo
        );
        return i && i.content || t.content;
      }
      /**
       * Clones the provided template content and returns a document fragment
       * containing the cloned dom.
       *
       * The template is parsed (once and memoized) using this library's
       * template parsing features, and provides the following value-added
       * features:
       * * Adds declarative event listeners for `on-event="handler"` attributes
       * * Generates an "id map" for all nodes with id's under `$` on returned
       *   document fragment
       * * Passes template info including `content` back to templates as
       *   `_templateInfo` (a performance optimization to avoid deep template
       *   cloning)
       *
       * Note that the memoized template parsing process is destructive to the
       * template: attributes for bindings and declarative event listeners are
       * removed after being noted in notes, and any nested `<template>.content`
       * is removed and stored in notes as well.
       *
       * @param {!HTMLTemplateElement} template Template to stamp
       * @param {TemplateInfo=} templateInfo Optional template info associated
       *   with the template to be stamped; if omitted the template will be
       *   automatically parsed.
       * @return {!StampedTemplate} Cloned template content
       * @override
       */
      _stampTemplate(t, i) {
        t && !t.content && window.HTMLTemplateElement && HTMLTemplateElement.decorate && HTMLTemplateElement.decorate(t), i = i || this.constructor._parseTemplate(t);
        let n = i.nodeInfoList, o = i.content || t.content, a = (
          /** @type {DocumentFragment} */
          document.importNode(o, !0)
        );
        a.__noInsertionPoint = !i.hasInsertionPoint;
        let l = a.nodeList = new Array(n.length);
        a.$ = {};
        for (let h = 0, d = n.length, f; h < d && (f = n[h]); h++) {
          let g = l[h] = yc(a, f);
          fu(this, a.$, g, f), gu(this, g, f, i), pu(this, g, f);
        }
        return a = /** @type {!StampedTemplate} */
        a, a;
      }
      /**
       * Adds an event listener by method name for the event provided.
       *
       * This method generates a handler function that looks up the method
       * name at handling time.
       *
       * @param {!EventTarget} node Node to add listener on
       * @param {string} eventName Name of event
       * @param {string} methodName Name of method
       * @param {*=} context Context the method will be called on (defaults
       *   to `node`)
       * @return {Function} Generated handler function
       * @override
       */
      _addMethodEventListenerToNode(t, i, n, o) {
        o = o || t;
        let a = mu(o, i, n);
        return this._addEventListenerToNode(t, i, a), a;
      }
      /**
       * Override point for adding custom or simulated event handling.
       *
       * @param {!EventTarget} node Node to add event listener to
       * @param {string} eventName Name of event
       * @param {function(!Event):void} handler Listener function to add
       * @return {void}
       * @override
       */
      _addEventListenerToNode(t, i, n) {
        t.addEventListener(i, n);
      }
      /**
       * Override point for adding custom or simulated event handling.
       *
       * @param {!EventTarget} node Node to remove event listener from
       * @param {string} eventName Name of event
       * @param {function(!Event):void} handler Listener function to remove
       * @return {void}
       * @override
       */
      _removeEventListenerFromNode(t, i, n) {
        t.removeEventListener(i, n);
      }
    }
    return r;
  }
);
/**
 * @fileoverview
 * @suppress {checkPrototypalTypes}
 * @license Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt The complete set of authors may be found
 * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may
 * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by
 * Google as part of the polymer project is also subject to an additional IP
 * rights grant found at http://polymer.github.io/PATENTS.txt
 */
let Or = 0;
const zr = [], Oe = {
  COMPUTE: "__computeEffects",
  REFLECT: "__reflectEffects",
  NOTIFY: "__notifyEffects",
  PROPAGATE: "__propagateEffects",
  OBSERVE: "__observeEffects",
  READ_ONLY: "__readOnly"
}, wc = "__computeInfo", _u = /[A-Z]/;
function Ho(s, r, e) {
  let t = s[r];
  if (!t)
    t = s[r] = {};
  else if (!s.hasOwnProperty(r) && (t = s[r] = Object.create(s[r]), e))
    for (let i in t) {
      let n = t[i], o = t[i] = Array(n.length);
      for (let a = 0; a < n.length; a++)
        o[a] = n[a];
    }
  return t;
}
function xr(s, r, e, t, i, n) {
  if (r) {
    let o = !1;
    const a = Or++;
    for (let l in e) {
      let h = i ? Ei(l) : l, d = r[h];
      if (d)
        for (let f = 0, g = d.length, w; f < g && (w = d[f]); f++)
          (!w.info || w.info.lastRun !== a) && (!i || Bs(l, w.trigger)) && (w.info && (w.info.lastRun = a), w.fn(s, l, e, t, w.info, i, n), o = !0);
    }
    return o;
  }
  return !1;
}
function bu(s, r, e, t, i, n, o, a) {
  let l = !1, h = o ? Ei(t) : t, d = r[h];
  if (d)
    for (let f = 0, g = d.length, w; f < g && (w = d[f]); f++)
      (!w.info || w.info.lastRun !== e) && (!o || Bs(t, w.trigger)) && (w.info && (w.info.lastRun = e), w.fn(s, t, i, n, w.info, o, a), l = !0);
  return l;
}
function Bs(s, r) {
  if (r) {
    let e = (
      /** @type {string} */
      r.name
    );
    return e == s || !!(r.structured && Jd(e, s)) || !!(r.wildcard && Nn(e, s));
  } else
    return !0;
}
function rl(s, r, e, t, i) {
  let n = typeof i.method == "string" ? s[i.method] : i.method, o = i.property;
  n ? n.call(s, s.__data[o], t[o]) : i.dynamicFn || console.warn("observer method `" + i.method + "` not defined");
}
function yu(s, r, e, t, i) {
  let n = s[Oe.NOTIFY], o, a = Or++;
  for (let h in r)
    r[h] && (n && bu(s, n, a, h, e, t, i) || i && wu(s, h, e)) && (o = !0);
  let l;
  o && (l = s.__dataHost) && l._invalidateProperties && l._invalidateProperties();
}
function wu(s, r, e) {
  let t = Ei(r);
  if (t !== r) {
    let i = Xn(t) + "-changed";
    return xc(s, i, e[r], r), !0;
  }
  return !1;
}
function xc(s, r, e, t) {
  let i = {
    value: e,
    queueProperty: !0
  };
  t && (i.path = t), _i(
    /** @type {!HTMLElement} */
    s
  ).dispatchEvent(new CustomEvent(r, { detail: i }));
}
function xu(s, r, e, t, i, n) {
  let a = (n ? Ei(r) : r) != r ? r : null, l = a ? ht(s, a) : s.__data[r];
  a && l === void 0 && (l = e[r]), xc(s, i.eventName, l, a);
}
function Cu(s, r, e, t, i) {
  let n, o = (
    /** @type {Object} */
    s.detail
  ), a = o && o.path;
  a ? (t = Hn(e, t, a), n = o && o.value) : n = s.currentTarget[e], n = i ? !n : n, (!r[Oe.READ_ONLY] || !r[Oe.READ_ONLY][t]) && r._setPendingPropertyOrPath(t, n, !0, !!a) && (!o || !o.queueProperty) && r._invalidateProperties();
}
function Tu(s, r, e, t, i) {
  let n = s.__data[r];
  Bn && (n = Bn(
    n,
    i.attrName,
    "attribute",
    /** @type {Node} */
    s
  )), s._propertyToAttribute(r, i.attrName, n);
}
function Eu(s, r, e, t) {
  let i = s[Oe.COMPUTE];
  if (i)
    if (Vd) {
      Or++;
      const n = Su(s), o = [];
      for (let l in r)
        nl(l, i, o, n, t);
      let a;
      for (; a = o.shift(); )
        Cc(s, "", r, e, a) && nl(a.methodInfo, i, o, n, t);
      Object.assign(
        /** @type {!Object} */
        e,
        s.__dataOld
      ), Object.assign(
        /** @type {!Object} */
        r,
        s.__dataPending
      ), s.__dataPending = null;
    } else {
      let n = r;
      for (; xr(s, i, n, e, t); )
        Object.assign(
          /** @type {!Object} */
          e,
          s.__dataOld
        ), Object.assign(
          /** @type {!Object} */
          r,
          s.__dataPending
        ), n = s.__dataPending, s.__dataPending = null;
    }
}
const Pu = (s, r, e) => {
  let t = 0, i = r.length - 1, n = -1;
  for (; t <= i; ) {
    const o = t + i >> 1, a = e.get(r[o].methodInfo) - e.get(s.methodInfo);
    if (a < 0)
      t = o + 1;
    else if (a > 0)
      i = o - 1;
    else {
      n = o;
      break;
    }
  }
  n < 0 && (n = i + 1), r.splice(n, 0, s);
}, nl = (s, r, e, t, i) => {
  const n = i ? Ei(s) : s, o = r[n];
  if (o)
    for (let a = 0; a < o.length; a++) {
      const l = o[a];
      l.info.lastRun !== Or && (!i || Bs(s, l.trigger)) && (l.info.lastRun = Or, Pu(l.info, e, t));
    }
};
function Su(s) {
  let r = s.constructor.__orderedComputedDeps;
  if (!r) {
    r = /* @__PURE__ */ new Map();
    const e = s[Oe.COMPUTE];
    let { counts: t, ready: i, total: n } = ku(s), o;
    for (; o = i.shift(); ) {
      r.set(o, r.size);
      const a = e[o];
      a && a.forEach((l) => {
        const h = l.info.methodInfo;
        --n, --t[h] === 0 && i.push(h);
      });
    }
    n !== 0 && console.warn(`Computed graph for ${/** @type {HTMLElement} */
    s.localName} incomplete; circular?`), s.constructor.__orderedComputedDeps = r;
  }
  return r;
}
function ku(s) {
  const r = s[wc], e = {}, t = s[Oe.COMPUTE], i = [];
  let n = 0;
  for (let o in r) {
    const a = r[o];
    n += e[o] = a.args.filter((l) => !l.literal).length + (a.dynamicFn ? 1 : 0);
  }
  for (let o in t)
    r[o] || i.push(o);
  return { counts: e, ready: i, total: n };
}
function Cc(s, r, e, t, i) {
  let n = ps(s, r, e, t, i);
  if (n === zr)
    return !1;
  let o = i.methodInfo;
  return s.__dataHasAccessor && s.__dataHasAccessor[o] ? s._setPendingProperty(o, n, !0) : (s[o] = n, !1);
}
function Au(s, r, e) {
  let t = s.__dataLinkedPaths;
  if (t) {
    let i;
    for (let n in t) {
      let o = t[n];
      Nn(n, r) ? (i = Hn(n, o, r), s._setPendingPropertyOrPath(i, e, !0, !0)) : Nn(o, r) && (i = Hn(o, n, r), s._setPendingPropertyOrPath(i, e, !0, !0));
    }
  }
}
function Vo(s, r, e, t, i, n, o) {
  e.bindings = e.bindings || [];
  let a = { kind: t, target: i, parts: n, literal: o, isCompound: n.length !== 1 };
  if (e.bindings.push(a), zu(a)) {
    let { event: h, negate: d } = a.parts[0];
    a.listenerEvent = h || Xn(i) + "-changed", a.listenerNegate = d;
  }
  let l = r.nodeInfoList.length;
  for (let h = 0; h < a.parts.length; h++) {
    let d = a.parts[h];
    d.compoundIndex = h, Ru(s, r, a, d, l);
  }
}
function Ru(s, r, e, t, i) {
  if (!t.literal)
    if (e.kind === "attribute" && e.target[0] === "-")
      console.warn("Cannot set attribute " + e.target + ' because "-" is not a valid attribute starting character');
    else {
      let n = t.dependencies, o = { index: i, binding: e, part: t, evaluator: s };
      for (let a = 0; a < n.length; a++) {
        let l = n[a];
        typeof l == "string" && (l = Ec(l), l.wildcard = !0), s._addTemplatePropertyEffect(r, l.rootProperty, {
          fn: Iu,
          info: o,
          trigger: l
        });
      }
    }
}
function Iu(s, r, e, t, i, n, o) {
  let a = o[i.index], l = i.binding, h = i.part;
  if (n && h.source && r.length > h.source.length && l.kind == "property" && !l.isCompound && a.__isPropertyEffectsClient && a.__dataHasAccessor && a.__dataHasAccessor[l.target]) {
    let d = e[r];
    r = Hn(h.source, l.target, r), a._setPendingPropertyOrPath(r, d, !1, !0) && s._enqueueClient(a);
  } else {
    let d = i.evaluator._evaluateBinding(s, h, r, e, t, n);
    d !== zr && Du(s, a, l, h, d);
  }
}
function Du(s, r, e, t, i) {
  if (i = Ou(r, i, e, t), Bn && (i = Bn(i, e.target, e.kind, r)), e.kind == "attribute")
    s._valueToNodeAttribute(
      /** @type {Element} */
      r,
      i,
      e.target
    );
  else {
    let n = e.target;
    r.__isPropertyEffectsClient && r.__dataHasAccessor && r.__dataHasAccessor[n] ? (!r[Oe.READ_ONLY] || !r[Oe.READ_ONLY][n]) && r._setPendingProperty(n, i) && s._enqueueClient(r) : s._setUnmanagedPropertyToNode(r, n, i);
  }
}
function Ou(s, r, e, t) {
  if (e.isCompound) {
    let i = s.__dataCompoundStorage[e.target];
    i[t.compoundIndex] = r, r = i.join("");
  }
  return e.kind !== "attribute" && (e.target === "textContent" || e.target === "value" && (s.localName === "input" || s.localName === "textarea")) && (r = r ?? ""), r;
}
function zu(s) {
  return !!s.target && s.kind != "attribute" && s.kind != "text" && !s.isCompound && s.parts[0].mode === "{";
}
function Fu(s, r) {
  let { nodeList: e, nodeInfoList: t } = r;
  if (t.length)
    for (let i = 0; i < t.length; i++) {
      let n = t[i], o = e[i], a = n.bindings;
      if (a)
        for (let l = 0; l < a.length; l++) {
          let h = a[l];
          Mu(o, h), Lu(o, s, h);
        }
      o.__dataHost = s;
    }
}
function Mu(s, r) {
  if (r.isCompound) {
    let e = s.__dataCompoundStorage || (s.__dataCompoundStorage = {}), t = r.parts, i = new Array(t.length);
    for (let o = 0; o < t.length; o++)
      i[o] = t[o].literal;
    let n = r.target;
    e[n] = i, r.literal && r.kind == "property" && (n === "className" && (s = _i(s)), s[n] = r.literal);
  }
}
function Lu(s, r, e) {
  if (e.listenerEvent) {
    let t = e.parts[0];
    s.addEventListener(e.listenerEvent, function(i) {
      Cu(i, r, e.target, t.source, t.negate);
    });
  }
}
function ol(s, r, e, t, i, n) {
  n = r.static || n && (typeof n != "object" || n[r.methodName]);
  let o = {
    methodName: r.methodName,
    args: r.args,
    methodInfo: i,
    dynamicFn: n
  };
  for (let a = 0, l; a < r.args.length && (l = r.args[a]); a++)
    l.literal || s._addPropertyEffect(l.rootProperty, e, {
      fn: t,
      info: o,
      trigger: l
    });
  return n && s._addPropertyEffect(r.methodName, e, {
    fn: t,
    info: o
  }), o;
}
function ps(s, r, e, t, i) {
  let n = s._methodHost || s, o = n[i.methodName];
  if (o) {
    let a = s._marshalArgs(i.args, r, e);
    return a === zr ? zr : o.apply(n, a);
  } else i.dynamicFn || console.warn("method `" + i.methodName + "` not defined");
}
const Bu = [], Tc = "(?:[a-zA-Z_$][\\w.:$\\-*]*)", Nu = "(?:[-+]?[0-9]*\\.?[0-9]+(?:[eE][-+]?[0-9]+)?)", Hu = "(?:'(?:[^'\\\\]|\\\\.)*')", Vu = '(?:"(?:[^"\\\\]|\\\\.)*")', Uu = "(?:" + Hu + "|" + Vu + ")", sl = "(?:(" + Tc + "|" + Nu + "|" + Uu + ")\\s*)", Wu = "(?:" + sl + "(?:,\\s*" + sl + ")*)", ju = "(?:\\(\\s*(?:" + Wu + "?)\\)\\s*)", Gu = "(" + Tc + "\\s*" + ju + "?)", qu = "(\\[\\[|{{)\\s*", Ku = "(?:]]|}})", Zu = "(?:(!)\\s*)?", Yu = qu + Zu + Gu + Ku, al = new RegExp(Yu, "g");
function ll(s) {
  let r = "";
  for (let e = 0; e < s.length; e++) {
    let t = s[e].literal;
    r += t || "";
  }
  return r;
}
function Uo(s) {
  let r = s.match(/([^\s]+?)\(([\s\S]*)\)/);
  if (r) {
    let t = { methodName: r[1], static: !0, args: Bu };
    if (r[2].trim()) {
      let i = r[2].replace(/\\,/g, "&comma;").split(",");
      return Xu(i, t);
    } else
      return t;
  }
  return null;
}
function Xu(s, r) {
  return r.args = s.map(function(e) {
    let t = Ec(e);
    return t.literal || (r.static = !1), t;
  }, this), r;
}
function Ec(s) {
  let r = s.trim().replace(/&comma;/g, ",").replace(/\\(.)/g, "$1"), e = {
    name: r,
    value: "",
    literal: !1
  }, t = r[0];
  switch (t === "-" && (t = r[1]), t >= "0" && t <= "9" && (t = "#"), t) {
    case "'":
    case '"':
      e.value = r.slice(1, -1), e.literal = !0;
      break;
    case "#":
      e.value = Number(r), e.literal = !0;
      break;
  }
  return e.literal || (e.rootProperty = Ei(r), e.structured = us(r), e.structured && (e.wildcard = r.slice(-2) == ".*", e.wildcard && (e.name = r.slice(0, -2)))), e;
}
function cl(s, r, e) {
  let t = ht(s, e);
  return t === void 0 && (t = r[e]), t;
}
function Pc(s, r, e, t) {
  const i = { indexSplices: t };
  ds && !s._overrideLegacyUndefined && (r.splices = i), s.notifyPath(e + ".splices", i), s.notifyPath(e + ".length", r.length), ds && !s._overrideLegacyUndefined && (i.indexSplices = []);
}
function mr(s, r, e, t, i, n) {
  Pc(s, r, e, [{
    index: t,
    addedCount: i,
    removed: n,
    object: r,
    type: "splice"
  }]);
}
function Ju(s) {
  return s[0].toUpperCase() + s.substring(1);
}
const Qu = $e((s) => {
  const r = vu(au(s));
  class e extends r {
    constructor() {
      super(), this.__isPropertyEffectsClient = !0, this.__dataClientsReady, this.__dataPendingClients, this.__dataToNotify, this.__dataLinkedPaths, this.__dataHasPaths, this.__dataCompoundStorage, this.__dataHost, this.__dataTemp, this.__dataClientsInitialized, this.__data, this.__dataPending, this.__dataOld, this.__computeEffects, this.__computeInfo, this.__reflectEffects, this.__notifyEffects, this.__propagateEffects, this.__observeEffects, this.__readOnly, this.__templateInfo, this._overrideLegacyUndefined;
    }
    get PROPERTY_EFFECT_TYPES() {
      return Oe;
    }
    /**
     * @override
     * @return {void}
     */
    _initializeProperties() {
      super._initializeProperties(), this._registerHost(), this.__dataClientsReady = !1, this.__dataPendingClients = null, this.__dataToNotify = null, this.__dataLinkedPaths = null, this.__dataHasPaths = !1, this.__dataCompoundStorage = this.__dataCompoundStorage || null, this.__dataHost = this.__dataHost || null, this.__dataTemp = {}, this.__dataClientsInitialized = !1;
    }
    _registerHost() {
      if (vr.length) {
        let i = vr[vr.length - 1];
        i._enqueueClient(this), this.__dataHost = i;
      }
    }
    /**
     * Overrides `PropertyAccessors` implementation to provide a
     * more efficient implementation of initializing properties from
     * the prototype on the instance.
     *
     * @override
     * @param {Object} props Properties to initialize on the prototype
     * @return {void}
     */
    _initializeProtoProperties(i) {
      this.__data = Object.create(i), this.__dataPending = Object.create(i), this.__dataOld = {};
    }
    /**
     * Overrides `PropertyAccessors` implementation to avoid setting
     * `_setProperty`'s `shouldNotify: true`.
     *
     * @override
     * @param {Object} props Properties to initialize on the instance
     * @return {void}
     */
    _initializeInstanceProperties(i) {
      let n = this[Oe.READ_ONLY];
      for (let o in i)
        (!n || !n[o]) && (this.__dataPending = this.__dataPending || {}, this.__dataOld = this.__dataOld || {}, this.__data[o] = this.__dataPending[o] = i[o]);
    }
    // Prototype setup ----------------------------------------
    /**
     * Equivalent to static `addPropertyEffect` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @override
     * @param {string} property Property that should trigger the effect
     * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
     * @param {Object=} effect Effect metadata object
     * @return {void}
     * @protected
     */
    _addPropertyEffect(i, n, o) {
      this._createPropertyAccessor(i, n == Oe.READ_ONLY);
      let a = Ho(this, n, !0)[i];
      a || (a = this[n][i] = []), a.push(o);
    }
    /**
     * Removes the given property effect.
     *
     * @override
     * @param {string} property Property the effect was associated with
     * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
     * @param {Object=} effect Effect metadata object to remove
     * @return {void}
     */
    _removePropertyEffect(i, n, o) {
      let a = Ho(this, n, !0)[i], l = a.indexOf(o);
      l >= 0 && a.splice(l, 1);
    }
    /**
     * Returns whether the current prototype/instance has a property effect
     * of a certain type.
     *
     * @override
     * @param {string} property Property name
     * @param {string=} type Effect type, from this.PROPERTY_EFFECT_TYPES
     * @return {boolean} True if the prototype/instance has an effect of this
     *     type
     * @protected
     */
    _hasPropertyEffect(i, n) {
      let o = this[n];
      return !!(o && o[i]);
    }
    /**
     * Returns whether the current prototype/instance has a "read only"
     * accessor for the given property.
     *
     * @override
     * @param {string} property Property name
     * @return {boolean} True if the prototype/instance has an effect of this
     *     type
     * @protected
     */
    _hasReadOnlyEffect(i) {
      return this._hasPropertyEffect(i, Oe.READ_ONLY);
    }
    /**
     * Returns whether the current prototype/instance has a "notify"
     * property effect for the given property.
     *
     * @override
     * @param {string} property Property name
     * @return {boolean} True if the prototype/instance has an effect of this
     *     type
     * @protected
     */
    _hasNotifyEffect(i) {
      return this._hasPropertyEffect(i, Oe.NOTIFY);
    }
    /**
     * Returns whether the current prototype/instance has a "reflect to
     * attribute" property effect for the given property.
     *
     * @override
     * @param {string} property Property name
     * @return {boolean} True if the prototype/instance has an effect of this
     *     type
     * @protected
     */
    _hasReflectEffect(i) {
      return this._hasPropertyEffect(i, Oe.REFLECT);
    }
    /**
     * Returns whether the current prototype/instance has a "computed"
     * property effect for the given property.
     *
     * @override
     * @param {string} property Property name
     * @return {boolean} True if the prototype/instance has an effect of this
     *     type
     * @protected
     */
    _hasComputedEffect(i) {
      return this._hasPropertyEffect(i, Oe.COMPUTE);
    }
    // Runtime ----------------------------------------
    /**
     * Sets a pending property or path.  If the root property of the path in
     * question had no accessor, the path is set, otherwise it is enqueued
     * via `_setPendingProperty`.
     *
     * This function isolates relatively expensive functionality necessary
     * for the public API (`set`, `setProperties`, `notifyPath`, and property
     * change listeners via {{...}} bindings), such that it is only done
     * when paths enter the system, and not at every propagation step.  It
     * also sets a `__dataHasPaths` flag on the instance which is used to
     * fast-path slower path-matching code in the property effects host paths.
     *
     * `path` can be a path string or array of path parts as accepted by the
     * public API.
     *
     * @override
     * @param {string | !Array<number|string>} path Path to set
     * @param {*} value Value to set
     * @param {boolean=} shouldNotify Set to true if this change should
     *  cause a property notification event dispatch
     * @param {boolean=} isPathNotification If the path being set is a path
     *   notification of an already changed value, as opposed to a request
     *   to set and notify the change.  In the latter `false` case, a dirty
     *   check is performed and then the value is set to the path before
     *   enqueuing the pending property change.
     * @return {boolean} Returns true if the property/path was enqueued in
     *   the pending changes bag.
     * @protected
     */
    _setPendingPropertyOrPath(i, n, o, a) {
      if (a || Ei(Array.isArray(i) ? i[0] : i) !== i) {
        if (!a) {
          let l = ht(this, i);
          if (i = /** @type {string} */
          el(this, i, n), !i || !super._shouldPropertyChange(i, n, l))
            return !1;
        }
        if (this.__dataHasPaths = !0, this._setPendingProperty(
          /**@type{string}*/
          i,
          n,
          o
        ))
          return Au(
            this,
            /**@type{string}*/
            i,
            n
          ), !0;
      } else {
        if (this.__dataHasAccessor && this.__dataHasAccessor[i])
          return this._setPendingProperty(
            /**@type{string}*/
            i,
            n,
            o
          );
        this[i] = n;
      }
      return !1;
    }
    /**
     * Applies a value to a non-Polymer element/node's property.
     *
     * The implementation makes a best-effort at binding interop:
     * Some native element properties have side-effects when
     * re-setting the same value (e.g. setting `<input>.value` resets the
     * cursor position), so we do a dirty-check before setting the value.
     * However, for better interop with non-Polymer custom elements that
     * accept objects, we explicitly re-set object changes coming from the
     * Polymer world (which may include deep object changes without the
     * top reference changing), erring on the side of providing more
     * information.
     *
     * Users may override this method to provide alternate approaches.
     *
     * @override
     * @param {!Node} node The node to set a property on
     * @param {string} prop The property to set
     * @param {*} value The value to set
     * @return {void}
     * @protected
     */
    _setUnmanagedPropertyToNode(i, n, o) {
      (o !== i[n] || typeof o == "object") && (n === "className" && (i = /** @type {!Node} */
      _i(i)), i[n] = o);
    }
    /**
     * Overrides the `PropertiesChanged` implementation to introduce special
     * dirty check logic depending on the property & value being set:
     *
     * 1. Any value set to a path (e.g. 'obj.prop': 42 or 'obj.prop': {...})
     *    Stored in `__dataTemp`, dirty checked against `__dataTemp`
     * 2. Object set to simple property (e.g. 'prop': {...})
     *    Stored in `__dataTemp` and `__data`, dirty checked against
     *    `__dataTemp` by default implementation of `_shouldPropertyChange`
     * 3. Primitive value set to simple property (e.g. 'prop': 42)
     *    Stored in `__data`, dirty checked against `__data`
     *
     * The dirty-check is important to prevent cycles due to two-way
     * notification, but paths and objects are only dirty checked against any
     * previous value set during this turn via a "temporary cache" that is
     * cleared when the last `_propertiesChanged` exits. This is so:
     * a. any cached array paths (e.g. 'array.3.prop') may be invalidated
     *    due to array mutations like shift/unshift/splice; this is fine
     *    since path changes are dirty-checked at user entry points like `set`
     * b. dirty-checking for objects only lasts one turn to allow the user
     *    to mutate the object in-place and re-set it with the same identity
     *    and have all sub-properties re-propagated in a subsequent turn.
     *
     * The temp cache is not necessarily sufficient to prevent invalid array
     * paths, since a splice can happen during the same turn (with pathological
     * user code); we could introduce a "fixup" for temporarily cached array
     * paths if needed: https://github.com/Polymer/polymer/issues/4227
     *
     * @override
     * @param {string} property Name of the property
     * @param {*} value Value to set
     * @param {boolean=} shouldNotify True if property should fire notification
     *   event (applies only for `notify: true` properties)
     * @return {boolean} Returns true if the property changed
     */
    _setPendingProperty(i, n, o) {
      let a = this.__dataHasPaths && us(i), l = a ? this.__dataTemp : this.__data;
      return this._shouldPropertyChange(i, n, l[i]) ? (this.__dataPending || (this.__dataPending = {}, this.__dataOld = {}), i in this.__dataOld || (this.__dataOld[i] = this.__data[i]), a ? this.__dataTemp[i] = n : this.__data[i] = n, this.__dataPending[i] = n, (a || this[Oe.NOTIFY] && this[Oe.NOTIFY][i]) && (this.__dataToNotify = this.__dataToNotify || {}, this.__dataToNotify[i] = o), !0) : !1;
    }
    /**
     * Overrides base implementation to ensure all accessors set `shouldNotify`
     * to true, for per-property notification tracking.
     *
     * @override
     * @param {string} property Name of the property
     * @param {*} value Value to set
     * @return {void}
     */
    _setProperty(i, n) {
      this._setPendingProperty(i, n, !0) && this._invalidateProperties();
    }
    /**
     * Overrides `PropertyAccessor`'s default async queuing of
     * `_propertiesChanged`: if `__dataReady` is false (has not yet been
     * manually flushed), the function no-ops; otherwise flushes
     * `_propertiesChanged` synchronously.
     *
     * @override
     * @return {void}
     */
    _invalidateProperties() {
      this.__dataReady && this._flushProperties();
    }
    /**
     * Enqueues the given client on a list of pending clients, whose
     * pending property changes can later be flushed via a call to
     * `_flushClients`.
     *
     * @override
     * @param {Object} client PropertyEffects client to enqueue
     * @return {void}
     * @protected
     */
    _enqueueClient(i) {
      this.__dataPendingClients = this.__dataPendingClients || [], i !== this && this.__dataPendingClients.push(i);
    }
    /**
     * Flushes any clients previously enqueued via `_enqueueClient`, causing
     * their `_flushProperties` method to run.
     *
     * @override
     * @return {void}
     * @protected
     */
    _flushClients() {
      this.__dataClientsReady ? this.__enableOrFlushClients() : (this.__dataClientsReady = !0, this._readyClients(), this.__dataReady = !0);
    }
    // NOTE: We ensure clients either enable or flush as appropriate. This
    // handles two corner cases:
    // (1) clients flush properly when connected/enabled before the host
    // enables; e.g.
    //   (a) Templatize stamps with no properties and does not flush and
    //   (b) the instance is inserted into dom and
    //   (c) then the instance flushes.
    // (2) clients enable properly when not connected/enabled when the host
    // flushes; e.g.
    //   (a) a template is runtime stamped and not yet connected/enabled
    //   (b) a host sets a property, causing stamped dom to flush
    //   (c) the stamped dom enables.
    __enableOrFlushClients() {
      let i = this.__dataPendingClients;
      if (i) {
        this.__dataPendingClients = null;
        for (let n = 0; n < i.length; n++) {
          let o = i[n];
          o.__dataEnabled ? o.__dataPending && o._flushProperties() : o._enableProperties();
        }
      }
    }
    /**
     * Perform any initial setup on client dom. Called before the first
     * `_flushProperties` call on client dom and before any element
     * observers are called.
     *
     * @override
     * @return {void}
     * @protected
     */
    _readyClients() {
      this.__enableOrFlushClients();
    }
    /**
     * Sets a bag of property changes to this instance, and
     * synchronously processes all effects of the properties as a batch.
     *
     * Property names must be simple properties, not paths.  Batched
     * path propagation is not supported.
     *
     * @override
     * @param {Object} props Bag of one or more key-value pairs whose key is
     *   a property and value is the new value to set for that property.
     * @param {boolean=} setReadOnly When true, any private values set in
     *   `props` will be set. By default, `setProperties` will not set
     *   `readOnly: true` root properties.
     * @return {void}
     * @public
     */
    setProperties(i, n) {
      for (let o in i)
        (n || !this[Oe.READ_ONLY] || !this[Oe.READ_ONLY][o]) && this._setPendingPropertyOrPath(o, i[o], !0);
      this._invalidateProperties();
    }
    /**
     * Overrides `PropertyAccessors` so that property accessor
     * side effects are not enabled until after client dom is fully ready.
     * Also calls `_flushClients` callback to ensure client dom is enabled
     * that was not enabled as a result of flushing properties.
     *
     * @override
     * @return {void}
     */
    ready() {
      this._flushProperties(), this.__dataClientsReady || this._flushClients(), this.__dataPending && this._flushProperties();
    }
    /**
     * Implements `PropertyAccessors`'s properties changed callback.
     *
     * Runs each class of effects for the batch of changed properties in
     * a specific order (compute, propagate, reflect, observe, notify).
     *
     * @override
     * @param {!Object} currentProps Bag of all current accessor values
     * @param {?Object} changedProps Bag of properties changed since the last
     *   call to `_propertiesChanged`
     * @param {?Object} oldProps Bag of previous values for each property
     *   in `changedProps`
     * @return {void}
     */
    _propertiesChanged(i, n, o) {
      let a = this.__dataHasPaths;
      this.__dataHasPaths = !1;
      let l;
      Eu(this, n, o, a), l = this.__dataToNotify, this.__dataToNotify = null, this._propagatePropertyChanges(n, o, a), this._flushClients(), xr(this, this[Oe.REFLECT], n, o, a), xr(this, this[Oe.OBSERVE], n, o, a), l && yu(this, l, n, o, a), this.__dataCounter == 1 && (this.__dataTemp = {});
    }
    /**
     * Called to propagate any property changes to stamped template nodes
     * managed by this element.
     *
     * @override
     * @param {Object} changedProps Bag of changed properties
     * @param {Object} oldProps Bag of previous values for changed properties
     * @param {boolean} hasPaths True with `props` contains one or more paths
     * @return {void}
     * @protected
     */
    _propagatePropertyChanges(i, n, o) {
      this[Oe.PROPAGATE] && xr(this, this[Oe.PROPAGATE], i, n, o), this.__templateInfo && this._runEffectsForTemplate(this.__templateInfo, i, n, o);
    }
    _runEffectsForTemplate(i, n, o, a) {
      const l = (h, d) => {
        xr(
          this,
          i.propertyEffects,
          h,
          o,
          d,
          i.nodeList
        );
        for (let f = i.firstChild; f; f = f.nextSibling)
          this._runEffectsForTemplate(f, h, o, d);
      };
      i.runEffects ? i.runEffects(l, n, a) : l(n, a);
    }
    /**
     * Aliases one data path as another, such that path notifications from one
     * are routed to the other.
     *
     * @override
     * @param {string | !Array<string|number>} to Target path to link.
     * @param {string | !Array<string|number>} from Source path to link.
     * @return {void}
     * @public
     */
    linkPaths(i, n) {
      i = wr(i), n = wr(n), this.__dataLinkedPaths = this.__dataLinkedPaths || {}, this.__dataLinkedPaths[i] = n;
    }
    /**
     * Removes a data path alias previously established with `_linkPaths`.
     *
     * Note, the path to unlink should be the target (`to`) used when
     * linking the paths.
     *
     * @override
     * @param {string | !Array<string|number>} path Target path to unlink.
     * @return {void}
     * @public
     */
    unlinkPaths(i) {
      i = wr(i), this.__dataLinkedPaths && delete this.__dataLinkedPaths[i];
    }
    /**
     * Notify that an array has changed.
     *
     * Example:
     *
     *     this.items = [ {name: 'Jim'}, {name: 'Todd'}, {name: 'Bill'} ];
     *     ...
     *     this.items.splice(1, 1, {name: 'Sam'});
     *     this.items.push({name: 'Bob'});
     *     this.notifySplices('items', [
     *       { index: 1, removed: [{name: 'Todd'}], addedCount: 1,
     *         object: this.items, type: 'splice' },
     *       { index: 3, removed: [], addedCount: 1,
     *         object: this.items, type: 'splice'}
     *     ]);
     *
     * @param {string} path Path that should be notified.
     * @param {Array} splices Array of splice records indicating ordered
     *   changes that occurred to the array. Each record should have the
     *   following fields:
     *    * index: index at which the change occurred
     *    * removed: array of items that were removed from this index
     *    * addedCount: number of new items added at this index
     *    * object: a reference to the array in question
     *    * type: the string literal 'splice'
     *
     *   Note that splice records _must_ be normalized such that they are
     *   reported in index order (raw results from `Object.observe` are not
     *   ordered and must be normalized/merged before notifying).
     *
     * @override
     * @return {void}
     * @public
     */
    notifySplices(i, n) {
      let o = { path: "" }, a = (
        /** @type {Array} */
        ht(this, i, o)
      );
      Pc(this, a, o.path, n);
    }
    /**
     * Convenience method for reading a value from a path.
     *
     * Note, if any part in the path is undefined, this method returns
     * `undefined` (this method does not throw when dereferencing undefined
     * paths).
     *
     * @override
     * @param {(string|!Array<(string|number)>)} path Path to the value
     *   to read.  The path may be specified as a string (e.g. `foo.bar.baz`)
     *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that
     *   bracketed expressions are not supported; string-based path parts
     *   *must* be separated by dots.  Note that when dereferencing array
     *   indices, the index may be used as a dotted part directly
     *   (e.g. `users.12.name` or `['users', 12, 'name']`).
     * @param {Object=} root Root object from which the path is evaluated.
     * @return {*} Value at the path, or `undefined` if any part of the path
     *   is undefined.
     * @public
     */
    get(i, n) {
      return ht(n || this, i);
    }
    /**
     * Convenience method for setting a value to a path and notifying any
     * elements bound to the same path.
     *
     * Note, if any part in the path except for the last is undefined,
     * this method does nothing (this method does not throw when
     * dereferencing undefined paths).
     *
     * @override
     * @param {(string|!Array<(string|number)>)} path Path to the value
     *   to write.  The path may be specified as a string (e.g. `'foo.bar.baz'`)
     *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that
     *   bracketed expressions are not supported; string-based path parts
     *   *must* be separated by dots.  Note that when dereferencing array
     *   indices, the index may be used as a dotted part directly
     *   (e.g. `'users.12.name'` or `['users', 12, 'name']`).
     * @param {*} value Value to set at the specified path.
     * @param {Object=} root Root object from which the path is evaluated.
     *   When specified, no notification will occur.
     * @return {void}
     * @public
     */
    set(i, n, o) {
      o ? el(o, i, n) : (!this[Oe.READ_ONLY] || !this[Oe.READ_ONLY][
        /** @type {string} */
        i
      ]) && this._setPendingPropertyOrPath(i, n, !0) && this._invalidateProperties();
    }
    /**
     * Adds items onto the end of the array at the path specified.
     *
     * The arguments after `path` and return value match that of
     * `Array.prototype.push`.
     *
     * This method notifies other paths to the same array that a
     * splice occurred to the array.
     *
     * @override
     * @param {string | !Array<string|number>} path Path to array.
     * @param {...*} items Items to push onto array
     * @return {number} New length of the array.
     * @public
     */
    push(i, ...n) {
      let o = { path: "" }, a = (
        /** @type {Array}*/
        ht(this, i, o)
      ), l = a.length, h = a.push(...n);
      return n.length && mr(this, a, o.path, l, n.length, []), h;
    }
    /**
     * Removes an item from the end of array at the path specified.
     *
     * The arguments after `path` and return value match that of
     * `Array.prototype.pop`.
     *
     * This method notifies other paths to the same array that a
     * splice occurred to the array.
     *
     * @override
     * @param {string | !Array<string|number>} path Path to array.
     * @return {*} Item that was removed.
     * @public
     */
    pop(i) {
      let n = { path: "" }, o = (
        /** @type {Array} */
        ht(this, i, n)
      ), a = !!o.length, l = o.pop();
      return a && mr(this, o, n.path, o.length, 0, [l]), l;
    }
    /**
     * Starting from the start index specified, removes 0 or more items
     * from the array and inserts 0 or more new items in their place.
     *
     * The arguments after `path` and return value match that of
     * `Array.prototype.splice`.
     *
     * This method notifies other paths to the same array that a
     * splice occurred to the array.
     *
     * @override
     * @param {string | !Array<string|number>} path Path to array.
     * @param {number} start Index from which to start removing/inserting.
     * @param {number=} deleteCount Number of items to remove.
     * @param {...*} items Items to insert into array.
     * @return {!Array} Array of removed items.
     * @public
     */
    splice(i, n, o, ...a) {
      let l = { path: "" }, h = (
        /** @type {Array} */
        ht(this, i, l)
      );
      n < 0 ? n = h.length - Math.floor(-n) : n && (n = Math.floor(n));
      let d;
      return arguments.length === 2 ? d = h.splice(n) : d = h.splice(n, o, ...a), (a.length || d.length) && mr(this, h, l.path, n, a.length, d), d;
    }
    /**
     * Removes an item from the beginning of array at the path specified.
     *
     * The arguments after `path` and return value match that of
     * `Array.prototype.pop`.
     *
     * This method notifies other paths to the same array that a
     * splice occurred to the array.
     *
     * @override
     * @param {string | !Array<string|number>} path Path to array.
     * @return {*} Item that was removed.
     * @public
     */
    shift(i) {
      let n = { path: "" }, o = (
        /** @type {Array} */
        ht(this, i, n)
      ), a = !!o.length, l = o.shift();
      return a && mr(this, o, n.path, 0, 0, [l]), l;
    }
    /**
     * Adds items onto the beginning of the array at the path specified.
     *
     * The arguments after `path` and return value match that of
     * `Array.prototype.push`.
     *
     * This method notifies other paths to the same array that a
     * splice occurred to the array.
     *
     * @override
     * @param {string | !Array<string|number>} path Path to array.
     * @param {...*} items Items to insert info array
     * @return {number} New length of the array.
     * @public
     */
    unshift(i, ...n) {
      let o = { path: "" }, a = (
        /** @type {Array} */
        ht(this, i, o)
      ), l = a.unshift(...n);
      return n.length && mr(this, a, o.path, 0, n.length, []), l;
    }
    /**
     * Notify that a path has changed.
     *
     * Example:
     *
     *     this.item.user.name = 'Bob';
     *     this.notifyPath('item.user.name');
     *
     * @override
     * @param {string} path Path that should be notified.
     * @param {*=} value Value at the path (optional).
     * @return {void}
     * @public
     */
    notifyPath(i, n) {
      let o;
      if (arguments.length == 1) {
        let a = { path: "" };
        n = ht(this, i, a), o = a.path;
      } else Array.isArray(i) ? o = wr(i) : o = /** @type{string} */
      i;
      this._setPendingPropertyOrPath(o, n, !0, !0) && this._invalidateProperties();
    }
    /**
     * Equivalent to static `createReadOnlyProperty` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @override
     * @param {string} property Property name
     * @param {boolean=} protectedSetter Creates a custom protected setter
     *   when `true`.
     * @return {void}
     * @protected
     */
    _createReadOnlyProperty(i, n) {
      this._addPropertyEffect(i, Oe.READ_ONLY), n && (this["_set" + Ju(i)] = /** @this {PropertyEffects} */
      function(o) {
        this._setProperty(i, o);
      });
    }
    /**
     * Equivalent to static `createPropertyObserver` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @override
     * @param {string} property Property name
     * @param {string|function(*,*)} method Function or name of observer method
     *     to call
     * @param {boolean=} dynamicFn Whether the method name should be included as
     *   a dependency to the effect.
     * @return {void}
     * @protected
     */
    _createPropertyObserver(i, n, o) {
      let a = { property: i, method: n, dynamicFn: !!o };
      this._addPropertyEffect(i, Oe.OBSERVE, {
        fn: rl,
        info: a,
        trigger: { name: i }
      }), o && this._addPropertyEffect(
        /** @type {string} */
        n,
        Oe.OBSERVE,
        {
          fn: rl,
          info: a,
          trigger: { name: n }
        }
      );
    }
    /**
     * Equivalent to static `createMethodObserver` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @override
     * @param {string} expression Method expression
     * @param {boolean|Object=} dynamicFn Boolean or object map indicating
     *   whether method names should be included as a dependency to the effect.
     * @return {void}
     * @protected
     */
    _createMethodObserver(i, n) {
      let o = Uo(i);
      if (!o)
        throw new Error("Malformed observer expression '" + i + "'");
      ol(this, o, Oe.OBSERVE, ps, null, n);
    }
    /**
     * Equivalent to static `createNotifyingProperty` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @override
     * @param {string} property Property name
     * @return {void}
     * @protected
     */
    _createNotifyingProperty(i) {
      this._addPropertyEffect(i, Oe.NOTIFY, {
        fn: xu,
        info: {
          eventName: Xn(i) + "-changed",
          property: i
        }
      });
    }
    /**
     * Equivalent to static `createReflectedProperty` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @override
     * @param {string} property Property name
     * @return {void}
     * @protected
     * @suppress {missingProperties} go/missingfnprops
     */
    _createReflectedProperty(i) {
      let n = this.constructor.attributeNameForProperty(i);
      n[0] === "-" ? console.warn("Property " + i + " cannot be reflected to attribute " + n + ' because "-" is not a valid starting attribute name. Use a lowercase first letter for the property instead.') : this._addPropertyEffect(i, Oe.REFLECT, {
        fn: Tu,
        info: {
          attrName: n
        }
      });
    }
    /**
     * Equivalent to static `createComputedProperty` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @override
     * @param {string} property Name of computed property to set
     * @param {string} expression Method expression
     * @param {boolean|Object=} dynamicFn Boolean or object map indicating
     *   whether method names should be included as a dependency to the effect.
     * @return {void}
     * @protected
     */
    _createComputedProperty(i, n, o) {
      let a = Uo(n);
      if (!a)
        throw new Error("Malformed computed expression '" + n + "'");
      const l = ol(this, a, Oe.COMPUTE, Cc, i, o);
      Ho(this, wc)[i] = l;
    }
    /**
     * Gather the argument values for a method specified in the provided array
     * of argument metadata.
     *
     * The `path` and `value` arguments are used to fill in wildcard descriptor
     * when the method is being called as a result of a path notification.
     *
     * @param {!Array<!MethodArg>} args Array of argument metadata
     * @param {string} path Property/path name that triggered the method effect
     * @param {Object} props Bag of current property changes
     * @return {!Array<*>} Array of argument values
     * @private
     */
    _marshalArgs(i, n, o) {
      const a = this.__data, l = [];
      for (let h = 0, d = i.length; h < d; h++) {
        let { name: f, structured: g, wildcard: w, value: C, literal: E } = i[h];
        if (!E)
          if (w) {
            const A = Nn(f, n), I = cl(a, o, A ? n : f);
            C = {
              path: A ? n : f,
              value: I,
              base: A ? ht(a, f) : I
            };
          } else
            C = g ? cl(a, o, f) : a[f];
        if (ds && !this._overrideLegacyUndefined && C === void 0 && i.length > 1)
          return zr;
        l[h] = C;
      }
      return l;
    }
    // -- static class methods ------------
    /**
     * Ensures an accessor exists for the specified property, and adds
     * to a list of "property effects" that will run when the accessor for
     * the specified property is set.  Effects are grouped by "type", which
     * roughly corresponds to a phase in effect processing.  The effect
     * metadata should be in the following form:
     *
     *     {
     *       fn: effectFunction, // Reference to function to call to perform effect
     *       info: { ... }       // Effect metadata passed to function
     *       trigger: {          // Optional triggering metadata; if not provided
     *         name: string      // the property is treated as a wildcard
     *         structured: boolean
     *         wildcard: boolean
     *       }
     *     }
     *
     * Effects are called from `_propertiesChanged` in the following order by
     * type:
     *
     * 1. COMPUTE
     * 2. PROPAGATE
     * 3. REFLECT
     * 4. OBSERVE
     * 5. NOTIFY
     *
     * Effect functions are called with the following signature:
     *
     *     effectFunction(inst, path, props, oldProps, info, hasPaths)
     *
     * @param {string} property Property that should trigger the effect
     * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
     * @param {Object=} effect Effect metadata object
     * @return {void}
     * @protected
     * @nocollapse
     */
    static addPropertyEffect(i, n, o) {
      this.prototype._addPropertyEffect(i, n, o);
    }
    /**
     * Creates a single-property observer for the given property.
     *
     * @param {string} property Property name
     * @param {string|function(*,*)} method Function or name of observer method to call
     * @param {boolean=} dynamicFn Whether the method name should be included as
     *   a dependency to the effect.
     * @return {void}
     * @protected
     * @nocollapse
     */
    static createPropertyObserver(i, n, o) {
      this.prototype._createPropertyObserver(i, n, o);
    }
    /**
     * Creates a multi-property "method observer" based on the provided
     * expression, which should be a string in the form of a normal JavaScript
     * function signature: `'methodName(arg1, [..., argn])'`.  Each argument
     * should correspond to a property or path in the context of this
     * prototype (or instance), or may be a literal string or number.
     *
     * @param {string} expression Method expression
     * @param {boolean|Object=} dynamicFn Boolean or object map indicating
     * @return {void}
     *   whether method names should be included as a dependency to the effect.
     * @protected
     * @nocollapse
     */
    static createMethodObserver(i, n) {
      this.prototype._createMethodObserver(i, n);
    }
    /**
     * Causes the setter for the given property to dispatch `<property>-changed`
     * events to notify of changes to the property.
     *
     * @param {string} property Property name
     * @return {void}
     * @protected
     * @nocollapse
     */
    static createNotifyingProperty(i) {
      this.prototype._createNotifyingProperty(i);
    }
    /**
     * Creates a read-only accessor for the given property.
     *
     * To set the property, use the protected `_setProperty` API.
     * To create a custom protected setter (e.g. `_setMyProp()` for
     * property `myProp`), pass `true` for `protectedSetter`.
     *
     * Note, if the property will have other property effects, this method
     * should be called first, before adding other effects.
     *
     * @param {string} property Property name
     * @param {boolean=} protectedSetter Creates a custom protected setter
     *   when `true`.
     * @return {void}
     * @protected
     * @nocollapse
     */
    static createReadOnlyProperty(i, n) {
      this.prototype._createReadOnlyProperty(i, n);
    }
    /**
     * Causes the setter for the given property to reflect the property value
     * to a (dash-cased) attribute of the same name.
     *
     * @param {string} property Property name
     * @return {void}
     * @protected
     * @nocollapse
     */
    static createReflectedProperty(i) {
      this.prototype._createReflectedProperty(i);
    }
    /**
     * Creates a computed property whose value is set to the result of the
     * method described by the given `expression` each time one or more
     * arguments to the method changes.  The expression should be a string
     * in the form of a normal JavaScript function signature:
     * `'methodName(arg1, [..., argn])'`
     *
     * @param {string} property Name of computed property to set
     * @param {string} expression Method expression
     * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether
     *   method names should be included as a dependency to the effect.
     * @return {void}
     * @protected
     * @nocollapse
     */
    static createComputedProperty(i, n, o) {
      this.prototype._createComputedProperty(i, n, o);
    }
    /**
     * Parses the provided template to ensure binding effects are created
     * for them, and then ensures property accessors are created for any
     * dependent properties in the template.  Binding effects for bound
     * templates are stored in a linked list on the instance so that
     * templates can be efficiently stamped and unstamped.
     *
     * @param {!HTMLTemplateElement} template Template containing binding
     *   bindings
     * @return {!TemplateInfo} Template metadata object
     * @protected
     * @nocollapse
     */
    static bindTemplate(i) {
      return this.prototype._bindTemplate(i);
    }
    // -- binding ----------------------------------------------
    /*
     * Overview of binding flow:
     *
     * During finalization (`instanceBinding==false`, `wasPreBound==false`):
     *  `_bindTemplate(t, false)` called directly during finalization - parses
     *  the template (for the first time), and then assigns that _prototypical_
     *  template info to `__preboundTemplateInfo` _on the prototype_; note in
     *  this case `wasPreBound` is false; this is the first time we're binding
     *  it, thus we create accessors.
     *
     * During first stamping (`instanceBinding==true`, `wasPreBound==true`):
     *   `_stampTemplate` calls `_bindTemplate(t, true)`: the `templateInfo`
     *   returned matches the prebound one, and so this is `wasPreBound == true`
     *   state; thus we _skip_ creating accessors, but _do_ create an instance
     *   of the template info to serve as the start of our linked list (needs to
     *   be an instance, not the prototypical one, so that we can add `nodeList`
     *   to it to contain the `nodeInfo`-ordered list of instance nodes for
     *   bindings, and so we can chain runtime-stamped template infos off of
     *   it). At this point, the call to `_stampTemplate` calls
     *   `applyTemplateInfo` for each nested `<template>` found during parsing
     *   to hand prototypical `_templateInfo` to them; we also pass the _parent_
     *   `templateInfo` to the `<template>` so that we have the instance-time
     *   parent to link the `templateInfo` under in the case it was
     *   runtime-stamped.
     *
     * During subsequent runtime stamping (`instanceBinding==true`,
     *   `wasPreBound==false`): `_stampTemplate` calls `_bindTemplate(t, true)`
     *   - here `templateInfo` is guaranteed to _not_ match the prebound one,
     *   because it was either a different template altogether, or even if it
     *   was the same template, the step above created a instance of the info;
     *   in this case `wasPreBound == false`, so we _do_ create accessors, _and_
     *   link a instance into the linked list.
     */
    /**
     * Equivalent to static `bindTemplate` API but can be called on an instance
     * to add effects at runtime.  See that method for full API docs.
     *
     * This method may be called on the prototype (for prototypical template
     * binding, to avoid creating accessors every instance) once per prototype,
     * and will be called with `runtimeBinding: true` by `_stampTemplate` to
     * create and link an instance of the template metadata associated with a
     * particular stamping.
     *
     * @override
     * @param {!HTMLTemplateElement} template Template containing binding
     * bindings
     * @param {boolean=} instanceBinding When false (default), performs
     * "prototypical" binding of the template and overwrites any previously
     * bound template for the class. When true (as passed from
     * `_stampTemplate`), the template info is instanced and linked into the
     * list of bound templates.
     * @return {!TemplateInfo} Template metadata object; for `runtimeBinding`,
     * this is an instance of the prototypical template info
     * @protected
     * @suppress {missingProperties} go/missingfnprops
     */
    _bindTemplate(i, n) {
      let o = this.constructor._parseTemplate(i), a = this.__preBoundTemplateInfo == o;
      if (!a)
        for (let l in o.propertyEffects)
          this._createPropertyAccessor(l);
      if (n)
        if (o = /** @type {!TemplateInfo} */
        Object.create(o), o.wasPreBound = a, !this.__templateInfo)
          this.__templateInfo = o;
        else {
          const l = i._parentTemplateInfo || this.__templateInfo, h = l.lastChild;
          o.parent = l, l.lastChild = o, o.previousSibling = h, h ? h.nextSibling = o : l.firstChild = o;
        }
      else
        this.__preBoundTemplateInfo = o;
      return o;
    }
    /**
     * Adds a property effect to the given template metadata, which is run
     * at the "propagate" stage of `_propertiesChanged` when the template
     * has been bound to the element via `_bindTemplate`.
     *
     * The `effect` object should match the format in `_addPropertyEffect`.
     *
     * @param {Object} templateInfo Template metadata to add effect to
     * @param {string} prop Property that should trigger the effect
     * @param {Object=} effect Effect metadata object
     * @return {void}
     * @protected
     * @nocollapse
     */
    static _addTemplatePropertyEffect(i, n, o) {
      let a = i.hostProps = i.hostProps || {};
      a[n] = !0;
      let l = i.propertyEffects = i.propertyEffects || {};
      (l[n] = l[n] || []).push(o);
    }
    /**
     * Stamps the provided template and performs instance-time setup for
     * Polymer template features, including data bindings, declarative event
     * listeners, and the `this.$` map of `id`'s to nodes.  A document fragment
     * is returned containing the stamped DOM, ready for insertion into the
     * DOM.
     *
     * This method may be called more than once; however note that due to
     * `shadycss` polyfill limitations, only styles from templates prepared
     * using `ShadyCSS.prepareTemplate` will be correctly polyfilled (scoped
     * to the shadow root and support CSS custom properties), and note that
     * `ShadyCSS.prepareTemplate` may only be called once per element. As such,
     * any styles required by in runtime-stamped templates must be included
     * in the main element template.
     *
     * @param {!HTMLTemplateElement} template Template to stamp
     * @param {TemplateInfo=} templateInfo Optional bound template info associated
     *   with the template to be stamped; if omitted the template will be
     *   automatically bound.
     * @return {!StampedTemplate} Cloned template content
     * @override
     * @protected
     */
    _stampTemplate(i, n) {
      n = n || /** @type {!TemplateInfo} */
      this._bindTemplate(i, !0), vr.push(this);
      let o = super._stampTemplate(i, n);
      if (vr.pop(), n.nodeList = o.nodeList, !n.wasPreBound) {
        let a = n.childNodes = [];
        for (let l = o.firstChild; l; l = l.nextSibling)
          a.push(l);
      }
      return o.templateInfo = n, Fu(this, n), this.__dataClientsReady && (this._runEffectsForTemplate(n, this.__data, null, !1), this._flushClients()), o;
    }
    /**
     * Removes and unbinds the nodes previously contained in the provided
     * DocumentFragment returned from `_stampTemplate`.
     *
     * @override
     * @param {!StampedTemplate} dom DocumentFragment previously returned
     *   from `_stampTemplate` associated with the nodes to be removed
     * @return {void}
     * @protected
     */
    _removeBoundDom(i) {
      const n = i.templateInfo, { previousSibling: o, nextSibling: a, parent: l } = n;
      o ? o.nextSibling = a : l && (l.firstChild = a), a ? a.previousSibling = o : l && (l.lastChild = o), n.nextSibling = n.previousSibling = null;
      let h = n.childNodes;
      for (let d = 0; d < h.length; d++) {
        let f = h[d];
        _i(_i(f).parentNode).removeChild(f);
      }
    }
    /**
     * Overrides default `TemplateStamp` implementation to add support for
     * parsing bindings from `TextNode`'s' `textContent`.  A `bindings`
     * array is added to `nodeInfo` and populated with binding metadata
     * with information capturing the binding target, and a `parts` array
     * with one or more metadata objects capturing the source(s) of the
     * binding.
     *
     * @param {Node} node Node to parse
     * @param {TemplateInfo} templateInfo Template metadata for current template
     * @param {NodeInfo} nodeInfo Node metadata for current template node
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     * @protected
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     * @nocollapse
     */
    static _parseTemplateNode(i, n, o) {
      let a = r._parseTemplateNode.call(
        this,
        i,
        n,
        o
      );
      if (i.nodeType === Node.TEXT_NODE) {
        let l = this._parseBindings(i.textContent, n);
        l && (i.textContent = ll(l) || " ", Vo(this, n, o, "text", "textContent", l), a = !0);
      }
      return a;
    }
    /**
     * Overrides default `TemplateStamp` implementation to add support for
     * parsing bindings from attributes.  A `bindings`
     * array is added to `nodeInfo` and populated with binding metadata
     * with information capturing the binding target, and a `parts` array
     * with one or more metadata objects capturing the source(s) of the
     * binding.
     *
     * @param {Element} node Node to parse
     * @param {TemplateInfo} templateInfo Template metadata for current template
     * @param {NodeInfo} nodeInfo Node metadata for current template node
     * @param {string} name Attribute name
     * @param {string} value Attribute value
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     * @protected
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     * @nocollapse
     */
    static _parseTemplateNodeAttribute(i, n, o, a, l) {
      let h = this._parseBindings(l, n);
      if (h) {
        let d = a, f = "property";
        _u.test(a) ? f = "attribute" : a[a.length - 1] == "$" && (a = a.slice(0, -1), f = "attribute");
        let g = ll(h);
        return g && f == "attribute" && (a == "class" && i.hasAttribute("class") && (g += " " + i.getAttribute(a)), i.setAttribute(a, g)), f == "attribute" && d == "disable-upgrade$" && i.setAttribute(a, ""), i.localName === "input" && d === "value" && i.setAttribute(d, ""), i.removeAttribute(d), f === "property" && (a = gc(a)), Vo(this, n, o, f, a, h, g), !0;
      } else
        return r._parseTemplateNodeAttribute.call(
          this,
          i,
          n,
          o,
          a,
          l
        );
    }
    /**
     * Overrides default `TemplateStamp` implementation to add support for
     * binding the properties that a nested template depends on to the template
     * as `_host_<property>`.
     *
     * @param {Node} node Node to parse
     * @param {TemplateInfo} templateInfo Template metadata for current template
     * @param {NodeInfo} nodeInfo Node metadata for current template node
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     * @protected
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     * @nocollapse
     */
    static _parseTemplateNestedTemplate(i, n, o) {
      let a = r._parseTemplateNestedTemplate.call(
        this,
        i,
        n,
        o
      );
      const l = i.parentNode, h = o.templateInfo, d = l.localName === "dom-if", f = l.localName === "dom-repeat";
      Ya && (d || f) && (l.removeChild(i), o = o.parentInfo, o.templateInfo = h, o.noted = !0, a = !1);
      let g = h.hostProps;
      if (Ud && d)
        g && (n.hostProps = Object.assign(n.hostProps || {}, g), Ya || (o.parentInfo.noted = !0));
      else {
        let w = "{";
        for (let C in g) {
          let E = [{ mode: w, source: C, dependencies: [C], hostProp: !0 }];
          Vo(this, n, o, "property", "_host_" + C, E);
        }
      }
      return a;
    }
    /**
     * Called to parse text in a template (either attribute values or
     * textContent) into binding metadata.
     *
     * Any overrides of this method should return an array of binding part
     * metadata  representing one or more bindings found in the provided text
     * and any "literal" text in between.  Any non-literal parts will be passed
     * to `_evaluateBinding` when any dependencies change.  The only required
     * fields of each "part" in the returned array are as follows:
     *
     * - `dependencies` - Array containing trigger metadata for each property
     *   that should trigger the binding to update
     * - `literal` - String containing text if the part represents a literal;
     *   in this case no `dependencies` are needed
     *
     * Additional metadata for use by `_evaluateBinding` may be provided in
     * each part object as needed.
     *
     * The default implementation handles the following types of bindings
     * (one or more may be intermixed with literal strings):
     * - Property binding: `[[prop]]`
     * - Path binding: `[[object.prop]]`
     * - Negated property or path bindings: `[[!prop]]` or `[[!object.prop]]`
     * - Two-way property or path bindings (supports negation):
     *   `{{prop}}`, `{{object.prop}}`, `{{!prop}}` or `{{!object.prop}}`
     * - Inline computed method (supports negation):
     *   `[[compute(a, 'literal', b)]]`, `[[!compute(a, 'literal', b)]]`
     *
     * The default implementation uses a regular expression for best
     * performance. However, the regular expression uses a white-list of
     * allowed characters in a data-binding, which causes problems for
     * data-bindings that do use characters not in this white-list.
     *
     * Instead of updating the white-list with all allowed characters,
     * there is a StrictBindingParser (see lib/mixins/strict-binding-parser)
     * that uses a state machine instead. This state machine is able to handle
     * all characters. However, it is slightly less performant, therefore we
     * extracted it into a separate optional mixin.
     *
     * @param {string} text Text to parse from attribute or textContent
     * @param {Object} templateInfo Current template metadata
     * @return {Array<!BindingPart>} Array of binding part metadata
     * @protected
     * @nocollapse
     */
    static _parseBindings(i, n) {
      let o = [], a = 0, l;
      for (; (l = al.exec(i)) !== null; ) {
        l.index > a && o.push({ literal: i.slice(a, l.index) });
        let h = l[1][0], d = !!l[2], f = l[3].trim(), g = !1, w = "", C = -1;
        h == "{" && (C = f.indexOf("::")) > 0 && (w = f.substring(C + 2), f = f.substring(0, C), g = !0);
        let E = Uo(f), A = [];
        if (E) {
          let { args: I, methodName: V } = E;
          for (let ce = 0; ce < I.length; ce++) {
            let re = I[ce];
            re.literal || A.push(re);
          }
          let K = n.dynamicFns;
          (K && K[V] || E.static) && (A.push(V), E.dynamicFn = !0);
        } else
          A.push(f);
        o.push({
          source: f,
          mode: h,
          negate: d,
          customEvent: g,
          signature: E,
          dependencies: A,
          event: w
        }), a = al.lastIndex;
      }
      if (a && a < i.length) {
        let h = i.substring(a);
        h && o.push({
          literal: h
        });
      }
      return o.length ? o : null;
    }
    /**
     * Called to evaluate a previously parsed binding part based on a set of
     * one or more changed dependencies.
     *
     * @param {!Polymer_PropertyEffects} inst Element that should be used as
     *     scope for binding dependencies
     * @param {BindingPart} part Binding part metadata
     * @param {string} path Property/path that triggered this effect
     * @param {Object} props Bag of current property changes
     * @param {Object} oldProps Bag of previous values for changed properties
     * @param {boolean} hasPaths True with `props` contains one or more paths
     * @return {*} Value the binding part evaluated to
     * @protected
     * @nocollapse
     */
    static _evaluateBinding(i, n, o, a, l, h) {
      let d;
      return n.signature ? d = ps(i, o, a, l, n.signature) : o != n.source ? d = ht(i, n.source) : h && us(o) ? d = ht(i, o) : d = i.__data[o], n.negate && (d = !d), d;
    }
  }
  return e;
}), vr = [];
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
function $u(s) {
  const r = {};
  for (let e in s) {
    const t = s[e];
    r[e] = typeof t == "function" ? { type: t } : t;
  }
  return r;
}
const ef = $e((s) => {
  const r = _c(s);
  function e(n) {
    const o = Object.getPrototypeOf(n);
    return o.prototype instanceof i ? (
      /** @type {!PropertiesMixinConstructor} */
      o
    ) : null;
  }
  function t(n) {
    if (!n.hasOwnProperty(JSCompiler_renameProperty("__ownProperties", n))) {
      let o = null;
      if (n.hasOwnProperty(JSCompiler_renameProperty("properties", n))) {
        const a = n.properties;
        a && (o = $u(a));
      }
      n.__ownProperties = o;
    }
    return n.__ownProperties;
  }
  class i extends r {
    /**
     * Implements standard custom elements getter to observes the attributes
     * listed in `properties`.
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     * @nocollapse
     */
    static get observedAttributes() {
      if (!this.hasOwnProperty(JSCompiler_renameProperty("__observedAttributes", this))) {
        this.prototype;
        const o = this._properties;
        this.__observedAttributes = o ? Object.keys(o).map((a) => this.prototype._addPropertyToAttributeMap(a)) : [];
      }
      return this.__observedAttributes;
    }
    /**
     * Finalizes an element definition, including ensuring any super classes
     * are also finalized. This includes ensuring property
     * accessors exist on the element prototype. This method calls
     * `_finalizeClass` to finalize each constructor in the prototype chain.
     * @return {void}
     * @nocollapse
     */
    static finalize() {
      if (!this.hasOwnProperty(JSCompiler_renameProperty("__finalized", this))) {
        const o = e(
          /** @type {!PropertiesMixinConstructor} */
          this
        );
        o && o.finalize(), this.__finalized = !0, this._finalizeClass();
      }
    }
    /**
     * Finalize an element class. This includes ensuring property
     * accessors exist on the element prototype. This method is called by
     * `finalize` and finalizes the class constructor.
     *
     * @protected
     * @nocollapse
     */
    static _finalizeClass() {
      const o = t(
        /** @type {!PropertiesMixinConstructor} */
        this
      );
      o && this.createProperties(o);
    }
    /**
     * Returns a memoized version of all properties, including those inherited
     * from super classes. Properties not in object format are converted to
     * at least {type}.
     *
     * @return {Object} Object containing properties for this class
     * @protected
     * @nocollapse
     */
    static get _properties() {
      if (!this.hasOwnProperty(
        JSCompiler_renameProperty("__properties", this)
      )) {
        const o = e(
          /** @type {!PropertiesMixinConstructor} */
          this
        );
        this.__properties = Object.assign(
          {},
          o && o._properties,
          t(
            /** @type {PropertiesMixinConstructor} */
            this
          )
        );
      }
      return this.__properties;
    }
    /**
     * Overrides `PropertiesChanged` method to return type specified in the
     * static `properties` object for the given property.
     * @param {string} name Name of property
     * @return {*} Type to which to deserialize attribute
     *
     * @protected
     * @nocollapse
     */
    static typeForProperty(o) {
      const a = this._properties[o];
      return a && a.type;
    }
    /**
     * Overrides `PropertiesChanged` method and adds a call to
     * `finalize` which lazily configures the element's property accessors.
     * @override
     * @return {void}
     */
    _initializeProperties() {
      this.constructor.finalize(), super._initializeProperties();
    }
    /**
     * Called when the element is added to a document.
     * Calls `_enableProperties` to turn on property system from
     * `PropertiesChanged`.
     * @suppress {missingProperties} Super may or may not implement the callback
     * @return {void}
     * @override
     */
    connectedCallback() {
      super.connectedCallback && super.connectedCallback(), this._enableProperties();
    }
    /**
     * Called when the element is removed from a document
     * @suppress {missingProperties} Super may or may not implement the callback
     * @return {void}
     * @override
     */
    disconnectedCallback() {
      super.disconnectedCallback && super.disconnectedCallback();
    }
  }
  return i;
});
/**
 * @fileoverview
 * @suppress {checkPrototypalTypes}
 * @license Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt The complete set of authors may be found
 * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may
 * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by
 * Google as part of the polymer project is also subject to an additional IP
 * rights grant found at http://polymer.github.io/PATENTS.txt
 */
const tf = "3.5.1", hl = window.ShadyCSS && window.ShadyCSS.cssBuild, rf = $e((s) => {
  const r = ef(Qu(s));
  function e(l) {
    if (!l.hasOwnProperty(
      JSCompiler_renameProperty("__propertyDefaults", l)
    )) {
      l.__propertyDefaults = null;
      let h = l._properties;
      for (let d in h) {
        let f = h[d];
        "value" in f && (l.__propertyDefaults = l.__propertyDefaults || {}, l.__propertyDefaults[d] = f);
      }
    }
    return l.__propertyDefaults;
  }
  function t(l) {
    return l.hasOwnProperty(
      JSCompiler_renameProperty("__ownObservers", l)
    ) || (l.__ownObservers = l.hasOwnProperty(
      JSCompiler_renameProperty("observers", l)
    ) ? (
      /** @type {PolymerElementConstructor} */
      l.observers
    ) : null), l.__ownObservers;
  }
  function i(l, h, d, f) {
    d.computed && (d.readOnly = !0), d.computed && (l._hasReadOnlyEffect(h) ? console.warn(`Cannot redefine computed property '${h}'.`) : l._createComputedProperty(h, d.computed, f)), d.readOnly && !l._hasReadOnlyEffect(h) ? l._createReadOnlyProperty(h, !d.computed) : d.readOnly === !1 && l._hasReadOnlyEffect(h) && console.warn(`Cannot make readOnly property '${h}' non-readOnly.`), d.reflectToAttribute && !l._hasReflectEffect(h) ? l._createReflectedProperty(h) : d.reflectToAttribute === !1 && l._hasReflectEffect(h) && console.warn(`Cannot make reflected property '${h}' non-reflected.`), d.notify && !l._hasNotifyEffect(h) ? l._createNotifyingProperty(h) : d.notify === !1 && l._hasNotifyEffect(h) && console.warn(`Cannot make notify property '${h}' non-notify.`), d.observer && l._createPropertyObserver(h, d.observer, f[d.observer]), l._addPropertyToAttributeMap(h);
  }
  function n(l, h, d, f) {
    if (!hl) {
      const g = h.content.querySelectorAll("style"), w = uc(h), C = Xd(d), E = h.content.firstElementChild;
      for (let I = 0; I < C.length; I++) {
        let V = C[I];
        V.textContent = l._processStyleText(V.textContent, f), h.content.insertBefore(V, E);
      }
      let A = 0;
      for (let I = 0; I < w.length; I++) {
        let V = w[I], K = g[A];
        K !== V ? (V = V.cloneNode(!0), K.parentNode.insertBefore(V, K)) : A++, V.textContent = l._processStyleText(V.textContent, f);
      }
    }
    if (window.ShadyCSS && window.ShadyCSS.prepareTemplate(h, d), Wd && hl && Fd) {
      const g = h.content.querySelectorAll("style");
      if (g) {
        let w = "";
        Array.from(g).forEach((C) => {
          w += C.textContent, C.parentNode.removeChild(C);
        }), l._styleSheet = new CSSStyleSheet(), l._styleSheet.replaceSync(w);
      }
    }
  }
  function o(l) {
    let h = null;
    if (l && (!hs || Ld) && (h = /** @type {?HTMLTemplateElement} */
    Dr.import(l, "template"), hs && !h))
      throw new Error(`strictTemplatePolicy: expecting dom-module or null template for ${l}`);
    return h;
  }
  class a extends r {
    /**
     * Current Polymer version in Semver notation.
     * @type {string} Semver notation of the current version of Polymer.
     * @nocollapse
     */
    static get polymerElementVersion() {
      return tf;
    }
    /**
     * Override of PropertiesMixin _finalizeClass to create observers and
     * find the template.
     * @return {void}
     * @protected
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     * @nocollapse
     */
    static _finalizeClass() {
      r._finalizeClass.call(this);
      const h = t(this);
      h && this.createObservers(h, this._properties), this._prepareTemplate();
    }
    /** @nocollapse */
    static _prepareTemplate() {
      let h = (
        /** @type {PolymerElementConstructor} */
        this.template
      );
      h && (typeof h == "string" ? (console.error("template getter must return HTMLTemplateElement"), h = null) : Bd || (h = h.cloneNode(!0))), this.prototype._template = h;
    }
    /**
     * Override of PropertiesChanged createProperties to create accessors
     * and property effects for all of the properties.
     * @param {!Object} props .
     * @return {void}
     * @protected
     * @nocollapse
     */
    static createProperties(h) {
      for (let d in h)
        i(
          /** @type {?} */
          this.prototype,
          d,
          h[d],
          h
        );
    }
    /**
     * Creates observers for the given `observers` array.
     * Leverages `PropertyEffects` to create observers.
     * @param {Object} observers Array of observer descriptors for
     *   this class
     * @param {Object} dynamicFns Object containing keys for any properties
     *   that are functions and should trigger the effect when the function
     *   reference is changed
     * @return {void}
     * @protected
     * @nocollapse
     */
    static createObservers(h, d) {
      const f = this.prototype;
      for (let g = 0; g < h.length; g++)
        f._createMethodObserver(h[g], d);
    }
    /**
     * Returns the template that will be stamped into this element's shadow root.
     *
     * If a `static get is()` getter is defined, the default implementation will
     * return the first `<template>` in a `dom-module` whose `id` matches this
     * element's `is` (note that a `_template` property on the class prototype
     * takes precedence over the `dom-module` template, to maintain legacy
     * element semantics; a subclass will subsequently fall back to its super
     * class template if neither a `prototype._template` or a `dom-module` for
     * the class's `is` was found).
     *
     * Users may override this getter to return an arbitrary template
     * (in which case the `is` getter is unnecessary). The template returned
     * must be an `HTMLTemplateElement`.
     *
     * Note that when subclassing, if the super class overrode the default
     * implementation and the subclass would like to provide an alternate
     * template via a `dom-module`, it should override this getter and
     * return `DomModule.import(this.is, 'template')`.
     *
     * If a subclass would like to modify the super class template, it should
     * clone it rather than modify it in place.  If the getter does expensive
     * work such as cloning/modifying a template, it should memoize the
     * template for maximum performance:
     *
     *   let memoizedTemplate;
     *   class MySubClass extends MySuperClass {
     *     static get template() {
     *       if (!memoizedTemplate) {
     *         memoizedTemplate = super.template.cloneNode(true);
     *         let subContent = document.createElement('div');
     *         subContent.textContent = 'This came from MySubClass';
     *         memoizedTemplate.content.appendChild(subContent);
     *       }
     *       return memoizedTemplate;
     *     }
     *   }
     *
     * @return {!HTMLTemplateElement|string} Template to be stamped
     * @nocollapse
     */
    static get template() {
      if (!this.hasOwnProperty(JSCompiler_renameProperty("_template", this))) {
        let h = this.prototype.hasOwnProperty(
          JSCompiler_renameProperty("_template", this.prototype)
        ) ? this.prototype._template : void 0;
        typeof h == "function" && (h = h()), this._template = // If user has put template on prototype (e.g. in legacy via registered
        // callback or info object), prefer that first. Note that `null` is
        // used as a sentinel to indicate "no template" and can be used to
        // override a super template, whereas `undefined` is used as a
        // sentinel to mean "fall-back to default template lookup" via
        // dom-module and/or super.template.
        h !== void 0 ? h : (
          // Look in dom-module associated with this element's is
          this.hasOwnProperty(JSCompiler_renameProperty("is", this)) && o(
            /** @type {PolymerElementConstructor}*/
            this.is
          ) || // Next look for superclass template (call the super impl this
          // way so that `this` points to the superclass)
          Object.getPrototypeOf(
            /** @type {PolymerElementConstructor}*/
            this.prototype
          ).constructor.template
        );
      }
      return this._template;
    }
    /**
     * Set the template.
     *
     * @param {!HTMLTemplateElement|string} value Template to set.
     * @nocollapse
     */
    static set template(h) {
      this._template = h;
    }
    /**
     * Path matching the url from which the element was imported.
     *
     * This path is used to resolve url's in template style cssText.
     * The `importPath` property is also set on element instances and can be
     * used to create bindings relative to the import path.
     *
     * For elements defined in ES modules, users should implement
     * `static get importMeta() { return import.meta; }`, and the default
     * implementation of `importPath` will  return `import.meta.url`'s path.
     * For elements defined in HTML imports, this getter will return the path
     * to the document containing a `dom-module` element matching this
     * element's static `is` property.
     *
     * Note, this path should contain a trailing `/`.
     *
     * @return {string} The import path for this element class
     * @suppress {missingProperties}
     * @nocollapse
     */
    static get importPath() {
      if (!this.hasOwnProperty(JSCompiler_renameProperty("_importPath", this))) {
        const h = this.importMeta;
        if (h)
          this._importPath = Ms(h.url);
        else {
          const d = Dr.import(
            /** @type {PolymerElementConstructor} */
            this.is
          );
          this._importPath = d && d.assetpath || Object.getPrototypeOf(
            /** @type {PolymerElementConstructor}*/
            this.prototype
          ).constructor.importPath;
        }
      }
      return this._importPath;
    }
    constructor() {
      super(), this._template, this._importPath, this.rootPath, this.importPath, this.root, this.$;
    }
    /**
     * Overrides the default `PropertyAccessors` to ensure class
     * metaprogramming related to property accessors and effects has
     * completed (calls `finalize`).
     *
     * It also initializes any property defaults provided via `value` in
     * `properties` metadata.
     *
     * @return {void}
     * @override
     * @suppress {invalidCasts,missingProperties} go/missingfnprops
     */
    _initializeProperties() {
      this.constructor.finalize(), this.constructor._finalizeTemplate(
        /** @type {!HTMLElement} */
        this.localName
      ), super._initializeProperties(), this.rootPath = Md, this.importPath = this.constructor.importPath;
      let h = e(this.constructor);
      if (h)
        for (let d in h) {
          let f = h[d];
          if (this._canApplyPropertyDefault(d)) {
            let g = typeof f.value == "function" ? f.value.call(this) : f.value;
            this._hasAccessor(d) ? this._setPendingProperty(d, g, !0) : this[d] = g;
          }
        }
    }
    /**
     * Determines if a property dfeault can be applied. For example, this
     * prevents a default from being applied when a property that has no
     * accessor is overridden by its host before upgrade (e.g. via a binding).
     * @override
     * @param {string} property Name of the property
     * @return {boolean} Returns true if the property default can be applied.
     */
    _canApplyPropertyDefault(h) {
      return !this.hasOwnProperty(h);
    }
    /**
     * Gather style text for a style element in the template.
     *
     * @param {string} cssText Text containing styling to process
     * @param {string} baseURI Base URI to rebase CSS paths against
     * @return {string} The processed CSS text
     * @protected
     * @nocollapse
     */
    static _processStyleText(h, d) {
      return Fs(h, d);
    }
    /**
    * Configures an element `proto` to function with a given `template`.
    * The element name `is` and extends `ext` must be specified for ShadyCSS
    * style scoping.
    *
    * @param {string} is Tag name (or type extension name) for this element
    * @return {void}
    * @protected
    * @nocollapse
    */
    static _finalizeTemplate(h) {
      const d = this.prototype._template;
      if (d && !d.__polymerFinalized) {
        d.__polymerFinalized = !0;
        const f = this.importPath, g = f ? Pr(f) : "";
        n(this, d, h, g), this.prototype._bindTemplate(d);
      }
    }
    /**
     * Provides a default implementation of the standard Custom Elements
     * `connectedCallback`.
     *
     * The default implementation enables the property effects system and
     * flushes any pending properties, and updates shimmed CSS properties
     * when using the ShadyCSS scoping/custom properties polyfill.
     *
     * @override
     * @suppress {missingProperties, invalidCasts} Super may or may not
     *     implement the callback
     * @return {void}
     */
    connectedCallback() {
      window.ShadyCSS && this._template && window.ShadyCSS.styleElement(
        /** @type {!HTMLElement} */
        this
      ), super.connectedCallback();
    }
    /**
     * Stamps the element template.
     *
     * @return {void}
     * @override
     */
    ready() {
      this._template && (this.root = this._stampTemplate(this._template), this.$ = this.root.$), super.ready();
    }
    /**
     * Implements `PropertyEffects`'s `_readyClients` call. Attaches
     * element dom by calling `_attachDom` with the dom stamped from the
     * element's template via `_stampTemplate`. Note that this allows
     * client dom to be attached to the element prior to any observers
     * running.
     *
     * @return {void}
     * @override
     */
    _readyClients() {
      this._template && (this.root = this._attachDom(
        /** @type {StampedTemplate} */
        this.root
      )), super._readyClients();
    }
    /**
     * Attaches an element's stamped dom to itself. By default,
     * this method creates a `shadowRoot` and adds the dom to it.
     * However, this method may be overridden to allow an element
     * to put its dom in another location.
     *
     * @override
     * @throws {Error}
     * @suppress {missingReturn}
     * @param {StampedTemplate} dom to attach to the element.
     * @return {ShadowRoot} node to which the dom has been attached.
     */
    _attachDom(h) {
      const d = _i(this);
      if (d.attachShadow)
        return h ? (d.shadowRoot || (d.attachShadow({ mode: "open", shadyUpgradeFragment: h }), d.shadowRoot.appendChild(h), this.constructor._styleSheet && (d.shadowRoot.adoptedStyleSheets = [this.constructor._styleSheet])), Hd && window.ShadyDOM && window.ShadyDOM.flushInitial(d.shadowRoot), d.shadowRoot) : null;
      throw new Error("ShadowDOM not available. PolymerElement can create dom as children instead of in ShadowDOM by setting `this.root = this;` before `ready`.");
    }
    /**
     * When using the ShadyCSS scoping and custom property shim, causes all
     * shimmed styles in this element (and its subtree) to be updated
     * based on current custom property values.
     *
     * The optional parameter overrides inline custom property styles with an
     * object of properties where the keys are CSS properties, and the values
     * are strings.
     *
     * Example: `this.updateStyles({'--color': 'blue'})`
     *
     * These properties are retained unless a value of `null` is set.
     *
     * Note: This function does not support updating CSS mixins.
     * You can not dynamically change the value of an `@apply`.
     *
     * @override
     * @param {Object=} properties Bag of custom property key/values to
     *   apply to this element.
     * @return {void}
     * @suppress {invalidCasts}
     */
    updateStyles(h) {
      window.ShadyCSS && window.ShadyCSS.styleSubtree(
        /** @type {!HTMLElement} */
        this,
        h
      );
    }
    /**
     * Rewrites a given URL relative to a base URL. The base URL defaults to
     * the original location of the document containing the `dom-module` for
     * this element. This method will return the same URL before and after
     * bundling.
     *
     * Note that this function performs no resolution for URLs that start
     * with `/` (absolute URLs) or `#` (hash identifiers).  For general purpose
     * URL resolution, use `window.URL`.
     *
     * @override
     * @param {string} url URL to resolve.
     * @param {string=} base Optional base URL to resolve against, defaults
     * to the element's `importPath`
     * @return {string} Rewritten URL relative to base
     */
    resolveUrl(h, d) {
      return !d && this.importPath && (d = Pr(this.importPath)), Pr(h, d);
    }
    /**
     * Overrides `PropertyEffects` to add map of dynamic functions on
     * template info, for consumption by `PropertyEffects` template binding
     * code. This map determines which method templates should have accessors
     * created for them.
     *
     * @param {!HTMLTemplateElement} template Template
     * @param {!TemplateInfo} templateInfo Template metadata for current template
     * @param {!NodeInfo} nodeInfo Node metadata for current template.
     * @return {boolean} .
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     * @nocollapse
     */
    static _parseTemplateContent(h, d, f) {
      return d.dynamicFns = d.dynamicFns || this._properties, r._parseTemplateContent.call(
        this,
        h,
        d,
        f
      );
    }
    /**
     * Overrides `PropertyEffects` to warn on use of undeclared properties in
     * template.
     *
     * @param {Object} templateInfo Template metadata to add effect to
     * @param {string} prop Property that should trigger the effect
     * @param {Object=} effect Effect metadata object
     * @return {void}
     * @protected
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     * @nocollapse
     */
    static _addTemplatePropertyEffect(h, d, f) {
      return Nd && !(d in this._properties) && // Methods used in templates with no dependencies (or only literal
      // dependencies) become accessors with template effects; ignore these
      !(f.info.part.signature && f.info.part.signature.static) && // Warnings for bindings added to nested templates are handled by
      // templatizer so ignore both the host-to-template bindings
      // (`hostProp`) and TemplateInstance-to-child bindings
      // (`nestedTemplate`)
      !f.info.part.hostProp && !h.nestedTemplate && console.warn(`Property '${d}' used in template but not declared in 'properties'; attribute will not be observed.`), r._addTemplatePropertyEffect.call(
        this,
        h,
        d,
        f
      );
    }
  }
  return a;
});
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const dl = window.trustedTypes && trustedTypes.createPolicy("polymer-html-literal", { createHTML: (s) => s });
class Sc {
  /**
   * @param {!ITemplateArray} strings Constant parts of tagged template literal
   * @param {!Array<*>} values Variable parts of tagged template literal
   */
  constructor(r, e) {
    Ac(r, e);
    const t = e.reduce(
      (i, n, o) => i + kc(n) + r[o + 1],
      r[0]
    );
    this.value = t.toString();
  }
  /**
   * @return {string} LiteralString string value
   * @override
   */
  toString() {
    return this.value;
  }
}
function kc(s) {
  if (s instanceof Sc)
    return (
      /** @type {!LiteralString} */
      s.value
    );
  throw new Error(
    `non-literal value passed to Polymer's htmlLiteral function: ${s}`
  );
}
function nf(s) {
  if (s instanceof HTMLTemplateElement)
    return (
      /** @type {!HTMLTemplateElement } */
      s.innerHTML
    );
  if (s instanceof Sc)
    return kc(s);
  throw new Error(
    `non-template value passed to Polymer's html function: ${s}`
  );
}
const er = function(r, ...e) {
  Ac(r, e);
  const t = (
    /** @type {!HTMLTemplateElement} */
    document.createElement("template")
  );
  let i = e.reduce(
    (n, o, a) => n + nf(o) + r[a + 1],
    r[0]
  );
  return dl && (i = dl.createHTML(i)), t.innerHTML = i, t;
}, Ac = (s, r) => {
  if (!Array.isArray(s) || !Array.isArray(s.raw) || r.length !== s.length - 1)
    throw new TypeError("Invalid call to the html template tag");
};
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const Pi = rf(HTMLElement);
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
let ul = 0, Rc = 0;
const Ui = [];
let gs = !1;
function of() {
  gs = !1;
  const s = Ui.length;
  for (let r = 0; r < s; r++) {
    const e = Ui[r];
    if (e)
      try {
        e();
      } catch (t) {
        setTimeout(() => {
          throw t;
        });
      }
  }
  Ui.splice(0, s), Rc += s;
}
const Ft = {
  /**
   * Returns a sub-module with the async interface providing the provided
   * delay.
   *
   * @memberof timeOut
   * @param {number=} delay Time to wait before calling callbacks in ms
   * @return {!AsyncInterface} An async timeout interface
   */
  after(s) {
    return {
      run(r) {
        return window.setTimeout(r, s);
      },
      cancel(r) {
        window.clearTimeout(r);
      }
    };
  },
  /**
   * Enqueues a function called in the next task.
   *
   * @memberof timeOut
   * @param {!Function} fn Callback to run
   * @param {number=} delay Delay in milliseconds
   * @return {number} Handle used for canceling task
   */
  run(s, r) {
    return window.setTimeout(s, r);
  },
  /**
   * Cancels a previously enqueued `timeOut` callback.
   *
   * @memberof timeOut
   * @param {number} handle Handle returned from `run` of callback to cancel
   * @return {void}
   */
  cancel(s) {
    window.clearTimeout(s);
  }
}, Jt = {
  /**
   * Enqueues a function called at `requestAnimationFrame` timing.
   *
   * @memberof animationFrame
   * @param {function(number):void} fn Callback to run
   * @return {number} Handle used for canceling task
   */
  run(s) {
    return window.requestAnimationFrame(s);
  },
  /**
   * Cancels a previously enqueued `animationFrame` callback.
   *
   * @memberof animationFrame
   * @param {number} handle Handle returned from `run` of callback to cancel
   * @return {void}
   */
  cancel(s) {
    window.cancelAnimationFrame(s);
  }
}, Ic = {
  /**
   * Enqueues a function called at `requestIdleCallback` timing.
   *
   * @memberof idlePeriod
   * @param {function(!IdleDeadline):void} fn Callback to run
   * @return {number} Handle used for canceling task
   */
  run(s) {
    return window.requestIdleCallback ? window.requestIdleCallback(s) : window.setTimeout(s, 16);
  },
  /**
   * Cancels a previously enqueued `idlePeriod` callback.
   *
   * @memberof idlePeriod
   * @param {number} handle Handle returned from `run` of callback to cancel
   * @return {void}
   */
  cancel(s) {
    window.cancelIdleCallback ? window.cancelIdleCallback(s) : window.clearTimeout(s);
  }
}, yt = {
  /**
   * Enqueues a function called at microtask timing.
   *
   * @memberof microTask
   * @param {!Function=} callback Callback to run
   * @return {number} Handle used for canceling task
   */
  run(s) {
    gs || (gs = !0, queueMicrotask(() => of())), Ui.push(s);
    const r = ul;
    return ul += 1, r;
  },
  /**
   * Cancels a previously enqueued `microTask` callback.
   *
   * @memberof microTask
   * @param {number} handle Handle returned from `run` of callback to cancel
   * @return {void}
   */
  cancel(s) {
    const r = s - Rc;
    if (r >= 0) {
      if (!Ui[r])
        throw new Error(`invalid async handle: ${s}`);
      Ui[r] = null;
    }
  }
};
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const Fr = /* @__PURE__ */ new Set();
class Le {
  /**
   * Creates a debouncer if no debouncer is passed as a parameter
   * or it cancels an active debouncer otherwise. The following
   * example shows how a debouncer can be called multiple times within a
   * microtask and "debounced" such that the provided callback function is
   * called once. Add this method to a custom element:
   *
   * ```js
   * import {microTask} from '@vaadin/component-base/src/async.js';
   * import {Debouncer} from '@vaadin/component-base/src/debounce.js';
   * // ...
   *
   * _debounceWork() {
   *   this._debounceJob = Debouncer.debounce(this._debounceJob,
   *       microTask, () => this._doWork());
   * }
   * ```
   *
   * If the `_debounceWork` method is called multiple times within the same
   * microtask, the `_doWork` function will be called only once at the next
   * microtask checkpoint.
   *
   * Note: In testing it is often convenient to avoid asynchrony. To accomplish
   * this with a debouncer, you can use `enqueueDebouncer` and
   * `flush`. For example, extend the above example by adding
   * `enqueueDebouncer(this._debounceJob)` at the end of the
   * `_debounceWork` method. Then in a test, call `flush` to ensure
   * the debouncer has completed.
   *
   * @param {Debouncer?} debouncer Debouncer object.
   * @param {!AsyncInterface} asyncModule Object with Async interface
   * @param {function()} callback Callback to run.
   * @return {!Debouncer} Returns a debouncer object.
   */
  static debounce(r, e, t) {
    return r instanceof Le ? r._cancelAsync() : r = new Le(), r.setConfig(e, t), r;
  }
  constructor() {
    this._asyncModule = null, this._callback = null, this._timer = null;
  }
  /**
   * Sets the scheduler; that is, a module with the Async interface,
   * a callback and optional arguments to be passed to the run function
   * from the async module.
   *
   * @param {!AsyncInterface} asyncModule Object with Async interface.
   * @param {function()} callback Callback to run.
   * @return {void}
   */
  setConfig(r, e) {
    this._asyncModule = r, this._callback = e, this._timer = this._asyncModule.run(() => {
      this._timer = null, Fr.delete(this), this._callback();
    });
  }
  /**
   * Cancels an active debouncer and returns a reference to itself.
   *
   * @return {void}
   */
  cancel() {
    this.isActive() && (this._cancelAsync(), Fr.delete(this));
  }
  /**
   * Cancels a debouncer's async callback.
   *
   * @return {void}
   */
  _cancelAsync() {
    this.isActive() && (this._asyncModule.cancel(
      /** @type {number} */
      this._timer
    ), this._timer = null);
  }
  /**
   * Flushes an active debouncer and returns a reference to itself.
   *
   * @return {void}
   */
  flush() {
    this.isActive() && (this.cancel(), this._callback());
  }
  /**
   * Returns true if the debouncer is active.
   *
   * @return {boolean} True if active.
   */
  isActive() {
    return this._timer != null;
  }
}
function Dc(s) {
  Fr.add(s);
}
function sf() {
  const s = !!Fr.size;
  return Fr.forEach((r) => {
    try {
      r.flush();
    } catch (e) {
      setTimeout(() => {
        throw e;
      });
    }
  }), s;
}
const Cr = () => {
  let s;
  do
    s = sf();
  while (s);
};
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Ot = [];
function ms(s, r, e = s.getAttribute("dir")) {
  r ? s.setAttribute("dir", r) : e != null && s.removeAttribute("dir");
}
function vs() {
  return document.documentElement.getAttribute("dir");
}
function af() {
  const s = vs();
  Ot.forEach((r) => {
    ms(r, s);
  });
}
const lf = new MutationObserver(af);
lf.observe(document.documentElement, { attributes: !0, attributeFilter: ["dir"] });
const Ur = (s) => class extends s {
  static get properties() {
    return {
      /**
       * @protected
       */
      dir: {
        type: String,
        value: "",
        reflectToAttribute: !0,
        converter: {
          fromAttribute: (e) => e || "",
          toAttribute: (e) => e === "" ? null : e
        }
      }
    };
  }
  /**
   * @return {boolean}
   * @protected
   */
  get __isRTL() {
    return this.getAttribute("dir") === "rtl";
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback(), (!this.hasAttribute("dir") || this.__restoreSubscription) && (this.__subscribe(), ms(this, vs(), null));
  }
  /** @protected */
  attributeChangedCallback(e, t, i) {
    if (super.attributeChangedCallback(e, t, i), e !== "dir")
      return;
    const n = vs(), o = i === n && Ot.indexOf(this) === -1, a = !i && t && Ot.indexOf(this) === -1;
    o || a ? (this.__subscribe(), ms(this, n, i)) : i !== n && t === n && this.__unsubscribe();
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback(), this.__restoreSubscription = Ot.includes(this), this.__unsubscribe();
  }
  /** @protected */
  _valueToNodeAttribute(e, t, i) {
    i === "dir" && t === "" && !e.hasAttribute("dir") || super._valueToNodeAttribute(e, t, i);
  }
  /** @protected */
  _attributeToProperty(e, t, i) {
    e === "dir" && !t ? this.dir = "" : super._attributeToProperty(e, t, i);
  }
  /** @private */
  __subscribe() {
    Ot.includes(this) || Ot.push(this);
  }
  /** @private */
  __unsubscribe() {
    Ot.includes(this) && Ot.splice(Ot.indexOf(this), 1);
  }
};
/**
 * @license
 * Copyright (c) 2023 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function Ci(s, r) {
  return s.split(".").reduce((e, t) => e ? e[t] : void 0, r);
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function Ns(s) {
  if (window.Vaadin && window.Vaadin.templateRendererCallback) {
    window.Vaadin.templateRendererCallback(s);
    return;
  }
  s.querySelector("template") && console.warn(
    `WARNING: <template> inside <${s.localName}> is no longer supported. Import @vaadin/polymer-legacy-adapter/template-renderer.js to enable compatibility.`
  );
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function cf(s) {
  const r = [];
  for (; s; ) {
    if (s.nodeType === Node.DOCUMENT_NODE) {
      r.push(s);
      break;
    }
    if (s.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
      r.push(s), s = s.host;
      continue;
    }
    if (s.assignedSlot) {
      s = s.assignedSlot;
      continue;
    }
    s = s.parentNode;
  }
  return r;
}
function Oc(s, r) {
  return r ? r.closest(s) || Oc(s, r.getRootNode().host) : null;
}
function Hs(s) {
  return s ? new Set(s.split(" ")) : /* @__PURE__ */ new Set();
}
function Jn(s) {
  return s ? [...s].join(" ") : "";
}
function Qn(s, r, e) {
  const t = Hs(s.getAttribute(r));
  t.add(e), s.setAttribute(r, Jn(t));
}
function Vs(s, r, e) {
  const t = Hs(s.getAttribute(r));
  if (t.delete(e), t.size === 0) {
    s.removeAttribute(r);
    return;
  }
  s.setAttribute(r, Jn(t));
}
function hf(s) {
  return s.nodeType === Node.TEXT_NODE && s.textContent.trim() === "";
}
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function Ki(s) {
  return s.__cells || Array.from(s.querySelectorAll('[part~="cell"]:not([part~="details-cell"])'));
}
function dt(s, r) {
  [...s.children].forEach(r);
}
function Zi(s, r) {
  Ki(s).forEach(r), s.__detailsCell && r(s.__detailsCell);
}
function df(s, r, e) {
  let t = 1;
  s.forEach((i) => {
    t % 10 === 0 && (t += 1), i._order = e + t * r, t += 1;
  });
}
function $n(s, r, e) {
  switch (typeof e) {
    case "boolean":
      s.toggleAttribute(r, e);
      break;
    case "string":
      s.setAttribute(r, e);
      break;
    default:
      s.removeAttribute(r);
      break;
  }
}
function Qt(s, r, e) {
  r || r === "" ? Qn(s, "part", e) : Vs(s, "part", e);
}
function Kt(s, r, e) {
  s.forEach((t) => {
    Qt(t, e, r);
  });
}
function Ni(s, r) {
  const e = Ki(s);
  Object.entries(r).forEach(([t, i]) => {
    $n(s, t, i);
    const n = `${t}-row`;
    Qt(s, i, n), Kt(e, `${n}-cell`, i);
  });
}
function fl(s, r) {
  const e = Ki(s);
  Object.entries(r).forEach(([t, i]) => {
    const n = s.getAttribute(t);
    if ($n(s, t, i), n) {
      const o = `${t}-${n}-row`;
      Qt(s, !1, o), Kt(e, `${o}-cell`, !1);
    }
    if (i) {
      const o = `${t}-${i}-row`;
      Qt(s, i, o), Kt(e, `${o}-cell`, i);
    }
  });
}
function fi(s, r, e, t, i) {
  $n(s, r, e), i && Qt(s, !1, i), Qt(s, e, t || `${r}-cell`);
}
class Wi {
  constructor(r, e) {
    this.__host = r, this.__callback = e, this.__currentSlots = [], this.__onMutation = this.__onMutation.bind(this), this.__observer = new MutationObserver(this.__onMutation), this.__observer.observe(r, {
      childList: !0
    }), this.__initialCallDebouncer = Le.debounce(this.__initialCallDebouncer, yt, () => this.__onMutation());
  }
  disconnect() {
    this.__observer.disconnect(), this.__initialCallDebouncer.cancel(), this.__toggleSlotChangeListeners(!1);
  }
  flush() {
    this.__onMutation();
  }
  __toggleSlotChangeListeners(r) {
    this.__currentSlots.forEach((e) => {
      r ? e.addEventListener("slotchange", this.__onMutation) : e.removeEventListener("slotchange", this.__onMutation);
    });
  }
  __onMutation() {
    const r = !this.__currentColumns;
    this.__currentColumns || (this.__currentColumns = []);
    const e = Wi.getColumns(this.__host), t = e.filter((a) => !this.__currentColumns.includes(a)), i = this.__currentColumns.filter((a) => !e.includes(a)), n = this.__currentColumns.some((a, l) => a !== e[l]);
    this.__currentColumns = e, this.__toggleSlotChangeListeners(!1), this.__currentSlots = [...this.__host.children].filter((a) => a instanceof HTMLSlotElement), this.__toggleSlotChangeListeners(!0), (r || t.length || i.length || n) && this.__callback(t, i);
  }
  /**
   * Default filter for column elements.
   */
  static __isColumnElement(r) {
    return r.nodeType === Node.ELEMENT_NODE && /\bcolumn\b/u.test(r.localName);
  }
  static getColumns(r) {
    const e = [], t = r._isColumnElement || Wi.__isColumnElement;
    return [...r.children].forEach((i) => {
      t(i) ? e.push(i) : i instanceof HTMLSlotElement && [...i.assignedElements({ flatten: !0 })].filter((n) => t(n)).forEach((n) => e.push(n));
    }), e;
  }
}
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const uf = (s) => class extends s {
  static get properties() {
    return {
      /**
       * When set to true, the column is user-resizable.
       * @default false
       */
      resizable: {
        type: Boolean,
        sync: !0,
        value() {
          if (this.localName === "vaadin-grid-column-group")
            return;
          const e = this.parentNode;
          return e && e.localName === "vaadin-grid-column-group" && e.resizable || !1;
        }
      },
      /**
       * When true, the column is frozen. When a column inside of a column group is frozen,
       * all of the sibling columns inside the group will get frozen also.
       * @type {boolean}
       */
      frozen: {
        type: Boolean,
        value: !1,
        sync: !0
      },
      /**
       * When true, the column is frozen to end of grid.
       *
       * When a column inside of a column group is frozen to end, all of the sibling columns
       * inside the group will get frozen to end also.
       *
       * Column can not be set as `frozen` and `frozenToEnd` at the same time.
       * @attr {boolean} frozen-to-end
       * @type {boolean}
       */
      frozenToEnd: {
        type: Boolean,
        value: !1,
        sync: !0
      },
      /**
       * When true, the cells for this column will be rendered with the `role` attribute
       * set as `rowheader`, instead of the `gridcell` role value used by default.
       *
       * When a column is set as row header, its cells will be announced by screen readers
       * while navigating to help user identify the current row as uniquely as possible.
       *
       * @attr {boolean} row-header
       * @type {boolean}
       */
      rowHeader: {
        type: Boolean,
        value: !1,
        sync: !0
      },
      /**
       * When set to true, the cells for this column are hidden.
       */
      hidden: {
        type: Boolean,
        value: !1,
        sync: !0
      },
      /**
       * Text content to display in the header cell of the column.
       */
      header: {
        type: String,
        sync: !0
      },
      /**
       * Aligns the columns cell content horizontally.
       * Supported values: "start", "center" and "end".
       * @attr {start|center|end} text-align
       * @type {GridColumnTextAlign | null | undefined}
       */
      textAlign: {
        type: String,
        sync: !0
      },
      /**
       * Custom part name for the header cell.
       *
       * @attr {string} header-part-name
       */
      headerPartName: {
        type: String,
        sync: !0
      },
      /**
       * Custom part name for the footer cell.
       *
       * @attr {string} footer-part-name
       */
      footerPartName: {
        type: String,
        sync: !0
      },
      /**
       * @type {boolean}
       * @protected
       */
      _lastFrozen: {
        type: Boolean,
        value: !1,
        sync: !0
      },
      /**
       * @type {boolean}
       * @protected
       */
      _bodyContentHidden: {
        type: Boolean,
        value: !1,
        sync: !0
      },
      /**
       * @type {boolean}
       * @protected
       */
      _firstFrozenToEnd: {
        type: Boolean,
        value: !1,
        sync: !0
      },
      /** @protected */
      _order: {
        type: Number,
        sync: !0
      },
      /** @private */
      _reorderStatus: {
        type: Boolean,
        sync: !0
      },
      /**
       * @type {Array<!HTMLElement>}
       * @protected
       */
      _emptyCells: Array,
      /** @private */
      _headerCell: Object,
      /** @private */
      _footerCell: Object,
      /** @protected */
      _grid: Object,
      /**
       * By default, the Polymer doesn't invoke the observer
       * during initialization if all of its dependencies are `undefined`.
       * This internal property can be used to force initial invocation of an observer
       * even the other dependencies of the observer are `undefined`.
       *
       * @private
       */
      __initialized: {
        type: Boolean,
        value: !0
      },
      /**
       * Custom function for rendering the header content.
       * Receives two arguments:
       *
       * - `root` The header cell content DOM element. Append your content to it.
       * - `column` The `<vaadin-grid-column>` element.
       *
       * @type {GridHeaderFooterRenderer | null | undefined}
       */
      headerRenderer: {
        type: Function,
        sync: !0
      },
      /**
       * Represents the final header renderer computed on the set of observable arguments.
       * It is supposed to be used internally when rendering the header cell content.
       *
       * @protected
       * @type {GridHeaderFooterRenderer | undefined}
       */
      _headerRenderer: {
        type: Function,
        computed: "_computeHeaderRenderer(headerRenderer, header, __initialized)",
        sync: !0
      },
      /**
       * Custom function for rendering the footer content.
       * Receives two arguments:
       *
       * - `root` The footer cell content DOM element. Append your content to it.
       * - `column` The `<vaadin-grid-column>` element.
       *
       * @type {GridHeaderFooterRenderer | null | undefined}
       */
      footerRenderer: {
        type: Function,
        sync: !0
      },
      /**
       * Represents the final footer renderer computed on the set of observable arguments.
       * It is supposed to be used internally when rendering the footer cell content.
       *
       * @protected
       * @type {GridHeaderFooterRenderer | undefined}
       */
      _footerRenderer: {
        type: Function,
        computed: "_computeFooterRenderer(footerRenderer, __initialized)",
        sync: !0
      },
      /**
       * An internal property that is mainly used by `vaadin-template-renderer`
       * to identify grid column elements.
       *
       * @private
       */
      __gridColumnElement: {
        type: Boolean,
        value: !0
      }
    };
  }
  static get observers() {
    return [
      "_widthChanged(width, _headerCell, _footerCell, _cells)",
      "_frozenChanged(frozen, _headerCell, _footerCell, _cells)",
      "_frozenToEndChanged(frozenToEnd, _headerCell, _footerCell, _cells)",
      "_flexGrowChanged(flexGrow, _headerCell, _footerCell, _cells)",
      "_textAlignChanged(textAlign, _cells, _headerCell, _footerCell)",
      "_orderChanged(_order, _headerCell, _footerCell, _cells)",
      "_lastFrozenChanged(_lastFrozen)",
      "_firstFrozenToEndChanged(_firstFrozenToEnd)",
      "_onRendererOrBindingChanged(_renderer, _cells, _bodyContentHidden, path)",
      "_onHeaderRendererOrBindingChanged(_headerRenderer, _headerCell, path, header)",
      "_onFooterRendererOrBindingChanged(_footerRenderer, _footerCell)",
      "_resizableChanged(resizable, _headerCell)",
      "_reorderStatusChanged(_reorderStatus, _headerCell, _footerCell, _cells)",
      "_hiddenChanged(hidden, _headerCell, _footerCell, _cells)",
      "_rowHeaderChanged(rowHeader, _cells)",
      "__headerFooterPartNameChanged(_headerCell, _footerCell, headerPartName, footerPartName)"
    ];
  }
  /**
   * @return {!Grid | undefined}
   * @protected
   */
  get _grid() {
    return this._gridValue || (this._gridValue = this._findHostGrid()), this._gridValue;
  }
  /**
   * @return {!Array<!HTMLElement>}
   * @protected
   */
  get _allCells() {
    return [].concat(this._cells || []).concat(this._emptyCells || []).concat(this._headerCell).concat(this._footerCell).filter((e) => e);
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback(), requestAnimationFrame(() => {
      this._grid && this._allCells.forEach((e) => {
        e._content.parentNode || this._grid.appendChild(e._content);
      });
    });
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback(), requestAnimationFrame(() => {
      this._grid || this._allCells.forEach((e) => {
        e._content.parentNode && e._content.parentNode.removeChild(e._content);
      });
    }), this._gridValue = void 0;
  }
  /** @protected */
  ready() {
    super.ready(), Ns(this);
  }
  /**
   * @return {!Grid | undefined}
   * @protected
   */
  _findHostGrid() {
    let e = this;
    for (; e && !/^vaadin.*grid(-pro)?$/u.test(e.localName); )
      e = e.assignedSlot ? e.assignedSlot.parentNode : e.parentNode;
    return e || void 0;
  }
  /** @protected */
  _renderHeaderAndFooter() {
    this._renderHeaderCellContent(this._headerRenderer, this._headerCell), this._renderFooterCellContent(this._footerRenderer, this._footerCell);
  }
  /** @private */
  _flexGrowChanged(e) {
    this.parentElement && this.parentElement._columnPropChanged && this.parentElement._columnPropChanged("flexGrow"), this._allCells.forEach((t) => {
      t.style.flexGrow = e;
    });
  }
  /** @private */
  _orderChanged(e) {
    this._allCells.forEach((t) => {
      t.style.order = e;
    });
  }
  /** @private */
  _widthChanged(e) {
    this.parentElement && this.parentElement._columnPropChanged && this.parentElement._columnPropChanged("width"), this._allCells.forEach((t) => {
      t.style.width = e;
    });
  }
  /** @private */
  _frozenChanged(e) {
    this.parentElement && this.parentElement._columnPropChanged && this.parentElement._columnPropChanged("frozen", e), this._allCells.forEach((t) => {
      fi(t, "frozen", e);
    }), this._grid && this._grid._frozenCellsChanged && this._grid._frozenCellsChanged();
  }
  /** @private */
  _frozenToEndChanged(e) {
    this.parentElement && this.parentElement._columnPropChanged && this.parentElement._columnPropChanged("frozenToEnd", e), this._allCells.forEach((t) => {
      this._grid && t.parentElement === this._grid.$.sizer || fi(t, "frozen-to-end", e);
    }), this._grid && this._grid._frozenCellsChanged && this._grid._frozenCellsChanged();
  }
  /** @private */
  _lastFrozenChanged(e) {
    this._allCells.forEach((t) => {
      fi(t, "last-frozen", e);
    }), this.parentElement && this.parentElement._columnPropChanged && (this.parentElement._lastFrozen = e);
  }
  /** @private */
  _firstFrozenToEndChanged(e) {
    this._allCells.forEach((t) => {
      this._grid && t.parentElement === this._grid.$.sizer || fi(t, "first-frozen-to-end", e);
    }), this.parentElement && this.parentElement._columnPropChanged && (this.parentElement._firstFrozenToEnd = e);
  }
  /** @private */
  _rowHeaderChanged(e, t) {
    t && t.forEach((i) => {
      i.setAttribute("role", e ? "rowheader" : "gridcell");
    });
  }
  /**
   * @param {string} path
   * @return {string}
   * @protected
   */
  _generateHeader(e) {
    return e.substr(e.lastIndexOf(".") + 1).replace(/([A-Z])/gu, "-$1").toLowerCase().replace(/-/gu, " ").replace(/^./u, (t) => t.toUpperCase());
  }
  /** @private */
  _reorderStatusChanged(e) {
    const t = this.__previousReorderStatus, i = t ? `reorder-${t}-cell` : "", n = `reorder-${e}-cell`;
    this._allCells.forEach((o) => {
      fi(o, "reorder-status", e, n, i);
    }), this.__previousReorderStatus = e;
  }
  /** @private */
  _resizableChanged(e, t) {
    e === void 0 || t === void 0 || t && [t].concat(this._emptyCells).forEach((i) => {
      if (i) {
        const n = i.querySelector('[part~="resize-handle"]');
        if (n && i.removeChild(n), e) {
          const o = document.createElement("div");
          o.setAttribute("part", "resize-handle"), i.appendChild(o);
        }
      }
    });
  }
  /** @private */
  _textAlignChanged(e) {
    if (e === void 0 || this._grid === void 0)
      return;
    if (["start", "end", "center"].indexOf(e) === -1) {
      console.warn('textAlign can only be set as "start", "end" or "center"');
      return;
    }
    let t;
    getComputedStyle(this._grid).direction === "ltr" ? e === "start" ? t = "left" : e === "end" && (t = "right") : e === "start" ? t = "right" : e === "end" && (t = "left"), this._allCells.forEach((i) => {
      i._content.style.textAlign = e, getComputedStyle(i._content).textAlign !== e && (i._content.style.textAlign = t);
    });
  }
  /** @private */
  _hiddenChanged(e) {
    this.parentElement && this.parentElement._columnPropChanged && this.parentElement._columnPropChanged("hidden", e), !!e != !!this._previousHidden && this._grid && (e === !0 && this._allCells.forEach((t) => {
      t._content.parentNode && t._content.parentNode.removeChild(t._content);
    }), this._grid._debouncerHiddenChanged = Le.debounce(
      this._grid._debouncerHiddenChanged,
      Jt,
      () => {
        this._grid && this._grid._renderColumnTree && this._grid._renderColumnTree(this._grid._columnTree);
      }
    ), this._grid._debounceUpdateFrozenColumn && this._grid._debounceUpdateFrozenColumn(), this._grid._resetKeyboardNavigation && this._grid._resetKeyboardNavigation()), this._previousHidden = e;
  }
  /** @protected */
  _runRenderer(e, t, i) {
    const n = i && i.item && !t.parentElement.hidden;
    if (!(n || e === this._headerRenderer || e === this._footerRenderer))
      return;
    const a = [t._content, this];
    n && a.push(i), e.apply(this, a);
  }
  /**
   * Renders the content to the given cells using a renderer.
   *
   * @private
   */
  __renderCellsContent(e, t) {
    this.hidden || !this._grid || t.forEach((i) => {
      if (!i.parentElement)
        return;
      const n = this._grid.__getRowModel(i.parentElement);
      e && (i._renderer !== e && this._clearCellContent(i), i._renderer = e, this._runRenderer(e, i, n));
    });
  }
  /**
   * Clears the content of a cell.
   *
   * @protected
   */
  _clearCellContent(e) {
    e._content.innerHTML = "", delete e._content._$litPart$;
  }
  /**
   * Renders the header cell content using a renderer,
   * and then updates the visibility of the parent row depending on
   * whether all its children cells are empty or not.
   *
   * @protected
   */
  _renderHeaderCellContent(e, t) {
    !t || !e || (this.__renderCellsContent(e, [t]), this._grid && t.parentElement && this._grid.__debounceUpdateHeaderFooterRowVisibility(t.parentElement));
  }
  /** @protected */
  _onHeaderRendererOrBindingChanged(e, t, ...i) {
    this._renderHeaderCellContent(e, t);
  }
  /** @private */
  __headerFooterPartNameChanged(e, t, i, n) {
    [
      { cell: e, partName: i },
      { cell: t, partName: n }
    ].forEach(({ cell: o, partName: a }) => {
      if (o) {
        const l = o.__customParts || [];
        o.part.remove(...l), o.__customParts = a ? a.trim().split(" ") : [], o.part.add(...o.__customParts);
      }
    });
  }
  /**
   * Renders the content of body cells using a renderer.
   *
   * @protected
   */
  _renderBodyCellsContent(e, t) {
    !t || !e || this.__renderCellsContent(e, t);
  }
  /** @protected */
  _onRendererOrBindingChanged(e, t, ...i) {
    this._renderBodyCellsContent(e, t);
  }
  /**
   * Renders the footer cell content using a renderer
   * and then updates the visibility of the parent row depending on
   * whether all its children cells are empty or not.
   *
   * @protected
   */
  _renderFooterCellContent(e, t) {
    !t || !e || (this.__renderCellsContent(e, [t]), this._grid && t.parentElement && this._grid.__debounceUpdateHeaderFooterRowVisibility(t.parentElement));
  }
  /** @protected */
  _onFooterRendererOrBindingChanged(e, t) {
    this._renderFooterCellContent(e, t);
  }
  /** @private */
  __setTextContent(e, t) {
    e.textContent !== t && (e.textContent = t);
  }
  /**
   * Renders the text header to the header cell.
   *
   * @private
   */
  __textHeaderRenderer() {
    this.__setTextContent(this._headerCell._content, this.header);
  }
  /**
   * Computes the property name based on the path and renders it to the header cell.
   * If the path is not defined, then nothing is rendered.
   *
   * @protected
   */
  _defaultHeaderRenderer() {
    this.path && this.__setTextContent(this._headerCell._content, this._generateHeader(this.path));
  }
  /**
   * Computes the item property value based on the path and renders it to the body cell.
   * If the path is not defined, then nothing is rendered.
   *
   * @protected
   */
  _defaultRenderer(e, t, { item: i }) {
    this.path && this.__setTextContent(e, Ci(this.path, i));
  }
  /**
   * By default, nothing is rendered to the footer cell.
   *
   * @protected
   */
  _defaultFooterRenderer() {
  }
  /**
   * Computes the final header renderer for the `_headerRenderer` computed property.
   * All the arguments are observable by the Polymer, it re-calls the method
   * once an argument is changed to update the property value.
   *
   * @protected
   * @return {GridHeaderFooterRenderer | undefined}
   */
  _computeHeaderRenderer(e, t) {
    return e || (t != null ? this.__textHeaderRenderer : this._defaultHeaderRenderer);
  }
  /**
   * Computes the final renderer for the `_renderer` property.
   * All the arguments are observable by the Polymer, it re-calls the method
   * once an argument is changed to update the property value.
   *
   * @protected
   * @return {GridBodyRenderer | undefined}
   */
  _computeRenderer(e) {
    return e || this._defaultRenderer;
  }
  /**
   * Computes the final footer renderer for the `_footerRenderer` property.
   * All the arguments are observable by the Polymer, it re-calls the method
   * once an argument is changed to update the property value.
   *
   * @protected
   * @return {GridHeaderFooterRenderer | undefined}
   */
  _computeFooterRenderer(e) {
    return e || this._defaultFooterRenderer;
  }
}, ff = (s) => class extends uf(Ur(s)) {
  static get properties() {
    return {
      /**
       * Width of the cells for this column.
       *
       * Please note that using the `em` length unit is discouraged as
       * it might lead to misalignment issues if the header, body, and footer
       * cells have different font sizes. Instead, use `rem` if you need
       * a length unit relative to the font size.
       */
      width: {
        type: String,
        value: "100px",
        sync: !0
      },
      /**
       * Flex grow ratio for the cell widths. When set to 0, cell width is fixed.
       * @attr {number} flex-grow
       * @type {number}
       */
      flexGrow: {
        type: Number,
        value: 1,
        sync: !0
      },
      /**
       * Custom function for rendering the cell content.
       * Receives three arguments:
       *
       * - `root` The cell content DOM element. Append your content to it.
       * - `column` The `<vaadin-grid-column>` element.
       * - `model` The object with the properties related with
       *   the rendered item, contains:
       *   - `model.index` The index of the item.
       *   - `model.item` The item.
       *   - `model.expanded` Sublevel toggle state.
       *   - `model.level` Level of the tree represented with a horizontal offset of the toggle button.
       *   - `model.selected` Selected state.
       *   - `model.detailsOpened` Details opened state.
       *
       * @type {GridBodyRenderer | null | undefined}
       */
      renderer: {
        type: Function,
        sync: !0
      },
      /**
       * Represents the final renderer computed on the set of observable arguments.
       * It is supposed to be used internally when rendering the content of a body cell.
       *
       * @protected
       * @type {GridBodyRenderer | undefined}
       */
      _renderer: {
        type: Function,
        computed: "_computeRenderer(renderer, __initialized)",
        sync: !0
      },
      /**
       * Path to an item sub-property whose value gets displayed in the column body cells.
       * The property name is also shown in the column header if an explicit header or renderer isn't defined.
       */
      path: {
        type: String,
        sync: !0
      },
      /**
       * Automatically sets the width of the column based on the column contents when this is set to `true`.
       *
       * For performance reasons the column width is calculated automatically only once when the grid items
       * are rendered for the first time and the calculation only considers the rows which are currently
       * rendered in DOM (a bit more than what is currently visible). If the grid is scrolled, or the cell
       * content changes, the column width might not match the contents anymore.
       *
       * Hidden columns are ignored in the calculation and their widths are not automatically updated when
       * you show a column that was initially hidden.
       *
       * You can manually trigger the auto sizing behavior again by calling `grid.recalculateColumnWidths()`.
       *
       * The column width may still grow larger when `flexGrow` is not 0.
       * @attr {boolean} auto-width
       * @type {boolean}
       */
      autoWidth: {
        type: Boolean,
        value: !1
      },
      /**
       * When true, wraps the cell's slot into an element with role="button", and sets
       * the tabindex attribute on the button element, instead of the cell itself.
       * This is needed to keep focus in sync with VoiceOver cursor when navigating
       * with Control + Option + arrow keys: focusing the `<td>` element does not fire
       * a focus event, but focusing an element with role="button" inside a cell fires it.
       * @protected
       */
      _focusButtonMode: {
        type: Boolean,
        value: !1
      },
      /**
       * @type {Array<!HTMLElement>}
       * @protected
       */
      _cells: {
        type: Array,
        sync: !0
      }
    };
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class pf extends ff(Pi) {
  static get is() {
    return "vaadin-grid-column";
  }
}
$t(pf);
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Wr = $e((s) => typeof s.prototype.addController == "function" ? s : class extends s {
  constructor() {
    super(), this.__controllers = /* @__PURE__ */ new Set();
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback(), this.__controllers.forEach((e) => {
      e.hostConnected && e.hostConnected();
    });
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback(), this.__controllers.forEach((e) => {
      e.hostDisconnected && e.hostDisconnected();
    });
  }
  /**
   * Registers a controller to participate in the element update cycle.
   *
   * @param {ReactiveController} controller
   * @protected
   */
  addController(e) {
    this.__controllers.add(e), this.$ !== void 0 && this.isConnected && e.hostConnected && e.hostConnected();
  }
  /**
   * Removes a controller from the element.
   *
   * @param {ReactiveController} controller
   * @protected
   */
  removeController(e) {
    this.__controllers.delete(e);
  }
}), gf = /\/\*[\*!]\s+vaadin-dev-mode:start([\s\S]*)vaadin-dev-mode:end\s+\*\*\//i, Pn = window.Vaadin && window.Vaadin.Flow && window.Vaadin.Flow.clients;
function mf() {
  function s() {
    return !0;
  }
  return zc(s);
}
function vf() {
  try {
    return _f() ? !0 : bf() ? Pn ? !yf() : !mf() : !1;
  } catch {
    return !1;
  }
}
function _f() {
  return localStorage.getItem("vaadin.developmentmode.force");
}
function bf() {
  return ["localhost", "127.0.0.1"].indexOf(window.location.hostname) >= 0;
}
function yf() {
  return !!(Pn && Object.keys(Pn).map((r) => Pn[r]).filter((r) => r.productionMode).length > 0);
}
function zc(s, r) {
  if (typeof s != "function")
    return;
  const e = gf.exec(s.toString());
  if (e)
    try {
      s = new Function(e[1]);
    } catch (t) {
      console.log("vaadin-development-mode-detector: uncommentAndRun() failed", t);
    }
  return s(r);
}
window.Vaadin = window.Vaadin || {};
const pl = function(s, r) {
  if (window.Vaadin.developmentMode)
    return zc(s, r);
};
window.Vaadin.developmentMode === void 0 && (window.Vaadin.developmentMode = vf());
function wf() {
  /*! vaadin-dev-mode:start
    (function () {
  'use strict';
  
  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };
  
  var classCallCheck = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };
  
  var createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
  
    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  
  var getPolymerVersion = function getPolymerVersion() {
    return window.Polymer && window.Polymer.version;
  };
  
  var StatisticsGatherer = function () {
    function StatisticsGatherer(logger) {
      classCallCheck(this, StatisticsGatherer);
  
      this.now = new Date().getTime();
      this.logger = logger;
    }
  
    createClass(StatisticsGatherer, [{
      key: 'frameworkVersionDetectors',
      value: function frameworkVersionDetectors() {
        return {
          'Flow': function Flow() {
            if (window.Vaadin && window.Vaadin.Flow && window.Vaadin.Flow.clients) {
              var flowVersions = Object.keys(window.Vaadin.Flow.clients).map(function (key) {
                return window.Vaadin.Flow.clients[key];
              }).filter(function (client) {
                return client.getVersionInfo;
              }).map(function (client) {
                return client.getVersionInfo().flow;
              });
              if (flowVersions.length > 0) {
                return flowVersions[0];
              }
            }
          },
          'Vaadin Framework': function VaadinFramework() {
            if (window.vaadin && window.vaadin.clients) {
              var frameworkVersions = Object.values(window.vaadin.clients).filter(function (client) {
                return client.getVersionInfo;
              }).map(function (client) {
                return client.getVersionInfo().vaadinVersion;
              });
              if (frameworkVersions.length > 0) {
                return frameworkVersions[0];
              }
            }
          },
          'AngularJs': function AngularJs() {
            if (window.angular && window.angular.version && window.angular.version) {
              return window.angular.version.full;
            }
          },
          'Angular': function Angular() {
            if (window.ng) {
              var tags = document.querySelectorAll("[ng-version]");
              if (tags.length > 0) {
                return tags[0].getAttribute("ng-version");
              }
              return "Unknown";
            }
          },
          'Backbone.js': function BackboneJs() {
            if (window.Backbone) {
              return window.Backbone.VERSION;
            }
          },
          'React': function React() {
            var reactSelector = '[data-reactroot], [data-reactid]';
            if (!!document.querySelector(reactSelector)) {
              // React does not publish the version by default
              return "unknown";
            }
          },
          'Ember': function Ember() {
            if (window.Em && window.Em.VERSION) {
              return window.Em.VERSION;
            } else if (window.Ember && window.Ember.VERSION) {
              return window.Ember.VERSION;
            }
          },
          'jQuery': function (_jQuery) {
            function jQuery() {
              return _jQuery.apply(this, arguments);
            }
  
            jQuery.toString = function () {
              return _jQuery.toString();
            };
  
            return jQuery;
          }(function () {
            if (typeof jQuery === 'function' && jQuery.prototype.jquery !== undefined) {
              return jQuery.prototype.jquery;
            }
          }),
          'Polymer': function Polymer() {
            var version = getPolymerVersion();
            if (version) {
              return version;
            }
          },
          'LitElement': function LitElement() {
            var version = window.litElementVersions && window.litElementVersions[0];
            if (version) {
              return version;
            }
          },
          'LitHtml': function LitHtml() {
            var version = window.litHtmlVersions && window.litHtmlVersions[0];
            if (version) {
              return version;
            }
          },
          'Vue.js': function VueJs() {
            if (window.Vue) {
              return window.Vue.version;
            }
          }
        };
      }
    }, {
      key: 'getUsedVaadinElements',
      value: function getUsedVaadinElements(elements) {
        var version = getPolymerVersion();
        var elementClasses = void 0;
        // NOTE: In case you edit the code here, YOU MUST UPDATE any statistics reporting code in Flow.
        // Check all locations calling the method getEntries() in
        // https://github.com/vaadin/flow/blob/master/flow-server/src/main/java/com/vaadin/flow/internal/UsageStatistics.java#L106
        // Currently it is only used by BootstrapHandler.
        if (version && version.indexOf('2') === 0) {
          // Polymer 2: components classes are stored in window.Vaadin
          elementClasses = Object.keys(window.Vaadin).map(function (c) {
            return window.Vaadin[c];
          }).filter(function (c) {
            return c.is;
          });
        } else {
          // Polymer 3: components classes are stored in window.Vaadin.registrations
          elementClasses = window.Vaadin.registrations || [];
        }
        elementClasses.forEach(function (klass) {
          var version = klass.version ? klass.version : "0.0.0";
          elements[klass.is] = { version: version };
        });
      }
    }, {
      key: 'getUsedVaadinThemes',
      value: function getUsedVaadinThemes(themes) {
        ['Lumo', 'Material'].forEach(function (themeName) {
          var theme;
          var version = getPolymerVersion();
          if (version && version.indexOf('2') === 0) {
            // Polymer 2: themes are stored in window.Vaadin
            theme = window.Vaadin[themeName];
          } else {
            // Polymer 3: themes are stored in custom element registry
            theme = customElements.get('vaadin-' + themeName.toLowerCase() + '-styles');
          }
          if (theme && theme.version) {
            themes[themeName] = { version: theme.version };
          }
        });
      }
    }, {
      key: 'getFrameworks',
      value: function getFrameworks(frameworks) {
        var detectors = this.frameworkVersionDetectors();
        Object.keys(detectors).forEach(function (framework) {
          var detector = detectors[framework];
          try {
            var version = detector();
            if (version) {
              frameworks[framework] = { version: version };
            }
          } catch (e) {}
        });
      }
    }, {
      key: 'gather',
      value: function gather(storage) {
        var storedStats = storage.read();
        var gatheredStats = {};
        var types = ["elements", "frameworks", "themes"];
  
        types.forEach(function (type) {
          gatheredStats[type] = {};
          if (!storedStats[type]) {
            storedStats[type] = {};
          }
        });
  
        var previousStats = JSON.stringify(storedStats);
  
        this.getUsedVaadinElements(gatheredStats.elements);
        this.getFrameworks(gatheredStats.frameworks);
        this.getUsedVaadinThemes(gatheredStats.themes);
  
        var now = this.now;
        types.forEach(function (type) {
          var keys = Object.keys(gatheredStats[type]);
          keys.forEach(function (key) {
            if (!storedStats[type][key] || _typeof(storedStats[type][key]) != _typeof({})) {
              storedStats[type][key] = { firstUsed: now };
            }
            // Discards any previously logged version number
            storedStats[type][key].version = gatheredStats[type][key].version;
            storedStats[type][key].lastUsed = now;
          });
        });
  
        var newStats = JSON.stringify(storedStats);
        storage.write(newStats);
        if (newStats != previousStats && Object.keys(storedStats).length > 0) {
          this.logger.debug("New stats: " + newStats);
        }
      }
    }]);
    return StatisticsGatherer;
  }();
  
  var StatisticsStorage = function () {
    function StatisticsStorage(key) {
      classCallCheck(this, StatisticsStorage);
  
      this.key = key;
    }
  
    createClass(StatisticsStorage, [{
      key: 'read',
      value: function read() {
        var localStorageStatsString = localStorage.getItem(this.key);
        try {
          return JSON.parse(localStorageStatsString ? localStorageStatsString : '{}');
        } catch (e) {
          return {};
        }
      }
    }, {
      key: 'write',
      value: function write(data) {
        localStorage.setItem(this.key, data);
      }
    }, {
      key: 'clear',
      value: function clear() {
        localStorage.removeItem(this.key);
      }
    }, {
      key: 'isEmpty',
      value: function isEmpty() {
        var storedStats = this.read();
        var empty = true;
        Object.keys(storedStats).forEach(function (key) {
          if (Object.keys(storedStats[key]).length > 0) {
            empty = false;
          }
        });
  
        return empty;
      }
    }]);
    return StatisticsStorage;
  }();
  
  var StatisticsSender = function () {
    function StatisticsSender(url, logger) {
      classCallCheck(this, StatisticsSender);
  
      this.url = url;
      this.logger = logger;
    }
  
    createClass(StatisticsSender, [{
      key: 'send',
      value: function send(data, errorHandler) {
        var logger = this.logger;
  
        if (navigator.onLine === false) {
          logger.debug("Offline, can't send");
          errorHandler();
          return;
        }
        logger.debug("Sending data to " + this.url);
  
        var req = new XMLHttpRequest();
        req.withCredentials = true;
        req.addEventListener("load", function () {
          // Stats sent, nothing more to do
          logger.debug("Response: " + req.responseText);
        });
        req.addEventListener("error", function () {
          logger.debug("Send failed");
          errorHandler();
        });
        req.addEventListener("abort", function () {
          logger.debug("Send aborted");
          errorHandler();
        });
        req.open("POST", this.url);
        req.setRequestHeader("Content-Type", "application/json");
        req.send(data);
      }
    }]);
    return StatisticsSender;
  }();
  
  var StatisticsLogger = function () {
    function StatisticsLogger(id) {
      classCallCheck(this, StatisticsLogger);
  
      this.id = id;
    }
  
    createClass(StatisticsLogger, [{
      key: '_isDebug',
      value: function _isDebug() {
        return localStorage.getItem("vaadin." + this.id + ".debug");
      }
    }, {
      key: 'debug',
      value: function debug(msg) {
        if (this._isDebug()) {
          console.info(this.id + ": " + msg);
        }
      }
    }]);
    return StatisticsLogger;
  }();
  
  var UsageStatistics = function () {
    function UsageStatistics() {
      classCallCheck(this, UsageStatistics);
  
      this.now = new Date();
      this.timeNow = this.now.getTime();
      this.gatherDelay = 10; // Delay between loading this file and gathering stats
      this.initialDelay = 24 * 60 * 60;
  
      this.logger = new StatisticsLogger("statistics");
      this.storage = new StatisticsStorage("vaadin.statistics.basket");
      this.gatherer = new StatisticsGatherer(this.logger);
      this.sender = new StatisticsSender("https://tools.vaadin.com/usage-stats/submit", this.logger);
    }
  
    createClass(UsageStatistics, [{
      key: 'maybeGatherAndSend',
      value: function maybeGatherAndSend() {
        var _this = this;
  
        if (localStorage.getItem(UsageStatistics.optOutKey)) {
          return;
        }
        this.gatherer.gather(this.storage);
        setTimeout(function () {
          _this.maybeSend();
        }, this.gatherDelay * 1000);
      }
    }, {
      key: 'lottery',
      value: function lottery() {
        return true;
      }
    }, {
      key: 'currentMonth',
      value: function currentMonth() {
        return this.now.getYear() * 12 + this.now.getMonth();
      }
    }, {
      key: 'maybeSend',
      value: function maybeSend() {
        var firstUse = Number(localStorage.getItem(UsageStatistics.firstUseKey));
        var monthProcessed = Number(localStorage.getItem(UsageStatistics.monthProcessedKey));
  
        if (!firstUse) {
          // Use a grace period to avoid interfering with tests, incognito mode etc
          firstUse = this.timeNow;
          localStorage.setItem(UsageStatistics.firstUseKey, firstUse);
        }
  
        if (this.timeNow < firstUse + this.initialDelay * 1000) {
          this.logger.debug("No statistics will be sent until the initial delay of " + this.initialDelay + "s has passed");
          return;
        }
        if (this.currentMonth() <= monthProcessed) {
          this.logger.debug("This month has already been processed");
          return;
        }
        localStorage.setItem(UsageStatistics.monthProcessedKey, this.currentMonth());
        // Use random sampling
        if (this.lottery()) {
          this.logger.debug("Congratulations, we have a winner!");
        } else {
          this.logger.debug("Sorry, no stats from you this time");
          return;
        }
  
        this.send();
      }
    }, {
      key: 'send',
      value: function send() {
        // Ensure we have the latest data
        this.gatherer.gather(this.storage);
  
        // Read, send and clean up
        var data = this.storage.read();
        data["firstUse"] = Number(localStorage.getItem(UsageStatistics.firstUseKey));
        data["usageStatisticsVersion"] = UsageStatistics.version;
        var info = 'This request contains usage statistics gathered from the application running in development mode. \n\nStatistics gathering is automatically disabled and excluded from production builds.\n\nFor details and to opt-out, see https://github.com/vaadin/vaadin-usage-statistics.\n\n\n\n';
        var self = this;
        this.sender.send(info + JSON.stringify(data), function () {
          // Revert the 'month processed' flag
          localStorage.setItem(UsageStatistics.monthProcessedKey, self.currentMonth() - 1);
        });
      }
    }], [{
      key: 'version',
      get: function get$1() {
        return '2.1.2';
      }
    }, {
      key: 'firstUseKey',
      get: function get$1() {
        return 'vaadin.statistics.firstuse';
      }
    }, {
      key: 'monthProcessedKey',
      get: function get$1() {
        return 'vaadin.statistics.monthProcessed';
      }
    }, {
      key: 'optOutKey',
      get: function get$1() {
        return 'vaadin.statistics.optout';
      }
    }]);
    return UsageStatistics;
  }();
  
  try {
    window.Vaadin = window.Vaadin || {};
    window.Vaadin.usageStatsChecker = window.Vaadin.usageStatsChecker || new UsageStatistics();
    window.Vaadin.usageStatsChecker.maybeGatherAndSend();
  } catch (e) {
    // Intentionally ignored as this is not a problem in the app being developed
  }
  
  }());
  
    vaadin-dev-mode:end **/
}
const xf = function() {
  if (typeof pl == "function")
    return pl(wf);
};
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
window.Vaadin || (window.Vaadin = {});
window.Vaadin.registrations || (window.Vaadin.registrations = []);
window.Vaadin.developmentModeCallback || (window.Vaadin.developmentModeCallback = {});
window.Vaadin.developmentModeCallback["vaadin-usage-statistics"] = function() {
  xf();
};
let Wo;
const gl = /* @__PURE__ */ new Set(), Fc = (s) => class extends Ur(s) {
  /** @protected */
  static finalize() {
    super.finalize();
    const { is: e } = this;
    e && !gl.has(e) && (window.Vaadin.registrations.push(this), gl.add(e), window.Vaadin.developmentModeCallback && (Wo = Le.debounce(Wo, Ic, () => {
      window.Vaadin.developmentModeCallback["vaadin-usage-statistics"]();
    }), Dc(Wo)));
  }
  constructor() {
    super(), document.doctype === null && console.warn(
      'Vaadin components require the "standards mode" declaration. Please add <!DOCTYPE html> to the HTML document.'
    );
  }
};
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
let Us = !1;
window.addEventListener(
  "keydown",
  () => {
    Us = !0;
  },
  { capture: !0 }
);
window.addEventListener(
  "mousedown",
  () => {
    Us = !1;
  },
  { capture: !0 }
);
function _s() {
  let s = document.activeElement || document.body;
  for (; s.shadowRoot && s.shadowRoot.activeElement; )
    s = s.shadowRoot.activeElement;
  return s;
}
function eo() {
  return Us;
}
function Mc(s) {
  const r = s.style;
  if (r.visibility === "hidden" || r.display === "none")
    return !0;
  const e = window.getComputedStyle(s);
  return e.visibility === "hidden" || e.display === "none";
}
function Cf(s, r) {
  const e = Math.max(s.tabIndex, 0), t = Math.max(r.tabIndex, 0);
  return e === 0 || t === 0 ? t > e : e > t;
}
function Tf(s, r) {
  const e = [];
  for (; s.length > 0 && r.length > 0; )
    Cf(s[0], r[0]) ? e.push(r.shift()) : e.push(s.shift());
  return e.concat(s, r);
}
function bs(s) {
  const r = s.length;
  if (r < 2)
    return s;
  const e = Math.ceil(r / 2), t = bs(s.slice(0, e)), i = bs(s.slice(e));
  return Tf(t, i);
}
function Un(s) {
  return s.offsetParent === null && s.clientWidth === 0 && s.clientHeight === 0 ? !0 : Mc(s);
}
function Ws(s) {
  return s.matches('[tabindex="-1"]') ? !1 : s.matches("input, select, textarea, button, object") ? s.matches(":not([disabled])") : s.matches("a[href], area[href], iframe, [tabindex], [contentEditable]");
}
function Lc(s) {
  return s.getRootNode().activeElement === s;
}
function Ef(s) {
  if (!Ws(s))
    return -1;
  const r = s.getAttribute("tabindex") || 0;
  return Number(r);
}
function Bc(s, r) {
  if (s.nodeType !== Node.ELEMENT_NODE || Mc(s))
    return !1;
  const e = (
    /** @type {HTMLElement} */
    s
  ), t = Ef(e);
  let i = t > 0;
  t >= 0 && r.push(e);
  let n = [];
  return e.localName === "slot" ? n = e.assignedNodes({ flatten: !0 }) : n = (e.shadowRoot || e).children, [...n].forEach((o) => {
    i = Bc(o, r) || i;
  }), i;
}
function Pf(s) {
  const r = [];
  return Bc(s, r) ? bs(r) : r;
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Nc = $e(
  (s) => class extends s {
    static get properties() {
      return {
        /**
         * If true, the user cannot interact with this element.
         */
        disabled: {
          type: Boolean,
          value: !1,
          observer: "_disabledChanged",
          reflectToAttribute: !0
        }
      };
    }
    /**
     * @param {boolean} disabled
     * @protected
     */
    _disabledChanged(e) {
      this._setAriaDisabled(e);
    }
    /**
     * @param {boolean} disabled
     * @protected
     */
    _setAriaDisabled(e) {
      e ? this.setAttribute("aria-disabled", "true") : this.removeAttribute("aria-disabled");
    }
    /**
     * Overrides the default element `click` method in order to prevent
     * firing the `click` event when the element is disabled.
     * @protected
     * @override
     */
    click() {
      this.disabled || super.click();
    }
  }
);
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Hc = (s) => class extends Nc(s) {
  static get properties() {
    return {
      /**
       * Indicates whether the element can be focused and where it participates in sequential keyboard navigation.
       *
       * @protected
       */
      tabindex: {
        type: Number,
        reflectToAttribute: !0,
        observer: "_tabindexChanged"
      },
      /**
       * Stores the last known tabindex since the element has been disabled.
       *
       * @protected
       */
      _lastTabIndex: {
        type: Number
      }
    };
  }
  /**
   * When the element gets disabled, the observer saves the last known tabindex
   * and makes the element not focusable by setting tabindex to -1.
   * As soon as the element gets enabled, the observer restores the last known tabindex
   * so that the element can be focusable again.
   *
   * @protected
   * @override
   */
  _disabledChanged(e, t) {
    super._disabledChanged(e, t), e ? (this.tabindex !== void 0 && (this._lastTabIndex = this.tabindex), this.tabindex = -1) : t && (this.tabindex = this._lastTabIndex);
  }
  /**
   * When the user has changed tabindex while the element is disabled,
   * the observer reverts tabindex to -1 and rather saves the new tabindex value to apply it later.
   * The new value will be applied as soon as the element becomes enabled.
   *
   * @protected
   */
  _tabindexChanged(e) {
    this.disabled && e !== -1 && (this._lastTabIndex = e, this.tabindex = -1);
  }
};
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const to = (s) => s.test(navigator.userAgent), ys = (s) => s.test(navigator.platform), Sf = (s) => s.test(navigator.vendor), ml = to(/Android/u), kf = to(/Chrome/u) && Sf(/Google Inc/u), Af = to(/Firefox/u), Rf = ys(/^iPad/u) || ys(/^Mac/u) && navigator.maxTouchPoints > 1, If = ys(/^iPhone/u), ws = If || Rf, Vc = to(/^((?!chrome|android).)*safari/iu), Mr = (() => {
  try {
    return document.createEvent("TouchEvent"), !0;
  } catch {
    return !1;
  }
})();
/**
 * @license
 * Copyright (c) 2023 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class Uc {
  constructor(r, e) {
    this.slot = r, this.callback = e, this._storedNodes = [], this._connected = !1, this._scheduled = !1, this._boundSchedule = () => {
      this._schedule();
    }, this.connect(), this._schedule();
  }
  /**
   * Activates an observer. This method is automatically called when
   * a `SlotObserver` is created. It should only be called to  re-activate
   * an observer that has been deactivated via the `disconnect` method.
   */
  connect() {
    this.slot.addEventListener("slotchange", this._boundSchedule), this._connected = !0;
  }
  /**
   * Deactivates the observer. After calling this method the observer callback
   * will not be called when changes to slotted nodes occur. The `connect` method
   * may be subsequently called to reactivate the observer.
   */
  disconnect() {
    this.slot.removeEventListener("slotchange", this._boundSchedule), this._connected = !1;
  }
  /** @private */
  _schedule() {
    this._scheduled || (this._scheduled = !0, queueMicrotask(() => {
      this.flush();
    }));
  }
  /**
   * Run the observer callback synchronously.
   */
  flush() {
    this._connected && (this._scheduled = !1, this._processNodes());
  }
  /** @private */
  _processNodes() {
    const r = this.slot.assignedNodes({ flatten: !0 });
    let e = [];
    const t = [], i = [];
    r.length && (e = r.filter((n) => !this._storedNodes.includes(n))), this._storedNodes.length && this._storedNodes.forEach((n, o) => {
      const a = r.indexOf(n);
      a === -1 ? t.push(n) : a !== o && i.push(n);
    }), (e.length || t.length || i.length) && this.callback({ addedNodes: e, currentNodes: r, movedNodes: i, removedNodes: t }), this._storedNodes = r;
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
let Df = 0;
function Wc() {
  return Df++;
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class js extends EventTarget {
  /**
   * Ensure that every instance has unique ID.
   *
   * @param {HTMLElement} host
   * @param {string} slotName
   * @return {string}
   * @protected
   */
  static generateId(r, e = "default") {
    return `${e}-${r.localName}-${Wc()}`;
  }
  constructor(r, e, t, i = {}) {
    super();
    const { initializer: n, multiple: o, observe: a, useUniqueId: l, uniqueIdPrefix: h } = i;
    this.host = r, this.slotName = e, this.tagName = t, this.observe = typeof a == "boolean" ? a : !0, this.multiple = typeof o == "boolean" ? o : !1, this.slotInitializer = n, o && (this.nodes = []), l && (this.defaultId = this.constructor.generateId(r, h || e));
  }
  hostConnected() {
    this.initialized || (this.multiple ? this.initMultiple() : this.initSingle(), this.observe && this.observeSlot(), this.initialized = !0);
  }
  /** @protected */
  initSingle() {
    let r = this.getSlotChild();
    r ? (this.node = r, this.initAddedNode(r)) : (r = this.attachDefaultNode(), this.initNode(r));
  }
  /** @protected */
  initMultiple() {
    const r = this.getSlotChildren();
    if (r.length === 0) {
      const e = this.attachDefaultNode();
      e && (this.nodes = [e], this.initNode(e));
    } else
      this.nodes = r, r.forEach((e) => {
        this.initAddedNode(e);
      });
  }
  /**
   * Create and attach default node using the provided tag name, if any.
   * @return {Node | undefined}
   * @protected
   */
  attachDefaultNode() {
    const { host: r, slotName: e, tagName: t } = this;
    let i = this.defaultNode;
    return !i && t && (i = document.createElement(t), i instanceof Element && (e !== "" && i.setAttribute("slot", e), this.defaultNode = i)), i && (this.node = i, r.appendChild(i)), i;
  }
  /**
   * Return the list of nodes matching the slot managed by the controller.
   * @return {Node}
   */
  getSlotChildren() {
    const { slotName: r } = this;
    return Array.from(this.host.childNodes).filter((e) => e.nodeType === Node.ELEMENT_NODE && e.slot === r || e.nodeType === Node.TEXT_NODE && e.textContent.trim() && r === "");
  }
  /**
   * Return a reference to the node managed by the controller.
   * @return {Node}
   */
  getSlotChild() {
    return this.getSlotChildren()[0];
  }
  /**
   * Run `slotInitializer` for the node managed by the controller.
   *
   * @param {Node} node
   * @protected
   */
  initNode(r) {
    const { slotInitializer: e } = this;
    e && e(r, this.host);
  }
  /**
   * Override to initialize the newly added custom node.
   *
   * @param {Node} _node
   * @protected
   */
  initCustomNode(r) {
  }
  /**
   * Override to teardown slotted node when it's removed.
   *
   * @param {Node} _node
   * @protected
   */
  teardownNode(r) {
  }
  /**
   * Run both `initCustomNode` and `initNode` for a custom slotted node.
   *
   * @param {Node} node
   * @protected
   */
  initAddedNode(r) {
    r !== this.defaultNode && (this.initCustomNode(r), this.initNode(r));
  }
  /**
   * Setup the observer to manage slot content changes.
   * @protected
   */
  observeSlot() {
    const { slotName: r } = this, e = r === "" ? "slot:not([name])" : `slot[name=${r}]`, t = this.host.shadowRoot.querySelector(e);
    this.__slotObserver = new Uc(t, ({ addedNodes: i, removedNodes: n }) => {
      const o = this.multiple ? this.nodes : [this.node], a = i.filter((l) => !hf(l) && !o.includes(l));
      n.length && (this.nodes = o.filter((l) => !n.includes(l)), n.forEach((l) => {
        this.teardownNode(l);
      })), a && a.length > 0 && (this.multiple ? (this.defaultNode && this.defaultNode.remove(), this.nodes = [...o, ...a].filter((l) => l !== this.defaultNode), a.forEach((l) => {
        this.initAddedNode(l);
      })) : (this.node && this.node.remove(), this.node = a[0], this.initAddedNode(this.node)));
    });
  }
}
/**
 * @license
 * Copyright (c) 2022 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class jc extends js {
  constructor(r) {
    super(r, "tooltip"), this.setTarget(r);
  }
  /**
   * Override to initialize the newly added custom tooltip.
   *
   * @param {Node} tooltipNode
   * @protected
   * @override
   */
  initCustomNode(r) {
    r.target = this.target, this.ariaTarget !== void 0 && (r.ariaTarget = this.ariaTarget), this.context !== void 0 && (r.context = this.context), this.manual !== void 0 && (r.manual = this.manual), this.opened !== void 0 && (r.opened = this.opened), this.position !== void 0 && (r._position = this.position), this.shouldShow !== void 0 && (r.shouldShow = this.shouldShow), this.__notifyChange();
  }
  /**
   * Override to notify the host when the tooltip is removed.
   *
   * @param {Node} tooltipNode
   * @protected
   * @override
   */
  teardownNode() {
    this.__notifyChange();
  }
  /**
   * Set an HTML element for linking with the tooltip overlay
   * via `aria-describedby` attribute used by screen readers.
   * @param {HTMLElement} ariaTarget
   */
  setAriaTarget(r) {
    this.ariaTarget = r;
    const e = this.node;
    e && (e.ariaTarget = r);
  }
  /**
   * Set a context object to be used by generator.
   * @param {object} context
   */
  setContext(r) {
    this.context = r;
    const e = this.node;
    e && (e.context = r);
  }
  /**
   * Toggle manual state on the slotted tooltip.
   * @param {boolean} manual
   */
  setManual(r) {
    this.manual = r;
    const e = this.node;
    e && (e.manual = r);
  }
  /**
   * Toggle opened state on the slotted tooltip.
   * @param {boolean} opened
   */
  setOpened(r) {
    this.opened = r;
    const e = this.node;
    e && (e.opened = r);
  }
  /**
   * Set default position for the slotted tooltip.
   * This can be overridden by setting the position
   * using corresponding property or attribute.
   * @param {string} position
   */
  setPosition(r) {
    this.position = r;
    const e = this.node;
    e && (e._position = r);
  }
  /**
   * Set function used to detect whether to show
   * the tooltip based on a condition.
   * @param {Function} shouldShow
   */
  setShouldShow(r) {
    this.shouldShow = r;
    const e = this.node;
    e && (e.shouldShow = r);
  }
  /**
   * Set an HTML element to attach the tooltip to.
   * @param {HTMLElement} target
   */
  setTarget(r) {
    this.target = r;
    const e = this.node;
    e && (e.target = r);
  }
  /** @private */
  __notifyChange() {
    this.dispatchEvent(new CustomEvent("tooltip-changed", { detail: { node: this.node } }));
  }
}
/**
 * @license
 * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
const vl = navigator.userAgent.match(/iP(?:hone|ad;(?: U;)? CPU) OS (\d+)/u), Of = vl && vl[1] >= 8, _l = 3, zf = {
  /**
   * The ratio of hidden tiles that should remain in the scroll direction.
   * Recommended value ~0.5, so it will distribute tiles evenly in both
   * directions.
   */
  _ratio: 0.5,
  /**
   * The padding-top value for the list.
   */
  _scrollerPaddingTop: 0,
  /**
   * This value is a cached value of `scrollTop` from the last `scroll` event.
   */
  _scrollPosition: 0,
  /**
   * The sum of the heights of all the tiles in the DOM.
   */
  _physicalSize: 0,
  /**
   * The average `offsetHeight` of the tiles observed till now.
   */
  _physicalAverage: 0,
  /**
   * The number of tiles which `offsetHeight` > 0 observed until now.
   */
  _physicalAverageCount: 0,
  /**
   * The Y position of the item rendered in the `_physicalStart`
   * tile relative to the scrolling list.
   */
  _physicalTop: 0,
  /**
   * The number of items in the list.
   */
  _virtualCount: 0,
  /**
   * The estimated scroll height based on `_physicalAverage`
   */
  _estScrollHeight: 0,
  /**
   * The scroll height of the dom node
   */
  _scrollHeight: 0,
  /**
   * The height of the list. This is referred as the viewport in the context of
   * list.
   */
  _viewportHeight: 0,
  /**
   * The width of the list. This is referred as the viewport in the context of
   * list.
   */
  _viewportWidth: 0,
  /**
   * An array of DOM nodes that are currently in the tree
   * @type {?Array<!HTMLElement>}
   */
  _physicalItems: null,
  /**
   * An array of heights for each item in `_physicalItems`
   * @type {?Array<number>}
   */
  _physicalSizes: null,
  /**
   * A cached value for the first visible index.
   * See `firstVisibleIndex`
   * @type {?number}
   */
  _firstVisibleIndexVal: null,
  /**
   * A cached value for the last visible index.
   * See `lastVisibleIndex`
   * @type {?number}
   */
  _lastVisibleIndexVal: null,
  /**
   * The max number of pages to render. One page is equivalent to the height of
   * the list.
   */
  _maxPages: 2,
  /**
   * The cost of stamping a template in ms.
   */
  _templateCost: 0,
  /**
   * The bottom of the physical content.
   */
  get _physicalBottom() {
    return this._physicalTop + this._physicalSize;
  },
  /**
   * The bottom of the scroll.
   */
  get _scrollBottom() {
    return this._scrollPosition + this._viewportHeight;
  },
  /**
   * The n-th item rendered in the last physical item.
   */
  get _virtualEnd() {
    return this._virtualStart + this._physicalCount - 1;
  },
  /**
   * The height of the physical content that isn't on the screen.
   */
  get _hiddenContentSize() {
    return this._physicalSize - this._viewportHeight;
  },
  /**
   * The maximum scroll top value.
   */
  get _maxScrollTop() {
    return this._estScrollHeight - this._viewportHeight + this._scrollOffset;
  },
  /**
   * The largest n-th value for an item such that it can be rendered in
   * `_physicalStart`.
   */
  get _maxVirtualStart() {
    const s = this._virtualCount;
    return Math.max(0, s - this._physicalCount);
  },
  get _virtualStart() {
    return this._virtualStartVal || 0;
  },
  set _virtualStart(s) {
    s = this._clamp(s, 0, this._maxVirtualStart), this._virtualStartVal = s;
  },
  get _physicalStart() {
    return this._physicalStartVal || 0;
  },
  /**
   * The k-th tile that is at the top of the scrolling list.
   */
  set _physicalStart(s) {
    s %= this._physicalCount, s < 0 && (s = this._physicalCount + s), this._physicalStartVal = s;
  },
  /**
   * The k-th tile that is at the bottom of the scrolling list.
   */
  get _physicalEnd() {
    return (this._physicalStart + this._physicalCount - 1) % this._physicalCount;
  },
  get _physicalCount() {
    return this._physicalCountVal || 0;
  },
  set _physicalCount(s) {
    this._physicalCountVal = s;
  },
  /**
   * An optimal physical size such that we will have enough physical items
   * to fill up the viewport and recycle when the user scrolls.
   *
   * This default value assumes that we will at least have the equivalent
   * to a viewport of physical items above and below the user's viewport.
   */
  get _optPhysicalSize() {
    return this._viewportHeight === 0 ? 1 / 0 : this._viewportHeight * this._maxPages;
  },
  /**
   * True if the current list is visible.
   */
  get _isVisible() {
    return !!(this.offsetWidth || this.offsetHeight);
  },
  /**
   * Gets the index of the first visible item in the viewport.
   *
   * @type {number}
   */
  get firstVisibleIndex() {
    let s = this._firstVisibleIndexVal;
    if (s == null) {
      let r = this._physicalTop + this._scrollOffset;
      s = this._iterateItems((e, t) => {
        if (r += this._getPhysicalSizeIncrement(e), r > this._scrollPosition)
          return t;
      }) || 0, this._firstVisibleIndexVal = s;
    }
    return s;
  },
  /**
   * Gets the index of the last visible item in the viewport.
   *
   * @type {number}
   */
  get lastVisibleIndex() {
    let s = this._lastVisibleIndexVal;
    if (s == null) {
      let r = this._physicalTop + this._scrollOffset;
      this._iterateItems((e, t) => {
        r < this._scrollBottom && (s = t), r += this._getPhysicalSizeIncrement(e);
      }), this._lastVisibleIndexVal = s;
    }
    return s;
  },
  get _scrollOffset() {
    return this._scrollerPaddingTop + this.scrollOffset;
  },
  /**
   * Recycles the physical items when needed.
   */
  _scrollHandler() {
    const s = Math.max(0, Math.min(this._maxScrollTop, this._scrollTop));
    let r = s - this._scrollPosition;
    const e = r >= 0;
    if (this._scrollPosition = s, this._firstVisibleIndexVal = null, this._lastVisibleIndexVal = null, Math.abs(r) > this._physicalSize && this._physicalSize > 0) {
      r -= this._scrollOffset;
      const t = Math.round(r / this._physicalAverage);
      this._virtualStart += t, this._physicalStart += t, this._physicalTop = Math.min(Math.floor(this._virtualStart) * this._physicalAverage, this._scrollPosition), this._update();
    } else if (this._physicalCount > 0) {
      const t = this._getReusables(e);
      e ? (this._physicalTop = t.physicalTop, this._virtualStart += t.indexes.length, this._physicalStart += t.indexes.length) : (this._virtualStart -= t.indexes.length, this._physicalStart -= t.indexes.length), this._update(t.indexes, e ? null : t.indexes), this._debounce("_increasePoolIfNeeded", this._increasePoolIfNeeded.bind(this, 0), yt);
    }
  },
  /**
   * Returns an object that contains the indexes of the physical items
   * that might be reused and the physicalTop.
   *
   * @param {boolean} fromTop If the potential reusable items are above the scrolling region.
   */
  _getReusables(s) {
    let r, e, t;
    const i = [], n = this._hiddenContentSize * this._ratio, o = this._virtualStart, a = this._virtualEnd, l = this._physicalCount;
    let h = this._physicalTop + this._scrollOffset;
    const d = this._physicalBottom + this._scrollOffset, f = this._scrollPosition, g = this._scrollBottom;
    for (s ? (r = this._physicalStart, e = f - h) : (r = this._physicalEnd, e = d - g); t = this._getPhysicalSizeIncrement(r), e -= t, !(i.length >= l || e <= n); )
      if (s) {
        if (a + i.length + 1 >= this._virtualCount || h + t >= f - this._scrollOffset)
          break;
        i.push(r), h += t, r = (r + 1) % l;
      } else {
        if (o - i.length <= 0 || h + this._physicalSize - t <= g)
          break;
        i.push(r), h -= t, r = r === 0 ? l - 1 : r - 1;
      }
    return { indexes: i, physicalTop: h - this._scrollOffset };
  },
  /**
   * Update the list of items, starting from the `_virtualStart` item.
   * @param {!Array<number>=} itemSet
   * @param {!Array<number>=} movingUp
   */
  _update(s, r) {
    if (!(s && s.length === 0 || this._physicalCount === 0)) {
      if (this._assignModels(s), this._updateMetrics(s), r)
        for (; r.length; ) {
          const e = r.pop();
          this._physicalTop -= this._getPhysicalSizeIncrement(e);
        }
      this._positionItems(), this._updateScrollerSize();
    }
  },
  _isClientFull() {
    return this._scrollBottom !== 0 && this._physicalBottom - 1 >= this._scrollBottom && this._physicalTop <= this._scrollPosition;
  },
  /**
   * Increases the pool size.
   */
  _increasePoolIfNeeded(s) {
    const e = this._clamp(
      this._physicalCount + s,
      _l,
      this._virtualCount - this._virtualStart
    ) - this._physicalCount;
    let t = Math.round(this._physicalCount * 0.5);
    if (!(e < 0)) {
      if (e > 0) {
        const i = window.performance.now();
        [].push.apply(this._physicalItems, this._createPool(e));
        for (let n = 0; n < e; n++)
          this._physicalSizes.push(0);
        this._physicalCount += e, this._physicalStart > this._physicalEnd && this._isIndexRendered(this._focusedVirtualIndex) && this._getPhysicalIndex(this._focusedVirtualIndex) < this._physicalEnd && (this._physicalStart += e), this._update(), this._templateCost = (window.performance.now() - i) / e, t = Math.round(this._physicalCount * 0.5);
      }
      this._virtualEnd >= this._virtualCount - 1 || t === 0 || (this._isClientFull() ? this._physicalSize < this._optPhysicalSize && this._debounce(
        "_increasePoolIfNeeded",
        this._increasePoolIfNeeded.bind(this, this._clamp(Math.round(50 / this._templateCost), 1, t)),
        Ic
      ) : this._debounce("_increasePoolIfNeeded", this._increasePoolIfNeeded.bind(this, t), yt));
    }
  },
  /**
   * Renders the a new list.
   */
  _render() {
    if (!(!this.isAttached || !this._isVisible))
      if (this._physicalCount !== 0) {
        const s = this._getReusables(!0);
        this._physicalTop = s.physicalTop, this._virtualStart += s.indexes.length, this._physicalStart += s.indexes.length, this._update(s.indexes), this._update(), this._increasePoolIfNeeded(0);
      } else this._virtualCount > 0 && (this.updateViewportBoundaries(), this._increasePoolIfNeeded(_l));
  },
  /**
   * Called when the items have changed. That is, reassignments
   * to `items`, splices or updates to a single item.
   */
  _itemsChanged(s) {
    s.path === "items" && (this._virtualStart = 0, this._physicalTop = 0, this._virtualCount = this.items ? this.items.length : 0, this._physicalIndexForKey = {}, this._firstVisibleIndexVal = null, this._lastVisibleIndexVal = null, this._physicalItems || (this._physicalItems = []), this._physicalSizes || (this._physicalSizes = []), this._physicalStart = 0, this._scrollTop > this._scrollOffset && this._resetScrollPosition(0), this._debounce("_render", this._render, Jt));
  },
  /**
   * Executes a provided function per every physical index in `itemSet`
   * `itemSet` default value is equivalent to the entire set of physical
   * indexes.
   *
   * @param {!function(number, number)} fn
   * @param {!Array<number>=} itemSet
   */
  _iterateItems(s, r) {
    let e, t, i, n;
    if (arguments.length === 2 && r) {
      for (n = 0; n < r.length; n++)
        if (e = r[n], t = this._computeVidx(e), (i = s.call(this, e, t)) != null)
          return i;
    } else {
      for (e = this._physicalStart, t = this._virtualStart; e < this._physicalCount; e++, t++)
        if ((i = s.call(this, e, t)) != null)
          return i;
      for (e = 0; e < this._physicalStart; e++, t++)
        if ((i = s.call(this, e, t)) != null)
          return i;
    }
  },
  /**
   * Returns the virtual index for a given physical index
   *
   * @param {number} pidx Physical index
   * @return {number}
   */
  _computeVidx(s) {
    return s >= this._physicalStart ? this._virtualStart + (s - this._physicalStart) : this._virtualStart + (this._physicalCount - this._physicalStart) + s;
  },
  /**
   * Updates the position of the physical items.
   */
  _positionItems() {
    this._adjustScrollPosition();
    let s = this._physicalTop;
    this._iterateItems((r) => {
      this.translate3d(0, `${s}px`, 0, this._physicalItems[r]), s += this._physicalSizes[r];
    });
  },
  _getPhysicalSizeIncrement(s) {
    return this._physicalSizes[s];
  },
  /**
   * Adjusts the scroll position when it was overestimated.
   */
  _adjustScrollPosition() {
    const s = this._virtualStart === 0 ? this._physicalTop : Math.min(this._scrollPosition + this._physicalTop, 0);
    if (s !== 0) {
      this._physicalTop -= s;
      const r = this._scrollPosition;
      !Of && r > 0 && this._resetScrollPosition(r - s);
    }
  },
  /**
   * Sets the position of the scroll.
   */
  _resetScrollPosition(s) {
    this.scrollTarget && s >= 0 && (this._scrollTop = s, this._scrollPosition = this._scrollTop);
  },
  /**
   * Sets the scroll height, that's the height of the content,
   *
   * @param {boolean=} forceUpdate If true, updates the height no matter what.
   */
  _updateScrollerSize(s) {
    const r = this._physicalBottom + Math.max(this._virtualCount - this._physicalCount - this._virtualStart, 0) * this._physicalAverage;
    this._estScrollHeight = r, (s || this._scrollHeight === 0 || this._scrollPosition >= r - this._physicalSize || Math.abs(r - this._scrollHeight) >= this._viewportHeight) && (this.$.items.style.height = `${r}px`, this._scrollHeight = r);
  },
  /**
   * Scroll to a specific index in the virtual list regardless
   * of the physical items in the DOM tree.
   *
   * @method scrollToIndex
   * @param {number} idx The index of the item
   */
  scrollToIndex(s) {
    if (typeof s != "number" || s < 0 || s > this.items.length - 1 || (Cr(), this._physicalCount === 0))
      return;
    s = this._clamp(s, 0, this._virtualCount - 1), (!this._isIndexRendered(s) || s >= this._maxVirtualStart) && (this._virtualStart = s - 1), this._assignModels(), this._updateMetrics(), this._physicalTop = this._virtualStart * this._physicalAverage;
    let r = this._physicalStart, e = this._virtualStart, t = 0;
    const i = this._hiddenContentSize;
    for (; e < s && t <= i; )
      t += this._getPhysicalSizeIncrement(r), r = (r + 1) % this._physicalCount, e += 1;
    this._updateScrollerSize(!0), this._positionItems(), this._resetScrollPosition(this._physicalTop + this._scrollOffset + t), this._increasePoolIfNeeded(0), this._firstVisibleIndexVal = null, this._lastVisibleIndexVal = null;
  },
  /**
   * Reset the physical average and the average count.
   */
  _resetAverage() {
    this._physicalAverage = 0, this._physicalAverageCount = 0;
  },
  /**
   * A handler for the `iron-resize` event triggered by `IronResizableBehavior`
   * when the element is resized.
   */
  _resizeHandler() {
    this._debounce(
      "_render",
      () => {
        this._firstVisibleIndexVal = null, this._lastVisibleIndexVal = null, this._isVisible ? (this.updateViewportBoundaries(), this.toggleScrollListener(!0), this._resetAverage(), this._render()) : this.toggleScrollListener(!1);
      },
      Jt
    );
  },
  _isIndexRendered(s) {
    return s >= this._virtualStart && s <= this._virtualEnd;
  },
  _getPhysicalIndex(s) {
    return (this._physicalStart + (s - this._virtualStart)) % this._physicalCount;
  },
  _clamp(s, r, e) {
    return Math.min(e, Math.max(r, s));
  },
  _debounce(s, r, e) {
    this._debouncers || (this._debouncers = {}), this._debouncers[s] = Le.debounce(this._debouncers[s], e, r.bind(this)), Dc(this._debouncers[s]);
  }
};
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Ff = 1e5, jo = 1e3;
class Gc {
  constructor({ createElements: r, updateElement: e, scrollTarget: t, scrollContainer: i, elementsContainer: n, reorderElements: o }) {
    this.isAttached = !0, this._vidxOffset = 0, this.createElements = r, this.updateElement = e, this.scrollTarget = t, this.scrollContainer = i, this.elementsContainer = n || i, this.reorderElements = o, this._maxPages = 1.3, this.__placeholderHeight = 200, this.__elementHeightQueue = Array(10), this.timeouts = {
      SCROLL_REORDER: 500,
      IGNORE_WHEEL: 500,
      FIX_INVALID_ITEM_POSITIONING: 100
    }, this.__resizeObserver = new ResizeObserver(() => this._resizeHandler()), getComputedStyle(this.scrollTarget).overflow === "visible" && (this.scrollTarget.style.overflow = "auto"), getComputedStyle(this.scrollContainer).position === "static" && (this.scrollContainer.style.position = "relative"), this.__resizeObserver.observe(this.scrollTarget), this.scrollTarget.addEventListener("scroll", () => this._scrollHandler()), this._scrollLineHeight = this._getScrollLineHeight(), this.scrollTarget.addEventListener("wheel", (a) => this.__onWheel(a)), this.scrollTarget.addEventListener("virtualizer-element-focused", (a) => this.__onElementFocused(a)), this.elementsContainer.addEventListener("focusin", () => {
      this.scrollTarget.dispatchEvent(
        new CustomEvent("virtualizer-element-focused", { detail: { element: this.__getFocusedElement() } })
      );
    }), this.reorderElements && (this.scrollTarget.addEventListener("mousedown", () => {
      this.__mouseDown = !0;
    }), this.scrollTarget.addEventListener("mouseup", () => {
      this.__mouseDown = !1, this.__pendingReorder && this.__reorderElements();
    }));
  }
  get scrollOffset() {
    return 0;
  }
  get adjustedFirstVisibleIndex() {
    return this.firstVisibleIndex + this._vidxOffset;
  }
  get adjustedLastVisibleIndex() {
    return this.lastVisibleIndex + this._vidxOffset;
  }
  get _maxVirtualIndexOffset() {
    return this.size - this._virtualCount;
  }
  __hasPlaceholders() {
    return this.__getVisibleElements().some((r) => r.__virtualizerPlaceholder);
  }
  scrollToIndex(r) {
    if (typeof r != "number" || isNaN(r) || this.size === 0 || !this.scrollTarget.offsetHeight)
      return;
    delete this.__pendingScrollToIndex, this._physicalCount <= 3 && this.flush(), r = this._clamp(r, 0, this.size - 1);
    const e = this.__getVisibleElements().length;
    let t = Math.floor(r / this.size * this._virtualCount);
    this._virtualCount - t < e ? (t = this._virtualCount - (this.size - r), this._vidxOffset = this._maxVirtualIndexOffset) : t < e ? r < jo ? (t = r, this._vidxOffset = 0) : (t = jo, this._vidxOffset = r - t) : this._vidxOffset = r - t, this.__skipNextVirtualIndexAdjust = !0, super.scrollToIndex(t), this.adjustedFirstVisibleIndex !== r && this._scrollTop < this._maxScrollTop && !this.grid && (this._scrollTop -= this.__getIndexScrollOffset(r) || 0), this._scrollHandler(), this.__hasPlaceholders() && (this.__pendingScrollToIndex = r);
  }
  flush() {
    this.scrollTarget.offsetHeight !== 0 && (this._resizeHandler(), Cr(), this._scrollHandler(), this.__fixInvalidItemPositioningDebouncer && this.__fixInvalidItemPositioningDebouncer.flush(), this.__scrollReorderDebouncer && this.__scrollReorderDebouncer.flush(), this.__debouncerWheelAnimationFrame && this.__debouncerWheelAnimationFrame.flush());
  }
  update(r = 0, e = this.size - 1) {
    const t = [];
    this.__getVisibleElements().forEach((i) => {
      i.__virtualIndex >= r && i.__virtualIndex <= e && (this.__updateElement(i, i.__virtualIndex, !0), t.push(i));
    }), this.__afterElementsUpdated(t);
  }
  /**
   * Updates the height for a given set of items.
   *
   * @param {!Array<number>=} itemSet
   */
  _updateMetrics(r) {
    Cr();
    let e = 0, t = 0;
    const i = this._physicalAverageCount, n = this._physicalAverage;
    this._iterateItems((o, a) => {
      t += this._physicalSizes[o], this._physicalSizes[o] = Math.ceil(this.__getBorderBoxHeight(this._physicalItems[o])), e += this._physicalSizes[o], this._physicalAverageCount += this._physicalSizes[o] ? 1 : 0;
    }, r), this._physicalSize = this._physicalSize + e - t, this._physicalAverageCount !== i && (this._physicalAverage = Math.round(
      (n * i + e) / this._physicalAverageCount
    ));
  }
  __getBorderBoxHeight(r) {
    const e = getComputedStyle(r), t = parseFloat(e.height) || 0;
    if (e.boxSizing === "border-box")
      return t;
    const i = parseFloat(e.paddingBottom) || 0, n = parseFloat(e.paddingTop) || 0, o = parseFloat(e.borderBottomWidth) || 0, a = parseFloat(e.borderTopWidth) || 0;
    return t + i + n + o + a;
  }
  __updateElement(r, e, t) {
    r.__virtualizerPlaceholder && (r.style.paddingTop = "", r.style.opacity = "", r.__virtualizerPlaceholder = !1), !this.__preventElementUpdates && (r.__lastUpdatedIndex !== e || t) && (this.updateElement(r, e), r.__lastUpdatedIndex = e);
  }
  /**
   * Called synchronously right after elements have been updated.
   * This is a good place to do any post-update work.
   *
   * @param {!Array<!HTMLElement>} updatedElements
   */
  __afterElementsUpdated(r) {
    r.forEach((e) => {
      const t = e.offsetHeight;
      if (t === 0)
        e.style.paddingTop = `${this.__placeholderHeight}px`, e.style.opacity = "0", e.__virtualizerPlaceholder = !0, this.__placeholderClearDebouncer = Le.debounce(
          this.__placeholderClearDebouncer,
          Jt,
          () => this._resizeHandler()
        );
      else {
        this.__elementHeightQueue.push(t), this.__elementHeightQueue.shift();
        const i = this.__elementHeightQueue.filter((n) => n !== void 0);
        this.__placeholderHeight = Math.round(i.reduce((n, o) => n + o, 0) / i.length);
      }
    }), this.__pendingScrollToIndex !== void 0 && !this.__hasPlaceholders() && this.scrollToIndex(this.__pendingScrollToIndex);
  }
  __getIndexScrollOffset(r) {
    const e = this.__getVisibleElements().find((t) => t.__virtualIndex === r);
    return e ? this.scrollTarget.getBoundingClientRect().top - e.getBoundingClientRect().top : void 0;
  }
  get size() {
    return this.__size;
  }
  set size(r) {
    if (r === this.size)
      return;
    this.__fixInvalidItemPositioningDebouncer && this.__fixInvalidItemPositioningDebouncer.cancel(), this._debouncers && this._debouncers._increasePoolIfNeeded && this._debouncers._increasePoolIfNeeded.cancel(), this.__preventElementUpdates = !0;
    let e, t;
    if (r > 0 && (e = this.adjustedFirstVisibleIndex, t = this.__getIndexScrollOffset(e)), this.__size = r, this._itemsChanged({
      path: "items"
    }), Cr(), r > 0) {
      e = Math.min(e, r - 1), this.scrollToIndex(e);
      const i = this.__getIndexScrollOffset(e);
      t !== void 0 && i !== void 0 && (this._scrollTop += t - i);
    }
    this.__preventElementUpdates = !1, this._isVisible || this._assignModels(), this.elementsContainer.children.length || requestAnimationFrame(() => this._resizeHandler()), this._resizeHandler(), Cr(), this._debounce("_update", this._update, yt);
  }
  /** @private */
  get _scrollTop() {
    return this.scrollTarget.scrollTop;
  }
  /** @private */
  set _scrollTop(r) {
    this.scrollTarget.scrollTop = r;
  }
  /** @private */
  get items() {
    return {
      length: Math.min(this.size, Ff)
    };
  }
  /** @private */
  get offsetHeight() {
    return this.scrollTarget.offsetHeight;
  }
  /** @private */
  get $() {
    return {
      items: this.scrollContainer
    };
  }
  /** @private */
  updateViewportBoundaries() {
    const r = window.getComputedStyle(this.scrollTarget);
    this._scrollerPaddingTop = this.scrollTarget === this ? 0 : parseInt(r["padding-top"], 10), this._isRTL = r.direction === "rtl", this._viewportWidth = this.elementsContainer.offsetWidth, this._viewportHeight = this.scrollTarget.offsetHeight, this._scrollPageHeight = this._viewportHeight - this._scrollLineHeight, this.grid && this._updateGridMetrics();
  }
  /** @private */
  setAttribute() {
  }
  /** @private */
  _createPool(r) {
    const e = this.createElements(r), t = document.createDocumentFragment();
    return e.forEach((i) => {
      i.style.position = "absolute", t.appendChild(i), this.__resizeObserver.observe(i);
    }), this.elementsContainer.appendChild(t), e;
  }
  /** @private */
  _assignModels(r) {
    const e = [];
    this._iterateItems((t, i) => {
      const n = this._physicalItems[t];
      n.hidden = i >= this.size, n.hidden ? delete n.__lastUpdatedIndex : (n.__virtualIndex = i + (this._vidxOffset || 0), this.__updateElement(n, n.__virtualIndex), e.push(n));
    }, r), this.__afterElementsUpdated(e);
  }
  /** @private */
  _isClientFull() {
    return setTimeout(() => {
      this.__clientFull = !0;
    }), this.__clientFull || super._isClientFull();
  }
  /** @private */
  translate3d(r, e, t, i) {
    i.style.transform = `translateY(${e})`;
  }
  /** @private */
  toggleScrollListener() {
  }
  /** @private */
  __getFocusedElement(r = this.__getVisibleElements()) {
    return r.find(
      (e) => e.contains(this.elementsContainer.getRootNode().activeElement) || e.contains(this.scrollTarget.getRootNode().activeElement)
    );
  }
  /** @private */
  __nextFocusableSiblingMissing(r, e) {
    return (
      // Check if focused element is the last visible DOM element
      e.indexOf(r) === e.length - 1 && // ...while there are more items available
      this.size > r.__virtualIndex + 1
    );
  }
  /** @private */
  __previousFocusableSiblingMissing(r, e) {
    return (
      // Check if focused element is the first visible DOM element
      e.indexOf(r) === 0 && // ...while there are preceding items available
      r.__virtualIndex > 0
    );
  }
  /** @private */
  __onElementFocused(r) {
    if (!this.reorderElements)
      return;
    const e = r.detail.element;
    if (!e)
      return;
    const t = this.__getVisibleElements();
    (this.__previousFocusableSiblingMissing(e, t) || this.__nextFocusableSiblingMissing(e, t)) && this.flush();
    const i = this.__getVisibleElements();
    this.__nextFocusableSiblingMissing(e, i) ? (this._scrollTop += Math.ceil(e.getBoundingClientRect().bottom) - Math.floor(this.scrollTarget.getBoundingClientRect().bottom - 1), this.flush()) : this.__previousFocusableSiblingMissing(e, i) && (this._scrollTop -= Math.ceil(this.scrollTarget.getBoundingClientRect().top + 1) - Math.floor(e.getBoundingClientRect().top), this.flush());
  }
  _scrollHandler() {
    if (this.scrollTarget.offsetHeight === 0)
      return;
    this._adjustVirtualIndexOffset(this._scrollTop - (this.__previousScrollTop || 0));
    const r = this.scrollTarget.scrollTop - this._scrollPosition;
    if (super._scrollHandler(), this._physicalCount !== 0) {
      const e = r >= 0, t = this._getReusables(!e);
      t.indexes.length && (this._physicalTop = t.physicalTop, e ? (this._virtualStart -= t.indexes.length, this._physicalStart -= t.indexes.length) : (this._virtualStart += t.indexes.length, this._physicalStart += t.indexes.length), this._resizeHandler());
    }
    r && (this.__fixInvalidItemPositioningDebouncer = Le.debounce(
      this.__fixInvalidItemPositioningDebouncer,
      Ft.after(this.timeouts.FIX_INVALID_ITEM_POSITIONING),
      () => this.__fixInvalidItemPositioning()
    )), this.reorderElements && (this.__scrollReorderDebouncer = Le.debounce(
      this.__scrollReorderDebouncer,
      Ft.after(this.timeouts.SCROLL_REORDER),
      () => this.__reorderElements()
    )), this.__previousScrollTop = this._scrollTop, this._scrollTop === 0 && this.firstVisibleIndex !== 0 && Math.abs(r) > 0 && this.scrollToIndex(0);
  }
  /**
   * Work around an iron-list issue with invalid item positioning.
   * See https://github.com/vaadin/flow-components/issues/4306
   * @private
   */
  __fixInvalidItemPositioning() {
    if (!this.scrollTarget.isConnected)
      return;
    const r = this._physicalTop > this._scrollTop, e = this._physicalBottom < this._scrollBottom, t = this.adjustedFirstVisibleIndex === 0, i = this.adjustedLastVisibleIndex === this.size - 1;
    if (r && !t || e && !i) {
      const n = e, o = this._ratio;
      this._ratio = 0, this._scrollPosition = this._scrollTop + (n ? -1 : 1), this._scrollHandler(), this._ratio = o;
    }
  }
  /** @private */
  __onWheel(r) {
    if (r.ctrlKey || this._hasScrolledAncestor(r.target, r.deltaX, r.deltaY))
      return;
    let e = r.deltaY;
    if (r.deltaMode === WheelEvent.DOM_DELTA_LINE ? e *= this._scrollLineHeight : r.deltaMode === WheelEvent.DOM_DELTA_PAGE && (e *= this._scrollPageHeight), this._deltaYAcc || (this._deltaYAcc = 0), this._wheelAnimationFrame) {
      this._deltaYAcc += e, r.preventDefault();
      return;
    }
    e += this._deltaYAcc, this._deltaYAcc = 0, this._wheelAnimationFrame = !0, this.__debouncerWheelAnimationFrame = Le.debounce(
      this.__debouncerWheelAnimationFrame,
      Jt,
      () => {
        this._wheelAnimationFrame = !1;
      }
    );
    const t = Math.abs(r.deltaX) + Math.abs(e);
    this._canScroll(this.scrollTarget, r.deltaX, e) ? (r.preventDefault(), this.scrollTarget.scrollTop += e, this.scrollTarget.scrollLeft += r.deltaX, this._hasResidualMomentum = !0, this._ignoreNewWheel = !0, this._debouncerIgnoreNewWheel = Le.debounce(
      this._debouncerIgnoreNewWheel,
      Ft.after(this.timeouts.IGNORE_WHEEL),
      () => {
        this._ignoreNewWheel = !1;
      }
    )) : this._hasResidualMomentum && t <= this._previousMomentum || this._ignoreNewWheel ? r.preventDefault() : t > this._previousMomentum && (this._hasResidualMomentum = !1), this._previousMomentum = t;
  }
  /**
   * Determines if the element has an ancestor that handles the scroll delta prior to this
   *
   * @private
   */
  _hasScrolledAncestor(r, e, t) {
    if (r === this.scrollTarget || r === this.scrollTarget.getRootNode().host)
      return !1;
    if (this._canScroll(r, e, t) && ["auto", "scroll"].indexOf(getComputedStyle(r).overflow) !== -1)
      return !0;
    if (r !== this && r.parentElement)
      return this._hasScrolledAncestor(r.parentElement, e, t);
  }
  _canScroll(r, e, t) {
    return t > 0 && r.scrollTop < r.scrollHeight - r.offsetHeight || t < 0 && r.scrollTop > 0 || e > 0 && r.scrollLeft < r.scrollWidth - r.offsetWidth || e < 0 && r.scrollLeft > 0;
  }
  /**
   * Increases the pool size.
   * @override
   */
  _increasePoolIfNeeded(r) {
    if (this._physicalCount > 2 && r) {
      const t = Math.ceil(this._optPhysicalSize / this._physicalAverage) - this._physicalCount;
      super._increasePoolIfNeeded(Math.max(r, Math.min(100, t)));
    } else
      super._increasePoolIfNeeded(r);
  }
  /**
   * An optimal physical size such that we will have enough physical items
   * to fill up the viewport and recycle when the user scrolls.
   *
   * This default value assumes that we will at least have the equivalent
   * to a viewport of physical items above and below the user's viewport.
   * @override
   */
  get _optPhysicalSize() {
    const r = super._optPhysicalSize;
    return r <= 0 || this.__hasPlaceholders() ? r : r + this.__getItemHeightBuffer();
  }
  /**
   * Extra item height buffer used when calculating optimal physical size.
   *
   * The iron list core uses the optimal physical size when determining whether to increase the item pool.
   * For the cases where some items are much larger than the average, the iron list core might not increase item pool.
   * This can lead to the large item not being rendered.
   *
   * @returns {Number} - Extra item height buffer
   * @private
   */
  __getItemHeightBuffer() {
    if (this._physicalCount === 0)
      return 0;
    const r = Math.ceil(this._viewportHeight * (this._maxPages - 1) / 2), e = Math.max(...this._physicalSizes);
    return e > Math.min(...this._physicalSizes) ? Math.max(0, e - r) : 0;
  }
  /**
   * @returns {Number|undefined} - The browser's default font-size in pixels
   * @private
   */
  _getScrollLineHeight() {
    const r = document.createElement("div");
    r.style.fontSize = "initial", r.style.display = "none", document.body.appendChild(r);
    const e = window.getComputedStyle(r).fontSize;
    return document.body.removeChild(r), e ? window.parseInt(e) : void 0;
  }
  __getVisibleElements() {
    return Array.from(this.elementsContainer.children).filter((r) => !r.hidden);
  }
  /** @private */
  __reorderElements() {
    if (this.__mouseDown) {
      this.__pendingReorder = !0;
      return;
    }
    this.__pendingReorder = !1;
    const r = this._virtualStart + (this._vidxOffset || 0), e = this.__getVisibleElements(), t = this.__getFocusedElement(e) || e[0];
    if (!t)
      return;
    const i = t.__virtualIndex - r, n = e.indexOf(t) - i;
    if (n > 0)
      for (let o = 0; o < n; o++)
        this.elementsContainer.appendChild(e[o]);
    else if (n < 0)
      for (let o = e.length + n; o < e.length; o++)
        this.elementsContainer.insertBefore(e[o], e[0]);
    if (Vc) {
      const { transform: o } = this.scrollTarget.style;
      this.scrollTarget.style.transform = "translateZ(0)", setTimeout(() => {
        this.scrollTarget.style.transform = o;
      });
    }
  }
  /** @private */
  _adjustVirtualIndexOffset(r) {
    const e = this._maxVirtualIndexOffset;
    if (this._virtualCount >= this.size)
      this._vidxOffset = 0;
    else if (this.__skipNextVirtualIndexAdjust)
      this.__skipNextVirtualIndexAdjust = !1;
    else if (Math.abs(r) > 1e4) {
      const t = this._scrollTop / (this.scrollTarget.scrollHeight - this.scrollTarget.clientHeight);
      this._vidxOffset = Math.round(t * e);
    } else {
      const t = this._vidxOffset, i = jo, n = 100;
      this._scrollTop === 0 ? (this._vidxOffset = 0, t !== this._vidxOffset && super.scrollToIndex(0)) : this.firstVisibleIndex < i && this._vidxOffset > 0 && (this._vidxOffset -= Math.min(this._vidxOffset, n), super.scrollToIndex(this.firstVisibleIndex + (t - this._vidxOffset))), this._scrollTop >= this._maxScrollTop && this._maxScrollTop > 0 ? (this._vidxOffset = e, t !== this._vidxOffset && super.scrollToIndex(this._virtualCount - 1)) : this.firstVisibleIndex > this._virtualCount - i && this._vidxOffset < e && (this._vidxOffset += Math.min(e - this._vidxOffset, n), super.scrollToIndex(this.firstVisibleIndex - (this._vidxOffset - t)));
    }
  }
}
Object.setPrototypeOf(Gc.prototype, zf);
class qc {
  /**
   * @typedef {Object} VirtualizerConfig
   * @property {Function} createElements Function that returns the given number of new elements
   * @property {Function} updateElement Function that updates the element at a specific index
   * @property {HTMLElement} scrollTarget Reference to the scrolling element
   * @property {HTMLElement} scrollContainer Reference to a wrapper for the item elements (or a slot) inside the scrollTarget
   * @property {HTMLElement | undefined} elementsContainer Reference to the container in which the item elements are placed, defaults to scrollContainer
   * @property {boolean | undefined} reorderElements Determines whether the physical item elements should be kept in order in the DOM
   * @param {VirtualizerConfig} config Configuration for the virtualizer
   */
  constructor(r) {
    this.__adapter = new Gc(r);
  }
  /**
   * Gets the index of the first visible item in the viewport.
   *
   * @return {number}
   */
  get firstVisibleIndex() {
    return this.__adapter.adjustedFirstVisibleIndex;
  }
  /**
   * Gets the index of the last visible item in the viewport.
   *
   * @return {number}
   */
  get lastVisibleIndex() {
    return this.__adapter.adjustedLastVisibleIndex;
  }
  /**
   * The size of the virtualizer
   * @return {number | undefined} The size of the virtualizer
   */
  get size() {
    return this.__adapter.size;
  }
  /**
   * The size of the virtualizer
   * @param {number} size The size of the virtualizer
   */
  set size(r) {
    this.__adapter.size = r;
  }
  /**
   * Scroll to a specific index in the virtual list
   *
   * @method scrollToIndex
   * @param {number} index The index of the item
   */
  scrollToIndex(r) {
    this.__adapter.scrollToIndex(r);
  }
  /**
   * Requests the virtualizer to re-render the item elements on an index range, if currently in the DOM
   *
   * @method update
   * @param {number | undefined} startIndex The start index of the range
   * @param {number | undefined} endIndex The end index of the range
   */
  update(r = 0, e = this.size - 1) {
    this.__adapter.update(r, e);
  }
  /**
   * Flushes active asynchronous tasks so that the component and the DOM end up in a stable state
   *
   * @method update
   * @param {number | undefined} startIndex The start index of the range
   * @param {number | undefined} endIndex The end index of the range
   */
  flush() {
    this.__adapter.flush();
  }
}
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Mf = (s) => class extends s {
  static get observers() {
    return ["_a11yUpdateGridSize(size, _columnTree)"];
  }
  /** @private */
  _a11yGetHeaderRowCount(e) {
    return e.filter(
      (t) => t.some((i) => i.headerRenderer || i.path && i.header !== null || i.header)
    ).length;
  }
  /** @private */
  _a11yGetFooterRowCount(e) {
    return e.filter((t) => t.some((i) => i.headerRenderer)).length;
  }
  /** @private */
  _a11yUpdateGridSize(e, t) {
    if (e === void 0 || t === void 0)
      return;
    const i = t[t.length - 1];
    this.$.table.setAttribute(
      "aria-rowcount",
      e + this._a11yGetHeaderRowCount(t) + this._a11yGetFooterRowCount(t)
    ), this.$.table.setAttribute("aria-colcount", i && i.length || 0), this._a11yUpdateHeaderRows(), this._a11yUpdateFooterRows();
  }
  /** @protected */
  _a11yUpdateHeaderRows() {
    dt(this.$.header, (e, t) => {
      e.setAttribute("aria-rowindex", t + 1);
    });
  }
  /** @protected */
  _a11yUpdateFooterRows() {
    dt(this.$.footer, (e, t) => {
      e.setAttribute("aria-rowindex", this._a11yGetHeaderRowCount(this._columnTree) + this.size + t + 1);
    });
  }
  /**
   * @param {!HTMLElement} row
   * @param {number} index
   * @protected
   */
  _a11yUpdateRowRowindex(e, t) {
    e.setAttribute("aria-rowindex", t + this._a11yGetHeaderRowCount(this._columnTree) + 1);
  }
  /**
   * @param {!HTMLElement} row
   * @param {boolean} selected
   * @protected
   */
  _a11yUpdateRowSelected(e, t) {
    e.setAttribute("aria-selected", !!t), Zi(e, (i) => {
      i.setAttribute("aria-selected", !!t);
    });
  }
  /**
   * @param {!HTMLElement} row
   * @protected
   */
  _a11yUpdateRowExpanded(e) {
    this.__isRowExpandable(e) ? e.setAttribute("aria-expanded", "false") : this.__isRowCollapsible(e) ? e.setAttribute("aria-expanded", "true") : e.removeAttribute("aria-expanded");
  }
  /**
   * @param {!HTMLElement} row
   * @param {number} level
   * @protected
   */
  _a11yUpdateRowLevel(e, t) {
    t > 0 || this.__isRowCollapsible(e) || this.__isRowExpandable(e) ? e.setAttribute("aria-level", t + 1) : e.removeAttribute("aria-level");
  }
  /**
   * @param {!HTMLElement} row
   * @param {!HTMLElement} detailsCell
   * @protected
   */
  _a11ySetRowDetailsCell(e, t) {
    Zi(e, (i) => {
      i !== t && i.setAttribute("aria-controls", t.id);
    });
  }
  /**
   * @param {!HTMLElement} row
   * @param {number} colspan
   * @protected
   */
  _a11yUpdateCellColspan(e, t) {
    e.setAttribute("aria-colspan", Number(t));
  }
  /** @protected */
  _a11yUpdateSorters() {
    Array.from(this.querySelectorAll("vaadin-grid-sorter")).forEach((e) => {
      let t = e.parentNode;
      for (; t && t.localName !== "vaadin-grid-cell-content"; )
        t = t.parentNode;
      t && t.assignedSlot && t.assignedSlot.parentNode.setAttribute(
        "aria-sort",
        {
          asc: "ascending",
          desc: "descending"
        }[String(e.direction)] || "none"
      );
    });
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Lf = (s) => s.offsetParent && !s.part.contains("body-cell") && Ws(s) && getComputedStyle(s).visibility !== "hidden", Bf = (s) => class extends s {
  static get properties() {
    return {
      /**
       * The item user has last interacted with. Turns to `null` after user deactivates
       * the item by re-interacting with the currently active item.
       * @type {GridItem}
       */
      activeItem: {
        type: Object,
        notify: !0,
        value: null,
        sync: !0
      }
    };
  }
  /** @protected */
  ready() {
    super.ready(), this.$.scroller.addEventListener("click", this._onClick.bind(this)), this.addEventListener("cell-activate", this._activateItem.bind(this)), this.addEventListener("row-activate", this._activateItem.bind(this));
  }
  /** @private */
  _activateItem(e) {
    const t = e.detail.model, i = t ? t.item : null;
    i && (this.activeItem = this._itemsEqual(this.activeItem, i) ? null : i);
  }
  /**
   * Checks whether the click event should not activate the cell on which it occurred.
   *
   * @protected
   */
  _shouldPreventCellActivationOnClick(e) {
    const { cell: t } = this._getGridEventLocation(e);
    return (
      // Something has handled this click already, e. g., <vaadin-grid-sorter>
      e.defaultPrevented || // No clicked cell available
      !t || // Cell is a details cell
      t.getAttribute("part").includes("details-cell") || // Cell is the empty state cell
      t === this.$.emptystatecell || // Cell content is focused
      t._content.contains(this.getRootNode().activeElement) || // Clicked on a focusable element
      this._isFocusable(e.target) || // Clicked on a label element
      e.target instanceof HTMLLabelElement
    );
  }
  /**
   * @param {!MouseEvent} e
   * @protected
   */
  _onClick(e) {
    if (this._shouldPreventCellActivationOnClick(e))
      return;
    const { cell: t } = this._getGridEventLocation(e);
    t && this.dispatchEvent(
      new CustomEvent("cell-activate", {
        detail: {
          model: this.__getRowModel(t.parentElement)
        }
      })
    );
  }
  /**
   * @param {!Element} target
   * @return {boolean}
   * @protected
   */
  _isFocusable(e) {
    return Lf(e);
  }
  /**
   * Fired when the `activeItem` property changes.
   *
   * @event active-item-changed
   */
  /**
   * Fired when the cell is activated with click or keyboard.
   *
   * @event cell-activate
   */
};
function Hi(s, r) {
  return s.split(".").reduce((e, t) => e[t], r);
}
function bl(s, r, e) {
  if (e.length === 0)
    return !1;
  let t = !0;
  return s.forEach(({ path: i }) => {
    if (!i || i.indexOf(".") === -1)
      return;
    const n = i.replace(/\.[^.]*$/u, "");
    Hi(n, e[0]) === void 0 && (console.warn(`Path "${i}" used for ${r} does not exist in all of the items, ${r} is disabled.`), t = !1);
  }), t;
}
function Wn(s) {
  return [void 0, null].indexOf(s) >= 0 ? "" : isNaN(s) ? s.toString() : s;
}
function yl(s, r) {
  return s = Wn(s), r = Wn(r), s < r ? -1 : s > r ? 1 : 0;
}
function Nf(s, r) {
  return s.sort((e, t) => r.map((i) => i.direction === "asc" ? yl(Hi(i.path, e), Hi(i.path, t)) : i.direction === "desc" ? yl(Hi(i.path, t), Hi(i.path, e)) : 0).reduce((i, n) => i !== 0 ? i : n, 0));
}
function Hf(s, r) {
  return s.filter((e) => r.every((t) => {
    const i = Wn(Hi(t.path, e)), n = Wn(t.value).toString().toLowerCase();
    return i.toString().toLowerCase().includes(n);
  }));
}
const Vf = (s) => (r, e) => {
  let t = s ? [...s] : [];
  r.filters && bl(r.filters, "filtering", t) && (t = Hf(t, r.filters)), Array.isArray(r.sortOrders) && r.sortOrders.length && bl(r.sortOrders, "sorting", t) && (t = Nf(t, r.sortOrders));
  const i = Math.min(t.length, r.pageSize), n = r.page * i, o = n + i, a = t.slice(n, o);
  e(a, t.length);
};
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Uf = (s) => class extends s {
  static get properties() {
    return {
      /**
       * An array containing the items which will be passed to renderer functions.
       *
       * @type {Array<!GridItem> | undefined}
       */
      items: {
        type: Array,
        sync: !0
      }
    };
  }
  static get observers() {
    return ["__dataProviderOrItemsChanged(dataProvider, items, isAttached, items.*)"];
  }
  /** @private */
  __setArrayDataProvider(e) {
    const t = Vf(this.items);
    t.__items = e, this._arrayDataProvider = t, this.size = e.length, this.dataProvider = t;
  }
  /**
   * @override
   * @protected
   */
  _onDataProviderPageReceived() {
    super._onDataProviderPageReceived(), this._arrayDataProvider && (this.size = this._flatSize);
  }
  /** @private */
  __dataProviderOrItemsChanged(e, t, i) {
    i && (this._arrayDataProvider ? e !== this._arrayDataProvider ? (this._arrayDataProvider = void 0, this.items = void 0) : t ? this._arrayDataProvider.__items === t ? this.clearCache() : this.__setArrayDataProvider(t) : (this._arrayDataProvider = void 0, this.dataProvider = void 0, this.size = 0, this.clearCache()) : t && this.__setArrayDataProvider(t));
  }
};
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const Wf = !1, jf = (s) => s, Gs = typeof document.head.style.touchAction == "string", xs = "__polymerGestures", Go = "__polymerGesturesHandled", Cs = "__polymerGesturesTouchAction", wl = 25, xl = 5, Gf = 2, qf = ["mousedown", "mousemove", "mouseup", "click"], Kf = [0, 1, 4, 2], Zf = function() {
  try {
    return new MouseEvent("test", { buttons: 1 }).buttons === 1;
  } catch {
    return !1;
  }
}();
function qs(s) {
  return qf.indexOf(s) > -1;
}
let Kc = !1;
(function() {
  try {
    const s = Object.defineProperty({}, "passive", {
      // eslint-disable-next-line getter-return
      get() {
        Kc = !0;
      }
    });
    window.addEventListener("test", null, s), window.removeEventListener("test", null, s);
  } catch {
  }
})();
function Yf(s) {
  if (!(qs(s) || s === "touchend") && Gs && Kc && Wf)
    return { passive: !0 };
}
const Xf = navigator.userAgent.match(/iP(?:[oa]d|hone)|Android/u), Jf = {
  button: !0,
  command: !0,
  fieldset: !0,
  input: !0,
  keygen: !0,
  optgroup: !0,
  option: !0,
  select: !0,
  textarea: !0
};
function bi(s) {
  const r = s.type;
  if (!qs(r))
    return !1;
  if (r === "mousemove") {
    let t = s.buttons === void 0 ? 1 : s.buttons;
    return s instanceof window.MouseEvent && !Zf && (t = Kf[s.which] || 0), !!(t & 1);
  }
  return (s.button === void 0 ? 0 : s.button) === 0;
}
function Qf(s) {
  if (s.type === "click") {
    if (s.detail === 0)
      return !0;
    const r = Yt(s);
    if (!r.nodeType || /** @type {Element} */
    r.nodeType !== Node.ELEMENT_NODE)
      return !0;
    const e = (
      /** @type {Element} */
      r.getBoundingClientRect()
    ), t = s.pageX, i = s.pageY;
    return !(t >= e.left && t <= e.right && i >= e.top && i <= e.bottom);
  }
  return !1;
}
const zt = {
  mouse: {
    target: null,
    mouseIgnoreJob: null
  },
  touch: {
    x: 0,
    y: 0,
    id: -1,
    scrollDecided: !1
  }
};
function $f(s) {
  let r = "auto";
  const e = Yc(s);
  for (let t = 0, i; t < e.length; t++)
    if (i = e[t], i[Cs]) {
      r = i[Cs];
      break;
    }
  return r;
}
function Zc(s, r, e) {
  s.movefn = r, s.upfn = e, document.addEventListener("mousemove", r), document.addEventListener("mouseup", e);
}
function ji(s) {
  document.removeEventListener("mousemove", s.movefn), document.removeEventListener("mouseup", s.upfn), s.movefn = null, s.upfn = null;
}
const Yc = window.ShadyDOM && window.ShadyDOM.noPatch ? window.ShadyDOM.composedPath : (s) => s.composedPath && s.composedPath() || [], Ks = {}, gi = [];
function ep(s, r) {
  let e = document.elementFromPoint(s, r), t = e;
  for (; t && t.shadowRoot && !window.ShadyDOM; ) {
    const i = t;
    if (t = t.shadowRoot.elementFromPoint(s, r), i === t)
      break;
    t && (e = t);
  }
  return e;
}
function Yt(s) {
  const r = Yc(
    /** @type {?Event} */
    s
  );
  return r.length > 0 ? r[0] : s.target;
}
function tp(s) {
  const r = s.type, t = s.currentTarget[xs];
  if (!t)
    return;
  const i = t[r];
  if (!i)
    return;
  if (!s[Go] && (s[Go] = {}, r.startsWith("touch"))) {
    const o = s.changedTouches[0];
    if (r === "touchstart" && s.touches.length === 1 && (zt.touch.id = o.identifier), zt.touch.id !== o.identifier)
      return;
    Gs || (r === "touchstart" || r === "touchmove") && ip(s);
  }
  const n = s[Go];
  if (!n.skip) {
    for (let o = 0, a; o < gi.length; o++)
      a = gi[o], i[a.name] && !n[a.name] && a.flow && a.flow.start.indexOf(s.type) > -1 && a.reset && a.reset();
    for (let o = 0, a; o < gi.length; o++)
      a = gi[o], i[a.name] && !n[a.name] && (n[a.name] = !0, a[r](s));
  }
}
function ip(s) {
  const r = s.changedTouches[0], e = s.type;
  if (e === "touchstart")
    zt.touch.x = r.clientX, zt.touch.y = r.clientY, zt.touch.scrollDecided = !1;
  else if (e === "touchmove") {
    if (zt.touch.scrollDecided)
      return;
    zt.touch.scrollDecided = !0;
    const t = $f(s);
    let i = !1;
    const n = Math.abs(zt.touch.x - r.clientX), o = Math.abs(zt.touch.y - r.clientY);
    s.cancelable && (t === "none" ? i = !0 : t === "pan-x" ? i = o > n : t === "pan-y" && (i = n > o)), i ? s.preventDefault() : jn("track");
  }
}
function Xc(s, r, e) {
  return Ks[r] ? (rp(s, r, e), !0) : !1;
}
function rp(s, r, e) {
  const t = Ks[r], i = t.deps, n = t.name;
  let o = s[xs];
  o || (s[xs] = o = {});
  for (let a = 0, l, h; a < i.length; a++)
    l = i[a], !(Xf && qs(l) && l !== "click") && (h = o[l], h || (o[l] = h = { _count: 0 }), h._count === 0 && s.addEventListener(l, tp, Yf(l)), h[n] = (h[n] || 0) + 1, h._count = (h._count || 0) + 1);
  s.addEventListener(r, e), t.touchAction && op(s, t.touchAction);
}
function Zs(s) {
  gi.push(s), s.emits.forEach((r) => {
    Ks[r] = s;
  });
}
function np(s) {
  for (let r = 0, e; r < gi.length; r++) {
    e = gi[r];
    for (let t = 0, i; t < e.emits.length; t++)
      if (i = e.emits[t], i === s)
        return e;
  }
  return null;
}
function op(s, r) {
  Gs && s instanceof HTMLElement && yt.run(() => {
    s.style.touchAction = r;
  }), s[Cs] = r;
}
function Ys(s, r, e) {
  const t = new Event(r, { bubbles: !0, cancelable: !0, composed: !0 });
  if (t.detail = e, jf(
    /** @type {!Node} */
    s
  ).dispatchEvent(t), t.defaultPrevented) {
    const i = e.preventer || e.sourceEvent;
    i && i.preventDefault && i.preventDefault();
  }
}
function jn(s) {
  const r = np(s);
  r.info && (r.info.prevent = !0);
}
Zs({
  name: "downup",
  deps: ["mousedown", "touchstart", "touchend"],
  flow: {
    start: ["mousedown", "touchstart"],
    end: ["mouseup", "touchend"]
  },
  emits: ["down", "up"],
  info: {
    movefn: null,
    upfn: null
  },
  /**
   * @this {GestureRecognizer}
   * @return {void}
   */
  reset() {
    ji(this.info);
  },
  /**
   * @this {GestureRecognizer}
   * @param {MouseEvent} e
   * @return {void}
   */
  mousedown(s) {
    if (!bi(s))
      return;
    const r = Yt(s), e = this, t = (n) => {
      bi(n) || (_r("up", r, n), ji(e.info));
    }, i = (n) => {
      bi(n) && _r("up", r, n), ji(e.info);
    };
    Zc(this.info, t, i), _r("down", r, s);
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   * @return {void}
   */
  touchstart(s) {
    _r("down", Yt(s), s.changedTouches[0], s);
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   * @return {void}
   */
  touchend(s) {
    _r("up", Yt(s), s.changedTouches[0], s);
  }
});
function _r(s, r, e, t) {
  r && Ys(r, s, {
    x: e.clientX,
    y: e.clientY,
    sourceEvent: e,
    preventer: t,
    prevent(i) {
      return jn(i);
    }
  });
}
Zs({
  name: "track",
  touchAction: "none",
  deps: ["mousedown", "touchstart", "touchmove", "touchend"],
  flow: {
    start: ["mousedown", "touchstart"],
    end: ["mouseup", "touchend"]
  },
  emits: ["track"],
  info: {
    x: 0,
    y: 0,
    state: "start",
    started: !1,
    moves: [],
    /** @this {GestureInfo} */
    addMove(s) {
      this.moves.length > Gf && this.moves.shift(), this.moves.push(s);
    },
    movefn: null,
    upfn: null,
    prevent: !1
  },
  /**
   * @this {GestureRecognizer}
   * @return {void}
   */
  reset() {
    this.info.state = "start", this.info.started = !1, this.info.moves = [], this.info.x = 0, this.info.y = 0, this.info.prevent = !1, ji(this.info);
  },
  /**
   * @this {GestureRecognizer}
   * @param {MouseEvent} e
   * @return {void}
   */
  mousedown(s) {
    if (!bi(s))
      return;
    const r = Yt(s), e = this, t = (n) => {
      const o = n.clientX, a = n.clientY;
      Cl(e.info, o, a) && (e.info.state = e.info.started ? n.type === "mouseup" ? "end" : "track" : "start", e.info.state === "start" && jn("tap"), e.info.addMove({ x: o, y: a }), bi(n) || (e.info.state = "end", ji(e.info)), r && qo(e.info, r, n), e.info.started = !0);
    }, i = (n) => {
      e.info.started && t(n), ji(e.info);
    };
    Zc(this.info, t, i), this.info.x = s.clientX, this.info.y = s.clientY;
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   * @return {void}
   */
  touchstart(s) {
    const r = s.changedTouches[0];
    this.info.x = r.clientX, this.info.y = r.clientY;
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   * @return {void}
   */
  touchmove(s) {
    const r = Yt(s), e = s.changedTouches[0], t = e.clientX, i = e.clientY;
    Cl(this.info, t, i) && (this.info.state === "start" && jn("tap"), this.info.addMove({ x: t, y: i }), qo(this.info, r, e), this.info.state = "track", this.info.started = !0);
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   * @return {void}
   */
  touchend(s) {
    const r = Yt(s), e = s.changedTouches[0];
    this.info.started && (this.info.state = "end", this.info.addMove({ x: e.clientX, y: e.clientY }), qo(this.info, r, e));
  }
});
function Cl(s, r, e) {
  if (s.prevent)
    return !1;
  if (s.started)
    return !0;
  const t = Math.abs(s.x - r), i = Math.abs(s.y - e);
  return t >= xl || i >= xl;
}
function qo(s, r, e) {
  if (!r)
    return;
  const t = s.moves[s.moves.length - 2], i = s.moves[s.moves.length - 1], n = i.x - s.x, o = i.y - s.y;
  let a, l = 0;
  t && (a = i.x - t.x, l = i.y - t.y), Ys(r, "track", {
    state: s.state,
    x: e.clientX,
    y: e.clientY,
    dx: n,
    dy: o,
    ddx: a,
    ddy: l,
    sourceEvent: e,
    hover() {
      return ep(e.clientX, e.clientY);
    }
  });
}
Zs({
  name: "tap",
  deps: ["mousedown", "click", "touchstart", "touchend"],
  flow: {
    start: ["mousedown", "touchstart"],
    end: ["click", "touchend"]
  },
  emits: ["tap"],
  info: {
    x: NaN,
    y: NaN,
    prevent: !1
  },
  /**
   * @this {GestureRecognizer}
   * @return {void}
   */
  reset() {
    this.info.x = NaN, this.info.y = NaN, this.info.prevent = !1;
  },
  /**
   * @this {GestureRecognizer}
   * @param {MouseEvent} e
   * @return {void}
   */
  mousedown(s) {
    bi(s) && (this.info.x = s.clientX, this.info.y = s.clientY);
  },
  /**
   * @this {GestureRecognizer}
   * @param {MouseEvent} e
   * @return {void}
   */
  click(s) {
    bi(s) && Tl(this.info, s);
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   * @return {void}
   */
  touchstart(s) {
    const r = s.changedTouches[0];
    this.info.x = r.clientX, this.info.y = r.clientY;
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   * @return {void}
   */
  touchend(s) {
    Tl(this.info, s.changedTouches[0], s);
  }
});
function Tl(s, r, e) {
  const t = Math.abs(r.clientX - s.x), i = Math.abs(r.clientY - s.y), n = Yt(e || r);
  !n || Jf[
    /** @type {!HTMLElement} */
    n.localName
  ] && n.hasAttribute("disabled") || (isNaN(t) || isNaN(i) || t <= wl && i <= wl || Qf(r)) && (s.prevent || Ys(n, "tap", {
    x: r.clientX,
    y: r.clientY,
    sourceEvent: r,
    preventer: e
  }));
}
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const sp = (s) => class extends s {
  static get properties() {
    return {
      /**
       * Set to true to allow column reordering.
       * @attr {boolean} column-reordering-allowed
       * @type {boolean}
       */
      columnReorderingAllowed: {
        type: Boolean,
        value: !1
      },
      /** @private */
      _orderBaseScope: {
        type: Number,
        value: 1e7
      }
    };
  }
  static get observers() {
    return ["_updateOrders(_columnTree)"];
  }
  /** @protected */
  ready() {
    super.ready(), Xc(this, "track", this._onTrackEvent), this._reorderGhost = this.shadowRoot.querySelector('[part="reorder-ghost"]'), this.addEventListener("touchstart", this._onTouchStart.bind(this)), this.addEventListener("touchmove", this._onTouchMove.bind(this)), this.addEventListener("touchend", this._onTouchEnd.bind(this)), this.addEventListener("contextmenu", this._onContextMenu.bind(this));
  }
  /** @private */
  _onContextMenu(e) {
    this.hasAttribute("reordering") && (e.preventDefault(), Mr || this._onTrackEnd());
  }
  /** @private */
  _onTouchStart(e) {
    this._startTouchReorderTimeout = setTimeout(() => {
      this._onTrackStart({
        detail: {
          x: e.touches[0].clientX,
          y: e.touches[0].clientY
        }
      });
    }, 100);
  }
  /** @private */
  _onTouchMove(e) {
    this._draggedColumn && e.preventDefault(), clearTimeout(this._startTouchReorderTimeout);
  }
  /** @private */
  _onTouchEnd() {
    clearTimeout(this._startTouchReorderTimeout), this._onTrackEnd();
  }
  /** @private */
  _onTrackEvent(e) {
    if (e.detail.state === "start") {
      const t = e.composedPath(), i = t[t.indexOf(this.$.header) - 2];
      if (!i || !i._content || i._content.contains(this.getRootNode().activeElement) || this.$.scroller.hasAttribute("column-resizing"))
        return;
      this._touchDevice || this._onTrackStart(e);
    } else e.detail.state === "track" ? this._onTrack(e) : e.detail.state === "end" && this._onTrackEnd(e);
  }
  /** @private */
  _onTrackStart(e) {
    if (!this.columnReorderingAllowed)
      return;
    const t = e.composedPath && e.composedPath();
    if (t && t.some((n) => n.hasAttribute && n.hasAttribute("draggable")))
      return;
    const i = this._cellFromPoint(e.detail.x, e.detail.y);
    if (!(!i || !i.getAttribute("part").includes("header-cell"))) {
      for (this.toggleAttribute("reordering", !0), this._draggedColumn = i._column; this._draggedColumn.parentElement.childElementCount === 1; )
        this._draggedColumn = this._draggedColumn.parentElement;
      this._setSiblingsReorderStatus(this._draggedColumn, "allowed"), this._draggedColumn._reorderStatus = "dragging", this._updateGhost(i), this._reorderGhost.style.visibility = "visible", this._updateGhostPosition(e.detail.x, this._touchDevice ? e.detail.y - 50 : e.detail.y), this._autoScroller();
    }
  }
  /** @private */
  _onTrack(e) {
    if (!this._draggedColumn)
      return;
    const t = this._cellFromPoint(e.detail.x, e.detail.y);
    if (!t)
      return;
    const i = this._getTargetColumn(t, this._draggedColumn);
    if (this._isSwapAllowed(this._draggedColumn, i) && this._isSwappableByPosition(i, e.detail.x)) {
      const n = this._columnTree.findIndex((d) => d.includes(i)), o = this._getColumnsInOrder(n), a = o.indexOf(this._draggedColumn), l = o.indexOf(i), h = a < l ? 1 : -1;
      for (let d = a; d !== l; d += h)
        this._swapColumnOrders(this._draggedColumn, o[d + h]);
    }
    this._updateGhostPosition(e.detail.x, this._touchDevice ? e.detail.y - 50 : e.detail.y), this._lastDragClientX = e.detail.x;
  }
  /** @private */
  _onTrackEnd() {
    this._draggedColumn && (this.toggleAttribute("reordering", !1), this._draggedColumn._reorderStatus = "", this._setSiblingsReorderStatus(this._draggedColumn, ""), this._draggedColumn = null, this._lastDragClientX = null, this._reorderGhost.style.visibility = "hidden", this.dispatchEvent(
      new CustomEvent("column-reorder", {
        detail: {
          columns: this._getColumnsInOrder()
        }
      })
    ));
  }
  /**
   * Returns the columns (or column groups) on the specified header level in visual order.
   * By default, the bottom level is used.
   *
   * @return {!Array<!GridColumn>}
   * @protected
   */
  _getColumnsInOrder(e = this._columnTree.length - 1) {
    return this._columnTree[e].filter((t) => !t.hidden).sort((t, i) => t._order - i._order);
  }
  /**
   * @param {number} x
   * @param {number} y
   * @return {HTMLElement | undefined}
   * @protected
   */
  _cellFromPoint(e = 0, t = 0) {
    this._draggedColumn || this.$.scroller.toggleAttribute("no-content-pointer-events", !0);
    const i = this.shadowRoot.elementFromPoint(e, t);
    return this.$.scroller.toggleAttribute("no-content-pointer-events", !1), this._getCellFromElement(i);
  }
  /** @private */
  _getCellFromElement(e) {
    if (e) {
      if (e._column)
        return e;
      const { parentElement: t } = e;
      if (t && t._focusButton === e)
        return t;
    }
    return null;
  }
  /**
   * @param {number} eventClientX
   * @param {number} eventClientY
   * @protected
   */
  _updateGhostPosition(e, t) {
    const i = this._reorderGhost.getBoundingClientRect(), n = e - i.width / 2, o = t - i.height / 2, a = parseInt(this._reorderGhost._left || 0), l = parseInt(this._reorderGhost._top || 0);
    this._reorderGhost._left = a - (i.left - n), this._reorderGhost._top = l - (i.top - o), this._reorderGhost.style.transform = `translate(${this._reorderGhost._left}px, ${this._reorderGhost._top}px)`;
  }
  /**
   * @param {!HTMLElement} cell
   * @return {!HTMLElement}
   * @protected
   */
  _updateGhost(e) {
    const t = this._reorderGhost;
    t.textContent = e._content.innerText;
    const i = window.getComputedStyle(e);
    return [
      "boxSizing",
      "display",
      "width",
      "height",
      "background",
      "alignItems",
      "padding",
      "border",
      "flex-direction",
      "overflow"
    ].forEach((n) => {
      t.style[n] = i[n];
    }), t;
  }
  /** @private */
  _updateOrders(e) {
    e !== void 0 && (e[0].forEach((t) => {
      t._order = 0;
    }), df(e[0], this._orderBaseScope, 0));
  }
  /**
   * @param {!GridColumn} column
   * @param {string} status
   * @protected
   */
  _setSiblingsReorderStatus(e, t) {
    dt(e.parentNode, (i) => {
      /column/u.test(i.localName) && this._isSwapAllowed(i, e) && (i._reorderStatus = t);
    });
  }
  /** @protected */
  _autoScroller() {
    if (this._lastDragClientX) {
      const e = this._lastDragClientX - this.getBoundingClientRect().right + 50, t = this.getBoundingClientRect().left - this._lastDragClientX + 50;
      e > 0 ? this.$.table.scrollLeft += e / 10 : t > 0 && (this.$.table.scrollLeft -= t / 10);
    }
    this._draggedColumn && setTimeout(() => this._autoScroller(), 10);
  }
  /**
   * @param {GridColumn | undefined} column1
   * @param {GridColumn | undefined} column2
   * @return {boolean | undefined}
   * @protected
   */
  _isSwapAllowed(e, t) {
    if (e && t) {
      const i = e !== t, n = e.parentElement === t.parentElement, o = e.frozen && t.frozen || // Both columns are frozen
      e.frozenToEnd && t.frozenToEnd || // Both columns are frozen to end
      !e.frozen && !e.frozenToEnd && !t.frozen && !t.frozenToEnd;
      return i && n && o;
    }
  }
  /**
   * @param {!GridColumn} targetColumn
   * @param {number} clientX
   * @return {boolean}
   * @protected
   */
  _isSwappableByPosition(e, t) {
    const i = Array.from(this.$.header.querySelectorAll('tr:not([hidden]) [part~="cell"]')).find(
      (a) => e.contains(a._column)
    ), n = this.$.header.querySelector("tr:not([hidden]) [reorder-status=dragging]").getBoundingClientRect(), o = i.getBoundingClientRect();
    return o.left > n.left ? t > o.right - n.width : t < o.left + n.width;
  }
  /**
   * @param {!GridColumn} column1
   * @param {!GridColumn} column2
   * @protected
   */
  _swapColumnOrders(e, t) {
    [e._order, t._order] = [t._order, e._order], this._debounceUpdateFrozenColumn(), this._updateFirstAndLastColumn();
  }
  /**
   * @param {HTMLElement | undefined} targetCell
   * @param {GridColumn} draggedColumn
   * @return {GridColumn | undefined}
   * @protected
   */
  _getTargetColumn(e, t) {
    if (e && t) {
      let i = e._column;
      for (; i.parentElement !== t.parentElement && i !== this; )
        i = i.parentElement;
      return i.parentElement === t.parentElement ? i : e._column;
    }
  }
  /**
   * Fired when the columns in the grid are reordered.
   *
   * @event column-reorder
   * @param {Object} detail
   * @param {Object} detail.columns the columns in the new order
   */
};
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const ap = (s) => class extends s {
  /** @protected */
  ready() {
    super.ready();
    const e = this.$.scroller;
    Xc(e, "track", this._onHeaderTrack.bind(this)), e.addEventListener("touchmove", (t) => e.hasAttribute("column-resizing") && t.preventDefault()), e.addEventListener(
      "contextmenu",
      (t) => t.target.getAttribute("part") === "resize-handle" && t.preventDefault()
    ), e.addEventListener(
      "mousedown",
      (t) => t.target.getAttribute("part") === "resize-handle" && t.preventDefault()
    );
  }
  /** @private */
  _onHeaderTrack(e) {
    const t = e.target;
    if (t.getAttribute("part") === "resize-handle") {
      let n = t.parentElement._column;
      for (this.$.scroller.toggleAttribute("column-resizing", !0); n.localName === "vaadin-grid-column-group"; )
        n = n._childColumns.slice(0).sort((f, g) => f._order - g._order).filter((f) => !f.hidden).pop();
      const o = this.__isRTL, a = e.detail.x, l = Array.from(this.$.header.querySelectorAll('[part~="row"]:last-child [part~="cell"]')), h = l.find((f) => f._column === n);
      if (h.offsetWidth) {
        const f = getComputedStyle(h._content), g = 10 + parseInt(f.paddingLeft) + parseInt(f.paddingRight) + parseInt(f.borderLeftWidth) + parseInt(f.borderRightWidth) + parseInt(f.marginLeft) + parseInt(f.marginRight);
        let w;
        const C = h.offsetWidth, E = h.getBoundingClientRect();
        h.hasAttribute("frozen-to-end") ? w = C + (o ? a - E.right : E.left - a) : w = C + (o ? E.left - a : a - E.right), n.width = `${Math.max(g, w)}px`, n.flexGrow = 0;
      }
      l.sort((f, g) => f._column._order - g._column._order).forEach((f, g, w) => {
        g < w.indexOf(h) && (f._column.width = `${f.offsetWidth}px`, f._column.flexGrow = 0);
      });
      const d = this._frozenToEndCells[0];
      if (d && this.$.table.scrollWidth > this.$.table.offsetWidth) {
        const f = d.getBoundingClientRect(), g = a - (o ? f.right : f.left);
        (o && g <= 0 || !o && g >= 0) && (this.$.table.scrollLeft += g);
      }
      e.detail.state === "end" && (this.$.scroller.toggleAttribute("column-resizing", !1), this.dispatchEvent(
        new CustomEvent("column-resize", {
          detail: { resizedColumn: n }
        })
      )), this._resizeHandler();
    }
  }
  /**
   * Fired when a column in the grid is resized by the user.
   *
   * @event column-resize
   * @param {Object} detail
   * @param {Object} detail.resizedColumn the column that was resized
   */
};
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function Gn(s, r, e = 0) {
  let t = r;
  for (const i of s.subCaches) {
    const n = i.parentCacheIndex;
    if (t <= n)
      break;
    if (t <= n + i.flatSize)
      return Gn(i, t - n - 1, e + 1);
    t -= i.flatSize;
  }
  return {
    cache: s,
    item: s.items[t],
    index: t,
    page: Math.floor(t / s.pageSize),
    level: e
  };
}
function Jc({ getItemId: s }, r, e, t = 0, i = 0) {
  for (let n = 0; n < r.items.length; n++) {
    const o = r.items[n];
    if (o && s(o) === s(e))
      return {
        cache: r,
        level: t,
        item: o,
        index: n,
        page: Math.floor(n / r.pageSize),
        subCache: r.getSubCache(n),
        flatIndex: i + r.getFlatIndex(n)
      };
  }
  for (const n of r.subCaches) {
    const o = i + r.getFlatIndex(n.parentCacheIndex), a = Jc({ getItemId: s }, n, e, t + 1, o + 1);
    if (a)
      return a;
  }
}
function Qc(s, [r, ...e], t = 0) {
  r === 1 / 0 && (r = s.size - 1);
  const i = s.getFlatIndex(r), n = s.getSubCache(r);
  return n && n.flatSize > 0 && e.length ? Qc(n, e, t + i + 1) : t + i;
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class Xs {
  /**
   * @param {Cache['context']} context
   * @param {number} pageSize
   * @param {number | undefined} size
   * @param {Cache | undefined} parentCache
   * @param {number | undefined} parentCacheIndex
   */
  constructor(r, e, t, i, n) {
    /**
     * A context object.
     *
     * @type {{ isExpanded: (item: unknown) => boolean }}
     */
    tt(this, "context");
    /**
     * The number of items to display per page.
     *
     * @type {number}
     */
    tt(this, "pageSize");
    /**
     * An array of cached items.
     *
     * @type {object[]}
     */
    tt(this, "items", []);
    /**
     * A map where the key is a requested page and the value is a callback
     * that will be called with data once the request is complete.
     *
     * @type {Record<number, Function>}
     */
    tt(this, "pendingRequests", {});
    /**
     * A map where the key is the index of an item in the `items` array
     * and the value is a sub-cache associated with that item.
     *
     * Note, it's intentionally defined as an object instead of a Map
     * to ensure that Object.entries() returns an array with keys sorted
     * in alphabetical order, rather than the order they were added.
     *
     * @type {Record<number, Cache>}
     * @private
     */
    tt(this, "__subCacheByIndex", {});
    /**
     * The number of items.
     *
     * @type {number}
     * @private
     */
    tt(this, "__size", 0);
    /**
     * The total number of items, including items from expanded sub-caches.
     *
     * @type {number}
     * @private
     */
    tt(this, "__flatSize", 0);
    this.context = r, this.pageSize = e, this.size = t, this.parentCache = i, this.parentCacheIndex = n, this.__flatSize = t || 0;
  }
  /**
   * An item in the parent cache that the current cache is associated with.
   *
   * @return {object | undefined}
   */
  get parentItem() {
    return this.parentCache && this.parentCache.items[this.parentCacheIndex];
  }
  /**
   * An array of sub-caches sorted in the same order as their associated items
   * appear in the `items` array.
   *
   * @return {Cache[]}
   */
  get subCaches() {
    return Object.values(this.__subCacheByIndex);
  }
  /**
   * Whether the cache or any of its descendant caches have pending requests.
   *
   * @return {boolean}
   */
  get isLoading() {
    return Object.keys(this.pendingRequests).length > 0 ? !0 : this.subCaches.some((r) => r.isLoading);
  }
  /**
   * The total number of items, including items from expanded sub-caches.
   *
   * @return {number}
   */
  get flatSize() {
    return this.__flatSize;
  }
  /**
   * The total number of items, including items from expanded sub-caches.
   *
   * @protected
   * @deprecated since 24.3 and will be removed in Vaadin 25.
   */
  get effectiveSize() {
    return console.warn(
      "<vaadin-grid> The `effectiveSize` property of ItemCache is deprecated and will be removed in Vaadin 25."
    ), this.flatSize;
  }
  /**
   * The number of items.
   *
   * @return {number}
   */
  get size() {
    return this.__size;
  }
  /**
   * Sets the number of items.
   *
   * @param {number} size
   */
  set size(r) {
    var t;
    if (this.__size !== r) {
      if (this.__size = r, this.context.placeholder !== void 0) {
        this.items.length = r || 0;
        for (let i = 0; i < r; i++)
          (t = this.items)[i] || (t[i] = this.context.placeholder);
      }
      Object.keys(this.pendingRequests).forEach((i) => {
        parseInt(i) * this.pageSize >= this.size && delete this.pendingRequests[i];
      });
    }
  }
  /**
   * Recalculates the flattened size for the cache and its descendant caches recursively.
   */
  recalculateFlatSize() {
    this.__flatSize = !this.parentItem || this.context.isExpanded(this.parentItem) ? this.size + this.subCaches.reduce((r, e) => (e.recalculateFlatSize(), r + e.flatSize), 0) : 0;
  }
  /**
   * Adds an array of items corresponding to the given page
   * to the `items` array.
   *
   * @param {number} page
   * @param {object[]} items
   */
  setPage(r, e) {
    const t = r * this.pageSize;
    e.forEach((i, n) => {
      const o = t + n;
      (this.size === void 0 || o < this.size) && (this.items[o] = i);
    });
  }
  /**
   * Retrieves the sub-cache associated with the item at the given index
   * in the `items` array.
   *
   * @param {number} index
   * @return {Cache | undefined}
   */
  getSubCache(r) {
    return this.__subCacheByIndex[r];
  }
  /**
   * Removes the sub-cache associated with the item at the given index
   * in the `items` array.
   *
   * @param {number} index
   */
  removeSubCache(r) {
    delete this.__subCacheByIndex[r];
  }
  /**
   * Removes all sub-caches.
   */
  removeSubCaches() {
    this.__subCacheByIndex = {};
  }
  /**
   * Creates and associates a sub-cache for the item at the given index
   * in the `items` array.
   *
   * @param {number} index
   * @return {Cache}
   */
  createSubCache(r) {
    const e = new Xs(this.context, this.pageSize, 0, this, r);
    return this.__subCacheByIndex[r] = e, e;
  }
  /**
   * Retrieves the flattened index corresponding to the given index
   * of an item in the `items` array.
   *
   * @param {number} index
   * @return {number}
   */
  getFlatIndex(r) {
    const e = Math.max(0, Math.min(this.size - 1, r));
    return this.subCaches.reduce((t, i) => {
      const n = i.parentCacheIndex;
      return e > n ? t + i.flatSize : t;
    }, e);
  }
  /**
   * @deprecated since 24.3 and will be removed in Vaadin 25.
   */
  getItemForIndex(r) {
    console.warn(
      "<vaadin-grid> The `getItemForIndex` method of ItemCache is deprecated and will be removed in Vaadin 25."
    );
    const { item: e } = Gn(this, r);
    return e;
  }
  /**
   * @deprecated since 24.3 and will be removed in Vaadin 25.
   */
  getCacheAndIndex(r) {
    console.warn(
      "<vaadin-grid> The `getCacheAndIndex` method of ItemCache is deprecated and will be removed in Vaadin 25."
    );
    const { cache: e, index: t } = Gn(this, r);
    return { cache: e, scaledIndex: t };
  }
  /**
   * @deprecated since 24.3 and will be removed in Vaadin 25.
   */
  updateSize() {
    console.warn("<vaadin-grid> The `updateSize` method of ItemCache is deprecated and will be removed in Vaadin 25."), this.recalculateFlatSize();
  }
  /**
   * @deprecated since 24.3 and will be removed in Vaadin 25.
   */
  ensureSubCacheForScaledIndex(r) {
    if (console.warn(
      "<vaadin-grid> The `ensureSubCacheForScaledIndex` method of ItemCache is deprecated and will be removed in Vaadin 25."
    ), !this.getSubCache(r)) {
      const e = this.createSubCache(r);
      this.context.__controller.__loadCachePage(e, 0);
    }
  }
  /**
   * @deprecated since 24.3 and will be removed in Vaadin 25.
   */
  get grid() {
    return console.warn("<vaadin-grid> The `grid` property of ItemCache is deprecated and will be removed in Vaadin 25."), this.context.__controller.host;
  }
  /**
   * @deprecated since 24.3 and will be removed in Vaadin 25.
   */
  get itemCaches() {
    return console.warn(
      "<vaadin-grid> The `itemCaches` property of ItemCache is deprecated and will be removed in Vaadin 25."
    ), this.__subCacheByIndex;
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class $c extends EventTarget {
  constructor(e, { size: t, pageSize: i, isExpanded: n, getItemId: o, isPlaceholder: a, placeholder: l, dataProvider: h, dataProviderParams: d }) {
    super();
    /**
     * The controller host element.
     *
     * @param {HTMLElement}
     */
    tt(this, "host");
    /**
     * A callback that returns data based on the passed params such as
     * `page`, `pageSize`, `parentItem`, etc.
     */
    tt(this, "dataProvider");
    /**
     * A callback that returns additional params that need to be passed
     * to the data provider callback with every request.
     */
    tt(this, "dataProviderParams");
    /**
     * A number of items to display per page.
     *
     * @type {number}
     */
    tt(this, "pageSize");
    /**
     * A callback that returns whether the given item is expanded.
     *
     * @type {(item: unknown) => boolean}
     */
    tt(this, "isExpanded");
    /**
     * A callback that returns the id for the given item and that
     * is used when checking object items for equality.
     *
     * @type { (item: unknown) => unknown}
     */
    tt(this, "getItemId");
    /**
     * A reference to the root cache instance.
     *
     * @param {Cache}
     */
    tt(this, "rootCache");
    /**
     * A placeholder item that is used to indicate that the item is not loaded yet.
     *
     * @type {unknown}
     */
    tt(this, "placeholder");
    /**
     * A callback that returns whether the given item is a placeholder.
     *
     * @type {(item: unknown) => boolean}
     */
    tt(this, "isPlaceholder");
    this.host = e, this.pageSize = i, this.getItemId = o, this.isExpanded = n, this.placeholder = l, this.isPlaceholder = a, this.dataProvider = h, this.dataProviderParams = d, this.rootCache = this.__createRootCache(t);
  }
  /**
   * The total number of items, including items from expanded sub-caches.
   */
  get flatSize() {
    return this.rootCache.flatSize;
  }
  /** @private */
  get __cacheContext() {
    return {
      isExpanded: this.isExpanded,
      placeholder: this.placeholder,
      // The controller instance is needed to ensure deprecated cache methods work.
      __controller: this
    };
  }
  /**
   * Whether the root cache or any of its decendant caches have pending requests.
   *
   * @return {boolean}
   */
  isLoading() {
    return this.rootCache.isLoading;
  }
  /**
   * Sets the page size and clears the cache.
   *
   * @param {number} pageSize
   */
  setPageSize(e) {
    this.pageSize = e, this.clearCache();
  }
  /**
   * Sets the data provider callback and clears the cache.
   *
   * @type {Function}
   */
  setDataProvider(e) {
    this.dataProvider = e, this.clearCache();
  }
  /**
   * Recalculates the flattened size.
   */
  recalculateFlatSize() {
    this.rootCache.recalculateFlatSize();
  }
  /**
   * Clears the cache.
   */
  clearCache() {
    this.rootCache = this.__createRootCache(this.rootCache.size);
  }
  /**
   * Returns context for the given flattened index, including:
   * - the corresponding cache
   * - the cache level
   * - the corresponding item (if loaded)
   * - the item's index in the cache's items array
   * - the page containing the item
   *
   * @param {number} flatIndex
   */
  getFlatIndexContext(e) {
    return Gn(this.rootCache, e);
  }
  /**
   * Returns context for the given item, including:
   * - the cache containing the item
   * - the cache level
   * - the item
   * - the item's index in the cache's items array
   * - the item's flattened index
   * - the item's sub-cache (if exists)
   * - the page containing the item
   *
   * If the item isn't found, the method returns undefined.
   */
  getItemContext(e) {
    return Jc({ getItemId: this.getItemId }, this.rootCache, e);
  }
  /**
   * Returns the flattened index for the item that the given indexes point to.
   * Each index in the path array points to a sub-item of the previous index.
   * Using `Infinity` as an index will point to the last item on the level.
   *
   * @param {number[]} path
   * @return {number}
   */
  getFlatIndexByPath(e) {
    return Qc(this.rootCache, e);
  }
  /**
   * Requests the data provider to load the page with the item corresponding
   * to the given flattened index. If the item is already loaded, the method
   * returns immediatelly.
   *
   * @param {number} flatIndex
   */
  ensureFlatIndexLoaded(e) {
    const { cache: t, page: i, item: n } = this.getFlatIndexContext(e);
    this.__isItemLoaded(n) || this.__loadCachePage(t, i);
  }
  /**
   * Creates a sub-cache for the item corresponding to the given flattened index and
   * requests the data provider to load the first page into the created sub-cache.
   * If the sub-cache already exists, the method returns immediatelly.
   *
   * @param {number} flatIndex
   */
  ensureFlatIndexHierarchy(e) {
    const { cache: t, item: i, index: n } = this.getFlatIndexContext(e);
    if (this.__isItemLoaded(i) && this.isExpanded(i) && !t.getSubCache(n)) {
      const o = t.createSubCache(n);
      this.__loadCachePage(o, 0);
    }
  }
  /**
   * Loads the first page into the root cache.
   */
  loadFirstPage() {
    this.__loadCachePage(this.rootCache, 0);
  }
  /** @private */
  __createRootCache(e) {
    return new Xs(this.__cacheContext, this.pageSize, e);
  }
  /** @private */
  __loadCachePage(e, t) {
    if (!this.dataProvider || e.pendingRequests[t])
      return;
    let i = {
      page: t,
      pageSize: this.pageSize,
      parentItem: e.parentItem
    };
    this.dataProviderParams && (i = { ...i, ...this.dataProviderParams() });
    const n = (o, a) => {
      e.pendingRequests[t] === n && (a !== void 0 ? e.size = a : i.parentItem && (e.size = o.length), e.setPage(t, o), this.recalculateFlatSize(), this.dispatchEvent(new CustomEvent("page-received")), delete e.pendingRequests[t], this.dispatchEvent(new CustomEvent("page-loaded")));
    };
    e.pendingRequests[t] = n, this.dispatchEvent(new CustomEvent("page-requested")), this.dataProvider(i, n);
  }
  /** @private */
  __isItemLoaded(e) {
    return this.isPlaceholder ? !this.isPlaceholder(e) : this.placeholder ? e !== this.placeholder : !!e;
  }
}
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const lp = (s) => class extends s {
  static get properties() {
    return {
      /**
       * The number of root-level items in the grid.
       * @attr {number} size
       * @type {number}
       */
      size: {
        type: Number,
        notify: !0,
        sync: !0
      },
      /**
       * @type {number}
       * @protected
       */
      _flatSize: {
        type: Number,
        sync: !0
      },
      /**
       * Number of items fetched at a time from the dataprovider.
       * @attr {number} page-size
       * @type {number}
       */
      pageSize: {
        type: Number,
        value: 50,
        observer: "_pageSizeChanged",
        sync: !0
      },
      /**
       * Function that provides items lazily. Receives arguments `params`, `callback`
       *
       * `params.page` Requested page index
       *
       * `params.pageSize` Current page size
       *
       * `params.filters` Currently applied filters
       *
       * `params.sortOrders` Currently applied sorting orders
       *
       * `params.parentItem` When tree is used, and sublevel items
       * are requested, reference to parent item of the requested sublevel.
       * Otherwise `undefined`.
       *
       * `callback(items, size)` Callback function with arguments:
       *   - `items` Current page of items
       *   - `size` Total number of items. When tree sublevel items
       *     are requested, total number of items in the requested sublevel.
       *     Optional when tree is not used, required for tree.
       *
       * @type {GridDataProvider | null | undefined}
       */
      dataProvider: {
        type: Object,
        notify: !0,
        observer: "_dataProviderChanged",
        sync: !0
      },
      /**
       * `true` while data is being requested from the data provider.
       */
      loading: {
        type: Boolean,
        notify: !0,
        readOnly: !0,
        reflectToAttribute: !0
      },
      /**
       * @protected
       */
      _hasData: {
        type: Boolean,
        value: !1,
        sync: !0
      },
      /**
       * Path to an item sub-property that indicates whether the item has child items.
       * @attr {string} item-has-children-path
       */
      itemHasChildrenPath: {
        type: String,
        value: "children",
        observer: "__itemHasChildrenPathChanged",
        sync: !0
      },
      /**
       * Path to an item sub-property that identifies the item.
       * @attr {string} item-id-path
       */
      itemIdPath: {
        type: String,
        value: null,
        sync: !0
      },
      /**
       * An array that contains the expanded items.
       * @type {!Array<!GridItem>}
       */
      expandedItems: {
        type: Object,
        notify: !0,
        value: () => [],
        sync: !0
      },
      /**
       * @private
       */
      __expandedKeys: {
        type: Object,
        computed: "__computeExpandedKeys(itemIdPath, expandedItems)"
      }
    };
  }
  static get observers() {
    return ["_sizeChanged(size)", "_expandedItemsChanged(expandedItems)"];
  }
  constructor() {
    super(), this._dataProviderController = new $c(this, {
      size: this.size || 0,
      pageSize: this.pageSize,
      getItemId: this.getItemId.bind(this),
      isExpanded: this._isExpanded.bind(this),
      dataProvider: this.dataProvider ? this.dataProvider.bind(this) : null,
      dataProviderParams: () => ({
        sortOrders: this._mapSorters(),
        filters: this._mapFilters()
      })
    }), this._dataProviderController.addEventListener("page-requested", this._onDataProviderPageRequested.bind(this)), this._dataProviderController.addEventListener("page-received", this._onDataProviderPageReceived.bind(this)), this._dataProviderController.addEventListener("page-loaded", this._onDataProviderPageLoaded.bind(this));
  }
  /**
   * @protected
   * @deprecated since 24.3 and will be removed in Vaadin 25.
   */
  get _cache() {
    return console.warn("<vaadin-grid> The `_cache` property is deprecated and will be removed in Vaadin 25."), this._dataProviderController.rootCache;
  }
  /**
   * @protected
   * @deprecated since 24.3 and will be removed in Vaadin 25.
   */
  get _effectiveSize() {
    return console.warn("<vaadin-grid> The `_effectiveSize` property is deprecated and will be removed in Vaadin 25."), this._flatSize;
  }
  /** @private */
  _sizeChanged(e) {
    this._dataProviderController.rootCache.size = e, this._dataProviderController.recalculateFlatSize(), this._flatSize = this._dataProviderController.flatSize;
  }
  /** @private */
  __itemHasChildrenPathChanged(e, t) {
    !t && e === "children" || this.requestContentUpdate();
  }
  /**
   * @param {number} index
   * @param {HTMLElement} el
   * @protected
   */
  _getItem(e, t) {
    t.index = e;
    const { item: i } = this._dataProviderController.getFlatIndexContext(e);
    i ? (this.__updateLoading(t, !1), this._updateItem(t, i), this._isExpanded(i) && this._dataProviderController.ensureFlatIndexHierarchy(e)) : (this.__updateLoading(t, !0), this._dataProviderController.ensureFlatIndexLoaded(e));
  }
  /**
   * @param {!HTMLElement} row
   * @param {boolean} loading
   * @private
   */
  __updateLoading(e, t) {
    const i = Ki(e);
    $n(e, "loading", t), Kt(i, "loading-row-cell", t), t && (this._generateCellClassNames(e), this._generateCellPartNames(e));
  }
  /**
   * Returns a value that identifies the item. Uses `itemIdPath` if available.
   * Can be customized by overriding.
   * @param {!GridItem} item
   * @return {!GridItem | !unknown}
   */
  getItemId(e) {
    return this.itemIdPath ? Ci(this.itemIdPath, e) : e;
  }
  /**
   * @param {!GridItem} item
   * @return {boolean}
   * @protected
   */
  _isExpanded(e) {
    return this.__expandedKeys && this.__expandedKeys.has(this.getItemId(e));
  }
  /** @private */
  _expandedItemsChanged() {
    this._dataProviderController.recalculateFlatSize(), this._flatSize = this._dataProviderController.flatSize, this.__updateVisibleRows();
  }
  /** @private */
  __computeExpandedKeys(e, t) {
    const i = t || [], n = /* @__PURE__ */ new Set();
    return i.forEach((o) => {
      n.add(this.getItemId(o));
    }), n;
  }
  /**
   * Expands the given item tree.
   * @param {!GridItem} item
   */
  expandItem(e) {
    this._isExpanded(e) || (this.expandedItems = [...this.expandedItems, e]);
  }
  /**
   * Collapses the given item tree.
   * @param {!GridItem} item
   */
  collapseItem(e) {
    this._isExpanded(e) && (this.expandedItems = this.expandedItems.filter((t) => !this._itemsEqual(t, e)));
  }
  /**
   * @param {number} index
   * @return {number}
   * @protected
   */
  _getIndexLevel(e = 0) {
    const { level: t } = this._dataProviderController.getFlatIndexContext(e);
    return t;
  }
  /**
   * @param {number} page
   * @param {ItemCache} cache
   * @protected
   * @deprecated since 24.3 and will be removed in Vaadin 25.
   */
  _loadPage(e, t) {
    console.warn("<vaadin-grid> The `_loadPage` method is deprecated and will be removed in Vaadin 25."), this._dataProviderController.__loadCachePage(t, e);
  }
  /** @protected */
  _onDataProviderPageRequested() {
    this._setLoading(!0);
  }
  /** @protected */
  _onDataProviderPageReceived() {
    this._flatSize !== this._dataProviderController.flatSize && (this._shouldUpdateAllRenderedRowsAfterPageLoad = !0, this._flatSize = this._dataProviderController.flatSize), this._getRenderedRows().forEach((e) => {
      this._dataProviderController.ensureFlatIndexHierarchy(e.index);
    }), this._hasData = !0;
  }
  /** @protected */
  _onDataProviderPageLoaded() {
    this._debouncerApplyCachedData = Le.debounce(this._debouncerApplyCachedData, Ft.after(0), () => {
      this._setLoading(!1);
      const e = this._shouldUpdateAllRenderedRowsAfterPageLoad;
      this._shouldUpdateAllRenderedRowsAfterPageLoad = !1, this._getRenderedRows().forEach((t) => {
        const { item: i } = this._dataProviderController.getFlatIndexContext(t.index);
        (i || e) && this._getItem(t.index, t);
      }), this.__scrollToPendingIndexes(), this.__dispatchPendingBodyCellFocus();
    }), this._dataProviderController.isLoading() || this._debouncerApplyCachedData.flush();
  }
  /** @private */
  __debounceClearCache() {
    this.__clearCacheDebouncer = Le.debounce(this.__clearCacheDebouncer, yt, () => this.clearCache());
  }
  /**
   * Clears the cached pages and reloads data from dataprovider when needed.
   */
  clearCache() {
    this._dataProviderController.clearCache(), this._dataProviderController.rootCache.size = this.size, this._dataProviderController.recalculateFlatSize(), this._hasData = !1, this.__updateVisibleRows(), (!this.__virtualizer || !this.__virtualizer.size) && this._dataProviderController.loadFirstPage();
  }
  /** @private */
  _pageSizeChanged(e, t) {
    this._dataProviderController.setPageSize(e), t !== void 0 && e !== t && this.clearCache();
  }
  /** @protected */
  _checkSize() {
    this.size === void 0 && this._flatSize === 0 && console.warn(
      "The <vaadin-grid> needs the total number of items in order to display rows, which you can specify either by setting the `size` property, or by providing it to the second argument of the `dataProvider` function `callback` call."
    );
  }
  /** @private */
  _dataProviderChanged(e, t) {
    this._dataProviderController.setDataProvider(e ? e.bind(this) : null), t !== void 0 && this.clearCache(), this._ensureFirstPageLoaded(), this._debouncerCheckSize = Le.debounce(
      this._debouncerCheckSize,
      Ft.after(2e3),
      this._checkSize.bind(this)
    );
  }
  /** @protected */
  _ensureFirstPageLoaded() {
    this._hasData || this._dataProviderController.loadFirstPage();
  }
  /**
   * @param {!GridItem} item1
   * @param {!GridItem} item2
   * @return {boolean}
   * @protected
   */
  _itemsEqual(e, t) {
    return this.getItemId(e) === this.getItemId(t);
  }
  /**
   * @param {!GridItem} item
   * @param {!Array<!GridItem>} array
   * @return {number}
   * @protected
   */
  _getItemIndexInArray(e, t) {
    let i = -1;
    return t.forEach((n, o) => {
      this._itemsEqual(n, e) && (i = o);
    }), i;
  }
  /**
   * Scroll to a specific row index in the virtual list. Note that the row index is
   * not always the same for any particular item. For example, sorting or filtering
   * items can affect the row index related to an item.
   *
   * The `indexes` parameter can be either a single number or multiple numbers.
   * The grid will first try to scroll to the item at the first index on the top level.
   * In case the item at the first index is expanded, the grid will then try scroll to the
   * item at the second index within the children of the expanded first item, and so on.
   * Each given index points to a child of the item at the previous index.
   *
   * Using `Infinity` as an index will point to the last item on the level.
   *
   * @param indexes {...number} Row indexes to scroll to
   */
  scrollToIndex(...e) {
    let t;
    for (; t !== (t = this._dataProviderController.getFlatIndexByPath(e)); )
      this._scrollToFlatIndex(t);
    (this._dataProviderController.isLoading() || !this.clientHeight) && (this.__pendingScrollToIndexes = e);
  }
  /** @private */
  __scrollToPendingIndexes() {
    if (this.__pendingScrollToIndexes && this.$.items.children.length) {
      const e = this.__pendingScrollToIndexes;
      delete this.__pendingScrollToIndexes, this.scrollToIndex(...e);
    }
  }
  /**
   * Fired when the `expandedItems` property changes.
   *
   * @event expanded-items-changed
   */
  /**
   * Fired when the `loading` property changes.
   *
   * @event loading-changed
   */
};
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const br = {
  BETWEEN: "between",
  ON_TOP: "on-top",
  ON_TOP_OR_BETWEEN: "on-top-or-between",
  ON_GRID: "on-grid"
}, Wt = {
  ON_TOP: "on-top",
  ABOVE: "above",
  BELOW: "below",
  EMPTY: "empty"
}, cp = !("draggable" in document.createElement("div")), hp = (s) => class extends s {
  static get properties() {
    return {
      /**
       * Defines the locations within the Grid row where an element can be dropped.
       *
       * Possible values are:
       * - `between`: The drop event can happen between Grid rows.
       * - `on-top`: The drop event can happen on top of Grid rows.
       * - `on-top-or-between`: The drop event can happen either on top of or between Grid rows.
       * - `on-grid`: The drop event will not happen on any specific row, it will show the drop target outline around the whole grid.
       * @attr {between|on-top|on-top-or-between|on-grid} drop-mode
       * @type {GridDropMode | null | undefined}
       */
      dropMode: {
        type: String,
        sync: !0
      },
      /**
       * Marks the grid's rows to be available for dragging.
       * @attr {boolean} rows-draggable
       */
      rowsDraggable: {
        type: Boolean,
        sync: !0
      },
      /**
       * A function that filters dragging of specific grid rows. The return value should be false
       * if dragging of the row should be disabled.
       *
       * Receives one argument:
       * - `model` The object with the properties related with
       *   the rendered item, contains:
       *   - `model.index` The index of the item.
       *   - `model.item` The item.
       *   - `model.expanded` Sublevel toggle state.
       *   - `model.level` Level of the tree represented with a horizontal offset of the toggle button.
       *   - `model.selected` Selected state.
       *
       * @type {GridDragAndDropFilter | null | undefined}
       */
      dragFilter: {
        type: Function,
        sync: !0
      },
      /**
       * A function that filters dropping on specific grid rows. The return value should be false
       * if dropping on the row should be disabled.
       *
       * Receives one argument:
       * - `model` The object with the properties related with
       *   the rendered item, contains:
       *   - `model.index` The index of the item.
       *   - `model.item` The item.
       *   - `model.expanded` Sublevel toggle state.
       *   - `model.level` Level of the tree represented with a horizontal offset of the toggle button.
       *   - `model.selected` Selected state.
       *
       * @type {GridDragAndDropFilter | null | undefined}
       */
      dropFilter: {
        type: Function,
        sync: !0
      },
      /** @private */
      __dndAutoScrollThreshold: {
        value: 50
      },
      /** @private  */
      __draggedItems: {
        value: () => []
      }
    };
  }
  static get observers() {
    return ["_dragDropAccessChanged(rowsDraggable, dropMode, dragFilter, dropFilter, loading)"];
  }
  constructor() {
    super(), this.__onDocumentDragStart = this.__onDocumentDragStart.bind(this);
  }
  /** @protected */
  ready() {
    super.ready(), this.$.table.addEventListener("dragstart", this._onDragStart.bind(this)), this.$.table.addEventListener("dragend", this._onDragEnd.bind(this)), this.$.table.addEventListener("dragover", this._onDragOver.bind(this)), this.$.table.addEventListener("dragleave", this._onDragLeave.bind(this)), this.$.table.addEventListener("drop", this._onDrop.bind(this)), this.$.table.addEventListener("dragenter", (e) => {
      this.dropMode && (e.preventDefault(), e.stopPropagation());
    });
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback(), document.addEventListener("dragstart", this.__onDocumentDragStart, { capture: !0 });
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback(), document.removeEventListener("dragstart", this.__onDocumentDragStart, { capture: !0 });
  }
  /** @private */
  _onDragStart(e) {
    if (this.rowsDraggable) {
      let t = e.target;
      if (t.localName === "vaadin-grid-cell-content" && (t = t.assignedSlot.parentNode.parentNode), t.parentNode !== this.$.items)
        return;
      if (e.stopPropagation(), this.toggleAttribute("dragging-rows", !0), this._safari) {
        const a = t.style.transform;
        t.style.top = /translateY\((.*)\)/u.exec(a)[1], t.style.transform = "none", requestAnimationFrame(() => {
          t.style.top = "", t.style.transform = a;
        });
      }
      const i = t.getBoundingClientRect();
      cp ? e.dataTransfer.setDragImage(t) : e.dataTransfer.setDragImage(t, e.clientX - i.left, e.clientY - i.top);
      let n = [t];
      this._isSelected(t._item) && (n = this.__getViewportRows().filter((a) => this._isSelected(a._item)).filter((a) => !this.dragFilter || this.dragFilter(this.__getRowModel(a)))), this.__draggedItems = n.map((a) => a._item), e.dataTransfer.setData("text", this.__formatDefaultTransferData(n)), Ni(t, { dragstart: n.length > 1 ? `${n.length}` : "" }), this.style.setProperty("--_grid-drag-start-x", `${e.clientX - i.left + 20}px`), this.style.setProperty("--_grid-drag-start-y", `${e.clientY - i.top + 10}px`), requestAnimationFrame(() => {
        Ni(t, { dragstart: !1 }), this.style.setProperty("--_grid-drag-start-x", ""), this.style.setProperty("--_grid-drag-start-y", ""), this.requestContentUpdate();
      });
      const o = new CustomEvent("grid-dragstart", {
        detail: {
          draggedItems: [...this.__draggedItems],
          setDragData: (a, l) => e.dataTransfer.setData(a, l),
          setDraggedItemsCount: (a) => t.setAttribute("dragstart", a)
        }
      });
      o.originalEvent = e, this.dispatchEvent(o);
    }
  }
  /** @private */
  _onDragEnd(e) {
    this.toggleAttribute("dragging-rows", !1), e.stopPropagation();
    const t = new CustomEvent("grid-dragend");
    t.originalEvent = e, this.dispatchEvent(t), this.__draggedItems = [], this.requestContentUpdate();
  }
  /** @private */
  _onDragLeave(e) {
    e.stopPropagation(), this._clearDragStyles();
  }
  /** @private */
  _onDragOver(e) {
    if (this.dropMode) {
      if (this._dropLocation = void 0, this._dragOverItem = void 0, this.__dndAutoScroll(e.clientY)) {
        this._clearDragStyles();
        return;
      }
      let t = e.composedPath().find((i) => i.localName === "tr");
      if (!this._flatSize || this.dropMode === br.ON_GRID)
        this._dropLocation = Wt.EMPTY;
      else if (!t || t.parentNode !== this.$.items) {
        if (t)
          return;
        if (this.dropMode === br.BETWEEN || this.dropMode === br.ON_TOP_OR_BETWEEN)
          t = Array.from(this.$.items.children).filter((i) => !i.hidden).pop(), this._dropLocation = Wt.BELOW;
        else
          return;
      } else {
        const i = t.getBoundingClientRect();
        if (this._dropLocation = Wt.ON_TOP, this.dropMode === br.BETWEEN) {
          const n = e.clientY - i.top < i.bottom - e.clientY;
          this._dropLocation = n ? Wt.ABOVE : Wt.BELOW;
        } else this.dropMode === br.ON_TOP_OR_BETWEEN && (e.clientY - i.top < i.height / 3 ? this._dropLocation = Wt.ABOVE : e.clientY - i.top > i.height / 3 * 2 && (this._dropLocation = Wt.BELOW));
      }
      if (t && t.hasAttribute("drop-disabled")) {
        this._dropLocation = void 0;
        return;
      }
      e.stopPropagation(), e.preventDefault(), this._dropLocation === Wt.EMPTY ? this.toggleAttribute("dragover", !0) : t ? (this._dragOverItem = t._item, t.getAttribute("dragover") !== this._dropLocation && fl(t, { dragover: this._dropLocation })) : this._clearDragStyles();
    }
  }
  /** @private */
  __onDocumentDragStart(e) {
    if (e.target.contains(this) && this.$.items.offsetHeight > 2e4) {
      const t = this.$.items.style.maxHeight, i = this.$.table.style.overflow;
      this.$.items.style.maxHeight = "0", this.$.table.style.overflow = "hidden", requestAnimationFrame(() => {
        this.$.items.style.maxHeight = t, this.$.table.style.overflow = i;
      });
    }
  }
  /** @private */
  __dndAutoScroll(e) {
    if (this.__dndAutoScrolling)
      return !0;
    const t = this.$.header.getBoundingClientRect().bottom, i = this.$.footer.getBoundingClientRect().top, n = t - e + this.__dndAutoScrollThreshold, o = e - i + this.__dndAutoScrollThreshold;
    let a = 0;
    if (o > 0 ? a = o * 2 : n > 0 && (a = -n * 2), a) {
      const l = this.$.table.scrollTop;
      if (this.$.table.scrollTop += a, l !== this.$.table.scrollTop)
        return this.__dndAutoScrolling = !0, setTimeout(() => {
          this.__dndAutoScrolling = !1;
        }, 20), !0;
    }
  }
  /** @private */
  __getViewportRows() {
    const e = this.$.header.getBoundingClientRect().bottom, t = this.$.footer.getBoundingClientRect().top;
    return Array.from(this.$.items.children).filter((i) => {
      const n = i.getBoundingClientRect();
      return n.bottom > e && n.top < t;
    });
  }
  /** @protected */
  _clearDragStyles() {
    this.removeAttribute("dragover"), dt(this.$.items, (e) => {
      fl(e, { dragover: null });
    });
  }
  /** @private */
  __updateDragSourceParts(e, t) {
    Ni(e, { "drag-source": this.__draggedItems.includes(t.item) });
  }
  /** @private */
  _onDrop(e) {
    if (this.dropMode) {
      e.stopPropagation(), e.preventDefault();
      const t = e.dataTransfer.types && Array.from(e.dataTransfer.types).map((n) => ({
        type: n,
        data: e.dataTransfer.getData(n)
      }));
      this._clearDragStyles();
      const i = new CustomEvent("grid-drop", {
        bubbles: e.bubbles,
        cancelable: e.cancelable,
        detail: {
          dropTargetItem: this._dragOverItem,
          dropLocation: this._dropLocation,
          dragData: t
        }
      });
      i.originalEvent = e, this.dispatchEvent(i);
    }
  }
  /** @private */
  __formatDefaultTransferData(e) {
    return e.map((t) => Array.from(t.children).filter((i) => !i.hidden && i.getAttribute("part").indexOf("details-cell") === -1).sort((i, n) => i._column._order > n._column._order ? 1 : -1).map((i) => i._content.textContent.trim()).filter((i) => i).join("	")).join(`
`);
  }
  /** @private */
  _dragDropAccessChanged() {
    this.filterDragAndDrop();
  }
  /**
   * Runs the `dragFilter` and `dropFilter` hooks for the visible cells.
   * If the filter depends on varying conditions, you may need to
   * call this function manually in order to update the draggability when
   * the conditions change.
   */
  filterDragAndDrop() {
    dt(this.$.items, (e) => {
      e.hidden || this._filterDragAndDrop(e, this.__getRowModel(e));
    });
  }
  /**
   * @param {!HTMLElement} row
   * @param {!GridItemModel} model
   * @protected
   */
  _filterDragAndDrop(e, t) {
    const i = this.loading || e.hasAttribute("loading"), n = !this.rowsDraggable || i || this.dragFilter && !this.dragFilter(t), o = !this.dropMode || i || this.dropFilter && !this.dropFilter(t);
    Zi(e, (a) => {
      n ? a._content.removeAttribute("draggable") : a._content.setAttribute("draggable", !0);
    }), Ni(e, {
      "drag-disabled": !!n,
      "drop-disabled": !!o
    });
  }
  /**
   * Fired when starting to drag grid rows.
   *
   * @event grid-dragstart
   * @param {Object} originalEvent The native dragstart event
   * @param {Object} detail
   * @param {Object} detail.draggedItems the items in the visible viewport that are dragged
   * @param {Function} detail.setDraggedItemsCount Overrides the default number shown in the drag image on multi row drag.
   * Parameter is of type number.
   * @param {Function} detail.setDragData Sets dataTransfer data for the drag operation.
   * Note that "text" is the only data type supported by all the browsers the grid currently supports (including IE11).
   * The function takes two parameters:
   * - type:string The type of the data
   * - data:string The data
   */
  /**
   * Fired when the dragging of the rows ends.
   *
   * @event grid-dragend
   * @param {Object} originalEvent The native dragend event
   */
  /**
   * Fired when a drop occurs on top of the grid.
   *
   * @event grid-drop
   * @param {Object} originalEvent The native drop event
   * @param {Object} detail
   * @param {Object} detail.dropTargetItem The item of the grid row on which the drop occurred.
   * @param {string} detail.dropLocation The position at which the drop event took place relative to a row.
   * Depending on the dropMode value, the drop location can be one of the following
   * - `on-top`: when the drop occurred on top of the row
   * - `above`: when the drop occurred above the row
   * - `below`: when the drop occurred below the row
   * - `empty`: when the drop occurred over the grid, not relative to any specific row
   * @param {string} detail.dragData An array of items with the payload as a string representation as the
   * `data` property and the type of the data as `type` property.
   */
};
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function eh(s, r) {
  if (!s || !r || s.length !== r.length)
    return !1;
  for (let e = 0, t = s.length; e < t; e++)
    if (s[e] instanceof Array && r[e] instanceof Array) {
      if (!eh(s[e], r[e]))
        return !1;
    } else if (s[e] !== r[e])
      return !1;
  return !0;
}
const dp = (s) => class extends s {
  static get properties() {
    return {
      /**
       * @protected
       */
      _columnTree: Object
    };
  }
  /** @protected */
  ready() {
    super.ready(), this._addNodeObserver();
  }
  /** @private */
  _hasColumnGroups(e) {
    return e.some((t) => t.localName === "vaadin-grid-column-group");
  }
  /**
   * @param {!GridColumnGroup} el
   * @return {!Array<!GridColumn>}
   * @protected
   */
  _getChildColumns(e) {
    return Wi.getColumns(e);
  }
  /** @private */
  _flattenColumnGroups(e) {
    return e.map((t) => t.localName === "vaadin-grid-column-group" ? this._getChildColumns(t) : [t]).reduce((t, i) => t.concat(i), []);
  }
  /** @private */
  _getColumnTree() {
    const e = Wi.getColumns(this), t = [e];
    let i = e;
    for (; this._hasColumnGroups(i); )
      i = this._flattenColumnGroups(i), t.push(i);
    return t;
  }
  /** @protected */
  _debounceUpdateColumnTree() {
    this.__updateColumnTreeDebouncer = Le.debounce(
      this.__updateColumnTreeDebouncer,
      yt,
      () => this._updateColumnTree()
    );
  }
  /** @protected */
  _updateColumnTree() {
    const e = this._getColumnTree();
    eh(e, this._columnTree) || (e.forEach((t) => {
      t.forEach((i) => {
        i.performUpdate && i.performUpdate();
      });
    }), this._columnTree = e);
  }
  /** @private */
  _addNodeObserver() {
    this._observer = new Wi(this, (e, t) => {
      const i = t.flatMap((o) => o._allCells), n = (o) => i.filter((a) => a && a._content.contains(o)).length;
      this.__removeSorters(this._sorters.filter(n)), this.__removeFilters(this._filters.filter(n)), this._debounceUpdateColumnTree(), this._debouncerCheckImports = Le.debounce(
        this._debouncerCheckImports,
        Ft.after(2e3),
        this._checkImports.bind(this)
      ), this._ensureFirstPageLoaded();
    });
  }
  /** @protected */
  _checkImports() {
    [
      "vaadin-grid-column-group",
      "vaadin-grid-filter",
      "vaadin-grid-filter-column",
      "vaadin-grid-tree-toggle",
      "vaadin-grid-selection-column",
      "vaadin-grid-sort-column",
      "vaadin-grid-sorter"
    ].forEach((e) => {
      this.querySelector(e) && !customElements.get(e) && console.warn(`Make sure you have imported the required module for <${e}> element.`);
    });
  }
  /** @protected */
  _updateFirstAndLastColumn() {
    Array.from(this.shadowRoot.querySelectorAll("tr")).forEach((e) => this._updateFirstAndLastColumnForRow(e));
  }
  /**
   * @param {!HTMLElement} row
   * @protected
   */
  _updateFirstAndLastColumnForRow(e) {
    Array.from(e.querySelectorAll('[part~="cell"]:not([part~="details-cell"])')).sort((t, i) => t._column._order - i._column._order).forEach((t, i, n) => {
      fi(t, "first-column", i === 0), fi(t, "last-column", i === n.length - 1);
    });
  }
  /**
   * @param {!Node} node
   * @return {boolean}
   * @protected
   */
  _isColumnElement(e) {
    return e.nodeType === Node.ELEMENT_NODE && /\bcolumn\b/u.test(e.localName);
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const up = (s) => class extends s {
  /**
   * Returns an object with context information about the event target:
   * - `item`: the data object corresponding to the targeted row (not specified when targeting header or footer)
   * - `column`: the column element corresponding to the targeted cell (not specified when targeting row details)
   * - `section`: whether the event targeted the body, header, footer or details of the grid
   *
   * These additional properties are included when `item` is specified:
   * - `index`: the index of the item
   * - `selected`: the selected state of the item
   * - `detailsOpened`: whether the row details are open for the item
   * - `expanded`: the expanded state of the tree toggle
   * - `level`: the tree hierarchy level
   *
   * The returned object is populated only when a grid cell, header, footer or row details is found in `event.composedPath()`.
   * This means mostly mouse and keyboard events. If such a grid part is not found in the path, an empty object is returned.
   * This may be the case eg. if the event is fired on the `<vaadin-grid>` element and not any deeper in the DOM, or if
   * the event targets the empty part of the grid body.
   *
   * @param {!Event} event
   * @return {GridEventContext}
   */
  getEventContext(e) {
    const t = {}, { cell: i } = this._getGridEventLocation(e);
    return i && (t.section = ["body", "header", "footer", "details"].find(
      (n) => i.getAttribute("part").indexOf(n) > -1
    ), i._column && (t.column = i._column), (t.section === "body" || t.section === "details") && Object.assign(t, this.__getRowModel(i.parentElement))), t;
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const fp = (s) => class extends s {
  static get properties() {
    return {
      /** @private */
      _filters: {
        type: Array,
        value: () => []
      }
    };
  }
  constructor() {
    super(), this._filterChanged = this._filterChanged.bind(this), this.addEventListener("filter-changed", this._filterChanged);
  }
  /** @private */
  _filterChanged(e) {
    e.stopPropagation(), this.__addFilter(e.target), this.__applyFilters();
  }
  /** @private */
  __removeFilters(e) {
    e.length !== 0 && (this._filters = this._filters.filter((t) => e.indexOf(t) < 0), this.__applyFilters());
  }
  /** @private */
  __addFilter(e) {
    this._filters.indexOf(e) === -1 && this._filters.push(e);
  }
  /** @private */
  __applyFilters() {
    this.dataProvider && this.isAttached && this.clearCache();
  }
  /**
   * @return {!Array<!GridFilterDefinition>}
   * @protected
   */
  _mapFilters() {
    return this._filters.map((e) => ({
      path: e.path,
      value: e.value
    }));
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function vn(s) {
  return s instanceof HTMLTableRowElement;
}
function _n(s) {
  return s instanceof HTMLTableCellElement;
}
function di(s) {
  return s.matches('[part~="details-cell"]');
}
const pp = (s) => class extends s {
  static get properties() {
    return {
      /** @private */
      _headerFocusable: {
        type: Object,
        observer: "_focusableChanged",
        sync: !0
      },
      /**
       * @type {!HTMLElement | undefined}
       * @protected
       */
      _itemsFocusable: {
        type: Object,
        observer: "_focusableChanged",
        sync: !0
      },
      /** @private */
      _footerFocusable: {
        type: Object,
        observer: "_focusableChanged",
        sync: !0
      },
      /** @private */
      _navigatingIsHidden: Boolean,
      /**
       * @type {number}
       * @protected
       */
      _focusedItemIndex: {
        type: Number,
        value: 0
      },
      /** @private */
      _focusedColumnOrder: Number,
      /** @private */
      _focusedCell: {
        type: Object,
        observer: "_focusedCellChanged",
        sync: !0
      },
      /**
       * Indicates whether the grid is currently in interaction mode.
       * In interaction mode the user is currently interacting with a control,
       * such as an input or a select, within a cell.
       * In interaction mode keyboard navigation between cells is disabled.
       * Interaction mode also prevents the focus target cell of that section of
       * the grid from receiving focus, allowing the user to switch focus to
       * controls in adjacent cells, rather than focussing the outer cell
       * itself.
       * @type {boolean}
       * @private
       */
      interacting: {
        type: Boolean,
        value: !1,
        reflectToAttribute: !0,
        readOnly: !0,
        observer: "_interactingChanged"
      }
    };
  }
  /** @private */
  get __rowFocusMode() {
    return [this._headerFocusable, this._itemsFocusable, this._footerFocusable].some(vn);
  }
  set __rowFocusMode(e) {
    ["_itemsFocusable", "_footerFocusable", "_headerFocusable"].forEach((t) => {
      const i = this[t];
      if (e) {
        const n = i && i.parentElement;
        _n(i) ? this[t] = n : _n(n) && (this[t] = n.parentElement);
      } else if (!e && vn(i)) {
        const n = i.firstElementChild;
        this[t] = n._focusButton || n;
      }
    });
  }
  /** @private */
  get _visibleItemsCount() {
    return this._lastVisibleIndex - this._firstVisibleIndex - 1;
  }
  /** @protected */
  ready() {
    super.ready(), !(this._ios || this._android) && (this.addEventListener("keydown", this._onKeyDown), this.addEventListener("keyup", this._onKeyUp), this.addEventListener("focusin", this._onFocusIn), this.addEventListener("focusout", this._onFocusOut), this.$.table.addEventListener("focusin", this._onContentFocusIn.bind(this)), this.addEventListener("mousedown", () => {
      this.toggleAttribute("navigating", !1), this._isMousedown = !0, this._focusedColumnOrder = void 0;
    }), this.addEventListener("mouseup", () => {
      this._isMousedown = !1;
    }));
  }
  /** @private */
  _focusableChanged(e, t) {
    t && t.setAttribute("tabindex", "-1"), e && this._updateGridSectionFocusTarget(e);
  }
  /** @private */
  _focusedCellChanged(e, t) {
    t && Vs(t, "part", "focused-cell"), e && Qn(e, "part", "focused-cell");
  }
  /** @private */
  _interactingChanged() {
    this._updateGridSectionFocusTarget(this._headerFocusable), this._updateGridSectionFocusTarget(this._itemsFocusable), this._updateGridSectionFocusTarget(this._footerFocusable);
  }
  /**
   * Since the focused cell/row state is stored as an element reference, the reference may get
   * out of sync when the virtual indexes for elements update due to effective size change.
   * This function updates the reference to the correct element after a possible index change.
   * @private
   */
  __updateItemsFocusable() {
    if (!this._itemsFocusable)
      return;
    const e = this.shadowRoot.activeElement === this._itemsFocusable;
    this._getRenderedRows().forEach((t) => {
      if (t.index === this._focusedItemIndex)
        if (this.__rowFocusMode)
          this._itemsFocusable = t;
        else {
          let i = this._itemsFocusable.parentElement, n = this._itemsFocusable;
          if (i) {
            _n(i) && (n = i, i = i.parentElement);
            const o = [...i.children].indexOf(n);
            this._itemsFocusable = this.__getFocusable(t, t.children[o]);
          }
        }
    }), e && this._itemsFocusable.focus();
  }
  /**
   * @param {!KeyboardEvent} e
   * @protected
   */
  _onKeyDown(e) {
    const t = e.key;
    let i;
    switch (t) {
      case "ArrowUp":
      case "ArrowDown":
      case "ArrowLeft":
      case "ArrowRight":
      case "PageUp":
      case "PageDown":
      case "Home":
      case "End":
        i = "Navigation";
        break;
      case "Enter":
      case "Escape":
      case "F2":
        i = "Interaction";
        break;
      case "Tab":
        i = "Tab";
        break;
      case " ":
        i = "Space";
        break;
    }
    this._detectInteracting(e), this.interacting && i !== "Interaction" && (i = void 0), i && this[`_on${i}KeyDown`](e, t);
  }
  /** @private */
  __ensureFlatIndexInViewport(e) {
    [...this.$.items.children].find((i) => i.index === e) ? this.__scrollIntoViewport(e) : this._scrollToFlatIndex(e);
  }
  /** @private */
  __isRowExpandable(e) {
    if (this.itemHasChildrenPath) {
      const t = e._item;
      return !!(t && Ci(this.itemHasChildrenPath, t) && !this._isExpanded(t));
    }
  }
  /** @private */
  __isRowCollapsible(e) {
    return this._isExpanded(e._item);
  }
  /** @private */
  _onNavigationKeyDown(e, t) {
    e.preventDefault();
    const i = this.__isRTL, n = e.composedPath().find(vn), o = e.composedPath().find(_n);
    let a = 0, l = 0;
    switch (t) {
      case "ArrowRight":
        a = i ? -1 : 1;
        break;
      case "ArrowLeft":
        a = i ? 1 : -1;
        break;
      case "Home":
        this.__rowFocusMode || e.ctrlKey ? l = -1 / 0 : a = -1 / 0;
        break;
      case "End":
        this.__rowFocusMode || e.ctrlKey ? l = 1 / 0 : a = 1 / 0;
        break;
      case "ArrowDown":
        l = 1;
        break;
      case "ArrowUp":
        l = -1;
        break;
      case "PageDown":
        if (this.$.items.contains(n)) {
          const f = this.__getIndexInGroup(n, this._focusedItemIndex);
          this._scrollToFlatIndex(f);
        }
        l = this._visibleItemsCount;
        break;
      case "PageUp":
        l = -this._visibleItemsCount;
        break;
    }
    if (this.__rowFocusMode && !n || !this.__rowFocusMode && !o)
      return;
    const h = i ? "ArrowLeft" : "ArrowRight", d = i ? "ArrowRight" : "ArrowLeft";
    if (t === h) {
      if (this.__rowFocusMode) {
        if (this.__isRowExpandable(n)) {
          this.expandItem(n._item);
          return;
        }
        this.__rowFocusMode = !1, this._onCellNavigation(n.firstElementChild, 0, 0);
        return;
      }
    } else if (t === d)
      if (this.__rowFocusMode) {
        if (this.__isRowCollapsible(n)) {
          this.collapseItem(n._item);
          return;
        }
      } else {
        const f = [...n.children].sort((g, w) => g._order - w._order);
        if (o === f[0] || di(o)) {
          this.__rowFocusMode = !0, this._onRowNavigation(n, 0);
          return;
        }
      }
    this.__rowFocusMode ? this._onRowNavigation(n, l) : this._onCellNavigation(o, a, l);
  }
  /**
   * Focuses the target row after navigating by the given dy offset.
   * If the row is not in the viewport, it is first scrolled to.
   * @private
   */
  _onRowNavigation(e, t) {
    const { dstRow: i } = this.__navigateRows(t, e);
    i && i.focus();
  }
  /** @private */
  __getIndexInGroup(e, t) {
    const i = e.parentNode;
    return i === this.$.items ? t !== void 0 ? t : e.index : [...i.children].indexOf(e);
  }
  /**
   * Returns the target row after navigating by the given dy offset.
   * Also returns information whether the details cell should be the target on the target row.
   * If the row is not in the viewport, it is first scrolled to.
   * @private
   */
  __navigateRows(e, t, i) {
    const n = this.__getIndexInGroup(t, this._focusedItemIndex), o = t.parentNode, a = (o === this.$.items ? this._flatSize : o.children.length) - 1;
    let l = Math.max(0, Math.min(n + e, a));
    if (o !== this.$.items) {
      if (l > n)
        for (; l < a && o.children[l].hidden; )
          l += 1;
      else if (l < n)
        for (; l > 0 && o.children[l].hidden; )
          l -= 1;
      return this.toggleAttribute("navigating", !0), { dstRow: o.children[l] };
    }
    let h = !1;
    if (i) {
      const d = di(i);
      if (o === this.$.items) {
        const f = t._item, { item: g } = this._dataProviderController.getFlatIndexContext(l);
        d ? h = e === 0 : h = e === 1 && this._isDetailsOpened(f) || e === -1 && l !== n && this._isDetailsOpened(g), h !== d && (e === 1 && h || e === -1 && !h) && (l = n);
      }
    }
    return this.__ensureFlatIndexInViewport(l), this._focusedItemIndex = l, this.toggleAttribute("navigating", !0), {
      dstRow: [...o.children].find((d) => !d.hidden && d.index === l),
      dstIsRowDetails: h
    };
  }
  /**
   * Focuses the target cell after navigating by the given dx and dy offset.
   * If the cell is not in the viewport, it is first scrolled to.
   * @private
   */
  _onCellNavigation(e, t, i) {
    const n = e.parentNode, { dstRow: o, dstIsRowDetails: a } = this.__navigateRows(i, n, e);
    if (!o)
      return;
    let l = [...n.children].indexOf(e);
    this.$.items.contains(e) && (l = [...this.$.sizer.children].findIndex((g) => g._column === e._column));
    const h = di(e), d = n.parentNode, f = this.__getIndexInGroup(n, this._focusedItemIndex);
    if (this._focusedColumnOrder === void 0 && (h ? this._focusedColumnOrder = 0 : this._focusedColumnOrder = this._getColumns(d, f).filter((g) => !g.hidden)[l]._order), a)
      [...o.children].find(di).focus();
    else {
      const g = this.__getIndexInGroup(o, this._focusedItemIndex), w = this._getColumns(d, g).filter((re) => !re.hidden), C = w.map((re) => re._order).sort((re, he) => re - he), E = C.length - 1, A = C.indexOf(
        C.slice(0).sort((re, he) => Math.abs(re - this._focusedColumnOrder) - Math.abs(he - this._focusedColumnOrder))[0]
      ), I = i === 0 && h ? A : Math.max(0, Math.min(A + t, E));
      I !== A && (this._focusedColumnOrder = void 0);
      const K = w.reduce((re, he, pe) => (re[he._order] = pe, re), {})[C[I]];
      let ce;
      if (this.$.items.contains(e)) {
        const re = this.$.sizer.children[K];
        this._lazyColumns && (this.__isColumnInViewport(re._column) || re.scrollIntoView(), this.__updateColumnsBodyContentHidden(), this.__updateHorizontalScrollPosition()), ce = [...o.children].find((he) => he._column === re._column), this._scrollHorizontallyToCell(ce);
      } else
        ce = o.children[K], this._scrollHorizontallyToCell(ce);
      ce.focus();
    }
  }
  /** @private */
  _onInteractionKeyDown(e, t) {
    const i = e.composedPath()[0], n = i.localName === "input" && !/^(button|checkbox|color|file|image|radio|range|reset|submit)$/iu.test(i.type);
    let o;
    switch (t) {
      case "Enter":
        o = this.interacting ? !n : !0;
        break;
      case "Escape":
        o = !1;
        break;
      case "F2":
        o = !this.interacting;
        break;
    }
    const { cell: a } = this._getGridEventLocation(e);
    if (this.interacting !== o && a !== null)
      if (o) {
        const l = a._content.querySelector("[focus-target]") || // If a child element hasn't been explicitly marked as a focus target,
        // fall back to any focusable element inside the cell.
        [...a._content.querySelectorAll("*")].find((h) => this._isFocusable(h));
        l && (e.preventDefault(), l.focus(), this._setInteracting(!0), this.toggleAttribute("navigating", !1));
      } else
        e.preventDefault(), this._focusedColumnOrder = void 0, a.focus(), this._setInteracting(!1), this.toggleAttribute("navigating", !0);
    t === "Escape" && this._hideTooltip(!0);
  }
  /** @private */
  _predictFocusStepTarget(e, t) {
    const i = [
      this.$.table,
      this._headerFocusable,
      this.__emptyState ? this.$.emptystatecell : this._itemsFocusable,
      this._footerFocusable,
      this.$.focusexit
    ];
    let n = i.indexOf(e);
    for (n += t; n >= 0 && n <= i.length - 1; ) {
      let a = i[n];
      if (a && !this.__rowFocusMode && (a = i[n].parentNode), !a || a.hidden)
        n += t;
      else
        break;
    }
    let o = i[n];
    if (o && !this.__isHorizontallyInViewport(o)) {
      const a = this._getColumnsInOrder().find((l) => this.__isColumnInViewport(l));
      if (a)
        if (o === this._headerFocusable)
          o = a._headerCell;
        else if (o === this._itemsFocusable) {
          const l = o._column._cells.indexOf(o);
          o = a._cells[l];
        } else o === this._footerFocusable && (o = a._footerCell);
    }
    return o;
  }
  /** @private */
  _onTabKeyDown(e) {
    const t = this._predictFocusStepTarget(e.composedPath()[0], e.shiftKey ? -1 : 1);
    t && (e.stopPropagation(), t === this.$.table ? this.$.table.focus() : t === this.$.focusexit ? this.$.focusexit.focus() : t === this._itemsFocusable ? (this.__ensureFlatIndexInViewport(this._focusedItemIndex), this.__updateItemsFocusable(), e.preventDefault(), this._itemsFocusable.focus()) : (e.preventDefault(), t.focus()), this.toggleAttribute("navigating", !0));
  }
  /** @private */
  _onSpaceKeyDown(e) {
    e.preventDefault();
    const t = e.composedPath()[0], i = vn(t);
    (i || !t._content || !t._content.firstElementChild) && this.dispatchEvent(
      new CustomEvent(i ? "row-activate" : "cell-activate", {
        detail: {
          model: this.__getRowModel(i ? t : t.parentElement)
        }
      })
    );
  }
  /** @private */
  _onKeyUp(e) {
    if (!/^( |SpaceBar)$/u.test(e.key) || this.interacting)
      return;
    e.preventDefault();
    const t = e.composedPath()[0];
    if (t._content && t._content.firstElementChild) {
      const i = this.hasAttribute("navigating");
      t._content.firstElementChild.dispatchEvent(
        new MouseEvent("click", {
          shiftKey: e.shiftKey,
          bubbles: !0,
          composed: !0,
          cancelable: !0
        })
      ), this.toggleAttribute("navigating", i);
    }
  }
  /**
   * @param {!FocusEvent} e
   * @protected
   */
  _onFocusIn(e) {
    this._isMousedown || this.toggleAttribute("navigating", !0);
    const t = e.composedPath()[0];
    t === this.$.table || t === this.$.focusexit ? (this._isMousedown || this._predictFocusStepTarget(t, t === this.$.table ? 1 : -1).focus(), this._setInteracting(!1)) : this._detectInteracting(e);
  }
  /**
   * @param {!FocusEvent} e
   * @protected
   */
  _onFocusOut(e) {
    this.toggleAttribute("navigating", !1), this._detectInteracting(e), this._hideTooltip(), this._focusedCell = null;
  }
  /** @private */
  _onContentFocusIn(e) {
    const { section: t, cell: i, row: n } = this._getGridEventLocation(e);
    if (!(!i && !this.__rowFocusMode) && (this._detectInteracting(e), t && (i || n)))
      if (this._activeRowGroup = t, t === this.$.header ? this._headerFocusable = this.__getFocusable(n, i) : t === this.$.items ? (this._itemsFocusable = this.__getFocusable(n, i), this._focusedItemIndex = n.index) : t === this.$.footer && (this._footerFocusable = this.__getFocusable(n, i)), i) {
        const o = this.getEventContext(e);
        this.__pendingBodyCellFocus = this.loading && o.section === "body", !this.__pendingBodyCellFocus && i !== this.$.emptystatecell && i.dispatchEvent(new CustomEvent("cell-focus", { bubbles: !0, composed: !0, detail: { context: o } })), this._focusedCell = i._focusButton || i, eo() && e.target === i && this._showTooltip(e);
      } else
        this._focusedCell = null;
  }
  /**
   * @private
   */
  __dispatchPendingBodyCellFocus() {
    this.__pendingBodyCellFocus && this.shadowRoot.activeElement === this._itemsFocusable && this._itemsFocusable.dispatchEvent(new Event("focusin", { bubbles: !0, composed: !0 }));
  }
  /**
   * Get the focusable element depending on the current focus mode.
   * It can be a row, a cell, or a focusable div inside a cell.
   *
   * @param {HTMLElement} row
   * @param {HTMLElement} cell
   * @return {HTMLElement}
   * @private
   */
  __getFocusable(e, t) {
    return this.__rowFocusMode ? e : t._focusButton || t;
  }
  /**
   * Enables interaction mode if a cells descendant receives focus or keyboard
   * input. Disables it if the event is not related to cell content.
   * @param {!KeyboardEvent|!FocusEvent} e
   * @private
   */
  _detectInteracting(e) {
    const t = e.composedPath().some((i) => i.localName === "slot" && this.shadowRoot.contains(i));
    this._setInteracting(t), this.__updateHorizontalScrollPosition();
  }
  /**
   * Enables or disables the focus target of the containing section of the
   * grid from receiving focus, based on whether the user is interacting with
   * that section of the grid.
   * @param {HTMLElement} focusTarget
   * @private
   */
  _updateGridSectionFocusTarget(e) {
    if (!e)
      return;
    const t = this._getGridSectionFromFocusTarget(e), i = this.interacting && t === this._activeRowGroup;
    e.tabIndex = i ? -1 : 0;
  }
  /** @protected */
  _preventScrollerRotatingCellFocus() {
    this._activeRowGroup === this.$.items && (this.__preventScrollerRotatingCellFocusDebouncer = Le.debounce(
      this.__preventScrollerRotatingCellFocusDebouncer,
      Jt,
      () => {
        const e = this._activeRowGroup === this.$.items;
        this._getRenderedRows().some((i) => i.index === this._focusedItemIndex) ? (this.__updateItemsFocusable(), e && !this.__rowFocusMode && (this._focusedCell = this._itemsFocusable), this._navigatingIsHidden && (this.toggleAttribute("navigating", !0), this._navigatingIsHidden = !1)) : e && (this._focusedCell = null, this.hasAttribute("navigating") && (this._navigatingIsHidden = !0, this.toggleAttribute("navigating", !1)));
      }
    ));
  }
  /**
   * @param {HTMLTableSectionElement=} rowGroup
   * @param {number=} rowIndex
   * @return {!Array<!GridColumn>}
   * @protected
   */
  _getColumns(e, t) {
    let i = this._columnTree.length - 1;
    return e === this.$.header ? i = t : e === this.$.footer && (i = this._columnTree.length - 1 - t), this._columnTree[i];
  }
  /** @private */
  __isValidFocusable(e) {
    return this.$.table.contains(e) && e.offsetHeight;
  }
  /** @protected */
  _resetKeyboardNavigation() {
    if (!this.$ && this.performUpdate && this.performUpdate(), ["header", "footer"].forEach((e) => {
      if (!this.__isValidFocusable(this[`_${e}Focusable`])) {
        const t = [...this.$[e].children].find((n) => n.offsetHeight), i = t ? [...t.children].find((n) => !n.hidden) : null;
        t && i && (this[`_${e}Focusable`] = this.__getFocusable(t, i));
      }
    }), !this.__isValidFocusable(this._itemsFocusable) && this.$.items.firstElementChild) {
      const e = this.__getFirstVisibleItem(), t = e ? [...e.children].find((i) => !i.hidden) : null;
      t && e && (this._focusedColumnOrder = void 0, this._itemsFocusable = this.__getFocusable(e, t));
    } else
      this.__updateItemsFocusable();
  }
  /**
   * @param {!HTMLElement} dstCell
   * @protected
   */
  _scrollHorizontallyToCell(e) {
    if (e.hasAttribute("frozen") || e.hasAttribute("frozen-to-end") || di(e))
      return;
    const t = e.getBoundingClientRect(), i = e.parentNode, n = Array.from(i.children).indexOf(e), o = this.$.table.getBoundingClientRect();
    let a = o.left, l = o.right;
    for (let h = n - 1; h >= 0; h--) {
      const d = i.children[h];
      if (!(d.hasAttribute("hidden") || di(d)) && (d.hasAttribute("frozen") || d.hasAttribute("frozen-to-end"))) {
        a = d.getBoundingClientRect().right;
        break;
      }
    }
    for (let h = n + 1; h < i.children.length; h++) {
      const d = i.children[h];
      if (!(d.hasAttribute("hidden") || di(d)) && (d.hasAttribute("frozen") || d.hasAttribute("frozen-to-end"))) {
        l = d.getBoundingClientRect().left;
        break;
      }
    }
    t.left < a && (this.$.table.scrollLeft += Math.round(t.left - a)), t.right > l && (this.$.table.scrollLeft += Math.round(t.right - l));
  }
  /**
   * @typedef {Object} GridEventLocation
   * @property {HTMLTableSectionElement | null} section - The table section element that the event occurred in (header, body, or footer), or null if the event did not occur in a section
   * @property {HTMLTableRowElement | null} row - The row element that the event occurred in, or null if the event did not occur in a row
   * @property {HTMLTableCellElement | null} cell - The cell element that the event occurred in, or null if the event did not occur in a cell
   * @private
   */
  /**
   * Takes an event and returns a location object describing in which part of the grid the event occurred.
   * The event may either target table section, a row, a cell or contents of a cell.
   * @param {Event} e
   * @returns {GridEventLocation}
   * @protected
   */
  _getGridEventLocation(e) {
    const t = e.__composedPath || e.composedPath(), i = t.indexOf(this.$.table), n = i >= 1 ? t[i - 1] : null, o = i >= 2 ? t[i - 2] : null, a = i >= 3 ? t[i - 3] : null;
    return {
      section: n,
      row: o,
      cell: a
    };
  }
  /**
   * Helper method that maps a focus target cell to the containing grid section
   * @param {HTMLElement} focusTarget
   * @returns {HTMLTableSectionElement | null}
   * @private
   */
  _getGridSectionFromFocusTarget(e) {
    return e === this._headerFocusable ? this.$.header : e === this._itemsFocusable ? this.$.items : e === this._footerFocusable ? this.$.footer : null;
  }
  /**
   * Fired when a cell is focused with click or keyboard navigation.
   *
   * Use context property of @see {@link GridCellFocusEvent} to get detail information about the event.
   *
   * @event cell-focus
   */
};
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const gp = (s) => class extends s {
  static get properties() {
    return {
      /**
       * An array containing references to items with open row details.
       * @type {!Array<!GridItem>}
       */
      detailsOpenedItems: {
        type: Array,
        value: () => [],
        sync: !0
      },
      /**
       * Custom function for rendering the content of the row details.
       * Receives three arguments:
       *
       * - `root` The row details content DOM element. Append your content to it.
       * - `grid` The `<vaadin-grid>` element.
       * - `model` The object with the properties related with
       *   the rendered item, contains:
       *   - `model.index` The index of the item.
       *   - `model.item` The item.
       *   - `model.level` The number of the item's tree sublevel, starts from 0.
       *   - `model.expanded` True if the item's tree sublevel is expanded.
       *   - `model.selected` True if the item is selected.
       *
       * @type {GridRowDetailsRenderer | null | undefined}
       */
      rowDetailsRenderer: {
        type: Function,
        sync: !0
      },
      /**
       * @type {!Array<!HTMLElement> | undefined}
       * @protected
       */
      _detailsCells: {
        type: Array
      }
    };
  }
  static get observers() {
    return [
      "_detailsOpenedItemsChanged(detailsOpenedItems, rowDetailsRenderer)",
      "_rowDetailsRendererChanged(rowDetailsRenderer)"
    ];
  }
  /** @protected */
  ready() {
    super.ready(), this._detailsCellResizeObserver = new ResizeObserver((e) => {
      e.forEach(({ target: t }) => {
        this._updateDetailsCellHeight(t.parentElement);
      }), this.__virtualizer.__adapter._resizeHandler();
    });
  }
  /** @private */
  _rowDetailsRendererChanged(e) {
    e && this._columnTree && dt(this.$.items, (t) => {
      if (!t.querySelector("[part~=details-cell]")) {
        this._updateRow(t, this._columnTree[this._columnTree.length - 1]);
        const i = this._isDetailsOpened(t._item);
        this._toggleDetailsCell(t, i);
      }
    });
  }
  /** @private */
  _detailsOpenedItemsChanged(e, t) {
    dt(this.$.items, (i) => {
      if (i.hasAttribute("details-opened")) {
        this._updateItem(i, i._item);
        return;
      }
      t && this._isDetailsOpened(i._item) && this._updateItem(i, i._item);
    });
  }
  /**
   * @param {!HTMLElement} cell
   * @protected
   */
  _configureDetailsCell(e) {
    e.setAttribute("part", "cell details-cell"), e.toggleAttribute("frozen", !0), this._detailsCellResizeObserver.observe(e);
  }
  /**
   * @param {!HTMLElement} row
   * @param {!GridItem} item
   * @protected
   */
  _toggleDetailsCell(e, t) {
    const i = e.querySelector('[part~="details-cell"]');
    i && (i.hidden = !t, !i.hidden && this.rowDetailsRenderer && (i._renderer = this.rowDetailsRenderer));
  }
  /** @protected */
  _updateDetailsCellHeight(e) {
    const t = e.querySelector('[part~="details-cell"]');
    t && (this.__updateDetailsRowPadding(e, t), requestAnimationFrame(() => this.__updateDetailsRowPadding(e, t)));
  }
  /** @private */
  __updateDetailsRowPadding(e, t) {
    t.hidden ? e.style.removeProperty("padding-bottom") : e.style.setProperty("padding-bottom", `${t.offsetHeight}px`);
  }
  /** @protected */
  _updateDetailsCellHeights() {
    dt(this.$.items, (e) => {
      this._updateDetailsCellHeight(e);
    });
  }
  /**
   * @param {!GridItem} item
   * @return {boolean}
   * @protected
   */
  _isDetailsOpened(e) {
    return this.detailsOpenedItems && this._getItemIndexInArray(e, this.detailsOpenedItems) !== -1;
  }
  /**
   * Open the details row of a given item.
   * @param {!GridItem} item
   */
  openItemDetails(e) {
    this._isDetailsOpened(e) || (this.detailsOpenedItems = [...this.detailsOpenedItems, e]);
  }
  /**
   * Close the details row of a given item.
   * @param {!GridItem} item
   */
  closeItemDetails(e) {
    this._isDetailsOpened(e) && (this.detailsOpenedItems = this.detailsOpenedItems.filter((t) => !this._itemsEqual(t, e)));
  }
};
/**
 * @license
 * Copyright (c) 2022 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const io = document.createElement("div");
io.style.position = "fixed";
io.style.clip = "rect(0px, 0px, 0px, 0px)";
io.setAttribute("aria-live", "polite");
document.body.appendChild(io);
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Js = $e(
  (s) => class extends s {
    /** @protected */
    ready() {
      super.ready(), this.addEventListener("keydown", (e) => {
        this._onKeyDown(e);
      }), this.addEventListener("keyup", (e) => {
        this._onKeyUp(e);
      });
    }
    /**
     * A handler for the `keydown` event. By default, it calls
     * separate methods for handling "Enter" and "Escape" keys.
     * Override the method to implement your own behavior.
     *
     * @param {KeyboardEvent} event
     * @protected
     */
    _onKeyDown(e) {
      switch (e.key) {
        case "Enter":
          this._onEnter(e);
          break;
        case "Escape":
          this._onEscape(e);
          break;
      }
    }
    /**
     * A handler for the `keyup` event. By default, it does nothing.
     * Override the method to implement your own behavior.
     *
     * @param {KeyboardEvent} _event
     * @protected
     */
    _onKeyUp(e) {
    }
    /**
     * A handler for the "Enter" key. By default, it does nothing.
     * Override the method to implement your own behavior.
     *
     * @param {KeyboardEvent} _event
     * @protected
     */
    _onEnter(e) {
    }
    /**
     * A handler for the "Escape" key. By default, it does nothing.
     * Override the method to implement your own behavior.
     *
     * @param {KeyboardEvent} _event
     * @protected
     */
    _onEscape(e) {
    }
  }
);
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const th = $e(
  (s) => class extends s {
    /**
     * @protected
     * @return {boolean}
     */
    get _keyboardActive() {
      return eo();
    }
    /** @protected */
    ready() {
      this.addEventListener("focusin", (e) => {
        this._shouldSetFocus(e) && this._setFocused(!0);
      }), this.addEventListener("focusout", (e) => {
        this._shouldRemoveFocus(e) && this._setFocused(!1);
      }), super.ready();
    }
    /** @protected */
    disconnectedCallback() {
      super.disconnectedCallback(), this.hasAttribute("focused") && this._setFocused(!1);
    }
    /**
     * Override to change how focused and focus-ring attributes are set.
     *
     * @param {boolean} focused
     * @protected
     */
    _setFocused(e) {
      this.toggleAttribute("focused", e), this.toggleAttribute("focus-ring", e && this._keyboardActive);
    }
    /**
     * Override to define if the field receives focus based on the event.
     *
     * @param {FocusEvent} _event
     * @return {boolean}
     * @protected
     */
    _shouldSetFocus(e) {
      return !0;
    }
    /**
     * Override to define if the field loses focus based on the event.
     *
     * @param {FocusEvent} _event
     * @return {boolean}
     * @protected
     */
    _shouldRemoveFocus(e) {
      return !0;
    }
  }
);
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const mp = $e(
  (s) => class extends th(Hc(s)) {
    static get properties() {
      return {
        /**
         * Specify that this control should have input focus when the page loads.
         */
        autofocus: {
          type: Boolean
        },
        /**
         * A reference to the focusable element controlled by the mixin.
         * It can be an input, textarea, button or any element with tabindex > -1.
         *
         * Any component implementing this mixin is expected to provide it
         * by using `this._setFocusElement(input)` Polymer API.
         *
         * Toggling `tabindex` attribute on the host element propagates its value to `focusElement`.
         *
         * @protected
         * @type {!HTMLElement}
         */
        focusElement: {
          type: Object,
          readOnly: !0,
          observer: "_focusElementChanged"
        },
        /**
         * Override the property from `TabIndexMixin`
         * to ensure the `tabindex` attribute of the focus element
         * will be restored to `0` after re-enabling the element.
         *
         * @protected
         * @override
         */
        _lastTabIndex: {
          value: 0
        }
      };
    }
    constructor() {
      super(), this._boundOnBlur = this._onBlur.bind(this), this._boundOnFocus = this._onFocus.bind(this);
    }
    /** @protected */
    ready() {
      super.ready(), this.autofocus && !this.disabled && requestAnimationFrame(() => {
        this.focus(), this.setAttribute("focus-ring", "");
      });
    }
    /**
     * @protected
     * @override
     */
    focus() {
      this.focusElement && !this.disabled && this.focusElement.focus();
    }
    /**
     * @protected
     * @override
     */
    blur() {
      this.focusElement && this.focusElement.blur();
    }
    /**
     * @protected
     * @override
     */
    click() {
      this.focusElement && !this.disabled && this.focusElement.click();
    }
    /** @protected */
    _focusElementChanged(e, t) {
      e ? (e.disabled = this.disabled, this._addFocusListeners(e), this.__forwardTabIndex(this.tabindex)) : t && this._removeFocusListeners(t);
    }
    /**
     * @param {HTMLElement} element
     * @protected
     */
    _addFocusListeners(e) {
      e.addEventListener("blur", this._boundOnBlur), e.addEventListener("focus", this._boundOnFocus);
    }
    /**
     * @param {HTMLElement} element
     * @protected
     */
    _removeFocusListeners(e) {
      e.removeEventListener("blur", this._boundOnBlur), e.removeEventListener("focus", this._boundOnFocus);
    }
    /**
     * Focus event does not bubble, so we dispatch it manually
     * on the host element to support adding focus listeners
     * when the focusable element is placed in light DOM.
     * @param {FocusEvent} event
     * @protected
     */
    _onFocus(e) {
      e.stopPropagation(), this.dispatchEvent(new Event("focus"));
    }
    /**
     * Blur event does not bubble, so we dispatch it manually
     * on the host element to support adding blur listeners
     * when the focusable element is placed in light DOM.
     * @param {FocusEvent} event
     * @protected
     */
    _onBlur(e) {
      e.stopPropagation(), this.dispatchEvent(new Event("blur"));
    }
    /**
     * @param {FocusEvent} event
     * @return {boolean}
     * @protected
     * @override
     */
    _shouldSetFocus(e) {
      return e.target === this.focusElement;
    }
    /**
     * @param {FocusEvent} event
     * @return {boolean}
     * @protected
     * @override
     */
    _shouldRemoveFocus(e) {
      return e.target === this.focusElement;
    }
    /**
     * @param {boolean} disabled
     * @param {boolean} oldDisabled
     * @protected
     * @override
     */
    _disabledChanged(e, t) {
      super._disabledChanged(e, t), this.focusElement && (this.focusElement.disabled = e), e && this.blur();
    }
    /**
     * Override an observer from `TabindexMixin`.
     * Do not call super to remove tabindex attribute
     * from the host after it has been forwarded.
     * @param {string} tabindex
     * @protected
     * @override
     */
    _tabindexChanged(e) {
      this.__forwardTabIndex(e);
    }
    /** @private */
    __forwardTabIndex(e) {
      e !== void 0 && this.focusElement && (this.focusElement.tabIndex = e, e !== -1 && (this.tabindex = void 0)), this.disabled && e && (e !== -1 && (this._lastTabIndex = e), this.tabindex = void 0);
    }
  }
);
/**
 * @license
 * Copyright (c) 2023 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Ko = /* @__PURE__ */ new Map();
function Qs(s) {
  return Ko.has(s) || Ko.set(s, /* @__PURE__ */ new WeakMap()), Ko.get(s);
}
function ih(s, r) {
  s && s.removeAttribute(r);
}
function rh(s, r) {
  if (!s || !r)
    return;
  const e = Qs(r);
  if (e.has(s))
    return;
  const t = Hs(s.getAttribute(r));
  e.set(s, new Set(t));
}
function vp(s, r) {
  if (!s || !r)
    return;
  const e = Qs(r), t = e.get(s);
  !t || t.size === 0 ? s.removeAttribute(r) : Qn(s, r, Jn(t)), e.delete(s);
}
function Zo(s, r, e = { newId: null, oldId: null, fromUser: !1 }) {
  if (!s || !r)
    return;
  const { newId: t, oldId: i, fromUser: n } = e, o = Qs(r), a = o.get(s);
  if (!n && a) {
    i && a.delete(i), t && a.add(t);
    return;
  }
  n && (a ? t || o.delete(s) : rh(s, r), ih(s, r)), Vs(s, r, i);
  const l = t || Jn(a);
  l && Qn(s, r, l);
}
function _p(s, r) {
  rh(s, r), ih(s, r);
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class bp {
  constructor(r) {
    this.host = r, this.__required = !1;
  }
  /**
   * Sets a target element to which ARIA attributes are added.
   *
   * @param {HTMLElement} target
   */
  setTarget(r) {
    this.__target = r, this.__setAriaRequiredAttribute(this.__required), this.__setLabelIdToAriaAttribute(this.__labelId, this.__labelId), this.__labelIdFromUser != null && this.__setLabelIdToAriaAttribute(this.__labelIdFromUser, this.__labelIdFromUser, !0), this.__setErrorIdToAriaAttribute(this.__errorId), this.__setHelperIdToAriaAttribute(this.__helperId), this.setAriaLabel(this.__label);
  }
  /**
   * Toggles the `aria-required` attribute on the target element
   * if the target is the host component (e.g. a field group).
   * Otherwise, it does nothing.
   *
   * @param {boolean} required
   */
  setRequired(r) {
    this.__setAriaRequiredAttribute(r), this.__required = r;
  }
  /**
   * Defines the `aria-label` attribute of the target element.
   *
   * To remove the attribute, pass `null` as `label`.
   *
   * @param {string | null | undefined} label
   */
  setAriaLabel(r) {
    this.__setAriaLabelToAttribute(r), this.__label = r;
  }
  /**
   * Links the target element with a slotted label element
   * via the target's attribute `aria-labelledby`.
   *
   * To unlink the previous slotted label element, pass `null` as `labelId`.
   *
   * @param {string | null} labelId
   */
  setLabelId(r, e = !1) {
    const t = e ? this.__labelIdFromUser : this.__labelId;
    this.__setLabelIdToAriaAttribute(r, t, e), e ? this.__labelIdFromUser = r : this.__labelId = r;
  }
  /**
   * Links the target element with a slotted error element via the target's attribute:
   * - `aria-labelledby` if the target is the host component (e.g a field group).
   * - `aria-describedby` otherwise.
   *
   * To unlink the previous slotted error element, pass `null` as `errorId`.
   *
   * @param {string | null} errorId
   */
  setErrorId(r) {
    this.__setErrorIdToAriaAttribute(r, this.__errorId), this.__errorId = r;
  }
  /**
   * Links the target element with a slotted helper element via the target's attribute:
   * - `aria-labelledby` if the target is the host component (e.g a field group).
   * - `aria-describedby` otherwise.
   *
   * To unlink the previous slotted helper element, pass `null` as `helperId`.
   *
   * @param {string | null} helperId
   */
  setHelperId(r) {
    this.__setHelperIdToAriaAttribute(r, this.__helperId), this.__helperId = r;
  }
  /**
   * @param {string | null | undefined} label
   * @private
   * */
  __setAriaLabelToAttribute(r) {
    this.__target && (r ? (_p(this.__target, "aria-labelledby"), this.__target.setAttribute("aria-label", r)) : this.__label && (vp(this.__target, "aria-labelledby"), this.__target.removeAttribute("aria-label")));
  }
  /**
   * @param {string | null | undefined} labelId
   * @param {string | null | undefined} oldLabelId
   * @param {boolean | null | undefined} fromUser
   * @private
   */
  __setLabelIdToAriaAttribute(r, e, t) {
    Zo(this.__target, "aria-labelledby", { newId: r, oldId: e, fromUser: t });
  }
  /**
   * @param {string | null | undefined} errorId
   * @param {string | null | undefined} oldErrorId
   * @private
   */
  __setErrorIdToAriaAttribute(r, e) {
    Zo(this.__target, "aria-describedby", { newId: r, oldId: e, fromUser: !1 });
  }
  /**
   * @param {string | null | undefined} helperId
   * @param {string | null | undefined} oldHelperId
   * @private
   */
  __setHelperIdToAriaAttribute(r, e) {
    Zo(this.__target, "aria-describedby", { newId: r, oldId: e, fromUser: !1 });
  }
  /**
   * @param {boolean} required
   * @private
   */
  __setAriaRequiredAttribute(r) {
    this.__target && (["input", "textarea"].includes(this.__target.localName) || (r ? this.__target.setAttribute("aria-required", "true") : this.__target.removeAttribute("aria-required")));
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Yo = [];
class yp {
  /**
   * @param {HTMLElement} host
   */
  constructor(r) {
    this.host = r, this.__trapNode = null, this.__onKeyDown = this.__onKeyDown.bind(this);
  }
  /**
   * An array of tab-ordered focusable elements inside the trap node.
   *
   * @return {HTMLElement[]}
   * @private
   */
  get __focusableElements() {
    return Pf(this.__trapNode);
  }
  /**
   * The index of the element inside the trap node that currently has focus.
   *
   * @return {HTMLElement | undefined}
   * @private
   */
  get __focusedElementIndex() {
    const r = this.__focusableElements;
    return r.indexOf(r.filter(Lc).pop());
  }
  hostConnected() {
    document.addEventListener("keydown", this.__onKeyDown);
  }
  hostDisconnected() {
    document.removeEventListener("keydown", this.__onKeyDown);
  }
  /**
   * Activates a focus trap for a DOM node that will prevent focus from escaping the node.
   * The trap can be deactivated with the `.releaseFocus()` method.
   *
   * If focus is initially outside the trap, the method will move focus inside,
   * on the first focusable element of the trap in the tab order.
   * The first focusable element can be the trap node itself if it is focusable
   * and comes first in the tab order.
   *
   * If there are no focusable elements, the method will throw an exception
   * and the trap will not be set.
   *
   * @param {HTMLElement} trapNode
   */
  trapFocus(r) {
    if (this.__trapNode = r, this.__focusableElements.length === 0)
      throw this.__trapNode = null, new Error("The trap node should have at least one focusable descendant or be focusable itself.");
    Yo.push(this), this.__focusedElementIndex === -1 && this.__focusableElements[0].focus();
  }
  /**
   * Deactivates the focus trap set with the `.trapFocus()` method
   * so that it becomes possible to tab outside the trap node.
   */
  releaseFocus() {
    this.__trapNode = null, Yo.pop();
  }
  /**
   * A `keydown` event handler that manages tabbing navigation when the trap is enabled.
   *
   * - Moves focus to the next focusable element of the trap on `Tab` press.
   * When no next element to focus, the method moves focus to the first focusable element.
   * - Moves focus to the prev focusable element of the trap on `Shift+Tab` press.
   * When no prev element to focus, the method moves focus to the last focusable element.
   *
   * @param {KeyboardEvent} event
   * @private
   */
  __onKeyDown(r) {
    if (this.__trapNode && this === Array.from(Yo).pop() && r.key === "Tab") {
      r.preventDefault();
      const e = r.shiftKey;
      this.__focusNextElement(e);
    }
  }
  /**
   * - Moves focus to the next focusable element if `backward === false`.
   * When no next element to focus, the method moves focus to the first focusable element.
   * - Moves focus to the prev focusable element if `backward === true`.
   * When no prev element to focus the method moves focus to the last focusable element.
   *
   * If no focusable elements, the method returns immediately.
   *
   * @param {boolean} backward
   * @private
   */
  __focusNextElement(r = !1) {
    const e = this.__focusableElements, t = r ? -1 : 1, i = this.__focusedElementIndex, n = (e.length + i + t) % e.length, o = e[n];
    o.focus(), o.localName === "input" && o.select();
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class wp {
  /**
   * Saves the given node as a target for restoring focus to
   * when `restoreFocus()` is called. If no node is provided,
   * the currently focused node in the DOM is saved as a target.
   *
   * @param {Node | null | undefined} focusNode
   */
  saveFocus(r) {
    this.focusNode = r || _s();
  }
  /**
   * Restores focus to the target node that was saved previously with `saveFocus()`.
   */
  restoreFocus(r) {
    const e = this.focusNode;
    if (!e)
      return;
    const t = r ? r.preventScroll : !1;
    _s() === document.body ? setTimeout(() => e.focus({ preventScroll: t })) : e.focus({ preventScroll: t }), this.focusNode = null;
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function El(s, r) {
  const { scrollLeft: e } = s;
  return r !== "rtl" ? e : s.scrollWidth - s.clientWidth + e;
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const bn = new ResizeObserver((s) => {
  setTimeout(() => {
    s.forEach((r) => {
      r.target.resizables ? r.target.resizables.forEach((e) => {
        e._onResize(r.contentRect);
      }) : r.target._onResize(r.contentRect);
    });
  });
}), xp = $e(
  (s) => class extends s {
    /**
     * When true, the parent element resize will be also observed.
     * Override this getter and return `true` to enable this.
     *
     * @protected
     */
    get _observeParent() {
      return !1;
    }
    /** @protected */
    connectedCallback() {
      if (super.connectedCallback(), bn.observe(this), this._observeParent) {
        const e = this.parentNode instanceof ShadowRoot ? this.parentNode.host : this.parentNode;
        e.resizables || (e.resizables = /* @__PURE__ */ new Set(), bn.observe(e)), e.resizables.add(this), this.__parent = e;
      }
    }
    /** @protected */
    disconnectedCallback() {
      super.disconnectedCallback(), bn.unobserve(this);
      const e = this.__parent;
      if (this._observeParent && e) {
        const t = e.resizables;
        t && (t.delete(this), t.size === 0 && bn.unobserve(e)), this.__parent = null;
      }
    }
    /**
     * A handler invoked on host resize. By default, it does nothing.
     * Override the method to implement your own behavior.
     *
     * @protected
     */
    _onResize(e) {
    }
  }
);
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Pl = {
  SCROLLING: 500,
  UPDATE_CONTENT_VISIBILITY: 100
}, Cp = (s) => class extends xp(s) {
  static get properties() {
    return {
      /**
       * Allows you to choose between modes for rendering columns in the grid:
       *
       * "eager" (default): All columns are rendered upfront, regardless of their visibility within the viewport.
       * This mode should generally be preferred, as it avoids the limitations imposed by the "lazy" mode.
       * Use this mode unless the grid has a large number of columns and performance outweighs the limitations
       * in priority.
       *
       * "lazy": Optimizes the rendering of cells when there are multiple columns in the grid by virtualizing
       * horizontal scrolling. In this mode, body cells are rendered only when their corresponding columns are
       * inside the visible viewport.
       *
       * Using "lazy" rendering should be used only if you're dealing with a large number of columns and performance
       * is your highest priority. For most use cases, the default "eager" mode is recommended due to the
       * limitations imposed by the "lazy" mode.
       *
       * When using the "lazy" mode, keep the following limitations in mind:
       *
       * - Row Height: When only a number of columns are visible at once, the height of a row can only be that of
       * the highest cell currently visible on that row. Make sure each cell on a single row has the same height
       * as all other cells on that row. If row cells have different heights, users may experience jumpiness when
       * scrolling the grid horizontally as lazily rendered cells with different heights are scrolled into view.
       *
       * - Auto-width Columns: For the columns that are initially outside the visible viewport but still use auto-width,
       * only the header content is taken into account when calculating the column width because the body cells
       * of the columns outside the viewport are not initially rendered.
       *
       * - Screen Reader Compatibility: Screen readers may not be able to associate the focused cells with the correct
       * headers when only a subset of the body cells on a row is rendered.
       *
       * - Keyboard Navigation: Tabbing through focusable elements inside the grid body may not work as expected because
       * some of the columns that would include focusable elements in the body cells may be outside the visible viewport
       * and thus not rendered.
       *
       * @attr {eager|lazy} column-rendering
       * @type {!ColumnRendering}
       */
      columnRendering: {
        type: String,
        value: "eager",
        sync: !0
      },
      /**
       * Cached array of frozen cells
       * @private
       */
      _frozenCells: {
        type: Array,
        value: () => []
      },
      /**
       * Cached array of cells frozen to end
       * @private
       */
      _frozenToEndCells: {
        type: Array,
        value: () => []
      },
      /** @private */
      _rowWithFocusedElement: Element
    };
  }
  static get observers() {
    return ["__columnRenderingChanged(_columnTree, columnRendering)"];
  }
  /** @private */
  get _scrollLeft() {
    return this.$.table.scrollLeft;
  }
  /** @private */
  get _scrollTop() {
    return this.$.table.scrollTop;
  }
  /**
   * Override (from iron-scroll-target-behavior) to avoid document scroll
   * @private
   */
  set _scrollTop(e) {
    this.$.table.scrollTop = e;
  }
  /** @protected */
  get _lazyColumns() {
    return this.columnRendering === "lazy";
  }
  /** @protected */
  ready() {
    super.ready(), this.scrollTarget = this.$.table, this.$.items.addEventListener("focusin", (e) => {
      const t = e.composedPath().indexOf(this.$.items);
      this._rowWithFocusedElement = e.composedPath()[t - 1], this._rowWithFocusedElement && (this._isMousedown || this.__scrollIntoViewport(this._rowWithFocusedElement.index), this.$.table.contains(e.relatedTarget) || this.$.table.dispatchEvent(
        new CustomEvent("virtualizer-element-focused", { detail: { element: this._rowWithFocusedElement } })
      ));
    }), this.$.items.addEventListener("focusout", () => {
      this._rowWithFocusedElement = void 0;
    }), this.$.table.addEventListener("scroll", () => this._afterScroll());
  }
  /**
   * @protected
   * @override
   */
  _onResize() {
    if (this._updateOverflow(), this.__updateHorizontalScrollPosition(), this._firefox) {
      const e = !Un(this);
      e && this.__previousVisible === !1 && (this._scrollTop = this.__memorizedScrollTop || 0), this.__previousVisible = e;
    }
  }
  /**
   * Scroll to a flat index in the grid. The method doesn't take into account
   * the hierarchy of the items.
   *
   * @param {number} index Row index to scroll to
   * @protected
   */
  _scrollToFlatIndex(e) {
    e = Math.min(this._flatSize - 1, Math.max(0, e)), this.__virtualizer.scrollToIndex(e), this.__scrollIntoViewport(e);
  }
  /**
   * Makes sure the row with the given index (if found in the DOM) is fully
   * inside the visible viewport, taking header/footer into account.
   * @private
   */
  __scrollIntoViewport(e) {
    const t = [...this.$.items.children].find((i) => i.index === e);
    if (t) {
      const i = t.getBoundingClientRect(), n = this.$.footer.getBoundingClientRect().top, o = this.$.header.getBoundingClientRect().bottom;
      i.bottom > n ? this.$.table.scrollTop += i.bottom - n : i.top < o && (this.$.table.scrollTop -= o - i.top);
    }
  }
  /** @private */
  _scheduleScrolling() {
    this._scrollingFrame || (this._scrollingFrame = requestAnimationFrame(() => this.$.scroller.toggleAttribute("scrolling", !0))), this._debounceScrolling = Le.debounce(this._debounceScrolling, Ft.after(Pl.SCROLLING), () => {
      cancelAnimationFrame(this._scrollingFrame), delete this._scrollingFrame, this.$.scroller.toggleAttribute("scrolling", !1);
    });
  }
  /** @private */
  _afterScroll() {
    this.__updateHorizontalScrollPosition(), this.hasAttribute("reordering") || this._scheduleScrolling(), this.hasAttribute("navigating") || this._hideTooltip(!0), this._updateOverflow(), this._debounceColumnContentVisibility = Le.debounce(
      this._debounceColumnContentVisibility,
      Ft.after(Pl.UPDATE_CONTENT_VISIBILITY),
      () => {
        this._lazyColumns && this.__cachedScrollLeft !== this._scrollLeft && (this.__cachedScrollLeft = this._scrollLeft, this.__updateColumnsBodyContentHidden());
      }
    ), this._firefox && !Un(this) && this.__previousVisible !== !1 && (this.__memorizedScrollTop = this._scrollTop);
  }
  /** @private */
  __updateColumnsBodyContentHidden() {
    if (!this._columnTree || !this._areSizerCellsAssigned())
      return;
    const e = this._getColumnsInOrder();
    let t = !1;
    if (e.forEach((i) => {
      const n = this._lazyColumns && !this.__isColumnInViewport(i);
      i._bodyContentHidden !== n && (t = !0, i._cells.forEach((o) => {
        if (o !== i._sizerCell) {
          if (n)
            o.remove();
          else if (o.__parentRow) {
            const a = [...o.__parentRow.children].find(
              (l) => e.indexOf(l._column) > e.indexOf(i)
            );
            o.__parentRow.insertBefore(o, a);
          }
        }
      })), i._bodyContentHidden = n;
    }), t && this._frozenCellsChanged(), this._lazyColumns) {
      const i = [...e].reverse().find((a) => a.frozen), n = this.__getColumnEnd(i), o = e.find((a) => !a.frozen && !a._bodyContentHidden);
      this.__lazyColumnsStart = this.__getColumnStart(o) - n, this.$.items.style.setProperty("--_grid-lazy-columns-start", `${this.__lazyColumnsStart}px`), this._resetKeyboardNavigation();
    }
  }
  /** @private */
  __getColumnEnd(e) {
    return e ? e._sizerCell.offsetLeft + (this.__isRTL ? 0 : e._sizerCell.offsetWidth) : this.__isRTL ? this.$.table.clientWidth : 0;
  }
  /** @private */
  __getColumnStart(e) {
    return e ? e._sizerCell.offsetLeft + (this.__isRTL ? e._sizerCell.offsetWidth : 0) : this.__isRTL ? this.$.table.clientWidth : 0;
  }
  /**
   * Returns true if the given column is horizontally inside the viewport.
   * @private
   */
  __isColumnInViewport(e) {
    return e.frozen || e.frozenToEnd ? !0 : this.__isHorizontallyInViewport(e._sizerCell);
  }
  /** @private */
  __isHorizontallyInViewport(e) {
    return e.offsetLeft + e.offsetWidth >= this._scrollLeft && e.offsetLeft <= this._scrollLeft + this.clientWidth;
  }
  /** @private */
  __columnRenderingChanged(e, t) {
    t === "eager" ? this.$.scroller.removeAttribute("column-rendering") : this.$.scroller.setAttribute("column-rendering", t), this.__updateColumnsBodyContentHidden();
  }
  /** @private */
  _updateOverflow() {
    this._debounceOverflow = Le.debounce(this._debounceOverflow, Jt, () => {
      this.__doUpdateOverflow();
    });
  }
  /** @private */
  __doUpdateOverflow() {
    let e = "";
    const t = this.$.table;
    t.scrollTop < t.scrollHeight - t.clientHeight && (e += " bottom"), t.scrollTop > 0 && (e += " top");
    const i = El(t, this.getAttribute("dir"));
    i > 0 && (e += " start"), i < t.scrollWidth - t.clientWidth && (e += " end"), this.__isRTL && (e = e.replace(/start|end/giu, (o) => o === "start" ? "end" : "start")), t.scrollLeft < t.scrollWidth - t.clientWidth && (e += " right"), t.scrollLeft > 0 && (e += " left");
    const n = e.trim();
    n.length > 0 && this.getAttribute("overflow") !== n ? this.setAttribute("overflow", n) : n.length === 0 && this.hasAttribute("overflow") && this.removeAttribute("overflow");
  }
  /** @protected */
  _frozenCellsChanged() {
    this._debouncerCacheElements = Le.debounce(this._debouncerCacheElements, yt, () => {
      Array.from(this.shadowRoot.querySelectorAll('[part~="cell"]')).forEach((e) => {
        e.style.transform = "";
      }), this._frozenCells = Array.prototype.slice.call(this.$.table.querySelectorAll("[frozen]")), this._frozenToEndCells = Array.prototype.slice.call(this.$.table.querySelectorAll("[frozen-to-end]")), this.__updateHorizontalScrollPosition();
    }), this._debounceUpdateFrozenColumn();
  }
  /** @protected */
  _debounceUpdateFrozenColumn() {
    this.__debounceUpdateFrozenColumn = Le.debounce(
      this.__debounceUpdateFrozenColumn,
      yt,
      () => this._updateFrozenColumn()
    );
  }
  /** @private */
  _updateFrozenColumn() {
    if (!this._columnTree)
      return;
    const e = this._columnTree[this._columnTree.length - 1].slice(0);
    e.sort((n, o) => n._order - o._order);
    let t, i;
    for (let n = 0; n < e.length; n++) {
      const o = e[n];
      o._lastFrozen = !1, o._firstFrozenToEnd = !1, i === void 0 && o.frozenToEnd && !o.hidden && (i = n), o.frozen && !o.hidden && (t = n);
    }
    t !== void 0 && (e[t]._lastFrozen = !0), i !== void 0 && (e[i]._firstFrozenToEnd = !0), this.__updateColumnsBodyContentHidden();
  }
  /** @private */
  __updateHorizontalScrollPosition() {
    if (!this._columnTree)
      return;
    const e = this.$.table.scrollWidth, t = this.$.table.clientWidth, i = Math.max(0, this.$.table.scrollLeft), n = El(this.$.table, this.getAttribute("dir")), o = `translate(${-i}px, 0)`;
    this.$.header.style.transform = o, this.$.footer.style.transform = o, this.$.items.style.transform = o;
    const a = this.__isRTL ? n + t - e : i, l = `translate(${a}px, 0)`;
    this._frozenCells.forEach((g) => {
      g.style.transform = l;
    });
    const h = this.__isRTL ? n : i + t - e, d = `translate(${h}px, 0)`;
    let f = d;
    if (this._lazyColumns && this._areSizerCellsAssigned()) {
      const g = this._getColumnsInOrder(), w = [...g].reverse().find((V) => !V.frozenToEnd && !V._bodyContentHidden), C = this.__getColumnEnd(w), E = g.find((V) => V.frozenToEnd), A = this.__getColumnStart(E);
      f = `translate(${h + (A - C) + this.__lazyColumnsStart}px, 0)`;
    }
    this._frozenToEndCells.forEach((g) => {
      this.$.items.contains(g) ? g.style.transform = f : g.style.transform = d;
    }), this.hasAttribute("navigating") && this.__rowFocusMode && this.$.table.style.setProperty("--_grid-horizontal-scroll-position", `${-a}px`);
  }
  /** @private */
  _areSizerCellsAssigned() {
    return this._getColumnsInOrder().every((e) => e._sizerCell);
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Tp = (s) => class extends s {
  static get properties() {
    return {
      /**
       * An array that contains the selected items.
       * @type {!Array<!GridItem>}
       */
      selectedItems: {
        type: Object,
        notify: !0,
        value: () => [],
        sync: !0
      },
      /**
       * Set of selected item ids
       * @private
       */
      __selectedKeys: {
        type: Object,
        computed: "__computeSelectedKeys(itemIdPath, selectedItems)"
      }
    };
  }
  static get observers() {
    return ["__selectedItemsChanged(itemIdPath, selectedItems)"];
  }
  /**
   * @param {!GridItem} item
   * @return {boolean}
   * @protected
   */
  _isSelected(e) {
    return this.__selectedKeys.has(this.getItemId(e));
  }
  /**
   * Selects the given item.
   *
   * @method selectItem
   * @param {!GridItem} item The item object
   */
  selectItem(e) {
    this._isSelected(e) || (this.selectedItems = [...this.selectedItems, e]);
  }
  /**
   * Deselects the given item if it is already selected.
   *
   * @method deselect
   * @param {!GridItem} item The item object
   */
  deselectItem(e) {
    this._isSelected(e) && (this.selectedItems = this.selectedItems.filter((t) => !this._itemsEqual(t, e)));
  }
  /**
   * Toggles the selected state of the given item.
   *
   * @method toggle
   * @param {!GridItem} item The item object
   * @protected
   */
  _toggleItem(e) {
    this._isSelected(e) ? this.deselectItem(e) : this.selectItem(e);
  }
  /** @private */
  __selectedItemsChanged() {
    this.requestContentUpdate();
  }
  /** @private */
  __computeSelectedKeys(e, t) {
    const i = t || [], n = /* @__PURE__ */ new Set();
    return i.forEach((o) => {
      n.add(this.getItemId(o));
    }), n;
  }
  /**
   * Fired when the `selectedItems` property changes.
   *
   * @event selected-items-changed
   */
};
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
let Sl = "prepend";
const Ep = (s) => class extends s {
  static get properties() {
    return {
      /**
       * When `true`, all `<vaadin-grid-sorter>` are applied for sorting.
       * @attr {boolean} multi-sort
       * @type {boolean}
       */
      multiSort: {
        type: Boolean,
        value: !1
      },
      /**
       * Controls how columns are added to the sort order when using multi-sort.
       * The sort order is visually indicated by numbers in grid sorters placed in column headers.
       *
       * By default, whenever an unsorted column is sorted, or the sort-direction of a column is
       * changed, that column gets sort priority 1, thus affecting the priority for all the other
       * sorted columns. This is identical to using `multi-sort-priority="prepend"`.
       *
       * Using this property allows to change this behavior so that sorting an unsorted column
       * would add it to the "end" of the sort, and changing column's sort direction would retain
       * it's previous priority. To set this, use `multi-sort-priority="append"`.
       *
       * @attr {string} multi-sort-priority
       */
      multiSortPriority: {
        type: String,
        value: () => Sl
      },
      /**
       * When `true`, Shift-clicking an unsorted column's sorter adds it to the multi-sort.
       * Shift + Space does the same action via keyboard. This property has precedence over the
       * `multiSort` property. If `multiSortOnShiftClick` is true, the multiSort property is effectively ignored.
       *
       * @attr {boolean} multi-sort-on-shift-click
       * @type {boolean}
       */
      multiSortOnShiftClick: {
        type: Boolean,
        value: !1
      },
      /**
       * @type {!Array<!GridSorterDefinition>}
       * @protected
       */
      _sorters: {
        type: Array,
        value: () => []
      },
      /** @private */
      _previousSorters: {
        type: Array,
        value: () => []
      }
    };
  }
  /**
   * Sets the default multi-sort priority to use for all grid instances.
   * This method should be called before creating any grid instances.
   * Changing this setting does not affect the default for existing grids.
   *
   * @param {string} priority
   */
  static setDefaultMultiSortPriority(e) {
    Sl = ["append", "prepend"].includes(e) ? e : "prepend";
  }
  /** @protected */
  ready() {
    super.ready(), this.addEventListener("sorter-changed", this._onSorterChanged);
  }
  /** @private */
  _onSorterChanged(e) {
    const t = e.target;
    e.stopPropagation(), t._grid = this, this.__updateSorter(t, e.detail.shiftClick, e.detail.fromSorterClick), this.__applySorters();
  }
  /** @private */
  __removeSorters(e) {
    e.length !== 0 && (this._sorters = this._sorters.filter((t) => !e.includes(t)), this.__applySorters());
  }
  /** @private */
  __updateSortOrders() {
    this._sorters.forEach((t) => {
      t._order = null;
    });
    const e = this._getActiveSorters();
    e.length > 1 && e.forEach((t, i) => {
      t._order = i;
    });
  }
  /** @private */
  __updateSorter(e, t, i) {
    if (!e.direction && !this._sorters.includes(e))
      return;
    e._order = null;
    const n = this._sorters.filter((o) => o !== e);
    this.multiSort && (!this.multiSortOnShiftClick || !i) || this.multiSortOnShiftClick && t ? this.multiSortPriority === "append" ? this._sorters = [...n, e] : this._sorters = [e, ...n] : (e.direction || this.multiSortOnShiftClick) && (this._sorters = e.direction ? [e] : [], n.forEach((o) => {
      o._order = null, o.direction = null;
    }));
  }
  /** @private */
  __applySorters() {
    this.__updateSortOrders(), this.dataProvider && // No need to clear cache if sorters didn't change and grid is attached
    this.isAttached && JSON.stringify(this._previousSorters) !== JSON.stringify(this._mapSorters()) && this.__debounceClearCache(), this._a11yUpdateSorters(), this._previousSorters = this._mapSorters();
  }
  /**
   * @type {GridSorterDefinition[]}
   * @protected
   */
  _getActiveSorters() {
    return this._sorters.filter((e) => e.direction && e.isConnected);
  }
  /**
   * @return {!Array<!GridSorterDefinition>}
   * @protected
   */
  _mapSorters() {
    return this._getActiveSorters().map((e) => ({
      path: e.path,
      direction: e.direction
    }));
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Pp = (s) => class extends s {
  static get properties() {
    return {
      /**
       * A function that allows generating CSS class names for grid cells
       * based on their row and column. The return value should be the generated
       * class name as a string, or multiple class names separated by whitespace
       * characters.
       *
       * Receives two arguments:
       * - `column` The `<vaadin-grid-column>` element (`undefined` for details-cell).
       * - `model` The object with the properties related with
       *   the rendered item, contains:
       *   - `model.index` The index of the item.
       *   - `model.item` The item.
       *   - `model.expanded` Sublevel toggle state.
       *   - `model.level` Level of the tree represented with a horizontal offset of the toggle button.
       *   - `model.selected` Selected state.
       *
       * @type {GridCellClassNameGenerator | null | undefined}
       * @deprecated Use `cellPartNameGenerator` instead.
       */
      cellClassNameGenerator: {
        type: Function,
        sync: !0
      },
      /**
       * A function that allows generating CSS `part` names for grid cells in Shadow DOM based
       * on their row and column, for styling from outside using the `::part()` selector.
       *
       * The return value should be the generated part name as a string, or multiple part names
       * separated by whitespace characters.
       *
       * Receives two arguments:
       * - `column` The `<vaadin-grid-column>` element (`undefined` for details-cell).
       * - `model` The object with the properties related with
       *   the rendered item, contains:
       *   - `model.index` The index of the item.
       *   - `model.item` The item.
       *   - `model.expanded` Sublevel toggle state.
       *   - `model.level` Level of the tree represented with a horizontal offset of the toggle button.
       *   - `model.selected` Selected state.
       *
       * @type {GridCellPartNameGenerator | null | undefined}
       */
      cellPartNameGenerator: {
        type: Function,
        sync: !0
      }
    };
  }
  static get observers() {
    return [
      "__cellClassNameGeneratorChanged(cellClassNameGenerator)",
      "__cellPartNameGeneratorChanged(cellPartNameGenerator)"
    ];
  }
  /** @private */
  __cellClassNameGeneratorChanged() {
    this.generateCellClassNames();
  }
  /** @private */
  __cellPartNameGeneratorChanged() {
    this.generateCellPartNames();
  }
  /**
   * Runs the `cellClassNameGenerator` for the visible cells.
   * If the generator depends on varying conditions, you need to
   * call this function manually in order to update the styles when
   * the conditions change.
   *
   * @deprecated Use `cellPartNameGenerator` and `generateCellPartNames()` instead.
   */
  generateCellClassNames() {
    dt(this.$.items, (e) => {
      e.hidden || this._generateCellClassNames(e, this.__getRowModel(e));
    });
  }
  /**
   * Runs the `cellPartNameGenerator` for the visible cells.
   * If the generator depends on varying conditions, you need to
   * call this function manually in order to update the styles when
   * the conditions change.
   */
  generateCellPartNames() {
    dt(this.$.items, (e) => {
      e.hidden || this._generateCellPartNames(e, this.__getRowModel(e));
    });
  }
  /** @private */
  _generateCellClassNames(e, t) {
    Zi(e, (i) => {
      if (i.__generatedClasses && i.__generatedClasses.forEach((n) => i.classList.remove(n)), this.cellClassNameGenerator && !e.hasAttribute("loading")) {
        const n = this.cellClassNameGenerator(i._column, t);
        i.__generatedClasses = n && n.split(" ").filter((o) => o.length > 0), i.__generatedClasses && i.__generatedClasses.forEach((o) => i.classList.add(o));
      }
    });
  }
  /** @private */
  _generateCellPartNames(e, t) {
    Zi(e, (i) => {
      if (i.__generatedParts && i.__generatedParts.forEach((n) => {
        Qt(i, null, n);
      }), this.cellPartNameGenerator && !e.hasAttribute("loading")) {
        const n = this.cellPartNameGenerator(i._column, t);
        i.__generatedParts = n && n.split(" ").filter((o) => o.length > 0), i.__generatedParts && i.__generatedParts.forEach((o) => {
          Qt(i, !0, o);
        });
      }
    });
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Sp = (s) => class extends Uf(
  lp(
    dp(
      Bf(
        Cp(
          Tp(
            Ep(
              gp(
                pp(
                  Mf(
                    fp(
                      sp(
                        ap(
                          up(hp(Pp(Hc(s))))
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  )
) {
  static get observers() {
    return ["_columnTreeChanged(_columnTree)", "_flatSizeChanged(_flatSize, __virtualizer, _hasData, _columnTree)"];
  }
  static get properties() {
    return {
      /** @private */
      _safari: {
        type: Boolean,
        value: Vc
      },
      /** @private */
      _ios: {
        type: Boolean,
        value: ws
      },
      /** @private */
      _firefox: {
        type: Boolean,
        value: Af
      },
      /** @private */
      _android: {
        type: Boolean,
        value: ml
      },
      /** @private */
      _touchDevice: {
        type: Boolean,
        value: Mr
      },
      /**
       * If true, the grid's height is defined by its rows.
       *
       * Effectively, this disables the grid's virtual scrolling so that all the rows are rendered in the DOM at once.
       * If the grid has a large number of items, using the feature is discouraged to avoid performance issues.
       * @attr {boolean} all-rows-visible
       * @type {boolean}
       */
      allRowsVisible: {
        type: Boolean,
        value: !1,
        reflectToAttribute: !0
      },
      /** @private */
      __pendingRecalculateColumnWidths: {
        type: Boolean,
        value: !0
      },
      /** @private */
      isAttached: {
        value: !1
      },
      /**
       * An internal property that is mainly used by `vaadin-template-renderer`
       * to identify grid elements.
       *
       * @private
       */
      __gridElement: {
        type: Boolean,
        value: !0
      },
      /** @private */
      __hasEmptyStateContent: {
        type: Boolean,
        value: !1
      },
      /** @private */
      __emptyState: {
        type: Boolean,
        computed: "__computeEmptyState(_flatSize, __hasEmptyStateContent)"
      }
    };
  }
  constructor() {
    super(), this.addEventListener("animationend", this._onAnimationEnd);
  }
  /** @private */
  get _firstVisibleIndex() {
    const r = this.__getFirstVisibleItem();
    return r ? r.index : void 0;
  }
  /** @private */
  get _lastVisibleIndex() {
    const r = this.__getLastVisibleItem();
    return r ? r.index : void 0;
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback(), this.isAttached = !0, this.recalculateColumnWidths();
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback(), this.isAttached = !1, this._hideTooltip(!0);
  }
  /** @private */
  __getFirstVisibleItem() {
    return this._getRenderedRows().find((r) => this._isInViewport(r));
  }
  /** @private */
  __getLastVisibleItem() {
    return this._getRenderedRows().reverse().find((r) => this._isInViewport(r));
  }
  /** @private */
  _isInViewport(r) {
    const e = this.$.table.getBoundingClientRect(), t = r.getBoundingClientRect(), i = this.$.header.getBoundingClientRect().height, n = this.$.footer.getBoundingClientRect().height;
    return t.bottom > e.top + i && t.top < e.bottom - n;
  }
  /** @private */
  _getRenderedRows() {
    return Array.from(this.$.items.children).filter((r) => !r.hidden).sort((r, e) => r.index - e.index);
  }
  /** @protected */
  _getRowContainingNode(r) {
    const e = Oc("vaadin-grid-cell-content", r);
    return e ? e.assignedSlot.parentElement.parentElement : void 0;
  }
  /** @protected */
  _isItemAssignedToRow(r, e) {
    const t = this.__getRowModel(e);
    return this.getItemId(r) === this.getItemId(t.item);
  }
  /** @protected */
  ready() {
    super.ready(), this.__virtualizer = new qc({
      createElements: this._createScrollerRows.bind(this),
      updateElement: this._updateScrollerItem.bind(this),
      scrollContainer: this.$.items,
      scrollTarget: this.$.table,
      reorderElements: !0
    }), new ResizeObserver(
      () => setTimeout(() => {
        this.__updateColumnsBodyContentHidden(), this.__tryToRecalculateColumnWidthsIfPending();
      })
    ).observe(this.$.table), Ns(this), this._tooltipController = new jc(this), this.addController(this._tooltipController), this._tooltipController.setManual(!0), this.__emptyStateContentObserver = new Uc(this.$.emptystateslot, ({ currentNodes: r }) => {
      this.$.emptystatecell._content = r[0], this.__hasEmptyStateContent = !!this.$.emptystatecell._content;
    });
  }
  /** @private */
  __getBodyCellCoordinates(r) {
    if (this.$.items.contains(r) && r.localName === "td")
      return {
        item: r.parentElement._item,
        column: r._column
      };
  }
  /** @private */
  __focusBodyCell({ item: r, column: e }) {
    const t = this._getRenderedRows().find((n) => n._item === r), i = t && [...t.children].find((n) => n._column === e);
    i && i.focus();
  }
  /** @protected */
  _focusFirstVisibleRow() {
    const r = this.__getFirstVisibleItem();
    this.__rowFocusMode = !0, r.focus();
  }
  /** @private */
  _flatSizeChanged(r, e, t, i) {
    if (e && t && i) {
      const n = this.shadowRoot.activeElement, o = this.__getBodyCellCoordinates(n), a = e.size || 0;
      e.size = r, e.update(a - 1, a - 1), r < a && e.update(r - 1, r - 1), o && n.parentElement.hidden && this.__focusBodyCell(o), this._resetKeyboardNavigation();
    }
  }
  /** @private */
  __getIntrinsicWidth(r) {
    return this.__intrinsicWidthCache.has(r) || this.__calculateAndCacheIntrinsicWidths([r]), this.__intrinsicWidthCache.get(r);
  }
  /** @private */
  __getDistributedWidth(r, e) {
    if (r == null || r === this)
      return 0;
    const t = Math.max(
      this.__getIntrinsicWidth(r),
      this.__getDistributedWidth((r.assignedSlot || r).parentElement, r)
    );
    if (!e)
      return t;
    const i = r, n = t, o = i._visibleChildColumns.map((d) => this.__getIntrinsicWidth(d)).reduce((d, f) => d + f, 0), a = Math.max(0, n - o), h = this.__getIntrinsicWidth(e) / o * a;
    return this.__getIntrinsicWidth(e) + h;
  }
  /**
   * @param {!Array<!GridColumn>} cols the columns to auto size based on their content width
   * @private
   */
  _recalculateColumnWidths(r) {
    this.__virtualizer.flush(), [...this.$.header.children, ...this.$.footer.children].forEach((i) => {
      i.__debounceUpdateHeaderFooterRowVisibility && i.__debounceUpdateHeaderFooterRowVisibility.flush();
    }), this._debouncerHiddenChanged && this._debouncerHiddenChanged.flush(), this.__intrinsicWidthCache = /* @__PURE__ */ new Map();
    const e = this._firstVisibleIndex, t = this._lastVisibleIndex;
    this.__viewportRowsCache = this._getRenderedRows().filter((i) => i.index >= e && i.index <= t), this.__calculateAndCacheIntrinsicWidths(r), r.forEach((i) => {
      i.width = `${this.__getDistributedWidth(i)}px`;
    });
  }
  /**
   * Toggles the cell content for the given column to use or not use auto width.
   *
   * While content for all the column cells uses auto width (instead of the default 100%),
   * their offsetWidth can be used to calculate the collective intrinsic width of the column.
   *
   * @private
   */
  __setVisibleCellContentAutoWidth(r, e) {
    r._allCells.filter((t) => this.$.items.contains(t) ? this.__viewportRowsCache.includes(t.parentElement) : !0).forEach((t) => {
      t.__measuringAutoWidth = e, t.__measuringAutoWidth ? (t.__originalWidth = t.style.width, t.style.width = "auto", t.style.position = "absolute") : (t.style.width = t.__originalWidth, delete t.__originalWidth, t.style.position = "");
    }), e ? this.$.scroller.setAttribute("measuring-auto-width", "") : this.$.scroller.removeAttribute("measuring-auto-width");
  }
  /**
   * Returns the maximum intrinsic width of the cell content in the given column.
   * Only cells which are marked for measuring auto width are considered.
   *
   * @private
   */
  __getAutoWidthCellsMaxWidth(r) {
    return r._allCells.reduce((e, t) => t.__measuringAutoWidth ? Math.max(e, t.offsetWidth + 1) : e, 0);
  }
  /**
   * Calculates and caches the intrinsic width of each given column.
   *
   * @private
   */
  __calculateAndCacheIntrinsicWidths(r) {
    r.forEach((e) => this.__setVisibleCellContentAutoWidth(e, !0)), r.forEach((e) => {
      const t = this.__getAutoWidthCellsMaxWidth(e);
      this.__intrinsicWidthCache.set(e, t);
    }), r.forEach((e) => this.__setVisibleCellContentAutoWidth(e, !1));
  }
  /**
   * Updates the `width` of all columns which have `autoWidth` set to `true`.
   */
  recalculateColumnWidths() {
    if (!this._columnTree)
      return;
    if (Un(this) || this._dataProviderController.isLoading()) {
      this.__pendingRecalculateColumnWidths = !0;
      return;
    }
    const r = this._getColumns().filter((t) => !t.hidden && t.autoWidth), e = r.filter((t) => !customElements.get(t.localName));
    e.length ? Promise.all(e.map((t) => customElements.whenDefined(t.localName))).then(() => {
      this._recalculateColumnWidths(r);
    }) : this._recalculateColumnWidths(r);
  }
  /** @private */
  __tryToRecalculateColumnWidthsIfPending() {
    if (!this.__pendingRecalculateColumnWidths || Un(this) || this._dataProviderController.isLoading() || [...this.$.items.children].some((t) => t.index === void 0))
      return;
    [...this.$.items.children].some((t) => t.clientHeight > 0) && (this.__pendingRecalculateColumnWidths = !1, this.recalculateColumnWidths());
  }
  /**
   * @protected
   * @override
   */
  _onDataProviderPageLoaded() {
    super._onDataProviderPageLoaded(), this.__tryToRecalculateColumnWidthsIfPending();
  }
  /** @private */
  _createScrollerRows(r) {
    const e = [];
    for (let t = 0; t < r; t++) {
      const i = document.createElement("tr");
      i.setAttribute("part", "row body-row"), i.setAttribute("role", "row"), i.setAttribute("tabindex", "-1"), this._columnTree && this._updateRow(i, this._columnTree[this._columnTree.length - 1], "body", !1, !0), e.push(i);
    }
    return this._columnTree && this._columnTree[this._columnTree.length - 1].forEach((t) => {
      t.isConnected && t._cells && (t._cells = [...t._cells]);
    }), this.__afterCreateScrollerRowsDebouncer = Le.debounce(
      this.__afterCreateScrollerRowsDebouncer,
      Jt,
      () => {
        this._afterScroll(), this.__tryToRecalculateColumnWidthsIfPending();
      }
    ), e;
  }
  /** @private */
  _createCell(r, e) {
    const i = `vaadin-grid-cell-content-${this._contentIndex = this._contentIndex + 1 || 0}`, n = document.createElement("vaadin-grid-cell-content");
    n.setAttribute("slot", i);
    const o = document.createElement(r);
    o.id = i.replace("-content-", "-"), o.setAttribute("role", r === "td" ? "gridcell" : "columnheader"), !ml && !ws && (o.addEventListener("mouseenter", (l) => {
      this.$.scroller.hasAttribute("scrolling") || this._showTooltip(l);
    }), o.addEventListener("mouseleave", () => {
      this._hideTooltip();
    }), o.addEventListener("mousedown", () => {
      this._hideTooltip(!0);
    }));
    const a = document.createElement("slot");
    if (a.setAttribute("name", i), e && e._focusButtonMode) {
      const l = document.createElement("div");
      l.setAttribute("role", "button"), l.setAttribute("tabindex", "-1"), o.appendChild(l), o._focusButton = l, o.focus = function(h) {
        o._focusButton.focus(h);
      }, l.appendChild(a);
    } else
      o.setAttribute("tabindex", "-1"), o.appendChild(a);
    return o._content = n, n.addEventListener("mousedown", () => {
      if (kf) {
        const l = (h) => {
          const d = n.contains(this.getRootNode().activeElement), f = h.composedPath().includes(n);
          !d && f && o.focus({ preventScroll: !0 }), document.removeEventListener("mouseup", l, !0);
        };
        document.addEventListener("mouseup", l, !0);
      } else
        setTimeout(() => {
          n.contains(this.getRootNode().activeElement) || o.focus({ preventScroll: !0 });
        });
    }), o;
  }
  /**
   * @param {!HTMLTableRowElement} row
   * @param {!Array<!GridColumn>} columns
   * @param {?string} section
   * @param {boolean} isColumnRow
   * @param {boolean} noNotify
   * @protected
   */
  _updateRow(r, e, t = "body", i = !1, n = !1) {
    const o = document.createDocumentFragment();
    Zi(r, (a) => {
      a._vacant = !0;
    }), r.innerHTML = "", t === "body" && (r.__cells = [], r.__detailsCell = null), e.filter((a) => !a.hidden).forEach((a, l, h) => {
      let d;
      if (t === "body") {
        a._cells || (a._cells = []), d = a._cells.find((g) => g._vacant), d || (d = this._createCell("td", a), a._onCellKeyDown && d.addEventListener("keydown", a._onCellKeyDown.bind(a)), a._cells.push(d)), d.setAttribute("part", "cell body-cell"), d.__parentRow = r, r.__cells.push(d);
        const f = r === this.$.sizer;
        if ((!a._bodyContentHidden || f) && r.appendChild(d), f && (a._sizerCell = d), l === h.length - 1 && this.rowDetailsRenderer) {
          this._detailsCells || (this._detailsCells = []);
          const g = this._detailsCells.find((w) => w._vacant) || this._createCell("td");
          this._detailsCells.indexOf(g) === -1 && this._detailsCells.push(g), g._content.parentElement || o.appendChild(g._content), this._configureDetailsCell(g), r.appendChild(g), r.__detailsCell = g, this._a11ySetRowDetailsCell(r, g), g._vacant = !1;
        }
        n || (a._cells = [...a._cells]);
      } else {
        const f = t === "header" ? "th" : "td";
        i || a.localName === "vaadin-grid-column-group" ? (d = a[`_${t}Cell`], d || (d = this._createCell(f), a._onCellKeyDown && d.addEventListener("keydown", a._onCellKeyDown.bind(a))), d._column = a, r.appendChild(d), a[`_${t}Cell`] = d) : (a._emptyCells || (a._emptyCells = []), d = a._emptyCells.find((g) => g._vacant) || this._createCell(f), d._column = a, r.appendChild(d), a._emptyCells.indexOf(d) === -1 && a._emptyCells.push(d)), d.part.add("cell", `${t}-cell`);
      }
      d._content.parentElement || o.appendChild(d._content), d._vacant = !1, d._column = a;
    }), t !== "body" && this.__debounceUpdateHeaderFooterRowVisibility(r), this.appendChild(o), this._frozenCellsChanged(), this._updateFirstAndLastColumnForRow(r);
  }
  /**
   * @param {HTMLTableRowElement} row
   * @protected
   */
  __debounceUpdateHeaderFooterRowVisibility(r) {
    r.__debounceUpdateHeaderFooterRowVisibility = Le.debounce(
      r.__debounceUpdateHeaderFooterRowVisibility,
      yt,
      () => this.__updateHeaderFooterRowVisibility(r)
    );
  }
  /**
   * @param {HTMLTableRowElement} row
   * @protected
   */
  __updateHeaderFooterRowVisibility(r) {
    if (!r)
      return;
    const e = Array.from(r.children).filter((t) => {
      const i = t._column;
      if (i._emptyCells && i._emptyCells.indexOf(t) > -1)
        return !1;
      if (r.parentElement === this.$.header) {
        if (i.headerRenderer)
          return !0;
        if (i.header === null)
          return !1;
        if (i.path || i.header !== void 0)
          return !0;
      } else if (i.footerRenderer)
        return !0;
      return !1;
    });
    r.hidden !== !e.length && (r.hidden = !e.length), this._resetKeyboardNavigation();
  }
  /** @private */
  _updateScrollerItem(r, e) {
    this._preventScrollerRotatingCellFocus(r, e), this._columnTree && (this._updateRowOrderParts(r, e), this._a11yUpdateRowRowindex(r, e), this._getItem(e, r));
  }
  /** @private */
  _columnTreeChanged(r) {
    this._renderColumnTree(r), this.recalculateColumnWidths(), this.__updateColumnsBodyContentHidden();
  }
  /** @private */
  _updateRowOrderParts(r, e = r.index) {
    Ni(r, {
      first: e === 0,
      last: e === this._flatSize - 1,
      odd: e % 2 !== 0,
      even: e % 2 === 0
    });
  }
  /** @private */
  _updateRowStateParts(r, { expanded: e, selected: t, detailsOpened: i }) {
    Ni(r, {
      expanded: e,
      collapsed: this.__isRowExpandable(r),
      selected: t,
      "details-opened": i
    });
  }
  /** @private */
  __computeEmptyState(r, e) {
    return r === 0 && e;
  }
  /**
   * @param {!Array<!GridColumn>} columnTree
   * @protected
   */
  _renderColumnTree(r) {
    for (dt(this.$.items, (e) => {
      this._updateRow(e, r[r.length - 1], "body", !1, !0);
      const t = this.__getRowModel(e);
      this._updateRowOrderParts(e), this._updateRowStateParts(e, t), this._filterDragAndDrop(e, t);
    }); this.$.header.children.length < r.length; ) {
      const e = document.createElement("tr");
      e.setAttribute("part", "row"), e.setAttribute("role", "row"), e.setAttribute("tabindex", "-1"), this.$.header.appendChild(e);
      const t = document.createElement("tr");
      t.setAttribute("part", "row"), t.setAttribute("role", "row"), t.setAttribute("tabindex", "-1"), this.$.footer.appendChild(t);
    }
    for (; this.$.header.children.length > r.length; )
      this.$.header.removeChild(this.$.header.firstElementChild), this.$.footer.removeChild(this.$.footer.firstElementChild);
    dt(this.$.header, (e, t, i) => {
      this._updateRow(e, r[t], "header", t === r.length - 1);
      const n = Ki(e);
      Kt(n, "first-header-row-cell", t === 0), Kt(n, "last-header-row-cell", t === i.length - 1);
    }), dt(this.$.footer, (e, t, i) => {
      this._updateRow(e, r[r.length - 1 - t], "footer", t === 0);
      const n = Ki(e);
      Kt(n, "first-footer-row-cell", t === 0), Kt(n, "last-footer-row-cell", t === i.length - 1);
    }), this._updateRow(this.$.sizer, r[r.length - 1]), this._resizeHandler(), this._frozenCellsChanged(), this._updateFirstAndLastColumn(), this._resetKeyboardNavigation(), this._a11yUpdateHeaderRows(), this._a11yUpdateFooterRows(), this.generateCellClassNames(), this.generateCellPartNames(), this.__updateHeaderAndFooter();
  }
  /**
   * @param {!HTMLElement} row
   * @param {GridItem} item
   * @protected
   */
  _updateItem(r, e) {
    r._item = e;
    const t = this.__getRowModel(r);
    this._toggleDetailsCell(r, t.detailsOpened), this._a11yUpdateRowLevel(r, t.level), this._a11yUpdateRowSelected(r, t.selected), this._updateRowStateParts(r, t), this._generateCellClassNames(r, t), this._generateCellPartNames(r, t), this._filterDragAndDrop(r, t), this.__updateDragSourceParts(r, t), dt(r, (i) => {
      if (!(i._column && !i._column.isConnected) && i._renderer) {
        const n = i._column || this;
        i._renderer.call(n, i._content, n, t);
      }
    }), this._updateDetailsCellHeight(r), this._a11yUpdateRowExpanded(r, t.expanded);
  }
  /** @private */
  _resizeHandler() {
    this._updateDetailsCellHeights(), this.__updateHorizontalScrollPosition();
  }
  /** @private */
  _onAnimationEnd(r) {
    r.animationName.indexOf("vaadin-grid-appear") === 0 && (r.stopPropagation(), this.__tryToRecalculateColumnWidthsIfPending(), this._resetKeyboardNavigation(), requestAnimationFrame(() => {
      this.__scrollToPendingIndexes();
    }));
  }
  /**
   * @param {!HTMLTableRowElement} row
   * @return {!GridItemModel}
   * @protected
   */
  __getRowModel(r) {
    return {
      index: r.index,
      item: r._item,
      level: this._getIndexLevel(r.index),
      expanded: this._isExpanded(r._item),
      selected: this._isSelected(r._item),
      detailsOpened: !!this.rowDetailsRenderer && this._isDetailsOpened(r._item)
    };
  }
  /**
   * @param {Event} event
   * @protected
   */
  _showTooltip(r) {
    const e = this._tooltipController.node;
    if (e && e.isConnected) {
      const t = r.target;
      if (!this.__isCellFullyVisible(t))
        return;
      this._tooltipController.setTarget(t), this._tooltipController.setContext(this.getEventContext(r)), e._stateController.open({
        focus: r.type === "focusin",
        hover: r.type === "mouseenter"
      });
    }
  }
  /** @private */
  __isCellFullyVisible(r) {
    if (r.hasAttribute("frozen") || r.hasAttribute("frozen-to-end"))
      return !0;
    let { left: e, right: t } = this.getBoundingClientRect();
    const i = [...r.parentNode.children].find((a) => a.hasAttribute("last-frozen"));
    if (i) {
      const a = i.getBoundingClientRect();
      e = this.__isRTL ? e : a.right, t = this.__isRTL ? a.left : t;
    }
    const n = [...r.parentNode.children].find((a) => a.hasAttribute("first-frozen-to-end"));
    if (n) {
      const a = n.getBoundingClientRect();
      e = this.__isRTL ? a.right : e, t = this.__isRTL ? t : a.left;
    }
    const o = r.getBoundingClientRect();
    return o.left >= e && o.right <= t;
  }
  /** @protected */
  _hideTooltip(r) {
    const e = this._tooltipController && this._tooltipController.node;
    e && e._stateController.close(r);
  }
  /**
   * Requests an update for the content of cells.
   *
   * While performing the update, the following renderers are invoked:
   * - `Grid.rowDetailsRenderer`
   * - `GridColumn.renderer`
   * - `GridColumn.headerRenderer`
   * - `GridColumn.footerRenderer`
   *
   * It is not guaranteed that the update happens immediately (synchronously) after it is requested.
   */
  requestContentUpdate() {
    this.__updateHeaderAndFooter(), this.__updateVisibleRows();
  }
  /** @private */
  __updateHeaderAndFooter() {
    (this._columnTree || []).forEach((r) => {
      r.forEach((e) => {
        e._renderHeaderAndFooter && e._renderHeaderAndFooter();
      });
    });
  }
  /** @protected */
  __updateVisibleRows(r, e) {
    this.__virtualizer && this.__virtualizer.update(r, e);
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const kp = ke`
  @keyframes vaadin-grid-appear {
    to {
      opacity: 1;
    }
  }

  :host {
    display: flex;
    flex-direction: column;
    animation: 1ms vaadin-grid-appear;
    height: 400px;
    flex: 1 1 auto;
    align-self: stretch;
    position: relative;
  }

  :host([hidden]) {
    display: none !important;
  }

  :host([disabled]) {
    pointer-events: none;
  }

  #scroller {
    display: flex;
    flex-direction: column;
    min-height: 100%;
    transform: translateY(0);
    width: auto;
    height: auto;
    position: absolute;
    inset: 0;
  }

  :host([all-rows-visible]) {
    height: auto;
    align-self: flex-start;
    flex-grow: 0;
    width: 100%;
  }

  :host([all-rows-visible]) #scroller {
    width: 100%;
    height: 100%;
    position: relative;
  }

  :host([all-rows-visible]) #items {
    min-height: 1px;
  }

  #table {
    display: flex;
    flex-direction: column;
    width: 100%;
    height: 100%;
    overflow: auto;
    position: relative;
    outline: none;
    /* Workaround for a Desktop Safari bug: new stacking context here prevents the scrollbar from getting hidden */
    z-index: 0;
  }

  #header,
  #footer {
    display: block;
    position: -webkit-sticky;
    position: sticky;
    left: 0;
    overflow: visible;
    width: 100%;
    z-index: 1;
  }

  #header {
    top: 0;
  }

  th {
    text-align: inherit;
  }

  /* Safari doesn't work with "inherit" */
  [safari] th {
    text-align: initial;
  }

  #footer {
    bottom: 0;
  }

  #items {
    flex-grow: 1;
    flex-shrink: 0;
    display: block;
    position: -webkit-sticky;
    position: sticky;
    width: 100%;
    left: 0;
    overflow: visible;
  }

  [part~='row'] {
    display: flex;
    width: 100%;
    box-sizing: border-box;
    margin: 0;
  }

  [part~='row'][loading] [part~='body-cell'] ::slotted(vaadin-grid-cell-content) {
    visibility: hidden;
  }

  [column-rendering='lazy'] [part~='body-cell']:not([frozen]):not([frozen-to-end]) {
    transform: translateX(var(--_grid-lazy-columns-start));
  }

  #items [part~='row'] {
    position: absolute;
  }

  #items [part~='row']:empty {
    height: 100%;
  }

  [part~='cell']:not([part~='details-cell']) {
    flex-shrink: 0;
    flex-grow: 1;
    box-sizing: border-box;
    display: flex;
    width: 100%;
    position: relative;
    align-items: center;
    padding: 0;
    white-space: nowrap;
  }

  [part~='cell'] {
    outline: none;
  }

  [part~='cell'] > [tabindex] {
    display: flex;
    align-items: inherit;
    outline: none;
    position: absolute;
    inset: 0;
  }

  /* Switch the focusButtonMode wrapping element to "position: static" temporarily
     when measuring real width of the cells in the auto-width columns. */
  [measuring-auto-width] [part~='cell'] > [tabindex] {
    position: static;
  }

  [part~='details-cell'] {
    position: absolute;
    bottom: 0;
    width: 100%;
    box-sizing: border-box;
    padding: 0;
  }

  [part~='cell'] ::slotted(vaadin-grid-cell-content) {
    display: block;
    width: 100%;
    box-sizing: border-box;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  [hidden] {
    display: none !important;
  }

  [frozen],
  [frozen-to-end] {
    z-index: 2;
    will-change: transform;
  }

  [no-scrollbars][safari] #table,
  [no-scrollbars][firefox] #table {
    overflow: hidden;
  }

  /* Empty state */

  #scroller:not([empty-state]) #emptystatebody,
  #scroller[empty-state] #items {
    display: none;
  }

  #emptystatebody {
    display: flex;
    position: sticky;
    inset: 0;
    flex: 1;
    overflow: hidden;
  }

  #emptystaterow {
    display: flex;
    flex: 1;
  }

  #emptystatecell {
    display: block;
    flex: 1;
    overflow: auto;
  }

  /* Reordering styles */
  :host([reordering]) [part~='cell'] ::slotted(vaadin-grid-cell-content),
  :host([reordering]) [part~='resize-handle'],
  #scroller[no-content-pointer-events] [part~='cell'] ::slotted(vaadin-grid-cell-content) {
    pointer-events: none;
  }

  [part~='reorder-ghost'] {
    visibility: hidden;
    position: fixed;
    pointer-events: none;
    opacity: 0.5;

    /* Prevent overflowing the grid in Firefox */
    top: 0;
    left: 0;
  }

  :host([reordering]) {
    -moz-user-select: none;
    -webkit-user-select: none;
    user-select: none;
  }

  /* Resizing styles */
  [part~='resize-handle'] {
    position: absolute;
    top: 0;
    right: 0;
    height: 100%;
    cursor: col-resize;
    z-index: 1;
  }

  [part~='resize-handle']::before {
    position: absolute;
    content: '';
    height: 100%;
    width: 35px;
    transform: translateX(-50%);
  }

  [last-column] [part~='resize-handle']::before,
  [last-frozen] [part~='resize-handle']::before {
    width: 18px;
    transform: none;
    right: 0;
  }

  [frozen-to-end] [part~='resize-handle'] {
    left: 0;
    right: auto;
  }

  [frozen-to-end] [part~='resize-handle']::before {
    left: 0;
    right: auto;
  }

  [first-frozen-to-end] [part~='resize-handle']::before {
    width: 18px;
    transform: none;
  }

  [first-frozen-to-end] {
    margin-inline-start: auto;
  }

  /* Hide resize handle if scrolled to end */
  :host(:not([overflow~='end'])) [first-frozen-to-end] [part~='resize-handle'] {
    display: none;
  }

  #scroller[column-resizing] {
    -ms-user-select: none;
    -moz-user-select: none;
    -webkit-user-select: none;
    user-select: none;
  }

  /* Sizer styles */
  #sizer {
    display: flex;
    position: absolute;
    visibility: hidden;
  }

  #sizer [part~='details-cell'] {
    display: none !important;
  }

  #sizer [part~='cell'][hidden] {
    display: none !important;
  }

  #sizer [part~='cell'] {
    display: block;
    flex-shrink: 0;
    line-height: 0;
    height: 0 !important;
    min-height: 0 !important;
    max-height: 0 !important;
    padding: 0 !important;
    border: none !important;
  }

  #sizer [part~='cell']::before {
    content: '-';
  }

  #sizer [part~='cell'] ::slotted(vaadin-grid-cell-content) {
    display: none !important;
  }

  /* RTL specific styles */

  :host([dir='rtl']) #items,
  :host([dir='rtl']) #header,
  :host([dir='rtl']) #footer {
    left: auto;
  }

  :host([dir='rtl']) [part~='reorder-ghost'] {
    left: auto;
    right: 0;
  }

  :host([dir='rtl']) [part~='resize-handle'] {
    left: 0;
    right: auto;
  }

  :host([dir='rtl']) [part~='resize-handle']::before {
    transform: translateX(50%);
  }

  :host([dir='rtl']) [last-column] [part~='resize-handle']::before,
  :host([dir='rtl']) [last-frozen] [part~='resize-handle']::before {
    left: 0;
    right: auto;
  }

  :host([dir='rtl']) [frozen-to-end] [part~='resize-handle'] {
    right: 0;
    left: auto;
  }

  :host([dir='rtl']) [frozen-to-end] [part~='resize-handle']::before {
    right: 0;
    left: auto;
  }

  @media (forced-colors: active) {
    [part~='selected-row'] [part~='first-column-cell']::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      bottom: 0;
      border: 2px solid;
    }

    [part~='focused-cell']::before {
      outline: 2px solid !important;
      outline-offset: -1px;
    }
  }
`;
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
Ke("vaadin-grid", kp, { moduleId: "vaadin-grid-styles" });
class Ap extends Sp(Fc(Vr(Wr(Pi)))) {
  static get template() {
    return er`
      <div
        id="scroller"
        safari$="[[_safari]]"
        ios$="[[_ios]]"
        loading$="[[loading]]"
        column-reordering-allowed$="[[columnReorderingAllowed]]"
        empty-state$="[[__emptyState]]"
      >
        <table id="table" role="treegrid" aria-multiselectable="true" tabindex="0">
          <caption id="sizer" part="row"></caption>
          <thead id="header" role="rowgroup"></thead>
          <tbody id="items" role="rowgroup"></tbody>
          <tbody id="emptystatebody">
            <tr id="emptystaterow">
              <td part="empty-state" id="emptystatecell" tabindex="0">
                <slot name="empty-state" id="emptystateslot"></slot>
              </td>
            </tr>
          </tbody>
          <tfoot id="footer" role="rowgroup"></tfoot>
        </table>

        <div part="reorder-ghost"></div>
      </div>

      <slot name="tooltip"></slot>

      <div id="focusexit" tabindex="0"></div>
    `;
  }
  static get is() {
    return "vaadin-grid";
  }
}
$t(Ap);
const nh = ke`
  :host {
    display: flex;
    align-items: center;
    box-sizing: border-box;
    font-family: var(--lumo-font-family);
    font-size: var(--lumo-font-size-m);
    line-height: var(--lumo-line-height-xs);
    padding: 0.5em calc(var(--lumo-space-l) + var(--lumo-border-radius-m) / 4) 0.5em
      var(--_lumo-list-box-item-padding-left, calc(var(--lumo-border-radius-m) / 4));
    min-height: var(--lumo-size-m);
    outline: none;
    border-radius: var(--lumo-border-radius-m);
    cursor: var(--lumo-clickable-cursor);
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    -webkit-tap-highlight-color: var(--lumo-primary-color-10pct);
    --_focus-ring-color: var(--vaadin-focus-ring-color, var(--lumo-primary-color-50pct));
    --_focus-ring-width: var(--vaadin-focus-ring-width, 2px);
    --_selection-color-text: var(--vaadin-selection-color-text, var(--lumo-primary-text-color));
  }

  /* Checkmark */
  [part='checkmark']::before {
    display: var(--_lumo-item-selected-icon-display, none);
    content: var(--lumo-icons-checkmark);
    font-family: lumo-icons;
    font-size: var(--lumo-icon-size-m);
    line-height: 1;
    font-weight: normal;
    width: 1em;
    height: 1em;
    margin: calc((1 - var(--lumo-line-height-xs)) * var(--lumo-font-size-m) / 2) 0;
    color: var(--_selection-color-text);
    flex: none;
    opacity: 0;
    transition:
      transform 0.2s cubic-bezier(0.12, 0.32, 0.54, 2),
      opacity 0.1s;
  }

  :host([selected]) [part='checkmark']::before {
    opacity: 1;
  }

  :host([active]:not([selected])) [part='checkmark']::before {
    transform: scale(0.8);
    opacity: 0;
    transition-duration: 0s;
  }

  [part='content'] {
    flex: auto;
  }

  /* Disabled */
  :host([disabled]) {
    color: var(--lumo-disabled-text-color);
    cursor: default;
    pointer-events: none;
  }

  /* TODO a workaround until we have "focus-follows-mouse". After that, use the hover style for focus-ring as well */
  @media (any-hover: hover) {
    :host(:hover:not([disabled])) {
      background-color: var(--lumo-primary-color-10pct);
    }
  }

  :host([focus-ring]:not([disabled])) {
    box-shadow: inset 0 0 0 var(--_focus-ring-width) var(--_focus-ring-color);
  }

  /* RTL specific styles */
  :host([dir='rtl']) {
    padding-left: calc(var(--lumo-space-l) + var(--lumo-border-radius-m) / 4);
    padding-right: var(--_lumo-list-box-item-padding-left, calc(var(--lumo-border-radius-m) / 4));
  }

  /* Slotted icons */
  :host ::slotted(vaadin-icon) {
    width: var(--lumo-icon-size-m);
    height: var(--lumo-icon-size-m);
  }
`;
Ke("vaadin-item", nh, { moduleId: "lumo-item" });
const Rp = ke`
  :host {
    transition: background-color 100ms;
    overflow: hidden;
    --_lumo-item-selected-icon-display: block;
    --_focus-ring-color: var(--vaadin-focus-ring-color, var(--lumo-primary-color-50pct));
    --_focus-ring-width: var(--vaadin-focus-ring-width, 2px);
  }

  :host([focused]:not([disabled])) {
    box-shadow: inset 0 0 0 var(--_focus-ring-width) var(--_focus-ring-color);
  }
`;
Ke("vaadin-combo-box-item", [nh, Rp], {
  moduleId: "lumo-combo-box-item"
});
/**
 * @license
 * Copyright (c) 2022 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Ip = ke`
  [part~='loader'] {
    box-sizing: border-box;
    width: var(--lumo-icon-size-s);
    height: var(--lumo-icon-size-s);
    border: 2px solid transparent;
    border-color: var(--lumo-primary-color-10pct) var(--lumo-primary-color-10pct) var(--lumo-primary-color)
      var(--lumo-primary-color);
    border-radius: calc(0.5 * var(--lumo-icon-size-s));
    opacity: 0;
    pointer-events: none;
  }

  :host(:not([loading])) [part~='loader'] {
    display: none;
  }

  :host([loading]) [part~='loader'] {
    animation:
      1s linear infinite lumo-loader-rotate,
      0.3s 0.1s lumo-loader-fade-in both;
  }

  @keyframes lumo-loader-fade-in {
    0% {
      opacity: 0;
    }

    100% {
      opacity: 1;
    }
  }

  @keyframes lumo-loader-rotate {
    0% {
      transform: rotate(0deg);
    }

    100% {
      transform: rotate(360deg);
    }
  }
`;
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const $s = ke`
  :host {
    top: var(--lumo-space-m);
    right: var(--lumo-space-m);
    bottom: var(--lumo-space-m);
    left: var(--lumo-space-m);
    /* Workaround for Edge issue (only on Surface), where an overflowing vaadin-list-box inside vaadin-select-overlay makes the overlay transparent */
    /* stylelint-disable-next-line */
    outline: 0px solid transparent;
  }

  [part='overlay'] {
    background-color: var(--lumo-base-color);
    background-image: linear-gradient(var(--lumo-tint-5pct), var(--lumo-tint-5pct));
    border-radius: var(--lumo-border-radius-m);
    box-shadow:
      0 0 0 1px var(--lumo-shade-5pct),
      var(--lumo-box-shadow-m);
    color: var(--lumo-body-text-color);
    font-family: var(--lumo-font-family);
    font-size: var(--lumo-font-size-m);
    font-weight: 400;
    line-height: var(--lumo-line-height-m);
    letter-spacing: 0;
    text-transform: none;
    -webkit-text-size-adjust: 100%;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }

  [part='content'] {
    padding: var(--lumo-space-xs);
  }

  [part='backdrop'] {
    background-color: var(--lumo-shade-20pct);
    animation: 0.2s lumo-overlay-backdrop-enter both;
    will-change: opacity;
  }

  @keyframes lumo-overlay-backdrop-enter {
    0% {
      opacity: 0;
    }
  }

  :host([closing]) [part='backdrop'] {
    animation: 0.2s lumo-overlay-backdrop-exit both;
  }

  @keyframes lumo-overlay-backdrop-exit {
    100% {
      opacity: 0;
    }
  }

  @keyframes lumo-overlay-dummy-animation {
    0% {
      opacity: 1;
    }

    100% {
      opacity: 1;
    }
  }
`;
Ke("", $s, { moduleId: "lumo-overlay" });
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const ea = ke`
  :host([opening]),
  :host([closing]) {
    animation: 0.14s lumo-overlay-dummy-animation;
  }

  [part='overlay'] {
    will-change: opacity, transform;
  }

  :host([opening]) [part='overlay'] {
    animation: 0.1s lumo-menu-overlay-enter ease-out both;
  }

  @keyframes lumo-menu-overlay-enter {
    0% {
      opacity: 0;
      transform: translateY(-4px);
    }
  }

  :host([closing]) [part='overlay'] {
    animation: 0.1s lumo-menu-overlay-exit both;
  }

  @keyframes lumo-menu-overlay-exit {
    100% {
      opacity: 0;
    }
  }
`;
Ke("", ea, { moduleId: "lumo-menu-overlay-core" });
const Dp = ke`
  /* Small viewport (bottom sheet) styles */
  /* Use direct media queries instead of the state attributes ([phone] and [fullscreen]) provided by the elements */
  @media (max-width: 420px), (max-height: 420px) {
    :host {
      top: 0 !important;
      right: 0 !important;
      bottom: var(--vaadin-overlay-viewport-bottom, 0) !important;
      left: 0 !important;
      align-items: stretch !important;
      justify-content: flex-end !important;
    }

    [part='overlay'] {
      max-height: 50vh;
      width: 100vw;
      border-radius: 0;
      box-shadow: var(--lumo-box-shadow-xl);
    }

    /* The content part scrolls instead of the overlay part, because of the gradient fade-out */
    [part='content'] {
      padding: 30px var(--lumo-space-m);
      max-height: inherit;
      box-sizing: border-box;
      -webkit-overflow-scrolling: touch;
      overflow: auto;
      -webkit-mask-image: linear-gradient(transparent, #000 40px, #000 calc(100% - 40px), transparent);
      mask-image: linear-gradient(transparent, #000 40px, #000 calc(100% - 40px), transparent);
    }

    [part='backdrop'] {
      display: block;
    }

    /* Animations */

    :host([opening]) [part='overlay'] {
      animation: 0.2s lumo-mobile-menu-overlay-enter cubic-bezier(0.215, 0.61, 0.355, 1) both;
    }

    :host([closing]),
    :host([closing]) [part='backdrop'] {
      animation-delay: 0.14s;
    }

    :host([closing]) [part='overlay'] {
      animation: 0.14s 0.14s lumo-mobile-menu-overlay-exit cubic-bezier(0.55, 0.055, 0.675, 0.19) both;
    }
  }

  @keyframes lumo-mobile-menu-overlay-enter {
    0% {
      transform: translateY(150%);
    }
  }

  @keyframes lumo-mobile-menu-overlay-exit {
    100% {
      transform: translateY(150%);
    }
  }
`, Op = [$s, ea, Dp];
Ke("", Op, { moduleId: "lumo-menu-overlay" });
const zp = ke`
  [part='content'] {
    padding: 0;
  }

  /* When items are empty, the spinner needs some room */
  :host(:not([closing])) [part~='content'] {
    min-height: calc(2 * var(--lumo-space-s) + var(--lumo-icon-size-s));
  }

  [part~='overlay'] {
    position: relative;
  }

  :host([top-aligned]) [part~='overlay'] {
    margin-top: var(--lumo-space-xs);
  }

  :host([bottom-aligned]) [part~='overlay'] {
    margin-bottom: var(--lumo-space-xs);
  }
`, Fp = ke`
  [part~='loader'] {
    position: absolute;
    z-index: 1;
    inset-inline: var(--lumo-space-s);
    top: var(--lumo-space-s);
    margin-inline: auto 0;
  }
`;
Ke(
  "vaadin-combo-box-overlay",
  [
    $s,
    ea,
    zp,
    Ip,
    Fp,
    ke`
      :host {
        --_vaadin-combo-box-items-container-border-width: var(--lumo-space-xs);
        --_vaadin-combo-box-items-container-border-style: solid;
      }
    `
  ],
  { moduleId: "lumo-combo-box-overlay" }
);
Ke(
  "vaadin-input-container",
  ke`
    :host {
      background: var(--_background);
      padding: 0 calc(0.375em + var(--_input-container-radius) / 4 - 1px);
      font-weight: var(--vaadin-input-field-value-font-weight, 500);
      line-height: 1;
      position: relative;
      cursor: text;
      box-sizing: border-box;
      border-radius:
        /* See https://developer.mozilla.org/en-US/docs/Web/CSS/border-radius#syntax */
        var(--vaadin-input-field-top-start-radius, var(--_input-container-radius))
        var(--vaadin-input-field-top-end-radius, var(--_input-container-radius))
        var(--vaadin-input-field-bottom-end-radius, var(--_input-container-radius))
        var(--vaadin-input-field-bottom-start-radius, var(--_input-container-radius));
      /* Fallback */
      --_input-container-radius: var(--vaadin-input-field-border-radius, var(--lumo-border-radius-m));
      --_input-height: var(--lumo-text-field-size, var(--lumo-size-m));
      /* Default values */
      --_background: var(--vaadin-input-field-background, var(--lumo-contrast-10pct));
      --_hover-highlight: var(--vaadin-input-field-hover-highlight, var(--lumo-contrast-50pct));
      --_input-border-color: var(--vaadin-input-field-border-color, var(--lumo-contrast-50pct));
      --_icon-color: var(--vaadin-input-field-icon-color, var(--lumo-contrast-60pct));
      --_icon-size: var(--vaadin-input-field-icon-size, var(--lumo-icon-size-m));
      --_invalid-background: var(--vaadin-input-field-invalid-background, var(--lumo-error-color-10pct));
      --_invalid-hover-highlight: var(--vaadin-input-field-invalid-hover-highlight, var(--lumo-error-color-50pct));
      --_disabled-background: var(--vaadin-input-field-disabled-background, var(--lumo-contrast-5pct));
      --_disabled-value-color: var(--vaadin-input-field-disabled-value-color, var(--lumo-disabled-text-color));
    }

    :host([dir='rtl']) {
      border-radius:
        /* Don't use logical props, see https://github.com/vaadin/vaadin-time-picker/issues/145 */
        var(--vaadin-input-field-top-end-radius, var(--_input-container-radius))
        var(--vaadin-input-field-top-start-radius, var(--_input-container-radius))
        var(--vaadin-input-field-bottom-start-radius, var(--_input-container-radius))
        var(--vaadin-input-field-bottom-end-radius, var(--_input-container-radius));
    }

    /* Used for hover and activation effects */
    :host::after {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: inherit;
      pointer-events: none;
      background: var(--_hover-highlight);
      opacity: 0;
      transition:
        transform 0.15s,
        opacity 0.2s;
      transform-origin: 100% 0;
    }

    ::slotted(:not([slot$='fix'])) {
      cursor: inherit;
      min-height: var(--vaadin-input-field-height, var(--_input-height));
      padding: 0 0.25em;
      --_lumo-text-field-overflow-mask-image: linear-gradient(to left, transparent, #000 1.25em);
      -webkit-mask-image: var(--_lumo-text-field-overflow-mask-image);
      mask-image: var(--_lumo-text-field-overflow-mask-image);
    }

    /* Read-only */
    :host([readonly]) {
      color: var(--lumo-secondary-text-color);
      background-color: transparent;
      cursor: default;
    }

    :host([readonly])::after {
      background-color: transparent;
      opacity: 1;
      border: var(--vaadin-input-field-readonly-border, 1px dashed var(--lumo-contrast-30pct));
    }

    /* Disabled */
    :host([disabled]) {
      background: var(--_disabled-background);
    }

    :host([disabled]) ::slotted(:not([slot$='fix'])) {
      -webkit-text-fill-color: var(--_disabled-value-color);
      color: var(--_disabled-value-color);
    }

    /* Invalid */
    :host([invalid]) {
      background: var(--_invalid-background);
    }

    :host([invalid]:not([readonly]))::after {
      background: var(--_invalid-hover-highlight);
    }

    /* Slotted icons */
    ::slotted(vaadin-icon) {
      color: var(--_icon-color);
      width: var(--_icon-size);
      height: var(--_icon-size);
    }

    /* Vaadin icons are based on a 16x16 grid (unlike Lumo and Material icons with 24x24), so they look too big by default */
    ::slotted(vaadin-icon[icon^='vaadin:']) {
      padding: 0.25em;
      box-sizing: border-box !important;
    }

    /* Text align */
    :host([dir='rtl']) ::slotted(:not([slot$='fix'])) {
      --_lumo-text-field-overflow-mask-image: linear-gradient(to right, transparent, #000 1.25em);
    }

    @-moz-document url-prefix() {
      :host([dir='rtl']) ::slotted(:not([slot$='fix'])) {
        mask-image: var(--_lumo-text-field-overflow-mask-image);
      }
    }

    :host([theme~='align-left']) ::slotted(:not([slot$='fix'])) {
      text-align: start;
      --_lumo-text-field-overflow-mask-image: none;
    }

    :host([theme~='align-center']) ::slotted(:not([slot$='fix'])) {
      text-align: center;
      --_lumo-text-field-overflow-mask-image: none;
    }

    :host([theme~='align-right']) ::slotted(:not([slot$='fix'])) {
      text-align: end;
      --_lumo-text-field-overflow-mask-image: none;
    }

    @-moz-document url-prefix() {
      /* Firefox is smart enough to align overflowing text to right */
      :host([theme~='align-right']) ::slotted(:not([slot$='fix'])) {
        --_lumo-text-field-overflow-mask-image: linear-gradient(to right, transparent 0.25em, #000 1.5em);
      }
    }

    @-moz-document url-prefix() {
      /* Firefox is smart enough to align overflowing text to right */
      :host([theme~='align-left']) ::slotted(:not([slot$='fix'])) {
        --_lumo-text-field-overflow-mask-image: linear-gradient(to left, transparent 0.25em, #000 1.5em);
      }
    }

    /* RTL specific styles */
    :host([dir='rtl'])::after {
      transform-origin: 0% 0;
    }

    :host([theme~='align-left'][dir='rtl']) ::slotted(:not([slot$='fix'])) {
      --_lumo-text-field-overflow-mask-image: none;
    }

    :host([theme~='align-center'][dir='rtl']) ::slotted(:not([slot$='fix'])) {
      --_lumo-text-field-overflow-mask-image: none;
    }

    :host([theme~='align-right'][dir='rtl']) ::slotted(:not([slot$='fix'])) {
      --_lumo-text-field-overflow-mask-image: none;
    }

    @-moz-document url-prefix() {
      /* Firefox is smart enough to align overflowing text to right */
      :host([theme~='align-right'][dir='rtl']) ::slotted(:not([slot$='fix'])) {
        --_lumo-text-field-overflow-mask-image: linear-gradient(to right, transparent 0.25em, #000 1.5em);
      }
    }

    @-moz-document url-prefix() {
      /* Firefox is smart enough to align overflowing text to right */
      :host([theme~='align-left'][dir='rtl']) ::slotted(:not([slot$='fix'])) {
        --_lumo-text-field-overflow-mask-image: linear-gradient(to left, transparent 0.25em, #000 1.5em);
      }
    }
  `,
  { moduleId: "lumo-input-container" }
);
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const oh = ke`
  [part$='button'] {
    flex: none;
    width: 1em;
    height: 1em;
    line-height: 1;
    font-size: var(--lumo-icon-size-m);
    text-align: center;
    color: var(--lumo-contrast-60pct);
    transition: 0.2s color;
    cursor: var(--lumo-clickable-cursor);
  }

  [part$='button']:hover {
    color: var(--lumo-contrast-90pct);
  }

  :host([disabled]) [part$='button'],
  :host([readonly]) [part$='button'] {
    color: var(--lumo-contrast-20pct);
    cursor: default;
  }

  [part$='button']::before {
    font-family: 'lumo-icons';
    display: block;
  }
`;
Ke("", oh, { moduleId: "lumo-field-button" });
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Mp = ke`
  :host {
    --_helper-spacing: var(--vaadin-input-field-helper-spacing, 0.4em);
  }

  :host([has-helper]) [part='helper-text']::before {
    content: '';
    display: block;
    height: var(--_helper-spacing);
  }

  [part='helper-text'] {
    display: block;
    color: var(--vaadin-input-field-helper-color, var(--lumo-secondary-text-color));
    font-size: var(--vaadin-input-field-helper-font-size, var(--lumo-font-size-xs));
    line-height: var(--lumo-line-height-xs);
    font-weight: var(--vaadin-input-field-helper-font-weight, 400);
    margin-left: calc(var(--lumo-border-radius-m) / 4);
    transition: color 0.2s;
  }

  :host(:hover:not([readonly])) [part='helper-text'] {
    color: var(--lumo-body-text-color);
  }

  :host([disabled]) [part='helper-text'] {
    color: var(--lumo-disabled-text-color);
    -webkit-text-fill-color: var(--lumo-disabled-text-color);
  }

  :host([has-helper][theme~='helper-above-field']) [part='helper-text']::before {
    display: none;
  }

  :host([has-helper][theme~='helper-above-field']) [part='helper-text']::after {
    content: '';
    display: block;
    height: var(--_helper-spacing);
  }

  :host([has-helper][theme~='helper-above-field']) [part='label'] {
    order: 0;
    padding-bottom: var(--_helper-spacing);
  }

  :host([has-helper][theme~='helper-above-field']) [part='helper-text'] {
    order: 1;
  }

  :host([has-helper][theme~='helper-above-field']) [part='label'] + * {
    order: 2;
  }

  :host([has-helper][theme~='helper-above-field']) [part='error-message'] {
    order: 3;
  }
`;
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const sh = ke`
  [part='label'] {
    align-self: flex-start;
    color: var(--vaadin-input-field-label-color, var(--lumo-secondary-text-color));
    font-weight: var(--vaadin-input-field-label-font-weight, 500);
    font-size: var(--vaadin-input-field-label-font-size, var(--lumo-font-size-s));
    margin-left: calc(var(--lumo-border-radius-m) / 4);
    transition: color 0.2s;
    line-height: 1;
    padding-right: 1em;
    padding-bottom: 0.5em;
    /* As a workaround for diacritics being cut off, add a top padding and a
    negative margin to compensate */
    padding-top: 0.25em;
    margin-top: -0.25em;
    overflow: hidden;
    white-space: nowrap;
    text-overflow: ellipsis;
    position: relative;
    max-width: 100%;
    box-sizing: border-box;
  }

  :host([focused]:not([readonly])) [part='label'] {
    color: var(--vaadin-input-field-focused-label-color, var(--lumo-primary-text-color));
  }

  :host(:hover:not([readonly]):not([focused])) [part='label'] {
    color: var(--vaadin-input-field-hovered-label-color, var(--lumo-body-text-color));
  }

  /* Touch device adjustment */
  @media (pointer: coarse) {
    :host(:hover:not([readonly]):not([focused])) [part='label'] {
      color: var(--vaadin-input-field-label-color, var(--lumo-secondary-text-color));
    }
  }

  :host([has-label])::before {
    margin-top: calc(var(--lumo-font-size-s) * 1.5);
  }

  :host([has-label][theme~='small'])::before {
    margin-top: calc(var(--lumo-font-size-xs) * 1.5);
  }

  :host([has-label]) {
    padding-top: var(--lumo-space-m);
  }

  :host([has-label]) ::slotted([slot='tooltip']) {
    --vaadin-tooltip-offset-bottom: calc((var(--lumo-space-m) - var(--lumo-space-xs)) * -1);
  }

  :host([required]) [part='required-indicator']::after {
    content: var(--lumo-required-field-indicator, '\\2022');
    transition: opacity 0.2s;
    color: var(--lumo-required-field-indicator-color, var(--lumo-primary-text-color));
    position: absolute;
    right: 0;
    width: 1em;
    text-align: center;
  }

  :host([invalid]) [part='required-indicator']::after {
    color: var(--lumo-required-field-indicator-color, var(--lumo-error-text-color));
  }

  [part='error-message'] {
    margin-left: calc(var(--lumo-border-radius-m) / 4);
    font-size: var(--vaadin-input-field-error-font-size, var(--lumo-font-size-xs));
    line-height: var(--lumo-line-height-xs);
    font-weight: var(--vaadin-input-field-error-font-weight, 400);
    color: var(--vaadin-input-field-error-color, var(--lumo-error-text-color));
    will-change: max-height;
    transition: 0.4s max-height;
    max-height: 5em;
  }

  :host([has-error-message]) [part='error-message']::before,
  :host([has-error-message]) [part='error-message']::after {
    content: '';
    display: block;
    height: 0.4em;
  }

  :host(:not([invalid])) [part='error-message'] {
    max-height: 0;
    overflow: hidden;
  }

  /* RTL specific styles */

  :host([dir='rtl']) [part='label'] {
    margin-left: 0;
    margin-right: calc(var(--lumo-border-radius-m) / 4);
  }

  :host([dir='rtl']) [part='label'] {
    padding-left: 1em;
    padding-right: 0;
  }

  :host([dir='rtl']) [part='required-indicator']::after {
    right: auto;
    left: 0;
  }

  :host([dir='rtl']) [part='error-message'] {
    margin-left: 0;
    margin-right: calc(var(--lumo-border-radius-m) / 4);
  }
`;
Ke("", sh, { moduleId: "lumo-required-field" });
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Lp = ke`
  :host {
    --lumo-text-field-size: var(--lumo-size-m);
    color: var(--vaadin-input-field-value-color, var(--lumo-body-text-color));
    font-size: var(--vaadin-input-field-value-font-size, var(--lumo-font-size-m));
    font-family: var(--lumo-font-family);
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    -webkit-tap-highlight-color: transparent;
    padding: var(--lumo-space-xs) 0;
    --_focus-ring-color: var(--vaadin-focus-ring-color, var(--lumo-primary-color-50pct));
    --_focus-ring-width: var(--vaadin-focus-ring-width, 2px);
    --_input-height: var(--vaadin-input-field-height, var(--lumo-text-field-size));
    --_disabled-value-color: var(--vaadin-input-field-disabled-value-color, var(--lumo-disabled-text-color));
  }

  :host::before {
    height: var(--_input-height);
    box-sizing: border-box;
    display: inline-flex;
    align-items: center;
  }

  :host([focused]) [part='input-field'] ::slotted(:is(input, textarea)) {
    -webkit-mask-image: none;
    mask-image: none;
  }

  ::slotted(:is(input, textarea):placeholder-shown) {
    color: var(--vaadin-input-field-placeholder-color, var(--lumo-secondary-text-color));
  }

  /* Hover */
  :host(:hover:not([readonly]):not([focused])) [part='input-field']::after {
    opacity: var(--vaadin-input-field-hover-highlight-opacity, 0.1);
  }

  /* Touch device adjustment */
  @media (pointer: coarse) {
    :host(:hover:not([readonly]):not([focused])) [part='input-field']::after {
      opacity: 0;
    }

    :host(:active:not([readonly]):not([focused])) [part='input-field']::after {
      opacity: 0.2;
    }
  }

  /* Trigger when not focusing using the keyboard */
  :host([focused]:not([focus-ring]):not([readonly])) [part='input-field']::after {
    transform: scaleX(0);
    transition-duration: 0.15s, 1s;
  }

  /* Focus-ring */
  :host([focus-ring]) [part='input-field'] {
    box-shadow: 0 0 0 var(--_focus-ring-width) var(--_focus-ring-color);
  }

  /* Read-only and disabled */
  :host(:is([readonly], [disabled])) ::slotted(:is(input, textarea):placeholder-shown) {
    opacity: 0;
  }

  /* Read-only style */
  :host([readonly]) {
    --vaadin-input-field-border-color: transparent;
  }

  /* Disabled style */
  :host([disabled]) {
    pointer-events: none;
    --vaadin-input-field-border-color: var(--lumo-contrast-20pct);
  }

  :host([disabled]) [part='label'],
  :host([disabled]) [part='input-field'] ::slotted([slot$='fix']) {
    color: var(--lumo-disabled-text-color);
    -webkit-text-fill-color: var(--lumo-disabled-text-color);
  }

  :host([disabled]) [part='input-field'] ::slotted(:not([slot$='fix'])) {
    color: var(--_disabled-value-color);
    -webkit-text-fill-color: var(--_disabled-value-color);
  }

  /* Invalid style */
  :host([invalid]) {
    --vaadin-input-field-border-color: var(--lumo-error-color);
  }

  :host([invalid][focus-ring]) [part='input-field'] {
    box-shadow: 0 0 0 2px var(--lumo-error-color-50pct);
  }

  :host([input-prevented]) [part='input-field'] {
    animation: shake 0.15s infinite;
  }

  @keyframes shake {
    25% {
      transform: translateX(4px);
    }
    75% {
      transform: translateX(-4px);
    }
  }

  /* Small theme */
  :host([theme~='small']) {
    font-size: var(--lumo-font-size-s);
    --lumo-text-field-size: var(--lumo-size-s);
  }

  :host([theme~='small']) [part='label'] {
    font-size: var(--lumo-font-size-xs);
  }

  :host([theme~='small']) [part='error-message'] {
    font-size: var(--lumo-font-size-xxs);
  }

  /* Slotted content */
  [part='input-field'] ::slotted(:not(vaadin-icon):not(input):not(textarea)) {
    color: var(--lumo-secondary-text-color);
    font-weight: 400;
  }

  [part='clear-button']::before {
    content: var(--lumo-icons-cross);
  }
`, ah = [sh, oh, Mp, Lp];
Ke("", ah, {
  moduleId: "lumo-input-field-shared-styles"
});
const Bp = ke`
  [part='toggle-button']::before {
    content: var(--lumo-icons-dropdown);
  }
`;
Ke("vaadin-combo-box", [ah, Bp], { moduleId: "lumo-combo-box" });
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Np = (s) => class extends s {
  static get properties() {
    return {
      /**
       * If true, the user cannot interact with this element.
       */
      disabled: {
        type: Boolean,
        reflectToAttribute: !0
      },
      /**
       * Set to true to make this element read-only.
       */
      readonly: {
        type: Boolean,
        reflectToAttribute: !0
      },
      /**
       * Set to true when the element is invalid.
       */
      invalid: {
        type: Boolean,
        reflectToAttribute: !0
      }
    };
  }
  /** @protected */
  ready() {
    super.ready(), this.addEventListener("pointerdown", (e) => {
      e.target === this && e.preventDefault();
    }), this.addEventListener("click", (e) => {
      e.target === this && this.shadowRoot.querySelector("slot:not([name])").assignedNodes({ flatten: !0 }).forEach((t) => t.focus && t.focus());
    });
  }
};
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Hp = ke`
  :host {
    display: flex;
    align-items: center;
    flex: 0 1 auto;
    border-radius:
            /* See https://developer.mozilla.org/en-US/docs/Web/CSS/border-radius */
      var(--vaadin-input-field-top-start-radius, var(--__border-radius))
      var(--vaadin-input-field-top-end-radius, var(--__border-radius))
      var(--vaadin-input-field-bottom-end-radius, var(--__border-radius))
      var(--vaadin-input-field-bottom-start-radius, var(--__border-radius));
    --_border-radius: var(--vaadin-input-field-border-radius, 0);
    --_input-border-width: var(--vaadin-input-field-border-width, 0);
    --_input-border-color: var(--vaadin-input-field-border-color, transparent);
    box-shadow: inset 0 0 0 var(--_input-border-width, 0) var(--_input-border-color);
  }

  :host([dir='rtl']) {
    border-radius:
            /* Don't use logical props, see https://github.com/vaadin/vaadin-time-picker/issues/145 */
      var(--vaadin-input-field-top-end-radius, var(--_border-radius))
      var(--vaadin-input-field-top-start-radius, var(--_border-radius))
      var(--vaadin-input-field-bottom-start-radius, var(--_border-radius))
      var(--vaadin-input-field-bottom-end-radius, var(--_border-radius));
  }

  :host([hidden]) {
    display: none !important;
  }

  /* Reset the native input styles */
  ::slotted(input) {
    -webkit-appearance: none;
    -moz-appearance: none;
    flex: auto;
    white-space: nowrap;
    overflow: hidden;
    width: 100%;
    height: 100%;
    outline: none;
    margin: 0;
    padding: 0;
    border: 0;
    border-radius: 0;
    min-width: 0;
    font: inherit;
    line-height: normal;
    color: inherit;
    background-color: transparent;
    /* Disable default invalid style in Firefox */
    box-shadow: none;
  }

  ::slotted(*) {
    flex: none;
  }

  ::slotted(:is(input, textarea))::placeholder {
    /* Use ::slotted(input:placeholder-shown) in themes to style the placeholder. */
    /* because ::slotted(...)::placeholder does not work in Safari. */
    font: inherit;
    color: inherit;
    /* Override default opacity in Firefox */
    opacity: 1;
  }
`;
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
Ke("vaadin-input-container", Hp, { moduleId: "vaadin-input-container-styles" });
class Vp extends Np(Vr(Ur(Pi))) {
  static get is() {
    return "vaadin-input-container";
  }
  static get template() {
    return er`
      <slot name="prefix"></slot>
      <slot></slot>
      <slot name="suffix"></slot>
    `;
  }
}
$t(Vp);
/**
 * @license
 * Copyright (c) 2015 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Up = (s) => class extends s {
  static get properties() {
    return {
      /**
       * The index of the item.
       */
      index: {
        type: Number
      },
      /**
       * The item to render.
       */
      item: {
        type: Object
      },
      /**
       * The text to render in the item.
       */
      label: {
        type: String
      },
      /**
       * True when item is selected.
       */
      selected: {
        type: Boolean,
        value: !1,
        reflectToAttribute: !0
      },
      /**
       * True when item is focused.
       */
      focused: {
        type: Boolean,
        value: !1,
        reflectToAttribute: !0
      },
      /**
       * Custom function for rendering the item content.
       */
      renderer: {
        type: Function
      }
    };
  }
  static get observers() {
    return ["__rendererOrItemChanged(renderer, index, item, selected, focused)", "__updateLabel(label, renderer)"];
  }
  static get observedAttributes() {
    return [...super.observedAttributes, "hidden"];
  }
  attributeChangedCallback(e, t, i) {
    e === "hidden" && i !== null ? this.index = void 0 : super.attributeChangedCallback(e, t, i);
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback(), this._owner = this.parentNode.owner;
    const e = this._owner.getAttribute("dir");
    e && this.setAttribute("dir", e);
  }
  /**
   * Requests an update for the content of the item.
   * While performing the update, it invokes the renderer passed in the `renderer` property.
   *
   * It is not guaranteed that the update happens immediately (synchronously) after it is requested.
   */
  requestContentUpdate() {
    if (!this.renderer || this.hidden)
      return;
    const e = {
      index: this.index,
      item: this.item,
      focused: this.focused,
      selected: this.selected
    };
    this.renderer(this, this._owner, e);
  }
  /** @private */
  __rendererOrItemChanged(e, t, i) {
    i === void 0 || t === void 0 || (this._oldRenderer !== e && (this.innerHTML = "", delete this._$litPart$), e && (this._oldRenderer = e, this.requestContentUpdate()));
  }
  /** @private */
  __updateLabel(e, t) {
    t || (this.textContent = e);
  }
};
/**
 * @license
 * Copyright (c) 2015 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class Wp extends Up(Vr(Ur(Pi))) {
  static get template() {
    return er`
      <style>
        :host {
          display: block;
        }

        :host([hidden]) {
          display: none;
        }
      </style>
      <span part="checkmark" aria-hidden="true"></span>
      <div part="content">
        <slot></slot>
      </div>
    `;
  }
  static get is() {
    return "vaadin-combo-box-item";
  }
}
$t(Wp);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
let Ts = !1, jp = [], lh = [];
function Gp() {
  Ts = !0, requestAnimationFrame(function() {
    Ts = !1, qp(jp), setTimeout(function() {
      Kp(lh);
    });
  });
}
function qp(s) {
  for (; s.length; )
    ch(s.shift());
}
function Kp(s) {
  for (let r = 0, e = s.length; r < e; r++)
    ch(s.shift());
}
function ch(s) {
  const r = s[0], e = s[1], t = s[2];
  try {
    e.apply(r, t);
  } catch (i) {
    setTimeout(() => {
      throw i;
    });
  }
}
function Zp(s, r, e) {
  Ts || Gp(), lh.push([s, r, e]);
}
/**
 * @license
 * Copyright (c) 2017 Anton Korzunov
 * SPDX-License-Identifier: MIT
 */
let Mi = /* @__PURE__ */ new WeakMap(), yn = /* @__PURE__ */ new WeakMap(), wn = {}, Xo = 0;
const kl = (s) => s && s.nodeType === Node.ELEMENT_NODE, Jo = (...s) => {
  console.error(`Error: ${s.join(" ")}. Skip setting aria-hidden.`);
}, Yp = (s, r) => kl(s) ? r.map((e) => {
  if (!kl(e))
    return Jo(e, "is not a valid element"), null;
  let t = e;
  for (; t && t !== s; ) {
    if (s.contains(t))
      return e;
    t = t.getRootNode().host;
  }
  return Jo(e, "is not contained inside", s), null;
}).filter((e) => !!e) : (Jo(s, "is not a valid element"), []), Xp = (s, r, e, t) => {
  const i = Yp(r, Array.isArray(s) ? s : [s]);
  wn[e] || (wn[e] = /* @__PURE__ */ new WeakMap());
  const n = wn[e], o = [], a = /* @__PURE__ */ new Set(), l = new Set(i), h = (f) => {
    if (!f || a.has(f))
      return;
    a.add(f);
    const g = f.assignedSlot;
    g && h(g), h(f.parentNode || f.host);
  };
  i.forEach(h);
  const d = (f) => {
    if (!f || l.has(f))
      return;
    const g = f.shadowRoot;
    (g ? [...f.children, ...g.children] : [...f.children]).forEach((C) => {
      if (!["template", "script", "style"].includes(C.localName))
        if (a.has(C))
          d(C);
        else {
          const E = C.getAttribute(t), A = E !== null && E !== "false", I = (Mi.get(C) || 0) + 1, V = (n.get(C) || 0) + 1;
          Mi.set(C, I), n.set(C, V), o.push(C), I === 1 && A && yn.set(C, !0), V === 1 && C.setAttribute(e, "true"), A || C.setAttribute(t, "true");
        }
    });
  };
  return d(r), a.clear(), Xo += 1, () => {
    o.forEach((f) => {
      const g = Mi.get(f) - 1, w = n.get(f) - 1;
      Mi.set(f, g), n.set(f, w), g || (yn.has(f) ? yn.delete(f) : f.removeAttribute(t)), w || f.removeAttribute(e);
    }), Xo -= 1, Xo || (Mi = /* @__PURE__ */ new WeakMap(), Mi = /* @__PURE__ */ new WeakMap(), yn = /* @__PURE__ */ new WeakMap(), wn = {});
  };
}, Jp = (s, r = document.body, e = "data-aria-hidden") => {
  const t = Array.from(Array.isArray(s) ? s : [s]);
  return r && t.push(...Array.from(r.querySelectorAll("[aria-live]"))), Xp(t, r, e, "aria-hidden");
};
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class Qp {
  /**
   * @param {HTMLElement} host
   */
  constructor(r, e) {
    this.host = r, this.callback = typeof e == "function" ? e : () => r;
  }
  /**
   * Make the controller host modal by hiding other elements from screen readers
   * using `aria-hidden` attribute (can be replaced with `inert` in the future).
   *
   * The method name is chosen to align with the one provided by native `<dialog>`:
   * https://developer.mozilla.org/en-US/docs/Web/API/HTMLDialogElement/showModal
   */
  showModal() {
    const r = this.callback();
    this.__showOthers = Jp(r);
  }
  /**
   * Remove `aria-hidden` from other elements unless there are any other
   * controller hosts on the page activated by using `showModal()` call.
   */
  close() {
    this.__showOthers && (this.__showOthers(), this.__showOthers = null);
  }
}
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const $p = (s) => class extends Wr(s) {
  static get properties() {
    return {
      /**
       * When true, opening the overlay moves focus to the first focusable child,
       * or to the overlay part with tabindex if there are no focusable children.
       * @attr {boolean} focus-trap
       */
      focusTrap: {
        type: Boolean,
        value: !1
      },
      /**
       * Set to true to enable restoring of focus when overlay is closed.
       * @attr {boolean} restore-focus-on-close
       */
      restoreFocusOnClose: {
        type: Boolean,
        value: !1
      },
      /**
       * Set to specify the element which should be focused on overlay close,
       * if `restoreFocusOnClose` is set to true.
       * @type {HTMLElement}
       */
      restoreFocusNode: {
        type: HTMLElement
      }
    };
  }
  constructor() {
    super(), this.__ariaModalController = new Qp(this), this.__focusTrapController = new yp(this), this.__focusRestorationController = new wp();
  }
  /** @protected */
  ready() {
    super.ready(), this.addController(this.__ariaModalController), this.addController(this.__focusTrapController), this.addController(this.__focusRestorationController);
  }
  /**
   * Release focus and restore focus after the overlay is closed.
   *
   * @protected
   */
  _resetFocus() {
    if (this.focusTrap && (this.__ariaModalController.close(), this.__focusTrapController.releaseFocus()), this.restoreFocusOnClose && this._shouldRestoreFocus()) {
      const e = !eo();
      this.__focusRestorationController.restoreFocus({ preventScroll: e });
    }
  }
  /**
   * Save the previously focused node when the overlay starts to open.
   *
   * @protected
   */
  _saveFocus() {
    this.restoreFocusOnClose && this.__focusRestorationController.saveFocus(this.restoreFocusNode);
  }
  /**
   * Trap focus within the overlay after opening has completed.
   *
   * @protected
   */
  _trapFocus() {
    this.focusTrap && (this.__ariaModalController.showModal(), this.__focusTrapController.trapFocus(this.$.overlay));
  }
  /**
   * Returns true if focus is still inside the overlay or on the body element,
   * otherwise false.
   *
   * Focus shouldn't be restored if it's been moved elsewhere by another
   * component or as a result of a user interaction e.g. the user clicked
   * on a button outside the overlay while the overlay was open.
   *
   * @protected
   * @return {boolean}
   */
  _shouldRestoreFocus() {
    const e = _s();
    return e === document.body || this._deepContains(e);
  }
  /**
   * Returns true if the overlay contains the given node,
   * including those within shadow DOM trees.
   *
   * @param {Node} node
   * @return {boolean}
   * @protected
   */
  _deepContains(e) {
    if (this.contains(e))
      return !0;
    let t = e;
    const i = e.ownerDocument;
    for (; t && t !== i && t !== this; )
      t = t.parentNode || t.host;
    return t === this;
  }
};
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Sn = () => Array.from(document.body.children).filter((s) => s instanceof HTMLElement && s._hasOverlayStackMixin && !s.hasAttribute("closing")).sort((s, r) => s.__zIndex - r.__zIndex || 0), eg = (s) => s === Sn().pop(), tg = (s) => class extends s {
  constructor() {
    super(), this._hasOverlayStackMixin = !0;
  }
  /**
   * Returns true if this is the last one in the opened overlays stack.
   *
   * @return {boolean}
   * @protected
   */
  get _last() {
    return eg(this);
  }
  /**
   * Brings the overlay as visually the frontmost one.
   */
  bringToFront() {
    let e = "";
    const t = Sn().filter((i) => i !== this).pop();
    t && (e = t.__zIndex + 1), this.style.zIndex = e, this.__zIndex = e || parseFloat(getComputedStyle(this).zIndex);
  }
  /** @protected */
  _enterModalState() {
    document.body.style.pointerEvents !== "none" && (this._previousDocumentPointerEvents = document.body.style.pointerEvents, document.body.style.pointerEvents = "none"), Sn().forEach((e) => {
      e !== this && e.$.overlay && (e.$.overlay.style.pointerEvents = "none");
    });
  }
  /** @protected */
  _exitModalState() {
    this._previousDocumentPointerEvents !== void 0 && (document.body.style.pointerEvents = this._previousDocumentPointerEvents, delete this._previousDocumentPointerEvents);
    const e = Sn();
    let t;
    for (; (t = e.pop()) && !(t !== this && (t.$.overlay && t.$.overlay.style.removeProperty("pointer-events"), !t.modeless)); )
      ;
  }
};
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const ig = (s) => class extends $p(tg(s)) {
  static get properties() {
    return {
      /**
       * When true, the overlay is visible and attached to body.
       */
      opened: {
        type: Boolean,
        notify: !0,
        observer: "_openedChanged",
        reflectToAttribute: !0
      },
      /**
       * Owner element passed with renderer function
       * @type {HTMLElement}
       */
      owner: {
        type: Object
      },
      /**
       * Object with properties that is passed to `renderer` function
       */
      model: {
        type: Object
      },
      /**
       * Custom function for rendering the content of the overlay.
       * Receives three arguments:
       *
       * - `root` The root container DOM element. Append your content to it.
       * - `owner` The host element of the renderer function.
       * - `model` The object with the properties related with rendering.
       * @type {OverlayRenderer | null | undefined}
       */
      renderer: {
        type: Object
      },
      /**
       * When true the overlay won't disable the main content, showing
       * it doesn't change the functionality of the user interface.
       * @type {boolean}
       */
      modeless: {
        type: Boolean,
        value: !1,
        reflectToAttribute: !0,
        observer: "_modelessChanged"
      },
      /**
       * When set to true, the overlay is hidden. This also closes the overlay
       * immediately in case there is a closing animation in progress.
       * @type {boolean}
       */
      hidden: {
        type: Boolean,
        reflectToAttribute: !0,
        observer: "_hiddenChanged"
      },
      /**
       * When true the overlay has backdrop on top of content when opened.
       * @type {boolean}
       */
      withBackdrop: {
        type: Boolean,
        value: !1,
        reflectToAttribute: !0
      }
    };
  }
  static get observers() {
    return ["_rendererOrDataChanged(renderer, owner, model, opened)"];
  }
  constructor() {
    super(), this._boundMouseDownListener = this._mouseDownListener.bind(this), this._boundMouseUpListener = this._mouseUpListener.bind(this), this._boundOutsideClickListener = this._outsideClickListener.bind(this), this._boundKeydownListener = this._keydownListener.bind(this), ws && (this._boundIosResizeListener = () => this._detectIosNavbar());
  }
  /** @protected */
  ready() {
    super.ready(), this.addEventListener("click", () => {
    }), this.$.backdrop.addEventListener("click", () => {
    }), this.addEventListener("mouseup", () => {
      document.activeElement === document.body && this.$.overlay.getAttribute("tabindex") === "0" && this.$.overlay.focus();
    });
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback(), this._boundIosResizeListener && (this._detectIosNavbar(), window.addEventListener("resize", this._boundIosResizeListener));
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback(), this._boundIosResizeListener && window.removeEventListener("resize", this._boundIosResizeListener);
  }
  /**
   * Requests an update for the content of the overlay.
   * While performing the update, it invokes the renderer passed in the `renderer` property.
   *
   * It is not guaranteed that the update happens immediately (synchronously) after it is requested.
   */
  requestContentUpdate() {
    this.renderer && this.renderer.call(this.owner, this, this.owner, this.model);
  }
  /**
   * @param {Event=} sourceEvent
   */
  close(e) {
    const t = new CustomEvent("vaadin-overlay-close", {
      bubbles: !0,
      cancelable: !0,
      detail: { sourceEvent: e }
    });
    this.dispatchEvent(t), t.defaultPrevented || (this.opened = !1);
  }
  /** @private */
  _detectIosNavbar() {
    if (!this.opened)
      return;
    const e = window.innerHeight, i = window.innerWidth > e, n = document.documentElement.clientHeight;
    i && n > e ? this.style.setProperty("--vaadin-overlay-viewport-bottom", `${n - e}px`) : this.style.setProperty("--vaadin-overlay-viewport-bottom", "0");
  }
  /** @private */
  _addGlobalListeners() {
    document.addEventListener("mousedown", this._boundMouseDownListener), document.addEventListener("mouseup", this._boundMouseUpListener), document.documentElement.addEventListener("click", this._boundOutsideClickListener, !0);
  }
  /** @private */
  _removeGlobalListeners() {
    document.removeEventListener("mousedown", this._boundMouseDownListener), document.removeEventListener("mouseup", this._boundMouseUpListener), document.documentElement.removeEventListener("click", this._boundOutsideClickListener, !0);
  }
  /** @private */
  _rendererOrDataChanged(e, t, i, n) {
    const o = this._oldOwner !== t || this._oldModel !== i;
    this._oldModel = i, this._oldOwner = t;
    const a = this._oldRenderer !== e, l = this._oldRenderer !== void 0;
    this._oldRenderer = e;
    const h = this._oldOpened !== n;
    this._oldOpened = n, a && l && (this.innerHTML = "", delete this._$litPart$), n && e && (a || h || o) && this.requestContentUpdate();
  }
  /** @private */
  _modelessChanged(e) {
    e ? (this._removeGlobalListeners(), this._exitModalState()) : this.opened && (this._addGlobalListeners(), this._enterModalState());
  }
  /** @private */
  _openedChanged(e, t) {
    e ? (this._saveFocus(), this._animatedOpening(), Zp(this, () => {
      this._trapFocus();
      const i = new CustomEvent("vaadin-overlay-open", { bubbles: !0 });
      this.dispatchEvent(i);
    }), document.addEventListener("keydown", this._boundKeydownListener), this.modeless || this._addGlobalListeners()) : t && (this._resetFocus(), this._animatedClosing(), document.removeEventListener("keydown", this._boundKeydownListener), this.modeless || this._removeGlobalListeners());
  }
  /** @private */
  _hiddenChanged(e) {
    e && this.hasAttribute("closing") && this._flushAnimation("closing");
  }
  /**
   * @return {boolean}
   * @private
   */
  _shouldAnimate() {
    const e = getComputedStyle(this), t = e.getPropertyValue("animation-name");
    return !(e.getPropertyValue("display") === "none") && t && t !== "none";
  }
  /**
   * @param {string} type
   * @param {Function} callback
   * @private
   */
  _enqueueAnimation(e, t) {
    const i = `__${e}Handler`, n = (o) => {
      o && o.target !== this || (t(), this.removeEventListener("animationend", n), delete this[i]);
    };
    this[i] = n, this.addEventListener("animationend", n);
  }
  /**
   * @param {string} type
   * @protected
   */
  _flushAnimation(e) {
    const t = `__${e}Handler`;
    typeof this[t] == "function" && this[t]();
  }
  /** @private */
  _animatedOpening() {
    this.parentNode === document.body && this.hasAttribute("closing") && this._flushAnimation("closing"), this._attachOverlay(), this.modeless || this._enterModalState(), this.setAttribute("opening", ""), this._shouldAnimate() ? this._enqueueAnimation("opening", () => {
      this._finishOpening();
    }) : this._finishOpening();
  }
  /** @private */
  _attachOverlay() {
    this._placeholder = document.createComment("vaadin-overlay-placeholder"), this.parentNode.insertBefore(this._placeholder, this), document.body.appendChild(this), this.bringToFront();
  }
  /** @private */
  _finishOpening() {
    this.removeAttribute("opening");
  }
  /** @private */
  _finishClosing() {
    this._detachOverlay(), this.$.overlay.style.removeProperty("pointer-events"), this.removeAttribute("closing"), this.dispatchEvent(new CustomEvent("vaadin-overlay-closed"));
  }
  /** @private */
  _animatedClosing() {
    this.hasAttribute("opening") && this._flushAnimation("opening"), this._placeholder && (this._exitModalState(), this.setAttribute("closing", ""), this.dispatchEvent(new CustomEvent("vaadin-overlay-closing")), this._shouldAnimate() ? this._enqueueAnimation("closing", () => {
      this._finishClosing();
    }) : this._finishClosing());
  }
  /** @private */
  _detachOverlay() {
    this._placeholder.parentNode.insertBefore(this, this._placeholder), this._placeholder.parentNode.removeChild(this._placeholder);
  }
  /** @private */
  _mouseDownListener(e) {
    this._mouseDownInside = e.composedPath().indexOf(this.$.overlay) >= 0;
  }
  /** @private */
  _mouseUpListener(e) {
    this._mouseUpInside = e.composedPath().indexOf(this.$.overlay) >= 0;
  }
  /**
   * Whether to close the overlay on outside click or not.
   * Override this method to customize the closing logic.
   *
   * @param {Event} _event
   * @return {boolean}
   * @protected
   */
  _shouldCloseOnOutsideClick(e) {
    return this._last;
  }
  /**
   * Outside click listener used in capture phase to close the overlay before
   * propagating the event to the listener on the element that triggered it.
   * Otherwise, calling `open()` would result in closing and re-opening.
   *
   * @private
   */
  _outsideClickListener(e) {
    if (e.composedPath().includes(this.$.overlay) || this._mouseDownInside || this._mouseUpInside) {
      this._mouseDownInside = !1, this._mouseUpInside = !1;
      return;
    }
    if (!this._shouldCloseOnOutsideClick(e))
      return;
    const t = new CustomEvent("vaadin-overlay-outside-click", {
      bubbles: !0,
      cancelable: !0,
      detail: { sourceEvent: e }
    });
    this.dispatchEvent(t), this.opened && !t.defaultPrevented && this.close(e);
  }
  /**
   * Listener used to close whe overlay on Escape press, if it is the last one.
   * @private
   */
  _keydownListener(e) {
    if (this._last && !(this.modeless && !e.composedPath().includes(this.$.overlay)) && e.key === "Escape") {
      const t = new CustomEvent("vaadin-overlay-escape-press", {
        bubbles: !0,
        cancelable: !0,
        detail: { sourceEvent: e }
      });
      this.dispatchEvent(t), this.opened && !t.defaultPrevented && this.close(e);
    }
  }
};
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const rg = ke`
  :host {
    z-index: 200;
    position: fixed;

    /* Despite of what the names say, <vaadin-overlay> is just a container
          for position/sizing/alignment. The actual overlay is the overlay part. */

    /* Default position constraints: the entire viewport. Note: themes can
          override this to introduce gaps between the overlay and the viewport. */
    inset: 0;
    bottom: var(--vaadin-overlay-viewport-bottom);

    /* Use flexbox alignment for the overlay part. */
    display: flex;
    flex-direction: column; /* makes dropdowns sizing easier */
    /* Align to center by default. */
    align-items: center;
    justify-content: center;

    /* Allow centering when max-width/max-height applies. */
    margin: auto;

    /* The host is not clickable, only the overlay part is. */
    pointer-events: none;

    /* Remove tap highlight on touch devices. */
    -webkit-tap-highlight-color: transparent;

    /* CSS API for host */
    --vaadin-overlay-viewport-bottom: 0;
  }

  :host([hidden]),
  :host(:not([opened]):not([closing])),
  :host(:not([opened]):not([closing])) [part='overlay'] {
    display: none !important;
  }

  [part='overlay'] {
    -webkit-overflow-scrolling: touch;
    overflow: auto;
    pointer-events: auto;

    /* Prevent overflowing the host */
    max-width: 100%;
    box-sizing: border-box;

    -webkit-tap-highlight-color: initial; /* reenable tap highlight inside */
  }

  [part='backdrop'] {
    z-index: -1;
    content: '';
    background: rgba(0, 0, 0, 0.5);
    position: fixed;
    inset: 0;
    pointer-events: auto;
  }
`;
/**
 * @license
 * Copyright (c) 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function ng(s, r) {
  let e = null;
  const t = document.documentElement;
  function i() {
    e && e.disconnect(), e = null;
  }
  function n(o = !1, a = 1) {
    i();
    const { left: l, top: h, width: d, height: f } = s.getBoundingClientRect();
    if (o || r(), !d || !f)
      return;
    const g = Math.floor(h), w = Math.floor(t.clientWidth - (l + d)), C = Math.floor(t.clientHeight - (h + f)), E = Math.floor(l), I = {
      rootMargin: `${-g}px ${-w}px ${-C}px ${-E}px`,
      threshold: Math.max(0, Math.min(1, a)) || 1
    };
    let V = !0;
    function K(ce) {
      let re = ce[0].intersectionRatio;
      if (re !== a) {
        if (!V)
          return n();
        re === 0 && (re = 1e-7), n(!1, re);
      }
      V = !1;
    }
    e = new IntersectionObserver(K, I), e.observe(s);
  }
  return n(!0), i;
}
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Qo = {
  start: "top",
  end: "bottom"
}, $o = {
  start: "left",
  end: "right"
}, Al = new ResizeObserver((s) => {
  setTimeout(() => {
    s.forEach((r) => {
      r.target.__overlay && r.target.__overlay._updatePosition();
    });
  });
}), og = (s) => class extends s {
  static get properties() {
    return {
      /**
       * The element next to which this overlay should be aligned.
       * The position of the overlay relative to the positionTarget can be adjusted
       * with properties `horizontalAlign`, `verticalAlign`, `noHorizontalOverlap`
       * and `noVerticalOverlap`.
       */
      positionTarget: {
        type: Object,
        value: null,
        sync: !0
      },
      /**
       * When `positionTarget` is set, this property defines whether to align the overlay's
       * left or right side to the target element by default.
       * Possible values are `start` and `end`.
       * RTL is taken into account when interpreting the value.
       * The overlay is automatically flipped to the opposite side when it doesn't fit into
       * the default side defined by this property.
       *
       * @attr {start|end} horizontal-align
       */
      horizontalAlign: {
        type: String,
        value: "start",
        sync: !0
      },
      /**
       * When `positionTarget` is set, this property defines whether to align the overlay's
       * top or bottom side to the target element by default.
       * Possible values are `top` and `bottom`.
       * The overlay is automatically flipped to the opposite side when it doesn't fit into
       * the default side defined by this property.
       *
       * @attr {top|bottom} vertical-align
       */
      verticalAlign: {
        type: String,
        value: "top",
        sync: !0
      },
      /**
       * When `positionTarget` is set, this property defines whether the overlay should overlap
       * the target element in the x-axis, or be positioned right next to it.
       *
       * @attr {boolean} no-horizontal-overlap
       */
      noHorizontalOverlap: {
        type: Boolean,
        value: !1,
        sync: !0
      },
      /**
       * When `positionTarget` is set, this property defines whether the overlay should overlap
       * the target element in the y-axis, or be positioned right above/below it.
       *
       * @attr {boolean} no-vertical-overlap
       */
      noVerticalOverlap: {
        type: Boolean,
        value: !1,
        sync: !0
      },
      /**
       * If the overlay content has no intrinsic height, this property can be used to set
       * the minimum vertical space (in pixels) required by the overlay. Setting a value to
       * the property effectively disables the content measurement in favor of using this
       * fixed value for determining the open direction.
       *
       * @attr {number} required-vertical-space
       */
      requiredVerticalSpace: {
        type: Number,
        value: 0,
        sync: !0
      }
    };
  }
  static get observers() {
    return [
      "__positionSettingsChanged(horizontalAlign, verticalAlign, noHorizontalOverlap, noVerticalOverlap, requiredVerticalSpace)",
      "__overlayOpenedChanged(opened, positionTarget)"
    ];
  }
  constructor() {
    super(), this.__onScroll = this.__onScroll.bind(this), this._updatePosition = this._updatePosition.bind(this);
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback(), this.opened && this.__addUpdatePositionEventListeners();
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback(), this.__removeUpdatePositionEventListeners();
  }
  /** @private */
  __addUpdatePositionEventListeners() {
    window.visualViewport.addEventListener("resize", this._updatePosition), window.visualViewport.addEventListener("scroll", this.__onScroll, !0), this.__positionTargetAncestorRootNodes = cf(this.positionTarget), this.__positionTargetAncestorRootNodes.forEach((e) => {
      e.addEventListener("scroll", this.__onScroll, !0);
    }), this.positionTarget && (this.__observePositionTargetMove = ng(this.positionTarget, () => {
      this._updatePosition();
    }));
  }
  /** @private */
  __removeUpdatePositionEventListeners() {
    window.visualViewport.removeEventListener("resize", this._updatePosition), window.visualViewport.removeEventListener("scroll", this.__onScroll, !0), this.__positionTargetAncestorRootNodes && (this.__positionTargetAncestorRootNodes.forEach((e) => {
      e.removeEventListener("scroll", this.__onScroll, !0);
    }), this.__positionTargetAncestorRootNodes = null), this.__observePositionTargetMove && (this.__observePositionTargetMove(), this.__observePositionTargetMove = null);
  }
  /** @private */
  __overlayOpenedChanged(e, t) {
    if (this.__removeUpdatePositionEventListeners(), t && (t.__overlay = null, Al.unobserve(t), e && (this.__addUpdatePositionEventListeners(), t.__overlay = this, Al.observe(t))), e) {
      const i = getComputedStyle(this);
      this.__margins || (this.__margins = {}, ["top", "bottom", "left", "right"].forEach((n) => {
        this.__margins[n] = parseInt(i[n], 10);
      })), this._updatePosition(), requestAnimationFrame(() => this._updatePosition());
    }
  }
  __positionSettingsChanged() {
    this._updatePosition();
  }
  /** @private */
  __onScroll(e) {
    e.target instanceof Node && this.contains(e.target) || this._updatePosition();
  }
  _updatePosition() {
    if (!this.positionTarget || !this.opened || !this.__margins)
      return;
    const e = this.positionTarget.getBoundingClientRect();
    if (e.width === 0 && e.height === 0 && this.opened) {
      this.opened = !1;
      return;
    }
    const t = this.__shouldAlignStartVertically(e);
    this.style.justifyContent = t ? "flex-start" : "flex-end";
    const i = this.__isRTL, n = this.__shouldAlignStartHorizontally(e, i), o = !i && n || i && !n;
    this.style.alignItems = o ? "flex-start" : "flex-end";
    const a = this.getBoundingClientRect(), l = this.__calculatePositionInOneDimension(
      e,
      a,
      this.noVerticalOverlap,
      Qo,
      this,
      t
    ), h = this.__calculatePositionInOneDimension(
      e,
      a,
      this.noHorizontalOverlap,
      $o,
      this,
      n
    );
    Object.assign(this.style, l, h), this.toggleAttribute("bottom-aligned", !t), this.toggleAttribute("top-aligned", t), this.toggleAttribute("end-aligned", !o), this.toggleAttribute("start-aligned", o);
  }
  __shouldAlignStartHorizontally(e, t) {
    const i = Math.max(this.__oldContentWidth || 0, this.$.overlay.offsetWidth);
    this.__oldContentWidth = this.$.overlay.offsetWidth;
    const n = Math.min(window.innerWidth, document.documentElement.clientWidth), o = !t && this.horizontalAlign === "start" || t && this.horizontalAlign === "end";
    return this.__shouldAlignStart(
      e,
      i,
      n,
      this.__margins,
      o,
      this.noHorizontalOverlap,
      $o
    );
  }
  __shouldAlignStartVertically(e) {
    const t = this.requiredVerticalSpace || Math.max(this.__oldContentHeight || 0, this.$.overlay.offsetHeight);
    this.__oldContentHeight = this.$.overlay.offsetHeight;
    const i = Math.min(window.innerHeight, document.documentElement.clientHeight), n = this.verticalAlign === "top";
    return this.__shouldAlignStart(
      e,
      t,
      i,
      this.__margins,
      n,
      this.noVerticalOverlap,
      Qo
    );
  }
  // eslint-disable-next-line @typescript-eslint/max-params
  __shouldAlignStart(e, t, i, n, o, a, l) {
    const h = i - e[a ? l.end : l.start] - n[l.end], d = e[a ? l.start : l.end] - n[l.start], f = o ? h : d, w = f > (o ? d : h) || f > t;
    return o === w;
  }
  /**
   * Returns an adjusted value after resizing the browser window,
   * to avoid wrong calculations when e.g. previously set `bottom`
   * CSS property value is larger than the updated viewport height.
   * See https://github.com/vaadin/web-components/issues/4604
   */
  __adjustBottomProperty(e, t, i) {
    let n;
    if (e === t.end) {
      if (t.end === Qo.end) {
        const o = Math.min(window.innerHeight, document.documentElement.clientHeight);
        if (i > o && this.__oldViewportHeight) {
          const a = this.__oldViewportHeight - o;
          n = i - a;
        }
        this.__oldViewportHeight = o;
      }
      if (t.end === $o.end) {
        const o = Math.min(window.innerWidth, document.documentElement.clientWidth);
        if (i > o && this.__oldViewportWidth) {
          const a = this.__oldViewportWidth - o;
          n = i - a;
        }
        this.__oldViewportWidth = o;
      }
    }
    return n;
  }
  /**
   * Returns an object with CSS position properties to set,
   * e.g. { top: "100px" }
   */
  // eslint-disable-next-line @typescript-eslint/max-params
  __calculatePositionInOneDimension(e, t, i, n, o, a) {
    const l = a ? n.start : n.end, h = a ? n.end : n.start, d = parseFloat(o.style[l] || getComputedStyle(o)[l]), f = this.__adjustBottomProperty(l, n, d), g = t[a ? n.start : n.end] - e[i === a ? n.end : n.start], w = f ? `${f}px` : `${d + g * (a ? -1 : 1)}px`;
    return {
      [l]: w,
      [h]: ""
    };
  }
};
/**
 * @license
 * Copyright (c) 2015 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const sg = (s) => class extends og(s) {
  static get observers() {
    return ["_setOverlayWidth(positionTarget, opened)"];
  }
  constructor() {
    super(), this.requiredVerticalSpace = 200;
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    const e = this._comboBox, t = e && e.getAttribute("dir");
    t && this.setAttribute("dir", t);
  }
  /**
   * Override method inherited from `Overlay`
   * to not close on position target click.
   *
   * @param {Event} event
   * @return {boolean}
   * @protected
   */
  _shouldCloseOnOutsideClick(e) {
    const t = e.composedPath();
    return !t.includes(this.positionTarget) && !t.includes(this);
  }
  /**
   * @protected
   * @override
   */
  _mouseDownListener(e) {
    super._mouseDownListener(e), this._shouldCloseOnOutsideClick(e) && !Ws(e.composedPath()[0]) && e.preventDefault();
  }
  /** @protected */
  _updateOverlayWidth() {
    const e = this.localName;
    this.style.setProperty(`--_${e}-default-width`, `${this.positionTarget.clientWidth}px`);
    const t = getComputedStyle(this._comboBox).getPropertyValue(`--${e}-width`);
    t === "" ? this.style.removeProperty(`--${e}-width`) : this.style.setProperty(`--${e}-width`, t);
  }
  /** @private */
  _setOverlayWidth(e, t) {
    e && t && (this._updateOverlayWidth(), this._updatePosition());
  }
};
/**
 * @license
 * Copyright (c) 2015 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const ag = ke`
  #overlay {
    width: var(--vaadin-combo-box-overlay-width, var(--_vaadin-combo-box-overlay-default-width, auto));
  }

  [part='content'] {
    display: flex;
    flex-direction: column;
    height: 100%;
  }
`;
Ke("vaadin-combo-box-overlay", [rg, ag], {
  moduleId: "vaadin-combo-box-overlay-styles"
});
class lg extends sg(ig(Ur(Vr(Pi)))) {
  static get is() {
    return "vaadin-combo-box-overlay";
  }
  static get template() {
    return er`
      <div id="backdrop" part="backdrop" hidden></div>
      <div part="overlay" id="overlay">
        <div part="loader"></div>
        <div part="content" id="content"><slot></slot></div>
      </div>
    `;
  }
}
$t(lg);
/**
 * @license
 * Copyright (c) 2015 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Yi = class {
  toString() {
    return "";
  }
};
/**
 * @license
 * Copyright (c) 2015 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const cg = (s) => class extends s {
  static get properties() {
    return {
      /**
       * A full set of items to filter the visible options from.
       * Set to an empty array when combo-box is not opened.
       */
      items: {
        type: Array,
        sync: !0,
        observer: "__itemsChanged"
      },
      /**
       * Index of an item that has focus outline and is scrolled into view.
       * The actual focus still remains in the input field.
       */
      focusedIndex: {
        type: Number,
        sync: !0,
        observer: "__focusedIndexChanged"
      },
      /**
       * Set to true while combo-box fetches new page from the data provider.
       */
      loading: {
        type: Boolean,
        sync: !0,
        observer: "__loadingChanged"
      },
      /**
       * Whether the combo-box is currently opened or not. If set to false,
       * calling `scrollIntoView` does not have any effect.
       */
      opened: {
        type: Boolean,
        sync: !0,
        observer: "__openedChanged"
      },
      /**
       * The selected item from the `items` array.
       */
      selectedItem: {
        type: Object,
        sync: !0,
        observer: "__selectedItemChanged"
      },
      /**
       * A function used to generate CSS class names for dropdown
       * items based on the item. The return value should be the
       * generated class name as a string, or multiple class names
       * separated by whitespace characters.
       */
      itemClassNameGenerator: {
        type: Object,
        observer: "__itemClassNameGeneratorChanged"
      },
      /**
       * Path for the id of the item, used to detect whether the item is selected.
       */
      itemIdPath: {
        type: String
      },
      /**
       * Reference to the owner (combo-box owner), used by the item elements.
       */
      owner: {
        type: Object
      },
      /**
       * Function used to set a label for every combo-box item.
       */
      getItemLabel: {
        type: Object
      },
      /**
       * Function used to render the content of every combo-box item.
       */
      renderer: {
        type: Object,
        sync: !0,
        observer: "__rendererChanged"
      },
      /**
       * Used to propagate the `theme` attribute from the host element.
       */
      theme: {
        type: String
      }
    };
  }
  constructor() {
    super(), this.__boundOnItemClick = this.__onItemClick.bind(this);
  }
  /** @private */
  get _viewportTotalPaddingBottom() {
    if (this._cachedViewportTotalPaddingBottom === void 0) {
      const e = window.getComputedStyle(this.$.selector);
      this._cachedViewportTotalPaddingBottom = [e.paddingBottom, e.borderBottomWidth].map((t) => parseInt(t, 10)).reduce((t, i) => t + i);
    }
    return this._cachedViewportTotalPaddingBottom;
  }
  /** @protected */
  ready() {
    super.ready(), this.setAttribute("role", "listbox"), this.id = `${this.localName}-${Wc()}`, this.__hostTagName = this.constructor.is.replace("-scroller", ""), this.addEventListener("click", (e) => e.stopPropagation()), this.__patchWheelOverScrolling();
  }
  /**
   * Updates the virtualizer's size and items.
   */
  requestContentUpdate() {
    this.__virtualizer && (this.items && (this.__virtualizer.size = this.items.length), this.opened && this.__virtualizer.update());
  }
  /**
   * Scrolls an item at given index into view and adjusts `scrollTop`
   * so that the element gets fully visible on Arrow Down key press.
   * @param {number} index
   */
  scrollIntoView(e) {
    if (!this.__virtualizer || !(this.opened && e >= 0))
      return;
    const t = this._visibleItemsCount();
    let i = e;
    e > this.__virtualizer.lastVisibleIndex - 1 ? (this.__virtualizer.scrollToIndex(e), i = e - t + 1) : e > this.__virtualizer.firstVisibleIndex && (i = this.__virtualizer.firstVisibleIndex), this.__virtualizer.scrollToIndex(Math.max(0, i));
    const n = [...this.children].find(
      (h) => !h.hidden && h.index === this.__virtualizer.lastVisibleIndex
    );
    if (!n || e !== n.index)
      return;
    const o = n.getBoundingClientRect(), a = this.getBoundingClientRect(), l = o.bottom - a.bottom + this._viewportTotalPaddingBottom;
    l > 0 && (this.scrollTop += l);
  }
  /**
   * @param {string | object} item
   * @param {string | object} selectedItem
   * @param {string} itemIdPath
   * @protected
   */
  _isItemSelected(e, t, i) {
    return e instanceof Yi ? !1 : i && e !== void 0 && t !== void 0 ? Ci(i, e) === Ci(i, t) : e === t;
  }
  /** @private */
  __initVirtualizer() {
    this.__virtualizer = new qc({
      createElements: this.__createElements.bind(this),
      updateElement: this._updateElement.bind(this),
      elementsContainer: this,
      scrollTarget: this,
      scrollContainer: this.$.selector,
      reorderElements: !0
    });
  }
  /** @private */
  __itemsChanged(e) {
    e && this.__virtualizer && this.requestContentUpdate();
  }
  /** @private */
  __loadingChanged() {
    this.requestContentUpdate();
  }
  /** @private */
  __openedChanged(e) {
    e && (this.__virtualizer || this.__initVirtualizer(), this.requestContentUpdate());
  }
  /** @private */
  __selectedItemChanged() {
    this.requestContentUpdate();
  }
  /** @private */
  __itemClassNameGeneratorChanged(e, t) {
    (e || t) && this.requestContentUpdate();
  }
  /** @private */
  __focusedIndexChanged(e, t) {
    e !== t && this.requestContentUpdate(), e >= 0 && !this.loading && this.scrollIntoView(e);
  }
  /** @private */
  __rendererChanged(e, t) {
    (e || t) && this.requestContentUpdate();
  }
  /** @private */
  __createElements(e) {
    return [...Array(e)].map(() => {
      const t = document.createElement(`${this.__hostTagName}-item`);
      return t.addEventListener("click", this.__boundOnItemClick), t.tabIndex = "-1", t.style.width = "100%", t;
    });
  }
  /**
   * @param {HTMLElement} el
   * @param {number} index
   * @protected
   */
  _updateElement(e, t) {
    const i = this.items[t], n = this.focusedIndex, o = this._isItemSelected(i, this.selectedItem, this.itemIdPath);
    e.setProperties({
      item: i,
      index: t,
      label: this.getItemLabel(i),
      selected: o,
      renderer: this.renderer,
      focused: !this.loading && n === t
    }), typeof this.itemClassNameGenerator == "function" ? e.className = this.itemClassNameGenerator(i) : e.className !== "" && (e.className = ""), e.performUpdate && !e.hasUpdated && e.performUpdate(), e.id = `${this.__hostTagName}-item-${t}`, e.setAttribute("role", t !== void 0 ? "option" : !1), e.setAttribute("aria-selected", o.toString()), e.setAttribute("aria-posinset", t + 1), e.setAttribute("aria-setsize", this.items.length), this.theme ? e.setAttribute("theme", this.theme) : e.removeAttribute("theme"), i instanceof Yi && this.__requestItemByIndex(t);
  }
  /** @private */
  __onItemClick(e) {
    this.dispatchEvent(new CustomEvent("selection-changed", { detail: { item: e.currentTarget.item } }));
  }
  /**
   * We want to prevent the kinetic scrolling energy from being transferred from the overlay contents over to the parent.
   * Further improvement ideas: after the contents have been scrolled to the top or bottom and scrolling has stopped, it could allow
   * scrolling the parent similarly to touch scrolling.
   * @private
   */
  __patchWheelOverScrolling() {
    this.$.selector.addEventListener("wheel", (e) => {
      const t = this.scrollTop === 0, i = this.scrollHeight - this.scrollTop - this.clientHeight <= 1;
      (t && e.deltaY < 0 || i && e.deltaY > 0) && e.preventDefault();
    });
  }
  /**
   * Dispatches an `index-requested` event for the given index to notify
   * the data provider that it should start loading the page containing the requested index.
   *
   * The event is dispatched asynchronously to prevent an immediate page request and therefore
   * a possible infinite recursion in case the data provider implements page request cancelation logic
   * by invoking data provider page callbacks with an empty array.
   * The infinite recursion may occur otherwise since invoking a data provider page callback with an empty array
   * triggers a synchronous scroller update and, if the callback corresponds to the currently visible page,
   * the scroller will synchronously request the page again which may lead to looping in the end.
   * That was the case for the Flow counterpart:
   * https://github.com/vaadin/flow-components/issues/3553#issuecomment-1239344828
   * @private
   */
  __requestItemByIndex(e) {
    requestAnimationFrame(() => {
      this.dispatchEvent(
        new CustomEvent("index-requested", {
          detail: {
            index: e
          }
        })
      );
    });
  }
  /** @private */
  _visibleItemsCount() {
    return this.__virtualizer.scrollToIndex(this.__virtualizer.firstVisibleIndex), this.__virtualizer.size > 0 ? this.__virtualizer.lastVisibleIndex - this.__virtualizer.firstVisibleIndex + 1 : 0;
  }
};
/**
 * @license
 * Copyright (c) 2015 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class hg extends cg(Pi) {
  static get is() {
    return "vaadin-combo-box-scroller";
  }
  static get template() {
    return er`
      <style>
        :host {
          display: block;
          min-height: 1px;
          overflow: auto;

          /* Fixes item background from getting on top of scrollbars on Safari */
          transform: translate3d(0, 0, 0);

          /* Enable momentum scrolling on iOS */
          -webkit-overflow-scrolling: touch;

          /* Fixes scrollbar disappearing when 'Show scroll bars: Always' enabled in Safari */
          box-shadow: 0 0 0 white;
        }

        #selector {
          border-width: var(--_vaadin-combo-box-items-container-border-width);
          border-style: var(--_vaadin-combo-box-items-container-border-style);
          border-color: var(--_vaadin-combo-box-items-container-border-color, transparent);
          position: relative;
        }
      </style>
      <div id="selector">
        <slot></slot>
      </div>
    `;
  }
}
$t(hg);
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const es = /* @__PURE__ */ new WeakMap();
function dg(s) {
  return es.has(s) || es.set(s, /* @__PURE__ */ new Set()), es.get(s);
}
function ug(s, r) {
  const e = document.createElement("style");
  e.textContent = s, r === document ? document.head.appendChild(e) : r.insertBefore(e, r.firstChild);
}
const fg = $e(
  (s) => class extends s {
    /**
     * List of styles to insert into root.
     * @protected
     */
    get slotStyles() {
      return {};
    }
    /** @protected */
    connectedCallback() {
      super.connectedCallback(), this.__applySlotStyles();
    }
    /** @private */
    __applySlotStyles() {
      const e = this.getRootNode(), t = dg(e);
      this.slotStyles.forEach((i) => {
        t.has(i) || (ug(i, e), t.add(i));
      });
    }
  }
);
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const ta = $e(
  (s) => class extends s {
    static get properties() {
      return {
        /**
         * A reference to the input element controlled by the mixin.
         * Any component implementing this mixin is expected to provide it
         * by using `this._setInputElement(input)` Polymer API.
         *
         * A typical case is using `InputController` that does this automatically.
         * However, the input element does not have to always be native <input>:
         * as an example, <vaadin-combo-box-light> accepts other components.
         *
         * @protected
         * @type {!HTMLElement}
         */
        inputElement: {
          type: Object,
          readOnly: !0,
          observer: "_inputElementChanged"
        },
        /**
         * String used to define input type.
         * @protected
         */
        type: {
          type: String,
          readOnly: !0
        },
        /**
         * The value of the field.
         */
        value: {
          type: String,
          value: "",
          observer: "_valueChanged",
          notify: !0,
          sync: !0
        },
        /**
         * Whether the input element has a non-empty value.
         *
         * @protected
         */
        _hasInputValue: {
          type: Boolean,
          value: !1,
          observer: "_hasInputValueChanged"
        }
      };
    }
    constructor() {
      super(), this._boundOnInput = this.__onInput.bind(this), this._boundOnChange = this._onChange.bind(this);
    }
    /**
     * Indicates whether the value is different from the default one.
     * Override if the `value` property has a type other than `string`.
     *
     * @protected
     */
    get _hasValue() {
      return this.value != null && this.value !== "";
    }
    /**
     * A property for accessing the input element's value.
     *
     * Override this getter if the property is different from the default `value` one.
     *
     * @protected
     * @return {string}
     */
    get _inputElementValueProperty() {
      return "value";
    }
    /**
     * The input element's value.
     *
     * @protected
     * @return {string}
     */
    get _inputElementValue() {
      return this.inputElement ? this.inputElement[this._inputElementValueProperty] : void 0;
    }
    /**
     * The input element's value.
     *
     * @protected
     */
    set _inputElementValue(e) {
      this.inputElement && (this.inputElement[this._inputElementValueProperty] = e);
    }
    /**
     * Clear the value of the field.
     */
    clear() {
      this._hasInputValue = !1, this.value = "", this._inputElementValue = "";
    }
    /**
     * Add event listeners to the input element instance.
     * Override this method to add custom listeners.
     * @param {!HTMLElement} input
     * @protected
     */
    _addInputListeners(e) {
      e.addEventListener("input", this._boundOnInput), e.addEventListener("change", this._boundOnChange);
    }
    /**
     * Remove event listeners from the input element instance.
     * @param {!HTMLElement} input
     * @protected
     */
    _removeInputListeners(e) {
      e.removeEventListener("input", this._boundOnInput), e.removeEventListener("change", this._boundOnChange);
    }
    /**
     * A method to forward the value property set on the field
     * programmatically back to the input element value.
     * Override this method to perform additional checks,
     * for example to skip this in certain conditions.
     * @param {string} value
     * @protected
     */
    _forwardInputValue(e) {
      this.inputElement && (this._inputElementValue = e ?? "");
    }
    /**
     * @param {HTMLElement | undefined} input
     * @param {HTMLElement | undefined} oldInput
     * @protected
     */
    _inputElementChanged(e, t) {
      e ? this._addInputListeners(e) : t && this._removeInputListeners(t);
    }
    /**
     * Observer to notify about the change of private property.
     *
     * @private
     */
    _hasInputValueChanged(e, t) {
      (e || t) && this.dispatchEvent(new CustomEvent("has-input-value-changed"));
    }
    /**
     * An input event listener used to update `_hasInputValue` property.
     * Do not override this method.
     *
     * @param {Event} event
     * @private
     */
    __onInput(e) {
      this._setHasInputValue(e), this._onInput(e);
    }
    /**
     * An input event listener used to update the field value.
     *
     * @param {Event} event
     * @protected
     */
    _onInput(e) {
      const t = e.composedPath()[0];
      this.__userInput = e.isTrusted, this.value = t.value, this.__userInput = !1;
    }
    /**
     * A change event listener.
     * Override this method with an actual implementation.
     * @param {Event} _event
     * @protected
     */
    _onChange(e) {
    }
    /**
     * Toggle the has-value attribute based on the value property.
     *
     * @param {boolean} hasValue
     * @protected
     */
    _toggleHasValue(e) {
      this.toggleAttribute("has-value", e);
    }
    /**
     * Observer called when a value property changes.
     * @param {string | undefined} newVal
     * @param {string | undefined} oldVal
     * @protected
     */
    _valueChanged(e, t) {
      this._toggleHasValue(this._hasValue), !(e === "" && t === void 0) && (this.__userInput || this._forwardInputValue(e));
    }
    /**
     * Sets the `_hasInputValue` property based on the `input` event.
     *
     * @param {InputEvent} event
     * @protected
     */
    _setHasInputValue(e) {
      const t = e.composedPath()[0];
      this._hasInputValue = t.value.length > 0;
    }
  }
);
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const pg = (s) => class extends ta(Js(s)) {
  static get properties() {
    return {
      /**
       * Set to true to display the clear icon which clears the input.
       *
       * It is up to the component to choose where to place the clear icon:
       * in the Shadow DOM or in the light DOM. In any way, a reference to
       * the clear icon element should be provided via the `clearElement` getter.
       *
       * @attr {boolean} clear-button-visible
       */
      clearButtonVisible: {
        type: Boolean,
        reflectToAttribute: !0,
        value: !1
      }
    };
  }
  /**
   * Any element extending this mixin is required to implement this getter.
   * It returns the reference to the clear button element.
   *
   * @protected
   * @return {Element | null | undefined}
   */
  get clearElement() {
    return console.warn(`Please implement the 'clearElement' property in <${this.localName}>`), null;
  }
  /** @protected */
  ready() {
    super.ready(), this.clearElement && (this.clearElement.addEventListener("mousedown", (e) => this._onClearButtonMouseDown(e)), this.clearElement.addEventListener("click", (e) => this._onClearButtonClick(e)));
  }
  /**
   * @param {Event} event
   * @protected
   */
  _onClearButtonClick(e) {
    e.preventDefault(), this._onClearAction();
  }
  /**
   * @param {MouseEvent} event
   * @protected
   */
  _onClearButtonMouseDown(e) {
    e.preventDefault(), Mr || this.inputElement.focus();
  }
  /**
   * Override an event listener inherited from `KeydownMixin` to clear on Esc.
   * Components that extend this mixin can prevent this behavior by overriding
   * this method without calling `super._onEscape` to provide custom logic.
   *
   * @param {KeyboardEvent} event
   * @protected
   * @override
   */
  _onEscape(e) {
    super._onEscape(e), this.clearButtonVisible && this.value && (e.stopPropagation(), this._onClearAction());
  }
  /**
   * Clears the value and dispatches `input` and `change` events
   * on the input element. This method should be called
   * when the clear action originates from the user.
   *
   * @protected
   */
  _onClearAction() {
    this._inputElementValue = "", this.inputElement.dispatchEvent(new Event("input", { bubbles: !0, composed: !0 })), this.inputElement.dispatchEvent(new Event("change", { bubbles: !0 }));
  }
};
/**
 * @license
 * Copyright (c) 2022 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class ia extends js {
  constructor(r, e, t, i = {}) {
    super(r, e, t, { ...i, useUniqueId: !0 });
  }
  /**
   * Override to initialize the newly added custom node.
   *
   * @param {Node} node
   * @protected
   * @override
   */
  initCustomNode(r) {
    this.__updateNodeId(r), this.__notifyChange(r);
  }
  /**
   * Override to notify the controller host about removal of
   * the custom node, and to apply the default one if needed.
   *
   * @param {Node} _node
   * @protected
   * @override
   */
  teardownNode(r) {
    const e = this.getSlotChild();
    e && e !== this.defaultNode ? this.__notifyChange(e) : (this.restoreDefaultNode(), this.updateDefaultNode(this.node));
  }
  /**
   * Override method inherited from `SlotMixin`
   * to set ID attribute on the default node.
   *
   * @return {Node}
   * @protected
   * @override
   */
  attachDefaultNode() {
    const r = super.attachDefaultNode();
    return r && this.__updateNodeId(r), r;
  }
  /**
   * Override to restore default node when a custom one is removed.
   *
   * @protected
   */
  restoreDefaultNode() {
  }
  /**
   * Override to update default node text on property change.
   *
   * @param {Node} node
   * @protected
   */
  updateDefaultNode(r) {
    this.__notifyChange(r);
  }
  /**
   * Setup the mutation observer on the node to update ID and notify host.
   * Node doesn't get observed automatically until this method is called.
   *
   * @param {Node} node
   * @protected
   */
  observeNode(r) {
    this.__nodeObserver && this.__nodeObserver.disconnect(), this.__nodeObserver = new MutationObserver((e) => {
      e.forEach((t) => {
        const i = t.target, n = i === this.node;
        t.type === "attributes" ? n && this.__updateNodeId(i) : (n || i.parentElement === this.node) && this.__notifyChange(this.node);
      });
    }), this.__nodeObserver.observe(r, {
      attributes: !0,
      attributeFilter: ["id"],
      childList: !0,
      subtree: !0,
      characterData: !0
    });
  }
  /**
   * Returns true if a node is an HTML element with children,
   * or is a defined custom element, or has non-empty text.
   *
   * @param {Node} node
   * @return {boolean}
   * @private
   */
  __hasContent(r) {
    return r ? r.nodeType === Node.ELEMENT_NODE && (customElements.get(r.localName) || r.children.length > 0) || r.textContent && r.textContent.trim() !== "" : !1;
  }
  /**
   * Fire an event to notify the controller host about node changes.
   *
   * @param {Node} node
   * @private
   */
  __notifyChange(r) {
    this.dispatchEvent(
      new CustomEvent("slot-content-changed", {
        detail: { hasContent: this.__hasContent(r), node: r }
      })
    );
  }
  /**
   * Set default ID on the node in case it is an HTML element.
   *
   * @param {Node} node
   * @private
   */
  __updateNodeId(r) {
    const e = !this.nodes || r === this.nodes[0];
    r.nodeType === Node.ELEMENT_NODE && (!this.multiple || e) && !r.id && (r.id = this.defaultId);
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class gg extends ia {
  constructor(r) {
    super(r, "error-message", "div");
  }
  /**
   * Set the error message element text content.
   *
   * @param {string} errorMessage
   */
  setErrorMessage(r) {
    this.errorMessage = r, this.updateDefaultNode(this.node);
  }
  /**
   * Set invalid state for detecting whether to show error message.
   *
   * @param {boolean} invalid
   */
  setInvalid(r) {
    this.invalid = r, this.updateDefaultNode(this.node);
  }
  /**
   * Override method inherited from `SlotController` to not run
   * initializer on the custom slotted node unnecessarily.
   *
   * @param {Node} node
   * @protected
   * @override
   */
  initAddedNode(r) {
    r !== this.defaultNode && this.initCustomNode(r);
  }
  /**
   * Override to initialize the newly added default error message.
   *
   * @param {Node} errorNode
   * @protected
   * @override
   */
  initNode(r) {
    this.updateDefaultNode(r);
  }
  /**
   * Override to initialize the newly added custom error message.
   *
   * @param {Node} errorNode
   * @protected
   * @override
   */
  initCustomNode(r) {
    r.textContent && !this.errorMessage && (this.errorMessage = r.textContent.trim()), super.initCustomNode(r);
  }
  /**
   * Override method inherited from `SlotChildObserveController`
   * to restore the default error message element.
   *
   * @protected
   * @override
   */
  restoreDefaultNode() {
    this.attachDefaultNode();
  }
  /**
   * Override method inherited from `SlotChildObserveController`
   * to update the error message text and hidden state.
   *
   * Note: unlike with other controllers, this method is
   * called for both default and custom error message.
   *
   * @param {Node | undefined} node
   * @protected
   * @override
   */
  updateDefaultNode(r) {
    const { errorMessage: e, invalid: t } = this, i = !!(t && e && e.trim() !== "");
    r && (r.textContent = i ? e : "", r.hidden = !i, i ? r.setAttribute("role", "alert") : r.removeAttribute("role")), super.updateDefaultNode(r);
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class mg extends ia {
  constructor(r) {
    super(r, "helper", null);
  }
  /**
   * Set helper text based on corresponding host property.
   *
   * @param {string} helperText
   */
  setHelperText(r) {
    this.helperText = r, this.getSlotChild() || this.restoreDefaultNode(), this.node === this.defaultNode && this.updateDefaultNode(this.node);
  }
  /**
   * Override method inherited from `SlotChildObserveController`
   * to create the default helper element lazily as needed.
   *
   * @param {Node | undefined} node
   * @protected
   * @override
   */
  restoreDefaultNode() {
    const { helperText: r } = this;
    if (r && r.trim() !== "") {
      this.tagName = "div";
      const e = this.attachDefaultNode();
      this.observeNode(e);
    }
  }
  /**
   * Override method inherited from `SlotChildObserveController`
   * to update the default helper element text content.
   *
   * @param {Node | undefined} node
   * @protected
   * @override
   */
  updateDefaultNode(r) {
    r && (r.textContent = this.helperText), super.updateDefaultNode(r);
  }
  /**
   * Override to observe the newly added custom node.
   *
   * @param {Node} node
   * @protected
   * @override
   */
  initCustomNode(r) {
    super.initCustomNode(r), this.observeNode(r);
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class vg extends ia {
  constructor(r) {
    super(r, "label", "label");
  }
  /**
   * Set label based on corresponding host property.
   *
   * @param {string} label
   */
  setLabel(r) {
    this.label = r, this.getSlotChild() || this.restoreDefaultNode(), this.node === this.defaultNode && this.updateDefaultNode(this.node);
  }
  /**
   * Override method inherited from `SlotChildObserveController`
   * to restore and observe the default label element.
   *
   * @protected
   * @override
   */
  restoreDefaultNode() {
    const { label: r } = this;
    if (r && r.trim() !== "") {
      const e = this.attachDefaultNode();
      this.observeNode(e);
    }
  }
  /**
   * Override method inherited from `SlotChildObserveController`
   * to update the default label element text content.
   *
   * @param {Node | undefined} node
   * @protected
   * @override
   */
  updateDefaultNode(r) {
    r && (r.textContent = this.label), super.updateDefaultNode(r);
  }
  /**
   * Override to observe the newly added custom node.
   *
   * @param {Node} node
   * @protected
   * @override
   */
  initCustomNode(r) {
    super.initCustomNode(r), this.observeNode(r);
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const _g = $e(
  (s) => class extends Wr(s) {
    static get properties() {
      return {
        /**
         * The label text for the input node.
         * When no light dom defined via [slot=label], this value will be used.
         */
        label: {
          type: String,
          observer: "_labelChanged"
        }
      };
    }
    constructor() {
      super(), this._labelController = new vg(this), this._labelController.addEventListener("slot-content-changed", (e) => {
        this.toggleAttribute("has-label", e.detail.hasContent);
      });
    }
    /** @protected */
    get _labelId() {
      const e = this._labelNode;
      return e && e.id;
    }
    /** @protected */
    get _labelNode() {
      return this._labelController.node;
    }
    /** @protected */
    ready() {
      super.ready(), this.addController(this._labelController);
    }
    /** @protected */
    _labelChanged(e) {
      this._labelController.setLabel(e);
    }
  }
);
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const ra = $e(
  (s) => class extends s {
    static get properties() {
      return {
        /**
         * Set to true when the field is invalid.
         */
        invalid: {
          type: Boolean,
          reflectToAttribute: !0,
          notify: !0,
          value: !1
        },
        /**
         * Specifies that the user must fill in a value.
         */
        required: {
          type: Boolean,
          reflectToAttribute: !0
        }
      };
    }
    /**
     * Validates the field and sets the `invalid` property based on the result.
     *
     * The method fires a `validated` event with the result of the validation.
     *
     * @return {boolean} True if the value is valid.
     */
    validate() {
      const e = this.checkValidity();
      return this._setInvalid(!e), this.dispatchEvent(new CustomEvent("validated", { detail: { valid: e } })), e;
    }
    /**
     * Returns true if the field value satisfies all constraints (if any).
     *
     * @return {boolean}
     */
    checkValidity() {
      return !this.required || !!this.value;
    }
    /**
     * @param {boolean} invalid
     * @protected
     */
    _setInvalid(e) {
      this._shouldSetInvalid(e) && (this.invalid = e);
    }
    /**
     * Override this method to define whether the given `invalid` state should be set.
     *
     * @param {boolean} _invalid
     * @return {boolean}
     * @protected
     */
    _shouldSetInvalid(e) {
      return !0;
    }
    /**
     * Fired whenever the field is validated.
     *
     * @event validated
     * @param {Object} detail
     * @param {boolean} detail.valid the result of the validation.
     */
  }
);
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const bg = (s) => class extends ra(_g(Wr(s))) {
  static get properties() {
    return {
      /**
       * A target element to which ARIA attributes are set.
       * @protected
       */
      ariaTarget: {
        type: Object,
        observer: "_ariaTargetChanged"
      },
      /**
       * Error to show when the field is invalid.
       *
       * @attr {string} error-message
       */
      errorMessage: {
        type: String,
        observer: "_errorMessageChanged"
      },
      /**
       * String used for the helper text.
       * @attr {string} helper-text
       */
      helperText: {
        type: String,
        observer: "_helperTextChanged"
      },
      /**
       * String used to label the component to screen reader users.
       * @attr {string} accessible-name
       */
      accessibleName: {
        type: String,
        observer: "_accessibleNameChanged"
      },
      /**
       * Id of the element used as label of the component to screen reader users.
       * @attr {string} accessible-name-ref
       */
      accessibleNameRef: {
        type: String,
        observer: "_accessibleNameRefChanged"
      }
    };
  }
  static get observers() {
    return ["_invalidChanged(invalid)", "_requiredChanged(required)"];
  }
  constructor() {
    super(), this._fieldAriaController = new bp(this), this._helperController = new mg(this), this._errorController = new gg(this), this._errorController.addEventListener("slot-content-changed", (e) => {
      this.toggleAttribute("has-error-message", e.detail.hasContent);
    }), this._labelController.addEventListener("slot-content-changed", (e) => {
      const { hasContent: t, node: i } = e.detail;
      this.__labelChanged(t, i);
    }), this._helperController.addEventListener("slot-content-changed", (e) => {
      const { hasContent: t, node: i } = e.detail;
      this.toggleAttribute("has-helper", t), this.__helperChanged(t, i);
    });
  }
  /**
   * @protected
   * @return {HTMLElement}
   */
  get _errorNode() {
    return this._errorController.node;
  }
  /**
   * @protected
   * @return {HTMLElement}
   */
  get _helperNode() {
    return this._helperController.node;
  }
  /** @protected */
  ready() {
    super.ready(), this.addController(this._fieldAriaController), this.addController(this._helperController), this.addController(this._errorController);
  }
  /** @private */
  __helperChanged(e, t) {
    e ? this._fieldAriaController.setHelperId(t.id) : this._fieldAriaController.setHelperId(null);
  }
  /** @protected */
  _accessibleNameChanged(e) {
    this._fieldAriaController.setAriaLabel(e);
  }
  /** @protected */
  _accessibleNameRefChanged(e) {
    this._fieldAriaController.setLabelId(e, !0);
  }
  /** @private */
  __labelChanged(e, t) {
    e ? this._fieldAriaController.setLabelId(t.id) : this._fieldAriaController.setLabelId(null);
  }
  /**
   * @param {string | null | undefined} errorMessage
   * @protected
   */
  _errorMessageChanged(e) {
    this._errorController.setErrorMessage(e);
  }
  /**
   * @param {string} helperText
   * @protected
   */
  _helperTextChanged(e) {
    this._helperController.setHelperText(e);
  }
  /**
   * @param {HTMLElement | null | undefined} target
   * @protected
   */
  _ariaTargetChanged(e) {
    e && this._fieldAriaController.setTarget(e);
  }
  /**
   * @param {boolean} required
   * @protected
   */
  _requiredChanged(e) {
    this._fieldAriaController.setRequired(e);
  }
  /**
   * @param {boolean} invalid
   * @protected
   */
  _invalidChanged(e) {
    this._errorController.setInvalid(e), setTimeout(() => {
      if (e) {
        const t = this._errorNode;
        this._fieldAriaController.setErrorId(t && t.id);
      } else
        this._fieldAriaController.setErrorId(null);
    });
  }
};
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const yg = $e(
  (s) => class extends s {
    static get properties() {
      return {
        /**
         * A target element to which attributes and properties are delegated.
         * @protected
         */
        stateTarget: {
          type: Object,
          observer: "_stateTargetChanged"
        }
      };
    }
    /**
     * An array of the host attributes to delegate to the target element.
     */
    static get delegateAttrs() {
      return [];
    }
    /**
     * An array of the host properties to delegate to the target element.
     */
    static get delegateProps() {
      return [];
    }
    /** @protected */
    ready() {
      super.ready(), this._createDelegateAttrsObserver(), this._createDelegatePropsObserver();
    }
    /** @protected */
    _stateTargetChanged(e) {
      e && (this._ensureAttrsDelegated(), this._ensurePropsDelegated());
    }
    /** @protected */
    _createDelegateAttrsObserver() {
      this._createMethodObserver(`_delegateAttrsChanged(${this.constructor.delegateAttrs.join(", ")})`);
    }
    /** @protected */
    _createDelegatePropsObserver() {
      this._createMethodObserver(`_delegatePropsChanged(${this.constructor.delegateProps.join(", ")})`);
    }
    /** @protected */
    _ensureAttrsDelegated() {
      this.constructor.delegateAttrs.forEach((e) => {
        this._delegateAttribute(e, this[e]);
      });
    }
    /** @protected */
    _ensurePropsDelegated() {
      this.constructor.delegateProps.forEach((e) => {
        this._delegateProperty(e, this[e]);
      });
    }
    /** @protected */
    _delegateAttrsChanged(...e) {
      this.constructor.delegateAttrs.forEach((t, i) => {
        this._delegateAttribute(t, e[i]);
      });
    }
    /** @protected */
    _delegatePropsChanged(...e) {
      this.constructor.delegateProps.forEach((t, i) => {
        this._delegateProperty(t, e[i]);
      });
    }
    /** @protected */
    _delegateAttribute(e, t) {
      this.stateTarget && (e === "invalid" && this._delegateAttribute("aria-invalid", t ? "true" : !1), typeof t == "boolean" ? this.stateTarget.toggleAttribute(e, t) : t ? this.stateTarget.setAttribute(e, t) : this.stateTarget.removeAttribute(e));
    }
    /** @protected */
    _delegateProperty(e, t) {
      this.stateTarget && (this.stateTarget[e] = t);
    }
  }
);
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const hh = $e(
  (s) => class extends yg(ra(ta(s))) {
    /**
     * An array of attributes which participate in the input validation.
     * Changing these attributes will cause the input to re-validate.
     *
     * IMPORTANT: The attributes should be properly delegated to the input element
     * from the host using `delegateAttrs` getter (see `DelegateStateMixin`).
     * The `required` attribute is already delegated.
     */
    static get constraints() {
      return ["required"];
    }
    static get delegateAttrs() {
      return [...super.delegateAttrs, "required"];
    }
    /** @protected */
    ready() {
      super.ready(), this._createConstraintsObserver();
    }
    /**
     * Returns true if the current input value satisfies all constraints (if any).
     * @return {boolean}
     */
    checkValidity() {
      return this.inputElement && this._hasValidConstraints(this.constructor.constraints.map((e) => this[e])) ? this.inputElement.checkValidity() : !this.invalid;
    }
    /**
     * Returns true if some of the provided set of constraints are valid.
     * @param {Array} constraints
     * @return {boolean}
     * @protected
     */
    _hasValidConstraints(e) {
      return e.some((t) => this.__isValidConstraint(t));
    }
    /**
     * Override this method to customize setting up constraints observer.
     * @protected
     */
    _createConstraintsObserver() {
      this._createMethodObserver(`_constraintsChanged(stateTarget, ${this.constructor.constraints.join(", ")})`);
    }
    /**
     * Override this method to implement custom validation constraints.
     * @param {HTMLElement | undefined} stateTarget
     * @param {unknown[]} constraints
     * @protected
     */
    _constraintsChanged(e, ...t) {
      if (!e)
        return;
      const i = this._hasValidConstraints(t), n = this.__previousHasConstraints && !i;
      (this._hasValue || this.invalid) && i ? this.validate() : n && this._setInvalid(!1), this.__previousHasConstraints = i;
    }
    /**
     * Override an event listener inherited from `InputMixin`
     * to capture native `change` event and make sure that
     * a new one is dispatched after validation runs.
     * @param {Event} event
     * @protected
     * @override
     */
    _onChange(e) {
      e.stopPropagation(), this.validate(), this.dispatchEvent(
        new CustomEvent("change", {
          detail: {
            sourceEvent: e
          },
          bubbles: e.bubbles,
          cancelable: e.cancelable
        })
      );
    }
    /** @private */
    __isValidConstraint(e) {
      return !!e || e === 0;
    }
  }
);
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const wg = (s) => class extends fg(
  mp(hh(bg(pg(Js(s)))))
) {
  static get properties() {
    return {
      /**
       * A pattern matched against individual characters the user inputs.
       *
       * When set, the field will prevent:
       * - `keydown` events if the entered key doesn't match `/^allowedCharPattern$/`
       * - `paste` events if the pasted text doesn't match `/^allowedCharPattern*$/`
       * - `drop` events if the dropped text doesn't match `/^allowedCharPattern*$/`
       *
       * For example, to allow entering only numbers and minus signs, use:
       * `allowedCharPattern = "[\\d-]"`
       * @attr {string} allowed-char-pattern
       */
      allowedCharPattern: {
        type: String,
        observer: "_allowedCharPatternChanged"
      },
      /**
       * If true, the input text gets fully selected when the field is focused using click or touch / tap.
       */
      autoselect: {
        type: Boolean,
        value: !1
      },
      /**
       * The name of this field.
       */
      name: {
        type: String,
        reflectToAttribute: !0
      },
      /**
       * A hint to the user of what can be entered in the field.
       */
      placeholder: {
        type: String,
        reflectToAttribute: !0
      },
      /**
       * When present, it specifies that the field is read-only.
       */
      readonly: {
        type: Boolean,
        value: !1,
        reflectToAttribute: !0
      },
      /**
       * The text usually displayed in a tooltip popup when the mouse is over the field.
       */
      title: {
        type: String,
        reflectToAttribute: !0
      }
    };
  }
  static get delegateAttrs() {
    return [...super.delegateAttrs, "name", "type", "placeholder", "readonly", "invalid", "title"];
  }
  constructor() {
    super(), this._boundOnPaste = this._onPaste.bind(this), this._boundOnDrop = this._onDrop.bind(this), this._boundOnBeforeInput = this._onBeforeInput.bind(this);
  }
  /** @protected */
  get slotStyles() {
    return [
      `
          :is(input[slot='input'], textarea[slot='textarea'])::placeholder {
            font: inherit;
            color: inherit;
          }
        `
    ];
  }
  /**
   * Override an event listener from `DelegateFocusMixin`.
   * @param {FocusEvent} event
   * @protected
   * @override
   */
  _onFocus(e) {
    super._onFocus(e), this.autoselect && this.inputElement && this.inputElement.select();
  }
  /**
   * Override an event listener inherited from `InputMixin`
   * to capture native `change` event and make sure that
   * a new one is dispatched after validation runs.
   * @param {Event} event
   * @protected
   * @override
   */
  _onChange(e) {
    e.stopPropagation(), this.validate(), this.dispatchEvent(
      new CustomEvent("change", {
        detail: {
          sourceEvent: e
        },
        bubbles: e.bubbles,
        cancelable: e.cancelable
      })
    );
  }
  /**
   * Override a method from `InputMixin`.
   * @param {!HTMLElement} input
   * @protected
   * @override
   */
  _addInputListeners(e) {
    super._addInputListeners(e), e.addEventListener("paste", this._boundOnPaste), e.addEventListener("drop", this._boundOnDrop), e.addEventListener("beforeinput", this._boundOnBeforeInput);
  }
  /**
   * Override a method from `InputMixin`.
   * @param {!HTMLElement} input
   * @protected
   * @override
   */
  _removeInputListeners(e) {
    super._removeInputListeners(e), e.removeEventListener("paste", this._boundOnPaste), e.removeEventListener("drop", this._boundOnDrop), e.removeEventListener("beforeinput", this._boundOnBeforeInput);
  }
  /**
   * Override an event listener from `KeyboardMixin`.
   * @param {!KeyboardEvent} event
   * @protected
   * @override
   */
  _onKeyDown(e) {
    super._onKeyDown(e), this.allowedCharPattern && !this.__shouldAcceptKey(e) && e.target === this.inputElement && (e.preventDefault(), this._markInputPrevented());
  }
  /** @protected */
  _markInputPrevented() {
    this.setAttribute("input-prevented", ""), this._preventInputDebouncer = Le.debounce(this._preventInputDebouncer, Ft.after(200), () => {
      this.removeAttribute("input-prevented");
    });
  }
  /** @private */
  __shouldAcceptKey(e) {
    return e.metaKey || e.ctrlKey || !e.key || // Allow typing anything if event.key is not supported
    e.key.length !== 1 || // Allow "Backspace", "ArrowLeft" etc.
    this.__allowedCharRegExp.test(e.key);
  }
  /** @private */
  _onPaste(e) {
    if (this.allowedCharPattern) {
      const t = e.clipboardData.getData("text");
      this.__allowedTextRegExp.test(t) || (e.preventDefault(), this._markInputPrevented());
    }
  }
  /** @private */
  _onDrop(e) {
    if (this.allowedCharPattern) {
      const t = e.dataTransfer.getData("text");
      this.__allowedTextRegExp.test(t) || (e.preventDefault(), this._markInputPrevented());
    }
  }
  /** @private */
  _onBeforeInput(e) {
    this.allowedCharPattern && e.data && !this.__allowedTextRegExp.test(e.data) && (e.preventDefault(), this._markInputPrevented());
  }
  /** @private */
  _allowedCharPatternChanged(e) {
    if (e)
      try {
        this.__allowedCharRegExp = new RegExp(`^${e}$`, "u"), this.__allowedTextRegExp = new RegExp(`^${e}*$`, "u");
      } catch (t) {
        console.error(t);
      }
  }
  /**
   * Fired when the user commits a value change.
   *
   * @event change
   */
  /**
   * Fired when the value is changed by the user: on every typing keystroke,
   * and the value is cleared using the clear button.
   *
   * @event input
   */
};
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class xg extends js {
  constructor(r, e, t = {}) {
    const { uniqueIdPrefix: i } = t;
    super(r, "input", "input", {
      initializer: (n, o) => {
        o.value && (n.value = o.value), o.type && n.setAttribute("type", o.type), n.id = this.defaultId, typeof e == "function" && e(n);
      },
      useUniqueId: !0,
      uniqueIdPrefix: i
    });
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class Cg {
  constructor(r, e) {
    this.input = r, this.__preventDuplicateLabelClick = this.__preventDuplicateLabelClick.bind(this), e.addEventListener("slot-content-changed", (t) => {
      this.__initLabel(t.detail.node);
    }), this.__initLabel(e.node);
  }
  /**
   * @param {HTMLElement} label
   * @private
   */
  __initLabel(r) {
    r && (r.addEventListener("click", this.__preventDuplicateLabelClick), this.input && r.setAttribute("for", this.input.id));
  }
  /**
   * The native platform fires an event for both the click on the label, and also
   * the subsequent click on the native input element caused by label click.
   * This results in two click events arriving at the host, but we only want one.
   * This method prevents the duplicate click and ensures the correct isTrusted event
   * with the correct event.target arrives at the host.
   * @private
   */
  __preventDuplicateLabelClick() {
    const r = (e) => {
      e.stopImmediatePropagation(), this.input.removeEventListener("click", r);
    };
    this.input.addEventListener("click", r);
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Tg = (s) => class extends hh(s) {
  static get properties() {
    return {
      /**
       * A regular expression that the value is checked against.
       * The pattern must match the entire value, not just some subset.
       */
      pattern: {
        type: String
      }
    };
  }
  static get delegateAttrs() {
    return [...super.delegateAttrs, "pattern"];
  }
  static get constraints() {
    return [...super.constraints, "pattern"];
  }
};
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd..
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Eg = ke`
  [part='clear-button'] {
    display: none;
    cursor: default;
  }

  [part='clear-button']::before {
    content: '\\2715';
  }

  :host([clear-button-visible][has-value]:not([disabled]):not([readonly])) [part='clear-button'] {
    display: block;
  }
`;
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd..
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Pg = ke`
  :host {
    display: inline-flex;
    outline: none;
  }

  :host::before {
    content: '\\2003';
    width: 0;
    display: inline-block;
    /* Size and position this element on the same vertical position as the input-field element
          to make vertical align for the host element work as expected */
  }

  :host([hidden]) {
    display: none !important;
  }

  :host(:not([has-label])) [part='label'] {
    display: none;
  }

  @media (forced-colors: active) {
    :host(:not([readonly])) [part='input-field'] {
      outline: 1px solid;
      outline-offset: -1px;
    }
    :host([focused]) [part='input-field'] {
      outline-width: 2px;
    }
    :host([disabled]) [part='input-field'] {
      outline-color: GrayText;
    }
  }
`;
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd..
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Sg = ke`
  [class$='container'] {
    display: flex;
    flex-direction: column;
    min-width: 100%;
    max-width: 100%;
    width: var(--vaadin-field-default-width, 12em);
  }
`;
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd..
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const kg = [Pg, Sg, Eg];
/**
 * @license
 * Copyright (c) 2015 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Ag = (s) => class extends s {
  static get properties() {
    return {
      /**
       * Number of items fetched at a time from the dataprovider.
       * @attr {number} page-size
       * @type {number}
       */
      pageSize: {
        type: Number,
        value: 50,
        observer: "_pageSizeChanged",
        sync: !0
      },
      /**
       * Total number of items.
       * @type {number | undefined}
       */
      size: {
        type: Number,
        observer: "_sizeChanged",
        sync: !0
      },
      /**
       * Function that provides items lazily. Receives arguments `params`, `callback`
       *
       * `params.page` Requested page index
       *
       * `params.pageSize` Current page size
       *
       * `params.filter` Currently applied filter
       *
       * `callback(items, size)` Callback function with arguments:
       *   - `items` Current page of items
       *   - `size` Total number of items.
       * @type {ComboBoxDataProvider | undefined}
       */
      dataProvider: {
        type: Object,
        observer: "_dataProviderChanged",
        sync: !0
      },
      /** @private */
      __dataProviderInitialized: {
        type: Boolean,
        value: !1
      },
      /** @private */
      __previousDataProviderFilter: {
        type: String
      }
    };
  }
  static get observers() {
    return [
      "_dataProviderFilterChanged(filter)",
      "_warnDataProviderValue(dataProvider, value)",
      "_ensureFirstPage(opened)"
    ];
  }
  constructor() {
    super(), this.__dataProviderController = new $c(this, {
      placeholder: new Yi(),
      isPlaceholder: (e) => e instanceof Yi,
      dataProviderParams: () => ({ filter: this.filter })
    }), this.__dataProviderController.addEventListener("page-requested", this.__onDataProviderPageRequested.bind(this)), this.__dataProviderController.addEventListener("page-loaded", this.__onDataProviderPageLoaded.bind(this));
  }
  /** @protected */
  ready() {
    super.ready(), this._scroller.addEventListener("index-requested", (e) => {
      if (!this._shouldFetchData())
        return;
      const t = e.detail.index;
      t !== void 0 && this.__dataProviderController.ensureFlatIndexLoaded(t);
    }), this.__dataProviderInitialized = !0, this.dataProvider && this.__synchronizeControllerState();
  }
  /** @private */
  _dataProviderFilterChanged(e) {
    if (this.__previousDataProviderFilter === void 0 && e === "") {
      this.__previousDataProviderFilter = e;
      return;
    }
    this.__previousDataProviderFilter !== e && (this.__previousDataProviderFilter = e, this.__keepOverlayOpened = !0, this.size = void 0, this.clearCache(), this.__keepOverlayOpened = !1);
  }
  /** @protected */
  _shouldFetchData() {
    return this.dataProvider ? this.opened || this.filter && this.filter.length : !1;
  }
  /** @private */
  _ensureFirstPage(e) {
    !this._shouldFetchData() || !e || (this._forceNextRequest || this.size === void 0 ? (this._forceNextRequest = !1, this.__dataProviderController.loadFirstPage()) : this.size > 0 && this.__dataProviderController.ensureFlatIndexLoaded(0));
  }
  /** @private */
  __onDataProviderPageRequested() {
    this.loading = !0;
  }
  /** @private */
  __onDataProviderPageLoaded() {
    const { rootCache: e } = this.__dataProviderController;
    e.items = [...e.items], this.__synchronizeControllerState(), !this.opened && !this._isInputFocused() && this._commitValue();
  }
  /**
   * Clears the cached pages and reloads data from dataprovider when needed.
   */
  clearCache() {
    this.dataProvider && (this.__dataProviderController.clearCache(), this.__synchronizeControllerState(), this._shouldFetchData() ? (this._forceNextRequest = !1, this.__dataProviderController.loadFirstPage()) : this._forceNextRequest = !0);
  }
  /**
   * When the size change originates externally, synchronizes the new size with
   * the controller and request a content update to re-render the scroller.
   *
   * @private
   */
  _sizeChanged(e) {
    const { rootCache: t } = this.__dataProviderController;
    t.size !== e && (t.size = e, t.items = [...t.items], this.__synchronizeControllerState());
  }
  /**
   * When the items change originates externally, synchronizes the new items with
   * the controller and requests a content update to re-render the scroller.
   *
   * @private
   * @override
   */
  _filteredItemsChanged(e) {
    if (super._filteredItemsChanged(e), this.dataProvider && e) {
      const { rootCache: t } = this.__dataProviderController;
      t.items !== e && (t.items = e, this.__synchronizeControllerState());
    }
  }
  /**
   * Synchronizes the controller's state with the component, which can be
   * out of sync after the controller receives new data from the data provider
   * or if the state in the controller is directly manipulated.
   *
   * @private
   */
  __synchronizeControllerState() {
    if (this.__dataProviderInitialized && this.dataProvider) {
      const { rootCache: e } = this.__dataProviderController;
      this.size = e.size, this.filteredItems = e.items, this.loading = this.__dataProviderController.isLoading();
    }
  }
  /** @private */
  _pageSizeChanged(e, t) {
    if (Math.floor(e) !== e || e < 1)
      throw this.pageSize = t, new Error("`pageSize` value must be an integer > 0");
    this.__dataProviderController.setPageSize(e), this.clearCache();
  }
  /** @private */
  _dataProviderChanged(e, t) {
    this._ensureItemsOrDataProvider(() => {
      this.dataProvider = t;
    }), this.__dataProviderController.setDataProvider(e), this.clearCache();
  }
  /** @private */
  _ensureItemsOrDataProvider(e) {
    if (this.items !== void 0 && this.dataProvider !== void 0)
      throw e(), new Error("Using `items` and `dataProvider` together is not supported");
  }
  /** @private */
  _warnDataProviderValue(e, t) {
    if (e && t !== "" && (this.selectedItem === void 0 || this.selectedItem === null)) {
      const i = this.__getItemIndexByValue(this.filteredItems, t);
      (i < 0 || !this._getItemLabel(this.filteredItems[i])) && console.warn(
        "Warning: unable to determine the label for the provided `value`. Nothing to display in the text field. This usually happens when setting an initial `value` before any items are returned from the `dataProvider` callback. Consider setting `selectedItem` instead of `value`"
      );
    }
  }
};
/**
 * @license
 * Copyright (c) 2023 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Rg = (s) => class extends s {
  static get properties() {
    return {
      /**
       * A space-delimited list of CSS class names to set on the overlay element.
       * This property does not affect other CSS class names set manually via JS.
       *
       * Note, if the CSS class name was set with this property, clearing it will
       * remove it from the overlay, even if the same class name was also added
       * manually, e.g. by using `classList.add()` in the `renderer` function.
       *
       * @attr {string} overlay-class
       */
      overlayClass: {
        type: String
      },
      /**
       * An overlay element on which CSS class names are set.
       *
       * @protected
       */
      _overlayElement: {
        type: Object
      }
    };
  }
  static get observers() {
    return ["__updateOverlayClassNames(overlayClass, _overlayElement)"];
  }
  /** @private */
  __updateOverlayClassNames(e, t) {
    if (!t || e === void 0)
      return;
    const { classList: i } = t;
    if (this.__initialClasses || (this.__initialClasses = new Set(i)), Array.isArray(this.__previousClasses)) {
      const o = this.__previousClasses.filter((a) => !this.__initialClasses.has(a));
      o.length > 0 && i.remove(...o);
    }
    const n = typeof e == "string" ? e.split(" ").filter(Boolean) : [];
    n.length > 0 && i.add(...n), this.__previousClasses = n;
  }
};
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class Ig {
  /**
   * @param {{ inputElement?: HTMLElement; opened: boolean } & HTMLElement} host
   */
  constructor(r) {
    this.host = r, r.addEventListener("opened-changed", () => {
      r.opened || this.__setVirtualKeyboardEnabled(!1);
    }), r.addEventListener("blur", () => this.__setVirtualKeyboardEnabled(!0)), r.addEventListener("touchstart", () => this.__setVirtualKeyboardEnabled(!0));
  }
  /** @private */
  __setVirtualKeyboardEnabled(r) {
    this.host.inputElement && (this.host.inputElement.inputMode = r ? "" : "none");
  }
}
/**
 * @license
 * Copyright (c) 2015 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function Rl(s) {
  return s != null;
}
function Il(s, r) {
  return s.findIndex((e) => e instanceof Yi ? !1 : r(e));
}
const Dg = (s) => class extends Rg(
  Wr(ra(th(Js(ta(Nc(s))))))
) {
  static get properties() {
    return {
      /**
       * True if the dropdown is open, false otherwise.
       * @type {boolean}
       */
      opened: {
        type: Boolean,
        notify: !0,
        value: !1,
        reflectToAttribute: !0,
        sync: !0,
        observer: "_openedChanged"
      },
      /**
       * Set true to prevent the overlay from opening automatically.
       * @attr {boolean} auto-open-disabled
       */
      autoOpenDisabled: {
        type: Boolean,
        sync: !0
      },
      /**
       * When present, it specifies that the field is read-only.
       * @type {boolean}
       */
      readonly: {
        type: Boolean,
        value: !1,
        reflectToAttribute: !0
      },
      /**
       * Custom function for rendering the content of every item.
       * Receives three arguments:
       *
       * - `root` The `<vaadin-combo-box-item>` internal container DOM element.
       * - `comboBox` The reference to the `<vaadin-combo-box>` element.
       * - `model` The object with the properties related with the rendered
       *   item, contains:
       *   - `model.index` The index of the rendered item.
       *   - `model.item` The item.
       * @type {ComboBoxRenderer | undefined}
       */
      renderer: {
        type: Object,
        sync: !0
      },
      /**
       * A full set of items to filter the visible options from.
       * The items can be of either `String` or `Object` type.
       * @type {!Array<!ComboBoxItem | string> | undefined}
       */
      items: {
        type: Array,
        sync: !0,
        observer: "_itemsChanged"
      },
      /**
       * If `true`, the user can input a value that is not present in the items list.
       * `value` property will be set to the input value in this case.
       * Also, when `value` is set programmatically, the input value will be set
       * to reflect that value.
       * @attr {boolean} allow-custom-value
       * @type {boolean}
       */
      allowCustomValue: {
        type: Boolean,
        value: !1
      },
      /**
       * A subset of items, filtered based on the user input. Filtered items
       * can be assigned directly to omit the internal filtering functionality.
       * The items can be of either `String` or `Object` type.
       * @type {!Array<!ComboBoxItem | string> | undefined}
       */
      filteredItems: {
        type: Array,
        observer: "_filteredItemsChanged",
        sync: !0
      },
      /**
       * Used to detect user value changes and fire `change` events.
       * @private
       */
      _lastCommittedValue: String,
      /**
       * When set to `true`, "loading" attribute is added to host and the overlay element.
       * @type {boolean}
       */
      loading: {
        type: Boolean,
        value: !1,
        reflectToAttribute: !0,
        sync: !0
      },
      /**
       * @type {number}
       * @protected
       */
      _focusedIndex: {
        type: Number,
        observer: "_focusedIndexChanged",
        value: -1,
        sync: !0
      },
      /**
       * Filtering string the user has typed into the input field.
       * @type {string}
       */
      filter: {
        type: String,
        value: "",
        notify: !0,
        sync: !0
      },
      /**
       * The selected item from the `items` array.
       * @type {ComboBoxItem | string | undefined}
       */
      selectedItem: {
        type: Object,
        notify: !0,
        sync: !0
      },
      /**
       * A function used to generate CSS class names for dropdown
       * items based on the item. The return value should be the
       * generated class name as a string, or multiple class names
       * separated by whitespace characters.
       */
      itemClassNameGenerator: {
        type: Object
      },
      /**
       * Path for label of the item. If `items` is an array of objects, the
       * `itemLabelPath` is used to fetch the displayed string label for each
       * item.
       *
       * The item label is also used for matching items when processing user
       * input, i.e., for filtering and selecting items.
       * @attr {string} item-label-path
       * @type {string}
       */
      itemLabelPath: {
        type: String,
        value: "label",
        observer: "_itemLabelPathChanged",
        sync: !0
      },
      /**
       * Path for the value of the item. If `items` is an array of objects, the
       * `itemValuePath:` is used to fetch the string value for the selected
       * item.
       *
       * The item value is used in the `value` property of the combo box,
       * to provide the form value.
       * @attr {string} item-value-path
       * @type {string}
       */
      itemValuePath: {
        type: String,
        value: "value",
        sync: !0
      },
      /**
       * Path for the id of the item. If `items` is an array of objects,
       * the `itemIdPath` is used to compare and identify the same item
       * in `selectedItem` and `filteredItems` (items given by the
       * `dataProvider` callback).
       * @attr {string} item-id-path
       */
      itemIdPath: {
        type: String,
        sync: !0
      },
      /**
       * @type {!HTMLElement | undefined}
       * @protected
       */
      _toggleElement: {
        type: Object,
        observer: "_toggleElementChanged"
      },
      /**
       * Set of items to be rendered in the dropdown.
       * @protected
       */
      _dropdownItems: {
        type: Array,
        sync: !0
      },
      /** @private */
      _closeOnBlurIsPrevented: Boolean,
      /** @private */
      _scroller: {
        type: Object,
        sync: !0
      },
      /** @private */
      _overlayOpened: {
        type: Boolean,
        sync: !0,
        observer: "_overlayOpenedChanged"
      },
      /** @private */
      __keepOverlayOpened: {
        type: Boolean,
        sync: !0
      }
    };
  }
  static get observers() {
    return [
      "_selectedItemChanged(selectedItem, itemValuePath, itemLabelPath)",
      "_openedOrItemsChanged(opened, _dropdownItems, loading, __keepOverlayOpened)",
      "_updateScroller(_scroller, _dropdownItems, opened, loading, selectedItem, itemIdPath, _focusedIndex, renderer, _theme, itemClassNameGenerator)"
    ];
  }
  constructor() {
    super(), this._boundOverlaySelectedItemChanged = this._overlaySelectedItemChanged.bind(this), this._boundOnClearButtonMouseDown = this.__onClearButtonMouseDown.bind(this), this._boundOnClick = this._onClick.bind(this), this._boundOnOverlayTouchAction = this._onOverlayTouchAction.bind(this), this._boundOnTouchend = this._onTouchend.bind(this);
  }
  /**
   * Tag name prefix used by scroller and items.
   * @protected
   * @return {string}
   */
  get _tagNamePrefix() {
    return "vaadin-combo-box";
  }
  /**
   * Get a reference to the native `<input>` element.
   * Override to provide a custom input.
   * @protected
   * @return {HTMLInputElement | undefined}
   */
  get _nativeInput() {
    return this.inputElement;
  }
  /**
   * Override method inherited from `InputMixin`
   * to customize the input element.
   * @protected
   * @override
   */
  _inputElementChanged(e) {
    super._inputElementChanged(e);
    const t = this._nativeInput;
    t && (t.autocomplete = "off", t.autocapitalize = "off", t.setAttribute("role", "combobox"), t.setAttribute("aria-autocomplete", "list"), t.setAttribute("aria-expanded", !!this.opened), t.setAttribute("spellcheck", "false"), t.setAttribute("autocorrect", "off"), this._revertInputValueToValue(), this.clearElement && this.clearElement.addEventListener("mousedown", this._boundOnClearButtonMouseDown));
  }
  /** @protected */
  ready() {
    super.ready(), this._initOverlay(), this._initScroller(), this._lastCommittedValue = this.value, this.addEventListener("click", this._boundOnClick), this.addEventListener("touchend", this._boundOnTouchend);
    const e = () => {
      requestAnimationFrame(() => {
        this._overlayElement.bringToFront();
      });
    };
    this.addEventListener("mousedown", e), this.addEventListener("touchstart", e), Ns(this), this.addController(new Ig(this));
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback(), this.close();
  }
  /**
   * Requests an update for the content of items.
   * While performing the update, it invokes the renderer (passed in the `renderer` property) once an item.
   *
   * It is not guaranteed that the update happens immediately (synchronously) after it is requested.
   */
  requestContentUpdate() {
    this._scroller && (this._scroller.requestContentUpdate(), this._getItemElements().forEach((e) => {
      e.requestContentUpdate();
    }));
  }
  /**
   * Opens the dropdown list.
   */
  open() {
    !this.disabled && !this.readonly && (this.opened = !0);
  }
  /**
   * Closes the dropdown list.
   */
  close() {
    this.opened = !1;
  }
  /**
   * Override Polymer lifecycle callback to handle `filter` property change after
   * the observer for `opened` property is triggered. This is needed when opening
   * combo-box on user input to ensure the focused index is set correctly.
   *
   * @param {!Object} currentProps Current accessor values
   * @param {?Object} changedProps Properties changed since the last call
   * @param {?Object} oldProps Previous values for each changed property
   * @protected
   * @override
   */
  _propertiesChanged(e, t, i) {
    super._propertiesChanged(e, t, i), t.filter !== void 0 && this._filterChanged(t.filter);
  }
  /**
   * Override LitElement lifecycle callback to handle filter property change.
   * @param {Object} props
   */
  updated(e) {
    super.updated(e), e.has("filter") && this._filterChanged(this.filter);
  }
  /** @private */
  _initOverlay() {
    const e = this.$.overlay;
    e._comboBox = this, e.addEventListener("touchend", this._boundOnOverlayTouchAction), e.addEventListener("touchmove", this._boundOnOverlayTouchAction), e.addEventListener("mousedown", (t) => t.preventDefault()), e.addEventListener("opened-changed", (t) => {
      this._overlayOpened = t.detail.value;
    }), this._overlayElement = e;
  }
  /**
   * Create and initialize the scroller element.
   * Override to provide custom host reference.
   *
   * @protected
   */
  _initScroller(e) {
    const t = document.createElement(`${this._tagNamePrefix}-scroller`);
    t.owner = e || this, t.getItemLabel = this._getItemLabel.bind(this), t.addEventListener("selection-changed", this._boundOverlaySelectedItemChanged);
    const i = this._overlayElement;
    i.renderer = (n) => {
      n.innerHTML || n.appendChild(t);
    }, i.requestContentUpdate(), this._scroller = t;
  }
  /** @private */
  // eslint-disable-next-line @typescript-eslint/max-params
  _updateScroller(e, t, i, n, o, a, l, h, d, f) {
    if (e && (i && (e.style.maxHeight = getComputedStyle(this).getPropertyValue(`--${this._tagNamePrefix}-overlay-max-height`) || "65vh"), e.setProperties({
      items: i ? t : [],
      opened: i,
      loading: n,
      selectedItem: o,
      itemIdPath: a,
      focusedIndex: l,
      renderer: h,
      theme: d,
      itemClassNameGenerator: f
    }), e.performUpdate && !e.hasUpdated))
      try {
        e.performUpdate();
      } catch {
      }
  }
  /** @private */
  _openedOrItemsChanged(e, t, i, n) {
    this._overlayOpened = e && (n || i || !!(t && t.length));
  }
  /** @private */
  _overlayOpenedChanged(e, t) {
    e ? (this.dispatchEvent(new CustomEvent("vaadin-combo-box-dropdown-opened", { bubbles: !0, composed: !0 })), this._onOpened()) : t && this._dropdownItems && this._dropdownItems.length && (this.close(), this.dispatchEvent(new CustomEvent("vaadin-combo-box-dropdown-closed", { bubbles: !0, composed: !0 })));
  }
  /** @private */
  _focusedIndexChanged(e, t) {
    t !== void 0 && this._updateActiveDescendant(e);
  }
  /** @protected */
  _isInputFocused() {
    return this.inputElement && Lc(this.inputElement);
  }
  /** @private */
  _updateActiveDescendant(e) {
    const t = this._nativeInput;
    if (!t)
      return;
    const i = this._getItemElements().find((n) => n.index === e);
    i ? t.setAttribute("aria-activedescendant", i.id) : t.removeAttribute("aria-activedescendant");
  }
  /** @private */
  _openedChanged(e, t) {
    if (t === void 0)
      return;
    e ? !this._isInputFocused() && !Mr && this.inputElement && this.inputElement.focus() : this._onClosed();
    const i = this._nativeInput;
    i && (i.setAttribute("aria-expanded", !!e), e ? i.setAttribute("aria-controls", this._scroller.id) : i.removeAttribute("aria-controls"));
  }
  /** @private */
  _onOverlayTouchAction() {
    this._closeOnBlurIsPrevented = !0, this.inputElement.blur(), this._closeOnBlurIsPrevented = !1;
  }
  /** @protected */
  _isClearButton(e) {
    return e.composedPath()[0] === this.clearElement;
  }
  /** @private */
  __onClearButtonMouseDown(e) {
    e.preventDefault(), this.inputElement.focus();
  }
  /**
   * @param {Event} event
   * @protected
   */
  _onClearButtonClick(e) {
    e.preventDefault(), this._onClearAction(), this.opened && this.requestContentUpdate();
  }
  /**
   * @param {Event} event
   * @private
   */
  _onToggleButtonClick(e) {
    e.preventDefault(), this.opened ? this.close() : this.open();
  }
  /**
   * @param {Event} event
   * @protected
   */
  _onHostClick(e) {
    this.autoOpenDisabled || (e.preventDefault(), this.open());
  }
  /** @private */
  _onClick(e) {
    this._isClearButton(e) ? this._onClearButtonClick(e) : e.composedPath().includes(this._toggleElement) ? this._onToggleButtonClick(e) : this._onHostClick(e);
  }
  /**
   * Override an event listener from `KeyboardMixin`.
   *
   * @param {KeyboardEvent} e
   * @protected
   * @override
   */
  _onKeyDown(e) {
    super._onKeyDown(e), e.key === "ArrowDown" ? (this._onArrowDown(), e.preventDefault()) : e.key === "ArrowUp" && (this._onArrowUp(), e.preventDefault());
  }
  /** @private */
  _getItemLabel(e) {
    let t = e && this.itemLabelPath ? Ci(this.itemLabelPath, e) : void 0;
    return t == null && (t = e ? e.toString() : ""), t;
  }
  /** @private */
  _getItemValue(e) {
    let t = e && this.itemValuePath ? Ci(this.itemValuePath, e) : void 0;
    return t === void 0 && (t = e ? e.toString() : ""), t;
  }
  /** @private */
  _onArrowDown() {
    if (this.opened) {
      const e = this._dropdownItems;
      e && (this._focusedIndex = Math.min(e.length - 1, this._focusedIndex + 1), this._prefillFocusedItemLabel());
    } else
      this.open();
  }
  /** @private */
  _onArrowUp() {
    if (this.opened) {
      if (this._focusedIndex > -1)
        this._focusedIndex = Math.max(0, this._focusedIndex - 1);
      else {
        const e = this._dropdownItems;
        e && (this._focusedIndex = e.length - 1);
      }
      this._prefillFocusedItemLabel();
    } else
      this.open();
  }
  /** @private */
  _prefillFocusedItemLabel() {
    if (this._focusedIndex > -1) {
      const e = this._dropdownItems[this._focusedIndex];
      this._inputElementValue = this._getItemLabel(e), this._markAllSelectionRange();
    }
  }
  /** @private */
  _setSelectionRange(e, t) {
    this._isInputFocused() && this.inputElement.setSelectionRange && this.inputElement.setSelectionRange(e, t);
  }
  /** @private */
  _markAllSelectionRange() {
    this._inputElementValue !== void 0 && this._setSelectionRange(0, this._inputElementValue.length);
  }
  /** @private */
  _clearSelectionRange() {
    if (this._inputElementValue !== void 0) {
      const e = this._inputElementValue ? this._inputElementValue.length : 0;
      this._setSelectionRange(e, e);
    }
  }
  /** @private */
  _closeOrCommit() {
    !this.opened && !this.loading ? this._commitValue() : this.close();
  }
  /**
   * Override an event listener from `KeyboardMixin`.
   *
   * @param {KeyboardEvent} e
   * @protected
   * @override
   */
  _onEnter(e) {
    if (!this._hasValidInputValue()) {
      e.preventDefault(), e.stopPropagation();
      return;
    }
    this.opened && (e.preventDefault(), e.stopPropagation()), this._closeOrCommit();
  }
  /**
   * @protected
   */
  _hasValidInputValue() {
    const e = this._focusedIndex < 0 && this._inputElementValue !== "" && this._getItemLabel(this.selectedItem) !== this._inputElementValue;
    return this.allowCustomValue || !e;
  }
  /**
   * Override an event listener from `KeyboardMixin`.
   * Do not call `super` in order to override clear
   * button logic defined in `InputControlMixin`.
   *
   * @param {!KeyboardEvent} e
   * @protected
   * @override
   */
  _onEscape(e) {
    this.autoOpenDisabled ? this.opened || this.value !== this._inputElementValue && this._inputElementValue.length > 0 ? (e.stopPropagation(), this._focusedIndex = -1, this.cancel()) : this.clearButtonVisible && !this.opened && this.value && (e.stopPropagation(), this._onClearAction()) : this.opened ? (e.stopPropagation(), this._focusedIndex > -1 ? (this._focusedIndex = -1, this._revertInputValue()) : this.cancel()) : this.clearButtonVisible && this.value && (e.stopPropagation(), this._onClearAction());
  }
  /** @private */
  _toggleElementChanged(e) {
    e && (e.addEventListener("mousedown", (t) => t.preventDefault()), e.addEventListener("click", () => {
      Mr && !this._isInputFocused() && document.activeElement.blur();
    }));
  }
  /**
   * Clears the current value.
   * @protected
   */
  _onClearAction() {
    this.selectedItem = null, this.allowCustomValue && (this.value = ""), this._detectAndDispatchChange();
  }
  /**
   * Clears the current filter. Should be used instead of setting the property
   * directly in order to allow overriding this in multi-select combo box.
   * @protected
   */
  _clearFilter() {
    this.filter = "";
  }
  /**
   * Reverts back to original value.
   */
  cancel() {
    this._revertInputValueToValue(), this._lastCommittedValue = this.value, this._closeOrCommit();
  }
  /** @private */
  _onOpened() {
    this._lastCommittedValue = this.value;
  }
  /** @private */
  _onClosed() {
    (!this.loading || this.allowCustomValue) && this._commitValue();
  }
  /** @private */
  _commitValue() {
    if (this._focusedIndex > -1) {
      const e = this._dropdownItems[this._focusedIndex];
      this.selectedItem !== e && (this.selectedItem = e), this._inputElementValue = this._getItemLabel(this.selectedItem), this._focusedIndex = -1;
    } else if (this._inputElementValue === "" || this._inputElementValue === void 0)
      this.selectedItem = null, this.allowCustomValue && (this.value = "");
    else {
      const e = [this.selectedItem, ...this._dropdownItems || []], t = e[this.__getItemIndexByLabel(e, this._inputElementValue)];
      if (this.allowCustomValue && // To prevent a repetitive input value being saved after pressing ESC and Tab.
      !t) {
        const i = this._inputElementValue;
        this._lastCustomValue = i;
        const n = new CustomEvent("custom-value-set", {
          detail: i,
          composed: !0,
          cancelable: !0,
          bubbles: !0
        });
        this.dispatchEvent(n), n.defaultPrevented || (this.value = i);
      } else !this.allowCustomValue && !this.opened && t ? this.value = this._getItemValue(t) : this._revertInputValueToValue();
    }
    this._detectAndDispatchChange(), this._clearSelectionRange(), this._clearFilter();
  }
  /**
   * Override an event listener from `InputMixin`.
   * @param {!Event} event
   * @protected
   * @override
   */
  _onInput(e) {
    const t = this._inputElementValue, i = {};
    this.filter === t ? this._filterChanged(this.filter) : i.filter = t, !this.opened && !this._isClearButton(e) && !this.autoOpenDisabled && (i.opened = !0), this.setProperties(i);
  }
  /**
   * Override an event listener from `InputMixin`.
   * @param {!Event} event
   * @protected
   * @override
   */
  _onChange(e) {
    e.stopPropagation();
  }
  /** @private */
  _itemLabelPathChanged(e) {
    typeof e != "string" && console.error("You should set itemLabelPath to a valid string");
  }
  /** @private */
  _filterChanged(e) {
    this._scrollIntoView(0), this._focusedIndex = -1, this.items ? this.filteredItems = this._filterItems(this.items, e) : this._filteredItemsChanged(this.filteredItems);
  }
  /** @protected */
  _revertInputValue() {
    this.filter !== "" ? this._inputElementValue = this.filter : this._revertInputValueToValue(), this._clearSelectionRange();
  }
  /** @private */
  _revertInputValueToValue() {
    this.allowCustomValue && !this.selectedItem ? this._inputElementValue = this.value : this._inputElementValue = this._getItemLabel(this.selectedItem);
  }
  /** @private */
  _selectedItemChanged(e) {
    if (e == null)
      this.filteredItems && (this.allowCustomValue || (this.value = ""), this._toggleHasValue(this._hasValue), this._inputElementValue = this.value);
    else {
      const t = this._getItemValue(e);
      if (this.value !== t && (this.value = t, this.value !== t))
        return;
      this._toggleHasValue(!0), this._inputElementValue = this._getItemLabel(e);
    }
  }
  /**
   * Override an observer from `InputMixin`.
   * @protected
   * @override
   */
  _valueChanged(e, t) {
    e === "" && t === void 0 || (Rl(e) ? (this._getItemValue(this.selectedItem) !== e && this._selectItemForValue(e), !this.selectedItem && this.allowCustomValue && (this._inputElementValue = e), this._toggleHasValue(this._hasValue)) : this.selectedItem = null, this._clearFilter(), this._lastCommittedValue = void 0);
  }
  /** @private */
  _detectAndDispatchChange() {
    document.hasFocus() && this.validate(), this.value !== this._lastCommittedValue && (this.dispatchEvent(new CustomEvent("change", { bubbles: !0 })), this._lastCommittedValue = this.value);
  }
  /** @private */
  _itemsChanged(e, t) {
    this._ensureItemsOrDataProvider(() => {
      this.items = t;
    }), e ? this.filteredItems = e.slice(0) : t && (this.filteredItems = null);
  }
  /** @private */
  _filteredItemsChanged(e) {
    this._setDropdownItems(e);
  }
  /** @private */
  _filterItems(e, t) {
    return e && e.filter((n) => (t = t ? t.toString().toLowerCase() : "", this._getItemLabel(n).toString().toLowerCase().indexOf(t) > -1));
  }
  /** @private */
  _selectItemForValue(e) {
    const t = this.__getItemIndexByValue(this.filteredItems, e), i = this.selectedItem;
    t >= 0 ? this.selectedItem = this.filteredItems[t] : this.dataProvider && this.selectedItem === void 0 ? this.selectedItem = void 0 : this.selectedItem = null, this.selectedItem === null && i === null && this._selectedItemChanged(this.selectedItem);
  }
  /**
   * Provide items to be rendered in the dropdown.
   * Override this method to show custom items.
   *
   * @protected
   */
  _setDropdownItems(e) {
    const t = this._dropdownItems;
    this._dropdownItems = e;
    const i = t ? t[this._focusedIndex] : null, n = this.__getItemIndexByValue(e, this.value);
    (this.selectedItem === null || this.selectedItem === void 0) && n >= 0 && (this.selectedItem = e[n]);
    const o = this.__getItemIndexByValue(e, this._getItemValue(i));
    o > -1 ? this._focusedIndex = o : this._focusedIndex = this.__getItemIndexByLabel(e, this.filter);
  }
  /** @private */
  _getItemElements() {
    return Array.from(this._scroller.querySelectorAll(`${this._tagNamePrefix}-item`));
  }
  /** @private */
  _scrollIntoView(e) {
    this._scroller && this._scroller.scrollIntoView(e);
  }
  /**
   * Returns the first item that matches the provided value.
   *
   * @private
   */
  __getItemIndexByValue(e, t) {
    return !e || !Rl(t) ? -1 : Il(e, (i) => this._getItemValue(i) === t);
  }
  /**
   * Returns the first item that matches the provided label.
   * Labels are matched against each other case insensitively.
   *
   * @private
   */
  __getItemIndexByLabel(e, t) {
    return !e || !t ? -1 : Il(e, (i) => this._getItemLabel(i).toString().toLowerCase() === t.toString().toLowerCase());
  }
  /** @private */
  _overlaySelectedItemChanged(e) {
    e.stopPropagation(), !(e.detail.item instanceof Yi) && this.opened && (this._focusedIndex = this.filteredItems.indexOf(e.detail.item), this.close());
  }
  /**
   * Override method inherited from `FocusMixin`
   * to close the overlay on blur and commit the value.
   *
   * @param {boolean} focused
   * @protected
   * @override
   */
  _setFocused(e) {
    if (super._setFocused(e), !e && !this.readonly && !this._closeOnBlurIsPrevented) {
      if (!this.opened && this.allowCustomValue && this._inputElementValue === this._lastCustomValue) {
        delete this._lastCustomValue;
        return;
      }
      if (eo()) {
        this._closeOrCommit();
        return;
      }
      this.opened ? this._overlayOpened || this.close() : this._commitValue();
    }
  }
  /**
   * Override method inherited from `FocusMixin` to not remove focused
   * state when focus moves to the overlay.
   *
   * @param {FocusEvent} event
   * @return {boolean}
   * @protected
   * @override
   */
  _shouldRemoveFocus(e) {
    return e.relatedTarget && e.relatedTarget.localName === `${this._tagNamePrefix}-item` ? !1 : e.relatedTarget === this._overlayElement ? (e.composedPath()[0].focus(), !1) : !0;
  }
  /** @private */
  _onTouchend(e) {
    !this.clearElement || e.composedPath()[0] !== this.clearElement || (e.preventDefault(), this._onClearAction());
  }
  /**
   * Fired when the value changes.
   *
   * @event value-changed
   * @param {Object} detail
   * @param {String} detail.value the combobox value
   */
  /**
   * Fired when selected item changes.
   *
   * @event selected-item-changed
   * @param {Object} detail
   * @param {Object|String} detail.value the selected item. Type is the same as the type of `items`.
   */
  /**
   * Fired when the user sets a custom value.
   * @event custom-value-set
   * @param {String} detail the custom value
   */
  /**
   * Fired when value changes.
   * To comply with https://developer.mozilla.org/en-US/docs/Web/Events/change
   * @event change
   */
  /**
   * Fired after the `vaadin-combo-box-overlay` opens.
   *
   * @event vaadin-combo-box-dropdown-opened
   */
  /**
   * Fired after the `vaadin-combo-box-overlay` closes.
   *
   * @event vaadin-combo-box-dropdown-closed
   */
};
/**
 * @license
 * Copyright (c) 2015 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
Ke("vaadin-combo-box", kg, { moduleId: "vaadin-combo-box-styles" });
class Og extends Ag(
  Dg(Tg(wg(Vr(Fc(Pi)))))
) {
  static get is() {
    return "vaadin-combo-box";
  }
  static get template() {
    return er`
      <style>
        :host([opened]) {
          pointer-events: auto;
        }
      </style>

      <div class="vaadin-combo-box-container">
        <div part="label">
          <slot name="label"></slot>
          <span part="required-indicator" aria-hidden="true" on-click="focus"></span>
        </div>

        <vaadin-input-container
          part="input-field"
          readonly="[[readonly]]"
          disabled="[[disabled]]"
          invalid="[[invalid]]"
          theme$="[[_theme]]"
        >
          <slot name="prefix" slot="prefix"></slot>
          <slot name="input"></slot>
          <div id="clearButton" part="clear-button" slot="suffix" aria-hidden="true"></div>
          <div id="toggleButton" part="toggle-button" slot="suffix" aria-hidden="true"></div>
        </vaadin-input-container>

        <div part="helper-text">
          <slot name="helper"></slot>
        </div>

        <div part="error-message">
          <slot name="error-message"></slot>
        </div>
      </div>

      <vaadin-combo-box-overlay
        id="overlay"
        opened="[[_overlayOpened]]"
        loading$="[[loading]]"
        theme$="[[_theme]]"
        position-target="[[_positionTarget]]"
        no-vertical-overlap
      ></vaadin-combo-box-overlay>

      <slot name="tooltip"></slot>
    `;
  }
  static get properties() {
    return {
      /**
       * @protected
       */
      _positionTarget: {
        type: Object
      }
    };
  }
  /**
   * Used by `InputControlMixin` as a reference to the clear button element.
   * @protected
   * @return {!HTMLElement}
   */
  get clearElement() {
    return this.$.clearButton;
  }
  /** @protected */
  ready() {
    super.ready(), this.addController(
      new xg(this, (r) => {
        this._setInputElement(r), this._setFocusElement(r), this.stateTarget = r, this.ariaTarget = r;
      })
    ), this.addController(new Cg(this.inputElement, this._labelController)), this._tooltipController = new jc(this), this.addController(this._tooltipController), this._tooltipController.setPosition("top"), this._tooltipController.setAriaTarget(this.inputElement), this._tooltipController.setShouldShow((r) => !r.opened), this._positionTarget = this.shadowRoot.querySelector('[part="input-field"]'), this._toggleElement = this.$.toggleButton;
  }
  /**
   * Override the method from `InputControlMixin`
   * to stop event propagation to prevent `ComboBoxMixin`
   * from handling this click event also on its own.
   *
   * @param {Event} event
   * @protected
   * @override
   */
  _onClearButtonClick(r) {
    r.stopPropagation(), super._onClearButtonClick(r);
  }
  /**
   * @param {Event} event
   * @protected
   */
  _onHostClick(r) {
    const e = r.composedPath();
    (e.includes(this._labelNode) || e.includes(this._positionTarget)) && super._onHostClick(r);
  }
}
$t(Og);
const zg = '*{padding:0;margin:0;border:0px;-webkit-user-select:none;user-select:none}p,div{-webkit-user-select:text;user-select:text}select{-webkit-user-select:none;user-select:none}.col-bg-body-lighter{background-color:var(--col-bg-body-lighter)}.col-bg-body{background-color:var(--col-bg-body)}.col-bg-body-darker{background-color:var(--col-bg-body-darker)}.col-bg-1-lighter{background-color:var(--col-bg-1-lighter)}.col-bg-1{background-color:var(--col-bg-1)}.col-bg-1-darker{background-color:var(--col-bg-1-darker)}.col-bg-1-input{background-color:var(--col-bg-1-input)}.col-primary-bg-1{background-color:var(--col-primary-bg-1)}.col-accent-bg-1{background-color:var(--col-accent-bg-1)}.col-success-bg-1{background-color:var(--col-success-bg-1)}.col-warning-bg-1{background-color:var(--col-warning-bg-1)}.col-error-bg-1{background-color:var(--col-error-bg-1)}.col-bg-2-lighter{background-color:var(--col-bg-2-lighter)}.col-bg-2{background-color:var(--col-bg-2)}.col-bg-2-darker{background-color:var(--col-bg-2-darker)}.col-bg-2-button{background-color:var(--col-bg-2-button)}.col-bg-2-input{background-color:var(--col-bg-2-input)}.col-primary-bg-2{background-color:var(--col-primary-bg-2)}.col-accent-bg-2{background-color:var(--col-accent-bg-2)}.col-success-bg-2{background-color:var(--col-success-bg-2)}.col-warning-bg-2{background-color:var(--col-warning-bg-2)}.col-error-bg-2{background-color:var(--col-error-bg-2)}.col-bg-3-lighter{background-color:var(--col-bg-3-lighter)}.col-bg-3{background-color:var(--col-bg-3)}.col-bg-3-darker{background-color:var(--col-bg-3-darker)}.col-bg-3-button{background-color:var(--col-bg-3-button)}.col-bg-3-input{background-color:var(--col-bg-3-input)}.col-primary-bg-3{background-color:var(--col-primary-bg-3)}.col-accent-bg-3{background-color:var(--col-accent-bg-3)}.col-success-bg-3{background-color:var(--col-success-bg-3)}.col-warning-bg-3{background-color:var(--col-warning-bg-3)}.col-error-bg-3{background-color:var(--col-error-bg-3)}.col-bg-ack-lighter{background-color:var(--col-bg-ack-lighter)}.col-bg-ack{background-color:var(--col-bg-ack)}.col-bg-ack-darker{background-color:var(--col-bg-ack-darker)}.col-primary-bg-ack{background-color:var(--col-primary-bg-ack)}.col-accent-bg-ack{background-color:var(--col-accent-bg-ack)}.col-bg-att-lighter{background-color:var(--col-bg-att-lighter)}.col-bg-att{background-color:var(--col-bg-att)}.col-bg-att-darker{background-color:var(--col-bg-att-darker)}.col-primary-bg-att{background-color:var(--col-primary-bg-att)}.col-accent-bg-att{background-color:var(--col-accent-bg-att)}.col-bg-alert-lighter{background-color:var(--col-bg-alert-lighter)}.col-bg-alert{background-color:var(--col-bg-alert)}.col-bg-alert-darker{background-color:var(--col-bg-alert-darker)}.col-primary-bg-alert{background-color:var(--col-primary-bg-alert)}.col-accent-bg-alert{background-color:var(--col-accent-bg-alert)}.col-bg-btn-lighter{background-color:var(--col-bg-btn-lighter)}.col-bg-btn{background-color:var(--col-bg-btn)}.col-bg-btn-darker{background-color:var(--col-bg-btn-darker)}.col-primary-bg-btn{background-color:var(--col-primary-bg-btn)}.col-accent-bg-btn{background-color:var(--col-accent-bg-btn)}.pattern-diagonal-stripes-sm{background:repeating-linear-gradient(45deg,transparent,transparent 10px,currentColor 10px,currentColor 20px)}.pattern-dots-lg{background-image:radial-gradient(currentColor 1.5px,transparent 1.5px);background-size:15px 15px}.pattern-dots-md{background-image:radial-gradient(currentColor 1px,transparent 1px);background-size:8px 8px}.pattern-dots-medium-dense{background-image:radial-gradient(currentColor .5px,transparent .5px);background-size:3px 3px}.pattern-dots-sm{background-image:radial-gradient(currentColor .5px,transparent .5px);background-size:5px 5px}.pattern-cross-dots-md,.imagelist-background{background-image:radial-gradient(currentColor .7px,transparent 1px),radial-gradient(currentColor .7px,transparent 1px);background-size:6.5px 6.5px;background-position:0 0,3.5px 3.5px}.imagelist-background{background-color:#fff9;background-blend-mode:overlay}label{font-family:var(--monospace-font);font-size:.9em}input,select{-webkit-user-select:text;-moz-user-select:text;-ms-user-select:text;box-sizing:border-box;border-radius:0;user-select:text;font-family:var(--standard-text-font);background-color:var(--col-bg-1-input);border:none;color:var(--col-primary-bg-1);padding:2px;margin-bottom:2px;outline:none}textarea{outline:none}input:not([type=radio],[type=checkbox]),select,textarea{width:100%}input:not([type=radio],[type=checkbox]):focus,select:focus,textarea:focus{margin-bottom:0;border-bottom:2px solid rgb(0,0,0)}h1{font-size:var(--font-size-h1)}h2{font-size:var(--font-size-h2)}h3{font-size:var(--font-size-h3)}h4{font-size:var(--font-size-h4)}small,.font-small{font-size:var(--font-size-small)}button{width:60px;height:60px;border-radius:35px;border-style:solid;border-width:2px;background-color:var(--col-bg-btn);color:var(--col-primary-bg-btn);border-color:var(--col-bg-btn-darker);font-family:var(--headline-text-font);font-size:var(--font-size-h4);font-weight:700}button:hover,button:focus{outline:none;background-color:var(--col-bg-btn-lighter)}button:active{padding-top:3px;color:var(--col-primary-bg-btn);background-color:var(--col-bg-btn-darker);border-color:var(--col-bg-btn-darker)}.kiosk-btn-128{width:128px;height:128px}.kiosk-btn-32{width:32px;height:32px}.kiosk-dropdown-btn{box-sizing:content-box;border-radius:0;background-color:var(--col-bg-btn);border-color:var(--col-bg-btn-darker);color:var(--col-primary-bg-btn);height:30px;width:30px}.kiosk-dropdown-btn .drop-down-btn{float:left}.kiosk-dropdown-btn .caret{color:var(--col-primary-bg-btn);display:inline-block;width:0;height:0;margin-left:2px;vertical-align:middle;border-color:var(--col-primary-bg-btn);border-top:4px solid;border-right:4px solid transparent;border-left:4px solid transparent}button:disabled{opacity:.3}.modal-round-button,.modal-delete,.modal-close,.modal-cancel,.modal-back,.modal-next,.modal-ok,.modal-button{box-sizing:border-box;margin-left:25px;background-image:none;display:inline-block;font-style:normal;font-variant:normal;text-rendering:auto;-webkit-font-smoothing:antialiased;font-family:"Font Awesome 6 Free";font-weight:900;font-size:24px;line-height:24px;vertical-align:center;text-align:center}.modal-ok:after{content:var(--icon-bt-ok)}.modal-next:after{padding-left:2px;content:var(--icon-bt-next)}.modal-back:after{padding-right:2px;content:var(--icon-bt-back)}.modal-cancel:after{content:var(--icon-bt-cancel)}.modal-close:before{content:var(--icon-bt-close)}.modal-delete{background-color:var(--col-bg-alert);color:var(--col-primary-bg-alert)}.modal-delete:before{content:var(--icon-bt-trash)}.modal-delete:hover,.modal-delete:focus{border-color:var(--col-bg-alert);background-color:var(--col-bg-alert-lighter);background-size:75%}.modal-delete:active{border-color:var(--col-bg-alert);background-color:var(--col-bg-alert-darker);color:var(--col-primary-bg-alert)}.kiosk-rounded{border-radius:15px}.kiosk-shaded{box-shadow:2px 2px 10px #2e380394}.kiosk-margin-bottom{margin-bottom:1em}.flex-line-break{width:100%;height:0px}.kiosk-align-flex-end{align-items:flex-end}.kiosk-align-flex-start{align-items:flex-start}.full-background-bg-1{background:linear-gradient(to right bottom,var(--col-bg-1-darker),var(--col-bg-1-lighter));height:100%;width:100%}.small-list-button i{border-radius:25px;box-shadow:2px 2px 5px #2e380394}.small-list-button:hover{color:var(--col-bg-att)}.small-list-button:hover i{box-shadow:2px 2px 5px #2e380394}.small-list-button:active,.small-list-button:focus{color:var(--col-bg-ack);transform:translateY(5px)}.small-list-button:active i,.small-list-button:focus i{box-shadow:none}.dialog-radio-div{display:flex;flex-direction:row}.dialog-radio-div input[type=radio]{margin-right:.5em}.rainbow-loading{display:flex;justify-content:center;align-items:center;height:5px;width:100%;background-color:#000}.rainbow-loading.to-top{position:fixed;top:0;z-index:1000}.rainbow-loading-progress{height:5px;width:100%;border-radius:3px;background:linear-gradient(90deg,red,#ff0,#0f0 30%,#0ff 50%,#00f,#f0f 80%,red);background-size:200%;animation:move-gradient 2s ease-in infinite}@keyframes move-gradient{0%{background-position:0% 0%}to{background-position:-200% 0%}}.fa,.fas{font-family:"Font Awesome 6 Free";font-weight:900;font-style:normal}.fa-trash:before{content:""}.fa-view-grid:before{content:""}.fa-reload:before{content:""}.fa-view-list:before{content:""}.fa-camera:before{content:""}.fa-view-image:before{content:""}.fa-check:before{content:""}.fa-bug:before{content:""}.fa-lightbulb:before{content:""}.fa-query:before{content:""}.fa-footsteps{transform:rotate(270deg)}.fa-footsteps:before{content:""}.fa-next:before{content:""}.fa-prev:before{content:""}.fa-hide:before{content:""}.fa-circle-half-stroke:before{content:""}i{font-family:"Font Awesome 6 Free";font-style:normal;font-variant:normal;text-rendering:auto;-webkit-font-smoothing:antialiased;font-weight:900;font-size:.9em}div,p{font-family:var(--standard-text-font)}:host{--lumo-font-size-s: $font-size-standard;--_lumo-grid-secondary-border-color: $col-bg-2-lighter;--_lumo-grid-border-width: 5px;--lumo-font-family: $standard-text;--lumo-size-m: $font-size-standard}vaadin-grid{margin-top:.5em;background-color:var(--col-bg-2);--_lumo-grid-selected-row-color: var(--col-bg-2-darker)}vaadin-grid::part(cell){padding-left:.5em;padding-top:3px;padding-bottom:3px;background-color:var(--col-bg-2)}vaadin-grid::part(header-cell){min-height:auto;padding-top:.2em;padding-bottom:.2em;border-bottom-color:var(--col-bg-2-darker);border-bottom-width:2px;background-color:var(--col-bg-2-darker)}vaadin-grid::part(row){background-color:var(--col-bg-2);color:var(--col-primary-bg-2)}vaadin-grid::part(selected-row){color:var(--col-accent-bg-2)}';
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const ro = (s) => (r, e) => {
  e !== void 0 ? e.addInitializer(() => {
    customElements.define(s, r);
  }) : customElements.define(s, r);
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Fg = { attribute: !0, type: String, converter: Fn, reflect: !1, hasChanged: Is }, Mg = (s = Fg, r, e) => {
  const { kind: t, metadata: i } = e;
  let n = globalThis.litPropertyMetadata.get(i);
  if (n === void 0 && globalThis.litPropertyMetadata.set(i, n = /* @__PURE__ */ new Map()), n.set(e.name, s), t === "accessor") {
    const { name: o } = e;
    return { set(a) {
      const l = r.get.call(this);
      r.set.call(this, a), this.requestUpdate(o, l, s);
    }, init(a) {
      return a !== void 0 && this.P(o, void 0, s), a;
    } };
  }
  if (t === "setter") {
    const { name: o } = e;
    return function(a) {
      const l = this[o];
      r.call(this, a), this.requestUpdate(o, l, s);
    };
  }
  throw Error("Unsupported decorator location: " + t);
};
function et(s) {
  return (r, e) => typeof e == "object" ? Mg(s, r, e) : ((t, i, n) => {
    const o = i.hasOwnProperty(n);
    return i.constructor.createProperty(n, o ? { ...t, wrapped: !0 } : t), o ? Object.getOwnPropertyDescriptor(i, n) : void 0;
  })(s, r, e);
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function ei(s) {
  return et({ ...s, state: !0, attribute: !1 });
}
const dh = 2, Es = 3;
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const kn = globalThis, na = kn.ShadowRoot && (kn.ShadyCSS === void 0 || kn.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, uh = Symbol(), Dl = /* @__PURE__ */ new WeakMap();
let Lg = class {
  constructor(r, e, t) {
    if (this._$cssResult$ = !0, t !== uh) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = r, this.t = e;
  }
  get styleSheet() {
    let r = this.o;
    const e = this.t;
    if (na && r === void 0) {
      const t = e !== void 0 && e.length === 1;
      t && (r = Dl.get(e)), r === void 0 && ((this.o = r = new CSSStyleSheet()).replaceSync(this.cssText), t && Dl.set(e, r));
    }
    return r;
  }
  toString() {
    return this.cssText;
  }
};
const Bg = (s) => new Lg(typeof s == "string" ? s : s + "", void 0, uh), Ng = (s, r) => {
  if (na) s.adoptedStyleSheets = r.map((e) => e instanceof CSSStyleSheet ? e : e.styleSheet);
  else for (const e of r) {
    const t = document.createElement("style"), i = kn.litNonce;
    i !== void 0 && t.setAttribute("nonce", i), t.textContent = e.cssText, s.appendChild(t);
  }
}, Ol = na ? (s) => s : (s) => s instanceof CSSStyleSheet ? ((r) => {
  let e = "";
  for (const t of r.cssRules) e += t.cssText;
  return Bg(e);
})(s) : s;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const { is: Hg, defineProperty: Vg, getOwnPropertyDescriptor: Ug, getOwnPropertyNames: Wg, getOwnPropertySymbols: jg, getPrototypeOf: Gg } = Object, Xt = globalThis, zl = Xt.trustedTypes, qg = zl ? zl.emptyScript : "", ts = Xt.reactiveElementPolyfillSupport, Sr = (s, r) => s, qn = { toAttribute(s, r) {
  switch (r) {
    case Boolean:
      s = s ? qg : null;
      break;
    case Object:
    case Array:
      s = s == null ? s : JSON.stringify(s);
  }
  return s;
}, fromAttribute(s, r) {
  let e = s;
  switch (r) {
    case Boolean:
      e = s !== null;
      break;
    case Number:
      e = s === null ? null : Number(s);
      break;
    case Object:
    case Array:
      try {
        e = JSON.parse(s);
      } catch {
        e = null;
      }
  }
  return e;
} }, oa = (s, r) => !Hg(s, r), Fl = { attribute: !0, type: String, converter: qn, reflect: !1, hasChanged: oa };
Symbol.metadata ?? (Symbol.metadata = Symbol("metadata")), Xt.litPropertyMetadata ?? (Xt.litPropertyMetadata = /* @__PURE__ */ new WeakMap());
class Bi extends HTMLElement {
  static addInitializer(r) {
    this._$Ei(), (this.l ?? (this.l = [])).push(r);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(r, e = Fl) {
    if (e.state && (e.attribute = !1), this._$Ei(), this.elementProperties.set(r, e), !e.noAccessor) {
      const t = Symbol(), i = this.getPropertyDescriptor(r, t, e);
      i !== void 0 && Vg(this.prototype, r, i);
    }
  }
  static getPropertyDescriptor(r, e, t) {
    const { get: i, set: n } = Ug(this.prototype, r) ?? { get() {
      return this[e];
    }, set(o) {
      this[e] = o;
    } };
    return { get() {
      return i == null ? void 0 : i.call(this);
    }, set(o) {
      const a = i == null ? void 0 : i.call(this);
      n.call(this, o), this.requestUpdate(r, a, t);
    }, configurable: !0, enumerable: !0 };
  }
  static getPropertyOptions(r) {
    return this.elementProperties.get(r) ?? Fl;
  }
  static _$Ei() {
    if (this.hasOwnProperty(Sr("elementProperties"))) return;
    const r = Gg(this);
    r.finalize(), r.l !== void 0 && (this.l = [...r.l]), this.elementProperties = new Map(r.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(Sr("finalized"))) return;
    if (this.finalized = !0, this._$Ei(), this.hasOwnProperty(Sr("properties"))) {
      const e = this.properties, t = [...Wg(e), ...jg(e)];
      for (const i of t) this.createProperty(i, e[i]);
    }
    const r = this[Symbol.metadata];
    if (r !== null) {
      const e = litPropertyMetadata.get(r);
      if (e !== void 0) for (const [t, i] of e) this.elementProperties.set(t, i);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [e, t] of this.elementProperties) {
      const i = this._$Eu(e, t);
      i !== void 0 && this._$Eh.set(i, e);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(r) {
    const e = [];
    if (Array.isArray(r)) {
      const t = new Set(r.flat(1 / 0).reverse());
      for (const i of t) e.unshift(Ol(i));
    } else r !== void 0 && e.push(Ol(r));
    return e;
  }
  static _$Eu(r, e) {
    const t = e.attribute;
    return t === !1 ? void 0 : typeof t == "string" ? t : typeof r == "string" ? r.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = !1, this.hasUpdated = !1, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    var r;
    this._$ES = new Promise((e) => this.enableUpdating = e), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), (r = this.constructor.l) == null || r.forEach((e) => e(this));
  }
  addController(r) {
    var e;
    (this._$EO ?? (this._$EO = /* @__PURE__ */ new Set())).add(r), this.renderRoot !== void 0 && this.isConnected && ((e = r.hostConnected) == null || e.call(r));
  }
  removeController(r) {
    var e;
    (e = this._$EO) == null || e.delete(r);
  }
  _$E_() {
    const r = /* @__PURE__ */ new Map(), e = this.constructor.elementProperties;
    for (const t of e.keys()) this.hasOwnProperty(t) && (r.set(t, this[t]), delete this[t]);
    r.size > 0 && (this._$Ep = r);
  }
  createRenderRoot() {
    const r = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return Ng(r, this.constructor.elementStyles), r;
  }
  connectedCallback() {
    var r;
    this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this.enableUpdating(!0), (r = this._$EO) == null || r.forEach((e) => {
      var t;
      return (t = e.hostConnected) == null ? void 0 : t.call(e);
    });
  }
  enableUpdating(r) {
  }
  disconnectedCallback() {
    var r;
    (r = this._$EO) == null || r.forEach((e) => {
      var t;
      return (t = e.hostDisconnected) == null ? void 0 : t.call(e);
    });
  }
  attributeChangedCallback(r, e, t) {
    this._$AK(r, t);
  }
  _$EC(r, e) {
    var n;
    const t = this.constructor.elementProperties.get(r), i = this.constructor._$Eu(r, t);
    if (i !== void 0 && t.reflect === !0) {
      const o = (((n = t.converter) == null ? void 0 : n.toAttribute) !== void 0 ? t.converter : qn).toAttribute(e, t.type);
      this._$Em = r, o == null ? this.removeAttribute(i) : this.setAttribute(i, o), this._$Em = null;
    }
  }
  _$AK(r, e) {
    var n;
    const t = this.constructor, i = t._$Eh.get(r);
    if (i !== void 0 && this._$Em !== i) {
      const o = t.getPropertyOptions(i), a = typeof o.converter == "function" ? { fromAttribute: o.converter } : ((n = o.converter) == null ? void 0 : n.fromAttribute) !== void 0 ? o.converter : qn;
      this._$Em = i, this[i] = a.fromAttribute(e, o.type), this._$Em = null;
    }
  }
  requestUpdate(r, e, t) {
    if (r !== void 0) {
      if (t ?? (t = this.constructor.getPropertyOptions(r)), !(t.hasChanged ?? oa)(this[r], e)) return;
      this.P(r, e, t);
    }
    this.isUpdatePending === !1 && (this._$ES = this._$ET());
  }
  P(r, e, t) {
    this._$AL.has(r) || this._$AL.set(r, e), t.reflect === !0 && this._$Em !== r && (this._$Ej ?? (this._$Ej = /* @__PURE__ */ new Set())).add(r);
  }
  async _$ET() {
    this.isUpdatePending = !0;
    try {
      await this._$ES;
    } catch (e) {
      Promise.reject(e);
    }
    const r = this.scheduleUpdate();
    return r != null && await r, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var t;
    if (!this.isUpdatePending) return;
    if (!this.hasUpdated) {
      if (this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this._$Ep) {
        for (const [n, o] of this._$Ep) this[n] = o;
        this._$Ep = void 0;
      }
      const i = this.constructor.elementProperties;
      if (i.size > 0) for (const [n, o] of i) o.wrapped !== !0 || this._$AL.has(n) || this[n] === void 0 || this.P(n, this[n], o);
    }
    let r = !1;
    const e = this._$AL;
    try {
      r = this.shouldUpdate(e), r ? (this.willUpdate(e), (t = this._$EO) == null || t.forEach((i) => {
        var n;
        return (n = i.hostUpdate) == null ? void 0 : n.call(i);
      }), this.update(e)) : this._$EU();
    } catch (i) {
      throw r = !1, this._$EU(), i;
    }
    r && this._$AE(e);
  }
  willUpdate(r) {
  }
  _$AE(r) {
    var e;
    (e = this._$EO) == null || e.forEach((t) => {
      var i;
      return (i = t.hostUpdated) == null ? void 0 : i.call(t);
    }), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(r)), this.updated(r);
  }
  _$EU() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = !1;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(r) {
    return !0;
  }
  update(r) {
    this._$Ej && (this._$Ej = this._$Ej.forEach((e) => this._$EC(e, this[e]))), this._$EU();
  }
  updated(r) {
  }
  firstUpdated(r) {
  }
}
Bi.elementStyles = [], Bi.shadowRootOptions = { mode: "open" }, Bi[Sr("elementProperties")] = /* @__PURE__ */ new Map(), Bi[Sr("finalized")] = /* @__PURE__ */ new Map(), ts == null || ts({ ReactiveElement: Bi }), (Xt.reactiveElementVersions ?? (Xt.reactiveElementVersions = [])).push("2.0.4");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const kr = globalThis, Kn = kr.trustedTypes, Ml = Kn ? Kn.createPolicy("lit-html", { createHTML: (s) => s }) : void 0, fh = "$lit$", Gt = `lit$${Math.random().toFixed(9).slice(2)}$`, ph = "?" + Gt, Kg = `<${ph}>`, Ti = document, Lr = () => Ti.createComment(""), Br = (s) => s === null || typeof s != "object" && typeof s != "function", sa = Array.isArray, Zg = (s) => sa(s) || typeof (s == null ? void 0 : s[Symbol.iterator]) == "function", is = `[ 	
\f\r]`, yr = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, Ll = /-->/g, Bl = />/g, ui = RegExp(`>|${is}(?:([^\\s"'>=/]+)(${is}*=${is}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), Nl = /'/g, Hl = /"/g, gh = /^(?:script|style|textarea|title)$/i, Yg = (s) => (r, ...e) => ({ _$litType$: s, strings: r, values: e }), qt = Yg(1), Xi = Symbol.for("lit-noChange"), qe = Symbol.for("lit-nothing"), Vl = /* @__PURE__ */ new WeakMap(), mi = Ti.createTreeWalker(Ti, 129);
function mh(s, r) {
  if (!sa(s) || !s.hasOwnProperty("raw")) throw Error("invalid template strings array");
  return Ml !== void 0 ? Ml.createHTML(r) : r;
}
const Xg = (s, r) => {
  const e = s.length - 1, t = [];
  let i, n = r === 2 ? "<svg>" : r === 3 ? "<math>" : "", o = yr;
  for (let a = 0; a < e; a++) {
    const l = s[a];
    let h, d, f = -1, g = 0;
    for (; g < l.length && (o.lastIndex = g, d = o.exec(l), d !== null); ) g = o.lastIndex, o === yr ? d[1] === "!--" ? o = Ll : d[1] !== void 0 ? o = Bl : d[2] !== void 0 ? (gh.test(d[2]) && (i = RegExp("</" + d[2], "g")), o = ui) : d[3] !== void 0 && (o = ui) : o === ui ? d[0] === ">" ? (o = i ?? yr, f = -1) : d[1] === void 0 ? f = -2 : (f = o.lastIndex - d[2].length, h = d[1], o = d[3] === void 0 ? ui : d[3] === '"' ? Hl : Nl) : o === Hl || o === Nl ? o = ui : o === Ll || o === Bl ? o = yr : (o = ui, i = void 0);
    const w = o === ui && s[a + 1].startsWith("/>") ? " " : "";
    n += o === yr ? l + Kg : f >= 0 ? (t.push(h), l.slice(0, f) + fh + l.slice(f) + Gt + w) : l + Gt + (f === -2 ? a : w);
  }
  return [mh(s, n + (s[e] || "<?>") + (r === 2 ? "</svg>" : r === 3 ? "</math>" : "")), t];
};
class Nr {
  constructor({ strings: r, _$litType$: e }, t) {
    let i;
    this.parts = [];
    let n = 0, o = 0;
    const a = r.length - 1, l = this.parts, [h, d] = Xg(r, e);
    if (this.el = Nr.createElement(h, t), mi.currentNode = this.el.content, e === 2 || e === 3) {
      const f = this.el.content.firstChild;
      f.replaceWith(...f.childNodes);
    }
    for (; (i = mi.nextNode()) !== null && l.length < a; ) {
      if (i.nodeType === 1) {
        if (i.hasAttributes()) for (const f of i.getAttributeNames()) if (f.endsWith(fh)) {
          const g = d[o++], w = i.getAttribute(f).split(Gt), C = /([.?@])?(.*)/.exec(g);
          l.push({ type: 1, index: n, name: C[2], strings: w, ctor: C[1] === "." ? Qg : C[1] === "?" ? $g : C[1] === "@" ? em : no }), i.removeAttribute(f);
        } else f.startsWith(Gt) && (l.push({ type: 6, index: n }), i.removeAttribute(f));
        if (gh.test(i.tagName)) {
          const f = i.textContent.split(Gt), g = f.length - 1;
          if (g > 0) {
            i.textContent = Kn ? Kn.emptyScript : "";
            for (let w = 0; w < g; w++) i.append(f[w], Lr()), mi.nextNode(), l.push({ type: 2, index: ++n });
            i.append(f[g], Lr());
          }
        }
      } else if (i.nodeType === 8) if (i.data === ph) l.push({ type: 2, index: n });
      else {
        let f = -1;
        for (; (f = i.data.indexOf(Gt, f + 1)) !== -1; ) l.push({ type: 7, index: n }), f += Gt.length - 1;
      }
      n++;
    }
  }
  static createElement(r, e) {
    const t = Ti.createElement("template");
    return t.innerHTML = r, t;
  }
}
function Ji(s, r, e = s, t) {
  var o, a;
  if (r === Xi) return r;
  let i = t !== void 0 ? (o = e._$Co) == null ? void 0 : o[t] : e._$Cl;
  const n = Br(r) ? void 0 : r._$litDirective$;
  return (i == null ? void 0 : i.constructor) !== n && ((a = i == null ? void 0 : i._$AO) == null || a.call(i, !1), n === void 0 ? i = void 0 : (i = new n(s), i._$AT(s, e, t)), t !== void 0 ? (e._$Co ?? (e._$Co = []))[t] = i : e._$Cl = i), i !== void 0 && (r = Ji(s, i._$AS(s, r.values), i, t)), r;
}
class Jg {
  constructor(r, e) {
    this._$AV = [], this._$AN = void 0, this._$AD = r, this._$AM = e;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(r) {
    const { el: { content: e }, parts: t } = this._$AD, i = ((r == null ? void 0 : r.creationScope) ?? Ti).importNode(e, !0);
    mi.currentNode = i;
    let n = mi.nextNode(), o = 0, a = 0, l = t[0];
    for (; l !== void 0; ) {
      if (o === l.index) {
        let h;
        l.type === 2 ? h = new jr(n, n.nextSibling, this, r) : l.type === 1 ? h = new l.ctor(n, l.name, l.strings, this, r) : l.type === 6 && (h = new tm(n, this, r)), this._$AV.push(h), l = t[++a];
      }
      o !== (l == null ? void 0 : l.index) && (n = mi.nextNode(), o++);
    }
    return mi.currentNode = Ti, i;
  }
  p(r) {
    let e = 0;
    for (const t of this._$AV) t !== void 0 && (t.strings !== void 0 ? (t._$AI(r, t, e), e += t.strings.length - 2) : t._$AI(r[e])), e++;
  }
}
class jr {
  get _$AU() {
    var r;
    return ((r = this._$AM) == null ? void 0 : r._$AU) ?? this._$Cv;
  }
  constructor(r, e, t, i) {
    this.type = 2, this._$AH = qe, this._$AN = void 0, this._$AA = r, this._$AB = e, this._$AM = t, this.options = i, this._$Cv = (i == null ? void 0 : i.isConnected) ?? !0;
  }
  get parentNode() {
    let r = this._$AA.parentNode;
    const e = this._$AM;
    return e !== void 0 && (r == null ? void 0 : r.nodeType) === 11 && (r = e.parentNode), r;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(r, e = this) {
    r = Ji(this, r, e), Br(r) ? r === qe || r == null || r === "" ? (this._$AH !== qe && this._$AR(), this._$AH = qe) : r !== this._$AH && r !== Xi && this._(r) : r._$litType$ !== void 0 ? this.$(r) : r.nodeType !== void 0 ? this.T(r) : Zg(r) ? this.k(r) : this._(r);
  }
  O(r) {
    return this._$AA.parentNode.insertBefore(r, this._$AB);
  }
  T(r) {
    this._$AH !== r && (this._$AR(), this._$AH = this.O(r));
  }
  _(r) {
    this._$AH !== qe && Br(this._$AH) ? this._$AA.nextSibling.data = r : this.T(Ti.createTextNode(r)), this._$AH = r;
  }
  $(r) {
    var n;
    const { values: e, _$litType$: t } = r, i = typeof t == "number" ? this._$AC(r) : (t.el === void 0 && (t.el = Nr.createElement(mh(t.h, t.h[0]), this.options)), t);
    if (((n = this._$AH) == null ? void 0 : n._$AD) === i) this._$AH.p(e);
    else {
      const o = new Jg(i, this), a = o.u(this.options);
      o.p(e), this.T(a), this._$AH = o;
    }
  }
  _$AC(r) {
    let e = Vl.get(r.strings);
    return e === void 0 && Vl.set(r.strings, e = new Nr(r)), e;
  }
  k(r) {
    sa(this._$AH) || (this._$AH = [], this._$AR());
    const e = this._$AH;
    let t, i = 0;
    for (const n of r) i === e.length ? e.push(t = new jr(this.O(Lr()), this.O(Lr()), this, this.options)) : t = e[i], t._$AI(n), i++;
    i < e.length && (this._$AR(t && t._$AB.nextSibling, i), e.length = i);
  }
  _$AR(r = this._$AA.nextSibling, e) {
    var t;
    for ((t = this._$AP) == null ? void 0 : t.call(this, !1, !0, e); r && r !== this._$AB; ) {
      const i = r.nextSibling;
      r.remove(), r = i;
    }
  }
  setConnected(r) {
    var e;
    this._$AM === void 0 && (this._$Cv = r, (e = this._$AP) == null || e.call(this, r));
  }
}
class no {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(r, e, t, i, n) {
    this.type = 1, this._$AH = qe, this._$AN = void 0, this.element = r, this.name = e, this._$AM = i, this.options = n, t.length > 2 || t[0] !== "" || t[1] !== "" ? (this._$AH = Array(t.length - 1).fill(new String()), this.strings = t) : this._$AH = qe;
  }
  _$AI(r, e = this, t, i) {
    const n = this.strings;
    let o = !1;
    if (n === void 0) r = Ji(this, r, e, 0), o = !Br(r) || r !== this._$AH && r !== Xi, o && (this._$AH = r);
    else {
      const a = r;
      let l, h;
      for (r = n[0], l = 0; l < n.length - 1; l++) h = Ji(this, a[t + l], e, l), h === Xi && (h = this._$AH[l]), o || (o = !Br(h) || h !== this._$AH[l]), h === qe ? r = qe : r !== qe && (r += (h ?? "") + n[l + 1]), this._$AH[l] = h;
    }
    o && !i && this.j(r);
  }
  j(r) {
    r === qe ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, r ?? "");
  }
}
class Qg extends no {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(r) {
    this.element[this.name] = r === qe ? void 0 : r;
  }
}
class $g extends no {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(r) {
    this.element.toggleAttribute(this.name, !!r && r !== qe);
  }
}
class em extends no {
  constructor(r, e, t, i, n) {
    super(r, e, t, i, n), this.type = 5;
  }
  _$AI(r, e = this) {
    if ((r = Ji(this, r, e, 0) ?? qe) === Xi) return;
    const t = this._$AH, i = r === qe && t !== qe || r.capture !== t.capture || r.once !== t.once || r.passive !== t.passive, n = r !== qe && (t === qe || i);
    i && this.element.removeEventListener(this.name, this, t), n && this.element.addEventListener(this.name, this, r), this._$AH = r;
  }
  handleEvent(r) {
    var e;
    typeof this._$AH == "function" ? this._$AH.call(((e = this.options) == null ? void 0 : e.host) ?? this.element, r) : this._$AH.handleEvent(r);
  }
}
class tm {
  constructor(r, e, t) {
    this.element = r, this.type = 6, this._$AN = void 0, this._$AM = e, this.options = t;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(r) {
    Ji(this, r);
  }
}
const rs = kr.litHtmlPolyfillSupport;
rs == null || rs(Nr, jr), (kr.litHtmlVersions ?? (kr.litHtmlVersions = [])).push("3.2.1");
const im = (s, r, e) => {
  const t = (e == null ? void 0 : e.renderBefore) ?? r;
  let i = t._$litPart$;
  if (i === void 0) {
    const n = (e == null ? void 0 : e.renderBefore) ?? null;
    t._$litPart$ = i = new jr(r.insertBefore(Lr(), n), n, void 0, e ?? {});
  }
  return i._$AI(s), i;
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
let Gi = class extends Bi {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    var e;
    const r = super.createRenderRoot();
    return (e = this.renderOptions).renderBefore ?? (e.renderBefore = r.firstChild), r;
  }
  update(r) {
    const e = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(r), this._$Do = im(e, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    var r;
    super.connectedCallback(), (r = this._$Do) == null || r.setConnected(!0);
  }
  disconnectedCallback() {
    var r;
    super.disconnectedCallback(), (r = this._$Do) == null || r.setConnected(!1);
  }
  render() {
    return Xi;
  }
};
var Yl;
Gi._$litElement$ = !0, Gi.finalized = !0, (Yl = globalThis.litElementHydrateSupport) == null || Yl.call(globalThis, { LitElement: Gi });
const ns = globalThis.litElementPolyfillSupport;
ns == null || ns({ LitElement: Gi });
(globalThis.litElementVersions ?? (globalThis.litElementVersions = [])).push("4.1.1");
const la = class la extends Gi {
  constructor() {
    super(), this.kiosk_base_url = "/", this.appErrors = [], this.apiContext = void 0, this.showProgress = !1;
  }
  onAppMessage(r) {
    console.log("Unhandled AppMessage received", r.detail), this.addAppError(r.detail.headline + "<br>" + r.detail.body);
  }
  firstUpdated(r) {
    super.firstUpdated(r), this.addEventListener("send-message", this.onAppMessage);
  }
  updated(r) {
    r.has("apiContext") && (this.showProgress = !1, this.apiContext && this.apiContext.status === Es && this.addAppError("Cannot connect to Kiosk API."), !r.apiContext && this.apiContext && this.apiConnected());
  }
  apiConnected() {
  }
  render() {
    let r;
    return this.apiContext && this.apiContext.status === dh ? r = this.apiRender() : this.apiContext && this.apiContext.status === Es ? r = this.renderApiError() : r = this.renderNoContextYet(), qt`
            <style>
                .system-message {
                    display: flex;
                    flex-direction: row;
                    justify-content: space-between;
                    border-style: solid;
                    border-width: 2px;
                    padding: 2px 1em;
                    position: relative;
                    margin-bottom: 10px;
                    background: linear-gradient(135deg, #882501, #bb3302);
                    color: #fabc02;
                }
                .system-message i {
                    
                }
                .loading {
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    height: 5px;
                    width: 100vw;
                    background-color: black;
                }
                .loading-progress {
                    height: 5px;
                    width: 100%;
                    border-radius: 3px;
                    background: linear-gradient(
                        90deg,
                        red 0%,
                        yellow 15%,
                        lime 30%,
                        cyan 50%,
                        blue 65%,
                        magenta 80%,
                        red 100%
                    );
                    background-size: 200%;
                    animation: move-gradient 2s ease-in infinite;
                }
                @keyframes move-gradient {
                    0% {
                        background-position: 0% 0%;
                    }
                    100% {
                        background-position: -200% 0%;
                    }
                }
            </style>
            <link rel="stylesheet" href="${this.kiosk_base_url}static/styles.css" />
            ${this.renderProgress()} ${this.renderErrors()} ${r}
        `;
  }
  renderNoContextYet() {
    return qt` <link rel="stylesheet" href="${this.kiosk_base_url}static/styles.css" /> `;
  }
  renderApiError() {
  }
  renderErrors() {
    return this.appErrors.length > 0 ? qt` ${this.appErrors.map((r) => qt`<div class="system-message" @click="${this.errorClicked}"><span>${r}</span><i>x</i></div>`)} ` : qe;
  }
  errorClicked(r) {
    let e = r.currentTarget.children[0].textContent;
    e && this.deleteError(e);
  }
  renderProgress(r = !1) {
    if (r || this.showProgress)
      return qt` <div class="loading">
                <div class="loading-progress"></div>
            </div>`;
  }
  addAppError(r) {
    this.appErrors.push(r), this.requestUpdate();
  }
  clearAppErrors() {
    this.appErrors = [], this.requestUpdate();
  }
  deleteError(r) {
    let e = -1;
    this.appErrors.find((t, i) => t === r ? (e = i, !0) : !1), e > -1 && (this.appErrors.splice(e, 1), this.appErrors = [...this.appErrors]);
  }
};
la.properties = {
  /**
   * The Api Context
   */
  apiContext: { type: Object },
  appErrors: { type: Array },
  showProgress: { type: Boolean }
};
let Ul = la;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const rm = { attribute: !0, type: String, converter: qn, reflect: !1, hasChanged: oa }, nm = (s = rm, r, e) => {
  const { kind: t, metadata: i } = e;
  let n = globalThis.litPropertyMetadata.get(i);
  if (n === void 0 && globalThis.litPropertyMetadata.set(i, n = /* @__PURE__ */ new Map()), n.set(e.name, s), t === "accessor") {
    const { name: o } = e;
    return { set(a) {
      const l = r.get.call(this);
      r.set.call(this, a), this.requestUpdate(o, l, s);
    }, init(a) {
      return a !== void 0 && this.P(o, void 0, s), a;
    } };
  }
  if (t === "setter") {
    const { name: o } = e;
    return function(a) {
      const l = this[o];
      r.call(this, a), this.requestUpdate(o, l, s);
    };
  }
  throw Error("Unsupported decorator location: " + t);
};
function om(s) {
  return (r, e) => typeof e == "object" ? nm(s, r, e) : ((t, i, n) => {
    const o = i.hasOwnProperty(n);
    return i.constructor.createProperty(n, o ? { ...t, wrapped: !0 } : t), o ? Object.getOwnPropertyDescriptor(i, n) : void 0;
  })(s, r, e);
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function sm(s) {
  return om({ ...s, state: !0, attribute: !1 });
}
var am = Object.defineProperty, lm = (s, r, e, t) => {
  for (var i = void 0, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = o(r, e, i) || i);
  return i && am(r, e, i), i;
};
const ca = class ca extends Gi {
  constructor() {
    super(), this.kiosk_base_url = "/", this.showProgress = !1, this.apiContext = void 0;
  }
  updated(r) {
    r.has("apiContext") && (this.showProgress = !1);
  }
  /**
   * dispatches a BeforeEvent and coordinates calling cancelCallback and finishCallback either synchronously or asynchronously, if the
   * consumer of the event used .defer on the event object.
   *
   * The dispatched BeforeEvent has a method "defer" which returns a deferrance object that itself has methods finish and cancel.
   * One of those must be called to complete the event asynchronously.
   *
   * example for an emitter:
   *   tryClose() {
   *       if (!this.emitBeforeEvent("beforeClose", {},
   *           () => {
   *               this.closeDeferred = false
   *           },
   *           () => {
   *               this.open = false
   *           })
   *       ) this.closeDeferred = true
   * }
   *
   * example for an async consumer:
   *   beforeCloseLightbox(e: BeforeEvent) {
   *       const defObj = e.detail.defer(e)
   *       setTimeout(()=>defObj.finish(),1000)
   *   }
   *
   * example for a sync consumer that let's the event succeed:
   *   beforeCloseLightbox(e: BeforeEvent) {
   *       e.stopPropagation()
   *   }
   *
   *  example for a sync consumer that cancels the event:
   *   beforeCloseLightbox(e: BeforeEvent) {
   *       e.stopPropagation()
   *       e.preventDefault()
   *   }
   *
   * @param eventName Name a consumer can listen to
   * @param detail additional data to send to the consumer
   * @param cancelCallback the code to run in case the event gets cancelled (either synchronously or asynchronously)
   * @param finishCallback the code to run in case the event's default behaviour may proceed (either synchronously or asynchronously)
   * @returns false if the consumer of the event asked to defer the result of the event,
   *              otherwise true (in which case the default behaviour will run synchronously)
   */
  emitBeforeEvent(r, e, t, i) {
    let o = {
      // some this math is going on in here: here this points to the beforeEventDetail object. That's why the component's this needed saving
      component: this,
      _defer: !1,
      defer: function(l = void 0) {
        return this._defer = !0, l && (l.stopPropagation(), l.preventDefault()), {
          cancel: () => {
            this.component.updateComplete.then(() => {
              t();
            });
          },
          finish: () => {
            this.component.updateComplete.then(() => {
              i();
            });
          }
        };
      }
    };
    Object.assign(o, e);
    const a = new CustomEvent(r, {
      bubbles: !0,
      composed: !0,
      cancelable: !0,
      detail: o
    });
    if (this.dispatchEvent(a))
      i();
    else {
      if (o._defer)
        return !1;
      t();
    }
    return !0;
  }
  render() {
    let r;
    return this.apiContext && this.apiContext.status === dh ? r = this.apiRender() : this.apiContext && this.apiContext.status === Es ? r = this.renderApiError() : r = this.renderNoContextYet(), qt`
            <link rel="stylesheet" href="${this.kiosk_base_url}static/styles.css" />
            ${r}
        `;
  }
  renderNoContextYet() {
    return qt` <link rel="stylesheet" href="${this.kiosk_base_url}static/styles.css" /> `;
  }
  renderApiError() {
  }
  renderProgress(r = !1) {
    if (r || this.showProgress)
      return qt` <div class="loading">
                <div class="loading-progress"></div>
            </div>`;
  }
};
ca.properties = {
  /**
   * The Api Context
   */
  apiContext: { type: Object }
};
let Qi = ca;
lm([
  sm()
], Qi.prototype, "showProgress");
const os = "MSG_NETWORK_ERROR";
class cm {
  constructor(r, e, t = "") {
    this.messageId = r, this.headline = e, this.body = t;
  }
}
function ss(s, r, e, t = "") {
  let i = new cm(r, e, t);
  s.dispatchEvent(new CustomEvent("send-message", { bubbles: !0, composed: !0, detail: i }));
}
function hm(s, r) {
  return s && r in s ? s[r] : r.replace("_", " ");
}
function dm(s, r, e = "", t = null) {
  if (e && (e += ": "), r.response) {
    if (r.response.status == 403 || r.response.status == 401) {
      ss(s, os, `${e}You are not logged in properly or your session has timed out`, '<a href="/logout">Please log in again.</a>');
      return;
    }
    t ? t(r) : ss(s, os, `${e}Kiosk server responded with an error.`, `(${r.msg}). 
                The server might be down or perhaps you are not logged in properly.`);
  } else {
    ss(s, os, `${e}Kiosk server responded with a network error.`, `(${r}). 
            The server might be down or perhaps you are not logged in properly.`);
    return;
  }
}
var um = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function vh(s) {
  return s && s.__esModule && Object.prototype.hasOwnProperty.call(s, "default") ? s.default : s;
}
var An = { exports: {} }, fm = An.exports, Wl;
function pm() {
  return Wl || (Wl = 1, function(s, r) {
    (function(e, t) {
      s.exports = t();
    })(fm, function() {
      var e = function(c, u) {
        return (e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(p, v) {
          p.__proto__ = v;
        } || function(p, v) {
          for (var y in v) Object.prototype.hasOwnProperty.call(v, y) && (p[y] = v[y]);
        })(c, u);
      }, t = function() {
        return (t = Object.assign || function(c) {
          for (var u, p = 1, v = arguments.length; p < v; p++) for (var y in u = arguments[p]) Object.prototype.hasOwnProperty.call(u, y) && (c[y] = u[y]);
          return c;
        }).apply(this, arguments);
      };
      function i(c, u, p) {
        for (var v, y = 0, x = u.length; y < x; y++) !v && y in u || ((v = v || Array.prototype.slice.call(u, 0, y))[y] = u[y]);
        return c.concat(v || Array.prototype.slice.call(u));
      }
      var n = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : um, o = Object.keys, a = Array.isArray;
      function l(c, u) {
        return typeof u != "object" || o(u).forEach(function(p) {
          c[p] = u[p];
        }), c;
      }
      typeof Promise > "u" || n.Promise || (n.Promise = Promise);
      var h = Object.getPrototypeOf, d = {}.hasOwnProperty;
      function f(c, u) {
        return d.call(c, u);
      }
      function g(c, u) {
        typeof u == "function" && (u = u(h(c))), (typeof Reflect > "u" ? o : Reflect.ownKeys)(u).forEach(function(p) {
          C(c, p, u[p]);
        });
      }
      var w = Object.defineProperty;
      function C(c, u, p, v) {
        w(c, u, l(p && f(p, "get") && typeof p.get == "function" ? { get: p.get, set: p.set, configurable: !0 } : { value: p, configurable: !0, writable: !0 }, v));
      }
      function E(c) {
        return { from: function(u) {
          return c.prototype = Object.create(u.prototype), C(c.prototype, "constructor", c), { extend: g.bind(null, c.prototype) };
        } };
      }
      var A = Object.getOwnPropertyDescriptor, I = [].slice;
      function V(c, u, p) {
        return I.call(c, u, p);
      }
      function K(c, u) {
        return u(c);
      }
      function ce(c) {
        if (!c) throw new Error("Assertion Failed");
      }
      function re(c) {
        n.setImmediate ? setImmediate(c) : setTimeout(c, 0);
      }
      function he(c, u) {
        if (typeof u == "string" && f(c, u)) return c[u];
        if (!u) return c;
        if (typeof u != "string") {
          for (var p = [], v = 0, y = u.length; v < y; ++v) {
            var x = he(c, u[v]);
            p.push(x);
          }
          return p;
        }
        var k = u.indexOf(".");
        if (k !== -1) {
          var R = c[u.substr(0, k)];
          return R == null ? void 0 : he(R, u.substr(k + 1));
        }
      }
      function pe(c, u, p) {
        if (c && u !== void 0 && !("isFrozen" in Object && Object.isFrozen(c))) if (typeof u != "string" && "length" in u) {
          ce(typeof p != "string" && "length" in p);
          for (var v = 0, y = u.length; v < y; ++v) pe(c, u[v], p[v]);
        } else {
          var x, k, R = u.indexOf(".");
          R !== -1 ? (x = u.substr(0, R), (k = u.substr(R + 1)) === "" ? p === void 0 ? a(c) && !isNaN(parseInt(x)) ? c.splice(x, 1) : delete c[x] : c[x] = p : pe(R = !(R = c[x]) || !f(c, x) ? c[x] = {} : R, k, p)) : p === void 0 ? a(c) && !isNaN(parseInt(u)) ? c.splice(u, 1) : delete c[u] : c[u] = p;
        }
      }
      function Te(c) {
        var u, p = {};
        for (u in c) f(c, u) && (p[u] = c[u]);
        return p;
      }
      var Ae = [].concat;
      function He(c) {
        return Ae.apply([], c);
      }
      var It = "BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(He([8, 16, 32, 64].map(function(c) {
        return ["Int", "Uint", "Float"].map(function(u) {
          return u + c + "Array";
        });
      }))).filter(function(c) {
        return n[c];
      }), Fe = new Set(It.map(function(c) {
        return n[c];
      })), ve = null;
      function Re(c) {
        return ve = /* @__PURE__ */ new WeakMap(), c = function u(p) {
          if (!p || typeof p != "object") return p;
          var v = ve.get(p);
          if (v) return v;
          if (a(p)) {
            v = [], ve.set(p, v);
            for (var y = 0, x = p.length; y < x; ++y) v.push(u(p[y]));
          } else if (Fe.has(p.constructor)) v = p;
          else {
            var k, R = h(p);
            for (k in v = R === Object.prototype ? {} : Object.create(R), ve.set(p, v), p) f(p, k) && (v[k] = u(p[k]));
          }
          return v;
        }(c), ve = null, c;
      }
      var Ze = {}.toString;
      function Ue(c) {
        return Ze.call(c).slice(8, -1);
      }
      var We = typeof Symbol < "u" ? Symbol.iterator : "@@iterator", it = typeof We == "symbol" ? function(c) {
        var u;
        return c != null && (u = c[We]) && u.apply(c);
      } : function() {
        return null;
      };
      function Ve(c, u) {
        return u = c.indexOf(u), 0 <= u && c.splice(u, 1), 0 <= u;
      }
      var rt = {};
      function Ye(c) {
        var u, p, v, y;
        if (arguments.length === 1) {
          if (a(c)) return c.slice();
          if (this === rt && typeof c == "string") return [c];
          if (y = it(c)) {
            for (p = []; !(v = y.next()).done; ) p.push(v.value);
            return p;
          }
          if (c == null) return [c];
          if (typeof (u = c.length) != "number") return [c];
          for (p = new Array(u); u--; ) p[u] = c[u];
          return p;
        }
        for (u = arguments.length, p = new Array(u); u--; ) p[u] = arguments[u];
        return p;
      }
      var ti = typeof Symbol < "u" ? function(c) {
        return c[Symbol.toStringTag] === "AsyncFunction";
      } : function() {
        return !1;
      }, Ce = ["Unknown", "Constraint", "Data", "TransactionInactive", "ReadOnly", "Version", "NotFound", "InvalidState", "InvalidAccess", "Abort", "Timeout", "QuotaExceeded", "Syntax", "DataClone"], vt = ["Modify", "Bulk", "OpenFailed", "VersionChange", "Schema", "Upgrade", "InvalidTable", "MissingAPI", "NoSuchDatabase", "InvalidArgument", "SubTransaction", "Unsupported", "Internal", "DatabaseClosed", "PrematureCommit", "ForeignAwait"].concat(Ce), ir = { VersionChanged: "Database version changed by other database connection", DatabaseClosed: "Database has been closed", Abort: "Transaction aborted", TransactionInactive: "Transaction has already completed or failed", MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb" };
      function _e(c, u) {
        this.name = c, this.message = u;
      }
      function ii(c, u) {
        return c + ". Errors: " + Object.keys(u).map(function(p) {
          return u[p].toString();
        }).filter(function(p, v, y) {
          return y.indexOf(p) === v;
        }).join(`
`);
      }
      function kt(c, u, p, v) {
        this.failures = u, this.failedKeys = v, this.successCount = p, this.message = ii(c, u);
      }
      function _t(c, u) {
        this.name = "BulkError", this.failures = Object.keys(u).map(function(p) {
          return u[p];
        }), this.failuresByPos = u, this.message = ii(c, this.failures);
      }
      E(_e).from(Error).extend({ toString: function() {
        return this.name + ": " + this.message;
      } }), E(kt).from(_e), E(_t).from(_e);
      var xt = vt.reduce(function(c, u) {
        return c[u] = u + "Error", c;
      }, {}), Si = _e, fe = vt.reduce(function(c, u) {
        var p = u + "Error";
        function v(y, x) {
          this.name = p, y ? typeof y == "string" ? (this.message = "".concat(y).concat(x ? `
 ` + x : ""), this.inner = x || null) : typeof y == "object" && (this.message = "".concat(y.name, " ").concat(y.message), this.inner = y) : (this.message = ir[u] || p, this.inner = null);
        }
        return E(v).from(Si), c[u] = v, c;
      }, {});
      fe.Syntax = SyntaxError, fe.Type = TypeError, fe.Range = RangeError;
      var ri = Ce.reduce(function(c, u) {
        return c[u + "Error"] = fe[u], c;
      }, {}), At = vt.reduce(function(c, u) {
        return ["Syntax", "Type", "Range"].indexOf(u) === -1 && (c[u + "Error"] = fe[u]), c;
      }, {});
      function Ie() {
      }
      function Ct(c) {
        return c;
      }
      function rr(c, u) {
        return c == null || c === Ct ? u : function(p) {
          return u(c(p));
        };
      }
      function ut(c, u) {
        return function() {
          c.apply(this, arguments), u.apply(this, arguments);
        };
      }
      function Mt(c, u) {
        return c === Ie ? u : function() {
          var p = c.apply(this, arguments);
          p !== void 0 && (arguments[0] = p);
          var v = this.onsuccess, y = this.onerror;
          this.onsuccess = null, this.onerror = null;
          var x = u.apply(this, arguments);
          return v && (this.onsuccess = this.onsuccess ? ut(v, this.onsuccess) : v), y && (this.onerror = this.onerror ? ut(y, this.onerror) : y), x !== void 0 ? x : p;
        };
      }
      function m(c, u) {
        return c === Ie ? u : function() {
          c.apply(this, arguments);
          var p = this.onsuccess, v = this.onerror;
          this.onsuccess = this.onerror = null, u.apply(this, arguments), p && (this.onsuccess = this.onsuccess ? ut(p, this.onsuccess) : p), v && (this.onerror = this.onerror ? ut(v, this.onerror) : v);
        };
      }
      function P(c, u) {
        return c === Ie ? u : function(p) {
          var v = c.apply(this, arguments);
          l(p, v);
          var y = this.onsuccess, x = this.onerror;
          return this.onsuccess = null, this.onerror = null, p = u.apply(this, arguments), y && (this.onsuccess = this.onsuccess ? ut(y, this.onsuccess) : y), x && (this.onerror = this.onerror ? ut(x, this.onerror) : x), v === void 0 ? p === void 0 ? void 0 : p : l(v, p);
        };
      }
      function U(c, u) {
        return c === Ie ? u : function() {
          return u.apply(this, arguments) !== !1 && c.apply(this, arguments);
        };
      }
      function J(c, u) {
        return c === Ie ? u : function() {
          var p = c.apply(this, arguments);
          if (p && typeof p.then == "function") {
            for (var v = this, y = arguments.length, x = new Array(y); y--; ) x[y] = arguments[y];
            return p.then(function() {
              return u.apply(v, x);
            });
          }
          return u.apply(this, arguments);
        };
      }
      At.ModifyError = kt, At.DexieError = _e, At.BulkError = _t;
      var ie = typeof location < "u" && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
      function de(c) {
        ie = c;
      }
      var X = {}, me = 100, It = typeof Promise > "u" ? [] : function() {
        var c = Promise.resolve();
        if (typeof crypto > "u" || !crypto.subtle) return [c, h(c), c];
        var u = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
        return [u, h(u), c];
      }(), Ce = It[0], vt = It[1], It = It[2], vt = vt && vt.then, Se = Ce && Ce.constructor, ge = !!It, Me = function(c, u) {
        Ee.push([c, u]), _ && (queueMicrotask(Eh), _ = !1);
      }, b = !0, _ = !0, T = [], S = [], q = Ct, Q = { id: "global", global: !0, ref: 0, unhandleds: [], onunhandled: Ie, pgp: !1, env: {}, finalize: Ie }, Y = Q, Ee = [], ue = 0, Xe = [];
      function $(c) {
        if (typeof this != "object") throw new TypeError("Promises must be constructed via new");
        this._listeners = [], this._lib = !1;
        var u = this._PSD = Y;
        if (typeof c != "function") {
          if (c !== X) throw new TypeError("Not a function");
          return this._state = arguments[1], this._value = arguments[2], void (this._state === !1 && ki(this, this._value));
        }
        this._state = null, this._value = null, ++u.ref, function p(v, y) {
          try {
            y(function(x) {
              if (v._state === null) {
                if (x === v) throw new TypeError("A promise cannot be resolved with itself.");
                var k = v._lib && Ai();
                x && typeof x.then == "function" ? p(v, function(R, O) {
                  x instanceof $ ? x._then(R, O) : x.then(R, O);
                }) : (v._state = !0, v._value = x, or(v)), k && Ri();
              }
            }, ki.bind(null, v));
          } catch (x) {
            ki(v, x);
          }
        }(this, c);
      }
      var Tt = { get: function() {
        var c = Y, u = Zr;
        function p(v, y) {
          var x = this, k = !c.global && (c !== Y || u !== Zr), R = k && !Bt(), O = new $(function(F, B) {
            oo(x, new nr(da(v, c, k, R), da(y, c, k, R), F, B, c));
          });
          return this._consoleTask && (O._consoleTask = this._consoleTask), O;
        }
        return p.prototype = X, p;
      }, set: function(c) {
        C(this, "then", c && c.prototype === X ? Tt : { get: function() {
          return c;
        }, set: Tt.set });
      } };
      function nr(c, u, p, v, y) {
        this.onFulfilled = typeof c == "function" ? c : null, this.onRejected = typeof u == "function" ? u : null, this.resolve = p, this.reject = v, this.psd = y;
      }
      function ki(c, u) {
        var p, v;
        S.push(u), c._state === null && (p = c._lib && Ai(), u = q(u), c._state = !1, c._value = u, v = c, T.some(function(y) {
          return y._value === v._value;
        }) || T.push(v), or(c), p && Ri());
      }
      function or(c) {
        var u = c._listeners;
        c._listeners = [];
        for (var p = 0, v = u.length; p < v; ++p) oo(c, u[p]);
        var y = c._PSD;
        --y.ref || y.finalize(), ue === 0 && (++ue, Me(function() {
          --ue == 0 && so();
        }, []));
      }
      function oo(c, u) {
        if (c._state !== null) {
          var p = c._state ? u.onFulfilled : u.onRejected;
          if (p === null) return (c._state ? u.resolve : u.reject)(c._value);
          ++u.psd.ref, ++ue, Me(Th, [p, c, u]);
        } else c._listeners.push(u);
      }
      function Th(c, u, p) {
        try {
          var v, y = u._value;
          !u._state && S.length && (S = []), v = ie && u._consoleTask ? u._consoleTask.run(function() {
            return c(y);
          }) : c(y), u._state || S.indexOf(y) !== -1 || function(x) {
            for (var k = T.length; k; ) if (T[--k]._value === x._value) return T.splice(k, 1);
          }(u), p.resolve(v);
        } catch (x) {
          p.reject(x);
        } finally {
          --ue == 0 && so(), --p.psd.ref || p.psd.finalize();
        }
      }
      function Eh() {
        ni(Q, function() {
          Ai() && Ri();
        });
      }
      function Ai() {
        var c = b;
        return _ = b = !1, c;
      }
      function Ri() {
        var c, u, p;
        do
          for (; 0 < Ee.length; ) for (c = Ee, Ee = [], p = c.length, u = 0; u < p; ++u) {
            var v = c[u];
            v[0].apply(null, v[1]);
          }
        while (0 < Ee.length);
        _ = b = !0;
      }
      function so() {
        var c = T;
        T = [], c.forEach(function(v) {
          v._PSD.onunhandled.call(null, v._value, v);
        });
        for (var u = Xe.slice(0), p = u.length; p; ) u[--p]();
      }
      function Gr(c) {
        return new $(X, !1, c);
      }
      function Ne(c, u) {
        var p = Y;
        return function() {
          var v = Ai(), y = Y;
          try {
            return Nt(p, !0), c.apply(this, arguments);
          } catch (x) {
            u && u(x);
          } finally {
            Nt(y, !1), v && Ri();
          }
        };
      }
      g($.prototype, { then: Tt, _then: function(c, u) {
        oo(this, new nr(null, null, c, u, Y));
      }, catch: function(c) {
        if (arguments.length === 1) return this.then(null, c);
        var u = c, p = arguments[1];
        return typeof u == "function" ? this.then(null, function(v) {
          return (v instanceof u ? p : Gr)(v);
        }) : this.then(null, function(v) {
          return (v && v.name === u ? p : Gr)(v);
        });
      }, finally: function(c) {
        return this.then(function(u) {
          return $.resolve(c()).then(function() {
            return u;
          });
        }, function(u) {
          return $.resolve(c()).then(function() {
            return Gr(u);
          });
        });
      }, timeout: function(c, u) {
        var p = this;
        return c < 1 / 0 ? new $(function(v, y) {
          var x = setTimeout(function() {
            return y(new fe.Timeout(u));
          }, c);
          p.then(v, y).finally(clearTimeout.bind(null, x));
        }) : this;
      } }), typeof Symbol < "u" && Symbol.toStringTag && C($.prototype, Symbol.toStringTag, "Dexie.Promise"), Q.env = ha(), g($, { all: function() {
        var c = Ye.apply(null, arguments).map(Yr);
        return new $(function(u, p) {
          c.length === 0 && u([]);
          var v = c.length;
          c.forEach(function(y, x) {
            return $.resolve(y).then(function(k) {
              c[x] = k, --v || u(c);
            }, p);
          });
        });
      }, resolve: function(c) {
        return c instanceof $ ? c : c && typeof c.then == "function" ? new $(function(u, p) {
          c.then(u, p);
        }) : new $(X, !0, c);
      }, reject: Gr, race: function() {
        var c = Ye.apply(null, arguments).map(Yr);
        return new $(function(u, p) {
          c.map(function(v) {
            return $.resolve(v).then(u, p);
          });
        });
      }, PSD: { get: function() {
        return Y;
      }, set: function(c) {
        return Y = c;
      } }, totalEchoes: { get: function() {
        return Zr;
      } }, newPSD: Lt, usePSD: ni, scheduler: { get: function() {
        return Me;
      }, set: function(c) {
        Me = c;
      } }, rejectionMapper: { get: function() {
        return q;
      }, set: function(c) {
        q = c;
      } }, follow: function(c, u) {
        return new $(function(p, v) {
          return Lt(function(y, x) {
            var k = Y;
            k.unhandleds = [], k.onunhandled = x, k.finalize = ut(function() {
              var R, O = this;
              R = function() {
                O.unhandleds.length === 0 ? y() : x(O.unhandleds[0]);
              }, Xe.push(function F() {
                R(), Xe.splice(Xe.indexOf(F), 1);
              }), ++ue, Me(function() {
                --ue == 0 && so();
              }, []);
            }, k.finalize), c();
          }, u, p, v);
        });
      } }), Se && (Se.allSettled && C($, "allSettled", function() {
        var c = Ye.apply(null, arguments).map(Yr);
        return new $(function(u) {
          c.length === 0 && u([]);
          var p = c.length, v = new Array(p);
          c.forEach(function(y, x) {
            return $.resolve(y).then(function(k) {
              return v[x] = { status: "fulfilled", value: k };
            }, function(k) {
              return v[x] = { status: "rejected", reason: k };
            }).then(function() {
              return --p || u(v);
            });
          });
        });
      }), Se.any && typeof AggregateError < "u" && C($, "any", function() {
        var c = Ye.apply(null, arguments).map(Yr);
        return new $(function(u, p) {
          c.length === 0 && p(new AggregateError([]));
          var v = c.length, y = new Array(v);
          c.forEach(function(x, k) {
            return $.resolve(x).then(function(R) {
              return u(R);
            }, function(R) {
              y[k] = R, --v || p(new AggregateError(y));
            });
          });
        });
      }), Se.withResolvers && ($.withResolvers = Se.withResolvers));
      var Je = { awaits: 0, echoes: 0, id: 0 }, Ph = 0, qr = [], Kr = 0, Zr = 0, Sh = 0;
      function Lt(c, u, p, v) {
        var y = Y, x = Object.create(y);
        return x.parent = y, x.ref = 0, x.global = !1, x.id = ++Sh, Q.env, x.env = ge ? { Promise: $, PromiseProp: { value: $, configurable: !0, writable: !0 }, all: $.all, race: $.race, allSettled: $.allSettled, any: $.any, resolve: $.resolve, reject: $.reject } : {}, u && l(x, u), ++y.ref, x.finalize = function() {
          --this.parent.ref || this.parent.finalize();
        }, v = ni(x, c, p, v), x.ref === 0 && x.finalize(), v;
      }
      function Ii() {
        return Je.id || (Je.id = ++Ph), ++Je.awaits, Je.echoes += me, Je.id;
      }
      function Bt() {
        return !!Je.awaits && (--Je.awaits == 0 && (Je.id = 0), Je.echoes = Je.awaits * me, !0);
      }
      function Yr(c) {
        return Je.echoes && c && c.constructor === Se ? (Ii(), c.then(function(u) {
          return Bt(), u;
        }, function(u) {
          return Bt(), je(u);
        })) : c;
      }
      function kh() {
        var c = qr[qr.length - 1];
        qr.pop(), Nt(c, !1);
      }
      function Nt(c, u) {
        var p, v = Y;
        (u ? !Je.echoes || Kr++ && c === Y : !Kr || --Kr && c === Y) || queueMicrotask(u ? (function(y) {
          ++Zr, Je.echoes && --Je.echoes != 0 || (Je.echoes = Je.awaits = Je.id = 0), qr.push(Y), Nt(y, !0);
        }).bind(null, c) : kh), c !== Y && (Y = c, v === Q && (Q.env = ha()), ge && (p = Q.env.Promise, u = c.env, (v.global || c.global) && (Object.defineProperty(n, "Promise", u.PromiseProp), p.all = u.all, p.race = u.race, p.resolve = u.resolve, p.reject = u.reject, u.allSettled && (p.allSettled = u.allSettled), u.any && (p.any = u.any))));
      }
      function ha() {
        var c = n.Promise;
        return ge ? { Promise: c, PromiseProp: Object.getOwnPropertyDescriptor(n, "Promise"), all: c.all, race: c.race, allSettled: c.allSettled, any: c.any, resolve: c.resolve, reject: c.reject } : {};
      }
      function ni(c, u, p, v, y) {
        var x = Y;
        try {
          return Nt(c, !0), u(p, v, y);
        } finally {
          Nt(x, !1);
        }
      }
      function da(c, u, p, v) {
        return typeof c != "function" ? c : function() {
          var y = Y;
          p && Ii(), Nt(u, !0);
          try {
            return c.apply(this, arguments);
          } finally {
            Nt(y, !1), v && queueMicrotask(Bt);
          }
        };
      }
      function ao(c) {
        Promise === Se && Je.echoes === 0 ? Kr === 0 ? c() : enqueueNativeMicroTask(c) : setTimeout(c, 0);
      }
      ("" + vt).indexOf("[native code]") === -1 && (Ii = Bt = Ie);
      var je = $.reject, oi = "", Rt = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.", ua = "String expected.", Di = [], Xr = "__dbnames", lo = "readonly", co = "readwrite";
      function si(c, u) {
        return c ? u ? function() {
          return c.apply(this, arguments) && u.apply(this, arguments);
        } : c : u;
      }
      var fa = { type: 3, lower: -1 / 0, lowerOpen: !1, upper: [[]], upperOpen: !1 };
      function Jr(c) {
        return typeof c != "string" || /\./.test(c) ? function(u) {
          return u;
        } : function(u) {
          return u[c] === void 0 && c in u && delete (u = Re(u))[c], u;
        };
      }
      function pa() {
        throw fe.Type();
      }
      function Pe(c, u) {
        try {
          var p = ga(c), v = ga(u);
          if (p !== v) return p === "Array" ? 1 : v === "Array" ? -1 : p === "binary" ? 1 : v === "binary" ? -1 : p === "string" ? 1 : v === "string" ? -1 : p === "Date" ? 1 : v !== "Date" ? NaN : -1;
          switch (p) {
            case "number":
            case "Date":
            case "string":
              return u < c ? 1 : c < u ? -1 : 0;
            case "binary":
              return function(y, x) {
                for (var k = y.length, R = x.length, O = k < R ? k : R, F = 0; F < O; ++F) if (y[F] !== x[F]) return y[F] < x[F] ? -1 : 1;
                return k === R ? 0 : k < R ? -1 : 1;
              }(ma(c), ma(u));
            case "Array":
              return function(y, x) {
                for (var k = y.length, R = x.length, O = k < R ? k : R, F = 0; F < O; ++F) {
                  var B = Pe(y[F], x[F]);
                  if (B !== 0) return B;
                }
                return k === R ? 0 : k < R ? -1 : 1;
              }(c, u);
          }
        } catch {
        }
        return NaN;
      }
      function ga(c) {
        var u = typeof c;
        return u != "object" ? u : ArrayBuffer.isView(c) ? "binary" : (c = Ue(c), c === "ArrayBuffer" ? "binary" : c);
      }
      function ma(c) {
        return c instanceof Uint8Array ? c : ArrayBuffer.isView(c) ? new Uint8Array(c.buffer, c.byteOffset, c.byteLength) : new Uint8Array(c);
      }
      var va = (Be.prototype._trans = function(c, u, p) {
        var v = this._tx || Y.trans, y = this.name, x = ie && typeof console < "u" && console.createTask && console.createTask("Dexie: ".concat(c === "readonly" ? "read" : "write", " ").concat(this.name));
        function k(F, B, D) {
          if (!D.schema[y]) throw new fe.NotFound("Table " + y + " not part of transaction");
          return u(D.idbtrans, D);
        }
        var R = Ai();
        try {
          var O = v && v.db._novip === this.db._novip ? v === Y.trans ? v._promise(c, k, p) : Lt(function() {
            return v._promise(c, k, p);
          }, { trans: v, transless: Y.transless || Y }) : function F(B, D, H, z) {
            if (B.idbdb && (B._state.openComplete || Y.letThrough || B._vip)) {
              var L = B._createTransaction(D, H, B._dbSchema);
              try {
                L.create(), B._state.PR1398_maxLoop = 3;
              } catch (N) {
                return N.name === xt.InvalidState && B.isOpen() && 0 < --B._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), B.close({ disableAutoOpen: !1 }), B.open().then(function() {
                  return F(B, D, H, z);
                })) : je(N);
              }
              return L._promise(D, function(N, M) {
                return Lt(function() {
                  return Y.trans = L, z(N, M, L);
                });
              }).then(function(N) {
                if (D === "readwrite") try {
                  L.idbtrans.commit();
                } catch {
                }
                return D === "readonly" ? N : L._completion.then(function() {
                  return N;
                });
              });
            }
            if (B._state.openComplete) return je(new fe.DatabaseClosed(B._state.dbOpenError));
            if (!B._state.isBeingOpened) {
              if (!B._state.autoOpen) return je(new fe.DatabaseClosed());
              B.open().catch(Ie);
            }
            return B._state.dbReadyPromise.then(function() {
              return F(B, D, H, z);
            });
          }(this.db, c, [this.name], k);
          return x && (O._consoleTask = x, O = O.catch(function(F) {
            return console.trace(F), je(F);
          })), O;
        } finally {
          R && Ri();
        }
      }, Be.prototype.get = function(c, u) {
        var p = this;
        return c && c.constructor === Object ? this.where(c).first(u) : c == null ? je(new fe.Type("Invalid argument to Table.get()")) : this._trans("readonly", function(v) {
          return p.core.get({ trans: v, key: c }).then(function(y) {
            return p.hook.reading.fire(y);
          });
        }).then(u);
      }, Be.prototype.where = function(c) {
        if (typeof c == "string") return new this.db.WhereClause(this, c);
        if (a(c)) return new this.db.WhereClause(this, "[".concat(c.join("+"), "]"));
        var u = o(c);
        if (u.length === 1) return this.where(u[0]).equals(c[u[0]]);
        var p = this.schema.indexes.concat(this.schema.primKey).filter(function(R) {
          if (R.compound && u.every(function(F) {
            return 0 <= R.keyPath.indexOf(F);
          })) {
            for (var O = 0; O < u.length; ++O) if (u.indexOf(R.keyPath[O]) === -1) return !1;
            return !0;
          }
          return !1;
        }).sort(function(R, O) {
          return R.keyPath.length - O.keyPath.length;
        })[0];
        if (p && this.db._maxKey !== oi) {
          var x = p.keyPath.slice(0, u.length);
          return this.where(x).equals(x.map(function(O) {
            return c[O];
          }));
        }
        !p && ie && console.warn("The query ".concat(JSON.stringify(c), " on ").concat(this.name, " would benefit from a ") + "compound index [".concat(u.join("+"), "]"));
        var v = this.schema.idxByName;
        function y(R, O) {
          return Pe(R, O) === 0;
        }
        var k = u.reduce(function(D, O) {
          var F = D[0], B = D[1], D = v[O], H = c[O];
          return [F || D, F || !D ? si(B, D && D.multi ? function(z) {
            return z = he(z, O), a(z) && z.some(function(L) {
              return y(H, L);
            });
          } : function(z) {
            return y(H, he(z, O));
          }) : B];
        }, [null, null]), x = k[0], k = k[1];
        return x ? this.where(x.name).equals(c[x.keyPath]).filter(k) : p ? this.filter(k) : this.where(u).equals("");
      }, Be.prototype.filter = function(c) {
        return this.toCollection().and(c);
      }, Be.prototype.count = function(c) {
        return this.toCollection().count(c);
      }, Be.prototype.offset = function(c) {
        return this.toCollection().offset(c);
      }, Be.prototype.limit = function(c) {
        return this.toCollection().limit(c);
      }, Be.prototype.each = function(c) {
        return this.toCollection().each(c);
      }, Be.prototype.toArray = function(c) {
        return this.toCollection().toArray(c);
      }, Be.prototype.toCollection = function() {
        return new this.db.Collection(new this.db.WhereClause(this));
      }, Be.prototype.orderBy = function(c) {
        return new this.db.Collection(new this.db.WhereClause(this, a(c) ? "[".concat(c.join("+"), "]") : c));
      }, Be.prototype.reverse = function() {
        return this.toCollection().reverse();
      }, Be.prototype.mapToClass = function(c) {
        var u, p = this.db, v = this.name;
        function y() {
          return u !== null && u.apply(this, arguments) || this;
        }
        (this.schema.mappedClass = c).prototype instanceof pa && (function(O, F) {
          if (typeof F != "function" && F !== null) throw new TypeError("Class extends value " + String(F) + " is not a constructor or null");
          function B() {
            this.constructor = O;
          }
          e(O, F), O.prototype = F === null ? Object.create(F) : (B.prototype = F.prototype, new B());
        }(y, u = c), Object.defineProperty(y.prototype, "db", { get: function() {
          return p;
        }, enumerable: !1, configurable: !0 }), y.prototype.table = function() {
          return v;
        }, c = y);
        for (var x = /* @__PURE__ */ new Set(), k = c.prototype; k; k = h(k)) Object.getOwnPropertyNames(k).forEach(function(O) {
          return x.add(O);
        });
        function R(O) {
          if (!O) return O;
          var F, B = Object.create(c.prototype);
          for (F in O) if (!x.has(F)) try {
            B[F] = O[F];
          } catch {
          }
          return B;
        }
        return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = R, this.hook("reading", R), c;
      }, Be.prototype.defineClass = function() {
        return this.mapToClass(function(c) {
          l(this, c);
        });
      }, Be.prototype.add = function(c, u) {
        var p = this, v = this.schema.primKey, y = v.auto, x = v.keyPath, k = c;
        return x && y && (k = Jr(x)(c)), this._trans("readwrite", function(R) {
          return p.core.mutate({ trans: R, type: "add", keys: u != null ? [u] : null, values: [k] });
        }).then(function(R) {
          return R.numFailures ? $.reject(R.failures[0]) : R.lastResult;
        }).then(function(R) {
          if (x) try {
            pe(c, x, R);
          } catch {
          }
          return R;
        });
      }, Be.prototype.update = function(c, u) {
        return typeof c != "object" || a(c) ? this.where(":id").equals(c).modify(u) : (c = he(c, this.schema.primKey.keyPath), c === void 0 ? je(new fe.InvalidArgument("Given object does not contain its primary key")) : this.where(":id").equals(c).modify(u));
      }, Be.prototype.put = function(c, u) {
        var p = this, v = this.schema.primKey, y = v.auto, x = v.keyPath, k = c;
        return x && y && (k = Jr(x)(c)), this._trans("readwrite", function(R) {
          return p.core.mutate({ trans: R, type: "put", values: [k], keys: u != null ? [u] : null });
        }).then(function(R) {
          return R.numFailures ? $.reject(R.failures[0]) : R.lastResult;
        }).then(function(R) {
          if (x) try {
            pe(c, x, R);
          } catch {
          }
          return R;
        });
      }, Be.prototype.delete = function(c) {
        var u = this;
        return this._trans("readwrite", function(p) {
          return u.core.mutate({ trans: p, type: "delete", keys: [c] });
        }).then(function(p) {
          return p.numFailures ? $.reject(p.failures[0]) : void 0;
        });
      }, Be.prototype.clear = function() {
        var c = this;
        return this._trans("readwrite", function(u) {
          return c.core.mutate({ trans: u, type: "deleteRange", range: fa });
        }).then(function(u) {
          return u.numFailures ? $.reject(u.failures[0]) : void 0;
        });
      }, Be.prototype.bulkGet = function(c) {
        var u = this;
        return this._trans("readonly", function(p) {
          return u.core.getMany({ keys: c, trans: p }).then(function(v) {
            return v.map(function(y) {
              return u.hook.reading.fire(y);
            });
          });
        });
      }, Be.prototype.bulkAdd = function(c, u, p) {
        var v = this, y = Array.isArray(u) ? u : void 0, x = (p = p || (y ? void 0 : u)) ? p.allKeys : void 0;
        return this._trans("readwrite", function(k) {
          var F = v.schema.primKey, R = F.auto, F = F.keyPath;
          if (F && y) throw new fe.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
          if (y && y.length !== c.length) throw new fe.InvalidArgument("Arguments objects and keys must have the same length");
          var O = c.length, F = F && R ? c.map(Jr(F)) : c;
          return v.core.mutate({ trans: k, type: "add", keys: y, values: F, wantResults: x }).then(function(L) {
            var D = L.numFailures, H = L.results, z = L.lastResult, L = L.failures;
            if (D === 0) return x ? H : z;
            throw new _t("".concat(v.name, ".bulkAdd(): ").concat(D, " of ").concat(O, " operations failed"), L);
          });
        });
      }, Be.prototype.bulkPut = function(c, u, p) {
        var v = this, y = Array.isArray(u) ? u : void 0, x = (p = p || (y ? void 0 : u)) ? p.allKeys : void 0;
        return this._trans("readwrite", function(k) {
          var F = v.schema.primKey, R = F.auto, F = F.keyPath;
          if (F && y) throw new fe.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
          if (y && y.length !== c.length) throw new fe.InvalidArgument("Arguments objects and keys must have the same length");
          var O = c.length, F = F && R ? c.map(Jr(F)) : c;
          return v.core.mutate({ trans: k, type: "put", keys: y, values: F, wantResults: x }).then(function(L) {
            var D = L.numFailures, H = L.results, z = L.lastResult, L = L.failures;
            if (D === 0) return x ? H : z;
            throw new _t("".concat(v.name, ".bulkPut(): ").concat(D, " of ").concat(O, " operations failed"), L);
          });
        });
      }, Be.prototype.bulkUpdate = function(c) {
        var u = this, p = this.core, v = c.map(function(k) {
          return k.key;
        }), y = c.map(function(k) {
          return k.changes;
        }), x = [];
        return this._trans("readwrite", function(k) {
          return p.getMany({ trans: k, keys: v, cache: "clone" }).then(function(R) {
            var O = [], F = [];
            c.forEach(function(D, H) {
              var z = D.key, L = D.changes, N = R[H];
              if (N) {
                for (var M = 0, W = Object.keys(L); M < W.length; M++) {
                  var j = W[M], G = L[j];
                  if (j === u.schema.primKey.keyPath) {
                    if (Pe(G, z) !== 0) throw new fe.Constraint("Cannot update primary key in bulkUpdate()");
                  } else pe(N, j, G);
                }
                x.push(H), O.push(z), F.push(N);
              }
            });
            var B = O.length;
            return p.mutate({ trans: k, type: "put", keys: O, values: F, updates: { keys: v, changeSpecs: y } }).then(function(D) {
              var H = D.numFailures, z = D.failures;
              if (H === 0) return B;
              for (var L = 0, N = Object.keys(z); L < N.length; L++) {
                var M, W = N[L], j = x[Number(W)];
                j != null && (M = z[W], delete z[W], z[j] = M);
              }
              throw new _t("".concat(u.name, ".bulkUpdate(): ").concat(H, " of ").concat(B, " operations failed"), z);
            });
          });
        });
      }, Be.prototype.bulkDelete = function(c) {
        var u = this, p = c.length;
        return this._trans("readwrite", function(v) {
          return u.core.mutate({ trans: v, type: "delete", keys: c });
        }).then(function(k) {
          var y = k.numFailures, x = k.lastResult, k = k.failures;
          if (y === 0) return x;
          throw new _t("".concat(u.name, ".bulkDelete(): ").concat(y, " of ").concat(p, " operations failed"), k);
        });
      }, Be);
      function Be() {
      }
      function sr(c) {
        function u(k, R) {
          if (R) {
            for (var O = arguments.length, F = new Array(O - 1); --O; ) F[O - 1] = arguments[O];
            return p[k].subscribe.apply(null, F), c;
          }
          if (typeof k == "string") return p[k];
        }
        var p = {};
        u.addEventType = x;
        for (var v = 1, y = arguments.length; v < y; ++v) x(arguments[v]);
        return u;
        function x(k, R, O) {
          if (typeof k != "object") {
            var F;
            R = R || U;
            var B = { subscribers: [], fire: O = O || Ie, subscribe: function(D) {
              B.subscribers.indexOf(D) === -1 && (B.subscribers.push(D), B.fire = R(B.fire, D));
            }, unsubscribe: function(D) {
              B.subscribers = B.subscribers.filter(function(H) {
                return H !== D;
              }), B.fire = B.subscribers.reduce(R, O);
            } };
            return p[k] = u[k] = B;
          }
          o(F = k).forEach(function(D) {
            var H = F[D];
            if (a(H)) x(D, F[D][0], F[D][1]);
            else {
              if (H !== "asap") throw new fe.InvalidArgument("Invalid event config");
              var z = x(D, Ct, function() {
                for (var L = arguments.length, N = new Array(L); L--; ) N[L] = arguments[L];
                z.subscribers.forEach(function(M) {
                  re(function() {
                    M.apply(null, N);
                  });
                });
              });
            }
          });
        }
      }
      function ar(c, u) {
        return E(u).from({ prototype: c }), u;
      }
      function Oi(c, u) {
        return !(c.filter || c.algorithm || c.or) && (u ? c.justLimit : !c.replayFilter);
      }
      function ho(c, u) {
        c.filter = si(c.filter, u);
      }
      function uo(c, u, p) {
        var v = c.replayFilter;
        c.replayFilter = v ? function() {
          return si(v(), u());
        } : u, c.justLimit = p && !v;
      }
      function Qr(c, u) {
        if (c.isPrimKey) return u.primaryKey;
        var p = u.getIndexByKeyPath(c.index);
        if (!p) throw new fe.Schema("KeyPath " + c.index + " on object store " + u.name + " is not indexed");
        return p;
      }
      function _a(c, u, p) {
        var v = Qr(c, u.schema);
        return u.openCursor({ trans: p, values: !c.keysOnly, reverse: c.dir === "prev", unique: !!c.unique, query: { index: v, range: c.range } });
      }
      function $r(c, u, p, v) {
        var y = c.replayFilter ? si(c.filter, c.replayFilter()) : c.filter;
        if (c.or) {
          var x = {}, k = function(R, O, F) {
            var B, D;
            y && !y(O, F, function(H) {
              return O.stop(H);
            }, function(H) {
              return O.fail(H);
            }) || ((D = "" + (B = O.primaryKey)) == "[object ArrayBuffer]" && (D = "" + new Uint8Array(B)), f(x, D) || (x[D] = !0, u(R, O, F)));
          };
          return Promise.all([c.or._iterate(k, p), ba(_a(c, v, p), c.algorithm, k, !c.keysOnly && c.valueMapper)]);
        }
        return ba(_a(c, v, p), si(c.algorithm, y), u, !c.keysOnly && c.valueMapper);
      }
      function ba(c, u, p, v) {
        var y = Ne(v ? function(x, k, R) {
          return p(v(x), k, R);
        } : p);
        return c.then(function(x) {
          if (x) return x.start(function() {
            var k = function() {
              return x.continue();
            };
            u && !u(x, function(R) {
              return k = R;
            }, function(R) {
              x.stop(R), k = Ie;
            }, function(R) {
              x.fail(R), k = Ie;
            }) || y(x.value, x, function(R) {
              return k = R;
            }), k();
          });
        });
      }
      var It = Symbol(), lr = (ya.prototype.execute = function(c) {
        if (this.add !== void 0) {
          var u = this.add;
          if (a(u)) return i(i([], a(c) ? c : [], !0), u).sort();
          if (typeof u == "number") return (Number(c) || 0) + u;
          if (typeof u == "bigint") try {
            return BigInt(c) + u;
          } catch {
            return BigInt(0) + u;
          }
          throw new TypeError("Invalid term ".concat(u));
        }
        if (this.remove !== void 0) {
          var p = this.remove;
          if (a(p)) return a(c) ? c.filter(function(v) {
            return !p.includes(v);
          }).sort() : [];
          if (typeof p == "number") return Number(c) - p;
          if (typeof p == "bigint") try {
            return BigInt(c) - p;
          } catch {
            return BigInt(0) - p;
          }
          throw new TypeError("Invalid subtrahend ".concat(p));
        }
        return u = (u = this.replacePrefix) === null || u === void 0 ? void 0 : u[0], u && typeof c == "string" && c.startsWith(u) ? this.replacePrefix[1] + c.substring(u.length) : c;
      }, ya);
      function ya(c) {
        Object.assign(this, c);
      }
      var Ah = (De.prototype._read = function(c, u) {
        var p = this._ctx;
        return p.error ? p.table._trans(null, je.bind(null, p.error)) : p.table._trans("readonly", c).then(u);
      }, De.prototype._write = function(c) {
        var u = this._ctx;
        return u.error ? u.table._trans(null, je.bind(null, u.error)) : u.table._trans("readwrite", c, "locked");
      }, De.prototype._addAlgorithm = function(c) {
        var u = this._ctx;
        u.algorithm = si(u.algorithm, c);
      }, De.prototype._iterate = function(c, u) {
        return $r(this._ctx, c, u, this._ctx.table.core);
      }, De.prototype.clone = function(c) {
        var u = Object.create(this.constructor.prototype), p = Object.create(this._ctx);
        return c && l(p, c), u._ctx = p, u;
      }, De.prototype.raw = function() {
        return this._ctx.valueMapper = null, this;
      }, De.prototype.each = function(c) {
        var u = this._ctx;
        return this._read(function(p) {
          return $r(u, c, p, u.table.core);
        });
      }, De.prototype.count = function(c) {
        var u = this;
        return this._read(function(p) {
          var v = u._ctx, y = v.table.core;
          if (Oi(v, !0)) return y.count({ trans: p, query: { index: Qr(v, y.schema), range: v.range } }).then(function(k) {
            return Math.min(k, v.limit);
          });
          var x = 0;
          return $r(v, function() {
            return ++x, !1;
          }, p, y).then(function() {
            return x;
          });
        }).then(c);
      }, De.prototype.sortBy = function(c, u) {
        var p = c.split(".").reverse(), v = p[0], y = p.length - 1;
        function x(O, F) {
          return F ? x(O[p[F]], F - 1) : O[v];
        }
        var k = this._ctx.dir === "next" ? 1 : -1;
        function R(O, F) {
          return Pe(x(O, y), x(F, y)) * k;
        }
        return this.toArray(function(O) {
          return O.sort(R);
        }).then(u);
      }, De.prototype.toArray = function(c) {
        var u = this;
        return this._read(function(p) {
          var v = u._ctx;
          if (v.dir === "next" && Oi(v, !0) && 0 < v.limit) {
            var y = v.valueMapper, x = Qr(v, v.table.core.schema);
            return v.table.core.query({ trans: p, limit: v.limit, values: !0, query: { index: x, range: v.range } }).then(function(R) {
              return R = R.result, y ? R.map(y) : R;
            });
          }
          var k = [];
          return $r(v, function(R) {
            return k.push(R);
          }, p, v.table.core).then(function() {
            return k;
          });
        }, c);
      }, De.prototype.offset = function(c) {
        var u = this._ctx;
        return c <= 0 || (u.offset += c, Oi(u) ? uo(u, function() {
          var p = c;
          return function(v, y) {
            return p === 0 || (p === 1 ? --p : y(function() {
              v.advance(p), p = 0;
            }), !1);
          };
        }) : uo(u, function() {
          var p = c;
          return function() {
            return --p < 0;
          };
        })), this;
      }, De.prototype.limit = function(c) {
        return this._ctx.limit = Math.min(this._ctx.limit, c), uo(this._ctx, function() {
          var u = c;
          return function(p, v, y) {
            return --u <= 0 && v(y), 0 <= u;
          };
        }, !0), this;
      }, De.prototype.until = function(c, u) {
        return ho(this._ctx, function(p, v, y) {
          return !c(p.value) || (v(y), u);
        }), this;
      }, De.prototype.first = function(c) {
        return this.limit(1).toArray(function(u) {
          return u[0];
        }).then(c);
      }, De.prototype.last = function(c) {
        return this.reverse().first(c);
      }, De.prototype.filter = function(c) {
        var u;
        return ho(this._ctx, function(p) {
          return c(p.value);
        }), (u = this._ctx).isMatch = si(u.isMatch, c), this;
      }, De.prototype.and = function(c) {
        return this.filter(c);
      }, De.prototype.or = function(c) {
        return new this.db.WhereClause(this._ctx.table, c, this);
      }, De.prototype.reverse = function() {
        return this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev", this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this;
      }, De.prototype.desc = function() {
        return this.reverse();
      }, De.prototype.eachKey = function(c) {
        var u = this._ctx;
        return u.keysOnly = !u.isMatch, this.each(function(p, v) {
          c(v.key, v);
        });
      }, De.prototype.eachUniqueKey = function(c) {
        return this._ctx.unique = "unique", this.eachKey(c);
      }, De.prototype.eachPrimaryKey = function(c) {
        var u = this._ctx;
        return u.keysOnly = !u.isMatch, this.each(function(p, v) {
          c(v.primaryKey, v);
        });
      }, De.prototype.keys = function(c) {
        var u = this._ctx;
        u.keysOnly = !u.isMatch;
        var p = [];
        return this.each(function(v, y) {
          p.push(y.key);
        }).then(function() {
          return p;
        }).then(c);
      }, De.prototype.primaryKeys = function(c) {
        var u = this._ctx;
        if (u.dir === "next" && Oi(u, !0) && 0 < u.limit) return this._read(function(v) {
          var y = Qr(u, u.table.core.schema);
          return u.table.core.query({ trans: v, values: !1, limit: u.limit, query: { index: y, range: u.range } });
        }).then(function(v) {
          return v.result;
        }).then(c);
        u.keysOnly = !u.isMatch;
        var p = [];
        return this.each(function(v, y) {
          p.push(y.primaryKey);
        }).then(function() {
          return p;
        }).then(c);
      }, De.prototype.uniqueKeys = function(c) {
        return this._ctx.unique = "unique", this.keys(c);
      }, De.prototype.firstKey = function(c) {
        return this.limit(1).keys(function(u) {
          return u[0];
        }).then(c);
      }, De.prototype.lastKey = function(c) {
        return this.reverse().firstKey(c);
      }, De.prototype.distinct = function() {
        var c = this._ctx, c = c.index && c.table.schema.idxByName[c.index];
        if (!c || !c.multi) return this;
        var u = {};
        return ho(this._ctx, function(y) {
          var v = y.primaryKey.toString(), y = f(u, v);
          return u[v] = !0, !y;
        }), this;
      }, De.prototype.modify = function(c) {
        var u = this, p = this._ctx;
        return this._write(function(v) {
          var y, x, k;
          k = typeof c == "function" ? c : (y = o(c), x = y.length, function(M) {
            for (var W = !1, j = 0; j < x; ++j) {
              var G = y[j], Z = c[G], ee = he(M, G);
              Z instanceof lr ? (pe(M, G, Z.execute(ee)), W = !0) : ee !== Z && (pe(M, G, Z), W = !0);
            }
            return W;
          });
          var R = p.table.core, D = R.schema.primaryKey, O = D.outbound, F = D.extractKey, B = 200, D = u.db._options.modifyChunkSize;
          D && (B = typeof D == "object" ? D[R.name] || D["*"] || 200 : D);
          function H(M, G) {
            var j = G.failures, G = G.numFailures;
            L += M - G;
            for (var Z = 0, ee = o(j); Z < ee.length; Z++) {
              var se = ee[Z];
              z.push(j[se]);
            }
          }
          var z = [], L = 0, N = [];
          return u.clone().primaryKeys().then(function(M) {
            function W(G) {
              var Z = Math.min(B, M.length - G);
              return R.getMany({ trans: v, keys: M.slice(G, G + Z), cache: "immutable" }).then(function(ee) {
                for (var se = [], te = [], ne = O ? [] : null, ae = [], oe = 0; oe < Z; ++oe) {
                  var le = ee[oe], ye = { value: Re(le), primKey: M[G + oe] };
                  k.call(ye, ye.value, ye) !== !1 && (ye.value == null ? ae.push(M[G + oe]) : O || Pe(F(le), F(ye.value)) === 0 ? (te.push(ye.value), O && ne.push(M[G + oe])) : (ae.push(M[G + oe]), se.push(ye.value)));
                }
                return Promise.resolve(0 < se.length && R.mutate({ trans: v, type: "add", values: se }).then(function(we) {
                  for (var xe in we.failures) ae.splice(parseInt(xe), 1);
                  H(se.length, we);
                })).then(function() {
                  return (0 < te.length || j && typeof c == "object") && R.mutate({ trans: v, type: "put", keys: ne, values: te, criteria: j, changeSpec: typeof c != "function" && c, isAdditionalChunk: 0 < G }).then(function(we) {
                    return H(te.length, we);
                  });
                }).then(function() {
                  return (0 < ae.length || j && c === fo) && R.mutate({ trans: v, type: "delete", keys: ae, criteria: j, isAdditionalChunk: 0 < G }).then(function(we) {
                    return H(ae.length, we);
                  });
                }).then(function() {
                  return M.length > G + Z && W(G + B);
                });
              });
            }
            var j = Oi(p) && p.limit === 1 / 0 && (typeof c != "function" || c === fo) && { index: p.index, range: p.range };
            return W(0).then(function() {
              if (0 < z.length) throw new kt("Error modifying one or more objects", z, L, N);
              return M.length;
            });
          });
        });
      }, De.prototype.delete = function() {
        var c = this._ctx, u = c.range;
        return Oi(c) && (c.isPrimKey || u.type === 3) ? this._write(function(p) {
          var v = c.table.core.schema.primaryKey, y = u;
          return c.table.core.count({ trans: p, query: { index: v, range: y } }).then(function(x) {
            return c.table.core.mutate({ trans: p, type: "deleteRange", range: y }).then(function(k) {
              var R = k.failures;
              if (k.lastResult, k.results, k = k.numFailures, k) throw new kt("Could not delete some values", Object.keys(R).map(function(O) {
                return R[O];
              }), x - k);
              return x - k;
            });
          });
        }) : this.modify(fo);
      }, De);
      function De() {
      }
      var fo = function(c, u) {
        return u.value = null;
      };
      function Rh(c, u) {
        return c < u ? -1 : c === u ? 0 : 1;
      }
      function Ih(c, u) {
        return u < c ? -1 : c === u ? 0 : 1;
      }
      function ft(c, u, p) {
        return c = c instanceof xa ? new c.Collection(c) : c, c._ctx.error = new (p || TypeError)(u), c;
      }
      function zi(c) {
        return new c.Collection(c, function() {
          return wa("");
        }).limit(0);
      }
      function en(c, u, p, v) {
        var y, x, k, R, O, F, B, D = p.length;
        if (!p.every(function(L) {
          return typeof L == "string";
        })) return ft(c, ua);
        function H(L) {
          y = L === "next" ? function(M) {
            return M.toUpperCase();
          } : function(M) {
            return M.toLowerCase();
          }, x = L === "next" ? function(M) {
            return M.toLowerCase();
          } : function(M) {
            return M.toUpperCase();
          }, k = L === "next" ? Rh : Ih;
          var N = p.map(function(M) {
            return { lower: x(M), upper: y(M) };
          }).sort(function(M, W) {
            return k(M.lower, W.lower);
          });
          R = N.map(function(M) {
            return M.upper;
          }), O = N.map(function(M) {
            return M.lower;
          }), B = (F = L) === "next" ? "" : v;
        }
        H("next"), c = new c.Collection(c, function() {
          return Ht(R[0], O[D - 1] + v);
        }), c._ondirectionchange = function(L) {
          H(L);
        };
        var z = 0;
        return c._addAlgorithm(function(L, N, M) {
          var W = L.key;
          if (typeof W != "string") return !1;
          var j = x(W);
          if (u(j, O, z)) return !0;
          for (var G = null, Z = z; Z < D; ++Z) {
            var ee = function(se, te, ne, ae, oe, le) {
              for (var ye = Math.min(se.length, ae.length), we = -1, xe = 0; xe < ye; ++xe) {
                var pt = te[xe];
                if (pt !== ae[xe]) return oe(se[xe], ne[xe]) < 0 ? se.substr(0, xe) + ne[xe] + ne.substr(xe + 1) : oe(se[xe], ae[xe]) < 0 ? se.substr(0, xe) + ae[xe] + ne.substr(xe + 1) : 0 <= we ? se.substr(0, we) + te[we] + ne.substr(we + 1) : null;
                oe(se[xe], pt) < 0 && (we = xe);
              }
              return ye < ae.length && le === "next" ? se + ne.substr(se.length) : ye < se.length && le === "prev" ? se.substr(0, ne.length) : we < 0 ? null : se.substr(0, we) + ae[we] + ne.substr(we + 1);
            }(W, j, R[Z], O[Z], k, F);
            ee === null && G === null ? z = Z + 1 : (G === null || 0 < k(G, ee)) && (G = ee);
          }
          return N(G !== null ? function() {
            L.continue(G + B);
          } : M), !1;
        }), c;
      }
      function Ht(c, u, p, v) {
        return { type: 2, lower: c, upper: u, lowerOpen: p, upperOpen: v };
      }
      function wa(c) {
        return { type: 1, lower: c, upper: c };
      }
      var xa = (Object.defineProperty(Qe.prototype, "Collection", { get: function() {
        return this._ctx.table.db.Collection;
      }, enumerable: !1, configurable: !0 }), Qe.prototype.between = function(c, u, p, v) {
        p = p !== !1, v = v === !0;
        try {
          return 0 < this._cmp(c, u) || this._cmp(c, u) === 0 && (p || v) && (!p || !v) ? zi(this) : new this.Collection(this, function() {
            return Ht(c, u, !p, !v);
          });
        } catch {
          return ft(this, Rt);
        }
      }, Qe.prototype.equals = function(c) {
        return c == null ? ft(this, Rt) : new this.Collection(this, function() {
          return wa(c);
        });
      }, Qe.prototype.above = function(c) {
        return c == null ? ft(this, Rt) : new this.Collection(this, function() {
          return Ht(c, void 0, !0);
        });
      }, Qe.prototype.aboveOrEqual = function(c) {
        return c == null ? ft(this, Rt) : new this.Collection(this, function() {
          return Ht(c, void 0, !1);
        });
      }, Qe.prototype.below = function(c) {
        return c == null ? ft(this, Rt) : new this.Collection(this, function() {
          return Ht(void 0, c, !1, !0);
        });
      }, Qe.prototype.belowOrEqual = function(c) {
        return c == null ? ft(this, Rt) : new this.Collection(this, function() {
          return Ht(void 0, c);
        });
      }, Qe.prototype.startsWith = function(c) {
        return typeof c != "string" ? ft(this, ua) : this.between(c, c + oi, !0, !0);
      }, Qe.prototype.startsWithIgnoreCase = function(c) {
        return c === "" ? this.startsWith(c) : en(this, function(u, p) {
          return u.indexOf(p[0]) === 0;
        }, [c], oi);
      }, Qe.prototype.equalsIgnoreCase = function(c) {
        return en(this, function(u, p) {
          return u === p[0];
        }, [c], "");
      }, Qe.prototype.anyOfIgnoreCase = function() {
        var c = Ye.apply(rt, arguments);
        return c.length === 0 ? zi(this) : en(this, function(u, p) {
          return p.indexOf(u) !== -1;
        }, c, "");
      }, Qe.prototype.startsWithAnyOfIgnoreCase = function() {
        var c = Ye.apply(rt, arguments);
        return c.length === 0 ? zi(this) : en(this, function(u, p) {
          return p.some(function(v) {
            return u.indexOf(v) === 0;
          });
        }, c, oi);
      }, Qe.prototype.anyOf = function() {
        var c = this, u = Ye.apply(rt, arguments), p = this._cmp;
        try {
          u.sort(p);
        } catch {
          return ft(this, Rt);
        }
        if (u.length === 0) return zi(this);
        var v = new this.Collection(this, function() {
          return Ht(u[0], u[u.length - 1]);
        });
        v._ondirectionchange = function(x) {
          p = x === "next" ? c._ascending : c._descending, u.sort(p);
        };
        var y = 0;
        return v._addAlgorithm(function(x, k, R) {
          for (var O = x.key; 0 < p(O, u[y]); ) if (++y === u.length) return k(R), !1;
          return p(O, u[y]) === 0 || (k(function() {
            x.continue(u[y]);
          }), !1);
        }), v;
      }, Qe.prototype.notEqual = function(c) {
        return this.inAnyRange([[-1 / 0, c], [c, this.db._maxKey]], { includeLowers: !1, includeUppers: !1 });
      }, Qe.prototype.noneOf = function() {
        var c = Ye.apply(rt, arguments);
        if (c.length === 0) return new this.Collection(this);
        try {
          c.sort(this._ascending);
        } catch {
          return ft(this, Rt);
        }
        var u = c.reduce(function(p, v) {
          return p ? p.concat([[p[p.length - 1][1], v]]) : [[-1 / 0, v]];
        }, null);
        return u.push([c[c.length - 1], this.db._maxKey]), this.inAnyRange(u, { includeLowers: !1, includeUppers: !1 });
      }, Qe.prototype.inAnyRange = function(W, u) {
        var p = this, v = this._cmp, y = this._ascending, x = this._descending, k = this._min, R = this._max;
        if (W.length === 0) return zi(this);
        if (!W.every(function(j) {
          return j[0] !== void 0 && j[1] !== void 0 && y(j[0], j[1]) <= 0;
        })) return ft(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", fe.InvalidArgument);
        var O = !u || u.includeLowers !== !1, F = u && u.includeUppers === !0, B, D = y;
        function H(j, G) {
          return D(j[0], G[0]);
        }
        try {
          (B = W.reduce(function(j, G) {
            for (var Z = 0, ee = j.length; Z < ee; ++Z) {
              var se = j[Z];
              if (v(G[0], se[1]) < 0 && 0 < v(G[1], se[0])) {
                se[0] = k(se[0], G[0]), se[1] = R(se[1], G[1]);
                break;
              }
            }
            return Z === ee && j.push(G), j;
          }, [])).sort(H);
        } catch {
          return ft(this, Rt);
        }
        var z = 0, L = F ? function(j) {
          return 0 < y(j, B[z][1]);
        } : function(j) {
          return 0 <= y(j, B[z][1]);
        }, N = O ? function(j) {
          return 0 < x(j, B[z][0]);
        } : function(j) {
          return 0 <= x(j, B[z][0]);
        }, M = L, W = new this.Collection(this, function() {
          return Ht(B[0][0], B[B.length - 1][1], !O, !F);
        });
        return W._ondirectionchange = function(j) {
          D = j === "next" ? (M = L, y) : (M = N, x), B.sort(H);
        }, W._addAlgorithm(function(j, G, Z) {
          for (var ee, se = j.key; M(se); ) if (++z === B.length) return G(Z), !1;
          return !L(ee = se) && !N(ee) || (p._cmp(se, B[z][1]) === 0 || p._cmp(se, B[z][0]) === 0 || G(function() {
            D === y ? j.continue(B[z][0]) : j.continue(B[z][1]);
          }), !1);
        }), W;
      }, Qe.prototype.startsWithAnyOf = function() {
        var c = Ye.apply(rt, arguments);
        return c.every(function(u) {
          return typeof u == "string";
        }) ? c.length === 0 ? zi(this) : this.inAnyRange(c.map(function(u) {
          return [u, u + oi];
        })) : ft(this, "startsWithAnyOf() only works with strings");
      }, Qe);
      function Qe() {
      }
      function Et(c) {
        return Ne(function(u) {
          return cr(u), c(u.target.error), !1;
        });
      }
      function cr(c) {
        c.stopPropagation && c.stopPropagation(), c.preventDefault && c.preventDefault();
      }
      var hr = "storagemutated", po = "x-storagemutated-1", Vt = sr(null, hr), Dh = (Pt.prototype._lock = function() {
        return ce(!Y.global), ++this._reculock, this._reculock !== 1 || Y.global || (Y.lockOwnerFor = this), this;
      }, Pt.prototype._unlock = function() {
        if (ce(!Y.global), --this._reculock == 0) for (Y.global || (Y.lockOwnerFor = null); 0 < this._blockedFuncs.length && !this._locked(); ) {
          var c = this._blockedFuncs.shift();
          try {
            ni(c[1], c[0]);
          } catch {
          }
        }
        return this;
      }, Pt.prototype._locked = function() {
        return this._reculock && Y.lockOwnerFor !== this;
      }, Pt.prototype.create = function(c) {
        var u = this;
        if (!this.mode) return this;
        var p = this.db.idbdb, v = this.db._state.dbOpenError;
        if (ce(!this.idbtrans), !c && !p) switch (v && v.name) {
          case "DatabaseClosedError":
            throw new fe.DatabaseClosed(v);
          case "MissingAPIError":
            throw new fe.MissingAPI(v.message, v);
          default:
            throw new fe.OpenFailed(v);
        }
        if (!this.active) throw new fe.TransactionInactive();
        return ce(this._completion._state === null), (c = this.idbtrans = c || (this.db.core || p).transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })).onerror = Ne(function(y) {
          cr(y), u._reject(c.error);
        }), c.onabort = Ne(function(y) {
          cr(y), u.active && u._reject(new fe.Abort(c.error)), u.active = !1, u.on("abort").fire(y);
        }), c.oncomplete = Ne(function() {
          u.active = !1, u._resolve(), "mutatedParts" in c && Vt.storagemutated.fire(c.mutatedParts);
        }), this;
      }, Pt.prototype._promise = function(c, u, p) {
        var v = this;
        if (c === "readwrite" && this.mode !== "readwrite") return je(new fe.ReadOnly("Transaction is readonly"));
        if (!this.active) return je(new fe.TransactionInactive());
        if (this._locked()) return new $(function(x, k) {
          v._blockedFuncs.push([function() {
            v._promise(c, u, p).then(x, k);
          }, Y]);
        });
        if (p) return Lt(function() {
          var x = new $(function(k, R) {
            v._lock();
            var O = u(k, R, v);
            O && O.then && O.then(k, R);
          });
          return x.finally(function() {
            return v._unlock();
          }), x._lib = !0, x;
        });
        var y = new $(function(x, k) {
          var R = u(x, k, v);
          R && R.then && R.then(x, k);
        });
        return y._lib = !0, y;
      }, Pt.prototype._root = function() {
        return this.parent ? this.parent._root() : this;
      }, Pt.prototype.waitFor = function(c) {
        var u, p = this._root(), v = $.resolve(c);
        p._waitingFor ? p._waitingFor = p._waitingFor.then(function() {
          return v;
        }) : (p._waitingFor = v, p._waitingQueue = [], u = p.idbtrans.objectStore(p.storeNames[0]), function x() {
          for (++p._spinCount; p._waitingQueue.length; ) p._waitingQueue.shift()();
          p._waitingFor && (u.get(-1 / 0).onsuccess = x);
        }());
        var y = p._waitingFor;
        return new $(function(x, k) {
          v.then(function(R) {
            return p._waitingQueue.push(Ne(x.bind(null, R)));
          }, function(R) {
            return p._waitingQueue.push(Ne(k.bind(null, R)));
          }).finally(function() {
            p._waitingFor === y && (p._waitingFor = null);
          });
        });
      }, Pt.prototype.abort = function() {
        this.active && (this.active = !1, this.idbtrans && this.idbtrans.abort(), this._reject(new fe.Abort()));
      }, Pt.prototype.table = function(c) {
        var u = this._memoizedTables || (this._memoizedTables = {});
        if (f(u, c)) return u[c];
        var p = this.schema[c];
        if (!p) throw new fe.NotFound("Table " + c + " not part of transaction");
        return p = new this.db.Table(c, p, this), p.core = this.db.core.table(c), u[c] = p;
      }, Pt);
      function Pt() {
      }
      function go(c, u, p, v, y, x, k) {
        return { name: c, keyPath: u, unique: p, multi: v, auto: y, compound: x, src: (p && !k ? "&" : "") + (v ? "*" : "") + (y ? "++" : "") + Ca(u) };
      }
      function Ca(c) {
        return typeof c == "string" ? c : c ? "[" + [].join.call(c, "+") + "]" : "";
      }
      function mo(c, u, p) {
        return { name: c, primKey: u, indexes: p, mappedClass: null, idxByName: (v = function(y) {
          return [y.name, y];
        }, p.reduce(function(y, x, k) {
          return k = v(x, k), k && (y[k[0]] = k[1]), y;
        }, {})) };
        var v;
      }
      var dr = function(c) {
        try {
          return c.only([[]]), dr = function() {
            return [[]];
          }, [[]];
        } catch {
          return dr = function() {
            return oi;
          }, oi;
        }
      };
      function vo(c) {
        return c == null ? function() {
        } : typeof c == "string" ? (u = c).split(".").length === 1 ? function(p) {
          return p[u];
        } : function(p) {
          return he(p, u);
        } : function(p) {
          return he(p, c);
        };
        var u;
      }
      function Ta(c) {
        return [].slice.call(c);
      }
      var Oh = 0;
      function ur(c) {
        return c == null ? ":id" : typeof c == "string" ? c : "[".concat(c.join("+"), "]");
      }
      function zh(c, u, O) {
        function v(M) {
          if (M.type === 3) return null;
          if (M.type === 4) throw new Error("Cannot convert never type to IDBKeyRange");
          var z = M.lower, L = M.upper, N = M.lowerOpen, M = M.upperOpen;
          return z === void 0 ? L === void 0 ? null : u.upperBound(L, !!M) : L === void 0 ? u.lowerBound(z, !!N) : u.bound(z, L, !!N, !!M);
        }
        function y(H) {
          var z, L = H.name;
          return { name: L, schema: H, mutate: function(N) {
            var M = N.trans, W = N.type, j = N.keys, G = N.values, Z = N.range;
            return new Promise(function(ee, se) {
              ee = Ne(ee);
              var te = M.objectStore(L), ne = te.keyPath == null, ae = W === "put" || W === "add";
              if (!ae && W !== "delete" && W !== "deleteRange") throw new Error("Invalid operation type: " + W);
              var oe, le = (j || G || { length: 1 }).length;
              if (j && G && j.length !== G.length) throw new Error("Given keys array must have same length as given values array.");
              if (le === 0) return ee({ numFailures: 0, failures: {}, results: [], lastResult: void 0 });
              function ye(lt) {
                ++pt, cr(lt);
              }
              var we = [], xe = [], pt = 0;
              if (W === "deleteRange") {
                if (Z.type === 4) return ee({ numFailures: pt, failures: xe, results: [], lastResult: void 0 });
                Z.type === 3 ? we.push(oe = te.clear()) : we.push(oe = te.delete(v(Z)));
              } else {
                var ne = ae ? ne ? [G, j] : [G, null] : [j, null], be = ne[0], ot = ne[1];
                if (ae) for (var st = 0; st < le; ++st) we.push(oe = ot && ot[st] !== void 0 ? te[W](be[st], ot[st]) : te[W](be[st])), oe.onerror = ye;
                else for (st = 0; st < le; ++st) we.push(oe = te[W](be[st])), oe.onerror = ye;
              }
              function pn(lt) {
                lt = lt.target.result, we.forEach(function(ci, Fo) {
                  return ci.error != null && (xe[Fo] = ci.error);
                }), ee({ numFailures: pt, failures: xe, results: W === "delete" ? j : we.map(function(ci) {
                  return ci.result;
                }), lastResult: lt });
              }
              oe.onerror = function(lt) {
                ye(lt), pn(lt);
              }, oe.onsuccess = pn;
            });
          }, getMany: function(N) {
            var M = N.trans, W = N.keys;
            return new Promise(function(j, G) {
              j = Ne(j);
              for (var Z, ee = M.objectStore(L), se = W.length, te = new Array(se), ne = 0, ae = 0, oe = function(we) {
                we = we.target, te[we._pos] = we.result, ++ae === ne && j(te);
              }, le = Et(G), ye = 0; ye < se; ++ye) W[ye] != null && ((Z = ee.get(W[ye]))._pos = ye, Z.onsuccess = oe, Z.onerror = le, ++ne);
              ne === 0 && j(te);
            });
          }, get: function(N) {
            var M = N.trans, W = N.key;
            return new Promise(function(j, G) {
              j = Ne(j);
              var Z = M.objectStore(L).get(W);
              Z.onsuccess = function(ee) {
                return j(ee.target.result);
              }, Z.onerror = Et(G);
            });
          }, query: (z = F, function(N) {
            return new Promise(function(M, W) {
              M = Ne(M);
              var j, G, Z, ne = N.trans, ee = N.values, se = N.limit, oe = N.query, te = se === 1 / 0 ? void 0 : se, ae = oe.index, oe = oe.range, ne = ne.objectStore(L), ae = ae.isPrimaryKey ? ne : ne.index(ae.name), oe = v(oe);
              if (se === 0) return M({ result: [] });
              z ? ((te = ee ? ae.getAll(oe, te) : ae.getAllKeys(oe, te)).onsuccess = function(le) {
                return M({ result: le.target.result });
              }, te.onerror = Et(W)) : (j = 0, G = !ee && "openKeyCursor" in ae ? ae.openKeyCursor(oe) : ae.openCursor(oe), Z = [], G.onsuccess = function(le) {
                var ye = G.result;
                return ye ? (Z.push(ee ? ye.value : ye.primaryKey), ++j === se ? M({ result: Z }) : void ye.continue()) : M({ result: Z });
              }, G.onerror = Et(W));
            });
          }), openCursor: function(N) {
            var M = N.trans, W = N.values, j = N.query, G = N.reverse, Z = N.unique;
            return new Promise(function(ee, se) {
              ee = Ne(ee);
              var ae = j.index, te = j.range, ne = M.objectStore(L), ne = ae.isPrimaryKey ? ne : ne.index(ae.name), ae = G ? Z ? "prevunique" : "prev" : Z ? "nextunique" : "next", oe = !W && "openKeyCursor" in ne ? ne.openKeyCursor(v(te), ae) : ne.openCursor(v(te), ae);
              oe.onerror = Et(se), oe.onsuccess = Ne(function(le) {
                var ye, we, xe, pt, be = oe.result;
                be ? (be.___id = ++Oh, be.done = !1, ye = be.continue.bind(be), we = (we = be.continuePrimaryKey) && we.bind(be), xe = be.advance.bind(be), pt = function() {
                  throw new Error("Cursor not stopped");
                }, be.trans = M, be.stop = be.continue = be.continuePrimaryKey = be.advance = function() {
                  throw new Error("Cursor not started");
                }, be.fail = Ne(se), be.next = function() {
                  var ot = this, st = 1;
                  return this.start(function() {
                    return st-- ? ot.continue() : ot.stop();
                  }).then(function() {
                    return ot;
                  });
                }, be.start = function(ot) {
                  function st() {
                    if (oe.result) try {
                      ot();
                    } catch (lt) {
                      be.fail(lt);
                    }
                    else be.done = !0, be.start = function() {
                      throw new Error("Cursor behind last entry");
                    }, be.stop();
                  }
                  var pn = new Promise(function(lt, ci) {
                    lt = Ne(lt), oe.onerror = Et(ci), be.fail = ci, be.stop = function(Fo) {
                      be.stop = be.continue = be.continuePrimaryKey = be.advance = pt, lt(Fo);
                    };
                  });
                  return oe.onsuccess = Ne(function(lt) {
                    oe.onsuccess = st, st();
                  }), be.continue = ye, be.continuePrimaryKey = we, be.advance = xe, st(), pn;
                }, ee(be)) : ee(null);
              }, se);
            });
          }, count: function(N) {
            var M = N.query, W = N.trans, j = M.index, G = M.range;
            return new Promise(function(Z, ee) {
              var se = W.objectStore(L), te = j.isPrimaryKey ? se : se.index(j.name), se = v(G), te = se ? te.count(se) : te.count();
              te.onsuccess = Ne(function(ne) {
                return Z(ne.target.result);
              }), te.onerror = Et(ee);
            });
          } };
        }
        var x, k, R, B = (k = O, R = Ta((x = c).objectStoreNames), { schema: { name: x.name, tables: R.map(function(H) {
          return k.objectStore(H);
        }).map(function(H) {
          var z = H.keyPath, M = H.autoIncrement, L = a(z), N = {}, M = { name: H.name, primaryKey: { name: null, isPrimaryKey: !0, outbound: z == null, compound: L, keyPath: z, autoIncrement: M, unique: !0, extractKey: vo(z) }, indexes: Ta(H.indexNames).map(function(W) {
            return H.index(W);
          }).map(function(Z) {
            var j = Z.name, G = Z.unique, ee = Z.multiEntry, Z = Z.keyPath, ee = { name: j, compound: a(Z), keyPath: Z, unique: G, multiEntry: ee, extractKey: vo(Z) };
            return N[ur(Z)] = ee;
          }), getIndexByKeyPath: function(W) {
            return N[ur(W)];
          } };
          return N[":id"] = M.primaryKey, z != null && (N[ur(z)] = M.primaryKey), M;
        }) }, hasGetAll: 0 < R.length && "getAll" in k.objectStore(R[0]) && !(typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) }), O = B.schema, F = B.hasGetAll, B = O.tables.map(y), D = {};
        return B.forEach(function(H) {
          return D[H.name] = H;
        }), { stack: "dbcore", transaction: c.transaction.bind(c), table: function(H) {
          if (!D[H]) throw new Error("Table '".concat(H, "' not found"));
          return D[H];
        }, MIN_KEY: -1 / 0, MAX_KEY: dr(u), schema: O };
      }
      function Fh(c, u, p, v) {
        var y = p.IDBKeyRange;
        return p.indexedDB, { dbcore: (v = zh(u, y, v), c.dbcore.reduce(function(x, k) {
          return k = k.create, t(t({}, x), k(x));
        }, v)) };
      }
      function tn(c, v) {
        var p = v.db, v = Fh(c._middlewares, p, c._deps, v);
        c.core = v.dbcore, c.tables.forEach(function(y) {
          var x = y.name;
          c.core.schema.tables.some(function(k) {
            return k.name === x;
          }) && (y.core = c.core.table(x), c[x] instanceof c.Table && (c[x].core = y.core));
        });
      }
      function rn(c, u, p, v) {
        p.forEach(function(y) {
          var x = v[y];
          u.forEach(function(k) {
            var R = function O(F, B) {
              return A(F, B) || (F = h(F)) && O(F, B);
            }(k, y);
            (!R || "value" in R && R.value === void 0) && (k === c.Transaction.prototype || k instanceof c.Transaction ? C(k, y, { get: function() {
              return this.table(y);
            }, set: function(O) {
              w(this, y, { value: O, writable: !0, configurable: !0, enumerable: !0 });
            } }) : k[y] = new c.Table(y, x));
          });
        });
      }
      function _o(c, u) {
        u.forEach(function(p) {
          for (var v in p) p[v] instanceof c.Table && delete p[v];
        });
      }
      function Mh(c, u) {
        return c._cfg.version - u._cfg.version;
      }
      function Lh(c, u, p, v) {
        var y = c._dbSchema;
        p.objectStoreNames.contains("$meta") && !y.$meta && (y.$meta = mo("$meta", Pa("")[0], []), c._storeNames.push("$meta"));
        var x = c._createTransaction("readwrite", c._storeNames, y);
        x.create(p), x._completion.catch(v);
        var k = x._reject.bind(x), R = Y.transless || Y;
        Lt(function() {
          return Y.trans = x, Y.transless = R, u !== 0 ? (tn(c, p), F = u, ((O = x).storeNames.includes("$meta") ? O.table("$meta").get("version").then(function(B) {
            return B ?? F;
          }) : $.resolve(F)).then(function(B) {
            return H = B, z = x, L = p, N = [], B = (D = c)._versions, M = D._dbSchema = on(0, D.idbdb, L), (B = B.filter(function(W) {
              return W._cfg.version >= H;
            })).length !== 0 ? (B.forEach(function(W) {
              N.push(function() {
                var j = M, G = W._cfg.dbschema;
                sn(D, j, L), sn(D, G, L), M = D._dbSchema = G;
                var Z = bo(j, G);
                Z.add.forEach(function(ae) {
                  yo(L, ae[0], ae[1].primKey, ae[1].indexes);
                }), Z.change.forEach(function(ae) {
                  if (ae.recreate) throw new fe.Upgrade("Not yet support for changing primary key");
                  var oe = L.objectStore(ae.name);
                  ae.add.forEach(function(le) {
                    return nn(oe, le);
                  }), ae.change.forEach(function(le) {
                    oe.deleteIndex(le.name), nn(oe, le);
                  }), ae.del.forEach(function(le) {
                    return oe.deleteIndex(le);
                  });
                });
                var ee = W._cfg.contentUpgrade;
                if (ee && W._cfg.version > H) {
                  tn(D, L), z._memoizedTables = {};
                  var se = Te(G);
                  Z.del.forEach(function(ae) {
                    se[ae] = j[ae];
                  }), _o(D, [D.Transaction.prototype]), rn(D, [D.Transaction.prototype], o(se), se), z.schema = se;
                  var te, ne = ti(ee);
                  return ne && Ii(), Z = $.follow(function() {
                    var ae;
                    (te = ee(z)) && ne && (ae = Bt.bind(null, null), te.then(ae, ae));
                  }), te && typeof te.then == "function" ? $.resolve(te) : Z.then(function() {
                    return te;
                  });
                }
              }), N.push(function(j) {
                var G, Z, ee = W._cfg.dbschema;
                G = ee, Z = j, [].slice.call(Z.db.objectStoreNames).forEach(function(se) {
                  return G[se] == null && Z.db.deleteObjectStore(se);
                }), _o(D, [D.Transaction.prototype]), rn(D, [D.Transaction.prototype], D._storeNames, D._dbSchema), z.schema = D._dbSchema;
              }), N.push(function(j) {
                D.idbdb.objectStoreNames.contains("$meta") && (Math.ceil(D.idbdb.version / 10) === W._cfg.version ? (D.idbdb.deleteObjectStore("$meta"), delete D._dbSchema.$meta, D._storeNames = D._storeNames.filter(function(G) {
                  return G !== "$meta";
                })) : j.objectStore("$meta").put(W._cfg.version, "version"));
              });
            }), function W() {
              return N.length ? $.resolve(N.shift()(z.idbtrans)).then(W) : $.resolve();
            }().then(function() {
              Ea(M, L);
            })) : $.resolve();
            var D, H, z, L, N, M;
          }).catch(k)) : (o(y).forEach(function(B) {
            yo(p, B, y[B].primKey, y[B].indexes);
          }), tn(c, p), void $.follow(function() {
            return c.on.populate.fire(x);
          }).catch(k));
          var O, F;
        });
      }
      function Bh(c, u) {
        Ea(c._dbSchema, u), u.db.version % 10 != 0 || u.objectStoreNames.contains("$meta") || u.db.createObjectStore("$meta").add(Math.ceil(u.db.version / 10 - 1), "version");
        var p = on(0, c.idbdb, u);
        sn(c, c._dbSchema, u);
        for (var v = 0, y = bo(p, c._dbSchema).change; v < y.length; v++) {
          var x = function(k) {
            if (k.change.length || k.recreate) return console.warn("Unable to patch indexes of table ".concat(k.name, " because it has changes on the type of index or primary key.")), { value: void 0 };
            var R = u.objectStore(k.name);
            k.add.forEach(function(O) {
              ie && console.debug("Dexie upgrade patch: Creating missing index ".concat(k.name, ".").concat(O.src)), nn(R, O);
            });
          }(y[v]);
          if (typeof x == "object") return x.value;
        }
      }
      function bo(c, u) {
        var p, v = { del: [], add: [], change: [] };
        for (p in c) u[p] || v.del.push(p);
        for (p in u) {
          var y = c[p], x = u[p];
          if (y) {
            var k = { name: p, def: x, recreate: !1, del: [], add: [], change: [] };
            if ("" + (y.primKey.keyPath || "") != "" + (x.primKey.keyPath || "") || y.primKey.auto !== x.primKey.auto) k.recreate = !0, v.change.push(k);
            else {
              var R = y.idxByName, O = x.idxByName, F = void 0;
              for (F in R) O[F] || k.del.push(F);
              for (F in O) {
                var B = R[F], D = O[F];
                B ? B.src !== D.src && k.change.push(D) : k.add.push(D);
              }
              (0 < k.del.length || 0 < k.add.length || 0 < k.change.length) && v.change.push(k);
            }
          } else v.add.push([p, x]);
        }
        return v;
      }
      function yo(c, u, p, v) {
        var y = c.db.createObjectStore(u, p.keyPath ? { keyPath: p.keyPath, autoIncrement: p.auto } : { autoIncrement: p.auto });
        return v.forEach(function(x) {
          return nn(y, x);
        }), y;
      }
      function Ea(c, u) {
        o(c).forEach(function(p) {
          u.db.objectStoreNames.contains(p) || (ie && console.debug("Dexie: Creating missing table", p), yo(u, p, c[p].primKey, c[p].indexes));
        });
      }
      function nn(c, u) {
        c.createIndex(u.name, u.keyPath, { unique: u.unique, multiEntry: u.multi });
      }
      function on(c, u, p) {
        var v = {};
        return V(u.objectStoreNames, 0).forEach(function(y) {
          for (var x = p.objectStore(y), k = go(Ca(F = x.keyPath), F || "", !0, !1, !!x.autoIncrement, F && typeof F != "string", !0), R = [], O = 0; O < x.indexNames.length; ++O) {
            var B = x.index(x.indexNames[O]), F = B.keyPath, B = go(B.name, F, !!B.unique, !!B.multiEntry, !1, F && typeof F != "string", !1);
            R.push(B);
          }
          v[y] = mo(y, k, R);
        }), v;
      }
      function sn(c, u, p) {
        for (var v = p.db.objectStoreNames, y = 0; y < v.length; ++y) {
          var x = v[y], k = p.objectStore(x);
          c._hasGetAll = "getAll" in k;
          for (var R = 0; R < k.indexNames.length; ++R) {
            var O = k.indexNames[R], F = k.index(O).keyPath, B = typeof F == "string" ? F : "[" + V(F).join("+") + "]";
            !u[x] || (F = u[x].idxByName[B]) && (F.name = O, delete u[x].idxByName[B], u[x].idxByName[O] = F);
          }
        }
        typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && n.WorkerGlobalScope && n instanceof n.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604 && (c._hasGetAll = !1);
      }
      function Pa(c) {
        return c.split(",").map(function(u, p) {
          var v = (u = u.trim()).replace(/([&*]|\+\+)/g, ""), y = /^\[/.test(v) ? v.match(/^\[(.*)\]$/)[1].split("+") : v;
          return go(v, y || null, /\&/.test(u), /\*/.test(u), /\+\+/.test(u), a(y), p === 0);
        });
      }
      var Nh = (an.prototype._parseStoresSpec = function(c, u) {
        o(c).forEach(function(p) {
          if (c[p] !== null) {
            var v = Pa(c[p]), y = v.shift();
            if (y.unique = !0, y.multi) throw new fe.Schema("Primary key cannot be multi-valued");
            v.forEach(function(x) {
              if (x.auto) throw new fe.Schema("Only primary key can be marked as autoIncrement (++)");
              if (!x.keyPath) throw new fe.Schema("Index must have a name and cannot be an empty string");
            }), u[p] = mo(p, y, v);
          }
        });
      }, an.prototype.stores = function(p) {
        var u = this.db;
        this._cfg.storesSource = this._cfg.storesSource ? l(this._cfg.storesSource, p) : p;
        var p = u._versions, v = {}, y = {};
        return p.forEach(function(x) {
          l(v, x._cfg.storesSource), y = x._cfg.dbschema = {}, x._parseStoresSpec(v, y);
        }), u._dbSchema = y, _o(u, [u._allTables, u, u.Transaction.prototype]), rn(u, [u._allTables, u, u.Transaction.prototype, this._cfg.tables], o(y), y), u._storeNames = o(y), this;
      }, an.prototype.upgrade = function(c) {
        return this._cfg.contentUpgrade = J(this._cfg.contentUpgrade || Ie, c), this;
      }, an);
      function an() {
      }
      function wo(c, u) {
        var p = c._dbNamesDB;
        return p || (p = c._dbNamesDB = new Dt(Xr, { addons: [], indexedDB: c, IDBKeyRange: u })).version(1).stores({ dbnames: "name" }), p.table("dbnames");
      }
      function xo(c) {
        return c && typeof c.databases == "function";
      }
      function Co(c) {
        return Lt(function() {
          return Y.letThrough = !0, c();
        });
      }
      function To(c) {
        return !("from" in c);
      }
      var nt = function(c, u) {
        if (!this) {
          var p = new nt();
          return c && "d" in c && l(p, c), p;
        }
        l(this, arguments.length ? { d: 1, from: c, to: 1 < arguments.length ? u : c } : { d: 0 });
      };
      function fr(c, u, p) {
        var v = Pe(u, p);
        if (!isNaN(v)) {
          if (0 < v) throw RangeError();
          if (To(c)) return l(c, { from: u, to: p, d: 1 });
          var y = c.l, v = c.r;
          if (Pe(p, c.from) < 0) return y ? fr(y, u, p) : c.l = { from: u, to: p, d: 1, l: null, r: null }, ka(c);
          if (0 < Pe(u, c.to)) return v ? fr(v, u, p) : c.r = { from: u, to: p, d: 1, l: null, r: null }, ka(c);
          Pe(u, c.from) < 0 && (c.from = u, c.l = null, c.d = v ? v.d + 1 : 1), 0 < Pe(p, c.to) && (c.to = p, c.r = null, c.d = c.l ? c.l.d + 1 : 1), p = !c.r, y && !c.l && pr(c, y), v && p && pr(c, v);
        }
      }
      function pr(c, u) {
        To(u) || function p(v, O) {
          var x = O.from, k = O.to, R = O.l, O = O.r;
          fr(v, x, k), R && p(v, R), O && p(v, O);
        }(c, u);
      }
      function Sa(c, u) {
        var p = ln(u), v = p.next();
        if (v.done) return !1;
        for (var y = v.value, x = ln(c), k = x.next(y.from), R = k.value; !v.done && !k.done; ) {
          if (Pe(R.from, y.to) <= 0 && 0 <= Pe(R.to, y.from)) return !0;
          Pe(y.from, R.from) < 0 ? y = (v = p.next(R.from)).value : R = (k = x.next(y.from)).value;
        }
        return !1;
      }
      function ln(c) {
        var u = To(c) ? null : { s: 0, n: c };
        return { next: function(p) {
          for (var v = 0 < arguments.length; u; ) switch (u.s) {
            case 0:
              if (u.s = 1, v) for (; u.n.l && Pe(p, u.n.from) < 0; ) u = { up: u, n: u.n.l, s: 1 };
              else for (; u.n.l; ) u = { up: u, n: u.n.l, s: 1 };
            case 1:
              if (u.s = 2, !v || Pe(p, u.n.to) <= 0) return { value: u.n, done: !1 };
            case 2:
              if (u.n.r) {
                u.s = 3, u = { up: u, n: u.n.r, s: 0 };
                continue;
              }
            case 3:
              u = u.up;
          }
          return { done: !0 };
        } };
      }
      function ka(c) {
        var u, p, v = (((u = c.r) === null || u === void 0 ? void 0 : u.d) || 0) - (((p = c.l) === null || p === void 0 ? void 0 : p.d) || 0), y = 1 < v ? "r" : v < -1 ? "l" : "";
        y && (u = y == "r" ? "l" : "r", p = t({}, c), v = c[y], c.from = v.from, c.to = v.to, c[y] = v[y], p[y] = v[u], (c[u] = p).d = Aa(p)), c.d = Aa(c);
      }
      function Aa(p) {
        var u = p.r, p = p.l;
        return (u ? p ? Math.max(u.d, p.d) : u.d : p ? p.d : 0) + 1;
      }
      function cn(c, u) {
        return o(u).forEach(function(p) {
          c[p] ? pr(c[p], u[p]) : c[p] = function v(y) {
            var x, k, R = {};
            for (x in y) f(y, x) && (k = y[x], R[x] = !k || typeof k != "object" || Fe.has(k.constructor) ? k : v(k));
            return R;
          }(u[p]);
        }), c;
      }
      function Eo(c, u) {
        return c.all || u.all || Object.keys(c).some(function(p) {
          return u[p] && Sa(u[p], c[p]);
        });
      }
      g(nt.prototype, ((vt = { add: function(c) {
        return pr(this, c), this;
      }, addKey: function(c) {
        return fr(this, c, c), this;
      }, addKeys: function(c) {
        var u = this;
        return c.forEach(function(p) {
          return fr(u, p, p);
        }), this;
      }, hasKey: function(c) {
        var u = ln(this).next(c).value;
        return u && Pe(u.from, c) <= 0 && 0 <= Pe(u.to, c);
      } })[We] = function() {
        return ln(this);
      }, vt));
      var ai = {}, Po = {}, So = !1;
      function hn(c) {
        cn(Po, c), So || (So = !0, setTimeout(function() {
          So = !1, ko(Po, !(Po = {}));
        }, 0));
      }
      function ko(c, u) {
        u === void 0 && (u = !1);
        var p = /* @__PURE__ */ new Set();
        if (c.all) for (var v = 0, y = Object.values(ai); v < y.length; v++) Ra(k = y[v], c, p, u);
        else for (var x in c) {
          var k, R = /^idb\:\/\/(.*)\/(.*)\//.exec(x);
          R && (x = R[1], R = R[2], (k = ai["idb://".concat(x, "/").concat(R)]) && Ra(k, c, p, u));
        }
        p.forEach(function(O) {
          return O();
        });
      }
      function Ra(c, u, p, v) {
        for (var y = [], x = 0, k = Object.entries(c.queries.query); x < k.length; x++) {
          for (var R = k[x], O = R[0], F = [], B = 0, D = R[1]; B < D.length; B++) {
            var H = D[B];
            Eo(u, H.obsSet) ? H.subscribers.forEach(function(M) {
              return p.add(M);
            }) : v && F.push(H);
          }
          v && y.push([O, F]);
        }
        if (v) for (var z = 0, L = y; z < L.length; z++) {
          var N = L[z], O = N[0], F = N[1];
          c.queries.query[O] = F;
        }
      }
      function Hh(c) {
        var u = c._state, p = c._deps.indexedDB;
        if (u.isBeingOpened || c.idbdb) return u.dbReadyPromise.then(function() {
          return u.dbOpenError ? je(u.dbOpenError) : c;
        });
        u.isBeingOpened = !0, u.dbOpenError = null, u.openComplete = !1;
        var v = u.openCanceller, y = Math.round(10 * c.verno), x = !1;
        function k() {
          if (u.openCanceller !== v) throw new fe.DatabaseClosed("db.open() was cancelled");
        }
        function R() {
          return new $(function(H, z) {
            if (k(), !p) throw new fe.MissingAPI();
            var L = c.name, N = u.autoSchema || !y ? p.open(L) : p.open(L, y);
            if (!N) throw new fe.MissingAPI();
            N.onerror = Et(z), N.onblocked = Ne(c._fireOnBlocked), N.onupgradeneeded = Ne(function(M) {
              var W;
              B = N.transaction, u.autoSchema && !c._options.allowEmptyDB ? (N.onerror = cr, B.abort(), N.result.close(), (W = p.deleteDatabase(L)).onsuccess = W.onerror = Ne(function() {
                z(new fe.NoSuchDatabase("Database ".concat(L, " doesnt exist")));
              })) : (B.onerror = Et(z), M = M.oldVersion > Math.pow(2, 62) ? 0 : M.oldVersion, D = M < 1, c.idbdb = N.result, x && Bh(c, B), Lh(c, M / 10, B, z));
            }, z), N.onsuccess = Ne(function() {
              B = null;
              var M, W, j, G, Z, ee = c.idbdb = N.result, se = V(ee.objectStoreNames);
              if (0 < se.length) try {
                var te = ee.transaction((G = se).length === 1 ? G[0] : G, "readonly");
                if (u.autoSchema) W = ee, j = te, (M = c).verno = W.version / 10, j = M._dbSchema = on(0, W, j), M._storeNames = V(W.objectStoreNames, 0), rn(M, [M._allTables], o(j), j);
                else if (sn(c, c._dbSchema, te), ((Z = bo(on(0, (Z = c).idbdb, te), Z._dbSchema)).add.length || Z.change.some(function(ne) {
                  return ne.add.length || ne.change.length;
                })) && !x) return console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Dexie will add missing parts and increment native version number to workaround this."), ee.close(), y = ee.version + 1, x = !0, H(R());
                tn(c, te);
              } catch {
              }
              Di.push(c), ee.onversionchange = Ne(function(ne) {
                u.vcFired = !0, c.on("versionchange").fire(ne);
              }), ee.onclose = Ne(function(ne) {
                c.on("close").fire(ne);
              }), D && (Z = c._deps, te = L, ee = Z.indexedDB, Z = Z.IDBKeyRange, xo(ee) || te === Xr || wo(ee, Z).put({ name: te }).catch(Ie)), H();
            }, z);
          }).catch(function(H) {
            switch (H == null ? void 0 : H.name) {
              case "UnknownError":
                if (0 < u.PR1398_maxLoop) return u.PR1398_maxLoop--, console.warn("Dexie: Workaround for Chrome UnknownError on open()"), R();
                break;
              case "VersionError":
                if (0 < y) return y = 0, R();
            }
            return $.reject(H);
          });
        }
        var O, F = u.dbReadyResolve, B = null, D = !1;
        return $.race([v, (typeof navigator > "u" ? $.resolve() : !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent) && indexedDB.databases ? new Promise(function(H) {
          function z() {
            return indexedDB.databases().finally(H);
          }
          O = setInterval(z, 100), z();
        }).finally(function() {
          return clearInterval(O);
        }) : Promise.resolve()).then(R)]).then(function() {
          return k(), u.onReadyBeingFired = [], $.resolve(Co(function() {
            return c.on.ready.fire(c.vip);
          })).then(function H() {
            if (0 < u.onReadyBeingFired.length) {
              var z = u.onReadyBeingFired.reduce(J, Ie);
              return u.onReadyBeingFired = [], $.resolve(Co(function() {
                return z(c.vip);
              })).then(H);
            }
          });
        }).finally(function() {
          u.openCanceller === v && (u.onReadyBeingFired = null, u.isBeingOpened = !1);
        }).catch(function(H) {
          u.dbOpenError = H;
          try {
            B && B.abort();
          } catch {
          }
          return v === u.openCanceller && c._close(), je(H);
        }).finally(function() {
          u.openComplete = !0, F();
        }).then(function() {
          var H;
          return D && (H = {}, c.tables.forEach(function(z) {
            z.schema.indexes.forEach(function(L) {
              L.name && (H["idb://".concat(c.name, "/").concat(z.name, "/").concat(L.name)] = new nt(-1 / 0, [[[]]]));
            }), H["idb://".concat(c.name, "/").concat(z.name, "/")] = H["idb://".concat(c.name, "/").concat(z.name, "/:dels")] = new nt(-1 / 0, [[[]]]);
          }), Vt(hr).fire(H), ko(H, !0)), c;
        });
      }
      function Ao(c) {
        function u(x) {
          return c.next(x);
        }
        var p = y(u), v = y(function(x) {
          return c.throw(x);
        });
        function y(x) {
          return function(O) {
            var R = x(O), O = R.value;
            return R.done ? O : O && typeof O.then == "function" ? O.then(p, v) : a(O) ? Promise.all(O).then(p, v) : p(O);
          };
        }
        return y(u)();
      }
      function dn(c, u, p) {
        for (var v = a(c) ? c.slice() : [c], y = 0; y < p; ++y) v.push(u);
        return v;
      }
      var Vh = { stack: "dbcore", name: "VirtualIndexMiddleware", level: 1, create: function(c) {
        return t(t({}, c), { table: function(u) {
          var p = c.table(u), v = p.schema, y = {}, x = [];
          function k(D, H, z) {
            var L = ur(D), N = y[L] = y[L] || [], M = D == null ? 0 : typeof D == "string" ? 1 : D.length, W = 0 < H, W = t(t({}, z), { name: W ? "".concat(L, "(virtual-from:").concat(z.name, ")") : z.name, lowLevelIndex: z, isVirtual: W, keyTail: H, keyLength: M, extractKey: vo(D), unique: !W && z.unique });
            return N.push(W), W.isPrimaryKey || x.push(W), 1 < M && k(M === 2 ? D[0] : D.slice(0, M - 1), H + 1, z), N.sort(function(j, G) {
              return j.keyTail - G.keyTail;
            }), W;
          }
          u = k(v.primaryKey.keyPath, 0, v.primaryKey), y[":id"] = [u];
          for (var R = 0, O = v.indexes; R < O.length; R++) {
            var F = O[R];
            k(F.keyPath, 0, F);
          }
          function B(D) {
            var H, z = D.query.index;
            return z.isVirtual ? t(t({}, D), { query: { index: z.lowLevelIndex, range: (H = D.query.range, z = z.keyTail, { type: H.type === 1 ? 2 : H.type, lower: dn(H.lower, H.lowerOpen ? c.MAX_KEY : c.MIN_KEY, z), lowerOpen: !0, upper: dn(H.upper, H.upperOpen ? c.MIN_KEY : c.MAX_KEY, z), upperOpen: !0 }) } }) : D;
          }
          return t(t({}, p), { schema: t(t({}, v), { primaryKey: u, indexes: x, getIndexByKeyPath: function(D) {
            return (D = y[ur(D)]) && D[0];
          } }), count: function(D) {
            return p.count(B(D));
          }, query: function(D) {
            return p.query(B(D));
          }, openCursor: function(D) {
            var H = D.query.index, z = H.keyTail, L = H.isVirtual, N = H.keyLength;
            return L ? p.openCursor(B(D)).then(function(W) {
              return W && M(W);
            }) : p.openCursor(D);
            function M(W) {
              return Object.create(W, { continue: { value: function(j) {
                j != null ? W.continue(dn(j, D.reverse ? c.MAX_KEY : c.MIN_KEY, z)) : D.unique ? W.continue(W.key.slice(0, N).concat(D.reverse ? c.MIN_KEY : c.MAX_KEY, z)) : W.continue();
              } }, continuePrimaryKey: { value: function(j, G) {
                W.continuePrimaryKey(dn(j, c.MAX_KEY, z), G);
              } }, primaryKey: { get: function() {
                return W.primaryKey;
              } }, key: { get: function() {
                var j = W.key;
                return N === 1 ? j[0] : j.slice(0, N);
              } }, value: { get: function() {
                return W.value;
              } } });
            }
          } });
        } });
      } };
      function Ro(c, u, p, v) {
        return p = p || {}, v = v || "", o(c).forEach(function(y) {
          var x, k, R;
          f(u, y) ? (x = c[y], k = u[y], typeof x == "object" && typeof k == "object" && x && k ? (R = Ue(x)) !== Ue(k) ? p[v + y] = u[y] : R === "Object" ? Ro(x, k, p, v + y + ".") : x !== k && (p[v + y] = u[y]) : x !== k && (p[v + y] = u[y])) : p[v + y] = void 0;
        }), o(u).forEach(function(y) {
          f(c, y) || (p[v + y] = u[y]);
        }), p;
      }
      function Io(c, u) {
        return u.type === "delete" ? u.keys : u.keys || u.values.map(c.extractKey);
      }
      var Uh = { stack: "dbcore", name: "HooksMiddleware", level: 2, create: function(c) {
        return t(t({}, c), { table: function(u) {
          var p = c.table(u), v = p.schema.primaryKey;
          return t(t({}, p), { mutate: function(y) {
            var x = Y.trans, k = x.table(u).hook, R = k.deleting, O = k.creating, F = k.updating;
            switch (y.type) {
              case "add":
                if (O.fire === Ie) break;
                return x._promise("readwrite", function() {
                  return B(y);
                }, !0);
              case "put":
                if (O.fire === Ie && F.fire === Ie) break;
                return x._promise("readwrite", function() {
                  return B(y);
                }, !0);
              case "delete":
                if (R.fire === Ie) break;
                return x._promise("readwrite", function() {
                  return B(y);
                }, !0);
              case "deleteRange":
                if (R.fire === Ie) break;
                return x._promise("readwrite", function() {
                  return function D(H, z, L) {
                    return p.query({ trans: H, values: !1, query: { index: v, range: z }, limit: L }).then(function(N) {
                      var M = N.result;
                      return B({ type: "delete", keys: M, trans: H }).then(function(W) {
                        return 0 < W.numFailures ? Promise.reject(W.failures[0]) : M.length < L ? { failures: [], numFailures: 0, lastResult: void 0 } : D(H, t(t({}, z), { lower: M[M.length - 1], lowerOpen: !0 }), L);
                      });
                    });
                  }(y.trans, y.range, 1e4);
                }, !0);
            }
            return p.mutate(y);
            function B(D) {
              var H, z, L, N = Y.trans, M = D.keys || Io(v, D);
              if (!M) throw new Error("Keys missing");
              return (D = D.type === "add" || D.type === "put" ? t(t({}, D), { keys: M }) : t({}, D)).type !== "delete" && (D.values = i([], D.values)), D.keys && (D.keys = i([], D.keys)), H = p, L = M, ((z = D).type === "add" ? Promise.resolve([]) : H.getMany({ trans: z.trans, keys: L, cache: "immutable" })).then(function(W) {
                var j = M.map(function(G, Z) {
                  var ee, se, te, ne = W[Z], ae = { onerror: null, onsuccess: null };
                  return D.type === "delete" ? R.fire.call(ae, G, ne, N) : D.type === "add" || ne === void 0 ? (ee = O.fire.call(ae, G, D.values[Z], N), G == null && ee != null && (D.keys[Z] = G = ee, v.outbound || pe(D.values[Z], v.keyPath, G))) : (ee = Ro(ne, D.values[Z]), (se = F.fire.call(ae, ee, G, ne, N)) && (te = D.values[Z], Object.keys(se).forEach(function(oe) {
                    f(te, oe) ? te[oe] = se[oe] : pe(te, oe, se[oe]);
                  }))), ae;
                });
                return p.mutate(D).then(function(G) {
                  for (var Z = G.failures, ee = G.results, se = G.numFailures, G = G.lastResult, te = 0; te < M.length; ++te) {
                    var ne = (ee || M)[te], ae = j[te];
                    ne == null ? ae.onerror && ae.onerror(Z[te]) : ae.onsuccess && ae.onsuccess(D.type === "put" && W[te] ? D.values[te] : ne);
                  }
                  return { failures: Z, results: ee, numFailures: se, lastResult: G };
                }).catch(function(G) {
                  return j.forEach(function(Z) {
                    return Z.onerror && Z.onerror(G);
                  }), Promise.reject(G);
                });
              });
            }
          } });
        } });
      } };
      function Ia(c, u, p) {
        try {
          if (!u || u.keys.length < c.length) return null;
          for (var v = [], y = 0, x = 0; y < u.keys.length && x < c.length; ++y) Pe(u.keys[y], c[x]) === 0 && (v.push(p ? Re(u.values[y]) : u.values[y]), ++x);
          return v.length === c.length ? v : null;
        } catch {
          return null;
        }
      }
      var Wh = { stack: "dbcore", level: -1, create: function(c) {
        return { table: function(u) {
          var p = c.table(u);
          return t(t({}, p), { getMany: function(v) {
            if (!v.cache) return p.getMany(v);
            var y = Ia(v.keys, v.trans._cache, v.cache === "clone");
            return y ? $.resolve(y) : p.getMany(v).then(function(x) {
              return v.trans._cache = { keys: v.keys, values: v.cache === "clone" ? Re(x) : x }, x;
            });
          }, mutate: function(v) {
            return v.type !== "add" && (v.trans._cache = null), p.mutate(v);
          } });
        } };
      } };
      function Da(c, u) {
        return c.trans.mode === "readonly" && !!c.subscr && !c.trans.explicit && c.trans.db._options.cache !== "disabled" && !u.schema.primaryKey.outbound;
      }
      function Oa(c, u) {
        switch (c) {
          case "query":
            return u.values && !u.unique;
          case "get":
          case "getMany":
          case "count":
          case "openCursor":
            return !1;
        }
      }
      var jh = { stack: "dbcore", level: 0, name: "Observability", create: function(c) {
        var u = c.schema.name, p = new nt(c.MIN_KEY, c.MAX_KEY);
        return t(t({}, c), { transaction: function(v, y, x) {
          if (Y.subscr && y !== "readonly") throw new fe.ReadOnly("Readwrite transaction in liveQuery context. Querier source: ".concat(Y.querier));
          return c.transaction(v, y, x);
        }, table: function(v) {
          var y = c.table(v), x = y.schema, k = x.primaryKey, D = x.indexes, R = k.extractKey, O = k.outbound, F = k.autoIncrement && D.filter(function(z) {
            return z.compound && z.keyPath.includes(k.keyPath);
          }), B = t(t({}, y), { mutate: function(z) {
            function L(oe) {
              return oe = "idb://".concat(u, "/").concat(v, "/").concat(oe), G[oe] || (G[oe] = new nt());
            }
            var N, M, W, j = z.trans, G = z.mutatedParts || (z.mutatedParts = {}), Z = L(""), ee = L(":dels"), se = z.type, ae = z.type === "deleteRange" ? [z.range] : z.type === "delete" ? [z.keys] : z.values.length < 50 ? [Io(k, z).filter(function(oe) {
              return oe;
            }), z.values] : [], te = ae[0], ne = ae[1], ae = z.trans._cache;
            return a(te) ? (Z.addKeys(te), (ae = se === "delete" || te.length === ne.length ? Ia(te, ae) : null) || ee.addKeys(te), (ae || ne) && (N = L, M = ae, W = ne, x.indexes.forEach(function(oe) {
              var le = N(oe.name || "");
              function ye(xe) {
                return xe != null ? oe.extractKey(xe) : null;
              }
              function we(xe) {
                return oe.multiEntry && a(xe) ? xe.forEach(function(pt) {
                  return le.addKey(pt);
                }) : le.addKey(xe);
              }
              (M || W).forEach(function(xe, ot) {
                var be = M && ye(M[ot]), ot = W && ye(W[ot]);
                Pe(be, ot) !== 0 && (be != null && we(be), ot != null && we(ot));
              });
            }))) : te ? (ne = { from: (ne = te.lower) !== null && ne !== void 0 ? ne : c.MIN_KEY, to: (ne = te.upper) !== null && ne !== void 0 ? ne : c.MAX_KEY }, ee.add(ne), Z.add(ne)) : (Z.add(p), ee.add(p), x.indexes.forEach(function(oe) {
              return L(oe.name).add(p);
            })), y.mutate(z).then(function(oe) {
              return !te || z.type !== "add" && z.type !== "put" || (Z.addKeys(oe.results), F && F.forEach(function(le) {
                for (var ye = z.values.map(function(be) {
                  return le.extractKey(be);
                }), we = le.keyPath.findIndex(function(be) {
                  return be === k.keyPath;
                }), xe = 0, pt = oe.results.length; xe < pt; ++xe) ye[xe][we] = oe.results[xe];
                L(le.name).addKeys(ye);
              })), j.mutatedParts = cn(j.mutatedParts || {}, G), oe;
            });
          } }), D = function(L) {
            var N = L.query, L = N.index, N = N.range;
            return [L, new nt((L = N.lower) !== null && L !== void 0 ? L : c.MIN_KEY, (N = N.upper) !== null && N !== void 0 ? N : c.MAX_KEY)];
          }, H = { get: function(z) {
            return [k, new nt(z.key)];
          }, getMany: function(z) {
            return [k, new nt().addKeys(z.keys)];
          }, count: D, query: D, openCursor: D };
          return o(H).forEach(function(z) {
            B[z] = function(L) {
              var N = Y.subscr, M = !!N, W = Da(Y, y) && Oa(z, L) ? L.obsSet = {} : N;
              if (M) {
                var j = function(ne) {
                  return ne = "idb://".concat(u, "/").concat(v, "/").concat(ne), W[ne] || (W[ne] = new nt());
                }, G = j(""), Z = j(":dels"), N = H[z](L), M = N[0], N = N[1];
                if ((z === "query" && M.isPrimaryKey && !L.values ? Z : j(M.name || "")).add(N), !M.isPrimaryKey) {
                  if (z !== "count") {
                    var ee = z === "query" && O && L.values && y.query(t(t({}, L), { values: !1 }));
                    return y[z].apply(this, arguments).then(function(ne) {
                      if (z === "query") {
                        if (O && L.values) return ee.then(function(ye) {
                          return ye = ye.result, G.addKeys(ye), ne;
                        });
                        var ae = L.values ? ne.result.map(R) : ne.result;
                        (L.values ? G : Z).addKeys(ae);
                      } else if (z === "openCursor") {
                        var oe = ne, le = L.values;
                        return oe && Object.create(oe, { key: { get: function() {
                          return Z.addKey(oe.primaryKey), oe.key;
                        } }, primaryKey: { get: function() {
                          var ye = oe.primaryKey;
                          return Z.addKey(ye), ye;
                        } }, value: { get: function() {
                          return le && G.addKey(oe.primaryKey), oe.value;
                        } } });
                      }
                      return ne;
                    });
                  }
                  Z.add(p);
                }
              }
              return y[z].apply(this, arguments);
            };
          }), B;
        } });
      } };
      function za(c, u, p) {
        if (p.numFailures === 0) return u;
        if (u.type === "deleteRange") return null;
        var v = u.keys ? u.keys.length : "values" in u && u.values ? u.values.length : 1;
        return p.numFailures === v ? null : (u = t({}, u), a(u.keys) && (u.keys = u.keys.filter(function(y, x) {
          return !(x in p.failures);
        })), "values" in u && a(u.values) && (u.values = u.values.filter(function(y, x) {
          return !(x in p.failures);
        })), u);
      }
      function Do(c, u) {
        return p = c, ((v = u).lower === void 0 || (v.lowerOpen ? 0 < Pe(p, v.lower) : 0 <= Pe(p, v.lower))) && (c = c, (u = u).upper === void 0 || (u.upperOpen ? Pe(c, u.upper) < 0 : Pe(c, u.upper) <= 0));
        var p, v;
      }
      function Fa(c, u, H, v, y, x) {
        if (!H || H.length === 0) return c;
        var k = u.query.index, R = k.multiEntry, O = u.query.range, F = v.schema.primaryKey.extractKey, B = k.extractKey, D = (k.lowLevelIndex || k).extractKey, H = H.reduce(function(z, L) {
          var N = z, M = [];
          if (L.type === "add" || L.type === "put") for (var W = new nt(), j = L.values.length - 1; 0 <= j; --j) {
            var G, Z = L.values[j], ee = F(Z);
            W.hasKey(ee) || (G = B(Z), (R && a(G) ? G.some(function(oe) {
              return Do(oe, O);
            }) : Do(G, O)) && (W.addKey(ee), M.push(Z)));
          }
          switch (L.type) {
            case "add":
              var se = new nt().addKeys(u.values ? z.map(function(le) {
                return F(le);
              }) : z), N = z.concat(u.values ? M.filter(function(le) {
                return le = F(le), !se.hasKey(le) && (se.addKey(le), !0);
              }) : M.map(function(le) {
                return F(le);
              }).filter(function(le) {
                return !se.hasKey(le) && (se.addKey(le), !0);
              }));
              break;
            case "put":
              var te = new nt().addKeys(L.values.map(function(le) {
                return F(le);
              }));
              N = z.filter(function(le) {
                return !te.hasKey(u.values ? F(le) : le);
              }).concat(u.values ? M : M.map(function(le) {
                return F(le);
              }));
              break;
            case "delete":
              var ne = new nt().addKeys(L.keys);
              N = z.filter(function(le) {
                return !ne.hasKey(u.values ? F(le) : le);
              });
              break;
            case "deleteRange":
              var ae = L.range;
              N = z.filter(function(le) {
                return !Do(F(le), ae);
              });
          }
          return N;
        }, c);
        return H === c ? c : (H.sort(function(z, L) {
          return Pe(D(z), D(L)) || Pe(F(z), F(L));
        }), u.limit && u.limit < 1 / 0 && (H.length > u.limit ? H.length = u.limit : c.length === u.limit && H.length < u.limit && (y.dirty = !0)), x ? Object.freeze(H) : H);
      }
      function Ma(c, u) {
        return Pe(c.lower, u.lower) === 0 && Pe(c.upper, u.upper) === 0 && !!c.lowerOpen == !!u.lowerOpen && !!c.upperOpen == !!u.upperOpen;
      }
      function Gh(c, u) {
        return function(p, v, y, x) {
          if (p === void 0) return v !== void 0 ? -1 : 0;
          if (v === void 0) return 1;
          if ((v = Pe(p, v)) === 0) {
            if (y && x) return 0;
            if (y) return 1;
            if (x) return -1;
          }
          return v;
        }(c.lower, u.lower, c.lowerOpen, u.lowerOpen) <= 0 && 0 <= function(p, v, y, x) {
          if (p === void 0) return v !== void 0 ? 1 : 0;
          if (v === void 0) return -1;
          if ((v = Pe(p, v)) === 0) {
            if (y && x) return 0;
            if (y) return -1;
            if (x) return 1;
          }
          return v;
        }(c.upper, u.upper, c.upperOpen, u.upperOpen);
      }
      function qh(c, u, p, v) {
        c.subscribers.add(p), v.addEventListener("abort", function() {
          var y, x;
          c.subscribers.delete(p), c.subscribers.size === 0 && (y = c, x = u, setTimeout(function() {
            y.subscribers.size === 0 && Ve(x, y);
          }, 3e3));
        });
      }
      var Kh = { stack: "dbcore", level: 0, name: "Cache", create: function(c) {
        var u = c.schema.name;
        return t(t({}, c), { transaction: function(p, v, y) {
          var x, k, R = c.transaction(p, v, y);
          return v === "readwrite" && (k = (x = new AbortController()).signal, y = function(O) {
            return function() {
              if (x.abort(), v === "readwrite") {
                for (var F = /* @__PURE__ */ new Set(), B = 0, D = p; B < D.length; B++) {
                  var H = D[B], z = ai["idb://".concat(u, "/").concat(H)];
                  if (z) {
                    var L = c.table(H), N = z.optimisticOps.filter(function(le) {
                      return le.trans === R;
                    });
                    if (R._explicit && O && R.mutatedParts) for (var M = 0, W = Object.values(z.queries.query); M < W.length; M++) for (var j = 0, G = (se = W[M]).slice(); j < G.length; j++) Eo((te = G[j]).obsSet, R.mutatedParts) && (Ve(se, te), te.subscribers.forEach(function(le) {
                      return F.add(le);
                    }));
                    else if (0 < N.length) {
                      z.optimisticOps = z.optimisticOps.filter(function(le) {
                        return le.trans !== R;
                      });
                      for (var Z = 0, ee = Object.values(z.queries.query); Z < ee.length; Z++) for (var se, te, ne, ae = 0, oe = (se = ee[Z]).slice(); ae < oe.length; ae++) (te = oe[ae]).res != null && R.mutatedParts && (O && !te.dirty ? (ne = Object.isFrozen(te.res), ne = Fa(te.res, te.req, N, L, te, ne), te.dirty ? (Ve(se, te), te.subscribers.forEach(function(le) {
                        return F.add(le);
                      })) : ne !== te.res && (te.res = ne, te.promise = $.resolve({ result: ne }))) : (te.dirty && Ve(se, te), te.subscribers.forEach(function(le) {
                        return F.add(le);
                      })));
                    }
                  }
                }
                F.forEach(function(le) {
                  return le();
                });
              }
            };
          }, R.addEventListener("abort", y(!1), { signal: k }), R.addEventListener("error", y(!1), { signal: k }), R.addEventListener("complete", y(!0), { signal: k })), R;
        }, table: function(p) {
          var v = c.table(p), y = v.schema.primaryKey;
          return t(t({}, v), { mutate: function(x) {
            var k = Y.trans;
            if (y.outbound || k.db._options.cache === "disabled" || k.explicit || k.idbtrans.mode !== "readwrite") return v.mutate(x);
            var R = ai["idb://".concat(u, "/").concat(p)];
            return R ? (k = v.mutate(x), x.type !== "add" && x.type !== "put" || !(50 <= x.values.length || Io(y, x).some(function(O) {
              return O == null;
            })) ? (R.optimisticOps.push(x), x.mutatedParts && hn(x.mutatedParts), k.then(function(O) {
              0 < O.numFailures && (Ve(R.optimisticOps, x), (O = za(0, x, O)) && R.optimisticOps.push(O), x.mutatedParts && hn(x.mutatedParts));
            }), k.catch(function() {
              Ve(R.optimisticOps, x), x.mutatedParts && hn(x.mutatedParts);
            })) : k.then(function(O) {
              var F = za(0, t(t({}, x), { values: x.values.map(function(B, D) {
                var H;
                return O.failures[D] ? B : (B = (H = y.keyPath) !== null && H !== void 0 && H.includes(".") ? Re(B) : t({}, B), pe(B, y.keyPath, O.results[D]), B);
              }) }), O);
              R.optimisticOps.push(F), queueMicrotask(function() {
                return x.mutatedParts && hn(x.mutatedParts);
              });
            }), k) : v.mutate(x);
          }, query: function(x) {
            if (!Da(Y, v) || !Oa("query", x)) return v.query(x);
            var k = ((F = Y.trans) === null || F === void 0 ? void 0 : F.db._options.cache) === "immutable", D = Y, R = D.requery, O = D.signal, F = function(L, N, M, W) {
              var j = ai["idb://".concat(L, "/").concat(N)];
              if (!j) return [];
              if (!(N = j.queries[M])) return [null, !1, j, null];
              var G = N[(W.query ? W.query.index.name : null) || ""];
              if (!G) return [null, !1, j, null];
              switch (M) {
                case "query":
                  var Z = G.find(function(ee) {
                    return ee.req.limit === W.limit && ee.req.values === W.values && Ma(ee.req.query.range, W.query.range);
                  });
                  return Z ? [Z, !0, j, G] : [G.find(function(ee) {
                    return ("limit" in ee.req ? ee.req.limit : 1 / 0) >= W.limit && (!W.values || ee.req.values) && Gh(ee.req.query.range, W.query.range);
                  }), !1, j, G];
                case "count":
                  return Z = G.find(function(ee) {
                    return Ma(ee.req.query.range, W.query.range);
                  }), [Z, !!Z, j, G];
              }
            }(u, p, "query", x), B = F[0], D = F[1], H = F[2], z = F[3];
            return B && D ? B.obsSet = x.obsSet : (D = v.query(x).then(function(L) {
              var N = L.result;
              if (B && (B.res = N), k) {
                for (var M = 0, W = N.length; M < W; ++M) Object.freeze(N[M]);
                Object.freeze(N);
              } else L.result = Re(N);
              return L;
            }).catch(function(L) {
              return z && B && Ve(z, B), Promise.reject(L);
            }), B = { obsSet: x.obsSet, promise: D, subscribers: /* @__PURE__ */ new Set(), type: "query", req: x, dirty: !1 }, z ? z.push(B) : (z = [B], (H = H || (ai["idb://".concat(u, "/").concat(p)] = { queries: { query: {}, count: {} }, objs: /* @__PURE__ */ new Map(), optimisticOps: [], unsignaledParts: {} })).queries.query[x.query.index.name || ""] = z)), qh(B, z, R, O), B.promise.then(function(L) {
              return { result: Fa(L.result, x, H == null ? void 0 : H.optimisticOps, v, B, k) };
            });
          } });
        } });
      } };
      function un(c, u) {
        return new Proxy(c, { get: function(p, v, y) {
          return v === "db" ? u : Reflect.get(p, v, y);
        } });
      }
      var Dt = (Ge.prototype.version = function(c) {
        if (isNaN(c) || c < 0.1) throw new fe.Type("Given version is not a positive number");
        if (c = Math.round(10 * c) / 10, this.idbdb || this._state.isBeingOpened) throw new fe.Schema("Cannot add version when database is open");
        this.verno = Math.max(this.verno, c);
        var u = this._versions, p = u.filter(function(v) {
          return v._cfg.version === c;
        })[0];
        return p || (p = new this.Version(c), u.push(p), u.sort(Mh), p.stores({}), this._state.autoSchema = !1, p);
      }, Ge.prototype._whenReady = function(c) {
        var u = this;
        return this.idbdb && (this._state.openComplete || Y.letThrough || this._vip) ? c() : new $(function(p, v) {
          if (u._state.openComplete) return v(new fe.DatabaseClosed(u._state.dbOpenError));
          if (!u._state.isBeingOpened) {
            if (!u._state.autoOpen) return void v(new fe.DatabaseClosed());
            u.open().catch(Ie);
          }
          u._state.dbReadyPromise.then(p, v);
        }).then(c);
      }, Ge.prototype.use = function(c) {
        var u = c.stack, p = c.create, v = c.level, y = c.name;
        return y && this.unuse({ stack: u, name: y }), c = this._middlewares[u] || (this._middlewares[u] = []), c.push({ stack: u, create: p, level: v ?? 10, name: y }), c.sort(function(x, k) {
          return x.level - k.level;
        }), this;
      }, Ge.prototype.unuse = function(c) {
        var u = c.stack, p = c.name, v = c.create;
        return u && this._middlewares[u] && (this._middlewares[u] = this._middlewares[u].filter(function(y) {
          return v ? y.create !== v : !!p && y.name !== p;
        })), this;
      }, Ge.prototype.open = function() {
        var c = this;
        return ni(Q, function() {
          return Hh(c);
        });
      }, Ge.prototype._close = function() {
        var c = this._state, u = Di.indexOf(this);
        if (0 <= u && Di.splice(u, 1), this.idbdb) {
          try {
            this.idbdb.close();
          } catch {
          }
          this.idbdb = null;
        }
        c.isBeingOpened || (c.dbReadyPromise = new $(function(p) {
          c.dbReadyResolve = p;
        }), c.openCanceller = new $(function(p, v) {
          c.cancelOpen = v;
        }));
      }, Ge.prototype.close = function(p) {
        var u = (p === void 0 ? { disableAutoOpen: !0 } : p).disableAutoOpen, p = this._state;
        u ? (p.isBeingOpened && p.cancelOpen(new fe.DatabaseClosed()), this._close(), p.autoOpen = !1, p.dbOpenError = new fe.DatabaseClosed()) : (this._close(), p.autoOpen = this._options.autoOpen || p.isBeingOpened, p.openComplete = !1, p.dbOpenError = null);
      }, Ge.prototype.delete = function(c) {
        var u = this;
        c === void 0 && (c = { disableAutoOpen: !0 });
        var p = 0 < arguments.length && typeof arguments[0] != "object", v = this._state;
        return new $(function(y, x) {
          function k() {
            u.close(c);
            var R = u._deps.indexedDB.deleteDatabase(u.name);
            R.onsuccess = Ne(function() {
              var O, F, B;
              O = u._deps, F = u.name, B = O.indexedDB, O = O.IDBKeyRange, xo(B) || F === Xr || wo(B, O).delete(F).catch(Ie), y();
            }), R.onerror = Et(x), R.onblocked = u._fireOnBlocked;
          }
          if (p) throw new fe.InvalidArgument("Invalid closeOptions argument to db.delete()");
          v.isBeingOpened ? v.dbReadyPromise.then(k) : k();
        });
      }, Ge.prototype.backendDB = function() {
        return this.idbdb;
      }, Ge.prototype.isOpen = function() {
        return this.idbdb !== null;
      }, Ge.prototype.hasBeenClosed = function() {
        var c = this._state.dbOpenError;
        return c && c.name === "DatabaseClosed";
      }, Ge.prototype.hasFailed = function() {
        return this._state.dbOpenError !== null;
      }, Ge.prototype.dynamicallyOpened = function() {
        return this._state.autoSchema;
      }, Object.defineProperty(Ge.prototype, "tables", { get: function() {
        var c = this;
        return o(this._allTables).map(function(u) {
          return c._allTables[u];
        });
      }, enumerable: !1, configurable: !0 }), Ge.prototype.transaction = function() {
        var c = (function(u, p, v) {
          var y = arguments.length;
          if (y < 2) throw new fe.InvalidArgument("Too few arguments");
          for (var x = new Array(y - 1); --y; ) x[y - 1] = arguments[y];
          return v = x.pop(), [u, He(x), v];
        }).apply(this, arguments);
        return this._transaction.apply(this, c);
      }, Ge.prototype._transaction = function(c, u, p) {
        var v = this, y = Y.trans;
        y && y.db === this && c.indexOf("!") === -1 || (y = null);
        var x, k, R = c.indexOf("?") !== -1;
        c = c.replace("!", "").replace("?", "");
        try {
          if (k = u.map(function(F) {
            if (F = F instanceof v.Table ? F.name : F, typeof F != "string") throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
            return F;
          }), c == "r" || c === lo) x = lo;
          else {
            if (c != "rw" && c != co) throw new fe.InvalidArgument("Invalid transaction mode: " + c);
            x = co;
          }
          if (y) {
            if (y.mode === lo && x === co) {
              if (!R) throw new fe.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
              y = null;
            }
            y && k.forEach(function(F) {
              if (y && y.storeNames.indexOf(F) === -1) {
                if (!R) throw new fe.SubTransaction("Table " + F + " not included in parent transaction.");
                y = null;
              }
            }), R && y && !y.active && (y = null);
          }
        } catch (F) {
          return y ? y._promise(null, function(B, D) {
            D(F);
          }) : je(F);
        }
        var O = (function F(B, D, H, z, L) {
          return $.resolve().then(function() {
            var N = Y.transless || Y, M = B._createTransaction(D, H, B._dbSchema, z);
            if (M.explicit = !0, N = { trans: M, transless: N }, z) M.idbtrans = z.idbtrans;
            else try {
              M.create(), M.idbtrans._explicit = !0, B._state.PR1398_maxLoop = 3;
            } catch (G) {
              return G.name === xt.InvalidState && B.isOpen() && 0 < --B._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), B.close({ disableAutoOpen: !1 }), B.open().then(function() {
                return F(B, D, H, null, L);
              })) : je(G);
            }
            var W, j = ti(L);
            return j && Ii(), N = $.follow(function() {
              var G;
              (W = L.call(M, M)) && (j ? (G = Bt.bind(null, null), W.then(G, G)) : typeof W.next == "function" && typeof W.throw == "function" && (W = Ao(W)));
            }, N), (W && typeof W.then == "function" ? $.resolve(W).then(function(G) {
              return M.active ? G : je(new fe.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"));
            }) : N.then(function() {
              return W;
            })).then(function(G) {
              return z && M._resolve(), M._completion.then(function() {
                return G;
              });
            }).catch(function(G) {
              return M._reject(G), je(G);
            });
          });
        }).bind(null, this, x, k, y, p);
        return y ? y._promise(x, O, "lock") : Y.trans ? ni(Y.transless, function() {
          return v._whenReady(O);
        }) : this._whenReady(O);
      }, Ge.prototype.table = function(c) {
        if (!f(this._allTables, c)) throw new fe.InvalidTable("Table ".concat(c, " does not exist"));
        return this._allTables[c];
      }, Ge);
      function Ge(c, u) {
        var p = this;
        this._middlewares = {}, this.verno = 0;
        var v = Ge.dependencies;
        this._options = u = t({ addons: Ge.addons, autoOpen: !0, indexedDB: v.indexedDB, IDBKeyRange: v.IDBKeyRange, cache: "cloned" }, u), this._deps = { indexedDB: u.indexedDB, IDBKeyRange: u.IDBKeyRange }, v = u.addons, this._dbSchema = {}, this._versions = [], this._storeNames = [], this._allTables = {}, this.idbdb = null, this._novip = this;
        var y, x, k, R, O, F = { dbOpenError: null, isBeingOpened: !1, onReadyBeingFired: null, openComplete: !1, dbReadyResolve: Ie, dbReadyPromise: null, cancelOpen: Ie, openCanceller: null, autoSchema: !0, PR1398_maxLoop: 3, autoOpen: u.autoOpen };
        F.dbReadyPromise = new $(function(D) {
          F.dbReadyResolve = D;
        }), F.openCanceller = new $(function(D, H) {
          F.cancelOpen = H;
        }), this._state = F, this.name = c, this.on = sr(this, "populate", "blocked", "versionchange", "close", { ready: [J, Ie] }), this.on.ready.subscribe = K(this.on.ready.subscribe, function(D) {
          return function(H, z) {
            Ge.vip(function() {
              var L, N = p._state;
              N.openComplete ? (N.dbOpenError || $.resolve().then(H), z && D(H)) : N.onReadyBeingFired ? (N.onReadyBeingFired.push(H), z && D(H)) : (D(H), L = p, z || D(function M() {
                L.on.ready.unsubscribe(H), L.on.ready.unsubscribe(M);
              }));
            });
          };
        }), this.Collection = (y = this, ar(Ah.prototype, function(W, M) {
          this.db = y;
          var z = fa, L = null;
          if (M) try {
            z = M();
          } catch (j) {
            L = j;
          }
          var N = W._ctx, M = N.table, W = M.hook.reading.fire;
          this._ctx = { table: M, index: N.index, isPrimKey: !N.index || M.schema.primKey.keyPath && N.index === M.schema.primKey.name, range: z, keysOnly: !1, dir: "next", unique: "", algorithm: null, filter: null, replayFilter: null, justLimit: !0, isMatch: null, offset: 0, limit: 1 / 0, error: L, or: N.or, valueMapper: W !== Ct ? W : null };
        })), this.Table = (x = this, ar(va.prototype, function(D, H, z) {
          this.db = x, this._tx = z, this.name = D, this.schema = H, this.hook = x._allTables[D] ? x._allTables[D].hook : sr(null, { creating: [Mt, Ie], reading: [rr, Ct], updating: [P, Ie], deleting: [m, Ie] });
        })), this.Transaction = (k = this, ar(Dh.prototype, function(D, H, z, L, N) {
          var M = this;
          this.db = k, this.mode = D, this.storeNames = H, this.schema = z, this.chromeTransactionDurability = L, this.idbtrans = null, this.on = sr(this, "complete", "error", "abort"), this.parent = N || null, this.active = !0, this._reculock = 0, this._blockedFuncs = [], this._resolve = null, this._reject = null, this._waitingFor = null, this._waitingQueue = null, this._spinCount = 0, this._completion = new $(function(W, j) {
            M._resolve = W, M._reject = j;
          }), this._completion.then(function() {
            M.active = !1, M.on.complete.fire();
          }, function(W) {
            var j = M.active;
            return M.active = !1, M.on.error.fire(W), M.parent ? M.parent._reject(W) : j && M.idbtrans && M.idbtrans.abort(), je(W);
          });
        })), this.Version = (R = this, ar(Nh.prototype, function(D) {
          this.db = R, this._cfg = { version: D, storesSource: null, dbschema: {}, tables: {}, contentUpgrade: null };
        })), this.WhereClause = (O = this, ar(xa.prototype, function(D, H, z) {
          if (this.db = O, this._ctx = { table: D, index: H === ":id" ? null : H, or: z }, this._cmp = this._ascending = Pe, this._descending = function(L, N) {
            return Pe(N, L);
          }, this._max = function(L, N) {
            return 0 < Pe(L, N) ? L : N;
          }, this._min = function(L, N) {
            return Pe(L, N) < 0 ? L : N;
          }, this._IDBKeyRange = O._deps.IDBKeyRange, !this._IDBKeyRange) throw new fe.MissingAPI();
        })), this.on("versionchange", function(D) {
          0 < D.newVersion ? console.warn("Another connection wants to upgrade database '".concat(p.name, "'. Closing db now to resume the upgrade.")) : console.warn("Another connection wants to delete database '".concat(p.name, "'. Closing db now to resume the delete request.")), p.close({ disableAutoOpen: !1 });
        }), this.on("blocked", function(D) {
          !D.newVersion || D.newVersion < D.oldVersion ? console.warn("Dexie.delete('".concat(p.name, "') was blocked")) : console.warn("Upgrade '".concat(p.name, "' blocked by other connection holding version ").concat(D.oldVersion / 10));
        }), this._maxKey = dr(u.IDBKeyRange), this._createTransaction = function(D, H, z, L) {
          return new p.Transaction(D, H, z, p._options.chromeTransactionDurability, L);
        }, this._fireOnBlocked = function(D) {
          p.on("blocked").fire(D), Di.filter(function(H) {
            return H.name === p.name && H !== p && !H._state.vcFired;
          }).map(function(H) {
            return H.on("versionchange").fire(D);
          });
        }, this.use(Wh), this.use(Kh), this.use(jh), this.use(Vh), this.use(Uh);
        var B = new Proxy(this, { get: function(D, H, z) {
          if (H === "_vip") return !0;
          if (H === "table") return function(N) {
            return un(p.table(N), B);
          };
          var L = Reflect.get(D, H, z);
          return L instanceof va ? un(L, B) : H === "tables" ? L.map(function(N) {
            return un(N, B);
          }) : H === "_createTransaction" ? function() {
            return un(L.apply(this, arguments), B);
          } : L;
        } });
        this.vip = B, v.forEach(function(D) {
          return D(p);
        });
      }
      var fn, vt = typeof Symbol < "u" && "observable" in Symbol ? Symbol.observable : "@@observable", Zh = (Oo.prototype.subscribe = function(c, u, p) {
        return this._subscribe(c && typeof c != "function" ? c : { next: c, error: u, complete: p });
      }, Oo.prototype[vt] = function() {
        return this;
      }, Oo);
      function Oo(c) {
        this._subscribe = c;
      }
      try {
        fn = { indexedDB: n.indexedDB || n.mozIndexedDB || n.webkitIndexedDB || n.msIndexedDB, IDBKeyRange: n.IDBKeyRange || n.webkitIDBKeyRange };
      } catch {
        fn = { indexedDB: null, IDBKeyRange: null };
      }
      function La(c) {
        var u, p = !1, v = new Zh(function(y) {
          var x = ti(c), k, R = !1, O = {}, F = {}, B = { get closed() {
            return R;
          }, unsubscribe: function() {
            R || (R = !0, k && k.abort(), D && Vt.storagemutated.unsubscribe(z));
          } };
          y.start && y.start(B);
          var D = !1, H = function() {
            return ao(L);
          }, z = function(N) {
            cn(O, N), Eo(F, O) && H();
          }, L = function() {
            var N, M, W;
            !R && fn.indexedDB && (O = {}, N = {}, k && k.abort(), k = new AbortController(), W = function(j) {
              var G = Ai();
              try {
                x && Ii();
                var Z = Lt(c, j);
                return Z = x ? Z.finally(Bt) : Z;
              } finally {
                G && Ri();
              }
            }(M = { subscr: N, signal: k.signal, requery: H, querier: c, trans: null }), Promise.resolve(W).then(function(j) {
              p = !0, u = j, R || M.signal.aborted || (O = {}, function(G) {
                for (var Z in G) if (f(G, Z)) return;
                return 1;
              }(F = N) || D || (Vt(hr, z), D = !0), ao(function() {
                return !R && y.next && y.next(j);
              }));
            }, function(j) {
              p = !1, ["DatabaseClosedError", "AbortError"].includes(j == null ? void 0 : j.name) || R || ao(function() {
                R || y.error && y.error(j);
              });
            }));
          };
          return setTimeout(H, 0), B;
        });
        return v.hasValue = function() {
          return p;
        }, v.getValue = function() {
          return u;
        }, v;
      }
      var li = Dt;
      function zo(c) {
        var u = Ut;
        try {
          Ut = !0, Vt.storagemutated.fire(c), ko(c, !0);
        } finally {
          Ut = u;
        }
      }
      g(li, t(t({}, At), { delete: function(c) {
        return new li(c, { addons: [] }).delete();
      }, exists: function(c) {
        return new li(c, { addons: [] }).open().then(function(u) {
          return u.close(), !0;
        }).catch("NoSuchDatabaseError", function() {
          return !1;
        });
      }, getDatabaseNames: function(c) {
        try {
          return u = li.dependencies, p = u.indexedDB, u = u.IDBKeyRange, (xo(p) ? Promise.resolve(p.databases()).then(function(v) {
            return v.map(function(y) {
              return y.name;
            }).filter(function(y) {
              return y !== Xr;
            });
          }) : wo(p, u).toCollection().primaryKeys()).then(c);
        } catch {
          return je(new fe.MissingAPI());
        }
        var u, p;
      }, defineClass: function() {
        return function(c) {
          l(this, c);
        };
      }, ignoreTransaction: function(c) {
        return Y.trans ? ni(Y.transless, c) : c();
      }, vip: Co, async: function(c) {
        return function() {
          try {
            var u = Ao(c.apply(this, arguments));
            return u && typeof u.then == "function" ? u : $.resolve(u);
          } catch (p) {
            return je(p);
          }
        };
      }, spawn: function(c, u, p) {
        try {
          var v = Ao(c.apply(p, u || []));
          return v && typeof v.then == "function" ? v : $.resolve(v);
        } catch (y) {
          return je(y);
        }
      }, currentTransaction: { get: function() {
        return Y.trans || null;
      } }, waitFor: function(c, u) {
        return u = $.resolve(typeof c == "function" ? li.ignoreTransaction(c) : c).timeout(u || 6e4), Y.trans ? Y.trans.waitFor(u) : u;
      }, Promise: $, debug: { get: function() {
        return ie;
      }, set: function(c) {
        de(c);
      } }, derive: E, extend: l, props: g, override: K, Events: sr, on: Vt, liveQuery: La, extendObservabilitySet: cn, getByKeyPath: he, setByKeyPath: pe, delByKeyPath: function(c, u) {
        typeof u == "string" ? pe(c, u, void 0) : "length" in u && [].map.call(u, function(p) {
          pe(c, p, void 0);
        });
      }, shallowClone: Te, deepClone: Re, getObjectDiff: Ro, cmp: Pe, asap: re, minKey: -1 / 0, addons: [], connections: Di, errnames: xt, dependencies: fn, cache: ai, semVer: "4.0.10", version: "4.0.10".split(".").map(function(c) {
        return parseInt(c);
      }).reduce(function(c, u, p) {
        return c + u / Math.pow(10, 2 * p);
      }) })), li.maxKey = dr(li.dependencies.IDBKeyRange), typeof dispatchEvent < "u" && typeof addEventListener < "u" && (Vt(hr, function(c) {
        Ut || (c = new CustomEvent(po, { detail: c }), Ut = !0, dispatchEvent(c), Ut = !1);
      }), addEventListener(po, function(c) {
        c = c.detail, Ut || zo(c);
      }));
      var Fi, Ut = !1, Ba = function() {
      };
      return typeof BroadcastChannel < "u" && ((Ba = function() {
        (Fi = new BroadcastChannel(po)).onmessage = function(c) {
          return c.data && zo(c.data);
        };
      })(), typeof Fi.unref == "function" && Fi.unref(), Vt(hr, function(c) {
        Ut || Fi.postMessage(c);
      })), typeof addEventListener < "u" && (addEventListener("pagehide", function(c) {
        if (!Dt.disableBfCache && c.persisted) {
          ie && console.debug("Dexie: handling persisted pagehide"), Fi != null && Fi.close();
          for (var u = 0, p = Di; u < p.length; u++) p[u].close({ disableAutoOpen: !1 });
        }
      }), addEventListener("pageshow", function(c) {
        !Dt.disableBfCache && c.persisted && (ie && console.debug("Dexie: handling persisted pageshow"), Ba(), zo({ all: new nt(-1 / 0, [[]]) }));
      })), $.rejectionMapper = function(c, u) {
        return !c || c instanceof _e || c instanceof TypeError || c instanceof SyntaxError || !c.name || !ri[c.name] ? c : (u = new ri[c.name](u || c.message, c), "stack" in c && C(u, "stack", { get: function() {
          return this.inner.stack;
        } }), u);
      }, de(ie), t(Dt, Object.freeze({ __proto__: null, Dexie: Dt, liveQuery: La, Entity: pa, cmp: Pe, PropModSymbol: It, PropModification: lr, replacePrefix: function(c, u) {
        return new lr({ replacePrefix: [c, u] });
      }, add: function(c) {
        return new lr({ add: c });
      }, remove: function(c) {
        return new lr({ remove: c });
      }, default: Dt, RangeSet: nt, mergeRanges: pr, rangesOverlap: Sa }), { default: Dt }), Dt;
    });
  }(An)), An.exports;
}
var gm = pm();
const Ps = /* @__PURE__ */ vh(gm), jl = Symbol.for("Dexie"), Ss = globalThis[jl] || (globalThis[jl] = Ps);
if (Ps.semVer !== Ss.semVer)
  throw new Error(`Two different versions of Dexie loaded in the same app: ${Ps.semVer} and ${Ss.semVer}`);
class mm {
  constructor(r) {
    this.apiContext = void 0, this.db = void 0, this.hasRefreshedFavourites = !1, this.hasRefreshedAll = !1, this.localCache = /* @__PURE__ */ new Map(), this.apiContext = r, this.db = this.initDb();
  }
  initDb() {
    const r = new Ss("KioskTimeZones");
    return r.version(1).stores({
      kioskTimeZones: "&id, tz_long, tz_IANA, deprecated, version, favourite"
    }), r;
  }
  getLocalCache() {
    return this.localCache;
  }
  async getFavouriteTimeZones(r = !1, e = !1) {
    if (this.db) {
      const t = await this.db.kioskTimeZones.count();
      let i;
      return t == 0 && await this.refreshFavourites(), r ? i = await this.db.kioskTimeZones.where({ favourite: 1 }).toArray() : i = await this.db.kioskTimeZones.where({ deprecated: 0, favourite: 1 }).toArray(), e && this.refreshFavourites().finally(() => {
        console.log("refreshed favourites");
      }), i;
    } else return [];
  }
  async refreshFavourites() {
    var r, e;
    if (!this.db) return [];
    if (!this.hasRefreshedFavourites) {
      const t = await this.fetchFavouriteTimeZones();
      if (t && t.length > 0) {
        let i = await ((r = this.db) == null ? void 0 : r.kioskTimeZones.where("favourite").equals(1).delete());
        console.log(`Deleted ${i} favourite time zones`);
        const n = t.map((a) => ({
          id: a.id,
          tz_IANA: a.tz_IANA,
          tz_long: a.tz_long,
          deprecated: a.deprecated ? 1 : 0,
          version: a.version,
          favourite: 1
        }));
        let o = await ((e = this.db) == null ? void 0 : e.kioskTimeZones.bulkAdd(n));
        return console.log(`Added ${o} new favourite time zones`), this.hasRefreshedFavourites = !0, n;
      }
    }
    return [];
  }
  async fetchFavouriteTimeZones() {
    var r;
    return await ((r = this.apiContext) == null ? void 0 : r.fetchFromApi(
      "",
      "favouritetimezones",
      {
        method: "GET",
        caller: "app.fetchFavouriteTimeZones"
      }
    ).then((e) => (console.log("favourite time zone information fetched"), e)).catch((e) => (console.log(`fetching time zone information failed: ${e}`), [])));
  }
  async fetchAllTimeZones(r = 0) {
    var t;
    const e = new URLSearchParams();
    return e.append("include_deprecated", "true"), r > 0 && e.append("newer_than", `${r}`), await ((t = this.apiContext) == null ? void 0 : t.fetchFromApi(
      "",
      "timezones",
      {
        method: "GET",
        caller: "app.fetchFavouriteTimeZones"
      },
      "v1",
      e
    ).then((i) => (console.log("time zone information fetched"), i)).catch((i) => (console.log(`time zone information failed: ${i}`), [])));
  }
  async getAllTimeZones(r = !1, e = !1) {
    var i;
    await this.refreshAllTimeZones(e);
    let t = await ((i = this.db) == null ? void 0 : i.kioskTimeZones.toArray());
    return t == null ? void 0 : t.filter((n) => n.deprecated == 0 || r);
  }
  async getTimeZoneByIndex(r, e = !1) {
    if (!this.db) return;
    await this.refreshAllTimeZones(e);
    let t = await this.db.kioskTimeZones.where("id").equals(r).toArray();
    return t.length > 0 ? t[0] : void 0;
  }
  /**
   * Asynchronously caches the time zone information locally based on the provided timezone index.
   * Locally cached time zone information can be retrieved synchronously using getTimeZoneInfoFromLocalCache
   * @param tzIndex a Kiosk Time Zone Index
   * @param tryRefresh Flag indicating whether to refresh the timezone information if not found in the cache.
   * @returns A Promise that resolves to the cached TimeZone object if found, otherwise undefined.
   */
  async cacheLocally(r, e = !1) {
    if (!this.db || typeof r != "number") return;
    let t = this.localCache.get(r);
    if (t) return t;
    if (t = await this.getTimeZoneByIndex(r), !t) {
      if (!e) return;
      await this.refreshAllTimeZones(!1), t = await this.getTimeZoneByIndex(r);
    }
    return t && (console.log("Cached TimeZone", t), this.localCache.set(r, t)), this.localCache.get(r);
  }
  /**
   * Retrieves timezone information from the local cache based on the provided timezone index.
   * Unlike other methods this is synchronous.
   * @param tzIndex - The index of the timezone to retrieve information for.
   * @returns a TimeZone instance if found in the local cache, otherwise undefined.
   */
  getTimeZoneInfoFromLocalCache(r) {
    if (typeof r == "string" && (r = parseInt(r)), !!r)
      return this.localCache.get(r);
  }
  async refreshAllTimeZones(r) {
    let e = [];
    if (this.db && (r || !this.hasRefreshedAll)) {
      let t = 0;
      const i = (await this.getFavouriteTimeZones()).filter((o) => o.favourite == 1).map((o) => o.id);
      if (!r)
        try {
          t = (await this.db.kioskTimeZones.where("favourite").equals(0).reverse().sortBy("version"))[0].version, console.log(`max version was ${t}`);
        } catch {
        }
      const n = await this.fetchAllTimeZones(t);
      if (n && n.length > 0) {
        let o = await this.db.kioskTimeZones.where("version").above(t).delete();
        console.log(`delete ${o} time zones above version ${t}`), e = n.map((a) => ({
          id: a.id,
          tz_IANA: a.tz_IANA,
          tz_long: a.tz_long,
          deprecated: a.deprecated ? 1 : 0,
          version: a.version,
          favourite: i.includes(a.id) ? 1 : 0
        })), o = await this.db.kioskTimeZones.bulkAdd(e), console.log(`added ${o} new time zones `);
      }
      this.hasRefreshedAll = !0;
    }
  }
}
const vm = '*{padding:0;margin:0;border:0px;-webkit-user-select:none;user-select:none}p,div{-webkit-user-select:text;user-select:text}select{-webkit-user-select:none;user-select:none}.col-bg-body-lighter{background-color:var(--col-bg-body-lighter)}.col-bg-body{background-color:var(--col-bg-body)}.col-bg-body-darker{background-color:var(--col-bg-body-darker)}.col-bg-1-lighter{background-color:var(--col-bg-1-lighter)}.col-bg-1{background-color:var(--col-bg-1)}.col-bg-1-darker{background-color:var(--col-bg-1-darker)}.col-bg-1-input{background-color:var(--col-bg-1-input)}.col-primary-bg-1{background-color:var(--col-primary-bg-1)}.col-accent-bg-1{background-color:var(--col-accent-bg-1)}.col-success-bg-1{background-color:var(--col-success-bg-1)}.col-warning-bg-1{background-color:var(--col-warning-bg-1)}.col-error-bg-1{background-color:var(--col-error-bg-1)}.col-bg-2-lighter{background-color:var(--col-bg-2-lighter)}.col-bg-2{background-color:var(--col-bg-2)}.col-bg-2-darker{background-color:var(--col-bg-2-darker)}.col-bg-2-button{background-color:var(--col-bg-2-button)}.col-bg-2-input{background-color:var(--col-bg-2-input)}.col-primary-bg-2{background-color:var(--col-primary-bg-2)}.col-accent-bg-2{background-color:var(--col-accent-bg-2)}.col-success-bg-2{background-color:var(--col-success-bg-2)}.col-warning-bg-2{background-color:var(--col-warning-bg-2)}.col-error-bg-2{background-color:var(--col-error-bg-2)}.col-bg-3-lighter{background-color:var(--col-bg-3-lighter)}.col-bg-3{background-color:var(--col-bg-3)}.col-bg-3-darker{background-color:var(--col-bg-3-darker)}.col-bg-3-button{background-color:var(--col-bg-3-button)}.col-bg-3-input{background-color:var(--col-bg-3-input)}.col-primary-bg-3{background-color:var(--col-primary-bg-3)}.col-accent-bg-3{background-color:var(--col-accent-bg-3)}.col-success-bg-3{background-color:var(--col-success-bg-3)}.col-warning-bg-3{background-color:var(--col-warning-bg-3)}.col-error-bg-3{background-color:var(--col-error-bg-3)}.col-bg-ack-lighter{background-color:var(--col-bg-ack-lighter)}.col-bg-ack{background-color:var(--col-bg-ack)}.col-bg-ack-darker{background-color:var(--col-bg-ack-darker)}.col-primary-bg-ack{background-color:var(--col-primary-bg-ack)}.col-accent-bg-ack{background-color:var(--col-accent-bg-ack)}.col-bg-att-lighter{background-color:var(--col-bg-att-lighter)}.col-bg-att{background-color:var(--col-bg-att)}.col-bg-att-darker{background-color:var(--col-bg-att-darker)}.col-primary-bg-att{background-color:var(--col-primary-bg-att)}.col-accent-bg-att{background-color:var(--col-accent-bg-att)}.col-bg-alert-lighter{background-color:var(--col-bg-alert-lighter)}.col-bg-alert{background-color:var(--col-bg-alert)}.col-bg-alert-darker{background-color:var(--col-bg-alert-darker)}.col-primary-bg-alert{background-color:var(--col-primary-bg-alert)}.col-accent-bg-alert{background-color:var(--col-accent-bg-alert)}.col-bg-btn-lighter{background-color:var(--col-bg-btn-lighter)}.col-bg-btn{background-color:var(--col-bg-btn)}.col-bg-btn-darker{background-color:var(--col-bg-btn-darker)}.col-primary-bg-btn{background-color:var(--col-primary-bg-btn)}.col-accent-bg-btn{background-color:var(--col-accent-bg-btn)}.pattern-diagonal-stripes-sm{background:repeating-linear-gradient(45deg,transparent,transparent 10px,currentColor 10px,currentColor 20px)}.pattern-dots-lg{background-image:radial-gradient(currentColor 1.5px,transparent 1.5px);background-size:15px 15px}.pattern-dots-md{background-image:radial-gradient(currentColor 1px,transparent 1px);background-size:8px 8px}.pattern-dots-medium-dense{background-image:radial-gradient(currentColor .5px,transparent .5px);background-size:3px 3px}.pattern-dots-sm{background-image:radial-gradient(currentColor .5px,transparent .5px);background-size:5px 5px}.pattern-cross-dots-md,.imagelist-background{background-image:radial-gradient(currentColor .7px,transparent 1px),radial-gradient(currentColor .7px,transparent 1px);background-size:6.5px 6.5px;background-position:0 0,3.5px 3.5px}.imagelist-background{background-color:#fff9;background-blend-mode:overlay}label{font-family:var(--monospace-font);font-size:.9em}input,select{-webkit-user-select:text;-moz-user-select:text;-ms-user-select:text;box-sizing:border-box;border-radius:0;user-select:text;font-family:var(--standard-text-font);background-color:var(--col-bg-1-input);border:none;color:var(--col-primary-bg-1);padding:2px;margin-bottom:2px;outline:none}textarea{outline:none}input:not([type=radio],[type=checkbox]),select,textarea{width:100%}input:not([type=radio],[type=checkbox]):focus,select:focus,textarea:focus{margin-bottom:0;border-bottom:2px solid rgb(0,0,0)}h1{font-size:var(--font-size-h1)}h2{font-size:var(--font-size-h2)}h3{font-size:var(--font-size-h3)}h4{font-size:var(--font-size-h4)}small,.font-small{font-size:var(--font-size-small)}button{width:60px;height:60px;border-radius:35px;border-style:solid;border-width:2px;background-color:var(--col-bg-btn);color:var(--col-primary-bg-btn);border-color:var(--col-bg-btn-darker);font-family:var(--headline-text-font);font-size:var(--font-size-h4);font-weight:700}button:hover,button:focus{outline:none;background-color:var(--col-bg-btn-lighter)}button:active{padding-top:3px;color:var(--col-primary-bg-btn);background-color:var(--col-bg-btn-darker);border-color:var(--col-bg-btn-darker)}.kiosk-btn-128{width:128px;height:128px}.kiosk-btn-32{width:32px;height:32px}.kiosk-dropdown-btn{box-sizing:content-box;border-radius:0;background-color:var(--col-bg-btn);border-color:var(--col-bg-btn-darker);color:var(--col-primary-bg-btn);height:30px;width:30px}.kiosk-dropdown-btn .drop-down-btn{float:left}.kiosk-dropdown-btn .caret{color:var(--col-primary-bg-btn);display:inline-block;width:0;height:0;margin-left:2px;vertical-align:middle;border-color:var(--col-primary-bg-btn);border-top:4px solid;border-right:4px solid transparent;border-left:4px solid transparent}button:disabled{opacity:.3}.modal-round-button,.modal-delete,.modal-close,.modal-cancel,.modal-back,.modal-next,.modal-ok,.modal-button{box-sizing:border-box;margin-left:25px;background-image:none;display:inline-block;font-style:normal;font-variant:normal;text-rendering:auto;-webkit-font-smoothing:antialiased;font-family:"Font Awesome 6 Free";font-weight:900;font-size:24px;line-height:24px;vertical-align:center;text-align:center}.modal-ok:after{content:var(--icon-bt-ok)}.modal-next:after{padding-left:2px;content:var(--icon-bt-next)}.modal-back:after{padding-right:2px;content:var(--icon-bt-back)}.modal-cancel:after{content:var(--icon-bt-cancel)}.modal-close:before{content:var(--icon-bt-close)}.modal-delete{background-color:var(--col-bg-alert);color:var(--col-primary-bg-alert)}.modal-delete:before{content:var(--icon-bt-trash)}.modal-delete:hover,.modal-delete:focus{border-color:var(--col-bg-alert);background-color:var(--col-bg-alert-lighter);background-size:75%}.modal-delete:active{border-color:var(--col-bg-alert);background-color:var(--col-bg-alert-darker);color:var(--col-primary-bg-alert)}.kiosk-rounded{border-radius:15px}.kiosk-shaded{box-shadow:2px 2px 10px #2e380394}.kiosk-margin-bottom{margin-bottom:1em}.flex-line-break{width:100%;height:0px}.kiosk-align-flex-end{align-items:flex-end}.kiosk-align-flex-start{align-items:flex-start}.full-background-bg-1{background:linear-gradient(to right bottom,var(--col-bg-1-darker),var(--col-bg-1-lighter));height:100%;width:100%}.small-list-button i{border-radius:25px;box-shadow:2px 2px 5px #2e380394}.small-list-button:hover{color:var(--col-bg-att)}.small-list-button:hover i{box-shadow:2px 2px 5px #2e380394}.small-list-button:active,.small-list-button:focus{color:var(--col-bg-ack);transform:translateY(5px)}.small-list-button:active i,.small-list-button:focus i{box-shadow:none}.dialog-radio-div{display:flex;flex-direction:row}.dialog-radio-div input[type=radio]{margin-right:.5em}.rainbow-loading{display:flex;justify-content:center;align-items:center;height:5px;width:100%;background-color:#000}.rainbow-loading.to-top{position:fixed;top:0;z-index:1000}.rainbow-loading-progress{height:5px;width:100%;border-radius:3px;background:linear-gradient(90deg,red,#ff0,#0f0 30%,#0ff 50%,#00f,#f0f 80%,red);background-size:200%;animation:move-gradient 2s ease-in infinite}@keyframes move-gradient{0%{background-position:0% 0%}to{background-position:-200% 0%}}.fa,.fas{font-family:"Font Awesome 6 Free";font-weight:900;font-style:normal}.fa-trash:before{content:""}.fa-view-grid:before{content:""}.fa-reload:before{content:""}.fa-view-list:before{content:""}.fa-camera:before{content:""}.fa-view-image:before{content:""}.fa-check:before{content:""}.fa-bug:before{content:""}.fa-lightbulb:before{content:""}.fa-query:before{content:""}.fa-footsteps{transform:rotate(270deg)}.fa-footsteps:before{content:""}.fa-next:before{content:""}.fa-prev:before{content:""}.fa-hide:before{content:""}.fa-circle-half-stroke:before{content:""}i{font-family:"Font Awesome 6 Free";font-style:normal;font-variant:normal;text-rendering:auto;-webkit-font-smoothing:antialiased;font-weight:900;font-size:.9em}div,p{font-family:var(--standard-text-font)}dialog{margin:auto;width:100%;height:100%;background-color:unset;outline:none;border:none}dialog .dialog-outer-zone{display:grid;background-color:unset;width:100%;height:100%;place-items:center}.dialog-frame{position:relative;background-color:var(--col-bg-1);display:flex;padding:20px 25px 10px;flex-direction:column;justify-content:space-between;border:2px solid var(--col-bg-1)}.dialog-header{height:auto;display:flex;width:100%;flex-direction:row;flex-wrap:nowrap;align-items:center;padding-bottom:.5rem;margin-top:.5em;margin-right:1em;border:0px solid black;border-bottom-width:1px;margin-bottom:1rem}.dialog-image{box-sizing:border-box;padding-right:10px;background-repeat:no-repeat;z-index:0}.dialog-name h3{font-family:var(--monospace-font)}.close-button{-webkit-user-select:none;user-select:none;position:absolute;font-size:var(--font-size-h3);color:var(--col-primary-bg-1);margin-left:auto;right:.5rem;top:.5rem}.close-button :hover{background-color:var(--col-bg-btn);color:var(--col-primary-bg-btn)}.close-button :active{background-color:var(--col-bg-btn);color:var(--col-accent-bg-btn)}';
var _m = Object.defineProperty, bm = Object.getOwnPropertyDescriptor, ym = Object.getPrototypeOf, wm = Reflect.get, _h = (s, r, e, t) => {
  for (var i = t > 1 ? void 0 : t ? bm(r, e) : r, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (t ? o(r, e, i) : o(i)) || i);
  return t && i && _m(r, e, i), i;
}, xm = (s, r, e) => wm(ym(s), e, r);
let yi = class extends vi {
  constructor() {
    super(...arguments), this.heading = "";
  }
  firstUpdated(s) {
    console.log("KioskDialog first updated", s), super.firstUpdated(s);
  }
  openDialog() {
    var r;
    let s = (r = this.shadowRoot) == null ? void 0 : r.querySelector("dialog");
    s && s.showModal();
  }
  closeDialog(s) {
    var e;
    let r = (e = this.shadowRoot) == null ? void 0 : e.querySelector("dialog");
    r && r.close(s);
  }
  _overlayClicked(s) {
    var r;
    s.target == ((r = this.shadowRoot) == null ? void 0 : r.querySelector(".dialog-outer-zone")) && this.closeDialog();
  }
  _onCloseDialog() {
    var e;
    let s = (e = this.shadowRoot) == null ? void 0 : e.querySelector("dialog"), r = new CustomEvent("kiosk-dialog-closed", {
      bubbles: !1,
      cancelable: !1,
      composed: !1,
      detail: s == null ? void 0 : s.returnValue
    });
    this.dispatchEvent(r);
  }
  render() {
    return mt`
            <dialog id="my-dialog" @close="${this._onCloseDialog}">
                <div class="dialog-outer-zone" @click="${this._overlayClicked}">
                    <div class="dialog-frame">
                        <div class="dialog-header">
                            <div class="dialog-image">
                                <slot name="dialog-image"></slot>
                            </div>
                            <div class="dialog-name">
                                <h3 class="dialog-title">${this.heading}</h3>
                            </div>
                            <div class="close-button" @click="${this.closeDialog}">
                                <i class="fa"></i>
                            </div>
                        </div>
                        <slot name="dialog-content">
                        </slot>
                    </div>
                </div>
            </dialog>
        `;
  }
};
yi.styles = Hr(vm);
yi.properties = {
  ...xm(yi, yi, "properties")
};
_h([
  et()
], yi.prototype, "heading", 2);
yi = _h([
  ro("kiosk-dialog")
], yi);
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const aa = { ATTRIBUTE: 1, CHILD: 2, PROPERTY: 3, BOOLEAN_ATTRIBUTE: 4, EVENT: 5, ELEMENT: 6 }, bh = (s) => (...r) => ({ _$litDirective$: s, values: r });
class yh {
  constructor(r) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(r, e, t) {
    this._$Ct = r, this._$AM = e, this._$Ci = t;
  }
  _$AS(r, e) {
    return this.update(r, e);
  }
  update(r, e) {
    return this.render(...e);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Cm = (s) => s.strings === void 0;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Ar = (s, r) => {
  var t;
  const e = s._$AN;
  if (e === void 0) return !1;
  for (const i of e) (t = i._$AO) == null || t.call(i, r, !1), Ar(i, r);
  return !0;
}, Zn = (s) => {
  let r, e;
  do {
    if ((r = s._$AM) === void 0) break;
    e = r._$AN, e.delete(s), s = r;
  } while ((e == null ? void 0 : e.size) === 0);
}, wh = (s) => {
  for (let r; r = s._$AM; s = r) {
    let e = r._$AN;
    if (e === void 0) r._$AN = e = /* @__PURE__ */ new Set();
    else if (e.has(s)) break;
    e.add(s), Pm(r);
  }
};
function Tm(s) {
  this._$AN !== void 0 ? (Zn(this), this._$AM = s, wh(this)) : this._$AM = s;
}
function Em(s, r = !1, e = 0) {
  const t = this._$AH, i = this._$AN;
  if (i !== void 0 && i.size !== 0) if (r) if (Array.isArray(t)) for (let n = e; n < t.length; n++) Ar(t[n], !1), Zn(t[n]);
  else t != null && (Ar(t, !1), Zn(t));
  else Ar(this, s);
}
const Pm = (s) => {
  s.type == aa.CHILD && (s._$AP ?? (s._$AP = Em), s._$AQ ?? (s._$AQ = Tm));
};
class Sm extends yh {
  constructor() {
    super(...arguments), this._$AN = void 0;
  }
  _$AT(r, e, t) {
    super._$AT(r, e, t), wh(this), this.isConnected = r._$AU;
  }
  _$AO(r, e = !0) {
    var t, i;
    r !== this.isConnected && (this.isConnected = r, r ? (t = this.reconnected) == null || t.call(this) : (i = this.disconnected) == null || i.call(this)), e && (Ar(this, r), Zn(this));
  }
  setValue(r) {
    if (Cm(this._$Ct)) this._$Ct._$AI(r, this);
    else {
      const e = [...this._$Ct._$AH];
      e[this._$Ci] = r, this._$Ct._$AI(e, this, 0);
    }
  }
  disconnected() {
  }
  reconnected() {
  }
}
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const Gl = Symbol("valueNotInitialized");
class km extends Sm {
  constructor(r) {
    if (super(r), r.type !== aa.ELEMENT)
      throw new Error(`\`${this.constructor.name}\` must be bound to an element.`);
    this.previousValue = Gl;
  }
  /** @override */
  render(r, e) {
    return ze;
  }
  /** @override */
  update(r, [e, t]) {
    return this.hasChanged(t) && (this.host = r.options && r.options.host, this.element = r.element, this.renderer = e, this.previousValue === Gl ? this.addRenderer() : this.runRenderer(), this.previousValue = Array.isArray(t) ? [...t] : t), ze;
  }
  /** @override */
  reconnected() {
    this.addRenderer();
  }
  /** @override */
  disconnected() {
    this.removeRenderer();
  }
  /** @abstract */
  addRenderer() {
    throw new Error("The `addRenderer` method must be implemented.");
  }
  /** @abstract */
  runRenderer() {
    throw new Error("The `runRenderer` method must be implemented.");
  }
  /** @abstract */
  removeRenderer() {
    throw new Error("The `removeRenderer` method must be implemented.");
  }
  /** @protected */
  renderRenderer(r, ...e) {
    const t = this.renderer.call(this.host, ...e);
    rc(t, r, { host: this.host });
  }
  /** @protected */
  hasChanged(r) {
    return Array.isArray(r) ? !Array.isArray(this.previousValue) || this.previousValue.length !== r.length ? !0 : r.some((e, t) => e !== this.previousValue[t]) : this.previousValue !== r;
  }
}
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const ql = Symbol("contentUpdateDebouncer");
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class Am extends km {
  /**
   * A property to that the renderer callback will be assigned.
   *
   * @abstract
   */
  get rendererProperty() {
    throw new Error("The `rendererProperty` getter must be implemented.");
  }
  /**
   * Adds the renderer callback to the grid column.
   */
  addRenderer() {
    this.element[this.rendererProperty] = (r, e) => {
      this.renderRenderer(r, e);
    };
  }
  /**
   * Runs the renderer callback on the grid column.
   */
  runRenderer() {
    const r = this.element._grid;
    r[ql] = Le.debounce(r[ql], yt, () => {
      r.requestContentUpdate();
    });
  }
  /**
   * Removes the renderer callback from the grid column.
   */
  removeRenderer() {
    this.element[this.rendererProperty] = null;
  }
}
class Rm extends Am {
  get rendererProperty() {
    return "renderer";
  }
  addRenderer() {
    this.element[this.rendererProperty] = (r, e, t) => {
      this.renderRenderer(r, t.item, t, e);
    };
  }
}
const Im = bh(Rm);
var Dm = Object.defineProperty, Om = Object.getOwnPropertyDescriptor, zm = Object.getPrototypeOf, Fm = Reflect.get, xh = (s) => {
  throw TypeError(s);
}, wt = (s, r, e, t) => {
  for (var i = t > 1 ? void 0 : t ? Om(r, e) : r, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (t ? o(r, e, i) : o(i)) || i);
  return t && i && Dm(r, e, i), i;
}, Ch = (s, r, e) => r.has(s) || xh("Cannot " + e), xn = (s, r, e) => (Ch(s, r, "read from private field"), e ? e.call(s) : r.get(s)), Cn = (s, r, e) => r.has(s) ? xh("Cannot add the same private member more than once") : r instanceof WeakSet ? r.add(s) : r.set(s, e), Tn = (s, r, e, t) => (Ch(s, r, "write to private field"), r.set(s, e), e), Mm = (s, r, e) => Fm(zm(s), e, r), Rn, In, Dn, On;
let at = class extends Qi {
  constructor() {
    super(), this.constants = {}, Cn(this, Rn, []), Cn(this, In, []), this.searchIdentifier = "", this.heading = "select archaeological entity", this.identifierColumnTitle = "entity", this.initialRecordType = "unit", Cn(this, Dn, []), Cn(this, On, {}), this.recordTypeFilter = [], this.cellRenderer = (s) => {
      const r = hm(this.recordTypeAliases, s.record_type);
      return mt`
            <div>
                ${r}
            </div>`;
    }, Ke("vaadin-grid", ke`
            :host [part~="header-cell"] ::slotted(vaadin-grid-cell-content), [part~="footer-cell"] ::slotted(vaadin-grid-cell-content), [part~="reorder-ghost"] {
                font-weight: bold
            }
        `);
  }
  get identifiers() {
    return xn(this, Rn);
  }
  set identifiers(s) {
    Tn(this, Rn, s);
  }
  get _identifiers() {
    return xn(this, In);
  }
  set _identifiers(s) {
    Tn(this, In, s);
  }
  get selectedItems() {
    return xn(this, Dn);
  }
  set selectedItems(s) {
    Tn(this, Dn, s);
  }
  get recordTypeAliases() {
    return xn(this, On);
  }
  set recordTypeAliases(s) {
    Tn(this, On, s);
  }
  updated(s) {
    var r;
    if (super.updated(s), s.has("apiContext") && this.apiConnected(), s.has("selectedItems") && this.selectedItems.length > 0) {
      const e = (r = this.shadowRoot) == null ? void 0 : r.querySelector("kiosk-dialog");
      e && setTimeout(() => {
        const t = new CustomEvent("closeSelection", {
          detail: this.selectedItems[0]
        });
        this.dispatchEvent(t), e.closeDialog();
      }, 250);
    }
  }
  willUpdate(s) {
    (s.has("identifiers") || s.has("recordTypeFilter")) && this.prepareIdentifiers();
  }
  apiConnected() {
    console.log("fetching identifiers"), (!this.identifiers || this.identifiers.length == 0) && this.fetchIdentifiers();
  }
  fetchIdentifiers() {
    this.apiContext.fetchFromApi(
      "",
      "contexts/full",
      {
        method: "GET",
        caller: "app.fetchIdentifiers"
      }
    ).then((s) => {
      this.identifiers = s.identifiers, console.log("identifier information fetched", this.identifiers);
    }).catch((s) => {
      this.showProgress = !1, console.log("fetching identifier information failed"), dm(this, s, "loadConstants");
    });
  }
  prepareIdentifiers() {
    console.log("prepare identifiers"), this.recordTypeFilter.length > 0 ? this._identifiers = this.identifiers.filter((s) => this.recordTypeFilter.includes(s.record_type.toLowerCase())) : this._identifiers = this.identifiers;
  }
  filterIdentifiers() {
    return this.searchIdentifier === "" && this.initialRecordType !== "" ? this._identifiers.filter((s) => s.record_type === this.initialRecordType) : this.searchIdentifier || this._identifiers.length < 50 ? this._identifiers.filter((s) => s.identifier.toLowerCase().startsWith(this.searchIdentifier)) : [];
  }
  openDialog() {
    var r;
    ((r = this.shadowRoot) == null ? void 0 : r.querySelector("kiosk-dialog")).openDialog();
  }
  searchChanged(s) {
    let r = s.target.value;
    this.searchIdentifier = r.toLowerCase();
  }
  activeItemChanged(s) {
    const r = s.detail.value;
    r && (this.selectedItems = [r]);
  }
  renderGrid() {
    return mt`
            <vaadin-grid id="grid" class="selection-grid"
                         .items=${this.filterIdentifiers()}
                         .selectedItems="${this.selectedItems}"
                         @active-item-changed="${this.activeItemChanged}">
                <vaadin-grid-column header="${this.identifierColumnTitle}" path="identifier"></vaadin-grid-column>
                <vaadin-grid-column header="type" ${Im(this.cellRenderer, [])}></vaadin-grid-column>
            </vaadin-grid>
        `;
  }
  apiRender() {
    return mt`
            <kiosk-dialog api heading="${this.heading}">
                <!--svg slot="dialog-image" xmlns="http://www.w3.org/2000/svg" width="auto" height="auto" viewBox="0 0 24 24" style="fill: rgba(0, 0, 0, 1);transform: ;msFilter:;"><path d="M11 19.91 10 22h4l-1-2.09c4-.65 7-5.28 7-9.91a8 8 0 0 0-16 0c0 4.63 3.08 9.26 7 9.91zm1-15.66v1.5A4.26 4.26 0 0 0 7.75 10h-1.5A5.76 5.76 0 0 1 12 4.25z"></path></svg-->
                <div slot="dialog-image">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                         style="fill: rgba(0, 0, 0, 1);transform: ;msFilter:;">
                        <path d="M4 22h12v-2H4V8H2v12c0 1.103.897 2 2 2z"></path>
                        <path
                            d="M20 2H8c-1.103 0-2 .897-2 2v12c0 1.103.897 2 2 2h12c1.103 0 2-.897 2-2V4c0-1.103-.897-2-2-2zm-2 9h-3v3h-2v-3h-3V9h3V6h2v3h3v2z"></path>
                    </svg>
                </div>
                <div slot="dialog-content">
                    <label for="identifier">search word expands selection</label>
                    <input id="identifier" type="text" @input="${this.searchChanged}" autofocus>
                    ${this.renderGrid()}
                </div>
            </kiosk-dialog>
        `;
  }
};
Rn = /* @__PURE__ */ new WeakMap();
In = /* @__PURE__ */ new WeakMap();
Dn = /* @__PURE__ */ new WeakMap();
On = /* @__PURE__ */ new WeakMap();
at.styles = Hr(zg);
at.properties = {
  ...Mm(at, at, "properties")
};
wt([
  et()
], at.prototype, "constants", 2);
wt([
  et()
], at.prototype, "identifiers", 1);
wt([
  ei()
], at.prototype, "_identifiers", 1);
wt([
  et()
], at.prototype, "searchIdentifier", 2);
wt([
  et()
], at.prototype, "heading", 2);
wt([
  et()
], at.prototype, "identifierColumnTitle", 2);
wt([
  et()
], at.prototype, "initialRecordType", 2);
wt([
  et()
], at.prototype, "selectedItems", 1);
wt([
  et()
], at.prototype, "recordTypeAliases", 1);
wt([
  et()
], at.prototype, "recordTypeFilter", 2);
at = wt([
  ro("kiosk-context-selector")
], at);
const Lm = '*{padding:0;margin:0;border:0px;-webkit-user-select:none;user-select:none}p,div{-webkit-user-select:text;user-select:text}select{-webkit-user-select:none;user-select:none}.col-bg-body-lighter{background-color:var(--col-bg-body-lighter)}.col-bg-body{background-color:var(--col-bg-body)}.col-bg-body-darker{background-color:var(--col-bg-body-darker)}.col-bg-1-lighter{background-color:var(--col-bg-1-lighter)}.col-bg-1{background-color:var(--col-bg-1)}.col-bg-1-darker{background-color:var(--col-bg-1-darker)}.col-bg-1-input{background-color:var(--col-bg-1-input)}.col-primary-bg-1{background-color:var(--col-primary-bg-1)}.col-accent-bg-1{background-color:var(--col-accent-bg-1)}.col-success-bg-1{background-color:var(--col-success-bg-1)}.col-warning-bg-1{background-color:var(--col-warning-bg-1)}.col-error-bg-1{background-color:var(--col-error-bg-1)}.col-bg-2-lighter{background-color:var(--col-bg-2-lighter)}.col-bg-2{background-color:var(--col-bg-2)}.col-bg-2-darker{background-color:var(--col-bg-2-darker)}.col-bg-2-button{background-color:var(--col-bg-2-button)}.col-bg-2-input{background-color:var(--col-bg-2-input)}.col-primary-bg-2{background-color:var(--col-primary-bg-2)}.col-accent-bg-2{background-color:var(--col-accent-bg-2)}.col-success-bg-2{background-color:var(--col-success-bg-2)}.col-warning-bg-2{background-color:var(--col-warning-bg-2)}.col-error-bg-2{background-color:var(--col-error-bg-2)}.col-bg-3-lighter{background-color:var(--col-bg-3-lighter)}.col-bg-3{background-color:var(--col-bg-3)}.col-bg-3-darker{background-color:var(--col-bg-3-darker)}.col-bg-3-button{background-color:var(--col-bg-3-button)}.col-bg-3-input{background-color:var(--col-bg-3-input)}.col-primary-bg-3{background-color:var(--col-primary-bg-3)}.col-accent-bg-3{background-color:var(--col-accent-bg-3)}.col-success-bg-3{background-color:var(--col-success-bg-3)}.col-warning-bg-3{background-color:var(--col-warning-bg-3)}.col-error-bg-3{background-color:var(--col-error-bg-3)}.col-bg-ack-lighter{background-color:var(--col-bg-ack-lighter)}.col-bg-ack{background-color:var(--col-bg-ack)}.col-bg-ack-darker{background-color:var(--col-bg-ack-darker)}.col-primary-bg-ack{background-color:var(--col-primary-bg-ack)}.col-accent-bg-ack{background-color:var(--col-accent-bg-ack)}.col-bg-att-lighter{background-color:var(--col-bg-att-lighter)}.col-bg-att{background-color:var(--col-bg-att)}.col-bg-att-darker{background-color:var(--col-bg-att-darker)}.col-primary-bg-att{background-color:var(--col-primary-bg-att)}.col-accent-bg-att{background-color:var(--col-accent-bg-att)}.col-bg-alert-lighter{background-color:var(--col-bg-alert-lighter)}.col-bg-alert{background-color:var(--col-bg-alert)}.col-bg-alert-darker{background-color:var(--col-bg-alert-darker)}.col-primary-bg-alert{background-color:var(--col-primary-bg-alert)}.col-accent-bg-alert{background-color:var(--col-accent-bg-alert)}.col-bg-btn-lighter{background-color:var(--col-bg-btn-lighter)}.col-bg-btn{background-color:var(--col-bg-btn)}.col-bg-btn-darker{background-color:var(--col-bg-btn-darker)}.col-primary-bg-btn{background-color:var(--col-primary-bg-btn)}.col-accent-bg-btn{background-color:var(--col-accent-bg-btn)}.pattern-diagonal-stripes-sm{background:repeating-linear-gradient(45deg,transparent,transparent 10px,currentColor 10px,currentColor 20px)}.pattern-dots-lg{background-image:radial-gradient(currentColor 1.5px,transparent 1.5px);background-size:15px 15px}.pattern-dots-md{background-image:radial-gradient(currentColor 1px,transparent 1px);background-size:8px 8px}.pattern-dots-medium-dense{background-image:radial-gradient(currentColor .5px,transparent .5px);background-size:3px 3px}.pattern-dots-sm{background-image:radial-gradient(currentColor .5px,transparent .5px);background-size:5px 5px}.pattern-cross-dots-md,.imagelist-background{background-image:radial-gradient(currentColor .7px,transparent 1px),radial-gradient(currentColor .7px,transparent 1px);background-size:6.5px 6.5px;background-position:0 0,3.5px 3.5px}.imagelist-background{background-color:#fff9;background-blend-mode:overlay}label{font-family:var(--monospace-font);font-size:.9em}input,select{-webkit-user-select:text;-moz-user-select:text;-ms-user-select:text;box-sizing:border-box;border-radius:0;user-select:text;font-family:var(--standard-text-font);background-color:var(--col-bg-1-input);border:none;color:var(--col-primary-bg-1);padding:2px;margin-bottom:2px;outline:none}textarea{outline:none}input:not([type=radio],[type=checkbox]),select,textarea{width:100%}input:not([type=radio],[type=checkbox]):focus,select:focus,textarea:focus{margin-bottom:0;border-bottom:2px solid rgb(0,0,0)}h1{font-size:var(--font-size-h1)}h2{font-size:var(--font-size-h2)}h3{font-size:var(--font-size-h3)}h4{font-size:var(--font-size-h4)}small,.font-small{font-size:var(--font-size-small)}button{width:60px;height:60px;border-radius:35px;border-style:solid;border-width:2px;background-color:var(--col-bg-btn);color:var(--col-primary-bg-btn);border-color:var(--col-bg-btn-darker);font-family:var(--headline-text-font);font-size:var(--font-size-h4);font-weight:700}button:hover,button:focus{outline:none;background-color:var(--col-bg-btn-lighter)}button:active{padding-top:3px;color:var(--col-primary-bg-btn);background-color:var(--col-bg-btn-darker);border-color:var(--col-bg-btn-darker)}.kiosk-btn-128{width:128px;height:128px}.kiosk-btn-32{width:32px;height:32px}.kiosk-dropdown-btn{box-sizing:content-box;border-radius:0;background-color:var(--col-bg-btn);border-color:var(--col-bg-btn-darker);color:var(--col-primary-bg-btn);height:30px;width:30px}.kiosk-dropdown-btn .drop-down-btn{float:left}.kiosk-dropdown-btn .caret{color:var(--col-primary-bg-btn);display:inline-block;width:0;height:0;margin-left:2px;vertical-align:middle;border-color:var(--col-primary-bg-btn);border-top:4px solid;border-right:4px solid transparent;border-left:4px solid transparent}button:disabled{opacity:.3}.modal-round-button,.modal-delete,.modal-close,.modal-cancel,.modal-back,.modal-next,.modal-ok,.modal-button{box-sizing:border-box;margin-left:25px;background-image:none;display:inline-block;font-style:normal;font-variant:normal;text-rendering:auto;-webkit-font-smoothing:antialiased;font-family:"Font Awesome 6 Free";font-weight:900;font-size:24px;line-height:24px;vertical-align:center;text-align:center}.modal-ok:after{content:var(--icon-bt-ok)}.modal-next:after{padding-left:2px;content:var(--icon-bt-next)}.modal-back:after{padding-right:2px;content:var(--icon-bt-back)}.modal-cancel:after{content:var(--icon-bt-cancel)}.modal-close:before{content:var(--icon-bt-close)}.modal-delete{background-color:var(--col-bg-alert);color:var(--col-primary-bg-alert)}.modal-delete:before{content:var(--icon-bt-trash)}.modal-delete:hover,.modal-delete:focus{border-color:var(--col-bg-alert);background-color:var(--col-bg-alert-lighter);background-size:75%}.modal-delete:active{border-color:var(--col-bg-alert);background-color:var(--col-bg-alert-darker);color:var(--col-primary-bg-alert)}.kiosk-rounded{border-radius:15px}.kiosk-shaded{box-shadow:2px 2px 10px #2e380394}.kiosk-margin-bottom{margin-bottom:1em}.flex-line-break{width:100%;height:0px}.kiosk-align-flex-end{align-items:flex-end}.kiosk-align-flex-start{align-items:flex-start}.full-background-bg-1{background:linear-gradient(to right bottom,var(--col-bg-1-darker),var(--col-bg-1-lighter));height:100%;width:100%}.small-list-button i{border-radius:25px;box-shadow:2px 2px 5px #2e380394}.small-list-button:hover{color:var(--col-bg-att)}.small-list-button:hover i{box-shadow:2px 2px 5px #2e380394}.small-list-button:active,.small-list-button:focus{color:var(--col-bg-ack);transform:translateY(5px)}.small-list-button:active i,.small-list-button:focus i{box-shadow:none}.dialog-radio-div{display:flex;flex-direction:row}.dialog-radio-div input[type=radio]{margin-right:.5em}.rainbow-loading{display:flex;justify-content:center;align-items:center;height:5px;width:100%;background-color:#000}.rainbow-loading.to-top{position:fixed;top:0;z-index:1000}.rainbow-loading-progress{height:5px;width:100%;border-radius:3px;background:linear-gradient(90deg,red,#ff0,#0f0 30%,#0ff 50%,#00f,#f0f 80%,red);background-size:200%;animation:move-gradient 2s ease-in infinite}@keyframes move-gradient{0%{background-position:0% 0%}to{background-position:-200% 0%}}.fa,.fas{font-family:"Font Awesome 6 Free";font-weight:900;font-style:normal}.fa-trash:before{content:""}.fa-view-grid:before{content:""}.fa-reload:before{content:""}.fa-view-list:before{content:""}.fa-camera:before{content:""}.fa-view-image:before{content:""}.fa-check:before{content:""}.fa-bug:before{content:""}.fa-lightbulb:before{content:""}.fa-query:before{content:""}.fa-footsteps{transform:rotate(270deg)}.fa-footsteps:before{content:""}.fa-next:before{content:""}.fa-prev:before{content:""}.fa-hide:before{content:""}.fa-circle-half-stroke:before{content:""}i{font-family:"Font Awesome 6 Free";font-style:normal;font-variant:normal;text-rendering:auto;-webkit-font-smoothing:antialiased;font-weight:900;font-size:.9em}div,p{font-family:var(--standard-text-font)}:host{--lumo-font-size-s: $font-size-standard;--lumo-font-family: $standard-text;--lumo-size-m: $font-size-standard;--lumo-contrast-10pct: rgba(0,0,0,0);--lumo-contrast-60pct: var(--col-accent-bg-1);--lumo-text-field-size: 1em;--lumo-font-size: var(--font-size-standard);--lumo-border-radius-l: 0;--lumo-border-radius-m: 0;--lumo-border-radius-s: 0}vaadin-combo-box{margin-left:calc(-1 * (.375em + var(--lumo-border-radius-m) / 4 - 1px));margin-right:calc(-1 * (.375em + var(--lumo-border-radius-m) / 4 - 1px));padding-top:0}vaadin-combo-box>input{--_lumo-text-field-overflow-mask-image: white;--lumo-text-field-size: 22px;background-color:#fff;max-height:var(--tz-combobox-max-height, 40);padding:var(--tz-combobox-horizontal-padding, 5px) var(--tz-combobox-vertical-padding, 5px)}vaadin-combo-box>input:disabled{background-color:var(--col-bg-1-lighter);--lumo-disabled-text-color: $col-primary-bg-1}vaadin-combo-box{font-family:var(--standard-text-font);font-size:var(--font-size-standard, 1rem);color:var(--col-primary-bg-1);background-color:var(--col-bg-2);width:100%;padding:0}vaadin-combo-box input:disabled,vaadin-combo-box textarea:disabled{background-color:var(--col-bg-1-lighter);color:var(--col-primary-bg-1);-webkit-text-fill-color:currentcolor;opacity:1}vaadin-combo-box::part(input-field){padding:0}';
var Bm = Object.defineProperty, Nm = Object.getOwnPropertyDescriptor, Hm = Object.getPrototypeOf, Vm = Reflect.get, tr = (s, r, e, t) => {
  for (var i = t > 1 ? void 0 : t ? Nm(r, e) : r, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (t ? o(r, e, i) : o(i)) || i);
  return t && i && Bm(r, e, i), i;
}, Um = (s, r, e) => Vm(Hm(s), e, r);
let bt = class extends Qi {
  // @property()
  // public timeZone: string;
  constructor() {
    super(), this.timeZones = [], this.value = null, this.text = "", this.disabled = !1, this.includeDeprecated = !1;
  }
  updated(s) {
    var r;
    if (super.updated(s), s.has("apiContext") && this.apiConnected(), s.has("value")) {
      console.log(`value updated to ${this.value}`);
      const e = (r = this.shadowRoot) == null ? void 0 : r.querySelector("vaadin-combo-box");
      e && !this.value && (e.value = "");
    }
  }
  // willUpdate(_changedProperties: any) {
  //     // if (_changedProperties.has("identifiers") || _changedProperties.has("recordTypeFilter")) {
  //     //     this.prepareIdentifiers();
  //     // }
  // }
  apiConnected() {
    console.log("fetching time zone information"), this.kioskTimeZones = new mm(this.apiContext), this.fetchFavouriteTimeZones();
  }
  fetchFavouriteTimeZones() {
    this.kioskTimeZones && this.kioskTimeZones.getFavouriteTimeZones(!1, !1).then((s) => {
      console.log(`about to add ${s.length} favourites`), this.addTimeZones(s, !0), this.kioskTimeZones && this.kioskTimeZones.getAllTimeZones(this.includeDeprecated).then((r) => {
        r && this.addTimeZones(r, !1);
      });
    });
  }
  addTimeZones(s, r = !1) {
    const e = s.filter((t) => r || t.favourite == 1).map((t) => ({ label: t.tz_long, value: t.id }));
    console.log(`kiosktzcombobox: added ${e.length} favourite timezones`), r || (e.push({ label: "------", value: -1 }), e.push(...s.filter((t) => t.favourite != 1).map((t) => ({ label: t.tz_long, value: t.id }))), console.log(`now we have ${e.length} overall timezones`)), this.timeZones = e;
  }
  timeZoneChanged(s) {
    const r = s.target;
    console.log(r.selectedItem), r.selectedItem && r.selectedItem.value > -1 ? (this.value = r.selectedItem.value, this.text = r.selectedItem.label) : (this.value = null, this.text = "", this.requestUpdate("value", -1)), s.preventDefault();
    const e = new CustomEvent("change");
    this.dispatchEvent(e);
  }
  onKeyUp(s) {
    (s.key === "Escape" || s.key === "Enter") && s.stopPropagation();
  }
  apiRender() {
    return mt`
            <vaadin-combo-box id="kiosk-tz-combo-box" ?disabled="${this.disabled || this.timeZones.length == 0}" .value=${this.value && this.value > -1 ? this.value : ""} @change=${this.timeZoneChanged} .items="${this.timeZones}" @keyup="${this.onKeyUp}"></vaadin-combo-box>
        `;
  }
};
bt.styles = Hr(Lm);
bt.properties = {
  ...Um(bt, bt, "properties")
};
tr([
  ei()
], bt.prototype, "timeZones", 2);
tr([
  et({ type: Number, reflect: !0 })
], bt.prototype, "value", 2);
tr([
  et({ type: String, reflect: !0 })
], bt.prototype, "text", 2);
tr([
  et({ attribute: !0, type: Boolean })
], bt.prototype, "disabled", 2);
tr([
  et({ attribute: !0, type: Boolean })
], bt.prototype, "includeDeprecated", 2);
bt = tr([
  ro("kiosk-tz-combo-box")
], bt);
const Wm = '*{padding:0;margin:0;border:0px;-webkit-user-select:none;user-select:none}p,div{-webkit-user-select:text;user-select:text}select{-webkit-user-select:none;user-select:none}.col-bg-body-lighter{background-color:var(--col-bg-body-lighter)}.col-bg-body{background-color:var(--col-bg-body)}.col-bg-body-darker{background-color:var(--col-bg-body-darker)}.col-bg-1-lighter{background-color:var(--col-bg-1-lighter)}.col-bg-1{background-color:var(--col-bg-1)}.col-bg-1-darker{background-color:var(--col-bg-1-darker)}.col-bg-1-input{background-color:var(--col-bg-1-input)}.col-primary-bg-1{background-color:var(--col-primary-bg-1)}.col-accent-bg-1{background-color:var(--col-accent-bg-1)}.col-success-bg-1{background-color:var(--col-success-bg-1)}.col-warning-bg-1{background-color:var(--col-warning-bg-1)}.col-error-bg-1{background-color:var(--col-error-bg-1)}.col-bg-2-lighter{background-color:var(--col-bg-2-lighter)}.col-bg-2{background-color:var(--col-bg-2)}.col-bg-2-darker{background-color:var(--col-bg-2-darker)}.col-bg-2-button{background-color:var(--col-bg-2-button)}.col-bg-2-input{background-color:var(--col-bg-2-input)}.col-primary-bg-2{background-color:var(--col-primary-bg-2)}.col-accent-bg-2{background-color:var(--col-accent-bg-2)}.col-success-bg-2{background-color:var(--col-success-bg-2)}.col-warning-bg-2{background-color:var(--col-warning-bg-2)}.col-error-bg-2{background-color:var(--col-error-bg-2)}.col-bg-3-lighter{background-color:var(--col-bg-3-lighter)}.col-bg-3{background-color:var(--col-bg-3)}.col-bg-3-darker{background-color:var(--col-bg-3-darker)}.col-bg-3-button{background-color:var(--col-bg-3-button)}.col-bg-3-input{background-color:var(--col-bg-3-input)}.col-primary-bg-3{background-color:var(--col-primary-bg-3)}.col-accent-bg-3{background-color:var(--col-accent-bg-3)}.col-success-bg-3{background-color:var(--col-success-bg-3)}.col-warning-bg-3{background-color:var(--col-warning-bg-3)}.col-error-bg-3{background-color:var(--col-error-bg-3)}.col-bg-ack-lighter{background-color:var(--col-bg-ack-lighter)}.col-bg-ack{background-color:var(--col-bg-ack)}.col-bg-ack-darker{background-color:var(--col-bg-ack-darker)}.col-primary-bg-ack{background-color:var(--col-primary-bg-ack)}.col-accent-bg-ack{background-color:var(--col-accent-bg-ack)}.col-bg-att-lighter{background-color:var(--col-bg-att-lighter)}.col-bg-att{background-color:var(--col-bg-att)}.col-bg-att-darker{background-color:var(--col-bg-att-darker)}.col-primary-bg-att{background-color:var(--col-primary-bg-att)}.col-accent-bg-att{background-color:var(--col-accent-bg-att)}.col-bg-alert-lighter{background-color:var(--col-bg-alert-lighter)}.col-bg-alert{background-color:var(--col-bg-alert)}.col-bg-alert-darker{background-color:var(--col-bg-alert-darker)}.col-primary-bg-alert{background-color:var(--col-primary-bg-alert)}.col-accent-bg-alert{background-color:var(--col-accent-bg-alert)}.col-bg-btn-lighter{background-color:var(--col-bg-btn-lighter)}.col-bg-btn{background-color:var(--col-bg-btn)}.col-bg-btn-darker{background-color:var(--col-bg-btn-darker)}.col-primary-bg-btn{background-color:var(--col-primary-bg-btn)}.col-accent-bg-btn{background-color:var(--col-accent-bg-btn)}.pattern-diagonal-stripes-sm{background:repeating-linear-gradient(45deg,transparent,transparent 10px,currentColor 10px,currentColor 20px)}.pattern-dots-lg{background-image:radial-gradient(currentColor 1.5px,transparent 1.5px);background-size:15px 15px}.pattern-dots-md{background-image:radial-gradient(currentColor 1px,transparent 1px);background-size:8px 8px}.pattern-dots-medium-dense{background-image:radial-gradient(currentColor .5px,transparent .5px);background-size:3px 3px}.pattern-dots-sm{background-image:radial-gradient(currentColor .5px,transparent .5px);background-size:5px 5px}.pattern-cross-dots-md,.imagelist-background{background-image:radial-gradient(currentColor .7px,transparent 1px),radial-gradient(currentColor .7px,transparent 1px);background-size:6.5px 6.5px;background-position:0 0,3.5px 3.5px}.imagelist-background{background-color:#fff9;background-blend-mode:overlay}label{font-family:var(--monospace-font);font-size:.9em}input,select{-webkit-user-select:text;-moz-user-select:text;-ms-user-select:text;box-sizing:border-box;border-radius:0;user-select:text;font-family:var(--standard-text-font);background-color:var(--col-bg-1-input);border:none;color:var(--col-primary-bg-1);padding:2px;margin-bottom:2px;outline:none}textarea{outline:none}input:not([type=radio],[type=checkbox]),select,textarea{width:100%}input:not([type=radio],[type=checkbox]):focus,select:focus,textarea:focus{margin-bottom:0;border-bottom:2px solid rgb(0,0,0)}h1{font-size:var(--font-size-h1)}h2{font-size:var(--font-size-h2)}h3{font-size:var(--font-size-h3)}h4{font-size:var(--font-size-h4)}small,.font-small{font-size:var(--font-size-small)}button{width:60px;height:60px;border-radius:35px;border-style:solid;border-width:2px;background-color:var(--col-bg-btn);color:var(--col-primary-bg-btn);border-color:var(--col-bg-btn-darker);font-family:var(--headline-text-font);font-size:var(--font-size-h4);font-weight:700}button:hover,button:focus{outline:none;background-color:var(--col-bg-btn-lighter)}button:active{padding-top:3px;color:var(--col-primary-bg-btn);background-color:var(--col-bg-btn-darker);border-color:var(--col-bg-btn-darker)}.kiosk-btn-128{width:128px;height:128px}.kiosk-btn-32{width:32px;height:32px}.kiosk-dropdown-btn{box-sizing:content-box;border-radius:0;background-color:var(--col-bg-btn);border-color:var(--col-bg-btn-darker);color:var(--col-primary-bg-btn);height:30px;width:30px}.kiosk-dropdown-btn .drop-down-btn{float:left}.kiosk-dropdown-btn .caret{color:var(--col-primary-bg-btn);display:inline-block;width:0;height:0;margin-left:2px;vertical-align:middle;border-color:var(--col-primary-bg-btn);border-top:4px solid;border-right:4px solid transparent;border-left:4px solid transparent}button:disabled{opacity:.3}.modal-round-button,.modal-delete,.modal-close,.modal-cancel,.modal-back,.modal-next,.modal-ok,.modal-button{box-sizing:border-box;margin-left:25px;background-image:none;display:inline-block;font-style:normal;font-variant:normal;text-rendering:auto;-webkit-font-smoothing:antialiased;font-family:"Font Awesome 6 Free";font-weight:900;font-size:24px;line-height:24px;vertical-align:center;text-align:center}.modal-ok:after{content:var(--icon-bt-ok)}.modal-next:after{padding-left:2px;content:var(--icon-bt-next)}.modal-back:after{padding-right:2px;content:var(--icon-bt-back)}.modal-cancel:after{content:var(--icon-bt-cancel)}.modal-close:before{content:var(--icon-bt-close)}.modal-delete{background-color:var(--col-bg-alert);color:var(--col-primary-bg-alert)}.modal-delete:before{content:var(--icon-bt-trash)}.modal-delete:hover,.modal-delete:focus{border-color:var(--col-bg-alert);background-color:var(--col-bg-alert-lighter);background-size:75%}.modal-delete:active{border-color:var(--col-bg-alert);background-color:var(--col-bg-alert-darker);color:var(--col-primary-bg-alert)}.kiosk-rounded{border-radius:15px}.kiosk-shaded{box-shadow:2px 2px 10px #2e380394}.kiosk-margin-bottom{margin-bottom:1em}.flex-line-break{width:100%;height:0px}.kiosk-align-flex-end{align-items:flex-end}.kiosk-align-flex-start{align-items:flex-start}.full-background-bg-1{background:linear-gradient(to right bottom,var(--col-bg-1-darker),var(--col-bg-1-lighter));height:100%;width:100%}.small-list-button i{border-radius:25px;box-shadow:2px 2px 5px #2e380394}.small-list-button:hover{color:var(--col-bg-att)}.small-list-button:hover i{box-shadow:2px 2px 5px #2e380394}.small-list-button:active,.small-list-button:focus{color:var(--col-bg-ack);transform:translateY(5px)}.small-list-button:active i,.small-list-button:focus i{box-shadow:none}.dialog-radio-div{display:flex;flex-direction:row}.dialog-radio-div input[type=radio]{margin-right:.5em}.rainbow-loading{display:flex;justify-content:center;align-items:center;height:5px;width:100%;background-color:#000}.rainbow-loading.to-top{position:fixed;top:0;z-index:1000}.rainbow-loading-progress{height:5px;width:100%;border-radius:3px;background:linear-gradient(90deg,red,#ff0,#0f0 30%,#0ff 50%,#00f,#f0f 80%,red);background-size:200%;animation:move-gradient 2s ease-in infinite}@keyframes move-gradient{0%{background-position:0% 0%}to{background-position:-200% 0%}}.fa,.fas{font-family:"Font Awesome 6 Free";font-weight:900;font-style:normal}.fa-trash:before{content:""}.fa-view-grid:before{content:""}.fa-reload:before{content:""}.fa-view-list:before{content:""}.fa-camera:before{content:""}.fa-view-image:before{content:""}.fa-check:before{content:""}.fa-bug:before{content:""}.fa-lightbulb:before{content:""}.fa-query:before{content:""}.fa-footsteps{transform:rotate(270deg)}.fa-footsteps:before{content:""}.fa-next:before{content:""}.fa-prev:before{content:""}.fa-hide:before{content:""}.fa-circle-half-stroke:before{content:""}i{font-family:"Font Awesome 6 Free";font-style:normal;font-variant:normal;text-rendering:auto;-webkit-font-smoothing:antialiased;font-weight:900;font-size:.9em}:host{position:fixed;top:0;left:0;height:100dvh;max-width:100dvw;z-index:100;overflow-y:auto;overflow-x:hidden;background-color:var(--col-bg-body-dm)}.kiosk-lightbox-error{position:absolute;font-size:var(--font-size-standard);font-family:var(--standard-text) sans-serif;font-weight:700;color:var(--col-primary-bg-alert);display:grid;place-items:center;z-index:100;background:var(--col-bg-alert);top:50%;margin-left:50vw;width:400px;height:10em;transform:translate(-50%) translateY(-50%)}.kiosk-lightbox-outer{top:0;left:0}.kiosk-lightbox-outer.background-dark{background:var(--col-bg-body-dm)}.kiosk-lightbox-outer.background-light{background:var(--col-bg-body)}.kiosk-lightbox-inner{display:block;right:0;left:auto;width:calc(100dvw - 2rem)}.hide-ui{visibility:hidden}.kiosk-lightbox-viewer{width:100cqw}.kiosk-lightbox-viewer.expanded{height:75dvh}.kiosk-lightbox-viewer.collapsed{height:calc(100dvh - 1rem)}.kiosk-lightbox-viewer.collapsed.nodata{height:calc(100dvh - 2rem)}.kiosk-lightbox-data{position:relative;z-index:10;transform:translateY(-25px);background-color:#fff;width:100%;min-height:calc(25dvh - 2rem)}.kiosk-lightbox-splitter{display:flex;place-content:center;width:100%;background-color:var(--col-bg-body-dm);color:var(--col-primary-bg-body-dm)}.kiosk-lightbox-splitter i{font-size:25px}.kiosk-lightbox-buttons{display:flex;position:fixed;right:3rem;left:auto;top:1em;z-index:2}.kiosk-lightbox-button{border-radius:24px;height:2rem;width:2rem;background-color:var(--col-bg-btn);box-shadow:0 0 5px 2px var(--col-bg-att-lighter);color:var(--col-primary-bg-btn);text-align:center}.kiosk-lightbox-button i{line-height:2rem}.kiosk-lightbox-button:hover{background-color:var(--col-bg-att);box-shadow:0 0 5px 2px var(--col-bg-att-darker);color:var(--col-primary-bg-att)}.kiosk-lightbox-button:active{background-color:var(--col-bg-ack);box-shadow:0 0 5px 2px var(--col-bg-ack-darker);color:var(--col-primary-bg-ack)}.kiosk-lightbox-button+.kiosk-lightbox-button{margin-left:1rem}.kiosk-lightbox-button:last-child{margin-left:2rem}.kiosk-lightbox-button:first-child{margin-right:1rem}';
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const jm = bh(class extends yh {
  constructor(s) {
    var r;
    if (super(s), s.type !== aa.ATTRIBUTE || s.name !== "class" || ((r = s.strings) == null ? void 0 : r.length) > 2) throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.");
  }
  render(s) {
    return " " + Object.keys(s).filter((r) => s[r]).join(" ") + " ";
  }
  update(s, [r]) {
    var t, i;
    if (this.st === void 0) {
      this.st = /* @__PURE__ */ new Set(), s.strings !== void 0 && (this.nt = new Set(s.strings.join(" ").split(/\s/).filter((n) => n !== "")));
      for (const n in r) r[n] && !((t = this.nt) != null && t.has(n)) && this.st.add(n);
      return this.render(r);
    }
    const e = s.element.classList;
    for (const n of this.st) n in r || (e.remove(n), this.st.delete(n));
    for (const n in r) {
      const o = !!r[n];
      o === this.st.has(n) || (i = this.nt) != null && i.has(n) || (o ? (e.add(n), this.st.add(n)) : (e.remove(n), this.st.delete(n)));
    }
    return xi;
  }
});
var zn = { exports: {} }, Gm = zn.exports, Kl;
function qm() {
  return Kl || (Kl = 1, function(s) {
    //! openseadragon 5.0.1
    //! Built on 2024-12-09
    //! Git commit: v5.0.1-0-480de92d
    //! http://openseadragon.github.io
    //! License: http://openseadragon.github.io/license/
    function r(e) {
      return new r.Viewer(e);
    }
    (function(e) {
      e.version = {
        versionStr: "5.0.1",
        major: parseInt("5", 10),
        minor: parseInt("0", 10),
        revision: parseInt("1", 10)
      };
      var t = {
        "[object Boolean]": "boolean",
        "[object Number]": "number",
        "[object String]": "string",
        "[object Function]": "function",
        "[object AsyncFunction]": "function",
        "[object Promise]": "promise",
        "[object Array]": "array",
        "[object Date]": "date",
        "[object RegExp]": "regexp",
        "[object Object]": "object"
      }, i = Object.prototype.toString, n = Object.prototype.hasOwnProperty;
      e.isFunction = function(o) {
        return e.type(o) === "function";
      }, e.isArray = Array.isArray || function(o) {
        return e.type(o) === "array";
      }, e.isWindow = function(o) {
        return o && typeof o == "object" && "setInterval" in o;
      }, e.type = function(o) {
        return o == null ? String(o) : t[i.call(o)] || "object";
      }, e.isPlainObject = function(o) {
        if (!o || r.type(o) !== "object" || o.nodeType || e.isWindow(o) || o.constructor && !n.call(o, "constructor") && !n.call(o.constructor.prototype, "isPrototypeOf"))
          return !1;
        var a;
        for (var l in o)
          a = l;
        return a === void 0 || n.call(o, a);
      }, e.isEmptyObject = function(o) {
        for (var a in o)
          return !1;
        return !0;
      }, e.freezeObject = function(o) {
        return Object.freeze ? e.freezeObject = Object.freeze : e.freezeObject = function(a) {
          return a;
        }, e.freezeObject(o);
      }, e.supportsCanvas = function() {
        var o = document.createElement("canvas");
        return !!(e.isFunction(o.getContext) && o.getContext("2d"));
      }(), e.isCanvasTainted = function(o) {
        var a = !1;
        try {
          o.getContext("2d").getImageData(0, 0, 1, 1);
        } catch {
          a = !0;
        }
        return a;
      }, e.supportsAddEventListener = function() {
        return !!(document.documentElement.addEventListener && document.addEventListener);
      }(), e.supportsRemoveEventListener = function() {
        return !!(document.documentElement.removeEventListener && document.removeEventListener);
      }(), e.supportsEventListenerOptions = function() {
        var o = 0;
        if (e.supportsAddEventListener)
          try {
            var a = {
              get capture() {
                return o++, !1;
              },
              get once() {
                return o++, !1;
              },
              get passive() {
                return o++, !1;
              }
            };
            window.addEventListener("test", null, a), window.removeEventListener("test", null, a);
          } catch {
            o = 0;
          }
        return o >= 3;
      }(), e.getCurrentPixelDensityRatio = function() {
        if (e.supportsCanvas) {
          var o = document.createElement("canvas").getContext("2d"), a = window.devicePixelRatio || 1, l = o.webkitBackingStorePixelRatio || o.mozBackingStorePixelRatio || o.msBackingStorePixelRatio || o.oBackingStorePixelRatio || o.backingStorePixelRatio || 1;
          return Math.max(a, 1) / l;
        } else
          return 1;
      }, e.pixelDensityRatio = e.getCurrentPixelDensityRatio();
    })(r), function(e) {
      e.extend = function() {
        var l, h, d, f, g, w, C = arguments[0] || {}, E = arguments.length, A = !1, I = 1;
        for (typeof C == "boolean" && (A = C, C = arguments[1] || {}, I = 2), typeof C != "object" && !r.isFunction(C) && (C = {}), E === I && (C = this, --I); I < E; I++)
          if (l = arguments[I], l !== null || l !== void 0)
            for (h in l) {
              var V = Object.getOwnPropertyDescriptor(l, h);
              if (V !== void 0) {
                if (V.get || V.set) {
                  Object.defineProperty(C, h, V);
                  continue;
                }
                f = V.value;
              } else {
                e.console.warn('Could not copy inherited property "' + h + '".');
                continue;
              }
              C !== f && (A && f && (r.isPlainObject(f) || (g = r.isArray(f))) ? (d = C[h], g ? (g = !1, w = d && r.isArray(d) ? d : []) : w = d && r.isPlainObject(d) ? d : {}, C[h] = r.extend(A, w, f)) : f !== void 0 && (C[h] = f));
            }
        return C;
      };
      var t = function() {
        if (typeof navigator != "object")
          return !1;
        var l = navigator.userAgent;
        return typeof l != "string" ? !1 : l.indexOf("iPhone") !== -1 || l.indexOf("iPad") !== -1 || l.indexOf("iPod") !== -1;
      };
      e.extend(
        e,
        /** @lends OpenSeadragon */
        {
          /**
           * The default values for the optional settings documented at {@link OpenSeadragon.Options}.
           * @static
           * @type {Object}
           */
          DEFAULT_SETTINGS: {
            //DATA SOURCE DETAILS
            xmlPath: null,
            tileSources: null,
            tileHost: null,
            initialPage: 0,
            crossOriginPolicy: !1,
            ajaxWithCredentials: !1,
            loadTilesWithAjax: !1,
            ajaxHeaders: {},
            splitHashDataForPost: !1,
            //PAN AND ZOOM SETTINGS AND CONSTRAINTS
            panHorizontal: !0,
            panVertical: !0,
            constrainDuringPan: !1,
            wrapHorizontal: !1,
            wrapVertical: !1,
            visibilityRatio: 0.5,
            //-> how much of the viewer can be negative space
            minPixelRatio: 0.5,
            //->closer to 0 draws tiles meant for a higher zoom at this zoom
            defaultZoomLevel: 0,
            minZoomLevel: null,
            maxZoomLevel: null,
            homeFillsViewer: !1,
            //UI RESPONSIVENESS AND FEEL
            clickTimeThreshold: 300,
            clickDistThreshold: 5,
            dblClickTimeThreshold: 300,
            dblClickDistThreshold: 20,
            springStiffness: 6.5,
            animationTime: 1.2,
            gestureSettingsMouse: {
              dragToPan: !0,
              scrollToZoom: !0,
              clickToZoom: !0,
              dblClickToZoom: !1,
              dblClickDragToZoom: !1,
              pinchToZoom: !1,
              zoomToRefPoint: !0,
              flickEnabled: !1,
              flickMinSpeed: 120,
              flickMomentum: 0.25,
              pinchRotate: !1
            },
            gestureSettingsTouch: {
              dragToPan: !0,
              scrollToZoom: !1,
              clickToZoom: !1,
              dblClickToZoom: !0,
              dblClickDragToZoom: !0,
              pinchToZoom: !0,
              zoomToRefPoint: !0,
              flickEnabled: !0,
              flickMinSpeed: 120,
              flickMomentum: 0.25,
              pinchRotate: !1
            },
            gestureSettingsPen: {
              dragToPan: !0,
              scrollToZoom: !1,
              clickToZoom: !0,
              dblClickToZoom: !1,
              dblClickDragToZoom: !1,
              pinchToZoom: !1,
              zoomToRefPoint: !0,
              flickEnabled: !1,
              flickMinSpeed: 120,
              flickMomentum: 0.25,
              pinchRotate: !1
            },
            gestureSettingsUnknown: {
              dragToPan: !0,
              scrollToZoom: !1,
              clickToZoom: !1,
              dblClickToZoom: !0,
              dblClickDragToZoom: !1,
              pinchToZoom: !0,
              zoomToRefPoint: !0,
              flickEnabled: !0,
              flickMinSpeed: 120,
              flickMomentum: 0.25,
              pinchRotate: !1
            },
            zoomPerClick: 2,
            zoomPerScroll: 1.2,
            zoomPerDblClickDrag: 1.2,
            zoomPerSecond: 1,
            blendTime: 0,
            alwaysBlend: !1,
            autoHideControls: !0,
            immediateRender: !1,
            minZoomImageRatio: 0.9,
            //-> closer to 0 allows zoom out to infinity
            maxZoomPixelRatio: 1.1,
            //-> higher allows 'over zoom' into pixels
            smoothTileEdgesMinZoom: 1.1,
            //-> higher than maxZoomPixelRatio disables it
            iOSDevice: t(),
            pixelsPerWheelLine: 40,
            pixelsPerArrowPress: 40,
            autoResize: !0,
            preserveImageSizeOnResize: !1,
            // requires autoResize=true
            minScrollDeltaTime: 50,
            rotationIncrement: 90,
            maxTilesPerFrame: 1,
            //DEFAULT CONTROL SETTINGS
            showSequenceControl: !0,
            //SEQUENCE
            sequenceControlAnchor: null,
            //SEQUENCE
            preserveViewport: !1,
            //SEQUENCE
            preserveOverlays: !1,
            //SEQUENCE
            navPrevNextWrap: !1,
            //SEQUENCE
            showNavigationControl: !0,
            //ZOOM/HOME/FULL/ROTATION
            navigationControlAnchor: null,
            //ZOOM/HOME/FULL/ROTATION
            showZoomControl: !0,
            //ZOOM
            showHomeControl: !0,
            //HOME
            showFullPageControl: !0,
            //FULL
            showRotationControl: !1,
            //ROTATION
            showFlipControl: !1,
            //FLIP
            controlsFadeDelay: 2e3,
            //ZOOM/HOME/FULL/SEQUENCE
            controlsFadeLength: 1500,
            //ZOOM/HOME/FULL/SEQUENCE
            mouseNavEnabled: !0,
            //GENERAL MOUSE INTERACTIVITY
            //VIEWPORT NAVIGATOR SETTINGS
            showNavigator: !1,
            navigatorElement: null,
            navigatorId: null,
            navigatorPosition: null,
            navigatorSizeRatio: 0.2,
            navigatorMaintainSizeRatio: !1,
            navigatorTop: null,
            navigatorLeft: null,
            navigatorHeight: null,
            navigatorWidth: null,
            navigatorAutoResize: !0,
            navigatorAutoFade: !0,
            navigatorRotate: !0,
            navigatorBackground: "#000",
            navigatorOpacity: 0.8,
            navigatorBorderColor: "#555",
            navigatorDisplayRegionColor: "#900",
            // INITIAL ROTATION
            degrees: 0,
            // INITIAL FLIP STATE
            flipped: !1,
            overlayPreserveContentDirection: !0,
            // APPEARANCE
            opacity: 1,
            // to be passed into each TiledImage
            compositeOperation: null,
            // to be passed into each TiledImage
            // DRAWER SETTINGS
            drawer: ["webgl", "canvas", "html"],
            // prefer using webgl, then canvas (i.e. context2d), then fallback to html
            drawerOptions: {
              webgl: {},
              canvas: {},
              html: {},
              custom: {}
            },
            // TILED IMAGE SETTINGS
            preload: !1,
            // to be passed into each TiledImage
            imageSmoothingEnabled: !0,
            // to be passed into each TiledImage
            placeholderFillStyle: null,
            // to be passed into each TiledImage
            subPixelRoundingForTransparency: null,
            // to be passed into each TiledImage
            //REFERENCE STRIP SETTINGS
            showReferenceStrip: !1,
            referenceStripScroll: "horizontal",
            referenceStripElement: null,
            referenceStripHeight: null,
            referenceStripWidth: null,
            referenceStripPosition: "BOTTOM_LEFT",
            referenceStripSizeRatio: 0.2,
            //COLLECTION VISUALIZATION SETTINGS
            collectionRows: 3,
            //or columns depending on layout
            collectionColumns: 0,
            //columns in horizontal layout, rows in vertical layout
            collectionLayout: "horizontal",
            //vertical
            collectionMode: !1,
            collectionTileSize: 800,
            collectionTileMargin: 80,
            //PERFORMANCE SETTINGS
            imageLoaderLimit: 0,
            maxImageCacheCount: 200,
            timeout: 3e4,
            tileRetryMax: 0,
            tileRetryDelay: 2500,
            //INTERFACE RESOURCE SETTINGS
            prefixUrl: "/images/",
            navImages: {
              zoomIn: {
                REST: "zoomin_rest.png",
                GROUP: "zoomin_grouphover.png",
                HOVER: "zoomin_hover.png",
                DOWN: "zoomin_pressed.png"
              },
              zoomOut: {
                REST: "zoomout_rest.png",
                GROUP: "zoomout_grouphover.png",
                HOVER: "zoomout_hover.png",
                DOWN: "zoomout_pressed.png"
              },
              home: {
                REST: "home_rest.png",
                GROUP: "home_grouphover.png",
                HOVER: "home_hover.png",
                DOWN: "home_pressed.png"
              },
              fullpage: {
                REST: "fullpage_rest.png",
                GROUP: "fullpage_grouphover.png",
                HOVER: "fullpage_hover.png",
                DOWN: "fullpage_pressed.png"
              },
              rotateleft: {
                REST: "rotateleft_rest.png",
                GROUP: "rotateleft_grouphover.png",
                HOVER: "rotateleft_hover.png",
                DOWN: "rotateleft_pressed.png"
              },
              rotateright: {
                REST: "rotateright_rest.png",
                GROUP: "rotateright_grouphover.png",
                HOVER: "rotateright_hover.png",
                DOWN: "rotateright_pressed.png"
              },
              flip: {
                // Flip icon designed by Yaroslav Samoylov from the Noun Project and modified by Nelson Campos ncampos@criteriamarathon.com, https://thenounproject.com/term/flip/136289/
                REST: "flip_rest.png",
                GROUP: "flip_grouphover.png",
                HOVER: "flip_hover.png",
                DOWN: "flip_pressed.png"
              },
              previous: {
                REST: "previous_rest.png",
                GROUP: "previous_grouphover.png",
                HOVER: "previous_hover.png",
                DOWN: "previous_pressed.png"
              },
              next: {
                REST: "next_rest.png",
                GROUP: "next_grouphover.png",
                HOVER: "next_hover.png",
                DOWN: "next_pressed.png"
              }
            },
            //DEVELOPER SETTINGS
            debugMode: !1,
            debugGridColor: ["#437AB2", "#1B9E77", "#D95F02", "#7570B3", "#E7298A", "#66A61E", "#E6AB02", "#A6761D", "#666666"],
            silenceMultiImageWarnings: !1
          },
          /**
           * Returns a function which invokes the method as if it were a method belonging to the object.
           * @function
           * @param {Object} object
           * @param {Function} method
           * @returns {Function}
           */
          delegate: function(l, h) {
            return function() {
              var d = arguments;
              return d === void 0 && (d = []), h.apply(l, d);
            };
          },
          /**
           * An enumeration of Browser vendors.
           * @static
           * @type {Object}
           * @property {Number} UNKNOWN
           * @property {Number} IE
           * @property {Number} FIREFOX
           * @property {Number} SAFARI
           * @property {Number} CHROME
           * @property {Number} OPERA
           * @property {Number} EDGE
           * @property {Number} CHROMEEDGE
           */
          BROWSERS: {
            UNKNOWN: 0,
            IE: 1,
            FIREFOX: 2,
            SAFARI: 3,
            CHROME: 4,
            OPERA: 5,
            EDGE: 6,
            CHROMEEDGE: 7
          },
          /**
           * An enumeration of when subpixel rounding should occur.
           * @static
           * @type {Object}
           * @property {Number} NEVER Never apply subpixel rounding for transparency.
           * @property {Number} ONLY_AT_REST Do not apply subpixel rounding for transparency during animation (panning, zoom, rotation) and apply it once animation is over.
           * @property {Number} ALWAYS Apply subpixel rounding for transparency during animation and when animation is over.
           */
          SUBPIXEL_ROUNDING_OCCURRENCES: {
            NEVER: 0,
            ONLY_AT_REST: 1,
            ALWAYS: 2
          },
          /**
           * Keep track of which {@link Viewer}s have been created.
           * - Key: {@link Element} to which a Viewer is attached.
           * - Value: {@link Viewer} of the element defined by the key.
           * @private
           * @static
           * @type {Object}
           */
          _viewers: /* @__PURE__ */ new Map(),
          /**
            * Returns the {@link Viewer} attached to a given DOM element. If there is
            * no viewer attached to the provided element, undefined is returned.
            * @function
            * @param {String|Element} element Accepts an id or element.
            * @returns {Viewer} The viewer attached to the given element, or undefined.
            */
          getViewer: function(l) {
            return e._viewers.get(this.getElement(l));
          },
          /**
           * Returns a DOM Element for the given id or element.
           * @function
           * @param {String|Element} element Accepts an id or element.
           * @returns {Element} The element with the given id, null, or the element itself.
           */
          getElement: function(l) {
            return typeof l == "string" && (l = document.getElementById(l)), l;
          },
          /**
           * Determines the position of the upper-left corner of the element.
           * @function
           * @param {Element|String} element - the element we want the position for.
           * @returns {OpenSeadragon.Point} - the position of the upper left corner of the element.
           */
          getElementPosition: function(l) {
            var h = new e.Point(), d, f;
            for (l = e.getElement(l), d = e.getElementStyle(l).position === "fixed", f = a(l, d); f; )
              h.x += l.offsetLeft, h.y += l.offsetTop, d && (h = h.plus(e.getPageScroll())), l = f, d = e.getElementStyle(l).position === "fixed", f = a(l, d);
            return h;
          },
          /**
           * Determines the position of the upper-left corner of the element adjusted for current page and/or element scroll.
           * @function
           * @param {Element|String} element - the element we want the position for.
           * @returns {OpenSeadragon.Point} - the position of the upper left corner of the element adjusted for current page and/or element scroll.
           */
          getElementOffset: function(l) {
            l = e.getElement(l);
            var h = l && l.ownerDocument, d, f, g = { top: 0, left: 0 };
            return h ? (d = h.documentElement, typeof l.getBoundingClientRect < "u" && (g = l.getBoundingClientRect()), f = h === h.window ? h : h.nodeType === 9 ? h.defaultView || h.parentWindow : !1, new e.Point(
              g.left + (f.pageXOffset || d.scrollLeft) - (d.clientLeft || 0),
              g.top + (f.pageYOffset || d.scrollTop) - (d.clientTop || 0)
            )) : new e.Point();
          },
          /**
           * Determines the height and width of the given element.
           * @function
           * @param {Element|String} element
           * @returns {OpenSeadragon.Point}
           */
          getElementSize: function(l) {
            return l = e.getElement(l), new e.Point(
              l.clientWidth,
              l.clientHeight
            );
          },
          /**
           * Returns the CSSStyle object for the given element.
           * @function
           * @param {Element|String} element
           * @returns {CSSStyle}
           */
          getElementStyle: document.documentElement.currentStyle ? function(l) {
            return l = e.getElement(l), l.currentStyle;
          } : function(l) {
            return l = e.getElement(l), window.getComputedStyle(l, "");
          },
          /**
           * Returns the property with the correct vendor prefix appended.
           * @param {String} property the property name
           * @returns {String} the property with the correct prefix or null if not
           * supported.
           */
          getCssPropertyWithVendorPrefix: function(l) {
            var h = {};
            return e.getCssPropertyWithVendorPrefix = function(d) {
              if (h[d] !== void 0)
                return h[d];
              var f = document.createElement("div").style, g = null;
              if (f[d] !== void 0)
                g = d;
              else
                for (var w = [
                  "Webkit",
                  "Moz",
                  "MS",
                  "O",
                  "webkit",
                  "moz",
                  "ms",
                  "o"
                ], C = e.capitalizeFirstLetter(d), E = 0; E < w.length; E++) {
                  var A = w[E] + C;
                  if (f[A] !== void 0) {
                    g = A;
                    break;
                  }
                }
              return h[d] = g, g;
            }, e.getCssPropertyWithVendorPrefix(l);
          },
          /**
           * Capitalizes the first letter of a string
           * @param {String} string
           * @returns {String} The string with the first letter capitalized
           */
          capitalizeFirstLetter: function(l) {
            return l.charAt(0).toUpperCase() + l.slice(1);
          },
          /**
           * Compute the modulo of a number but makes sure to always return
           * a positive value (also known as Euclidean modulo).
           * @param {Number} number the number to compute the modulo of
           * @param {Number} modulo the modulo
           * @returns {Number} the result of the modulo of number
           */
          positiveModulo: function(l, h) {
            var d = l % h;
            return d < 0 && (d += h), d;
          },
          /**
           * Determines if a point is within the bounding rectangle of the given element (hit-test).
           * @function
           * @param {Element|String} element
           * @param {OpenSeadragon.Point} point
           * @returns {Boolean}
           */
          pointInElement: function(l, h) {
            l = e.getElement(l);
            var d = e.getElementOffset(l), f = e.getElementSize(l);
            return h.x >= d.x && h.x < d.x + f.x && h.y < d.y + f.y && h.y >= d.y;
          },
          /**
           * Gets the position of the mouse on the screen for a given event.
           * @function
           * @param {Event} [event]
           * @returns {OpenSeadragon.Point}
           */
          getMousePosition: function(l) {
            if (typeof l.pageX == "number")
              e.getMousePosition = function(h) {
                var d = new e.Point();
                return d.x = h.pageX, d.y = h.pageY, d;
              };
            else if (typeof l.clientX == "number")
              e.getMousePosition = function(h) {
                var d = new e.Point();
                return d.x = h.clientX + document.body.scrollLeft + document.documentElement.scrollLeft, d.y = h.clientY + document.body.scrollTop + document.documentElement.scrollTop, d;
              };
            else
              throw new Error(
                "Unknown event mouse position, no known technique."
              );
            return e.getMousePosition(l);
          },
          /**
           * Determines the page's current scroll position.
           * @function
           * @returns {OpenSeadragon.Point}
           */
          getPageScroll: function() {
            var l = document.documentElement || {}, h = document.body || {};
            if (typeof window.pageXOffset == "number")
              e.getPageScroll = function() {
                return new e.Point(
                  window.pageXOffset,
                  window.pageYOffset
                );
              };
            else if (h.scrollLeft || h.scrollTop)
              e.getPageScroll = function() {
                return new e.Point(
                  document.body.scrollLeft,
                  document.body.scrollTop
                );
              };
            else if (l.scrollLeft || l.scrollTop)
              e.getPageScroll = function() {
                return new e.Point(
                  document.documentElement.scrollLeft,
                  document.documentElement.scrollTop
                );
              };
            else
              return new e.Point(0, 0);
            return e.getPageScroll();
          },
          /**
           * Set the page scroll position.
           * @function
           * @returns {OpenSeadragon.Point}
           */
          setPageScroll: function(l) {
            if (typeof window.scrollTo < "u")
              e.setPageScroll = function(f) {
                window.scrollTo(f.x, f.y);
              };
            else {
              var h = e.getPageScroll();
              if (h.x === l.x && h.y === l.y)
                return;
              document.body.scrollLeft = l.x, document.body.scrollTop = l.y;
              var d = e.getPageScroll();
              if (d.x !== h.x && d.y !== h.y) {
                e.setPageScroll = function(f) {
                  document.body.scrollLeft = f.x, document.body.scrollTop = f.y;
                };
                return;
              }
              if (document.documentElement.scrollLeft = l.x, document.documentElement.scrollTop = l.y, d = e.getPageScroll(), d.x !== h.x && d.y !== h.y) {
                e.setPageScroll = function(f) {
                  document.documentElement.scrollLeft = f.x, document.documentElement.scrollTop = f.y;
                };
                return;
              }
              e.setPageScroll = function(f) {
              };
            }
            e.setPageScroll(l);
          },
          /**
           * Determines the size of the browsers window.
           * @function
           * @returns {OpenSeadragon.Point}
           */
          getWindowSize: function() {
            var l = document.documentElement || {}, h = document.body || {};
            if (typeof window.innerWidth == "number")
              e.getWindowSize = function() {
                return new e.Point(
                  window.innerWidth,
                  window.innerHeight
                );
              };
            else if (l.clientWidth || l.clientHeight)
              e.getWindowSize = function() {
                return new e.Point(
                  document.documentElement.clientWidth,
                  document.documentElement.clientHeight
                );
              };
            else if (h.clientWidth || h.clientHeight)
              e.getWindowSize = function() {
                return new e.Point(
                  document.body.clientWidth,
                  document.body.clientHeight
                );
              };
            else
              throw new Error("Unknown window size, no known technique.");
            return e.getWindowSize();
          },
          /**
           * Wraps the given element in a nest of divs so that the element can
           * be easily centered using CSS tables
           * @function
           * @param {Element|String} element
           * @returns {Element} outermost wrapper element
           */
          makeCenteredNode: function(l) {
            l = e.getElement(l);
            var h = [
              e.makeNeutralElement("div"),
              e.makeNeutralElement("div"),
              e.makeNeutralElement("div")
            ];
            return e.extend(h[0].style, {
              display: "table",
              height: "100%",
              width: "100%"
            }), e.extend(h[1].style, {
              display: "table-row"
            }), e.extend(h[2].style, {
              display: "table-cell",
              verticalAlign: "middle",
              textAlign: "center"
            }), h[0].appendChild(h[1]), h[1].appendChild(h[2]), h[2].appendChild(l), h[0];
          },
          /**
           * Creates an easily positionable element of the given type that therefor
           * serves as an excellent container element.
           * @function
           * @param {String} tagName
           * @returns {Element}
           */
          makeNeutralElement: function(l) {
            var h = document.createElement(l), d = h.style;
            return d.background = "transparent none", d.border = "none", d.margin = "0px", d.padding = "0px", d.position = "static", h;
          },
          /**
           * Returns the current milliseconds, using Date.now() if available
           * @function
           */
          now: function() {
            return Date.now ? e.now = Date.now : e.now = function() {
              return (/* @__PURE__ */ new Date()).getTime();
            }, e.now();
          },
          /**
           * Ensures an image is loaded correctly to support alpha transparency.
           * @function
           * @param {String} src
           * @returns {Element}
           */
          makeTransparentImage: function(l) {
            var h = e.makeNeutralElement("img");
            return h.src = l, h;
          },
          /**
           * Sets the opacity of the specified element.
           * @function
           * @param {Element|String} element
           * @param {Number} opacity
           * @param {Boolean} [usesAlpha]
           */
          setElementOpacity: function(l, h, d) {
            var f, g;
            l = e.getElement(l), d && !e.Browser.alpha && (h = Math.round(h)), e.Browser.opacity ? l.style.opacity = h < 1 ? h : "" : h < 1 ? (f = Math.round(100 * h), g = "alpha(opacity=" + f + ")", l.style.filter = g) : l.style.filter = "";
          },
          /**
           * Sets the specified element's touch-action style attribute to 'none'.
           * @function
           * @param {Element|String} element
           */
          setElementTouchActionNone: function(l) {
            l = e.getElement(l), typeof l.style.touchAction < "u" ? l.style.touchAction = "none" : typeof l.style.msTouchAction < "u" && (l.style.msTouchAction = "none");
          },
          /**
           * Sets the specified element's pointer-events style attribute to the passed value.
           * @function
           * @param {Element|String} element
           * @param {String} value
           */
          setElementPointerEvents: function(l, h) {
            l = e.getElement(l), typeof l.style < "u" && typeof l.style.pointerEvents < "u" && (l.style.pointerEvents = h);
          },
          /**
           * Sets the specified element's pointer-events style attribute to 'none'.
           * @function
           * @param {Element|String} element
           */
          setElementPointerEventsNone: function(l) {
            e.setElementPointerEvents(l, "none");
          },
          /**
           * Add the specified CSS class to the element if not present.
           * @function
           * @param {Element|String} element
           * @param {String} className
           */
          addClass: function(l, h) {
            l = e.getElement(l), l.className ? (" " + l.className + " ").indexOf(" " + h + " ") === -1 && (l.className += " " + h) : l.className = h;
          },
          /**
           * Find the first index at which an element is found in an array or -1
           * if not present.
           *
           * Code taken and adapted from
           * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf#Compatibility
           *
           * @function
           * @param {Array} array The array from which to find the element
           * @param {Object} searchElement The element to find
           * @param {Number} [fromIndex=0] Index to start research.
           * @returns {Number} The index of the element in the array.
           */
          indexOf: function(l, h, d) {
            return Array.prototype.indexOf ? this.indexOf = function(f, g, w) {
              return f.indexOf(g, w);
            } : this.indexOf = function(f, g, w) {
              var C, E = w || 0, A;
              if (!f)
                throw new TypeError();
              if (A = f.length, A === 0 || E >= A)
                return -1;
              for (E < 0 && (E = A - Math.abs(E)), C = E; C < A; C++)
                if (f[C] === g)
                  return C;
              return -1;
            }, this.indexOf(l, h, d);
          },
          /**
           * Remove the specified CSS class from the element.
           * @function
           * @param {Element|String} element
           * @param {String} className
           */
          removeClass: function(l, h) {
            var d, f = [], g;
            for (l = e.getElement(l), d = l.className.split(/\s+/), g = 0; g < d.length; g++)
              d[g] && d[g] !== h && f.push(d[g]);
            l.className = f.join(" ");
          },
          /**
           * Convert passed addEventListener() options to boolean or options object,
           * depending on browser support.
           * @function
           * @param {Boolean|Object} [options] Boolean useCapture, or if [supportsEventListenerOptions]{@link OpenSeadragon.supportsEventListenerOptions}, can be an object
           * @param {Boolean} [options.capture]
           * @param {Boolean} [options.passive]
           * @param {Boolean} [options.once]
           * @returns {String} The protocol (http:, https:, file:, ftp: ...)
           */
          normalizeEventListenerOptions: function(l) {
            var h;
            return typeof l < "u" ? typeof l == "boolean" ? h = e.supportsEventListenerOptions ? { capture: l } : l : h = e.supportsEventListenerOptions ? l : typeof l.capture < "u" ? l.capture : !1 : h = e.supportsEventListenerOptions ? { capture: !1 } : !1, h;
          },
          /**
           * Adds an event listener for the given element, eventName and handler.
           * @function
           * @param {Element|String} element
           * @param {String} eventName
           * @param {Function} handler
           * @param {Boolean|Object} [options] Boolean useCapture, or if [supportsEventListenerOptions]{@link OpenSeadragon.supportsEventListenerOptions}, can be an object
           * @param {Boolean} [options.capture]
           * @param {Boolean} [options.passive]
           * @param {Boolean} [options.once]
           */
          addEvent: function() {
            if (e.supportsAddEventListener)
              return function(l, h, d, f) {
                f = e.normalizeEventListenerOptions(f), l = e.getElement(l), l.addEventListener(h, d, f);
              };
            if (document.documentElement.attachEvent && document.attachEvent)
              return function(l, h, d) {
                l = e.getElement(l), l.attachEvent("on" + h, d);
              };
            throw new Error("No known event model.");
          }(),
          /**
           * Remove a given event listener for the given element, event type and
           * handler.
           * @function
           * @param {Element|String} element
           * @param {String} eventName
           * @param {Function} handler
           * @param {Boolean|Object} [options] Boolean useCapture, or if [supportsEventListenerOptions]{@link OpenSeadragon.supportsEventListenerOptions}, can be an object
           * @param {Boolean} [options.capture]
           */
          removeEvent: function() {
            if (e.supportsRemoveEventListener)
              return function(l, h, d, f) {
                f = e.normalizeEventListenerOptions(f), l = e.getElement(l), l.removeEventListener(h, d, f);
              };
            if (document.documentElement.detachEvent && document.detachEvent)
              return function(l, h, d) {
                l = e.getElement(l), l.detachEvent("on" + h, d);
              };
            throw new Error("No known event model.");
          }(),
          /**
           * Cancels the default browser behavior had the event propagated all
           * the way up the DOM to the window object.
           * @function
           * @param {Event} [event]
           */
          cancelEvent: function(l) {
            l.preventDefault();
          },
          /**
           * Returns true if {@link OpenSeadragon.cancelEvent|cancelEvent} has been called on
           * the event, otherwise returns false.
           * @function
           * @param {Event} [event]
           */
          eventIsCanceled: function(l) {
            return l.defaultPrevented;
          },
          /**
           * Stops the propagation of the event through the DOM in the capturing and bubbling phases.
           * @function
           * @param {Event} [event]
           */
          stopEvent: function(l) {
            l.stopPropagation();
          },
          // Deprecated
          createCallback: function(l, h) {
            console.error("The createCallback function is deprecated and will be removed in future versions. Please use alternativeFunction instead.");
            var d = [], f;
            for (f = 2; f < arguments.length; f++)
              d.push(arguments[f]);
            return function() {
              var g = d.concat([]), w;
              for (w = 0; w < arguments.length; w++)
                g.push(arguments[w]);
              return h.apply(l, g);
            };
          },
          /**
           * Retrieves the value of a url parameter from the window.location string.
           * @function
           * @param {String} key
           * @returns {String} The value of the url parameter or null if no param matches.
           */
          getUrlParameter: function(l) {
            var h = o[l];
            return h || null;
          },
          /**
           * Retrieves the protocol used by the url. The url can either be absolute
           * or relative.
           * @function
           * @private
           * @param {String} url The url to retrieve the protocol from.
           * @returns {String} The protocol (http:, https:, file:, ftp: ...)
           */
          getUrlProtocol: function(l) {
            var h = l.match(/^([a-z]+:)\/\//i);
            return h === null ? window.location.protocol : h[1].toLowerCase();
          },
          /**
           * Create an XHR object
           * @private
           * @param {type} [local] Deprecated. Ignored (IE/ActiveXObject file protocol no longer supported).
           * @returns {XMLHttpRequest}
           */
          createAjaxRequest: function() {
            if (window.XMLHttpRequest)
              return e.createAjaxRequest = function() {
                return new XMLHttpRequest();
              }, new XMLHttpRequest();
            throw new Error("Browser doesn't support XMLHttpRequest.");
          },
          /**
           * Makes an AJAX request.
           * @param {Object} options
           * @param {String} options.url - the url to request
           * @param {Function} options.success - a function to call on a successful response
           * @param {Function} options.error - a function to call on when an error occurs
           * @param {Object} options.headers - headers to add to the AJAX request
           * @param {String} options.responseType - the response type of the AJAX request
           * @param {String} options.postData - HTTP POST data (usually but not necessarily in k=v&k2=v2... form,
           *      see TileSource::getPostData), GET method used if null
           * @param {Boolean} [options.withCredentials=false] - whether to set the XHR's withCredentials
           * @throws {Error}
           * @returns {XMLHttpRequest}
           */
          makeAjaxRequest: function(l, h, d) {
            var f, g, w, C;
            e.isPlainObject(l) && (h = l.success, d = l.error, f = l.withCredentials, g = l.headers, w = l.responseType || null, C = l.postData || null, l = l.url);
            var E = e.getUrlProtocol(l), A = e.createAjaxRequest();
            if (!e.isFunction(h))
              throw new Error("makeAjaxRequest requires a success callback");
            A.onreadystatechange = function() {
              A.readyState === 4 && (A.onreadystatechange = function() {
              }, A.status >= 200 && A.status < 300 || A.status === 0 && E !== "http:" && E !== "https:" ? h(A) : e.isFunction(d) ? d(A) : e.console.error("AJAX request returned %d: %s", A.status, l));
            };
            var I = C ? "POST" : "GET";
            try {
              if (A.open(I, l, !0), w && (A.responseType = w), g)
                for (var V in g)
                  Object.prototype.hasOwnProperty.call(g, V) && g[V] && A.setRequestHeader(V, g[V]);
              f && (A.withCredentials = !0), A.send(C);
            } catch (K) {
              e.console.error("%s while making AJAX request: %s", K.name, K.message), A.onreadystatechange = function() {
              }, e.isFunction(d) && d(A, K);
            }
            return A;
          },
          /**
           * Taken from jQuery 1.6.1
           * @function
           * @param {Object} options
           * @param {String} options.url
           * @param {Function} options.callback
           * @param {String} [options.param='callback'] The name of the url parameter
           *      to request the jsonp provider with.
           * @param {String} [options.callbackName=] The name of the callback to
           *      request the jsonp provider with.
           */
          jsonp: function(l) {
            var h, d = l.url, f = document.head || document.getElementsByTagName("head")[0] || document.documentElement, g = l.callbackName || "openseadragon" + e.now(), w = window[g], C = "$1" + g + "$2", E = l.param || "callback", A = l.callback;
            d = d.replace(/(=)\?(&|$)|\?\?/i, C), d += (/\?/.test(d) ? "&" : "?") + E + "=" + g, window[g] = function(I) {
              if (w)
                window[g] = w;
              else
                try {
                  delete window[g];
                } catch {
                }
              A && e.isFunction(A) && A(I);
            }, h = document.createElement("script"), (l.async !== void 0 || l.async !== !1) && (h.async = "async"), l.scriptCharset && (h.charset = l.scriptCharset), h.src = d, h.onload = h.onreadystatechange = function(I, V) {
              (V || !h.readyState || /loaded|complete/.test(h.readyState)) && (h.onload = h.onreadystatechange = null, f && h.parentNode && f.removeChild(h), h = void 0);
            }, f.insertBefore(h, f.firstChild);
          },
          /**
           * Fully deprecated. Will throw an error.
           * @function
           * @deprecated use {@link OpenSeadragon.Viewer#open}
           */
          createFromDZI: function() {
            throw "OpenSeadragon.createFromDZI is deprecated, use Viewer.open.";
          },
          /**
           * Parses an XML string into a DOM Document.
           * @function
           * @param {String} string
           * @returns {Document}
           */
          parseXml: function(l) {
            if (window.DOMParser)
              e.parseXml = function(h) {
                var d = null, f;
                return f = new DOMParser(), d = f.parseFromString(h, "text/xml"), d;
              };
            else
              throw new Error("Browser doesn't support XML DOM.");
            return e.parseXml(l);
          },
          /**
           * Parses a JSON string into a Javascript object.
           * @function
           * @param {String} string
           * @returns {Object}
           */
          parseJSON: function(l) {
            return e.parseJSON = window.JSON.parse, e.parseJSON(l);
          },
          /**
           * Reports whether the image format is supported for tiling in this
           * version.
           * @function
           * @param {String} [extension]
           * @returns {Boolean}
           */
          imageFormatSupported: function(l) {
            return l = l || "", !!n[l.toLowerCase()];
          },
          /**
           * Updates supported image formats with user-specified values.
           * Preexisting formats that are not being updated are left unchanged.
           * By default, the defined formats are
           * <pre><code>{
           *      avif: true,
           *      bmp:  false,
           *      jpeg: true,
           *      jpg:  true,
           *      png:  true,
           *      tif:  false,
           *      wdp:  false,
           *      webp: true
           * }
           * </code></pre>
           * @function
           * @example
           * // sets bmp as supported and png as unsupported
           * setImageFormatsSupported({bmp: true, png: false});
           * @param {Object} formats An object containing format extensions as
           * keys and booleans as values.
           */
          setImageFormatsSupported: function(l) {
            e.extend(n, l);
          }
        }
      );
      var i = function(l) {
      };
      e.console = window.console || {
        log: i,
        debug: i,
        info: i,
        warn: i,
        error: i,
        assert: i
      }, e.Browser = {
        vendor: e.BROWSERS.UNKNOWN,
        version: 0,
        alpha: !0
      };
      var n = {
        avif: !0,
        bmp: !1,
        jpeg: !0,
        jpg: !0,
        png: !0,
        tif: !1,
        wdp: !1,
        webp: !0
      }, o = {};
      (function() {
        var l = navigator.appVersion, h = navigator.userAgent, d;
        switch (navigator.appName) {
          case "Microsoft Internet Explorer":
            window.attachEvent && window.ActiveXObject && (e.Browser.vendor = e.BROWSERS.IE, e.Browser.version = parseFloat(
              h.substring(
                h.indexOf("MSIE") + 5,
                h.indexOf(";", h.indexOf("MSIE"))
              )
            ));
            break;
          case "Netscape":
            window.addEventListener && (h.indexOf("Edge") >= 0 ? (e.Browser.vendor = e.BROWSERS.EDGE, e.Browser.version = parseFloat(
              h.substring(h.indexOf("Edge") + 5)
            )) : h.indexOf("Edg") >= 0 ? (e.Browser.vendor = e.BROWSERS.CHROMEEDGE, e.Browser.version = parseFloat(
              h.substring(h.indexOf("Edg") + 4)
            )) : h.indexOf("Firefox") >= 0 ? (e.Browser.vendor = e.BROWSERS.FIREFOX, e.Browser.version = parseFloat(
              h.substring(h.indexOf("Firefox") + 8)
            )) : h.indexOf("Safari") >= 0 ? (e.Browser.vendor = h.indexOf("Chrome") >= 0 ? e.BROWSERS.CHROME : e.BROWSERS.SAFARI, e.Browser.version = parseFloat(
              h.substring(
                h.substring(0, h.indexOf("Safari")).lastIndexOf("/") + 1,
                h.indexOf("Safari")
              )
            )) : (d = new RegExp("Trident/.*rv:([0-9]{1,}[.0-9]{0,})"), d.exec(h) !== null && (e.Browser.vendor = e.BROWSERS.IE, e.Browser.version = parseFloat(RegExp.$1))));
            break;
          case "Opera":
            e.Browser.vendor = e.BROWSERS.OPERA, e.Browser.version = parseFloat(l);
            break;
        }
        var f = window.location.search.substring(1), g = f.split("&"), w, C, E;
        for (E = 0; E < g.length; E++)
          if (w = g[E], C = w.indexOf("="), C > 0) {
            var A = w.substring(0, C), I = w.substring(C + 1);
            try {
              o[A] = decodeURIComponent(I);
            } catch {
              e.console.error("Ignoring malformed URL parameter: %s=%s", A, I);
            }
          }
        e.Browser.alpha = !(e.Browser.vendor === e.BROWSERS.CHROME && e.Browser.version < 2), e.Browser.opacity = !0, e.Browser.vendor === e.BROWSERS.IE && e.console.error("Internet Explorer is not supported by OpenSeadragon");
      })(), function(l) {
        var h = l.requestAnimationFrame || l.mozRequestAnimationFrame || l.webkitRequestAnimationFrame || l.msRequestAnimationFrame, d = l.cancelAnimationFrame || l.mozCancelAnimationFrame || l.webkitCancelAnimationFrame || l.msCancelAnimationFrame;
        if (h && d)
          e.requestAnimationFrame = function() {
            return h.apply(l, arguments);
          }, e.cancelAnimationFrame = function() {
            return d.apply(l, arguments);
          };
        else {
          var f = [], g = [], w = 0, C;
          e.requestAnimationFrame = function(E) {
            return f.push([++w, E]), C || (C = setInterval(function() {
              if (f.length) {
                var A = e.now(), I = g;
                for (g = f, f = I; g.length; )
                  g.shift()[1](A);
              } else
                clearInterval(C), C = void 0;
            }, 1e3 / 50)), w;
          }, e.cancelAnimationFrame = function(E) {
            var A, I;
            for (A = 0, I = f.length; A < I; A += 1)
              if (f[A][0] === E) {
                f.splice(A, 1);
                return;
              }
            for (A = 0, I = g.length; A < I; A += 1)
              if (g[A][0] === E) {
                g.splice(A, 1);
                return;
              }
          };
        }
      }(window);
      function a(l, h) {
        return h && l !== document.body ? document.body : l.offsetParent;
      }
    }(r), function(e, t) {
      s.exports ? s.exports = t() : e.OpenSeadragon = t();
    }(Gm, function() {
      return r;
    }), function(e) {
      class t {
        constructor(n) {
          n || (n = [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
          ]), this.values = n;
        }
        /**
         * @function makeIdentity
         * @memberof OpenSeadragon.Mat3
         * @static
         * @returns {OpenSeadragon.Mat3} an identity matrix
         */
        static makeIdentity() {
          return new t([
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
          ]);
        }
        /**
         * @function makeTranslation
         * @memberof OpenSeadragon.Mat3
         * @static
         * @param {Number} tx The x value of the translation
         * @param {Number} ty The y value of the translation
         * @returns {OpenSeadragon.Mat3} A translation matrix
         */
        static makeTranslation(n, o) {
          return new t([
            1,
            0,
            0,
            0,
            1,
            0,
            n,
            o,
            1
          ]);
        }
        /**
         * @function makeRotation
         * @memberof OpenSeadragon.Mat3
         * @static
         * @param {Number} angleInRadians The desired rotation angle, in radians
         * @returns {OpenSeadragon.Mat3} A rotation matrix
         */
        static makeRotation(n) {
          var o = Math.cos(n), a = Math.sin(n);
          return new t([
            o,
            -a,
            0,
            a,
            o,
            0,
            0,
            0,
            1
          ]);
        }
        /**
         * @function makeScaling
         * @memberof OpenSeadragon.Mat3
         * @static
         * @param {Number} sx The x value of the scaling
         * @param {Number} sy The y value of the scaling
         * @returns {OpenSeadragon.Mat3} A scaling matrix
         */
        static makeScaling(n, o) {
          return new t([
            n,
            0,
            0,
            0,
            o,
            0,
            0,
            0,
            1
          ]);
        }
        /**
         * @alias multiply
         * @memberof! OpenSeadragon.Mat3
         * @param {OpenSeadragon.Mat3} other the matrix to multiply with
         * @returns {OpenSeadragon.Mat3} The result of matrix multiplication
         */
        multiply(n) {
          let o = this.values, a = n.values;
          var l = o[0 * 3 + 0], h = o[0 * 3 + 1], d = o[0 * 3 + 2], f = o[1 * 3 + 0], g = o[1 * 3 + 1], w = o[1 * 3 + 2], C = o[2 * 3 + 0], E = o[2 * 3 + 1], A = o[2 * 3 + 2], I = a[0 * 3 + 0], V = a[0 * 3 + 1], K = a[0 * 3 + 2], ce = a[1 * 3 + 0], re = a[1 * 3 + 1], he = a[1 * 3 + 2], pe = a[2 * 3 + 0], Te = a[2 * 3 + 1], Ae = a[2 * 3 + 2];
          return new t([
            I * l + V * f + K * C,
            I * h + V * g + K * E,
            I * d + V * w + K * A,
            ce * l + re * f + he * C,
            ce * h + re * g + he * E,
            ce * d + re * w + he * A,
            pe * l + Te * f + Ae * C,
            pe * h + Te * g + Ae * E,
            pe * d + Te * w + Ae * A
          ]);
        }
      }
      e.Mat3 = t;
    }(r), function(e) {
      var t = {
        supportsFullScreen: !1,
        isFullScreen: function() {
          return !1;
        },
        getFullScreenElement: function() {
          return null;
        },
        requestFullScreen: function() {
        },
        exitFullScreen: function() {
        },
        cancelFullScreen: function() {
        },
        fullScreenEventName: "",
        fullScreenErrorEventName: ""
      };
      document.exitFullscreen ? (t.supportsFullScreen = !0, t.getFullScreenElement = function() {
        return document.fullscreenElement;
      }, t.requestFullScreen = function(i) {
        return i.requestFullscreen().catch(function(n) {
          e.console.error("Fullscreen request failed: ", n);
        });
      }, t.exitFullScreen = function() {
        document.exitFullscreen().catch(function(i) {
          e.console.error("Error while exiting fullscreen: ", i);
        });
      }, t.fullScreenEventName = "fullscreenchange", t.fullScreenErrorEventName = "fullscreenerror") : document.msExitFullscreen ? (t.supportsFullScreen = !0, t.getFullScreenElement = function() {
        return document.msFullscreenElement;
      }, t.requestFullScreen = function(i) {
        return i.msRequestFullscreen();
      }, t.exitFullScreen = function() {
        document.msExitFullscreen();
      }, t.fullScreenEventName = "MSFullscreenChange", t.fullScreenErrorEventName = "MSFullscreenError") : document.webkitExitFullscreen ? (t.supportsFullScreen = !0, t.getFullScreenElement = function() {
        return document.webkitFullscreenElement;
      }, t.requestFullScreen = function(i) {
        return i.webkitRequestFullscreen();
      }, t.exitFullScreen = function() {
        document.webkitExitFullscreen();
      }, t.fullScreenEventName = "webkitfullscreenchange", t.fullScreenErrorEventName = "webkitfullscreenerror") : document.webkitCancelFullScreen ? (t.supportsFullScreen = !0, t.getFullScreenElement = function() {
        return document.webkitCurrentFullScreenElement;
      }, t.requestFullScreen = function(i) {
        return i.webkitRequestFullScreen();
      }, t.exitFullScreen = function() {
        document.webkitCancelFullScreen();
      }, t.fullScreenEventName = "webkitfullscreenchange", t.fullScreenErrorEventName = "webkitfullscreenerror") : document.mozCancelFullScreen && (t.supportsFullScreen = !0, t.getFullScreenElement = function() {
        return document.mozFullScreenElement;
      }, t.requestFullScreen = function(i) {
        return i.mozRequestFullScreen();
      }, t.exitFullScreen = function() {
        document.mozCancelFullScreen();
      }, t.fullScreenEventName = "mozfullscreenchange", t.fullScreenErrorEventName = "mozfullscreenerror"), t.isFullScreen = function() {
        return t.getFullScreenElement() !== null;
      }, t.cancelFullScreen = function() {
        e.console.error("cancelFullScreen is deprecated. Use exitFullScreen instead."), t.exitFullScreen();
      }, e.extend(e, t);
    }(r), function(e) {
      e.EventSource = function() {
        this.events = {}, this._rejectedEventList = {};
      }, e.EventSource.prototype = {
        /**
         * Add an event handler to be triggered only once (or a given number of times)
         * for a given event. It is not removable with removeHandler().
         * @function
         * @param {String} eventName - Name of event to register.
         * @param {OpenSeadragon.EventHandler} handler - Function to call when event
         * is triggered.
         * @param {Object} [userData=null] - Arbitrary object to be passed unchanged
         * to the handler.
         * @param {Number} [times=1] - The number of times to handle the event
         * before removing it.
         * @param {Number} [priority=0] - Handler priority. By default, all priorities are 0. Higher number = priority.
         * @returns {Boolean} - True if the handler was added, false if it was rejected
         */
        addOnceHandler: function(t, i, n, o, a) {
          var l = this;
          o = o || 1;
          var h = 0, d = function(f) {
            return h++, h === o && l.removeHandler(t, d), i(f);
          };
          return this.addHandler(t, d, n, a);
        },
        /**
         * Add an event handler for a given event.
         * @function
         * @param {String} eventName - Name of event to register.
         * @param {OpenSeadragon.EventHandler} handler - Function to call when event is triggered.
         * @param {Object} [userData=null] - Arbitrary object to be passed unchanged to the handler.
         * @param {Number} [priority=0] - Handler priority. By default, all priorities are 0. Higher number = priority.
         * @returns {Boolean} - True if the handler was added, false if it was rejected
         */
        addHandler: function(t, i, n, o) {
          if (Object.prototype.hasOwnProperty.call(this._rejectedEventList, t))
            return e.console.error(`Error adding handler for ${t}. ${this._rejectedEventList[t]}`), !1;
          var a = this.events[t];
          if (a || (this.events[t] = a = []), i && e.isFunction(i)) {
            var l = a.length, h = { handler: i, userData: n || null, priority: o || 0 };
            for (a[l] = h; l > 0 && a[l - 1].priority < a[l].priority; )
              a[l] = a[l - 1], a[l - 1] = h, l--;
          }
          return !0;
        },
        /**
         * Remove a specific event handler for a given event.
         * @function
         * @param {String} eventName - Name of event for which the handler is to be removed.
         * @param {OpenSeadragon.EventHandler} handler - Function to be removed.
         */
        removeHandler: function(t, i) {
          var n = this.events[t], o = [], a;
          if (n && e.isArray(n)) {
            for (a = 0; a < n.length; a++)
              n[a].handler !== i && o.push(n[a]);
            this.events[t] = o;
          }
        },
        /**
         * Get the amount of handlers registered for a given event.
         * @param {String} eventName - Name of event to inspect.
         * @returns {number} amount of events
         */
        numberOfHandlers: function(t) {
          var i = this.events[t];
          return i ? i.length : 0;
        },
        /**
         * Remove all event handlers for a given event type. If no type is given all
         * event handlers for every event type are removed.
         * @function
         * @param {String} eventName - Name of event for which all handlers are to be removed.
         */
        removeAllHandlers: function(t) {
          if (t)
            this.events[t] = [];
          else
            for (var i in this.events)
              this.events[i] = [];
        },
        /**
         * Get a function which iterates the list of all handlers registered for a given event, calling the handler for each.
         * @function
         * @param {String} eventName - Name of event to get handlers for.
         */
        getHandler: function(t) {
          var i = this.events[t];
          return !i || !i.length ? null : (i = i.length === 1 ? [i[0]] : Array.apply(null, i), function(n, o) {
            var a, l = i.length;
            for (a = 0; a < l; a++)
              i[a] && (o.eventSource = n, o.userData = i[a].userData, i[a].handler(o));
          });
        },
        /**
         * Trigger an event, optionally passing additional information.
         * @function
         * @param {String} eventName - Name of event to register.
         * @param {Object} eventArgs - Event-specific data.
         * @returns {Boolean} True if the event was fired, false if it was rejected because of rejectEventHandler(eventName)
         */
        raiseEvent: function(t, i) {
          if (Object.prototype.hasOwnProperty.call(this._rejectedEventList, t))
            return e.console.error(`Error adding handler for ${t}. ${this._rejectedEventList[t]}`), !1;
          var n = this.getHandler(t);
          return n && n(this, i || {}), !0;
        },
        /**
         * Set an event name as being disabled, and provide an optional error message
         * to be printed to the console
         * @param {String} eventName - Name of the event
         * @param {String} [errorMessage] - Optional string to print to the console
         * @private
         */
        rejectEventHandler(t, i = "") {
          this._rejectedEventList[t] = i;
        },
        /**
         * Explicitly allow an event handler to be added for this event type, undoing
         * the effects of rejectEventHandler
         * @param {String} eventName - Name of the event
         * @private
         */
        allowEventHandler(t) {
          delete this._rejectedEventList[t];
        }
      };
    }(r), function(e) {
      var t = {};
      e.MouseTracker = function(b) {
        var _ = arguments;
        e.isPlainObject(b) || (b = {
          element: _[0],
          clickTimeThreshold: _[1],
          clickDistThreshold: _[2]
        }), this.hash = Math.random(), this.element = e.getElement(b.element), this.clickTimeThreshold = b.clickTimeThreshold || e.DEFAULT_SETTINGS.clickTimeThreshold, this.clickDistThreshold = b.clickDistThreshold || e.DEFAULT_SETTINGS.clickDistThreshold, this.dblClickTimeThreshold = b.dblClickTimeThreshold || e.DEFAULT_SETTINGS.dblClickTimeThreshold, this.dblClickDistThreshold = b.dblClickDistThreshold || e.DEFAULT_SETTINGS.dblClickDistThreshold, this.userData = b.userData || null, this.stopDelay = b.stopDelay || 50, this.preProcessEventHandler = b.preProcessEventHandler || null, this.contextMenuHandler = b.contextMenuHandler || null, this.enterHandler = b.enterHandler || null, this.leaveHandler = b.leaveHandler || null, this.exitHandler = b.exitHandler || null, this.overHandler = b.overHandler || null, this.outHandler = b.outHandler || null, this.pressHandler = b.pressHandler || null, this.nonPrimaryPressHandler = b.nonPrimaryPressHandler || null, this.releaseHandler = b.releaseHandler || null, this.nonPrimaryReleaseHandler = b.nonPrimaryReleaseHandler || null, this.moveHandler = b.moveHandler || null, this.scrollHandler = b.scrollHandler || null, this.clickHandler = b.clickHandler || null, this.dblClickHandler = b.dblClickHandler || null, this.dragHandler = b.dragHandler || null, this.dragEndHandler = b.dragEndHandler || null, this.pinchHandler = b.pinchHandler || null, this.stopHandler = b.stopHandler || null, this.keyDownHandler = b.keyDownHandler || null, this.keyUpHandler = b.keyUpHandler || null, this.keyHandler = b.keyHandler || null, this.focusHandler = b.focusHandler || null, this.blurHandler = b.blurHandler || null;
        var T = this;
        t[this.hash] = {
          click: function(S) {
            K(T, S);
          },
          dblclick: function(S) {
            ce(T, S);
          },
          keydown: function(S) {
            re(T, S);
          },
          keyup: function(S) {
            he(T, S);
          },
          keypress: function(S) {
            pe(T, S);
          },
          focus: function(S) {
            Te(T, S);
          },
          blur: function(S) {
            Ae(T, S);
          },
          contextmenu: function(S) {
            He(T, S);
          },
          wheel: function(S) {
            Fe(T, S);
          },
          mousewheel: function(S) {
            ve(T, S);
          },
          DOMMouseScroll: function(S) {
            ve(T, S);
          },
          MozMousePixelScroll: function(S) {
            ve(T, S);
          },
          losecapture: function(S) {
            Ze(T, S);
          },
          mouseenter: function(S) {
            _e(T, S);
          },
          mouseleave: function(S) {
            ii(T, S);
          },
          mouseover: function(S) {
            kt(T, S);
          },
          mouseout: function(S) {
            _t(T, S);
          },
          mousedown: function(S) {
            xt(T, S);
          },
          mouseup: function(S) {
            Si(T, S);
          },
          mousemove: function(S) {
            At(T, S);
          },
          touchstart: function(S) {
            Ue(T, S);
          },
          touchend: function(S) {
            We(T, S);
          },
          touchmove: function(S) {
            it(T, S);
          },
          touchcancel: function(S) {
            Ve(T, S);
          },
          gesturestart: function(S) {
            rt(T, S);
          },
          // Safari/Safari iOS
          gesturechange: function(S) {
            Ye(T, S);
          },
          // Safari/Safari iOS
          gotpointercapture: function(S) {
            ti(T, S);
          },
          lostpointercapture: function(S) {
            ir(T, S);
          },
          pointerenter: function(S) {
            _e(T, S);
          },
          pointerleave: function(S) {
            ii(T, S);
          },
          pointerover: function(S) {
            kt(T, S);
          },
          pointerout: function(S) {
            _t(T, S);
          },
          pointerdown: function(S) {
            xt(T, S);
          },
          pointerup: function(S) {
            Si(T, S);
          },
          pointermove: function(S) {
            At(T, S);
          },
          pointercancel: function(S) {
            rr(T, S);
          },
          pointerupcaptured: function(S) {
            fe(T, S);
          },
          pointermovecaptured: function(S) {
            Ie(T, S);
          },
          tracking: !1,
          // Active pointers lists. Array of GesturePointList objects, one for each pointer device type.
          // GesturePointList objects are added each time a pointer is tracked by a new pointer device type (see getActivePointersListByType()).
          // Active pointers are any pointer being tracked for this element which are in the hit-test area
          //     of the element (for hover-capable devices) and/or have contact or a button press initiated in the element.
          activePointersLists: [],
          // Tracking for double-click gesture
          lastClickPos: null,
          dblClickTimeOut: null,
          // Tracking for pinch gesture
          pinchGPoints: [],
          lastPinchDist: 0,
          currentPinchDist: 0,
          lastPinchCenter: null,
          currentPinchCenter: null,
          // Tracking for drag
          sentDragEvent: !1
        }, this.hasGestureHandlers = !!(this.pressHandler || this.nonPrimaryPressHandler || this.releaseHandler || this.nonPrimaryReleaseHandler || this.clickHandler || this.dblClickHandler || this.dragHandler || this.dragEndHandler || this.pinchHandler), this.hasScrollHandler = !!this.scrollHandler, e.MouseTracker.havePointerEvents && e.setElementPointerEvents(this.element, "auto"), this.exitHandler && e.console.error("MouseTracker.exitHandler is deprecated. Use MouseTracker.leaveHandler instead."), b.startDisabled || this.setTracking(!0);
      }, e.MouseTracker.prototype = {
        /**
         * Clean up any events or objects created by the tracker.
         * @function
         */
        destroy: function() {
          l(this), this.element = null, t[this.hash] = null, delete t[this.hash];
        },
        /**
         * Are we currently tracking events on this element.
         * @deprecated Just use this.tracking
         * @function
         * @returns {Boolean} Are we currently tracking events on this element.
         */
        isTracking: function() {
          return t[this.hash].tracking;
        },
        /**
         * Enable or disable whether or not we are tracking events on this element.
         * @function
         * @param {Boolean} track True to start tracking, false to stop tracking.
         * @returns {OpenSeadragon.MouseTracker} Chainable.
         */
        setTracking: function(b) {
          return b ? a(this) : l(this), this;
        },
        /**
         * Returns the {@link OpenSeadragon.MouseTracker.GesturePointList|GesturePointList} for the given pointer device type,
         * creating and caching a new {@link OpenSeadragon.MouseTracker.GesturePointList|GesturePointList} if one doesn't already exist for the type.
         * @function
         * @param {String} type - The pointer device type: "mouse", "touch", "pen", etc.
         * @returns {OpenSeadragon.MouseTracker.GesturePointList}
         */
        getActivePointersListByType: function(b) {
          var _ = t[this.hash], T, S = _ ? _.activePointersLists.length : 0, q;
          for (T = 0; T < S; T++)
            if (_.activePointersLists[T].type === b)
              return _.activePointersLists[T];
          return q = new e.MouseTracker.GesturePointList(b), _ && _.activePointersLists.push(q), q;
        },
        /**
         * Returns the total number of pointers currently active on the tracked element.
         * @function
         * @returns {Number}
         */
        getActivePointerCount: function() {
          var b = t[this.hash], _, T = b.activePointersLists.length, S = 0;
          for (_ = 0; _ < T; _++)
            S += b.activePointersLists[_].getLength();
          return S;
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {OpenSeadragon.MouseTracker.EventProcessInfo} eventInfo
         */
        preProcessEventHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {OpenSeadragon.Point} event.position
         *      The position of the event relative to the tracked element.
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Boolean} event.preventDefault
         *      Set to true to prevent the default user-agent's handling of the contextmenu event.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        contextMenuHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {String} event.pointerType
         *     "mouse", "touch", "pen", etc.
         * @param {OpenSeadragon.Point} event.position
         *      The position of the event relative to the tracked element.
         * @param {Number} event.buttons
         *      Current buttons pressed.
         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
         * @param {Number} event.pointers
         *      Number of pointers (all types) active in the tracked element.
         * @param {Boolean} event.insideElementPressed
         *      True if the left mouse button is currently being pressed and was
         *      initiated inside the tracked element, otherwise false.
         * @param {Boolean} event.buttonDownAny
         *      Was the button down anywhere in the screen during the event. <span style="color:red;">Deprecated. Use buttons instead.</span>
         * @param {Boolean} event.isTouchEvent
         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        enterHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @since v2.5.0
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {String} event.pointerType
         *     "mouse", "touch", "pen", etc.
         * @param {OpenSeadragon.Point} event.position
         *      The position of the event relative to the tracked element.
         * @param {Number} event.buttons
         *      Current buttons pressed.
         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
         * @param {Number} event.pointers
         *      Number of pointers (all types) active in the tracked element.
         * @param {Boolean} event.insideElementPressed
         *      True if the left mouse button is currently being pressed and was
         *      initiated inside the tracked element, otherwise false.
         * @param {Boolean} event.buttonDownAny
         *      Was the button down anywhere in the screen during the event. <span style="color:red;">Deprecated. Use buttons instead.</span>
         * @param {Boolean} event.isTouchEvent
         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        leaveHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @deprecated v2.5.0 Use leaveHandler instead
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {String} event.pointerType
         *     "mouse", "touch", "pen", etc.
         * @param {OpenSeadragon.Point} event.position
         *      The position of the event relative to the tracked element.
         * @param {Number} event.buttons
         *      Current buttons pressed.
         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
         * @param {Number} event.pointers
         *      Number of pointers (all types) active in the tracked element.
         * @param {Boolean} event.insideElementPressed
         *      True if the left mouse button is currently being pressed and was
         *      initiated inside the tracked element, otherwise false.
         * @param {Boolean} event.buttonDownAny
         *      Was the button down anywhere in the screen during the event. <span style="color:red;">Deprecated. Use buttons instead.</span>
         * @param {Boolean} event.isTouchEvent
         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        exitHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @since v2.5.0
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {String} event.pointerType
         *     "mouse", "touch", "pen", etc.
         * @param {OpenSeadragon.Point} event.position
         *      The position of the event relative to the tracked element.
         * @param {Number} event.buttons
         *      Current buttons pressed.
         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
         * @param {Number} event.pointers
         *      Number of pointers (all types) active in the tracked element.
         * @param {Boolean} event.insideElementPressed
         *      True if the left mouse button is currently being pressed and was
         *      initiated inside the tracked element, otherwise false.
         * @param {Boolean} event.buttonDownAny
         *      Was the button down anywhere in the screen during the event. <span style="color:red;">Deprecated. Use buttons instead.</span>
         * @param {Boolean} event.isTouchEvent
         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        overHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @since v2.5.0
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {String} event.pointerType
         *     "mouse", "touch", "pen", etc.
         * @param {OpenSeadragon.Point} event.position
         *      The position of the event relative to the tracked element.
         * @param {Number} event.buttons
         *      Current buttons pressed.
         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
         * @param {Number} event.pointers
         *      Number of pointers (all types) active in the tracked element.
         * @param {Boolean} event.insideElementPressed
         *      True if the left mouse button is currently being pressed and was
         *      initiated inside the tracked element, otherwise false.
         * @param {Boolean} event.buttonDownAny
         *      Was the button down anywhere in the screen during the event. <span style="color:red;">Deprecated. Use buttons instead.</span>
         * @param {Boolean} event.isTouchEvent
         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        outHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {String} event.pointerType
         *     "mouse", "touch", "pen", etc.
         * @param {OpenSeadragon.Point} event.position
         *      The position of the event relative to the tracked element.
         * @param {Number} event.buttons
         *      Current buttons pressed.
         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
         * @param {Boolean} event.isTouchEvent
         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        pressHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {String} event.pointerType
         *     "mouse", "touch", "pen", etc.
         * @param {OpenSeadragon.Point} event.position
         *      The position of the event relative to the tracked element.
         * @param {Number} event.button
         *      Button which caused the event.
         *      -1: none, 0: primary/left, 1: aux/middle, 2: secondary/right, 3: X1/back, 4: X2/forward, 5: pen eraser.
         * @param {Number} event.buttons
         *      Current buttons pressed.
         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
         * @param {Boolean} event.isTouchEvent
         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        nonPrimaryPressHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {String} event.pointerType
         *     "mouse", "touch", "pen", etc.
         * @param {OpenSeadragon.Point} event.position
         *      The position of the event relative to the tracked element.
         * @param {Number} event.buttons
         *      Current buttons pressed.
         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
         * @param {Boolean} event.insideElementPressed
         *      True if the left mouse button is currently being pressed and was
         *      initiated inside the tracked element, otherwise false.
         * @param {Boolean} event.insideElementReleased
         *      True if the cursor inside the tracked element when the button was released.
         * @param {Boolean} event.isTouchEvent
         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        releaseHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {String} event.pointerType
         *     "mouse", "touch", "pen", etc.
         * @param {OpenSeadragon.Point} event.position
         *      The position of the event relative to the tracked element.
         * @param {Number} event.button
         *      Button which caused the event.
         *      -1: none, 0: primary/left, 1: aux/middle, 2: secondary/right, 3: X1/back, 4: X2/forward, 5: pen eraser.
         * @param {Number} event.buttons
         *      Current buttons pressed.
         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
         * @param {Boolean} event.isTouchEvent
         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        nonPrimaryReleaseHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {String} event.pointerType
         *     "mouse", "touch", "pen", etc.
         * @param {OpenSeadragon.Point} event.position
         *      The position of the event relative to the tracked element.
         * @param {Number} event.buttons
         *      Current buttons pressed.
         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
         * @param {Boolean} event.isTouchEvent
         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        moveHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {String} event.pointerType
         *     "mouse", "touch", "pen", etc.
         * @param {OpenSeadragon.Point} event.position
         *      The position of the event relative to the tracked element.
         * @param {Number} event.scroll
         *      The scroll delta for the event.
         * @param {Boolean} event.shift
         *      True if the shift key was pressed during this event.
         * @param {Boolean} event.isTouchEvent
         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead. Touch devices no longer generate scroll event.</span>
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Boolean} event.preventDefault
         *      Set to true to prevent the default user-agent's handling of the wheel event.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        scrollHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {String} event.pointerType
         *     "mouse", "touch", "pen", etc.
         * @param {OpenSeadragon.Point} event.position
         *      The position of the event relative to the tracked element.
         * @param {Boolean} event.quick
         *      True only if the clickDistThreshold and clickTimeThreshold are both passed. Useful for ignoring drag events.
         * @param {Boolean} event.shift
         *      True if the shift key was pressed during this event.
         * @param {Boolean} event.isTouchEvent
         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Element} event.originalTarget
         *      The DOM element clicked on.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        clickHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {String} event.pointerType
         *     "mouse", "touch", "pen", etc.
         * @param {OpenSeadragon.Point} event.position
         *      The position of the event relative to the tracked element.
         * @param {Boolean} event.shift
         *      True if the shift key was pressed during this event.
         * @param {Boolean} event.isTouchEvent
         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        dblClickHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {String} event.pointerType
         *     "mouse", "touch", "pen", etc.
         * @param {OpenSeadragon.Point} event.position
         *      The position of the event relative to the tracked element.
         * @param {Number} event.buttons
         *      Current buttons pressed.
         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
         * @param {OpenSeadragon.Point} event.delta
         *      The x,y components of the difference between the current position and the last drag event position.  Useful for ignoring or weighting the events.
         * @param {Number} event.speed
         *     Current computed speed, in pixels per second.
         * @param {Number} event.direction
         *     Current computed direction, expressed as an angle counterclockwise relative to the positive X axis (-pi to pi, in radians). Only valid if speed > 0.
         * @param {Boolean} event.shift
         *      True if the shift key was pressed during this event.
         * @param {Boolean} event.isTouchEvent
         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        dragHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {String} event.pointerType
         *     "mouse", "touch", "pen", etc.
         * @param {OpenSeadragon.Point} event.position
         *      The position of the event relative to the tracked element.
         * @param {Number} event.speed
         *     Speed at the end of a drag gesture, in pixels per second.
         * @param {Number} event.direction
         *     Direction at the end of a drag gesture, expressed as an angle counterclockwise relative to the positive X axis (-pi to pi, in radians). Only valid if speed > 0.
         * @param {Boolean} event.shift
         *      True if the shift key was pressed during this event.
         * @param {Boolean} event.isTouchEvent
         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        dragEndHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {String} event.pointerType
         *     "mouse", "touch", "pen", etc.
         * @param {Array.<OpenSeadragon.MouseTracker.GesturePoint>} event.gesturePoints
         *      Gesture points associated with the gesture. Velocity data can be found here.
         * @param {OpenSeadragon.Point} event.lastCenter
         *      The previous center point of the two pinch contact points relative to the tracked element.
         * @param {OpenSeadragon.Point} event.center
         *      The center point of the two pinch contact points relative to the tracked element.
         * @param {Number} event.lastDistance
         *      The previous distance between the two pinch contact points in CSS pixels.
         * @param {Number} event.distance
         *      The distance between the two pinch contact points in CSS pixels.
         * @param {Boolean} event.shift
         *      True if the shift key was pressed during this event.
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        pinchHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {String} event.pointerType
         *     "mouse", "touch", "pen", etc.
         * @param {OpenSeadragon.Point} event.position
         *      The position of the event relative to the tracked element.
         * @param {Number} event.buttons
         *      Current buttons pressed.
         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
         * @param {Boolean} event.isTouchEvent
         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        stopHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {Number} event.keyCode
         *      The key code that was pressed.
         * @param {Boolean} event.ctrl
         *      True if the ctrl key was pressed during this event.
         * @param {Boolean} event.shift
         *      True if the shift key was pressed during this event.
         * @param {Boolean} event.alt
         *      True if the alt key was pressed during this event.
         * @param {Boolean} event.meta
         *      True if the meta key was pressed during this event.
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Boolean} event.preventDefault
         *      Set to true to prevent the default user-agent's handling of the keydown event.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        keyDownHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {Number} event.keyCode
         *      The key code that was pressed.
         * @param {Boolean} event.ctrl
         *      True if the ctrl key was pressed during this event.
         * @param {Boolean} event.shift
         *      True if the shift key was pressed during this event.
         * @param {Boolean} event.alt
         *      True if the alt key was pressed during this event.
         * @param {Boolean} event.meta
         *      True if the meta key was pressed during this event.
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Boolean} event.preventDefault
         *      Set to true to prevent the default user-agent's handling of the keyup event.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        keyUpHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {Number} event.keyCode
         *      The key code that was pressed.
         * @param {Boolean} event.ctrl
         *      True if the ctrl key was pressed during this event.
         * @param {Boolean} event.shift
         *      True if the shift key was pressed during this event.
         * @param {Boolean} event.alt
         *      True if the alt key was pressed during this event.
         * @param {Boolean} event.meta
         *      True if the meta key was pressed during this event.
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Boolean} event.preventDefault
         *      Set to true to prevent the default user-agent's handling of the keypress event.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        keyHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        focusHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        blurHandler: function() {
        }
      };
      var i = function() {
        try {
          return window.self !== window.top;
        } catch {
          return !0;
        }
      }();
      function n(b) {
        try {
          return b.addEventListener && b.removeEventListener;
        } catch {
          return !1;
        }
      }
      e.MouseTracker.gesturePointVelocityTracker = /* @__PURE__ */ function() {
        var b = [], _ = 0, T = 0, S = function(Ee, ue) {
          return Ee.hash.toString() + ue.type + ue.id.toString();
        }, q = function() {
          var Ee, ue = b.length, Xe, $, Tt = e.now(), nr, ki, or;
          for (nr = Tt - T, T = Tt, Ee = 0; Ee < ue; Ee++)
            Xe = b[Ee], $ = Xe.gPoint, $.direction = Math.atan2($.currentPos.y - Xe.lastPos.y, $.currentPos.x - Xe.lastPos.x), ki = Xe.lastPos.distanceTo($.currentPos), Xe.lastPos = $.currentPos, or = 1e3 * ki / (nr + 1), $.speed = 0.75 * or + 0.25 * $.speed;
        }, Q = function(Ee, ue) {
          var Xe = S(Ee, ue);
          b.push(
            {
              guid: Xe,
              gPoint: ue,
              lastPos: ue.currentPos
            }
          ), b.length === 1 && (T = e.now(), _ = window.setInterval(q, 50));
        }, Y = function(Ee, ue) {
          var Xe = S(Ee, ue), $, Tt = b.length;
          for ($ = 0; $ < Tt; $++)
            if (b[$].guid === Xe) {
              b.splice($, 1), Tt--, Tt === 0 && window.clearInterval(_);
              break;
            }
        };
        return {
          addPoint: Q,
          removePoint: Y
        };
      }(), e.MouseTracker.captureElement = document, e.MouseTracker.wheelEventName = "onwheel" in document.createElement("div") ? "wheel" : (
        // Modern browsers support 'wheel'
        document.onmousewheel !== void 0 ? "mousewheel" : (
          // Webkit (and unsupported IE) support at least 'mousewheel'
          "DOMMouseScroll"
        )
      ), e.MouseTracker.subscribeEvents = ["click", "dblclick", "keydown", "keyup", "keypress", "focus", "blur", "contextmenu", e.MouseTracker.wheelEventName], e.MouseTracker.wheelEventName === "DOMMouseScroll" && e.MouseTracker.subscribeEvents.push("MozMousePixelScroll"), window.PointerEvent ? (e.MouseTracker.havePointerEvents = !0, e.MouseTracker.subscribeEvents.push("pointerenter", "pointerleave", "pointerover", "pointerout", "pointerdown", "pointerup", "pointermove", "pointercancel"), e.MouseTracker.havePointerCapture = function() {
        var b = document.createElement("div");
        return e.isFunction(b.setPointerCapture) && e.isFunction(b.releasePointerCapture);
      }(), e.MouseTracker.havePointerCapture && e.MouseTracker.subscribeEvents.push("gotpointercapture", "lostpointercapture")) : (e.MouseTracker.havePointerEvents = !1, e.MouseTracker.subscribeEvents.push("mouseenter", "mouseleave", "mouseover", "mouseout", "mousedown", "mouseup", "mousemove"), e.MouseTracker.mousePointerId = "legacy-mouse", e.MouseTracker.havePointerCapture = function() {
        var b = document.createElement("div");
        return e.isFunction(b.setCapture) && e.isFunction(b.releaseCapture);
      }(), e.MouseTracker.havePointerCapture && e.MouseTracker.subscribeEvents.push("losecapture"), "ontouchstart" in window && e.MouseTracker.subscribeEvents.push("touchstart", "touchend", "touchmove", "touchcancel"), "ongesturestart" in window && e.MouseTracker.subscribeEvents.push("gesturestart", "gesturechange")), e.MouseTracker.GesturePointList = function(b) {
        this._gPoints = [], this.type = b, this.buttons = 0, this.contacts = 0, this.clicks = 0, this.captureCount = 0;
      }, e.MouseTracker.GesturePointList.prototype = {
        /**
         * @function
         * @returns {Number} Number of gesture points in the list.
         */
        getLength: function() {
          return this._gPoints.length;
        },
        /**
         * @function
         * @returns {Array.<OpenSeadragon.MouseTracker.GesturePoint>} The list of gesture points in the list as an array (read-only).
         */
        asArray: function() {
          return this._gPoints;
        },
        /**
         * @function
         * @param {OpenSeadragon.MouseTracker.GesturePoint} gesturePoint - A gesture point to add to the list.
         * @returns {Number} Number of gesture points in the list.
         */
        add: function(b) {
          return this._gPoints.push(b);
        },
        /**
         * @function
         * @param {Number} id - The id of the gesture point to remove from the list.
         * @returns {Number} Number of gesture points in the list.
         */
        removeById: function(b) {
          var _, T = this._gPoints.length;
          for (_ = 0; _ < T; _++)
            if (this._gPoints[_].id === b) {
              this._gPoints.splice(_, 1);
              break;
            }
          return this._gPoints.length;
        },
        /**
         * @function
         * @param {Number} index - The index of the gesture point to retrieve from the list.
         * @returns {OpenSeadragon.MouseTracker.GesturePoint|null} The gesture point at the given index, or null if not found.
         */
        getByIndex: function(b) {
          return b < this._gPoints.length ? this._gPoints[b] : null;
        },
        /**
         * @function
         * @param {Number} id - The id of the gesture point to retrieve from the list.
         * @returns {OpenSeadragon.MouseTracker.GesturePoint|null} The gesture point with the given id, or null if not found.
         */
        getById: function(b) {
          var _, T = this._gPoints.length;
          for (_ = 0; _ < T; _++)
            if (this._gPoints[_].id === b)
              return this._gPoints[_];
          return null;
        },
        /**
         * @function
         * @returns {OpenSeadragon.MouseTracker.GesturePoint|null} The primary gesture point in the list, or null if not found.
         */
        getPrimary: function(b) {
          var _, T = this._gPoints.length;
          for (_ = 0; _ < T; _++)
            if (this._gPoints[_].isPrimary)
              return this._gPoints[_];
          return null;
        },
        /**
         * Increment this pointer list's contact count.
         * It will evaluate whether this pointer type is allowed to have multiple contacts.
         * @function
         */
        addContact: function() {
          ++this.contacts, this.contacts > 1 && (this.type === "mouse" || this.type === "pen") && (e.console.warn("GesturePointList.addContact() Implausible contacts value"), this.contacts = 1);
        },
        /**
         * Decrement this pointer list's contact count.
         * It will make sure the count does not go below 0.
         * @function
         */
        removeContact: function() {
          --this.contacts, this.contacts < 0 && (this.contacts = 0);
        }
      };
      function o(b) {
        var _ = t[b.hash], T, S, q, Q, Y, Ee = _.activePointersLists.length;
        for (T = 0; T < Ee; T++)
          if (q = _.activePointersLists[T], q.getLength() > 0) {
            for (Y = [], Q = q.asArray(), S = 0; S < Q.length; S++)
              Y.push(Q[S]);
            for (S = 0; S < Y.length; S++)
              Mt(b, q, Y[S]);
          }
        for (T = 0; T < Ee; T++)
          _.activePointersLists.pop();
        _.sentDragEvent = !1;
      }
      function a(b) {
        var _ = t[b.hash], T, S;
        if (!_.tracking) {
          for (S = 0; S < e.MouseTracker.subscribeEvents.length; S++)
            T = e.MouseTracker.subscribeEvents[S], e.addEvent(
              b.element,
              T,
              _[T],
              T === e.MouseTracker.wheelEventName ? { passive: !1, capture: !1 } : !1
            );
          o(b), _.tracking = !0;
        }
      }
      function l(b) {
        var _ = t[b.hash], T, S;
        if (_.tracking) {
          for (S = 0; S < e.MouseTracker.subscribeEvents.length; S++)
            T = e.MouseTracker.subscribeEvents[S], e.removeEvent(
              b.element,
              T,
              _[T],
              !1
            );
          o(b), _.tracking = !1;
        }
      }
      function h(b, _) {
        var T = t[b.hash];
        if (_ === "pointerevent")
          return {
            upName: "pointerup",
            upHandler: T.pointerupcaptured,
            moveName: "pointermove",
            moveHandler: T.pointermovecaptured
          };
        if (_ === "mouse")
          return {
            upName: "pointerup",
            upHandler: T.pointerupcaptured,
            moveName: "pointermove",
            moveHandler: T.pointermovecaptured
          };
        if (_ === "touch")
          return {
            upName: "touchend",
            upHandler: T.touchendcaptured,
            moveName: "touchmove",
            moveHandler: T.touchmovecaptured
          };
        throw new Error("MouseTracker.getCaptureEventParams: Unknown pointer type.");
      }
      function d(b, _) {
        var T;
        if (e.MouseTracker.havePointerCapture)
          if (e.MouseTracker.havePointerEvents)
            try {
              b.element.setPointerCapture(_.id);
            } catch {
              e.console.warn("setPointerCapture() called on invalid pointer ID");
              return;
            }
          else
            b.element.setCapture(!0);
        else
          T = h(b, e.MouseTracker.havePointerEvents ? "pointerevent" : _.type), i && n(window.top) && e.addEvent(
            window.top,
            T.upName,
            T.upHandler,
            !0
          ), e.addEvent(
            e.MouseTracker.captureElement,
            T.upName,
            T.upHandler,
            !0
          ), e.addEvent(
            e.MouseTracker.captureElement,
            T.moveName,
            T.moveHandler,
            !0
          );
        U(b, _, !0);
      }
      function f(b, _) {
        var T, S, q;
        if (e.MouseTracker.havePointerCapture)
          if (e.MouseTracker.havePointerEvents) {
            if (S = b.getActivePointersListByType(_.type), q = S.getById(_.id), !q || !q.captured)
              return;
            try {
              b.element.releasePointerCapture(_.id);
            } catch {
            }
          } else
            b.element.releaseCapture();
        else
          T = h(b, e.MouseTracker.havePointerEvents ? "pointerevent" : _.type), i && n(window.top) && e.removeEvent(
            window.top,
            T.upName,
            T.upHandler,
            !0
          ), e.removeEvent(
            e.MouseTracker.captureElement,
            T.moveName,
            T.moveHandler,
            !0
          ), e.removeEvent(
            e.MouseTracker.captureElement,
            T.upName,
            T.upHandler,
            !0
          );
        U(b, _, !1);
      }
      function g(b) {
        return e.MouseTracker.havePointerEvents ? b.pointerId : e.MouseTracker.mousePointerId;
      }
      function w(b) {
        return e.MouseTracker.havePointerEvents && b.pointerType ? b.pointerType : "mouse";
      }
      function C(b) {
        return e.MouseTracker.havePointerEvents ? b.isPrimary : !0;
      }
      function E(b) {
        return e.getMousePosition(b);
      }
      function A(b, _) {
        return I(E(b), _);
      }
      function I(b, _) {
        var T = e.getElementOffset(_);
        return b.minus(T);
      }
      function V(b, _) {
        return new e.Point((b.x + _.x) / 2, (b.y + _.y) / 2);
      }
      function K(b, _) {
        var T = {
          originalEvent: _,
          eventType: "click",
          pointerType: "mouse",
          isEmulated: !1
        };
        P(b, T), T.preventDefault && !T.defaultPrevented && e.cancelEvent(_), T.stopPropagation && e.stopEvent(_);
      }
      function ce(b, _) {
        var T = {
          originalEvent: _,
          eventType: "dblclick",
          pointerType: "mouse",
          isEmulated: !1
        };
        P(b, T), T.preventDefault && !T.defaultPrevented && e.cancelEvent(_), T.stopPropagation && e.stopEvent(_);
      }
      function re(b, _) {
        var T = null, S = {
          originalEvent: _,
          eventType: "keydown",
          pointerType: "",
          isEmulated: !1
        };
        P(b, S), b.keyDownHandler && !S.preventGesture && !S.defaultPrevented && (T = {
          eventSource: b,
          keyCode: _.keyCode ? _.keyCode : _.charCode,
          ctrl: _.ctrlKey,
          shift: _.shiftKey,
          alt: _.altKey,
          meta: _.metaKey,
          originalEvent: _,
          preventDefault: S.preventDefault || S.defaultPrevented,
          userData: b.userData
        }, b.keyDownHandler(T)), (T && T.preventDefault || S.preventDefault && !S.defaultPrevented) && e.cancelEvent(_), S.stopPropagation && e.stopEvent(_);
      }
      function he(b, _) {
        var T = null, S = {
          originalEvent: _,
          eventType: "keyup",
          pointerType: "",
          isEmulated: !1
        };
        P(b, S), b.keyUpHandler && !S.preventGesture && !S.defaultPrevented && (T = {
          eventSource: b,
          keyCode: _.keyCode ? _.keyCode : _.charCode,
          ctrl: _.ctrlKey,
          shift: _.shiftKey,
          alt: _.altKey,
          meta: _.metaKey,
          originalEvent: _,
          preventDefault: S.preventDefault || S.defaultPrevented,
          userData: b.userData
        }, b.keyUpHandler(T)), (T && T.preventDefault || S.preventDefault && !S.defaultPrevented) && e.cancelEvent(_), S.stopPropagation && e.stopEvent(_);
      }
      function pe(b, _) {
        var T = null, S = {
          originalEvent: _,
          eventType: "keypress",
          pointerType: "",
          isEmulated: !1
        };
        P(b, S), b.keyHandler && !S.preventGesture && !S.defaultPrevented && (T = {
          eventSource: b,
          keyCode: _.keyCode ? _.keyCode : _.charCode,
          ctrl: _.ctrlKey,
          shift: _.shiftKey,
          alt: _.altKey,
          meta: _.metaKey,
          originalEvent: _,
          preventDefault: S.preventDefault || S.defaultPrevented,
          userData: b.userData
        }, b.keyHandler(T)), (T && T.preventDefault || S.preventDefault && !S.defaultPrevented) && e.cancelEvent(_), S.stopPropagation && e.stopEvent(_);
      }
      function Te(b, _) {
        var T = {
          originalEvent: _,
          eventType: "focus",
          pointerType: "",
          isEmulated: !1
        };
        P(b, T), b.focusHandler && !T.preventGesture && b.focusHandler(
          {
            eventSource: b,
            originalEvent: _,
            userData: b.userData
          }
        );
      }
      function Ae(b, _) {
        var T = {
          originalEvent: _,
          eventType: "blur",
          pointerType: "",
          isEmulated: !1
        };
        P(b, T), b.blurHandler && !T.preventGesture && b.blurHandler(
          {
            eventSource: b,
            originalEvent: _,
            userData: b.userData
          }
        );
      }
      function He(b, _) {
        var T = null, S = {
          originalEvent: _,
          eventType: "contextmenu",
          pointerType: "mouse",
          isEmulated: !1
        };
        P(b, S), b.contextMenuHandler && !S.preventGesture && !S.defaultPrevented && (T = {
          eventSource: b,
          position: I(E(_), b.element),
          originalEvent: S.originalEvent,
          preventDefault: S.preventDefault || S.defaultPrevented,
          userData: b.userData
        }, b.contextMenuHandler(T)), (T && T.preventDefault || S.preventDefault && !S.defaultPrevented) && e.cancelEvent(_), S.stopPropagation && e.stopEvent(_);
      }
      function Fe(b, _) {
        Re(b, _, _);
      }
      function ve(b, _) {
        var T = {
          target: _.target || _.srcElement,
          type: "wheel",
          shiftKey: _.shiftKey || !1,
          clientX: _.clientX,
          clientY: _.clientY,
          pageX: _.pageX ? _.pageX : _.clientX,
          pageY: _.pageY ? _.pageY : _.clientY,
          deltaMode: _.type === "MozMousePixelScroll" ? 0 : 1,
          // 0=pixel, 1=line, 2=page
          deltaX: 0,
          deltaZ: 0
        };
        e.MouseTracker.wheelEventName === "mousewheel" ? T.deltaY = -_.wheelDelta / e.DEFAULT_SETTINGS.pixelsPerWheelLine : T.deltaY = _.detail, Re(b, T, _);
      }
      function Re(b, _, T) {
        var S = 0, q, Q = null;
        S = _.deltaY ? _.deltaY < 0 ? 1 : -1 : 0, q = {
          originalEvent: _,
          eventType: "wheel",
          pointerType: "mouse",
          isEmulated: _ !== T
        }, P(b, q), b.scrollHandler && !q.preventGesture && !q.defaultPrevented && (Q = {
          eventSource: b,
          pointerType: "mouse",
          position: A(_, b.element),
          scroll: S,
          shift: _.shiftKey,
          isTouchEvent: !1,
          originalEvent: T,
          preventDefault: q.preventDefault || q.defaultPrevented,
          userData: b.userData
        }, b.scrollHandler(Q)), q.stopPropagation && e.stopEvent(T), (Q && Q.preventDefault || q.preventDefault && !q.defaultPrevented) && e.cancelEvent(T);
      }
      function Ze(b, _) {
        var T = {
          id: e.MouseTracker.mousePointerId,
          type: "mouse"
        }, S = {
          originalEvent: _,
          eventType: "lostpointercapture",
          pointerType: "mouse",
          isEmulated: !1
        };
        P(b, S), _.target === b.element && U(b, T, !1), S.stopPropagation && e.stopEvent(_);
      }
      function Ue(b, _) {
        var T, S, q = _.changedTouches.length, Q, Y = b.getActivePointersListByType("touch");
        T = e.now(), Y.getLength() > _.touches.length - q && e.console.warn("Tracked touch contact count doesn't match event.touches.length");
        var Ee = {
          originalEvent: _,
          eventType: "pointerdown",
          pointerType: "touch",
          isEmulated: !1
        };
        for (P(b, Ee), S = 0; S < q; S++)
          Q = {
            id: _.changedTouches[S].identifier,
            type: "touch",
            // Simulate isPrimary
            isPrimary: Y.getLength() === 0,
            currentPos: E(_.changedTouches[S]),
            currentTime: T
          }, J(b, Ee, Q), me(b, Ee, Q, 0), U(b, Q, !0);
        Ee.preventDefault && !Ee.defaultPrevented && e.cancelEvent(_), Ee.stopPropagation && e.stopEvent(_);
      }
      function We(b, _) {
        var T, S, q = _.changedTouches.length, Q;
        T = e.now();
        var Y = {
          originalEvent: _,
          eventType: "pointerup",
          pointerType: "touch",
          isEmulated: !1
        };
        for (P(b, Y), S = 0; S < q; S++)
          Q = {
            id: _.changedTouches[S].identifier,
            type: "touch",
            currentPos: E(_.changedTouches[S]),
            currentTime: T
          }, Ce(b, Y, Q, 0), U(b, Q, !1), ie(b, Y, Q);
        Y.preventDefault && !Y.defaultPrevented && e.cancelEvent(_), Y.stopPropagation && e.stopEvent(_);
      }
      function it(b, _) {
        var T, S, q = _.changedTouches.length, Q;
        T = e.now();
        var Y = {
          originalEvent: _,
          eventType: "pointermove",
          pointerType: "touch",
          isEmulated: !1
        };
        for (P(b, Y), S = 0; S < q; S++)
          Q = {
            id: _.changedTouches[S].identifier,
            type: "touch",
            currentPos: E(_.changedTouches[S]),
            currentTime: T
          }, Se(b, Y, Q);
        Y.preventDefault && !Y.defaultPrevented && e.cancelEvent(_), Y.stopPropagation && e.stopEvent(_);
      }
      function Ve(b, _) {
        var T = _.changedTouches.length, S, q, Q = {
          originalEvent: _,
          eventType: "pointercancel",
          pointerType: "touch",
          isEmulated: !1
        };
        for (P(b, Q), S = 0; S < T; S++)
          q = {
            id: _.changedTouches[S].identifier,
            type: "touch"
          }, ge(b, Q, q);
        Q.stopPropagation && e.stopEvent(_);
      }
      function rt(b, _) {
        return e.eventIsCanceled(_) || _.preventDefault(), !1;
      }
      function Ye(b, _) {
        return e.eventIsCanceled(_) || _.preventDefault(), !1;
      }
      function ti(b, _) {
        var T = {
          originalEvent: _,
          eventType: "gotpointercapture",
          pointerType: w(_),
          isEmulated: !1
        };
        P(b, T), _.target === b.element && U(b, {
          id: _.pointerId,
          type: w(_)
        }, !0), T.stopPropagation && e.stopEvent(_);
      }
      function ir(b, _) {
        var T = {
          originalEvent: _,
          eventType: "lostpointercapture",
          pointerType: w(_),
          isEmulated: !1
        };
        P(b, T), _.target === b.element && U(b, {
          id: _.pointerId,
          type: w(_)
        }, !1), T.stopPropagation && e.stopEvent(_);
      }
      function _e(b, _) {
        var T = {
          id: g(_),
          type: w(_),
          isPrimary: C(_),
          currentPos: E(_),
          currentTime: e.now()
        }, S = {
          originalEvent: _,
          eventType: "pointerenter",
          pointerType: T.type,
          isEmulated: !1
        };
        P(b, S), J(b, S, T);
      }
      function ii(b, _) {
        var T = {
          id: g(_),
          type: w(_),
          isPrimary: C(_),
          currentPos: E(_),
          currentTime: e.now()
        }, S = {
          originalEvent: _,
          eventType: "pointerleave",
          pointerType: T.type,
          isEmulated: !1
        };
        P(b, S), ie(b, S, T);
      }
      function kt(b, _) {
        var T = {
          id: g(_),
          type: w(_),
          isPrimary: C(_),
          currentPos: E(_),
          currentTime: e.now()
        }, S = {
          originalEvent: _,
          eventType: "pointerover",
          pointerType: T.type,
          isEmulated: !1
        };
        P(b, S), de(b, S, T), S.preventDefault && !S.defaultPrevented && e.cancelEvent(_), S.stopPropagation && e.stopEvent(_);
      }
      function _t(b, _) {
        var T = {
          id: g(_),
          type: w(_),
          isPrimary: C(_),
          currentPos: E(_),
          currentTime: e.now()
        }, S = {
          originalEvent: _,
          eventType: "pointerout",
          pointerType: T.type,
          isEmulated: !1
        };
        P(b, S), X(b, S, T), S.preventDefault && !S.defaultPrevented && e.cancelEvent(_), S.stopPropagation && e.stopEvent(_);
      }
      function xt(b, _) {
        var T = {
          id: g(_),
          type: w(_),
          isPrimary: C(_),
          currentPos: E(_),
          currentTime: e.now()
        }, S = e.MouseTracker.havePointerEvents && T.type === "touch", q = {
          originalEvent: _,
          eventType: "pointerdown",
          pointerType: T.type,
          isEmulated: !1
        };
        P(b, q), me(b, q, T, _.button), q.preventDefault && !q.defaultPrevented && e.cancelEvent(_), q.stopPropagation && e.stopEvent(_), q.shouldCapture && (S ? U(b, T, !0) : d(b, T));
      }
      function Si(b, _) {
        ri(b, _);
      }
      function fe(b, _) {
        var T = b.getActivePointersListByType(w(_));
        T.getById(_.pointerId) && ri(b, _), e.stopEvent(_);
      }
      function ri(b, _) {
        var T;
        T = {
          id: g(_),
          type: w(_),
          isPrimary: C(_),
          currentPos: E(_),
          currentTime: e.now()
        };
        var S = {
          originalEvent: _,
          eventType: "pointerup",
          pointerType: T.type,
          isEmulated: !1
        };
        P(b, S), Ce(b, S, T, _.button), S.preventDefault && !S.defaultPrevented && e.cancelEvent(_), S.stopPropagation && e.stopEvent(_), S.shouldReleaseCapture && (_.target === b.element ? f(b, T) : U(b, T, !1));
      }
      function At(b, _) {
        Ct(b, _);
      }
      function Ie(b, _) {
        var T = b.getActivePointersListByType(w(_));
        T.getById(_.pointerId) && Ct(b, _), e.stopEvent(_);
      }
      function Ct(b, _) {
        var T = {
          id: g(_),
          type: w(_),
          isPrimary: C(_),
          currentPos: E(_),
          currentTime: e.now()
        }, S = {
          originalEvent: _,
          eventType: "pointermove",
          pointerType: T.type,
          isEmulated: !1
        };
        P(b, S), Se(b, S, T), S.preventDefault && !S.defaultPrevented && e.cancelEvent(_), S.stopPropagation && e.stopEvent(_);
      }
      function rr(b, _) {
        var T = {
          id: _.pointerId,
          type: w(_)
        }, S = {
          originalEvent: _,
          eventType: "pointercancel",
          pointerType: T.type,
          isEmulated: !1
        };
        P(b, S), ge(b, S, T), S.stopPropagation && e.stopEvent(_);
      }
      function ut(b, _) {
        return _.speed = 0, _.direction = 0, _.contactPos = _.currentPos, _.contactTime = _.currentTime, _.lastPos = _.currentPos, _.lastTime = _.currentTime, b.add(_);
      }
      function Mt(b, _, T) {
        var S, q = _.getById(T.id);
        return q ? (q.captured && (e.console.warn("stopTrackingPointer() called on captured pointer"), f(b, q)), _.removeContact(), S = _.removeById(T.id)) : S = _.getLength(), S;
      }
      function m(b, _) {
        switch (_.eventType) {
          case "pointermove":
            _.isStoppable = !0, _.isCancelable = !0, _.preventDefault = !1, _.preventGesture = !b.hasGestureHandlers, _.stopPropagation = !1;
            break;
          case "pointerover":
          case "pointerout":
          case "contextmenu":
          case "keydown":
          case "keyup":
          case "keypress":
            _.isStoppable = !0, _.isCancelable = !0, _.preventDefault = !1, _.preventGesture = !1, _.stopPropagation = !1;
            break;
          case "pointerdown":
            _.isStoppable = !0, _.isCancelable = !0, _.preventDefault = !1, _.preventGesture = !b.hasGestureHandlers, _.stopPropagation = !1;
            break;
          case "pointerup":
            _.isStoppable = !0, _.isCancelable = !0, _.preventDefault = !1, _.preventGesture = !b.hasGestureHandlers, _.stopPropagation = !1;
            break;
          case "wheel":
            _.isStoppable = !0, _.isCancelable = !0, _.preventDefault = !1, _.preventGesture = !b.hasScrollHandler, _.stopPropagation = !1;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
            _.isStoppable = !0, _.isCancelable = !1, _.preventDefault = !1, _.preventGesture = !1, _.stopPropagation = !1;
            break;
          case "click":
            _.isStoppable = !0, _.isCancelable = !0, _.preventDefault = !!b.clickHandler, _.preventGesture = !1, _.stopPropagation = !1;
            break;
          case "dblclick":
            _.isStoppable = !0, _.isCancelable = !0, _.preventDefault = !!b.dblClickHandler, _.preventGesture = !1, _.stopPropagation = !1;
            break;
          case "focus":
          case "blur":
          case "pointerenter":
          case "pointerleave":
          default:
            _.isStoppable = !1, _.isCancelable = !1, _.preventDefault = !1, _.preventGesture = !1, _.stopPropagation = !1;
            break;
        }
      }
      function P(b, _) {
        _.eventSource = b, _.eventPhase = _.originalEvent && typeof _.originalEvent.eventPhase < "u" ? _.originalEvent.eventPhase : 0, _.defaultPrevented = e.eventIsCanceled(_.originalEvent), _.shouldCapture = !1, _.shouldReleaseCapture = !1, _.userData = b.userData, m(b, _), b.preProcessEventHandler && b.preProcessEventHandler(_);
      }
      function U(b, _, T) {
        var S = b.getActivePointersListByType(_.type), q = S.getById(_.id);
        q ? T && !q.captured ? (q.captured = !0, S.captureCount++) : !T && q.captured && (q.captured = !1, S.captureCount--, S.captureCount < 0 && (S.captureCount = 0, e.console.warn("updatePointerCaptured() - pointsList.captureCount went negative"))) : e.console.warn("updatePointerCaptured() called on untracked pointer");
      }
      function J(b, _, T) {
        var S = b.getActivePointersListByType(T.type), q;
        q = S.getById(T.id), q ? (q.insideElement = !0, q.lastPos = q.currentPos, q.lastTime = q.currentTime, q.currentPos = T.currentPos, q.currentTime = T.currentTime, T = q) : (T.captured = !1, T.insideElementPressed = !1, T.insideElement = !0, ut(S, T)), b.enterHandler && b.enterHandler(
          {
            eventSource: b,
            pointerType: T.type,
            position: I(T.currentPos, b.element),
            buttons: S.buttons,
            pointers: b.getActivePointerCount(),
            insideElementPressed: T.insideElementPressed,
            buttonDownAny: S.buttons !== 0,
            isTouchEvent: T.type === "touch",
            originalEvent: _.originalEvent,
            userData: b.userData
          }
        );
      }
      function ie(b, _, T) {
        var S = b.getActivePointersListByType(T.type), q, Q;
        q = S.getById(T.id), q ? (q.captured ? (q.insideElement = !1, q.lastPos = q.currentPos, q.lastTime = q.currentTime, q.currentPos = T.currentPos, q.currentTime = T.currentTime) : Mt(b, S, q), T = q) : (T.captured = !1, T.insideElementPressed = !1), (b.leaveHandler || b.exitHandler) && (Q = {
          eventSource: b,
          pointerType: T.type,
          // GitHub PR: https://github.com/openseadragon/openseadragon/pull/1754 (gPoint.currentPos && )
          position: T.currentPos && I(T.currentPos, b.element),
          buttons: S.buttons,
          pointers: b.getActivePointerCount(),
          insideElementPressed: T.insideElementPressed,
          buttonDownAny: S.buttons !== 0,
          isTouchEvent: T.type === "touch",
          originalEvent: _.originalEvent,
          userData: b.userData
        }, b.leaveHandler && b.leaveHandler(Q), b.exitHandler && b.exitHandler(Q));
      }
      function de(b, _, T) {
        var S, q;
        S = b.getActivePointersListByType(T.type), q = S.getById(T.id), q ? T = q : (T.captured = !1, T.insideElementPressed = !1), b.overHandler && b.overHandler(
          {
            eventSource: b,
            pointerType: T.type,
            position: I(T.currentPos, b.element),
            buttons: S.buttons,
            pointers: b.getActivePointerCount(),
            insideElementPressed: T.insideElementPressed,
            buttonDownAny: S.buttons !== 0,
            isTouchEvent: T.type === "touch",
            originalEvent: _.originalEvent,
            userData: b.userData
          }
        );
      }
      function X(b, _, T) {
        var S, q;
        S = b.getActivePointersListByType(T.type), q = S.getById(T.id), q ? T = q : (T.captured = !1, T.insideElementPressed = !1), b.outHandler && b.outHandler({
          eventSource: b,
          pointerType: T.type,
          position: T.currentPos && I(T.currentPos, b.element),
          buttons: S.buttons,
          pointers: b.getActivePointerCount(),
          insideElementPressed: T.insideElementPressed,
          buttonDownAny: S.buttons !== 0,
          isTouchEvent: T.type === "touch",
          originalEvent: _.originalEvent,
          userData: b.userData
        });
      }
      function me(b, _, T, S) {
        var q = t[b.hash], Q = b.getActivePointersListByType(T.type), Y;
        if (typeof _.originalEvent.buttons < "u" ? Q.buttons = _.originalEvent.buttons : S === 0 ? Q.buttons |= 1 : S === 1 ? Q.buttons |= 4 : S === 2 ? Q.buttons |= 2 : S === 3 ? Q.buttons |= 8 : S === 4 ? Q.buttons |= 16 : S === 5 && (Q.buttons |= 32), S !== 0) {
          _.shouldCapture = !1, _.shouldReleaseCapture = !1, b.nonPrimaryPressHandler && !_.preventGesture && !_.defaultPrevented && (_.preventDefault = !0, b.nonPrimaryPressHandler(
            {
              eventSource: b,
              pointerType: T.type,
              position: I(T.currentPos, b.element),
              button: S,
              buttons: Q.buttons,
              isTouchEvent: T.type === "touch",
              originalEvent: _.originalEvent,
              userData: b.userData
            }
          ));
          return;
        }
        Y = Q.getById(T.id), Y ? (Y.insideElementPressed = !0, Y.insideElement = !0, Y.originalTarget = _.originalEvent.target, Y.contactPos = T.currentPos, Y.contactTime = T.currentTime, Y.lastPos = Y.currentPos, Y.lastTime = Y.currentTime, Y.currentPos = T.currentPos, Y.currentTime = T.currentTime, T = Y) : (T.captured = !1, T.insideElementPressed = !0, T.insideElement = !0, T.originalTarget = _.originalEvent.target, ut(Q, T)), Q.addContact(), !_.preventGesture && !_.defaultPrevented ? (_.shouldCapture = !0, _.shouldReleaseCapture = !1, _.preventDefault = !0, (b.dragHandler || b.dragEndHandler || b.pinchHandler) && e.MouseTracker.gesturePointVelocityTracker.addPoint(b, T), Q.contacts === 1 ? b.pressHandler && !_.preventGesture && b.pressHandler(
          {
            eventSource: b,
            pointerType: T.type,
            position: I(T.contactPos, b.element),
            buttons: Q.buttons,
            isTouchEvent: T.type === "touch",
            originalEvent: _.originalEvent,
            userData: b.userData
          }
        ) : Q.contacts === 2 && b.pinchHandler && T.type === "touch" && (q.pinchGPoints = Q.asArray(), q.lastPinchDist = q.currentPinchDist = q.pinchGPoints[0].currentPos.distanceTo(q.pinchGPoints[1].currentPos), q.lastPinchCenter = q.currentPinchCenter = V(q.pinchGPoints[0].currentPos, q.pinchGPoints[1].currentPos))) : (_.shouldCapture = !1, _.shouldReleaseCapture = !1);
      }
      function Ce(b, _, T, S) {
        var q = t[b.hash], Q = b.getActivePointersListByType(T.type), Y, Ee, ue, Xe = !1, $;
        if (typeof _.originalEvent.buttons < "u" ? Q.buttons = _.originalEvent.buttons : S === 0 ? Q.buttons ^= -2 : S === 1 ? Q.buttons ^= -5 : S === 2 ? Q.buttons ^= -3 : S === 3 ? Q.buttons ^= -9 : S === 4 ? Q.buttons ^= -17 : S === 5 && (Q.buttons ^= -33), _.shouldCapture = !1, S !== 0) {
          _.shouldReleaseCapture = !1, b.nonPrimaryReleaseHandler && !_.preventGesture && !_.defaultPrevented && (_.preventDefault = !0, b.nonPrimaryReleaseHandler(
            {
              eventSource: b,
              pointerType: T.type,
              position: I(T.currentPos, b.element),
              button: S,
              buttons: Q.buttons,
              isTouchEvent: T.type === "touch",
              originalEvent: _.originalEvent,
              userData: b.userData
            }
          ));
          return;
        }
        ue = Q.getById(T.id), ue ? (Q.removeContact(), ue.captured && (Xe = !0), ue.lastPos = ue.currentPos, ue.lastTime = ue.currentTime, ue.currentPos = T.currentPos, ue.currentTime = T.currentTime, ue.insideElement || Mt(b, Q, ue), Y = ue.currentPos, Ee = ue.currentTime) : (T.captured = !1, T.insideElementPressed = !1, T.insideElement = !0, ut(Q, T), ue = T), !_.preventGesture && !_.defaultPrevented && (Xe ? (_.shouldReleaseCapture = !0, _.preventDefault = !0, (b.dragHandler || b.dragEndHandler || b.pinchHandler) && e.MouseTracker.gesturePointVelocityTracker.removePoint(b, ue), Q.contacts === 0 ? (b.releaseHandler && Y && b.releaseHandler(
          {
            eventSource: b,
            pointerType: ue.type,
            position: I(Y, b.element),
            buttons: Q.buttons,
            insideElementPressed: ue.insideElementPressed,
            insideElementReleased: ue.insideElement,
            isTouchEvent: ue.type === "touch",
            originalEvent: _.originalEvent,
            userData: b.userData
          }
        ), b.dragEndHandler && q.sentDragEvent && b.dragEndHandler(
          {
            eventSource: b,
            pointerType: ue.type,
            position: I(ue.currentPos, b.element),
            speed: ue.speed,
            direction: ue.direction,
            shift: _.originalEvent.shiftKey,
            isTouchEvent: ue.type === "touch",
            originalEvent: _.originalEvent,
            userData: b.userData
          }
        ), q.sentDragEvent = !1, (b.clickHandler || b.dblClickHandler) && ue.insideElement && ($ = Ee - ue.contactTime <= b.clickTimeThreshold && ue.contactPos.distanceTo(Y) <= b.clickDistThreshold, b.clickHandler && b.clickHandler(
          {
            eventSource: b,
            pointerType: ue.type,
            position: I(ue.currentPos, b.element),
            quick: $,
            shift: _.originalEvent.shiftKey,
            isTouchEvent: ue.type === "touch",
            originalEvent: _.originalEvent,
            originalTarget: ue.originalTarget,
            userData: b.userData
          }
        ), b.dblClickHandler && $ && (Q.clicks++, Q.clicks === 1 ? (q.lastClickPos = Y, q.dblClickTimeOut = setTimeout(function() {
          Q.clicks = 0;
        }, b.dblClickTimeThreshold)) : Q.clicks === 2 && (clearTimeout(q.dblClickTimeOut), Q.clicks = 0, q.lastClickPos.distanceTo(Y) <= b.dblClickDistThreshold && b.dblClickHandler(
          {
            eventSource: b,
            pointerType: ue.type,
            position: I(ue.currentPos, b.element),
            shift: _.originalEvent.shiftKey,
            isTouchEvent: ue.type === "touch",
            originalEvent: _.originalEvent,
            userData: b.userData
          }
        ), q.lastClickPos = null)))) : Q.contacts === 2 && b.pinchHandler && ue.type === "touch" && (q.pinchGPoints = Q.asArray(), q.lastPinchDist = q.currentPinchDist = q.pinchGPoints[0].currentPos.distanceTo(q.pinchGPoints[1].currentPos), q.lastPinchCenter = q.currentPinchCenter = V(q.pinchGPoints[0].currentPos, q.pinchGPoints[1].currentPos))) : (_.shouldReleaseCapture = !1, b.releaseHandler && Y && (b.releaseHandler(
          {
            eventSource: b,
            pointerType: ue.type,
            position: I(Y, b.element),
            buttons: Q.buttons,
            insideElementPressed: ue.insideElementPressed,
            insideElementReleased: ue.insideElement,
            isTouchEvent: ue.type === "touch",
            originalEvent: _.originalEvent,
            userData: b.userData
          }
        ), _.preventDefault = !0)));
      }
      function Se(b, _, T) {
        var S = t[b.hash], q = b.getActivePointersListByType(T.type), Q, Y, Ee;
        if (typeof _.originalEvent.buttons < "u" && (q.buttons = _.originalEvent.buttons), Q = q.getById(T.id), Q)
          Q.lastPos = Q.currentPos, Q.lastTime = Q.currentTime, Q.currentPos = T.currentPos, Q.currentTime = T.currentTime;
        else
          return;
        _.shouldCapture = !1, _.shouldReleaseCapture = !1, b.stopHandler && T.type === "mouse" && (clearTimeout(b.stopTimeOut), b.stopTimeOut = setTimeout(function() {
          Me(b, _.originalEvent, T.type);
        }, b.stopDelay)), q.contacts === 0 ? b.moveHandler && b.moveHandler(
          {
            eventSource: b,
            pointerType: T.type,
            position: I(T.currentPos, b.element),
            buttons: q.buttons,
            isTouchEvent: T.type === "touch",
            originalEvent: _.originalEvent,
            userData: b.userData
          }
        ) : q.contacts === 1 ? (b.moveHandler && (Q = q.asArray()[0], b.moveHandler(
          {
            eventSource: b,
            pointerType: Q.type,
            position: I(Q.currentPos, b.element),
            buttons: q.buttons,
            isTouchEvent: Q.type === "touch",
            originalEvent: _.originalEvent,
            userData: b.userData
          }
        )), b.dragHandler && !_.preventGesture && !_.defaultPrevented && (Q = q.asArray()[0], Ee = Q.currentPos.minus(Q.lastPos), b.dragHandler(
          {
            eventSource: b,
            pointerType: Q.type,
            position: I(Q.currentPos, b.element),
            buttons: q.buttons,
            delta: Ee,
            speed: Q.speed,
            direction: Q.direction,
            shift: _.originalEvent.shiftKey,
            isTouchEvent: Q.type === "touch",
            originalEvent: _.originalEvent,
            userData: b.userData
          }
        ), _.preventDefault = !0, S.sentDragEvent = !0)) : q.contacts === 2 && (b.moveHandler && (Y = q.asArray(), b.moveHandler(
          {
            eventSource: b,
            pointerType: Y[0].type,
            position: I(V(Y[0].currentPos, Y[1].currentPos), b.element),
            buttons: q.buttons,
            isTouchEvent: Y[0].type === "touch",
            originalEvent: _.originalEvent,
            userData: b.userData
          }
        )), b.pinchHandler && T.type === "touch" && !_.preventGesture && !_.defaultPrevented && (Ee = S.pinchGPoints[0].currentPos.distanceTo(S.pinchGPoints[1].currentPos), Ee !== S.currentPinchDist && (S.lastPinchDist = S.currentPinchDist, S.currentPinchDist = Ee, S.lastPinchCenter = S.currentPinchCenter, S.currentPinchCenter = V(S.pinchGPoints[0].currentPos, S.pinchGPoints[1].currentPos), b.pinchHandler(
          {
            eventSource: b,
            pointerType: "touch",
            gesturePoints: S.pinchGPoints,
            lastCenter: I(S.lastPinchCenter, b.element),
            center: I(S.currentPinchCenter, b.element),
            lastDistance: S.lastPinchDist,
            distance: S.currentPinchDist,
            shift: _.originalEvent.shiftKey,
            originalEvent: _.originalEvent,
            userData: b.userData
          }
        ), _.preventDefault = !0)));
      }
      function ge(b, _, T) {
        var S = b.getActivePointersListByType(T.type), q;
        q = S.getById(T.id), q && Mt(b, S, q);
      }
      function Me(b, _, T) {
        b.stopHandler && b.stopHandler({
          eventSource: b,
          pointerType: T,
          position: A(_, b.element),
          buttons: b.getActivePointersListByType(T).buttons,
          isTouchEvent: T === "touch",
          originalEvent: _,
          userData: b.userData
        });
      }
    }(r), function(e) {
      e.ControlAnchor = {
        NONE: 0,
        TOP_LEFT: 1,
        TOP_RIGHT: 2,
        BOTTOM_RIGHT: 3,
        BOTTOM_LEFT: 4,
        ABSOLUTE: 5
      }, e.Control = function(t, i, n) {
        var o = t.parentNode;
        typeof i == "number" && (e.console.error("Passing an anchor directly into the OpenSeadragon.Control constructor is deprecated; please use an options object instead.  Support for this deprecated variant is scheduled for removal in December 2013"), i = { anchor: i }), i.attachToViewer = typeof i.attachToViewer > "u" ? !0 : i.attachToViewer, this.autoFade = typeof i.autoFade > "u" ? !0 : i.autoFade, this.element = t, this.anchor = i.anchor, this.container = n, this.anchor === e.ControlAnchor.ABSOLUTE ? (this.wrapper = e.makeNeutralElement("div"), this.wrapper.style.position = "absolute", this.wrapper.style.top = typeof i.top == "number" ? i.top + "px" : i.top, this.wrapper.style.left = typeof i.left == "number" ? i.left + "px" : i.left, this.wrapper.style.height = typeof i.height == "number" ? i.height + "px" : i.height, this.wrapper.style.width = typeof i.width == "number" ? i.width + "px" : i.width, this.wrapper.style.margin = "0px", this.wrapper.style.padding = "0px", this.element.style.position = "relative", this.element.style.top = "0px", this.element.style.left = "0px", this.element.style.height = "100%", this.element.style.width = "100%") : (this.wrapper = e.makeNeutralElement("div"), this.wrapper.style.display = "inline-block", this.anchor === e.ControlAnchor.NONE && (this.wrapper.style.width = this.wrapper.style.height = "100%")), this.wrapper.appendChild(this.element), i.attachToViewer ? this.anchor === e.ControlAnchor.TOP_RIGHT || this.anchor === e.ControlAnchor.BOTTOM_RIGHT ? this.container.insertBefore(
          this.wrapper,
          this.container.firstChild
        ) : this.container.appendChild(this.wrapper) : o.appendChild(this.wrapper);
      }, e.Control.prototype = {
        /**
         * Removes the control from the container.
         * @function
         */
        destroy: function() {
          this.wrapper.removeChild(this.element), this.anchor !== e.ControlAnchor.NONE && this.container.removeChild(this.wrapper);
        },
        /**
         * Determines if the control is currently visible.
         * @function
         * @returns {Boolean} true if currently visible, false otherwise.
         */
        isVisible: function() {
          return this.wrapper.style.display !== "none";
        },
        /**
         * Toggles the visibility of the control.
         * @function
         * @param {Boolean} visible - true to make visible, false to hide.
         */
        setVisible: function(t) {
          this.wrapper.style.display = t ? this.anchor === e.ControlAnchor.ABSOLUTE ? "block" : "inline-block" : "none";
        },
        /**
         * Sets the opacity level for the control.
         * @function
         * @param {Number} opactiy - a value between 1 and 0 inclusively.
         */
        setOpacity: function(t) {
          e.setElementOpacity(this.wrapper, t, !0);
        }
      };
    }(r), function(e) {
      e.ControlDock = function(i) {
        var n = ["topleft", "topright", "bottomright", "bottomleft"], o, a;
        for (e.extend(!0, this, {
          id: "controldock-" + e.now() + "-" + Math.floor(Math.random() * 1e6),
          container: e.makeNeutralElement("div"),
          controls: []
        }, i), this.container.onsubmit = function() {
          return !1;
        }, this.element && (this.element = e.getElement(this.element), this.element.appendChild(this.container), e.getElementStyle(this.element).position === "static" && (this.element.style.position = "relative"), this.container.style.width = "100%", this.container.style.height = "100%"), a = 0; a < n.length; a++)
          o = n[a], this.controls[o] = e.makeNeutralElement("div"), this.controls[o].style.position = "absolute", o.match("left") && (this.controls[o].style.left = "0px"), o.match("right") && (this.controls[o].style.right = "0px"), o.match("top") && (this.controls[o].style.top = "0px"), o.match("bottom") && (this.controls[o].style.bottom = "0px");
        this.container.appendChild(this.controls.topleft), this.container.appendChild(this.controls.topright), this.container.appendChild(this.controls.bottomright), this.container.appendChild(this.controls.bottomleft);
      }, e.ControlDock.prototype = {
        /**
         * @function
         */
        addControl: function(i, n) {
          i = e.getElement(i);
          var o = null;
          if (!(t(this, i) >= 0)) {
            switch (n.anchor) {
              case e.ControlAnchor.TOP_RIGHT:
                o = this.controls.topright, i.style.position = "relative", i.style.paddingRight = "0px", i.style.paddingTop = "0px";
                break;
              case e.ControlAnchor.BOTTOM_RIGHT:
                o = this.controls.bottomright, i.style.position = "relative", i.style.paddingRight = "0px", i.style.paddingBottom = "0px";
                break;
              case e.ControlAnchor.BOTTOM_LEFT:
                o = this.controls.bottomleft, i.style.position = "relative", i.style.paddingLeft = "0px", i.style.paddingBottom = "0px";
                break;
              case e.ControlAnchor.TOP_LEFT:
                o = this.controls.topleft, i.style.position = "relative", i.style.paddingLeft = "0px", i.style.paddingTop = "0px";
                break;
              case e.ControlAnchor.ABSOLUTE:
                o = this.container, i.style.margin = "0px", i.style.padding = "0px";
                break;
              default:
              case e.ControlAnchor.NONE:
                o = this.container, i.style.margin = "0px", i.style.padding = "0px";
                break;
            }
            this.controls.push(
              new e.Control(i, n, o)
            ), i.style.display = "inline-block";
          }
        },
        /**
         * @function
         * @returns {OpenSeadragon.ControlDock} Chainable.
         */
        removeControl: function(i) {
          i = e.getElement(i);
          var n = t(this, i);
          return n >= 0 && (this.controls[n].destroy(), this.controls.splice(n, 1)), this;
        },
        /**
         * @function
         * @returns {OpenSeadragon.ControlDock} Chainable.
         */
        clearControls: function() {
          for (; this.controls.length > 0; )
            this.controls.pop().destroy();
          return this;
        },
        /**
         * @function
         * @returns {Boolean}
         */
        areControlsEnabled: function() {
          var i;
          for (i = this.controls.length - 1; i >= 0; i--)
            if (this.controls[i].isVisible())
              return !0;
          return !1;
        },
        /**
         * @function
         * @returns {OpenSeadragon.ControlDock} Chainable.
         */
        setControlsEnabled: function(i) {
          var n;
          for (n = this.controls.length - 1; n >= 0; n--)
            this.controls[n].setVisible(i);
          return this;
        }
      };
      function t(i, n) {
        var o = i.controls, a;
        for (a = o.length - 1; a >= 0; a--)
          if (o[a].element === n)
            return a;
        return -1;
      }
    }(r), function(e) {
      e.Placement = e.freezeObject({
        CENTER: 0,
        TOP_LEFT: 1,
        TOP: 2,
        TOP_RIGHT: 3,
        RIGHT: 4,
        BOTTOM_RIGHT: 5,
        BOTTOM: 6,
        BOTTOM_LEFT: 7,
        LEFT: 8,
        properties: {
          0: {
            isLeft: !1,
            isHorizontallyCentered: !0,
            isRight: !1,
            isTop: !1,
            isVerticallyCentered: !0,
            isBottom: !1
          },
          1: {
            isLeft: !0,
            isHorizontallyCentered: !1,
            isRight: !1,
            isTop: !0,
            isVerticallyCentered: !1,
            isBottom: !1
          },
          2: {
            isLeft: !1,
            isHorizontallyCentered: !0,
            isRight: !1,
            isTop: !0,
            isVerticallyCentered: !1,
            isBottom: !1
          },
          3: {
            isLeft: !1,
            isHorizontallyCentered: !1,
            isRight: !0,
            isTop: !0,
            isVerticallyCentered: !1,
            isBottom: !1
          },
          4: {
            isLeft: !1,
            isHorizontallyCentered: !1,
            isRight: !0,
            isTop: !1,
            isVerticallyCentered: !0,
            isBottom: !1
          },
          5: {
            isLeft: !1,
            isHorizontallyCentered: !1,
            isRight: !0,
            isTop: !1,
            isVerticallyCentered: !1,
            isBottom: !0
          },
          6: {
            isLeft: !1,
            isHorizontallyCentered: !0,
            isRight: !1,
            isTop: !1,
            isVerticallyCentered: !1,
            isBottom: !0
          },
          7: {
            isLeft: !0,
            isHorizontallyCentered: !1,
            isRight: !1,
            isTop: !1,
            isVerticallyCentered: !1,
            isBottom: !0
          },
          8: {
            isLeft: !0,
            isHorizontallyCentered: !1,
            isRight: !1,
            isTop: !1,
            isVerticallyCentered: !0,
            isBottom: !1
          }
        }
      });
    }(r), function(e) {
      var t = {}, i = 1;
      e.Viewer = function(m) {
        var P = arguments, U = this, J;
        e.isPlainObject(m) || (m = {
          id: P[0],
          xmlPath: P.length > 1 ? P[1] : void 0,
          prefixUrl: P.length > 2 ? P[2] : void 0,
          controls: P.length > 3 ? P[3] : void 0,
          overlays: P.length > 4 ? P[4] : void 0
        }), m.config && (e.extend(!0, m, m.config), delete m.config);
        let ie = [
          "useCanvas"
          // deprecated
        ];
        if (m.drawerOptions = Object.assign(
          {},
          ie.reduce((X, me) => (X[me] = m[me], delete m[me], X), {}),
          m.drawerOptions
        ), e.extend(!0, this, {
          //internal state and dom identifiers
          id: m.id,
          hash: m.hash || i++,
          /**
           * Index for page to be shown first next time open() is called (only used in sequenceMode).
           * @member {Number} initialPage
           * @memberof OpenSeadragon.Viewer#
           */
          initialPage: 0,
          //dom nodes
          /**
           * The parent element of this Viewer instance, passed in when the Viewer was created.
           * @member {Element} element
           * @memberof OpenSeadragon.Viewer#
           */
          element: null,
          /**
           * A &lt;div&gt; element (provided by {@link OpenSeadragon.ControlDock}), the base element of this Viewer instance.<br><br>
           * Child element of {@link OpenSeadragon.Viewer#element}.
           * @member {Element} container
           * @memberof OpenSeadragon.Viewer#
           */
          container: null,
          /**
           * A &lt;div&gt; element, the element where user-input events are handled for panning and zooming.<br><br>
           * Child element of {@link OpenSeadragon.Viewer#container},
           * positioned on top of {@link OpenSeadragon.Viewer#keyboardCommandArea}.<br><br>
           * The parent of {@link OpenSeadragon.Drawer#canvas} instances.
           * @member {Element} canvas
           * @memberof OpenSeadragon.Viewer#
           */
          canvas: null,
          // Overlays list. An overlay allows to add html on top of the viewer.
          overlays: [],
          // Container inside the canvas where overlays are drawn.
          overlaysContainer: null,
          //private state properties
          previousBody: [],
          //This was originally initialized in the constructor and so could never
          //have anything in it.  now it can because we allow it to be specified
          //in the options and is only empty by default if not specified. Also
          //this array was returned from get_controls which I find confusing
          //since this object has a controls property which is treated in other
          //functions like clearControls.  I'm removing the accessors.
          customControls: [],
          //These are originally not part options but declared as members
          //in initialize.  It's still considered idiomatic to put them here
          //source is here for backwards compatibility. It is not an official
          //part of the API and should not be relied upon.
          source: null,
          /**
           * Handles rendering of tiles in the viewer. Created for each TileSource opened.
           * @member {OpenSeadragon.Drawer} drawer
           * @memberof OpenSeadragon.Viewer#
           */
          drawer: null,
          /**
           * Keeps track of all of the tiled images in the scene.
           * @member {OpenSeadragon.World} world
           * @memberof OpenSeadragon.Viewer#
           */
          world: null,
          /**
           * Handles coordinate-related functionality - zoom, pan, rotation, etc. Created for each TileSource opened.
           * @member {OpenSeadragon.Viewport} viewport
           * @memberof OpenSeadragon.Viewer#
           */
          viewport: null,
          /**
           * @member {OpenSeadragon.Navigator} navigator
           * @memberof OpenSeadragon.Viewer#
           */
          navigator: null,
          //A collection viewport is a separate viewport used to provide
          //simultaneous rendering of sets of tiles
          collectionViewport: null,
          collectionDrawer: null,
          //UI image resources
          //TODO: rename navImages to uiImages
          navImages: null,
          //interface button controls
          buttonGroup: null,
          //TODO: this is defunct so safely remove it
          profiler: null
        }, e.DEFAULT_SETTINGS, m), typeof this.hash > "u")
          throw new Error("A hash must be defined, either by specifying options.id or options.hash.");
        typeof t[this.hash] < "u" && e.console.warn("Hash " + this.hash + " has already been used."), t[this.hash] = {
          fsBoundsDelta: new e.Point(1, 1),
          prevContainerSize: null,
          animating: !1,
          forceRedraw: !1,
          needsResize: !1,
          forceResize: !1,
          mouseInside: !1,
          group: null,
          // whether we should be continuously zooming
          zooming: !1,
          // how much we should be continuously zooming by
          zoomFactor: null,
          lastZoomTime: null,
          fullPage: !1,
          onfullscreenchange: null,
          lastClickTime: null,
          draggingToZoom: !1
        }, this._sequenceIndex = 0, this._firstOpen = !0, this._updateRequestId = null, this._loadQueue = [], this.currentOverlays = [], this._updatePixelDensityRatioBind = null, this._lastScrollTime = e.now(), e.EventSource.call(this), this.addHandler("open-failed", function(X) {
          var me = e.getString("Errors.OpenFailed", X.eventSource, X.message);
          U._showMessage(me);
        }), e.ControlDock.call(this, m), this.xmlPath && (this.tileSources = [this.xmlPath]), this.element = this.element || document.getElementById(this.id), this.canvas = e.makeNeutralElement("div"), this.canvas.className = "openseadragon-canvas", function(X) {
          X.width = "100%", X.height = "100%", X.overflow = "hidden", X.position = "absolute", X.top = "0px", X.left = "0px";
        }(this.canvas.style), e.setElementTouchActionNone(this.canvas), m.tabIndex !== "" && (this.canvas.tabIndex = m.tabIndex === void 0 ? 0 : m.tabIndex), this.container.className = "openseadragon-container", function(X) {
          X.width = "100%", X.height = "100%", X.position = "relative", X.overflow = "hidden", X.left = "0px", X.top = "0px", X.textAlign = "left";
        }(this.container.style), e.setElementTouchActionNone(this.container), this.container.insertBefore(this.canvas, this.container.firstChild), this.element.appendChild(this.container), this.bodyWidth = document.body.style.width, this.bodyHeight = document.body.style.height, this.bodyOverflow = document.body.style.overflow, this.docOverflow = document.documentElement.style.overflow, this.innerTracker = new e.MouseTracker({
          userData: "Viewer.innerTracker",
          element: this.canvas,
          startDisabled: !this.mouseNavEnabled,
          clickTimeThreshold: this.clickTimeThreshold,
          clickDistThreshold: this.clickDistThreshold,
          dblClickTimeThreshold: this.dblClickTimeThreshold,
          dblClickDistThreshold: this.dblClickDistThreshold,
          contextMenuHandler: e.delegate(this, A),
          keyDownHandler: e.delegate(this, I),
          keyHandler: e.delegate(this, V),
          clickHandler: e.delegate(this, K),
          dblClickHandler: e.delegate(this, ce),
          dragHandler: e.delegate(this, re),
          dragEndHandler: e.delegate(this, he),
          enterHandler: e.delegate(this, pe),
          leaveHandler: e.delegate(this, Te),
          pressHandler: e.delegate(this, Ae),
          releaseHandler: e.delegate(this, He),
          nonPrimaryPressHandler: e.delegate(this, Fe),
          nonPrimaryReleaseHandler: e.delegate(this, ve),
          scrollHandler: e.delegate(this, We),
          pinchHandler: e.delegate(this, Re),
          focusHandler: e.delegate(this, Ze),
          blurHandler: e.delegate(this, Ue)
        }), this.outerTracker = new e.MouseTracker({
          userData: "Viewer.outerTracker",
          element: this.container,
          startDisabled: !this.mouseNavEnabled,
          clickTimeThreshold: this.clickTimeThreshold,
          clickDistThreshold: this.clickDistThreshold,
          dblClickTimeThreshold: this.dblClickTimeThreshold,
          dblClickDistThreshold: this.dblClickDistThreshold,
          enterHandler: e.delegate(this, it),
          leaveHandler: e.delegate(this, Ve)
        }), this.toolbar && (this.toolbar = new e.ControlDock({ element: this.toolbar })), this.bindStandardControls(), t[this.hash].prevContainerSize = n(this.container), window.ResizeObserver ? (this._autoResizePolling = !1, this._resizeObserver = new ResizeObserver(function() {
          t[U.hash].needsResize = !0;
        }), this._resizeObserver.observe(this.container, {})) : this._autoResizePolling = !0, this.world = new e.World({
          viewer: this
        }), this.world.addHandler("add-item", function(X) {
          U.source = U.world.getItemAt(0).source, t[U.hash].forceRedraw = !0, U._updateRequestId || (U._updateRequestId = h(U, rt));
        }), this.world.addHandler("remove-item", function(X) {
          U.world.getItemCount() ? U.source = U.world.getItemAt(0).source : U.source = null, t[U.hash].forceRedraw = !0;
        }), this.world.addHandler("metrics-change", function(X) {
          U.viewport && U.viewport._setContentBounds(U.world.getHomeBounds(), U.world.getContentFactor());
        }), this.world.addHandler("item-index-change", function(X) {
          U.source = U.world.getItemAt(0).source;
        }), this.viewport = new e.Viewport({
          containerSize: t[this.hash].prevContainerSize,
          springStiffness: this.springStiffness,
          animationTime: this.animationTime,
          minZoomImageRatio: this.minZoomImageRatio,
          maxZoomPixelRatio: this.maxZoomPixelRatio,
          visibilityRatio: this.visibilityRatio,
          wrapHorizontal: this.wrapHorizontal,
          wrapVertical: this.wrapVertical,
          defaultZoomLevel: this.defaultZoomLevel,
          minZoomLevel: this.minZoomLevel,
          maxZoomLevel: this.maxZoomLevel,
          viewer: this,
          degrees: this.degrees,
          flipped: this.flipped,
          overlayPreserveContentDirection: this.overlayPreserveContentDirection,
          navigatorRotate: this.navigatorRotate,
          homeFillsViewer: this.homeFillsViewer,
          margins: this.viewportMargins,
          silenceMultiImageWarnings: this.silenceMultiImageWarnings
        }), this.viewport._setContentBounds(this.world.getHomeBounds(), this.world.getContentFactor()), this.imageLoader = new e.ImageLoader({
          jobLimit: this.imageLoaderLimit,
          timeout: m.timeout,
          tileRetryMax: this.tileRetryMax,
          tileRetryDelay: this.tileRetryDelay
        }), this.tileCache = new e.TileCache({
          maxImageCacheCount: this.maxImageCacheCount
        }), Object.prototype.hasOwnProperty.call(this.drawerOptions, "useCanvas") && (e.console.error('useCanvas is deprecated, use the "drawer" option to indicate preferred drawer(s)'), this.drawerOptions.useCanvas || (this.drawer = e.HTMLDrawer), delete this.drawerOptions.useCanvas);
        let de = Array.isArray(this.drawer) ? this.drawer : [this.drawer];
        de.length === 0 && (de = [e.DEFAULT_SETTINGS.drawer].flat(), e.console.warn("No valid drawers were selected. Using the default value.")), this.drawer = null;
        for (const X of de)
          if (this.requestDrawer(X, { mainDrawer: !0, redrawImmediately: !1 }))
            break;
        if (!this.drawer)
          throw e.console.error("No drawer could be created!"), "Error with creating the selected drawer(s)";
        for (this.drawer.setImageSmoothingEnabled(this.imageSmoothingEnabled), this.overlaysContainer = e.makeNeutralElement("div"), this.canvas.appendChild(this.overlaysContainer), this.drawer.canRotate() || (this.rotateLeft && (J = this.buttonGroup.buttons.indexOf(this.rotateLeft), this.buttonGroup.buttons.splice(J, 1), this.buttonGroup.element.removeChild(this.rotateLeft.element)), this.rotateRight && (J = this.buttonGroup.buttons.indexOf(this.rotateRight), this.buttonGroup.buttons.splice(J, 1), this.buttonGroup.element.removeChild(this.rotateRight.element))), this._addUpdatePixelDensityRatioEvent(), this.showNavigator && (this.navigator = new e.Navigator({
          element: this.navigatorElement,
          id: this.navigatorId,
          position: this.navigatorPosition,
          sizeRatio: this.navigatorSizeRatio,
          maintainSizeRatio: this.navigatorMaintainSizeRatio,
          top: this.navigatorTop,
          left: this.navigatorLeft,
          width: this.navigatorWidth,
          height: this.navigatorHeight,
          autoResize: this.navigatorAutoResize,
          autoFade: this.navigatorAutoFade,
          prefixUrl: this.prefixUrl,
          viewer: this,
          navigatorRotate: this.navigatorRotate,
          background: this.navigatorBackground,
          opacity: this.navigatorOpacity,
          borderColor: this.navigatorBorderColor,
          displayRegionColor: this.navigatorDisplayRegionColor,
          crossOriginPolicy: this.crossOriginPolicy,
          animationTime: this.animationTime,
          drawer: this.drawer.getType(),
          loadTilesWithAjax: this.loadTilesWithAjax,
          ajaxHeaders: this.ajaxHeaders,
          ajaxWithCredentials: this.ajaxWithCredentials
        })), this.sequenceMode && this.bindSequenceControls(), this.tileSources && this.open(this.tileSources), J = 0; J < this.customControls.length; J++)
          this.addControl(
            this.customControls[J].id,
            { anchor: this.customControls[J].anchor }
          );
        e.requestAnimationFrame(function() {
          f(U);
        }), e._viewers.set(this.element, this);
      }, e.extend(
        e.Viewer.prototype,
        e.EventSource.prototype,
        e.ControlDock.prototype,
        /** @lends OpenSeadragon.Viewer.prototype */
        {
          /**
           * @function
           * @returns {Boolean}
           */
          isOpen: function() {
            return !!this.world.getItemCount();
          },
          // deprecated
          openDzi: function(m) {
            return e.console.error("[Viewer.openDzi] this function is deprecated; use Viewer.open() instead."), this.open(m);
          },
          // deprecated
          openTileSource: function(m) {
            return e.console.error("[Viewer.openTileSource] this function is deprecated; use Viewer.open() instead."), this.open(m);
          },
          //deprecated
          get buttons() {
            return e.console.warn("Viewer.buttons is deprecated; Please use Viewer.buttonGroup"), this.buttonGroup;
          },
          /**
           * Open tiled images into the viewer, closing any others.
           * To get the TiledImage instance created by open, add an event listener for
           * {@link OpenSeadragon.Viewer.html#.event:open}, which when fired can be used to get access
           * to the instance, i.e., viewer.world.getItemAt(0).
           * @function
           * @param {Array|String|Object|Function} tileSources - This can be a TiledImage
           * specifier, a TileSource specifier, or an array of either. A TiledImage specifier
           * is the same as the options parameter for {@link OpenSeadragon.Viewer#addTiledImage},
           * except for the index property; images are added in sequence.
           * A TileSource specifier is anything you could pass as the tileSource property
           * of the options parameter for {@link OpenSeadragon.Viewer#addTiledImage}.
           * @param {Number} initialPage - If sequenceMode is true, display this page initially
           * for the given tileSources. If specified, will overwrite the Viewer's existing initialPage property.
           * @returns {OpenSeadragon.Viewer} Chainable.
           * @fires OpenSeadragon.Viewer.event:open
           * @fires OpenSeadragon.Viewer.event:open-failed
           */
          open: function(m, P) {
            var U = this;
            if (this.close(), !m)
              return this;
            if (this.sequenceMode && e.isArray(m))
              return this.referenceStrip && (this.referenceStrip.destroy(), this.referenceStrip = null), typeof P < "u" && !isNaN(P) && (this.initialPage = P), this.tileSources = m, this._sequenceIndex = Math.max(0, Math.min(this.tileSources.length - 1, this.initialPage)), this.tileSources.length && (this.open(this.tileSources[this._sequenceIndex]), this.showReferenceStrip && this.addReferenceStrip()), this._updateSequenceButtons(this._sequenceIndex), this;
            if (e.isArray(m) || (m = [m]), !m.length)
              return this;
            this._opening = !0;
            for (var J = m.length, ie = 0, de = 0, X, me = function() {
              if (ie + de === J)
                if (ie) {
                  (U._firstOpen || !U.preserveViewport) && (U.viewport.goHome(!0), U.viewport.update()), U._firstOpen = !1;
                  var ge = m[0];
                  if (ge.tileSource && (ge = ge.tileSource), U.overlays && !U.preserveOverlays)
                    for (var Me = 0; Me < U.overlays.length; Me++)
                      U.currentOverlays[Me] = a(U, U.overlays[Me]);
                  U._drawOverlays(), U._opening = !1, U.raiseEvent("open", { source: ge });
                } else
                  U._opening = !1, U.raiseEvent("open-failed", X);
            }, Ce = function(ge) {
              (!e.isPlainObject(ge) || !ge.tileSource) && (ge = {
                tileSource: ge
              }), ge.index !== void 0 && (e.console.error("[Viewer.open] setting indexes here is not supported; use addTiledImage instead"), delete ge.index), ge.collectionImmediately === void 0 && (ge.collectionImmediately = !0);
              var Me = ge.success;
              ge.success = function(_) {
                if (ie++, ge.tileSource.overlays)
                  for (var T = 0; T < ge.tileSource.overlays.length; T++)
                    U.addOverlay(ge.tileSource.overlays[T]);
                Me && Me(_), me();
              };
              var b = ge.error;
              ge.error = function(_) {
                de++, X || (X = _), b && b(_), me();
              }, U.addTiledImage(ge);
            }, Se = 0; Se < m.length; Se++)
              Ce(m[Se]);
            return this;
          },
          /**
           * @function
           * @returns {OpenSeadragon.Viewer} Chainable.
           * @fires OpenSeadragon.Viewer.event:close
           */
          close: function() {
            return t[this.hash] ? (this._opening = !1, this.navigator && this.navigator.close(), this.preserveOverlays || (this.clearOverlays(), this.overlaysContainer.innerHTML = ""), t[this.hash].animating = !1, this.world.removeAll(), this.imageLoader.clear(), this.raiseEvent("close"), this) : this;
          },
          /**
           * Function to destroy the viewer and clean up everything created by OpenSeadragon.
           *
           * Example:
           * var viewer = OpenSeadragon({
           *   [...]
           * });
           *
           * //when you are done with the viewer:
           * viewer.destroy();
           * viewer = null; //important
           *
           * @function
           * @fires OpenSeadragon.Viewer.event:before-destroy
           * @fires OpenSeadragon.Viewer.event:destroy
           */
          destroy: function() {
            if (t[this.hash]) {
              if (this.raiseEvent("before-destroy"), this._removeUpdatePixelDensityRatioEvent(), this.close(), this.clearOverlays(), this.overlaysContainer.innerHTML = "", this._resizeObserver && this._resizeObserver.disconnect(), this.referenceStrip && (this.referenceStrip.destroy(), this.referenceStrip = null), this._updateRequestId !== null && (e.cancelAnimationFrame(this._updateRequestId), this._updateRequestId = null), this.drawer && this.drawer.destroy(), this.navigator && (this.navigator.destroy(), t[this.navigator.hash] = null, delete t[this.navigator.hash], this.navigator = null), this.buttonGroup)
                this.buttonGroup.destroy();
              else if (this.customButtons)
                for (; this.customButtons.length; )
                  this.customButtons.pop().destroy();
              if (this.paging && this.paging.destroy(), this.element)
                for (; this.element.firstChild; )
                  this.element.removeChild(this.element.firstChild);
              this.container.onsubmit = null, this.clearControls(), this.innerTracker && this.innerTracker.destroy(), this.outerTracker && this.outerTracker.destroy(), t[this.hash] = null, delete t[this.hash], this.canvas = null, this.container = null, e._viewers.delete(this.element), this.element = null, this.raiseEvent("destroy"), this.removeAllHandlers();
            }
          },
          /**
           * Request a drawer for this viewer, as a supported string or drawer constructor.
           * @param {String | OpenSeadragon.DrawerBase} drawerCandidate The type of drawer to try to construct.
           * @param { Object } options
           * @param { Boolean } [options.mainDrawer] Whether to use this as the viewer's main drawer. Default = true.
           * @param { Boolean } [options.redrawImmediately] Whether to immediately draw a new frame. Only used if options.mainDrawer = true. Default = true.
           * @param { Object } [options.drawerOptions] Options for this drawer. Defaults to viewer.drawerOptions.
           * for this viewer type. See {@link OpenSeadragon.Options}.
           * @returns {Object | Boolean} The drawer that was created, or false if the requested drawer is not supported
           */
          requestDrawer(m, P) {
            const U = {
              mainDrawer: !0,
              redrawImmediately: !0,
              drawerOptions: null
            };
            P = e.extend(!0, U, P);
            const J = P.mainDrawer, ie = P.redrawImmediately, de = P.drawerOptions, X = this.drawer;
            let me = null;
            if (m && m.prototype instanceof e.DrawerBase ? (me = m, m = "custom") : typeof m == "string" && (me = e.determineDrawer(m)), me || e.console.warn("Unsupported drawer! Drawer must be an existing string type, or a class that extends OpenSeadragon.DrawerBase."), me && me.isSupported()) {
              X && J && X.destroy();
              const Ce = new me({
                viewer: this,
                viewport: this.viewport,
                element: this.canvas,
                debugGridColor: this.debugGridColor,
                options: de || this.drawerOptions[m]
              });
              return J && (this.drawer = Ce, ie && this.forceRedraw()), Ce;
            }
            return !1;
          },
          /**
           * @function
           * @returns {Boolean}
           */
          isMouseNavEnabled: function() {
            return this.innerTracker.isTracking();
          },
          /**
           * @function
           * @param {Boolean} enabled - true to enable, false to disable
           * @returns {OpenSeadragon.Viewer} Chainable.
           * @fires OpenSeadragon.Viewer.event:mouse-enabled
           */
          setMouseNavEnabled: function(m) {
            return this.innerTracker.setTracking(m), this.outerTracker.setTracking(m), this.raiseEvent("mouse-enabled", { enabled: m }), this;
          },
          /**
           * @function
           * @returns {Boolean}
           */
          areControlsEnabled: function() {
            var m = this.controls.length, P;
            for (P = 0; P < this.controls.length; P++)
              m = m && this.controls[P].isVisible();
            return m;
          },
          /**
           * Shows or hides the controls (e.g. the default navigation buttons).
           *
           * @function
           * @param {Boolean} true to show, false to hide.
           * @returns {OpenSeadragon.Viewer} Chainable.
           * @fires OpenSeadragon.Viewer.event:controls-enabled
           */
          setControlsEnabled: function(m) {
            return m ? w(this) : f(this), this.raiseEvent("controls-enabled", { enabled: m }), this;
          },
          /**
           * Turns debugging mode on or off for this viewer.
           *
           * @function
           * @param {Boolean} debugMode true to turn debug on, false to turn debug off.
           */
          setDebugMode: function(m) {
            for (var P = 0; P < this.world.getItemCount(); P++)
              this.world.getItemAt(P).debugMode = m;
            this.debugMode = m, this.forceRedraw();
          },
          /**
           * Update headers to include when making AJAX requests.
           *
           * Unless `propagate` is set to false (which is likely only useful in rare circumstances),
           * the updated headers are propagated to all tiled images, each of which will subsequently
           * propagate the changed headers to all their tiles.
           * If applicable, the headers of the viewer's navigator and reference strip will also be updated.
           *
           * Note that the rules for merging headers still apply, i.e. headers returned by
           * {@link OpenSeadragon.TileSource#getTileAjaxHeaders} take precedence over
           * `TiledImage.ajaxHeaders`, which take precedence over the headers here in the viewer.
           *
           * @function
           * @param {Object} ajaxHeaders Updated AJAX headers.
           * @param {Boolean} [propagate=true] Whether to propagate updated headers to tiled images, etc.
           */
          setAjaxHeaders: function(m, P) {
            if (m === null && (m = {}), !e.isPlainObject(m)) {
              console.error("[Viewer.setAjaxHeaders] Ignoring invalid headers, must be a plain object");
              return;
            }
            if (P === void 0 && (P = !0), this.ajaxHeaders = m, P) {
              for (var U = 0; U < this.world.getItemCount(); U++)
                this.world.getItemAt(U)._updateAjaxHeaders(!0);
              if (this.navigator && this.navigator.setAjaxHeaders(this.ajaxHeaders, !0), this.referenceStrip && this.referenceStrip.miniViewers)
                for (var J in this.referenceStrip.miniViewers)
                  this.referenceStrip.miniViewers[J].setAjaxHeaders(this.ajaxHeaders, !0);
            }
          },
          /**
           * Adds the given button to this viewer.
           *
           * @function
           * @param {OpenSeadragon.Button} button
           */
          addButton: function(m) {
            this.buttonGroup.addButton(m);
          },
          /**
           * @function
           * @returns {Boolean}
           */
          isFullPage: function() {
            return t[this.hash] && t[this.hash].fullPage;
          },
          /**
           * Toggle full page mode.
           * @function
           * @param {Boolean} fullPage
           *      If true, enter full page mode.  If false, exit full page mode.
           * @returns {OpenSeadragon.Viewer} Chainable.
           * @fires OpenSeadragon.Viewer.event:pre-full-page
           * @fires OpenSeadragon.Viewer.event:full-page
           */
          setFullPage: function(m) {
            var P = document.body, U = P.style, J = document.documentElement.style, ie = this, de, X;
            if (m === this.isFullPage())
              return this;
            var me = {
              fullPage: m,
              preventDefaultAction: !1
            };
            if (this.raiseEvent("pre-full-page", me), me.preventDefaultAction)
              return this;
            if (m && this.element) {
              for (this.elementSize = e.getElementSize(this.element), this.pageScroll = e.getPageScroll(), this.elementMargin = this.element.style.margin, this.element.style.margin = "0", this.elementPadding = this.element.style.padding, this.element.style.padding = "0", this.bodyMargin = U.margin, this.docMargin = J.margin, U.margin = "0", J.margin = "0", this.bodyPadding = U.padding, this.docPadding = J.padding, U.padding = "0", J.padding = "0", this.bodyWidth = U.width, this.docWidth = J.width, U.width = "100%", J.width = "100%", this.bodyHeight = U.height, this.docHeight = J.height, U.height = "100%", J.height = "100%", this.bodyDisplay = U.display, U.display = "block", this.previousBody = [], t[this.hash].prevElementParent = this.element.parentNode, t[this.hash].prevNextSibling = this.element.nextSibling, t[this.hash].prevElementWidth = this.element.style.width, t[this.hash].prevElementHeight = this.element.style.height, de = P.childNodes.length, X = 0; X < de; X++)
                this.previousBody.push(P.childNodes[0]), P.removeChild(P.childNodes[0]);
              this.toolbar && this.toolbar.element && (this.toolbar.parentNode = this.toolbar.element.parentNode, this.toolbar.nextSibling = this.toolbar.element.nextSibling, P.appendChild(this.toolbar.element), e.addClass(this.toolbar.element, "fullpage")), e.addClass(this.element, "fullpage"), P.appendChild(this.element), this.element.style.height = "100vh", this.element.style.width = "100vw", this.toolbar && this.toolbar.element && (this.element.style.height = e.getElementSize(this.element).y - e.getElementSize(this.toolbar.element).y + "px"), t[this.hash].fullPage = !0, e.delegate(this, it)({});
            } else {
              for (this.element.style.margin = this.elementMargin, this.element.style.padding = this.elementPadding, U.margin = this.bodyMargin, J.margin = this.docMargin, U.padding = this.bodyPadding, J.padding = this.docPadding, U.width = this.bodyWidth, J.width = this.docWidth, U.height = this.bodyHeight, J.height = this.docHeight, U.display = this.bodyDisplay, P.removeChild(this.element), de = this.previousBody.length, X = 0; X < de; X++)
                P.appendChild(this.previousBody.shift());
              e.removeClass(this.element, "fullpage"), t[this.hash].prevElementParent.insertBefore(
                this.element,
                t[this.hash].prevNextSibling
              ), this.toolbar && this.toolbar.element && (P.removeChild(this.toolbar.element), e.removeClass(this.toolbar.element, "fullpage"), this.toolbar.parentNode.insertBefore(
                this.toolbar.element,
                this.toolbar.nextSibling
              ), delete this.toolbar.parentNode, delete this.toolbar.nextSibling), this.element.style.width = t[this.hash].prevElementWidth, this.element.style.height = t[this.hash].prevElementHeight;
              var Ce = 0, Se = function() {
                e.setPageScroll(ie.pageScroll);
                var ge = e.getPageScroll();
                Ce++, Ce < 10 && (ge.x !== ie.pageScroll.x || ge.y !== ie.pageScroll.y) && e.requestAnimationFrame(Se);
              };
              e.requestAnimationFrame(Se), t[this.hash].fullPage = !1, e.delegate(this, Ve)({});
            }
            return this.navigator && this.viewport && this.navigator.update(this.viewport), this.raiseEvent("full-page", { fullPage: m }), this;
          },
          /**
           * Toggle full screen mode if supported. Toggle full page mode otherwise.
           * @function
           * @param {Boolean} fullScreen
           *      If true, enter full screen mode.  If false, exit full screen mode.
           * @returns {OpenSeadragon.Viewer} Chainable.
           * @fires OpenSeadragon.Viewer.event:pre-full-screen
           * @fires OpenSeadragon.Viewer.event:full-screen
           */
          setFullScreen: function(m) {
            var P = this;
            if (!e.supportsFullScreen)
              return this.setFullPage(m);
            if (e.isFullScreen() === m)
              return this;
            var U = {
              fullScreen: m,
              preventDefaultAction: !1
            };
            if (this.raiseEvent("pre-full-screen", U), U.preventDefaultAction)
              return this;
            if (m) {
              if (this.setFullPage(!0), !this.isFullPage())
                return this;
              this.fullPageStyleWidth = this.element.style.width, this.fullPageStyleHeight = this.element.style.height, this.element.style.width = "100%", this.element.style.height = "100%";
              var J = function() {
                var ie = e.isFullScreen();
                ie || (e.removeEvent(document, e.fullScreenEventName, J), e.removeEvent(document, e.fullScreenErrorEventName, J), P.setFullPage(!1), P.isFullPage() && (P.element.style.width = P.fullPageStyleWidth, P.element.style.height = P.fullPageStyleHeight)), P.navigator && P.viewport && setTimeout(function() {
                  P.navigator.update(P.viewport);
                }), P.raiseEvent("full-screen", { fullScreen: ie });
              };
              e.addEvent(document, e.fullScreenEventName, J), e.addEvent(document, e.fullScreenErrorEventName, J), e.requestFullScreen(document.body);
            } else
              e.exitFullScreen();
            return this;
          },
          /**
           * @function
           * @returns {Boolean}
           */
          isVisible: function() {
            return this.container.style.visibility !== "hidden";
          },
          //
          /**
           * @function
           * @returns {Boolean} returns true if the viewer is in fullscreen
           */
          isFullScreen: function() {
            return e.isFullScreen() && this.isFullPage();
          },
          /**
           * @function
           * @param {Boolean} visible
           * @returns {OpenSeadragon.Viewer} Chainable.
           * @fires OpenSeadragon.Viewer.event:visible
           */
          setVisible: function(m) {
            return this.container.style.visibility = m ? "" : "hidden", this.raiseEvent("visible", { visible: m }), this;
          },
          /**
           * Add a tiled image to the viewer.
           * options.tileSource can be anything that {@link OpenSeadragon.Viewer#open}
           *  supports except arrays of images.
           * Note that you can specify options.width or options.height, but not both.
           * The other dimension will be calculated according to the item's aspect ratio.
           * If collectionMode is on (see {@link OpenSeadragon.Options}), the new image is
           * automatically arranged with the others.
           * @function
           * @param {Object} options
           * @param {String|Object|Function} options.tileSource - The TileSource specifier.
           * A String implies a url used to determine the tileSource implementation
           *      based on the file extension of url. JSONP is implied by *.js,
           *      otherwise the url is retrieved as text and the resulting text is
           *      introspected to determine if its json, xml, or text and parsed.
           * An Object implies an inline configuration which has a single
           *      property sufficient for being able to determine tileSource
           *      implementation. If the object has a property which is a function
           *      named 'getTileUrl', it is treated as a custom TileSource.
           * @param {Number} [options.index] The index of the item. Added on top of
           * all other items if not specified.
           * @param {Boolean} [options.replace=false] If true, the item at options.index will be
           * removed and the new item is added in its place. options.tileSource will be
           * interpreted and fetched if necessary before the old item is removed to avoid leaving
           * a gap in the world.
           * @param {Number} [options.x=0] The X position for the image in viewport coordinates.
           * @param {Number} [options.y=0] The Y position for the image in viewport coordinates.
           * @param {Number} [options.width=1] The width for the image in viewport coordinates.
           * @param {Number} [options.height] The height for the image in viewport coordinates.
           * @param {OpenSeadragon.Rect} [options.fitBounds] The bounds in viewport coordinates
           * to fit the image into. If specified, x, y, width and height get ignored.
           * @param {OpenSeadragon.Placement} [options.fitBoundsPlacement=OpenSeadragon.Placement.CENTER]
           * How to anchor the image in the bounds if options.fitBounds is set.
           * @param {OpenSeadragon.Rect} [options.clip] - An area, in image pixels, to clip to
           * (portions of the image outside of this area will not be visible). Only works on
           * browsers that support the HTML5 canvas.
           * @param {Number} [options.opacity=1] Proportional opacity of the tiled images (1=opaque, 0=hidden)
           * @param {Boolean} [options.preload=false]  Default switch for loading hidden images (true loads, false blocks)
           * @param {Number} [options.degrees=0] Initial rotation of the tiled image around
           * its top left corner in degrees.
           * @param {Boolean} [options.flipped=false] Whether to horizontally flip the image.
           * @param {String} [options.compositeOperation] How the image is composited onto other images.
           * @param {String} [options.crossOriginPolicy] The crossOriginPolicy for this specific image,
           * overriding viewer.crossOriginPolicy.
           * @param {Boolean} [options.ajaxWithCredentials] Whether to set withCredentials on tile AJAX
           * @param {Boolean} [options.loadTilesWithAjax]
           *      Whether to load tile data using AJAX requests.
           *      Defaults to the setting in {@link OpenSeadragon.Options}.
           * @param {Object} [options.ajaxHeaders]
           *      A set of headers to include when making tile AJAX requests.
           *      Note that these headers will be merged over any headers specified in {@link OpenSeadragon.Options}.
           *      Specifying a falsy value for a header will clear its existing value set at the Viewer level (if any).
           * @param {Function} [options.success] A function that gets called when the image is
           * successfully added. It's passed the event object which contains a single property:
           * "item", which is the resulting instance of TiledImage.
           * @param {Function} [options.error] A function that gets called if the image is
           * unable to be added. It's passed the error event object, which contains "message"
           * and "source" properties.
           * @param {Boolean} [options.collectionImmediately=false] If collectionMode is on,
           * specifies whether to snap to the new arrangement immediately or to animate to it.
           * @param {String|CanvasGradient|CanvasPattern|Function} [options.placeholderFillStyle] - See {@link OpenSeadragon.Options}.
           * @fires OpenSeadragon.World.event:add-item
           * @fires OpenSeadragon.Viewer.event:add-item-failed
           */
          addTiledImage: function(m) {
            e.console.assert(m, "[Viewer.addTiledImage] options is required"), e.console.assert(m.tileSource, "[Viewer.addTiledImage] options.tileSource is required"), e.console.assert(
              !m.replace || m.index > -1 && m.index < this.world.getItemCount(),
              "[Viewer.addTiledImage] if options.replace is used, options.index must be a valid index in Viewer.world"
            );
            var P = this;
            m.replace && (m.replaceItem = P.world.getItemAt(m.index)), this._hideMessage(), m.placeholderFillStyle === void 0 && (m.placeholderFillStyle = this.placeholderFillStyle), m.opacity === void 0 && (m.opacity = this.opacity), m.preload === void 0 && (m.preload = this.preload), m.compositeOperation === void 0 && (m.compositeOperation = this.compositeOperation), m.crossOriginPolicy === void 0 && (m.crossOriginPolicy = m.tileSource.crossOriginPolicy !== void 0 ? m.tileSource.crossOriginPolicy : this.crossOriginPolicy), m.ajaxWithCredentials === void 0 && (m.ajaxWithCredentials = this.ajaxWithCredentials), m.loadTilesWithAjax === void 0 && (m.loadTilesWithAjax = this.loadTilesWithAjax), e.isPlainObject(m.ajaxHeaders) || (m.ajaxHeaders = {});
            var U = {
              options: m
            };
            function J(X) {
              for (var me = 0; me < P._loadQueue.length; me++)
                if (P._loadQueue[me] === U) {
                  P._loadQueue.splice(me, 1);
                  break;
                }
              P._loadQueue.length === 0 && ie(U), P.raiseEvent("add-item-failed", X), m.error && m.error(X);
            }
            function ie(X) {
              P.collectionMode && (P.world.arrange({
                immediately: X.options.collectionImmediately,
                rows: P.collectionRows,
                columns: P.collectionColumns,
                layout: P.collectionLayout,
                tileSize: P.collectionTileSize,
                tileMargin: P.collectionTileMargin
              }), P.world.setAutoRefigureSizes(!0));
            }
            if (e.isArray(m.tileSource)) {
              setTimeout(function() {
                J({
                  message: "[Viewer.addTiledImage] Sequences can not be added; add them one at a time instead.",
                  source: m.tileSource,
                  options: m
                });
              });
              return;
            }
            this._loadQueue.push(U);
            function de() {
              for (var X, me, Ce; P._loadQueue.length && (X = P._loadQueue[0], !!X.tileSource); ) {
                if (P._loadQueue.splice(0, 1), X.options.replace) {
                  var Se = P.world.getIndexOfItem(X.options.replaceItem);
                  Se !== -1 && (X.options.index = Se), P.world.removeItem(X.options.replaceItem);
                }
                me = new e.TiledImage({
                  viewer: P,
                  source: X.tileSource,
                  viewport: P.viewport,
                  drawer: P.drawer,
                  tileCache: P.tileCache,
                  imageLoader: P.imageLoader,
                  x: X.options.x,
                  y: X.options.y,
                  width: X.options.width,
                  height: X.options.height,
                  fitBounds: X.options.fitBounds,
                  fitBoundsPlacement: X.options.fitBoundsPlacement,
                  clip: X.options.clip,
                  placeholderFillStyle: X.options.placeholderFillStyle,
                  opacity: X.options.opacity,
                  preload: X.options.preload,
                  degrees: X.options.degrees,
                  flipped: X.options.flipped,
                  compositeOperation: X.options.compositeOperation,
                  springStiffness: P.springStiffness,
                  animationTime: P.animationTime,
                  minZoomImageRatio: P.minZoomImageRatio,
                  wrapHorizontal: P.wrapHorizontal,
                  wrapVertical: P.wrapVertical,
                  maxTilesPerFrame: P.maxTilesPerFrame,
                  immediateRender: P.immediateRender,
                  blendTime: P.blendTime,
                  alwaysBlend: P.alwaysBlend,
                  minPixelRatio: P.minPixelRatio,
                  smoothTileEdgesMinZoom: P.smoothTileEdgesMinZoom,
                  iOSDevice: P.iOSDevice,
                  crossOriginPolicy: X.options.crossOriginPolicy,
                  ajaxWithCredentials: X.options.ajaxWithCredentials,
                  loadTilesWithAjax: X.options.loadTilesWithAjax,
                  ajaxHeaders: X.options.ajaxHeaders,
                  debugMode: P.debugMode,
                  subPixelRoundingForTransparency: P.subPixelRoundingForTransparency
                }), P.collectionMode && P.world.setAutoRefigureSizes(!1), P.navigator && (Ce = e.extend({}, X.options, {
                  replace: !1,
                  // navigator already removed the layer, nothing to replace
                  originalTiledImage: me,
                  tileSource: X.tileSource
                }), P.navigator.addTiledImage(Ce)), P.world.addItem(me, {
                  index: X.options.index
                }), P._loadQueue.length === 0 && ie(X), P.world.getItemCount() === 1 && !P.preserveViewport && P.viewport.goHome(!0), X.options.success && X.options.success({
                  item: me
                });
              }
            }
            o(this, m.tileSource, m, function(X) {
              U.tileSource = X, de();
            }, function(X) {
              X.options = m, J(X), de();
            });
          },
          /**
           * Add a simple image to the viewer.
           * The options are the same as the ones in {@link OpenSeadragon.Viewer#addTiledImage}
           * except for options.tileSource which is replaced by options.url.
           * @function
           * @param {Object} options - See {@link OpenSeadragon.Viewer#addTiledImage}
           * for all the options
           * @param {String} options.url - The URL of the image to add.
           * @fires OpenSeadragon.World.event:add-item
           * @fires OpenSeadragon.Viewer.event:add-item-failed
           */
          addSimpleImage: function(m) {
            e.console.assert(m, "[Viewer.addSimpleImage] options is required"), e.console.assert(m.url, "[Viewer.addSimpleImage] options.url is required");
            var P = e.extend({}, m, {
              tileSource: {
                type: "image",
                url: m.url
              }
            });
            delete P.url, this.addTiledImage(P);
          },
          // deprecated
          addLayer: function(m) {
            var P = this;
            e.console.error("[Viewer.addLayer] this function is deprecated; use Viewer.addTiledImage() instead.");
            var U = e.extend({}, m, {
              success: function(J) {
                P.raiseEvent("add-layer", {
                  options: m,
                  drawer: J.item
                });
              },
              error: function(J) {
                P.raiseEvent("add-layer-failed", J);
              }
            });
            return this.addTiledImage(U), this;
          },
          // deprecated
          getLayerAtLevel: function(m) {
            return e.console.error("[Viewer.getLayerAtLevel] this function is deprecated; use World.getItemAt() instead."), this.world.getItemAt(m);
          },
          // deprecated
          getLevelOfLayer: function(m) {
            return e.console.error("[Viewer.getLevelOfLayer] this function is deprecated; use World.getIndexOfItem() instead."), this.world.getIndexOfItem(m);
          },
          // deprecated
          getLayersCount: function() {
            return e.console.error("[Viewer.getLayersCount] this function is deprecated; use World.getItemCount() instead."), this.world.getItemCount();
          },
          // deprecated
          setLayerLevel: function(m, P) {
            return e.console.error("[Viewer.setLayerLevel] this function is deprecated; use World.setItemIndex() instead."), this.world.setItemIndex(m, P);
          },
          // deprecated
          removeLayer: function(m) {
            return e.console.error("[Viewer.removeLayer] this function is deprecated; use World.removeItem() instead."), this.world.removeItem(m);
          },
          /**
           * Force the viewer to redraw its contents.
           * @returns {OpenSeadragon.Viewer} Chainable.
           */
          forceRedraw: function() {
            return t[this.hash].forceRedraw = !0, this;
          },
          /**
           * Force the viewer to reset its size to match its container.
           */
          forceResize: function() {
            t[this.hash].needsResize = !0, t[this.hash].forceResize = !0;
          },
          /**
           * @function
           * @returns {OpenSeadragon.Viewer} Chainable.
           */
          bindSequenceControls: function() {
            var m = e.delegate(this, C), P = e.delegate(this, E), U = e.delegate(this, this.goToNextPage), J = e.delegate(this, this.goToPreviousPage), ie = this.navImages, de = !0;
            return this.showSequenceControl && ((this.previousButton || this.nextButton) && (de = !1), this.previousButton = new e.Button({
              element: this.previousButton ? e.getElement(this.previousButton) : null,
              clickTimeThreshold: this.clickTimeThreshold,
              clickDistThreshold: this.clickDistThreshold,
              tooltip: e.getString("Tooltips.PreviousPage"),
              srcRest: _e(this.prefixUrl, ie.previous.REST),
              srcGroup: _e(this.prefixUrl, ie.previous.GROUP),
              srcHover: _e(this.prefixUrl, ie.previous.HOVER),
              srcDown: _e(this.prefixUrl, ie.previous.DOWN),
              onRelease: J,
              onFocus: m,
              onBlur: P
            }), this.nextButton = new e.Button({
              element: this.nextButton ? e.getElement(this.nextButton) : null,
              clickTimeThreshold: this.clickTimeThreshold,
              clickDistThreshold: this.clickDistThreshold,
              tooltip: e.getString("Tooltips.NextPage"),
              srcRest: _e(this.prefixUrl, ie.next.REST),
              srcGroup: _e(this.prefixUrl, ie.next.GROUP),
              srcHover: _e(this.prefixUrl, ie.next.HOVER),
              srcDown: _e(this.prefixUrl, ie.next.DOWN),
              onRelease: U,
              onFocus: m,
              onBlur: P
            }), this.navPrevNextWrap || this.previousButton.disable(), (!this.tileSources || !this.tileSources.length) && this.nextButton.disable(), de && (this.paging = new e.ButtonGroup({
              buttons: [
                this.previousButton,
                this.nextButton
              ],
              clickTimeThreshold: this.clickTimeThreshold,
              clickDistThreshold: this.clickDistThreshold
            }), this.pagingControl = this.paging.element, this.toolbar ? this.toolbar.addControl(
              this.pagingControl,
              { anchor: e.ControlAnchor.BOTTOM_RIGHT }
            ) : this.addControl(
              this.pagingControl,
              { anchor: this.sequenceControlAnchor || e.ControlAnchor.TOP_LEFT }
            ))), this;
          },
          /**
           * @function
           * @returns {OpenSeadragon.Viewer} Chainable.
           */
          bindStandardControls: function() {
            var m = e.delegate(this, ii), P = e.delegate(this, _t), U = e.delegate(this, fe), J = e.delegate(this, kt), ie = e.delegate(this, ri), de = e.delegate(this, Ie), X = e.delegate(this, Ct), me = e.delegate(this, rr), Ce = e.delegate(this, ut), Se = e.delegate(this, Mt), ge = e.delegate(this, C), Me = e.delegate(this, E), b = this.navImages, _ = [], T = !0;
            return this.showNavigationControl && ((this.zoomInButton || this.zoomOutButton || this.homeButton || this.fullPageButton || this.rotateLeftButton || this.rotateRightButton || this.flipButton) && (T = !1), this.showZoomControl && (_.push(this.zoomInButton = new e.Button({
              element: this.zoomInButton ? e.getElement(this.zoomInButton) : null,
              clickTimeThreshold: this.clickTimeThreshold,
              clickDistThreshold: this.clickDistThreshold,
              tooltip: e.getString("Tooltips.ZoomIn"),
              srcRest: _e(this.prefixUrl, b.zoomIn.REST),
              srcGroup: _e(this.prefixUrl, b.zoomIn.GROUP),
              srcHover: _e(this.prefixUrl, b.zoomIn.HOVER),
              srcDown: _e(this.prefixUrl, b.zoomIn.DOWN),
              onPress: m,
              onRelease: P,
              onClick: U,
              onEnter: m,
              onExit: P,
              onFocus: ge,
              onBlur: Me
            })), _.push(this.zoomOutButton = new e.Button({
              element: this.zoomOutButton ? e.getElement(this.zoomOutButton) : null,
              clickTimeThreshold: this.clickTimeThreshold,
              clickDistThreshold: this.clickDistThreshold,
              tooltip: e.getString("Tooltips.ZoomOut"),
              srcRest: _e(this.prefixUrl, b.zoomOut.REST),
              srcGroup: _e(this.prefixUrl, b.zoomOut.GROUP),
              srcHover: _e(this.prefixUrl, b.zoomOut.HOVER),
              srcDown: _e(this.prefixUrl, b.zoomOut.DOWN),
              onPress: J,
              onRelease: P,
              onClick: ie,
              onEnter: J,
              onExit: P,
              onFocus: ge,
              onBlur: Me
            }))), this.showHomeControl && _.push(this.homeButton = new e.Button({
              element: this.homeButton ? e.getElement(this.homeButton) : null,
              clickTimeThreshold: this.clickTimeThreshold,
              clickDistThreshold: this.clickDistThreshold,
              tooltip: e.getString("Tooltips.Home"),
              srcRest: _e(this.prefixUrl, b.home.REST),
              srcGroup: _e(this.prefixUrl, b.home.GROUP),
              srcHover: _e(this.prefixUrl, b.home.HOVER),
              srcDown: _e(this.prefixUrl, b.home.DOWN),
              onRelease: de,
              onFocus: ge,
              onBlur: Me
            })), this.showFullPageControl && _.push(this.fullPageButton = new e.Button({
              element: this.fullPageButton ? e.getElement(this.fullPageButton) : null,
              clickTimeThreshold: this.clickTimeThreshold,
              clickDistThreshold: this.clickDistThreshold,
              tooltip: e.getString("Tooltips.FullPage"),
              srcRest: _e(this.prefixUrl, b.fullpage.REST),
              srcGroup: _e(this.prefixUrl, b.fullpage.GROUP),
              srcHover: _e(this.prefixUrl, b.fullpage.HOVER),
              srcDown: _e(this.prefixUrl, b.fullpage.DOWN),
              onRelease: X,
              onFocus: ge,
              onBlur: Me
            })), this.showRotationControl && (_.push(this.rotateLeftButton = new e.Button({
              element: this.rotateLeftButton ? e.getElement(this.rotateLeftButton) : null,
              clickTimeThreshold: this.clickTimeThreshold,
              clickDistThreshold: this.clickDistThreshold,
              tooltip: e.getString("Tooltips.RotateLeft"),
              srcRest: _e(this.prefixUrl, b.rotateleft.REST),
              srcGroup: _e(this.prefixUrl, b.rotateleft.GROUP),
              srcHover: _e(this.prefixUrl, b.rotateleft.HOVER),
              srcDown: _e(this.prefixUrl, b.rotateleft.DOWN),
              onRelease: me,
              onFocus: ge,
              onBlur: Me
            })), _.push(this.rotateRightButton = new e.Button({
              element: this.rotateRightButton ? e.getElement(this.rotateRightButton) : null,
              clickTimeThreshold: this.clickTimeThreshold,
              clickDistThreshold: this.clickDistThreshold,
              tooltip: e.getString("Tooltips.RotateRight"),
              srcRest: _e(this.prefixUrl, b.rotateright.REST),
              srcGroup: _e(this.prefixUrl, b.rotateright.GROUP),
              srcHover: _e(this.prefixUrl, b.rotateright.HOVER),
              srcDown: _e(this.prefixUrl, b.rotateright.DOWN),
              onRelease: Ce,
              onFocus: ge,
              onBlur: Me
            }))), this.showFlipControl && _.push(this.flipButton = new e.Button({
              element: this.flipButton ? e.getElement(this.flipButton) : null,
              clickTimeThreshold: this.clickTimeThreshold,
              clickDistThreshold: this.clickDistThreshold,
              tooltip: e.getString("Tooltips.Flip"),
              srcRest: _e(this.prefixUrl, b.flip.REST),
              srcGroup: _e(this.prefixUrl, b.flip.GROUP),
              srcHover: _e(this.prefixUrl, b.flip.HOVER),
              srcDown: _e(this.prefixUrl, b.flip.DOWN),
              onRelease: Se,
              onFocus: ge,
              onBlur: Me
            })), T ? (this.buttonGroup = new e.ButtonGroup({
              buttons: _,
              clickTimeThreshold: this.clickTimeThreshold,
              clickDistThreshold: this.clickDistThreshold
            }), this.navControl = this.buttonGroup.element, this.addHandler("open", e.delegate(this, At)), this.toolbar ? this.toolbar.addControl(
              this.navControl,
              { anchor: this.navigationControlAnchor || e.ControlAnchor.TOP_LEFT }
            ) : this.addControl(
              this.navControl,
              { anchor: this.navigationControlAnchor || e.ControlAnchor.TOP_LEFT }
            )) : this.customButtons = _), this;
          },
          /**
           * Gets the active page of a sequence
           * @function
           * @returns {Number}
           */
          currentPage: function() {
            return this._sequenceIndex;
          },
          /**
           * @function
           * @returns {OpenSeadragon.Viewer} Chainable.
           * @fires OpenSeadragon.Viewer.event:page
           */
          goToPage: function(m) {
            return this.tileSources && m >= 0 && m < this.tileSources.length && (this._sequenceIndex = m, this._updateSequenceButtons(m), this.open(this.tileSources[m]), this.referenceStrip && this.referenceStrip.setFocus(m), this.raiseEvent("page", { page: m })), this;
          },
          /**
            * Adds an html element as an overlay to the current viewport.  Useful for
            * highlighting words or areas of interest on an image or other zoomable
            * interface. The overlays added via this method are removed when the viewport
            * is closed which include when changing page.
            * @method
            * @param {Element|String|Object} element - A reference to an element or an id for
            *      the element which will be overlaid. Or an Object specifying the configuration for the overlay.
            *      If using an object, see {@link OpenSeadragon.Overlay} for a list of
            *      all available options.
            * @param {OpenSeadragon.Point|OpenSeadragon.Rect} location - The point or
            *      rectangle which will be overlaid. This is a viewport relative location.
            * @param {OpenSeadragon.Placement} [placement=OpenSeadragon.Placement.TOP_LEFT] - The position of the
            *      viewport which the location coordinates will be treated as relative
            *      to.
            * @param {function} [onDraw] - If supplied the callback is called when the overlay
            *      needs to be drawn. It is the responsibility of the callback to do any drawing/positioning.
            *      It is passed position, size and element.
            * @returns {OpenSeadragon.Viewer} Chainable.
            * @fires OpenSeadragon.Viewer.event:add-overlay
            */
          addOverlay: function(m, P, U, J) {
            var ie;
            if (e.isPlainObject(m) ? ie = m : ie = {
              element: m,
              location: P,
              placement: U,
              onDraw: J
            }, m = e.getElement(ie.element), l(this.currentOverlays, m) >= 0)
              return this;
            var de = a(this, ie);
            return this.currentOverlays.push(de), de.drawHTML(this.overlaysContainer, this.viewport), this.raiseEvent("add-overlay", {
              element: m,
              location: ie.location,
              placement: ie.placement
            }), this;
          },
          /**
           * Updates the overlay represented by the reference to the element or
           * element id moving it to the new location, relative to the new placement.
           * @method
           * @param {Element|String} element - A reference to an element or an id for
           *      the element which is overlaid.
           * @param {OpenSeadragon.Point|OpenSeadragon.Rect} location - The point or
           *      rectangle which will be overlaid. This is a viewport relative location.
           * @param {OpenSeadragon.Placement} [placement=OpenSeadragon.Placement.TOP_LEFT] - The position of the
           *      viewport which the location coordinates will be treated as relative
           *      to.
           * @returns {OpenSeadragon.Viewer} Chainable.
           * @fires OpenSeadragon.Viewer.event:update-overlay
           */
          updateOverlay: function(m, P, U) {
            var J;
            return m = e.getElement(m), J = l(this.currentOverlays, m), J >= 0 && (this.currentOverlays[J].update(P, U), t[this.hash].forceRedraw = !0, this.raiseEvent("update-overlay", {
              element: m,
              location: P,
              placement: U
            })), this;
          },
          /**
           * Removes an overlay identified by the reference element or element id
           * and schedules an update.
           * @method
           * @param {Element|String} element - A reference to the element or an
           *      element id which represent the ovelay content to be removed.
           * @returns {OpenSeadragon.Viewer} Chainable.
           * @fires OpenSeadragon.Viewer.event:remove-overlay
           */
          removeOverlay: function(m) {
            var P;
            return m = e.getElement(m), P = l(this.currentOverlays, m), P >= 0 && (this.currentOverlays[P].destroy(), this.currentOverlays.splice(P, 1), t[this.hash].forceRedraw = !0, this.raiseEvent("remove-overlay", {
              element: m
            })), this;
          },
          /**
           * Removes all currently configured Overlays from this Viewer and schedules
           * an update.
           * @method
           * @returns {OpenSeadragon.Viewer} Chainable.
           * @fires OpenSeadragon.Viewer.event:clear-overlay
           */
          clearOverlays: function() {
            for (; this.currentOverlays.length > 0; )
              this.currentOverlays.pop().destroy();
            return t[this.hash].forceRedraw = !0, this.raiseEvent("clear-overlay", {}), this;
          },
          /**
          * Finds an overlay identified by the reference element or element id
          * and returns it as an object, return null if not found.
          * @method
          * @param {Element|String} element - A reference to the element or an
          *      element id which represents the overlay content.
          * @returns {OpenSeadragon.Overlay} the matching overlay or null if none found.
          */
          getOverlayById: function(m) {
            var P;
            return m = e.getElement(m), P = l(this.currentOverlays, m), P >= 0 ? this.currentOverlays[P] : null;
          },
          /**
           * Updates the sequence buttons.
           * @function OpenSeadragon.Viewer.prototype._updateSequenceButtons
           * @private
           * @param {Number} Sequence Value
           */
          _updateSequenceButtons: function(m) {
            this.nextButton && (!this.tileSources || this.tileSources.length - 1 === m ? this.navPrevNextWrap || this.nextButton.disable() : this.nextButton.enable()), this.previousButton && (m > 0 ? this.previousButton.enable() : this.navPrevNextWrap || this.previousButton.disable());
          },
          /**
           * Display a message in the viewport
           * @function OpenSeadragon.Viewer.prototype._showMessage
           * @private
           * @param {String} text message
           */
          _showMessage: function(m) {
            this._hideMessage();
            var P = e.makeNeutralElement("div");
            P.appendChild(document.createTextNode(m)), this.messageDiv = e.makeCenteredNode(P), e.addClass(this.messageDiv, "openseadragon-message"), this.container.appendChild(this.messageDiv);
          },
          /**
           * Hide any currently displayed viewport message
           * @function OpenSeadragon.Viewer.prototype._hideMessage
           * @private
           */
          _hideMessage: function() {
            var m = this.messageDiv;
            m && (m.parentNode.removeChild(m), delete this.messageDiv);
          },
          /**
           * Gets this viewer's gesture settings for the given pointer device type.
           * @method
           * @param {String} type - The pointer device type to get the gesture settings for ("mouse", "touch", "pen", etc.).
           * @returns {OpenSeadragon.GestureSettings}
           */
          gestureSettingsByDeviceType: function(m) {
            switch (m) {
              case "mouse":
                return this.gestureSettingsMouse;
              case "touch":
                return this.gestureSettingsTouch;
              case "pen":
                return this.gestureSettingsPen;
              default:
                return this.gestureSettingsUnknown;
            }
          },
          // private
          _drawOverlays: function() {
            var m, P = this.currentOverlays.length;
            for (m = 0; m < P; m++)
              this.currentOverlays[m].drawHTML(this.overlaysContainer, this.viewport);
          },
          /**
           * Cancel the "in flight" images.
           */
          _cancelPendingImages: function() {
            this._loadQueue = [];
          },
          /**
           * Removes the reference strip and disables displaying it.
           * @function
           */
          removeReferenceStrip: function() {
            this.showReferenceStrip = !1, this.referenceStrip && (this.referenceStrip.destroy(), this.referenceStrip = null);
          },
          /**
           * Enables and displays the reference strip based on the currently set tileSources.
           * Works only when the Viewer has sequenceMode set to true.
           * @function
           */
          addReferenceStrip: function() {
            if (this.showReferenceStrip = !0, this.sequenceMode) {
              if (this.referenceStrip)
                return;
              this.tileSources.length && this.tileSources.length > 1 && (this.referenceStrip = new e.ReferenceStrip({
                id: this.referenceStripElement,
                position: this.referenceStripPosition,
                sizeRatio: this.referenceStripSizeRatio,
                scroll: this.referenceStripScroll,
                height: this.referenceStripHeight,
                width: this.referenceStripWidth,
                tileSources: this.tileSources,
                prefixUrl: this.prefixUrl,
                viewer: this
              }), this.referenceStrip.setFocus(this._sequenceIndex));
            } else
              e.console.warn('Attempting to display a reference strip while "sequenceMode" is off.');
          },
          /**
           * Adds _updatePixelDensityRatio to the window resize event.
           * @private
           */
          _addUpdatePixelDensityRatioEvent: function() {
            this._updatePixelDensityRatioBind = this._updatePixelDensityRatio.bind(this), e.addEvent(window, "resize", this._updatePixelDensityRatioBind);
          },
          /**
           * Removes _updatePixelDensityRatio from the window resize event.
           * @private
           */
          _removeUpdatePixelDensityRatioEvent: function() {
            e.removeEvent(window, "resize", this._updatePixelDensityRatioBind);
          },
          /**
           * Update pixel density ratio and forces a resize operation.
           * @private
           */
          _updatePixelDensityRatio: function() {
            var m = e.pixelDensityRatio, P = e.getCurrentPixelDensityRatio();
            m !== P && (e.pixelDensityRatio = P, this.forceResize());
          },
          /**
           * Sets the image source to the source with index equal to
           * currentIndex - 1. Changes current image in sequence mode.
           * If specified, wraps around (see navPrevNextWrap in
           * {@link OpenSeadragon.Options})
           *
           * @method
           */
          goToPreviousPage: function() {
            var m = this._sequenceIndex - 1;
            this.navPrevNextWrap && m < 0 && (m += this.tileSources.length), this.goToPage(m);
          },
          /**
           * Sets the image source to the source with index equal to
           * currentIndex + 1. Changes current image in sequence mode.
           * If specified, wraps around (see navPrevNextWrap in
           * {@link OpenSeadragon.Options})
           *
           * @method
           */
          goToNextPage: function() {
            var m = this._sequenceIndex + 1;
            this.navPrevNextWrap && m >= this.tileSources.length && (m = 0), this.goToPage(m);
          },
          isAnimating: function() {
            return t[this.hash].animating;
          }
        }
      );
      function n(m) {
        return m = e.getElement(m), new e.Point(
          m.clientWidth === 0 ? 1 : m.clientWidth,
          m.clientHeight === 0 ? 1 : m.clientHeight
        );
      }
      function o(m, P, U, J, ie) {
        var de = m;
        if (e.type(P) === "string") {
          if (P.match(/^\s*<.*>\s*$/))
            P = e.parseXml(P);
          else if (P.match(/^\s*[{[].*[}\]]\s*$/))
            try {
              var X = e.parseJSON(P);
              P = X;
            } catch {
            }
        }
        function me(Ce, Se) {
          Ce.ready ? J(Ce) : (Ce.addHandler("ready", function() {
            J(Ce);
          }), Ce.addHandler("open-failed", function(ge) {
            ie({
              message: ge.message,
              source: Se
            });
          }));
        }
        setTimeout(function() {
          if (e.type(P) === "string")
            P = new e.TileSource({
              url: P,
              crossOriginPolicy: U.crossOriginPolicy !== void 0 ? U.crossOriginPolicy : m.crossOriginPolicy,
              ajaxWithCredentials: m.ajaxWithCredentials,
              ajaxHeaders: U.ajaxHeaders ? U.ajaxHeaders : m.ajaxHeaders,
              splitHashDataForPost: m.splitHashDataForPost,
              success: function(Me) {
                J(Me.tileSource);
              }
            }), P.addHandler("open-failed", function(Me) {
              ie(Me);
            });
          else if (e.isPlainObject(P) || P.nodeType)
            if (P.crossOriginPolicy === void 0 && (U.crossOriginPolicy !== void 0 || m.crossOriginPolicy !== void 0) && (P.crossOriginPolicy = U.crossOriginPolicy !== void 0 ? U.crossOriginPolicy : m.crossOriginPolicy), P.ajaxWithCredentials === void 0 && (P.ajaxWithCredentials = m.ajaxWithCredentials), e.isFunction(P.getTileUrl)) {
              var Ce = new e.TileSource(P);
              Ce.getTileUrl = P.getTileUrl, J(Ce);
            } else {
              var Se = e.TileSource.determineType(de, P);
              if (!Se) {
                ie({
                  message: "Unable to load TileSource",
                  source: P
                });
                return;
              }
              var ge = Se.prototype.configure.apply(de, [P]);
              me(new Se(ge), P);
            }
          else
            me(P, P);
        });
      }
      function a(m, P) {
        if (P instanceof e.Overlay)
          return P;
        var U = null;
        if (P.element)
          U = e.getElement(P.element);
        else {
          var J = P.id ? P.id : "openseadragon-overlay-" + Math.floor(Math.random() * 1e7);
          U = e.getElement(P.id), U || (U = document.createElement("a"), U.href = "#/overlay/" + J), U.id = J, e.addClass(
            U,
            P.className ? P.className : "openseadragon-overlay"
          );
        }
        var ie = P.location, de = P.width, X = P.height;
        if (!ie) {
          var me = P.x, Ce = P.y;
          if (P.px !== void 0) {
            var Se = m.viewport.imageToViewportRectangle(new e.Rect(
              P.px,
              P.py,
              de || 0,
              X || 0
            ));
            me = Se.x, Ce = Se.y, de = de !== void 0 ? Se.width : void 0, X = X !== void 0 ? Se.height : void 0;
          }
          ie = new e.Point(me, Ce);
        }
        var ge = P.placement;
        return ge && e.type(ge) === "string" && (ge = e.Placement[P.placement.toUpperCase()]), new e.Overlay({
          element: U,
          location: ie,
          placement: ge,
          onDraw: P.onDraw,
          checkResize: P.checkResize,
          width: de,
          height: X,
          rotationMode: P.rotationMode
        });
      }
      function l(m, P) {
        var U;
        for (U = m.length - 1; U >= 0; U--)
          if (m[U].element === P)
            return U;
        return -1;
      }
      function h(m, P) {
        return e.requestAnimationFrame(function() {
          P(m);
        });
      }
      function d(m) {
        e.requestAnimationFrame(function() {
          g(m);
        });
      }
      function f(m) {
        m.autoHideControls && (m.controlsShouldFade = !0, m.controlsFadeBeginTime = e.now() + m.controlsFadeDelay, window.setTimeout(function() {
          d(m);
        }, m.controlsFadeDelay));
      }
      function g(m) {
        var P, U, J, ie;
        if (m.controlsShouldFade) {
          for (P = e.now(), U = P - m.controlsFadeBeginTime, J = 1 - U / m.controlsFadeLength, J = Math.min(1, J), J = Math.max(0, J), ie = m.controls.length - 1; ie >= 0; ie--)
            m.controls[ie].autoFade && m.controls[ie].setOpacity(J);
          J > 0 && d(m);
        }
      }
      function w(m) {
        var P;
        for (m.controlsShouldFade = !1, P = m.controls.length - 1; P >= 0; P--)
          m.controls[P].setOpacity(1);
      }
      function C() {
        w(this);
      }
      function E() {
        f(this);
      }
      function A(m) {
        var P = {
          tracker: m.eventSource,
          position: m.position,
          originalEvent: m.originalEvent,
          preventDefault: m.preventDefault
        };
        this.raiseEvent("canvas-contextmenu", P), m.preventDefault = P.preventDefault;
      }
      function I(m) {
        var P = {
          originalEvent: m.originalEvent,
          preventDefaultAction: !1,
          preventVerticalPan: m.preventVerticalPan || !this.panVertical,
          preventHorizontalPan: m.preventHorizontalPan || !this.panHorizontal
        };
        if (this.raiseEvent("canvas-key", P), !P.preventDefaultAction && !m.ctrl && !m.alt && !m.meta)
          switch (m.keyCode) {
            case 38:
              P.preventVerticalPan || (m.shift ? this.viewport.zoomBy(1.1) : this.viewport.panBy(this.viewport.deltaPointsFromPixels(new e.Point(0, -this.pixelsPerArrowPress))), this.viewport.applyConstraints()), m.preventDefault = !0;
              break;
            case 40:
              P.preventVerticalPan || (m.shift ? this.viewport.zoomBy(0.9) : this.viewport.panBy(this.viewport.deltaPointsFromPixels(new e.Point(0, this.pixelsPerArrowPress))), this.viewport.applyConstraints()), m.preventDefault = !0;
              break;
            case 37:
              P.preventHorizontalPan || (this.viewport.panBy(this.viewport.deltaPointsFromPixels(new e.Point(-this.pixelsPerArrowPress, 0))), this.viewport.applyConstraints()), m.preventDefault = !0;
              break;
            case 39:
              P.preventHorizontalPan || (this.viewport.panBy(this.viewport.deltaPointsFromPixels(new e.Point(this.pixelsPerArrowPress, 0))), this.viewport.applyConstraints()), m.preventDefault = !0;
              break;
            case 187:
              this.viewport.zoomBy(1.1), this.viewport.applyConstraints(), m.preventDefault = !0;
              break;
            case 189:
              this.viewport.zoomBy(0.9), this.viewport.applyConstraints(), m.preventDefault = !0;
              break;
            case 48:
              this.viewport.goHome(), this.viewport.applyConstraints(), m.preventDefault = !0;
              break;
            case 87:
              P.preventVerticalPan || (m.shift ? this.viewport.zoomBy(1.1) : this.viewport.panBy(this.viewport.deltaPointsFromPixels(new e.Point(0, -40))), this.viewport.applyConstraints()), m.preventDefault = !0;
              break;
            case 83:
              P.preventVerticalPan || (m.shift ? this.viewport.zoomBy(0.9) : this.viewport.panBy(this.viewport.deltaPointsFromPixels(new e.Point(0, 40))), this.viewport.applyConstraints()), m.preventDefault = !0;
              break;
            case 65:
              P.preventHorizontalPan || (this.viewport.panBy(this.viewport.deltaPointsFromPixels(new e.Point(-40, 0))), this.viewport.applyConstraints()), m.preventDefault = !0;
              break;
            case 68:
              P.preventHorizontalPan || (this.viewport.panBy(this.viewport.deltaPointsFromPixels(new e.Point(40, 0))), this.viewport.applyConstraints()), m.preventDefault = !0;
              break;
            case 82:
              m.shift ? this.viewport.flipped ? this.viewport.setRotation(this.viewport.getRotation() + this.rotationIncrement) : this.viewport.setRotation(this.viewport.getRotation() - this.rotationIncrement) : this.viewport.flipped ? this.viewport.setRotation(this.viewport.getRotation() - this.rotationIncrement) : this.viewport.setRotation(this.viewport.getRotation() + this.rotationIncrement), this.viewport.applyConstraints(), m.preventDefault = !0;
              break;
            case 70:
              this.viewport.toggleFlip(), m.preventDefault = !0;
              break;
            case 74:
              this.goToPreviousPage();
              break;
            case 75:
              this.goToNextPage();
              break;
            default:
              m.preventDefault = !1;
              break;
          }
        else
          m.preventDefault = !1;
      }
      function V(m) {
        var P = {
          originalEvent: m.originalEvent
        };
        this.raiseEvent("canvas-key-press", P);
      }
      function K(m) {
        var P, U = document.activeElement === this.canvas;
        U || this.canvas.focus(), this.viewport.flipped && (m.position.x = this.viewport.getContainerSize().x - m.position.x);
        var J = {
          tracker: m.eventSource,
          position: m.position,
          quick: m.quick,
          shift: m.shift,
          originalEvent: m.originalEvent,
          originalTarget: m.originalTarget,
          preventDefaultAction: !1
        };
        this.raiseEvent("canvas-click", J), !J.preventDefaultAction && this.viewport && m.quick && (P = this.gestureSettingsByDeviceType(m.pointerType), P.clickToZoom === !0 && (this.viewport.zoomBy(
          m.shift ? 1 / this.zoomPerClick : this.zoomPerClick,
          P.zoomToRefPoint ? this.viewport.pointFromPixel(m.position, !0) : null
        ), this.viewport.applyConstraints()), P.dblClickDragToZoom && (t[this.hash].draggingToZoom === !0 ? (t[this.hash].lastClickTime = null, t[this.hash].draggingToZoom = !1) : t[this.hash].lastClickTime = e.now()));
      }
      function ce(m) {
        var P, U = {
          tracker: m.eventSource,
          position: m.position,
          shift: m.shift,
          originalEvent: m.originalEvent,
          preventDefaultAction: !1
        };
        this.raiseEvent("canvas-double-click", U), !U.preventDefaultAction && this.viewport && (P = this.gestureSettingsByDeviceType(m.pointerType), P.dblClickToZoom && (this.viewport.zoomBy(
          m.shift ? 1 / this.zoomPerClick : this.zoomPerClick,
          P.zoomToRefPoint ? this.viewport.pointFromPixel(m.position, !0) : null
        ), this.viewport.applyConstraints()));
      }
      function re(m) {
        var P, U = {
          tracker: m.eventSource,
          pointerType: m.pointerType,
          position: m.position,
          delta: m.delta,
          speed: m.speed,
          direction: m.direction,
          shift: m.shift,
          originalEvent: m.originalEvent,
          preventDefaultAction: !1
        };
        if (this.raiseEvent("canvas-drag", U), P = this.gestureSettingsByDeviceType(m.pointerType), !U.preventDefaultAction && this.viewport) {
          if (P.dblClickDragToZoom && t[this.hash].draggingToZoom) {
            var J = Math.pow(this.zoomPerDblClickDrag, m.delta.y / 50);
            this.viewport.zoomBy(J);
          } else if (P.dragToPan && !t[this.hash].draggingToZoom) {
            if (this.panHorizontal || (m.delta.x = 0), this.panVertical || (m.delta.y = 0), this.viewport.flipped && (m.delta.x = -m.delta.x), this.constrainDuringPan) {
              var ie = this.viewport.deltaPointsFromPixels(m.delta.negate());
              this.viewport.centerSpringX.target.value += ie.x, this.viewport.centerSpringY.target.value += ie.y;
              var de = this.viewport.getConstrainedBounds();
              this.viewport.centerSpringX.target.value -= ie.x, this.viewport.centerSpringY.target.value -= ie.y, de.xConstrained && (m.delta.x = 0), de.yConstrained && (m.delta.y = 0);
            }
            this.viewport.panBy(this.viewport.deltaPointsFromPixels(m.delta.negate()), P.flickEnabled && !this.constrainDuringPan);
          }
        }
      }
      function he(m) {
        var P, U = {
          tracker: m.eventSource,
          pointerType: m.pointerType,
          position: m.position,
          speed: m.speed,
          direction: m.direction,
          shift: m.shift,
          originalEvent: m.originalEvent,
          preventDefaultAction: !1
        };
        if (this.raiseEvent("canvas-drag-end", U), P = this.gestureSettingsByDeviceType(m.pointerType), !U.preventDefaultAction && this.viewport) {
          if (!t[this.hash].draggingToZoom && P.dragToPan && P.flickEnabled && m.speed >= P.flickMinSpeed) {
            var J = 0;
            this.panHorizontal && (J = P.flickMomentum * m.speed * Math.cos(m.direction));
            var ie = 0;
            this.panVertical && (ie = P.flickMomentum * m.speed * Math.sin(m.direction));
            var de = this.viewport.pixelFromPoint(
              this.viewport.getCenter(!0)
            ), X = this.viewport.pointFromPixel(
              new e.Point(de.x - J, de.y - ie)
            );
            this.viewport.panTo(X, !1);
          }
          this.viewport.applyConstraints();
        }
        P.dblClickDragToZoom && t[this.hash].draggingToZoom === !0 && (t[this.hash].draggingToZoom = !1);
      }
      function pe(m) {
        this.raiseEvent("canvas-enter", {
          tracker: m.eventSource,
          pointerType: m.pointerType,
          position: m.position,
          buttons: m.buttons,
          pointers: m.pointers,
          insideElementPressed: m.insideElementPressed,
          buttonDownAny: m.buttonDownAny,
          originalEvent: m.originalEvent
        });
      }
      function Te(m) {
        this.raiseEvent("canvas-exit", {
          tracker: m.eventSource,
          pointerType: m.pointerType,
          position: m.position,
          buttons: m.buttons,
          pointers: m.pointers,
          insideElementPressed: m.insideElementPressed,
          buttonDownAny: m.buttonDownAny,
          originalEvent: m.originalEvent
        });
      }
      function Ae(m) {
        var P;
        if (this.raiseEvent("canvas-press", {
          tracker: m.eventSource,
          pointerType: m.pointerType,
          position: m.position,
          insideElementPressed: m.insideElementPressed,
          insideElementReleased: m.insideElementReleased,
          originalEvent: m.originalEvent
        }), P = this.gestureSettingsByDeviceType(m.pointerType), P.dblClickDragToZoom) {
          var U = t[this.hash].lastClickTime, J = e.now();
          if (U === null)
            return;
          J - U < this.dblClickTimeThreshold && (t[this.hash].draggingToZoom = !0), t[this.hash].lastClickTime = null;
        }
      }
      function He(m) {
        this.raiseEvent("canvas-release", {
          tracker: m.eventSource,
          pointerType: m.pointerType,
          position: m.position,
          insideElementPressed: m.insideElementPressed,
          insideElementReleased: m.insideElementReleased,
          originalEvent: m.originalEvent
        });
      }
      function Fe(m) {
        this.raiseEvent("canvas-nonprimary-press", {
          tracker: m.eventSource,
          position: m.position,
          pointerType: m.pointerType,
          button: m.button,
          buttons: m.buttons,
          originalEvent: m.originalEvent
        });
      }
      function ve(m) {
        this.raiseEvent("canvas-nonprimary-release", {
          tracker: m.eventSource,
          position: m.position,
          pointerType: m.pointerType,
          button: m.button,
          buttons: m.buttons,
          originalEvent: m.originalEvent
        });
      }
      function Re(m) {
        var P, U, J, ie, de = {
          tracker: m.eventSource,
          pointerType: m.pointerType,
          gesturePoints: m.gesturePoints,
          lastCenter: m.lastCenter,
          center: m.center,
          lastDistance: m.lastDistance,
          distance: m.distance,
          shift: m.shift,
          originalEvent: m.originalEvent,
          preventDefaultPanAction: !1,
          preventDefaultZoomAction: !1,
          preventDefaultRotateAction: !1
        };
        if (this.raiseEvent("canvas-pinch", de), this.viewport && (P = this.gestureSettingsByDeviceType(m.pointerType), P.pinchToZoom && (!de.preventDefaultPanAction || !de.preventDefaultZoomAction) && (U = this.viewport.pointFromPixel(m.center, !0), P.zoomToRefPoint && !de.preventDefaultPanAction && (J = this.viewport.pointFromPixel(m.lastCenter, !0), ie = J.minus(U), this.panHorizontal || (ie.x = 0), this.panVertical || (ie.y = 0), this.viewport.panBy(ie, !0)), de.preventDefaultZoomAction || this.viewport.zoomBy(m.distance / m.lastDistance, U, !0), this.viewport.applyConstraints()), P.pinchRotate && !de.preventDefaultRotateAction)) {
          var X = Math.atan2(
            m.gesturePoints[0].currentPos.y - m.gesturePoints[1].currentPos.y,
            m.gesturePoints[0].currentPos.x - m.gesturePoints[1].currentPos.x
          ), me = Math.atan2(
            m.gesturePoints[0].lastPos.y - m.gesturePoints[1].lastPos.y,
            m.gesturePoints[0].lastPos.x - m.gesturePoints[1].lastPos.x
          );
          U = this.viewport.pointFromPixel(m.center, !0), this.viewport.rotateTo(this.viewport.getRotation(!0) + (X - me) * (180 / Math.PI), U, !0);
        }
      }
      function Ze(m) {
        this.raiseEvent("canvas-focus", {
          tracker: m.eventSource,
          originalEvent: m.originalEvent
        });
      }
      function Ue(m) {
        this.raiseEvent("canvas-blur", {
          tracker: m.eventSource,
          originalEvent: m.originalEvent
        });
      }
      function We(m) {
        var P, U, J, ie, de;
        ie = e.now(), de = ie - this._lastScrollTime, de > this.minScrollDeltaTime ? (this._lastScrollTime = ie, P = {
          tracker: m.eventSource,
          position: m.position,
          scroll: m.scroll,
          shift: m.shift,
          originalEvent: m.originalEvent,
          preventDefaultAction: !1,
          preventDefault: !0
        }, this.raiseEvent("canvas-scroll", P), !P.preventDefaultAction && this.viewport && (this.viewport.flipped && (m.position.x = this.viewport.getContainerSize().x - m.position.x), U = this.gestureSettingsByDeviceType(m.pointerType), U.scrollToZoom && (J = Math.pow(this.zoomPerScroll, m.scroll), this.viewport.zoomBy(
          J,
          U.zoomToRefPoint ? this.viewport.pointFromPixel(m.position, !0) : null
        ), this.viewport.applyConstraints())), m.preventDefault = P.preventDefault) : m.preventDefault = !0;
      }
      function it(m) {
        t[this.hash].mouseInside = !0, w(this), this.raiseEvent("container-enter", {
          tracker: m.eventSource,
          pointerType: m.pointerType,
          position: m.position,
          buttons: m.buttons,
          pointers: m.pointers,
          insideElementPressed: m.insideElementPressed,
          buttonDownAny: m.buttonDownAny,
          originalEvent: m.originalEvent
        });
      }
      function Ve(m) {
        m.pointers < 1 && (t[this.hash].mouseInside = !1, t[this.hash].animating || f(this)), this.raiseEvent("container-exit", {
          tracker: m.eventSource,
          pointerType: m.pointerType,
          position: m.position,
          buttons: m.buttons,
          pointers: m.pointers,
          insideElementPressed: m.insideElementPressed,
          buttonDownAny: m.buttonDownAny,
          originalEvent: m.originalEvent
        });
      }
      function rt(m) {
        ti(m), m.isOpen() ? m._updateRequestId = h(m, rt) : m._updateRequestId = !1;
      }
      function Ye(m, P) {
        var U = m.viewport, J = U.getZoom(), ie = U.getCenter();
        U.resize(P, m.preserveImageSizeOnResize), U.panTo(ie, !0);
        var de;
        if (m.preserveImageSizeOnResize)
          de = t[m.hash].prevContainerSize.x / P.x;
        else {
          var X = new e.Point(0, 0), me = new e.Point(t[m.hash].prevContainerSize.x, t[m.hash].prevContainerSize.y).distanceTo(X), Ce = new e.Point(P.x, P.y).distanceTo(X);
          de = Ce / me * t[m.hash].prevContainerSize.x / P.x;
        }
        U.zoomTo(J * de, null, !0), t[m.hash].prevContainerSize = P, t[m.hash].forceRedraw = !0, t[m.hash].needsResize = !1, t[m.hash].forceResize = !1;
      }
      function ti(m) {
        if (!(m._opening || !t[m.hash])) {
          if (m.autoResize || t[m.hash].forceResize) {
            var P;
            if (m._autoResizePolling) {
              P = n(m.container);
              var U = t[m.hash].prevContainerSize;
              P.equals(U) || (t[m.hash].needsResize = !0);
            }
            t[m.hash].needsResize && Ye(m, P || n(m.container));
          }
          var J = m.viewport.update(), ie = m.world.update(J) || J;
          J && m.raiseEvent("viewport-change"), m.referenceStrip && (ie = m.referenceStrip.update(m.viewport) || ie);
          var de = t[m.hash].animating;
          !de && ie && (m.raiseEvent("animation-start"), w(m));
          var X = de && !ie;
          X && (t[m.hash].animating = !1), (ie || X || t[m.hash].forceRedraw || m.world.needsDraw()) && (ir(m), m._drawOverlays(), m.navigator && m.navigator.update(m.viewport), t[m.hash].forceRedraw = !1, ie && m.raiseEvent("animation")), X && (m.raiseEvent("animation-finish"), t[m.hash].mouseInside || f(m)), t[m.hash].animating = ie;
        }
      }
      function ir(m) {
        m.imageLoader.clear(), m.world.draw(), m.raiseEvent("update-viewport", {});
      }
      function _e(m, P) {
        return m ? m + P : P;
      }
      function ii() {
        t[this.hash].lastZoomTime = e.now(), t[this.hash].zoomFactor = this.zoomPerSecond, t[this.hash].zooming = !0, xt(this);
      }
      function kt() {
        t[this.hash].lastZoomTime = e.now(), t[this.hash].zoomFactor = 1 / this.zoomPerSecond, t[this.hash].zooming = !0, xt(this);
      }
      function _t() {
        t[this.hash].zooming = !1;
      }
      function xt(m) {
        e.requestAnimationFrame(e.delegate(m, Si));
      }
      function Si() {
        var m, P, U;
        t[this.hash].zooming && this.viewport && (m = e.now(), P = m - t[this.hash].lastZoomTime, U = Math.pow(t[this.hash].zoomFactor, P / 1e3), this.viewport.zoomBy(U), this.viewport.applyConstraints(), t[this.hash].lastZoomTime = m, xt(this));
      }
      function fe() {
        this.viewport && (t[this.hash].zooming = !1, this.viewport.zoomBy(
          this.zoomPerClick / 1
        ), this.viewport.applyConstraints());
      }
      function ri() {
        this.viewport && (t[this.hash].zooming = !1, this.viewport.zoomBy(
          1 / this.zoomPerClick
        ), this.viewport.applyConstraints());
      }
      function At() {
        this.buttonGroup && (this.buttonGroup.emulateEnter(), this.buttonGroup.emulateLeave());
      }
      function Ie() {
        this.viewport && this.viewport.goHome();
      }
      function Ct() {
        this.isFullPage() && !e.isFullScreen() ? this.setFullPage(!1) : this.setFullScreen(!this.isFullPage()), this.buttonGroup && this.buttonGroup.emulateLeave(), this.fullPageButton.element.focus(), this.viewport && this.viewport.applyConstraints();
      }
      function rr() {
        if (this.viewport) {
          var m = this.viewport.getRotation();
          this.viewport.flipped ? m += this.rotationIncrement : m -= this.rotationIncrement, this.viewport.setRotation(m);
        }
      }
      function ut() {
        if (this.viewport) {
          var m = this.viewport.getRotation();
          this.viewport.flipped ? m -= this.rotationIncrement : m += this.rotationIncrement, this.viewport.setRotation(m);
        }
      }
      function Mt() {
        this.viewport.toggleFlip();
      }
      e.determineDrawer = function(m) {
        for (let P in r) {
          const U = r[P], J = U.prototype;
          if (J && J instanceof r.DrawerBase && e.isFunction(J.getType) && J.getType.call(U) === m)
            return U;
        }
        return null;
      };
    }(r), function(e) {
      e.Navigator = function(h) {
        var d = h.viewer, f = this, g, w;
        h.element || h.id ? (h.element ? (h.id && e.console.warn("Given option.id for Navigator was ignored since option.element was provided and is being used instead."), h.element.id ? h.id = h.element.id : h.id = "navigator-" + e.now(), this.element = h.element) : this.element = document.getElementById(h.id), h.controlOptions = {
          anchor: e.ControlAnchor.NONE,
          attachToViewer: !1,
          autoFade: !1
        }) : (h.id = "navigator-" + e.now(), this.element = e.makeNeutralElement("div"), h.controlOptions = {
          anchor: e.ControlAnchor.TOP_RIGHT,
          attachToViewer: !0,
          autoFade: h.autoFade
        }, h.position && (h.position === "BOTTOM_RIGHT" ? h.controlOptions.anchor = e.ControlAnchor.BOTTOM_RIGHT : h.position === "BOTTOM_LEFT" ? h.controlOptions.anchor = e.ControlAnchor.BOTTOM_LEFT : h.position === "TOP_RIGHT" ? h.controlOptions.anchor = e.ControlAnchor.TOP_RIGHT : h.position === "TOP_LEFT" ? h.controlOptions.anchor = e.ControlAnchor.TOP_LEFT : h.position === "ABSOLUTE" && (h.controlOptions.anchor = e.ControlAnchor.ABSOLUTE, h.controlOptions.top = h.top, h.controlOptions.left = h.left, h.controlOptions.height = h.height, h.controlOptions.width = h.width))), this.element.id = h.id, this.element.className += " navigator", h = e.extend(!0, {
          sizeRatio: e.DEFAULT_SETTINGS.navigatorSizeRatio
        }, h, {
          element: this.element,
          tabIndex: -1,
          // No keyboard navigation, omit from tab order
          //These need to be overridden to prevent recursion since
          //the navigator is a viewer and a viewer has a navigator
          showNavigator: !1,
          mouseNavEnabled: !1,
          showNavigationControl: !1,
          showSequenceControl: !1,
          immediateRender: !0,
          blendTime: 0,
          animationTime: h.animationTime,
          // disable autoResize since resize behavior is implemented differently by the navigator
          autoResize: !1,
          // prevent resizing the navigator from adding unwanted space around the image
          minZoomImageRatio: 1,
          background: h.background,
          opacity: h.opacity,
          borderColor: h.borderColor,
          displayRegionColor: h.displayRegionColor
        }), h.minPixelRatio = this.minPixelRatio = d.minPixelRatio, e.setElementTouchActionNone(this.element), this.borderWidth = 2, this.fudge = new e.Point(1, 1), this.totalBorderWidths = new e.Point(this.borderWidth * 2, this.borderWidth * 2).minus(this.fudge), h.controlOptions.anchor !== e.ControlAnchor.NONE && function(A, I) {
          A.margin = "0px", A.border = I + "px solid " + h.borderColor, A.padding = "0px", A.background = h.background, A.opacity = h.opacity, A.overflow = "hidden";
        }(this.element.style, this.borderWidth), this.displayRegion = e.makeNeutralElement("div"), this.displayRegion.id = this.element.id + "-displayregion", this.displayRegion.className = "displayregion", function(A, I) {
          A.position = "relative", A.top = "0px", A.left = "0px", A.fontSize = "0px", A.overflow = "hidden", A.border = I + "px solid " + h.displayRegionColor, A.margin = "0px", A.padding = "0px", A.background = "transparent", A.float = "left", A.cssFloat = "left", A.zIndex = 999999999, A.cursor = "default", A.boxSizing = "content-box";
        }(this.displayRegion.style, this.borderWidth), e.setElementPointerEventsNone(this.displayRegion), e.setElementTouchActionNone(this.displayRegion), this.displayRegionContainer = e.makeNeutralElement("div"), this.displayRegionContainer.id = this.element.id + "-displayregioncontainer", this.displayRegionContainer.className = "displayregioncontainer", this.displayRegionContainer.style.width = "100%", this.displayRegionContainer.style.height = "100%", e.setElementPointerEventsNone(this.displayRegionContainer), e.setElementTouchActionNone(this.displayRegionContainer), d.addControl(
          this.element,
          h.controlOptions
        ), this._resizeWithViewer = h.controlOptions.anchor !== e.ControlAnchor.ABSOLUTE && h.controlOptions.anchor !== e.ControlAnchor.NONE, h.width && h.height ? (this.setWidth(h.width), this.setHeight(h.height)) : this._resizeWithViewer && (g = e.getElementSize(d.element), this.element.style.height = Math.round(g.y * h.sizeRatio) + "px", this.element.style.width = Math.round(g.x * h.sizeRatio) + "px", this.oldViewerSize = g, w = e.getElementSize(this.element), this.elementArea = w.x * w.y), this.oldContainerSize = new e.Point(0, 0), e.Viewer.apply(this, [h]), this.displayRegionContainer.appendChild(this.displayRegion), this.element.getElementsByTagName("div")[0].appendChild(this.displayRegionContainer);
        function C(A, I) {
          a(f.displayRegionContainer, A), a(f.displayRegion, -A), f.viewport.setRotation(A, I);
        }
        if (h.navigatorRotate) {
          var E = h.viewer.viewport ? h.viewer.viewport.getRotation() : h.viewer.degrees || 0;
          C(E, !0), h.viewer.addHandler("rotate", function(A) {
            C(A.degrees, A.immediately);
          });
        }
        this.innerTracker.destroy(), this.innerTracker = new e.MouseTracker({
          userData: "Navigator.innerTracker",
          element: this.element,
          //this.canvas,
          dragHandler: e.delegate(this, i),
          clickHandler: e.delegate(this, t),
          releaseHandler: e.delegate(this, n),
          scrollHandler: e.delegate(this, o),
          preProcessEventHandler: function(A) {
            A.eventType === "wheel" && (A.preventDefault = !0);
          }
        }), this.outerTracker.userData = "Navigator.outerTracker", e.setElementPointerEventsNone(this.canvas), e.setElementPointerEventsNone(this.container), this.addHandler("reset-size", function() {
          f.viewport && f.viewport.goHome(!0);
        }), d.world.addHandler("item-index-change", function(A) {
          window.setTimeout(function() {
            var I = f.world.getItemAt(A.previousIndex);
            f.world.setItemIndex(I, A.newIndex);
          }, 1);
        }), d.world.addHandler("remove-item", function(A) {
          var I = A.item, V = f._getMatchingItem(I);
          V && f.world.removeItem(V);
        }), this.update(d.viewport);
      }, e.extend(
        e.Navigator.prototype,
        e.EventSource.prototype,
        e.Viewer.prototype,
        /** @lends OpenSeadragon.Navigator.prototype */
        {
          /**
           * Used to notify the navigator when its size has changed.
           * Especially useful when {@link OpenSeadragon.Options}.navigatorAutoResize is set to false and the navigator is resizable.
           * @function
           */
          updateSize: function() {
            if (this.viewport) {
              var h = new e.Point(
                this.container.clientWidth === 0 ? 1 : this.container.clientWidth,
                this.container.clientHeight === 0 ? 1 : this.container.clientHeight
              );
              h.equals(this.oldContainerSize) || (this.viewport.resize(h, !0), this.viewport.goHome(!0), this.oldContainerSize = h, this.world.update(), this.world.draw(), this.update(this.viewer.viewport));
            }
          },
          /**
           * Explicitly sets the width of the navigator, in web coordinates. Disables automatic resizing.
           * @param {Number|String} width - the new width, either a number of pixels or a CSS string, such as "100%"
           */
          setWidth: function(h) {
            this.width = h, this.element.style.width = typeof h == "number" ? h + "px" : h, this._resizeWithViewer = !1, this.updateSize();
          },
          /**
           * Explicitly sets the height of the navigator, in web coordinates. Disables automatic resizing.
           * @param {Number|String} height - the new height, either a number of pixels or a CSS string, such as "100%"
           */
          setHeight: function(h) {
            this.height = h, this.element.style.height = typeof h == "number" ? h + "px" : h, this._resizeWithViewer = !1, this.updateSize();
          },
          /**
            * Flip navigator element
            * @param {Boolean} state - Flip state to set.
            */
          setFlip: function(h) {
            return this.viewport.setFlip(h), this.setDisplayTransform(this.viewer.viewport.getFlip() ? "scale(-1,1)" : "scale(1,1)"), this;
          },
          setDisplayTransform: function(h) {
            l(this.canvas, h), l(this.element, h);
          },
          /**
           * Used to update the navigator minimap's viewport rectangle when a change in the viewer's viewport occurs.
           * @function
           * @param {OpenSeadragon.Viewport} [viewport] The viewport to display. Default: the viewport this navigator is tracking.
           */
          update: function(h) {
            var d, f, g, w, C, E;
            if (h || (h = this.viewer.viewport), d = e.getElementSize(this.viewer.element), this._resizeWithViewer && d.x && d.y && !d.equals(this.oldViewerSize) && (this.oldViewerSize = d, this.maintainSizeRatio || !this.elementArea ? (f = d.x * this.sizeRatio, g = d.y * this.sizeRatio) : (f = Math.sqrt(this.elementArea * (d.x / d.y)), g = this.elementArea / f), this.element.style.width = Math.round(f) + "px", this.element.style.height = Math.round(g) + "px", this.elementArea || (this.elementArea = f * g), this.updateSize()), h && this.viewport) {
              if (w = h.getBoundsNoRotate(!0), C = this.viewport.pixelFromPointNoRotate(w.getTopLeft(), !1), E = this.viewport.pixelFromPointNoRotate(w.getBottomRight(), !1).minus(this.totalBorderWidths), !this.navigatorRotate) {
                var A = h.getRotation(!0);
                a(this.displayRegion, -A);
              }
              var I = this.displayRegion.style;
              I.display = this.world.getItemCount() ? "block" : "none", I.top = C.y.toFixed(2) + "px", I.left = C.x.toFixed(2) + "px";
              var V = E.x - C.x, K = E.y - C.y;
              I.width = Math.round(Math.max(V, 0)) + "px", I.height = Math.round(Math.max(K, 0)) + "px";
            }
          },
          // overrides Viewer.addTiledImage
          addTiledImage: function(h) {
            var d = this, f = h.originalTiledImage;
            delete h.original;
            var g = e.extend({}, h, {
              success: function(w) {
                var C = w.item;
                C._originalForNavigator = f, d._matchBounds(C, f, !0), d._matchOpacity(C, f), d._matchCompositeOperation(C, f);
                function E() {
                  d._matchBounds(C, f);
                }
                function A() {
                  d._matchOpacity(C, f);
                }
                function I() {
                  d._matchCompositeOperation(C, f);
                }
                f.addHandler("bounds-change", E), f.addHandler("clip-change", E), f.addHandler("opacity-change", A), f.addHandler("composite-operation-change", I);
              }
            });
            return e.Viewer.prototype.addTiledImage.apply(this, [g]);
          },
          destroy: function() {
            return e.Viewer.prototype.destroy.apply(this);
          },
          // private
          _getMatchingItem: function(h) {
            for (var d = this.world.getItemCount(), f, g = 0; g < d; g++)
              if (f = this.world.getItemAt(g), f._originalForNavigator === h)
                return f;
            return null;
          },
          // private
          _matchBounds: function(h, d, f) {
            var g = d.getBoundsNoRotate();
            h.setPosition(g.getTopLeft(), f), h.setWidth(g.width, f), h.setRotation(d.getRotation(), f), h.setClip(d.getClip()), h.setFlip(d.getFlip());
          },
          // private
          _matchOpacity: function(h, d) {
            h.setOpacity(d.opacity);
          },
          // private
          _matchCompositeOperation: function(h, d) {
            h.setCompositeOperation(d.compositeOperation);
          }
        }
      );
      function t(h) {
        var d = {
          tracker: h.eventSource,
          position: h.position,
          quick: h.quick,
          shift: h.shift,
          originalEvent: h.originalEvent,
          preventDefaultAction: !1
        };
        if (this.viewer.raiseEvent("navigator-click", d), !d.preventDefaultAction && h.quick && this.viewer.viewport && (this.panVertical || this.panHorizontal)) {
          this.viewer.viewport.flipped && (h.position.x = this.viewport.getContainerSize().x - h.position.x);
          var f = this.viewport.pointFromPixel(h.position);
          this.panVertical ? this.panHorizontal || (f.x = this.viewer.viewport.getCenter(!0).x) : f.y = this.viewer.viewport.getCenter(!0).y, this.viewer.viewport.panTo(f), this.viewer.viewport.applyConstraints();
        }
      }
      function i(h) {
        var d = {
          tracker: h.eventSource,
          position: h.position,
          delta: h.delta,
          speed: h.speed,
          direction: h.direction,
          shift: h.shift,
          originalEvent: h.originalEvent,
          preventDefaultAction: !1
        };
        this.viewer.raiseEvent("navigator-drag", d), !d.preventDefaultAction && this.viewer.viewport && (this.panHorizontal || (h.delta.x = 0), this.panVertical || (h.delta.y = 0), this.viewer.viewport.flipped && (h.delta.x = -h.delta.x), this.viewer.viewport.panBy(
          this.viewport.deltaPointsFromPixels(
            h.delta
          )
        ), this.viewer.constrainDuringPan && this.viewer.viewport.applyConstraints());
      }
      function n(h) {
        h.insideElementPressed && this.viewer.viewport && this.viewer.viewport.applyConstraints();
      }
      function o(h) {
        var d = {
          tracker: h.eventSource,
          position: h.position,
          scroll: h.scroll,
          shift: h.shift,
          originalEvent: h.originalEvent,
          preventDefault: h.preventDefault
        };
        this.viewer.raiseEvent("navigator-scroll", d), h.preventDefault = d.preventDefault;
      }
      function a(h, d) {
        l(h, "rotate(" + d + "deg)");
      }
      function l(h, d) {
        h.style.webkitTransform = d, h.style.mozTransform = d, h.style.msTransform = d, h.style.oTransform = d, h.style.transform = d;
      }
    }(r), function(e) {
      var t = {
        Errors: {
          Dzc: "Sorry, we don't support Deep Zoom Collections!",
          Dzi: "Hmm, this doesn't appear to be a valid Deep Zoom Image.",
          Xml: "Hmm, this doesn't appear to be a valid Deep Zoom Image.",
          ImageFormat: "Sorry, we don't support {0}-based Deep Zoom Images.",
          Security: "It looks like a security restriction stopped us from loading this Deep Zoom Image.",
          Status: "This space unintentionally left blank ({0} {1}).",
          OpenFailed: "Unable to open {0}: {1}"
        },
        Tooltips: {
          FullPage: "Toggle full page",
          Home: "Go home",
          ZoomIn: "Zoom in",
          ZoomOut: "Zoom out",
          NextPage: "Next page",
          PreviousPage: "Previous page",
          RotateLeft: "Rotate left",
          RotateRight: "Rotate right",
          Flip: "Flip Horizontally"
        }
      };
      e.extend(
        e,
        /** @lends OpenSeadragon */
        {
          /**
           * @function
           * @param {String} property
           */
          getString: function(i) {
            var n = i.split("."), o = null, a = arguments, l = t, h;
            for (h = 0; h < n.length - 1; h++)
              l = l[n[h]] || {};
            return o = l[n[h]], typeof o != "string" && (e.console.error("Untranslated source string:", i), o = ""), o.replace(/\{\d+\}/g, function(d) {
              var f = parseInt(d.match(/\d+/), 10) + 1;
              return f < a.length ? a[f] : "";
            });
          },
          /**
           * @function
           * @param {String} property
           * @param {*} value
           */
          setString: function(i, n) {
            var o = i.split("."), a = t, l;
            for (l = 0; l < o.length - 1; l++)
              a[o[l]] || (a[o[l]] = {}), a = a[o[l]];
            a[o[l]] = n;
          }
        }
      );
    }(r), function(e) {
      e.Point = function(t, i) {
        this.x = typeof t == "number" ? t : 0, this.y = typeof i == "number" ? i : 0;
      }, e.Point.prototype = {
        /**
         * @function
         * @returns {OpenSeadragon.Point} a duplicate of this Point
         */
        clone: function() {
          return new e.Point(this.x, this.y);
        },
        /**
         * Add another Point to this point and return a new Point.
         * @function
         * @param {OpenSeadragon.Point} point The point to add vector components.
         * @returns {OpenSeadragon.Point} A new point representing the sum of the
         *  vector components
         */
        plus: function(t) {
          return new e.Point(
            this.x + t.x,
            this.y + t.y
          );
        },
        /**
         * Subtract another Point to this point and return a new Point.
         * @function
         * @param {OpenSeadragon.Point} point The point to subtract vector components.
         * @returns {OpenSeadragon.Point} A new point representing the subtraction of the
         *  vector components
         */
        minus: function(t) {
          return new e.Point(
            this.x - t.x,
            this.y - t.y
          );
        },
        /**
         * Multiply this point by a factor and return a new Point.
         * @function
         * @param {Number} factor The factor to multiply vector components.
         * @returns {OpenSeadragon.Point} A new point representing the multiplication
         *  of the vector components by the factor
         */
        times: function(t) {
          return new e.Point(
            this.x * t,
            this.y * t
          );
        },
        /**
         * Divide this point by a factor and return a new Point.
         * @function
         * @param {Number} factor The factor to divide vector components.
         * @returns {OpenSeadragon.Point} A new point representing the division of the
         *  vector components by the factor
         */
        divide: function(t) {
          return new e.Point(
            this.x / t,
            this.y / t
          );
        },
        /**
         * Compute the opposite of this point and return a new Point.
         * @function
         * @returns {OpenSeadragon.Point} A new point representing the opposite of the
         *  vector components
         */
        negate: function() {
          return new e.Point(-this.x, -this.y);
        },
        /**
         * Compute the distance between this point and another point.
         * @function
         * @param {OpenSeadragon.Point} point The point to compute the distance with.
         * @returns {Number} The distance between the 2 points
         */
        distanceTo: function(t) {
          return Math.sqrt(
            Math.pow(this.x - t.x, 2) + Math.pow(this.y - t.y, 2)
          );
        },
        /**
         * Compute the squared distance between this point and another point.
         * Useful for optimizing things like comparing distances.
         * @function
         * @param {OpenSeadragon.Point} point The point to compute the squared distance with.
         * @returns {Number} The squared distance between the 2 points
         */
        squaredDistanceTo: function(t) {
          return Math.pow(this.x - t.x, 2) + Math.pow(this.y - t.y, 2);
        },
        /**
         * Apply a function to each coordinate of this point and return a new point.
         * @function
         * @param {function} func The function to apply to each coordinate.
         * @returns {OpenSeadragon.Point} A new point with the coordinates computed
         * by the specified function
         */
        apply: function(t) {
          return new e.Point(t(this.x), t(this.y));
        },
        /**
         * Check if this point is equal to another one.
         * @function
         * @param {OpenSeadragon.Point} point The point to compare this point with.
         * @returns {Boolean} true if they are equal, false otherwise.
         */
        equals: function(t) {
          return t instanceof e.Point && this.x === t.x && this.y === t.y;
        },
        /**
         * Rotates the point around the specified pivot
         * From http://stackoverflow.com/questions/4465931/rotate-rectangle-around-a-point
         * @function
         * @param {Number} degress to rotate around the pivot.
         * @param {OpenSeadragon.Point} [pivot=(0,0)] Point around which to rotate.
         * Defaults to the origin.
         * @returns {OpenSeadragon.Point}. A new point representing the point rotated around the specified pivot
         */
        rotate: function(t, i) {
          i = i || new e.Point(0, 0);
          var n, o;
          if (t % 90 === 0) {
            var a = e.positiveModulo(t, 360);
            switch (a) {
              case 0:
                n = 1, o = 0;
                break;
              case 90:
                n = 0, o = 1;
                break;
              case 180:
                n = -1, o = 0;
                break;
              case 270:
                n = 0, o = -1;
                break;
            }
          } else {
            var l = t * Math.PI / 180;
            n = Math.cos(l), o = Math.sin(l);
          }
          var h = n * (this.x - i.x) - o * (this.y - i.y) + i.x, d = o * (this.x - i.x) + n * (this.y - i.y) + i.y;
          return new e.Point(h, d);
        },
        /**
         * Convert this point to a string in the format (x,y) where x and y are
         * rounded to the nearest integer.
         * @function
         * @returns {String} A string representation of this point.
         */
        toString: function() {
          return "(" + Math.round(this.x * 100) / 100 + "," + Math.round(this.y * 100) / 100 + ")";
        }
      };
    }(r), function(e) {
      e.TileSource = function(i, n, o, a, l, h) {
        var d = this, f = arguments, g, w;
        if (e.isPlainObject(i) ? g = i : g = {
          width: f[0],
          height: f[1],
          tileSize: f[2],
          tileOverlap: f[3],
          minLevel: f[4],
          maxLevel: f[5]
        }, e.EventSource.call(this), e.extend(!0, this, g), !this.success) {
          for (w = 0; w < arguments.length; w++)
            if (e.isFunction(arguments[w])) {
              this.success = arguments[w];
              break;
            }
        }
        this.success && this.addHandler("ready", function(C) {
          d.success(C);
        }), e.type(arguments[0]) === "string" && (this.url = arguments[0]), this.url ? (this.aspectRatio = 1, this.dimensions = new e.Point(10, 10), this._tileWidth = 0, this._tileHeight = 0, this.tileOverlap = 0, this.minLevel = 0, this.maxLevel = 0, this.ready = !1, this.getImageInfo(this.url)) : (this.ready = !0, this.aspectRatio = g.width && g.height ? g.width / g.height : 1, this.dimensions = new e.Point(g.width, g.height), this.tileSize ? (this._tileWidth = this._tileHeight = this.tileSize, delete this.tileSize) : (this.tileWidth ? (this._tileWidth = this.tileWidth, delete this.tileWidth) : this._tileWidth = 0, this.tileHeight ? (this._tileHeight = this.tileHeight, delete this.tileHeight) : this._tileHeight = 0), this.tileOverlap = g.tileOverlap ? g.tileOverlap : 0, this.minLevel = g.minLevel ? g.minLevel : 0, this.maxLevel = g.maxLevel !== void 0 && g.maxLevel !== null ? g.maxLevel : g.width && g.height ? Math.ceil(
          Math.log(Math.max(g.width, g.height)) / Math.log(2)
        ) : 0, this.success && e.isFunction(this.success) && this.success(this));
      }, e.TileSource.prototype = {
        getTileSize: function(i) {
          return e.console.error(
            "[TileSource.getTileSize] is deprecated. Use TileSource.getTileWidth() and TileSource.getTileHeight() instead"
          ), this._tileWidth;
        },
        /**
         * Return the tileWidth for a given level.
         * Subclasses should override this if tileWidth can be different at different levels
         *   such as in IIIFTileSource.  Code should use this function rather than reading
         *   from ._tileWidth directly.
         * @function
         * @param {Number} level
         */
        getTileWidth: function(i) {
          return this._tileWidth ? this._tileWidth : this.getTileSize(i);
        },
        /**
         * Return the tileHeight for a given level.
         * Subclasses should override this if tileHeight can be different at different levels
         *   such as in IIIFTileSource.  Code should use this function rather than reading
         *   from ._tileHeight directly.
         * @function
         * @param {Number} level
         */
        getTileHeight: function(i) {
          return this._tileHeight ? this._tileHeight : this.getTileSize(i);
        },
        /**
         * Set the maxLevel to the given level, and perform the memoization of
         * getLevelScale with the new maxLevel. This function can be useful if the
         * memoization is required before the first call of getLevelScale, or both
         * memoized getLevelScale and maxLevel should be changed accordingly.
         * @function
         * @param {Number} level
         */
        setMaxLevel: function(i) {
          this.maxLevel = i, this._memoizeLevelScale();
        },
        /**
         * @function
         * @param {Number} level
         */
        getLevelScale: function(i) {
          return this._memoizeLevelScale(), this.getLevelScale(i);
        },
        // private
        _memoizeLevelScale: function() {
          var i = {}, n;
          for (n = 0; n <= this.maxLevel; n++)
            i[n] = 1 / Math.pow(2, this.maxLevel - n);
          this.getLevelScale = function(o) {
            return i[o];
          };
        },
        /**
         * @function
         * @param {Number} level
         */
        getNumTiles: function(i) {
          var n = this.getLevelScale(i), o = Math.ceil(n * this.dimensions.x / this.getTileWidth(i)), a = Math.ceil(n * this.dimensions.y / this.getTileHeight(i));
          return new e.Point(o, a);
        },
        /**
         * @function
         * @param {Number} level
         */
        getPixelRatio: function(i) {
          var n = this.dimensions.times(this.getLevelScale(i)), o = 1 / n.x * e.pixelDensityRatio, a = 1 / n.y * e.pixelDensityRatio;
          return new e.Point(o, a);
        },
        /**
         * @function
         * @returns {Number} The highest level in this tile source that can be contained in a single tile.
         */
        getClosestLevel: function() {
          var i, n;
          for (i = this.minLevel + 1; i <= this.maxLevel && (n = this.getNumTiles(i), !(n.x > 1 || n.y > 1)); i++)
            ;
          return i - 1;
        },
        /**
         * @function
         * @param {Number} level
         * @param {OpenSeadragon.Point} point
         */
        getTileAtPoint: function(i, n) {
          var o = n.x >= 0 && n.x <= 1 && n.y >= 0 && n.y <= 1 / this.aspectRatio;
          e.console.assert(o, "[TileSource.getTileAtPoint] must be called with a valid point.");
          var a = this.dimensions.x * this.getLevelScale(i), l = n.x * a, h = n.y * a, d = Math.floor(l / this.getTileWidth(i)), f = Math.floor(h / this.getTileHeight(i));
          n.x >= 1 && (d = this.getNumTiles(i).x - 1);
          var g = 1e-15;
          return n.y >= 1 / this.aspectRatio - g && (f = this.getNumTiles(i).y - 1), new e.Point(d, f);
        },
        /**
         * @function
         * @param {Number} level
         * @param {Number} x
         * @param {Number} y
         * @param {Boolean} [isSource=false] Whether to return the source bounds of the tile.
         * @returns {OpenSeadragon.Rect} Either where this tile fits (in normalized coordinates) or the
         * portion of the tile to use as the source of the drawing operation (in pixels), depending on
         * the isSource parameter.
         */
        getTileBounds: function(i, n, o, a) {
          var l = this.dimensions.times(this.getLevelScale(i)), h = this.getTileWidth(i), d = this.getTileHeight(i), f = n === 0 ? 0 : h * n - this.tileOverlap, g = o === 0 ? 0 : d * o - this.tileOverlap, w = h + (n === 0 ? 1 : 2) * this.tileOverlap, C = d + (o === 0 ? 1 : 2) * this.tileOverlap, E = 1 / l.x;
          return w = Math.min(w, l.x - f), C = Math.min(C, l.y - g), a ? new e.Rect(0, 0, w, C) : new e.Rect(f * E, g * E, w * E, C * E);
        },
        /**
         * Responsible for retrieving, and caching the
         * image metadata pertinent to this TileSources implementation.
         * @function
         * @param {String} url
         * @throws {Error}
         */
        getImageInfo: function(i) {
          var n = this, o, a, l, h, d, f, g;
          i && (d = i.split("/"), f = d[d.length - 1], g = f.lastIndexOf("."), g > -1 && (d[d.length - 1] = f.slice(0, g)));
          var w = null;
          if (this.splitHashDataForPost) {
            var C = i.indexOf("#");
            C !== -1 && (w = i.substring(C + 1), i = i.substr(0, C));
          }
          a = function(E) {
            typeof E == "string" && (E = e.parseXml(E));
            var A = e.TileSource.determineType(n, E, i);
            if (!A) {
              n.raiseEvent("open-failed", { message: "Unable to load TileSource", source: i });
              return;
            }
            h = A.prototype.configure.apply(n, [E, i, w]), h.ajaxWithCredentials === void 0 && (h.ajaxWithCredentials = n.ajaxWithCredentials), l = new A(h), n.ready = !0, n.raiseEvent("ready", { tileSource: l });
          }, i.match(/\.js$/) ? (o = i.split("/").pop().replace(".js", ""), e.jsonp({
            url: i,
            async: !1,
            callbackName: o,
            callback: a
          })) : e.makeAjaxRequest({
            url: i,
            postData: w,
            withCredentials: this.ajaxWithCredentials,
            headers: this.ajaxHeaders,
            success: function(E) {
              var A = t(E);
              a(A);
            },
            error: function(E, A) {
              var I;
              try {
                I = "HTTP " + E.status + " attempting to load TileSource: " + i;
              } catch {
                var V;
                typeof A > "u" || !A.toString ? V = "Unknown error" : V = A.toString(), I = V + " attempting to load TileSource: " + i;
              }
              e.console.error(I), n.raiseEvent("open-failed", {
                message: I,
                source: i,
                postData: w
              });
            }
          });
        },
        /**
         * Responsible for determining if the particular TileSource supports the
         * data format ( and allowed to apply logic against the url the data was
         * loaded from, if any ). Overriding implementations are expected to do
         * something smart with data and / or url to determine support.  Also
         * understand that iteration order of TileSources is not guaranteed so
         * please make sure your data or url is expressive enough to ensure a simple
         * and sufficient mechanism for clear determination.
         * @function
         * @param {String|Object|Array|Document} data
         * @param {String} url - the url the data was loaded
         *      from if any.
         * @returns {Boolean}
         */
        supports: function(i, n) {
          return !1;
        },
        /**
         * Responsible for parsing and configuring the
         * image metadata pertinent to this TileSources implementation.
         * This method is not implemented by this class other than to throw an Error
         * announcing you have to implement it.  Because of the variety of tile
         * server technologies, and various specifications for building image
         * pyramids, this method is here to allow easy integration.
         * @function
         * @param {String|Object|Array|Document} data
         * @param {String} url - the url the data was loaded
         *      from if any.
         * @param {String} postData - HTTP POST data in k=v&k2=v2... form or null value obtained from
         *      the protocol URL after '#' sign if flag splitHashDataForPost set to 'true'
         * @returns {Object} options - A dictionary of keyword arguments sufficient
         *      to configure the tile source constructor (include all values you want to
         *      instantiate the TileSource subclass with - what _options_ object should contain).
         * @throws {Error}
         */
        configure: function(i, n, o) {
          throw new Error("Method not implemented.");
        },
        /**
         * Responsible for retrieving the url which will return an image for the
         * region specified by the given x, y, and level components.
         * This method is not implemented by this class other than to throw an Error
         * announcing you have to implement it.  Because of the variety of tile
         * server technologies, and various specifications for building image
         * pyramids, this method is here to allow easy integration.
         * @function
         * @param {Number} level
         * @param {Number} x
         * @param {Number} y
         * @returns {String|Function} url - A string for the url or a function that returns a url string.
         * @throws {Error}
         */
        getTileUrl: function(i, n, o) {
          throw new Error("Method not implemented.");
        },
        /**
         * Must use AJAX in order to work, i.e. loadTilesWithAjax = true is set.
         * If a value is returned, ajax issues POST request to the tile url.
         * If null is returned, ajax issues GET request.
         * The return value must comply to the header 'content type'.
         *
         * Examples (USED HEADER --> getTilePostData CODE):
         * 'Content-type': 'application/x-www-form-urlencoded' -->
         *   return "key1=value=1&key2=value2";
         *
         * 'Content-type': 'application/x-www-form-urlencoded' -->
         *   return JSON.stringify({key: "value", number: 5});
         *
         * 'Content-type': 'multipart/form-data' -->
         *   let result = new FormData();
         *   result.append("data", myData);
         *   return result;
         *
         * IMPORTANT: in case you move all the logic on image fetching
         * to post data, you must re-define 'getTileHashKey(...)' to
         * stay unique for different tile images.
         *
         * @param {Number} level
         * @param {Number} x
         * @param {Number} y
         * @returns {*|null} post data to send with tile configuration request
         */
        getTilePostData: function(i, n, o) {
          return null;
        },
        /**
         * Responsible for retrieving the headers which will be attached to the image request for the
         * region specified by the given x, y, and level components.
         * This option is only relevant if {@link OpenSeadragon.Options}.loadTilesWithAjax is set to true.
         * The headers returned here will override headers specified at the Viewer or TiledImage level.
         * Specifying a falsy value for a header will clear its existing value set at the Viewer or
         * TiledImage level (if any).
         *
         * Note that the headers of existing tiles don't automatically change when this function
         * returns updated headers. To do that, you need to call {@link OpenSeadragon.Viewer#setAjaxHeaders}
         * and propagate the changes.
         *
         * @function
         * @param {Number} level
         * @param {Number} x
         * @param {Number} y
         * @returns {Object}
         */
        getTileAjaxHeaders: function(i, n, o) {
          return {};
        },
        /**
         * The tile cache object is uniquely determined by this key and used to lookup
         * the image data in cache: keys should be different if images are different.
         *
         * In case a tile has context2D property defined (TileSource.prototype.getContext2D)
         * or its context2D is set manually; the cache is not used and this function
         * is irrelevant.
         * Note: default behaviour does not take into account post data.
         * @param {Number} level tile level it was fetched with
         * @param {Number} x x-coordinate in the pyramid level
         * @param {Number} y y-coordinate in the pyramid level
         * @param {String} url the tile was fetched with
         * @param {Object} ajaxHeaders the tile was fetched with
         * @param {*} postData data the tile was fetched with (type depends on getTilePostData(..) return type)
         */
        getTileHashKey: function(i, n, o, a, l, h) {
          function d(f) {
            return l ? f + "+" + JSON.stringify(l) : f;
          }
          return d(typeof a != "string" ? i + "/" + n + "_" + o : a);
        },
        /**
         * @function
         * @param {Number} level
         * @param {Number} x
         * @param {Number} y
         */
        tileExists: function(i, n, o) {
          var a = this.getNumTiles(i);
          return i >= this.minLevel && i <= this.maxLevel && n >= 0 && o >= 0 && n < a.x && o < a.y;
        },
        /**
         * Decide whether tiles have transparency: this is crucial for correct images blending.
         * @returns {boolean} true if the image has transparency
         */
        hasTransparency: function(i, n, o, a) {
          return !!i || n.match(".png");
        },
        /**
         * Download tile data.
         * Note that if you override this function, you should override also downloadTileAbort().
         * @param {ImageJob} context job context that you have to call finish(...) on.
         * @param {String} [context.src] - URL of image to download.
         * @param {String} [context.loadWithAjax] - Whether to load this image with AJAX.
         * @param {String} [context.ajaxHeaders] - Headers to add to the image request if using AJAX.
         * @param {Boolean} [context.ajaxWithCredentials] - Whether to set withCredentials on AJAX requests.
         * @param {String} [context.crossOriginPolicy] - CORS policy to use for downloads
         * @param {String} [context.postData] - HTTP POST data (usually but not necessarily in k=v&k2=v2... form,
         *   see TileSource::getPostData) or null
         * @param {*} [context.userData] - Empty object to attach your own data and helper variables to.
         * @param {Function} [context.finish] - Should be called unless abort() was executed, e.g. on all occasions,
         *   be it successful or unsuccessful request.
         *   Usage: context.finish(data, request, errMessage). Pass the downloaded data object or null upon failure.
         *   Add also reference to an ajax request if used. Provide error message in case of failure.
         * @param {Function} [context.abort] - Called automatically when the job times out.
         *   Usage: context.abort().
         * @param {Function} [context.callback] @private - Called automatically once image has been downloaded
         *   (triggered by finish).
         * @param {Number} [context.timeout] @private - The max number of milliseconds that
         *   this image job may take to complete.
         * @param {string} [context.errorMsg] @private - The final error message, default null (set by finish).
         */
        downloadTileStart: function(i) {
          var n = i.userData, o = new Image();
          n.image = o, n.request = null;
          var a = function(l) {
            if (!o) {
              i.finish(null, n.request, "Image load failed: undefined Image instance.");
              return;
            }
            o.onload = o.onerror = o.onabort = null, i.finish(l ? null : o, n.request, l);
          };
          o.onload = function() {
            a();
          }, o.onabort = o.onerror = function() {
            a("Image load aborted.");
          }, i.loadWithAjax ? n.request = e.makeAjaxRequest({
            url: i.src,
            withCredentials: i.ajaxWithCredentials,
            headers: i.ajaxHeaders,
            responseType: "arraybuffer",
            postData: i.postData,
            success: function(l) {
              var h;
              try {
                h = new window.Blob([l.response]);
              } catch (g) {
                var d = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
                if (g.name === "TypeError" && d) {
                  var f = new d();
                  f.append(l.response), h = f.getBlob();
                }
              }
              h.size === 0 ? a("Empty image response.") : o.src = (window.URL || window.webkitURL).createObjectURL(h);
            },
            error: function(l) {
              a("Image load aborted - XHR error");
            }
          }) : (i.crossOriginPolicy !== !1 && (o.crossOrigin = i.crossOriginPolicy), o.src = i.src);
        },
        /**
         * Provide means of aborting the execution.
         * Note that if you override this function, you should override also downloadTileStart().
         * @param {ImageJob} context job, the same object as with downloadTileStart(..)
         * @param {*} [context.userData] - Empty object to attach (and mainly read) your own data.
         */
        downloadTileAbort: function(i) {
          i.userData.request && i.userData.request.abort();
          var n = i.userData.image;
          i.userData.image && (n.onload = n.onerror = n.onabort = null);
        },
        /**
         * Create cache object from the result of the download process. The
         * cacheObject parameter should be used to attach the data to, there are no
         * conventions on how it should be stored - all the logic is implemented within *TileCache() functions.
         *
         * Note that if you override any of *TileCache() functions, you should override all of them.
         * @param {object} cacheObject context cache object
         * @param {*} data image data, the data sent to ImageJob.prototype.finish(), by default an Image object
         * @param {Tile} tile instance the cache was created with
         */
        createTileCache: function(i, n, o) {
          i._data = n;
        },
        /**
         * Cache object destructor, unset all properties you created to allow GC collection.
         * Note that if you override any of *TileCache() functions, you should override all of them.
         * @param {object} cacheObject context cache object
         */
        destroyTileCache: function(i) {
          i._data = null, i._renderedContext = null;
        },
        /**
         * Raw data getter
         * Note that if you override any of *TileCache() functions, you should override all of them.
         * @param {object} cacheObject context cache object
         * @returns {*} cache data
         */
        getTileCacheData: function(i) {
          return i._data;
        },
        /**
         * Compatibility image element getter
         *  - plugins might need image representation of the data
         *  - div HTML rendering relies on image element presence
         * Note that if you override any of *TileCache() functions, you should override all of them.
         *  @param {object} cacheObject context cache object
         *  @returns {Image} cache data as an Image
         */
        getTileCacheDataAsImage: function(i) {
          return i._data;
        },
        /**
         * Compatibility context 2D getter
         *  - most heavily used rendering method is a canvas-based approach,
         *    convert the data to a canvas and return it's 2D context
         * Note that if you override any of *TileCache() functions, you should override all of them.
         * @param {object} cacheObject context cache object
         * @returns {CanvasRenderingContext2D} context of the canvas representation of the cache data
         */
        getTileCacheDataAsContext2D: function(i) {
          if (!i._renderedContext) {
            var n = document.createElement("canvas");
            n.width = i._data.width, n.height = i._data.height, i._renderedContext = n.getContext("2d"), i._renderedContext.drawImage(i._data, 0, 0), i._data = null;
          }
          return i._renderedContext;
        }
      }, e.extend(!0, e.TileSource.prototype, e.EventSource.prototype);
      function t(i) {
        var n = i.responseText, o = i.status, a, l;
        if (i) {
          if (i.status !== 200 && i.status !== 0)
            throw o = i.status, a = o === 404 ? "Not Found" : i.statusText, new Error(e.getString("Errors.Status", o, a));
        } else throw new Error(e.getString("Errors.Security"));
        if (n.match(/^\s*<.*/))
          try {
            l = i.responseXML && i.responseXML.documentElement ? i.responseXML : e.parseXml(n);
          } catch {
            l = i.responseText;
          }
        else if (n.match(/\s*[{[].*/))
          try {
            l = e.parseJSON(n);
          } catch {
            l = n;
          }
        else
          l = n;
        return l;
      }
      e.TileSource.determineType = function(i, n, o) {
        var a;
        for (a in r)
          if (a.match(/.+TileSource$/) && e.isFunction(r[a]) && e.isFunction(r[a].prototype.supports) && r[a].prototype.supports.call(i, n, o))
            return r[a];
        return e.console.error("No TileSource was able to open %s %s", o, n), null;
      };
    }(r), function(e) {
      e.DziTileSource = function(n, o, a, l, h, d, f, g, w) {
        var C, E, A, I;
        if (e.isPlainObject(n) ? I = n : I = {
          width: arguments[0],
          height: arguments[1],
          tileSize: arguments[2],
          tileOverlap: arguments[3],
          tilesUrl: arguments[4],
          fileFormat: arguments[5],
          displayRects: arguments[6],
          minLevel: arguments[7],
          maxLevel: arguments[8]
        }, this._levelRects = {}, this.tilesUrl = I.tilesUrl, this.fileFormat = I.fileFormat, this.displayRects = I.displayRects, this.displayRects)
          for (C = this.displayRects.length - 1; C >= 0; C--)
            for (E = this.displayRects[C], A = E.minLevel; A <= E.maxLevel; A++)
              this._levelRects[A] || (this._levelRects[A] = []), this._levelRects[A].push(E);
        e.TileSource.apply(this, [I]);
      }, e.extend(
        e.DziTileSource.prototype,
        e.TileSource.prototype,
        /** @lends OpenSeadragon.DziTileSource.prototype */
        {
          /**
           * Determine if the data and/or url imply the image service is supported by
           * this tile source.
           * @function
           * @param {Object|Array} data
           * @param {String} optional - url
           */
          supports: function(n, o) {
            var a;
            return n.Image ? a = n.Image.xmlns : n.documentElement && (n.documentElement.localName === "Image" || n.documentElement.tagName === "Image") && (a = n.documentElement.namespaceURI), a = (a || "").toLowerCase(), a.indexOf("schemas.microsoft.com/deepzoom/2008") !== -1 || a.indexOf("schemas.microsoft.com/deepzoom/2009") !== -1;
          },
          /**
           *
           * @function
           * @param {Object|XMLDocument} data - the raw configuration
           * @param {String} url - the url the data was retrieved from if any.
           * @param {String} postData - HTTP POST data in k=v&k2=v2... form or null
           * @returns {Object} options - A dictionary of keyword arguments sufficient
           *      to configure this tile sources constructor.
           */
          configure: function(n, o, a) {
            var l;
            return e.isPlainObject(n) ? l = i(this, n) : l = t(this, n), o && !l.tilesUrl && (l.tilesUrl = o.replace(
              /([^/]+?)(\.(dzi|xml|js)?(\?[^/]*)?)?\/?$/,
              "$1_files/"
            ), o.search(/\.(dzi|xml|js)\?/) !== -1 ? l.queryParams = o.match(/\?.*/) : l.queryParams = ""), l;
          },
          /**
           * @function
           * @param {Number} level
           * @param {Number} x
           * @param {Number} y
           */
          getTileUrl: function(n, o, a) {
            return [this.tilesUrl, n, "/", o, "_", a, ".", this.fileFormat, this.queryParams].join("");
          },
          /**
           * @function
           * @param {Number} level
           * @param {Number} x
           * @param {Number} y
           */
          tileExists: function(n, o, a) {
            var l = this._levelRects[n], h, d, f, g, w, C, E;
            if (this.minLevel && n < this.minLevel || this.maxLevel && n > this.maxLevel)
              return !1;
            if (!l || !l.length)
              return !0;
            for (E = l.length - 1; E >= 0; E--)
              if (h = l[E], !(n < h.minLevel || n > h.maxLevel) && (d = this.getLevelScale(n), f = h.x * d, g = h.y * d, w = f + h.width * d, C = g + h.height * d, f = Math.floor(f / this._tileWidth), g = Math.floor(g / this._tileWidth), w = Math.ceil(w / this._tileWidth), C = Math.ceil(C / this._tileWidth), f <= o && o < w && g <= a && a < C))
                return !0;
            return !1;
          }
        }
      );
      function t(n, o) {
        if (!o || !o.documentElement)
          throw new Error(e.getString("Errors.Xml"));
        var a = o.documentElement, l = a.localName || a.tagName, h = o.documentElement.namespaceURI, d = null, f = [], g, w, C, E, A;
        if (l === "Image")
          try {
            if (E = a.getElementsByTagName("Size")[0], E === void 0 && (E = a.getElementsByTagNameNS(h, "Size")[0]), d = {
              Image: {
                xmlns: "http://schemas.microsoft.com/deepzoom/2008",
                Url: a.getAttribute("Url"),
                Format: a.getAttribute("Format"),
                DisplayRect: null,
                Overlap: parseInt(a.getAttribute("Overlap"), 10),
                TileSize: parseInt(a.getAttribute("TileSize"), 10),
                Size: {
                  Height: parseInt(E.getAttribute("Height"), 10),
                  Width: parseInt(E.getAttribute("Width"), 10)
                }
              }
            }, !e.imageFormatSupported(d.Image.Format))
              throw new Error(
                e.getString("Errors.ImageFormat", d.Image.Format.toUpperCase())
              );
            for (g = a.getElementsByTagName("DisplayRect"), g === void 0 && (g = a.getElementsByTagNameNS(h, "DisplayRect")[0]), A = 0; A < g.length; A++)
              w = g[A], C = w.getElementsByTagName("Rect")[0], C === void 0 && (C = w.getElementsByTagNameNS(h, "Rect")[0]), f.push({
                Rect: {
                  X: parseInt(C.getAttribute("X"), 10),
                  Y: parseInt(C.getAttribute("Y"), 10),
                  Width: parseInt(C.getAttribute("Width"), 10),
                  Height: parseInt(C.getAttribute("Height"), 10),
                  MinLevel: parseInt(w.getAttribute("MinLevel"), 10),
                  MaxLevel: parseInt(w.getAttribute("MaxLevel"), 10)
                }
              });
            return f.length && (d.Image.DisplayRect = f), i(n, d);
          } catch (K) {
            throw K instanceof Error ? K : new Error(e.getString("Errors.Dzi"));
          }
        else {
          if (l === "Collection")
            throw new Error(e.getString("Errors.Dzc"));
          if (l === "Error") {
            var I = a.getElementsByTagName("Message")[0], V = I.firstChild.nodeValue;
            throw new Error(V);
          }
        }
        throw new Error(e.getString("Errors.Dzi"));
      }
      function i(n, o) {
        var a = o.Image, l = a.Url, h = a.Format, d = a.Size, f = a.DisplayRect || [], g = parseInt(d.Width, 10), w = parseInt(d.Height, 10), C = parseInt(a.TileSize, 10), E = parseInt(a.Overlap, 10), A = [], I, V;
        for (V = 0; V < f.length; V++)
          I = f[V].Rect, A.push(new e.DisplayRect(
            parseInt(I.X, 10),
            parseInt(I.Y, 10),
            parseInt(I.Width, 10),
            parseInt(I.Height, 10),
            parseInt(I.MinLevel, 10),
            parseInt(I.MaxLevel, 10)
          ));
        return e.extend(!0, {
          width: g,
          /* width *required */
          height: w,
          /* height *required */
          tileSize: C,
          /* tileSize *required */
          tileOverlap: E,
          /* tileOverlap *required */
          minLevel: null,
          /* minLevel */
          maxLevel: null,
          /* maxLevel */
          tilesUrl: l,
          /* tilesUrl */
          fileFormat: h,
          /* fileFormat */
          displayRects: A
          /* displayRects */
        }, o);
      }
    }(r), function(e) {
      e.IIIFTileSource = function(a) {
        if (e.extend(!0, this, a), this._id = this["@id"] || this.id || this.identifier || null, !(this.height && this.width && this._id))
          throw new Error("IIIF required parameters (width, height, or id) not provided.");
        if (a.tileSizePerScaleFactor = {}, this.tileFormat = this.tileFormat || "jpg", this.version = a.version, this.tile_width && this.tile_height)
          a.tileWidth = this.tile_width, a.tileHeight = this.tile_height;
        else if (this.tile_width)
          a.tileSize = this.tile_width;
        else if (this.tile_height)
          a.tileSize = this.tile_height;
        else if (this.tiles)
          if (this.tiles.length === 1)
            a.tileWidth = this.tiles[0].width, a.tileHeight = this.tiles[0].height || this.tiles[0].width, this.scale_factors = this.tiles[0].scaleFactors;
          else {
            this.scale_factors = [];
            for (var l = 0; l < this.tiles.length; l++)
              for (var h = 0; h < this.tiles[l].scaleFactors.length; h++) {
                var d = this.tiles[l].scaleFactors[h];
                this.scale_factors.push(d), a.tileSizePerScaleFactor[d] = {
                  width: this.tiles[l].width,
                  height: this.tiles[l].height || this.tiles[l].width
                };
              }
          }
        else if (t(a)) {
          for (var f = Math.min(this.height, this.width), g = [256, 512, 1024], w = [], C = 0; C < g.length; C++)
            g[C] <= f && w.push(g[C]);
          w.length > 0 ? a.tileSize = Math.max.apply(null, w) : a.tileSize = f;
        } else this.sizes && this.sizes.length > 0 ? (this.emulateLegacyImagePyramid = !0, a.levels = i(this), e.extend(!0, a, {
          width: a.levels[a.levels.length - 1].width,
          height: a.levels[a.levels.length - 1].height,
          tileSize: Math.max(a.height, a.width),
          tileOverlap: 0,
          minLevel: 0,
          maxLevel: a.levels.length - 1
        }), this.levels = a.levels) : e.console.error("Nothing in the info.json to construct image pyramids from");
        if (!a.maxLevel && !this.emulateLegacyImagePyramid)
          if (!this.scale_factors)
            a.maxLevel = Number(Math.round(Math.log(Math.max(this.width, this.height), 2)));
          else {
            var E = Math.max.apply(null, this.scale_factors);
            a.maxLevel = Math.round(Math.log(E) * Math.LOG2E);
          }
        if (this.sizes) {
          var A = this.sizes.length;
          (A === a.maxLevel || A === a.maxLevel + 1) && (this.levelSizes = this.sizes.slice().sort((I, V) => I.width - V.width), A === a.maxLevel && this.levelSizes.push({ width: this.width, height: this.height }));
        }
        e.TileSource.apply(this, [a]);
      }, e.extend(
        e.IIIFTileSource.prototype,
        e.TileSource.prototype,
        /** @lends OpenSeadragon.IIIFTileSource.prototype */
        {
          /**
           * Determine if the data and/or url imply the image service is supported by
           * this tile source.
           * @function
           * @param {Object|Array} data
           * @param {String} [url] - url
           */
          supports: function(a, l) {
            return a.protocol && a.protocol === "http://iiif.io/api/image" || a["@context"] && (a["@context"] === "http://library.stanford.edu/iiif/image-api/1.1/context.json" || a["@context"] === "http://iiif.io/api/image/1/context.json") || a.profile && a.profile.indexOf("http://library.stanford.edu/iiif/image-api/compliance.html") === 0 || a.identifier && a.width && a.height ? !0 : !!(a.documentElement && a.documentElement.tagName === "info" && a.documentElement.namespaceURI === "http://library.stanford.edu/iiif/image-api/ns/");
          },
          /**
           * A static function used to prepare an incoming IIIF Image API info.json
           * response for processing by the tile handler. Normalizes data for all
           * versions of IIIF (1.0, 1.1, 2.x, 3.x) and returns a data object that
           * may be passed to the IIIFTileSource.
           *
           * @function
           * @static
           * @param {Object} data - the raw configuration
           * @param {String} url - the url configuration was retrieved from
           * @param {String} postData - HTTP POST data in k=v&k2=v2... form or null
           * @returns {Object} A normalized IIIF data object
           * @example <caption>IIIF 2.x Info Looks like this</caption>
           * {
           * "@context": "http://iiif.io/api/image/2/context.json",
           * "@id": "http://iiif.example.com/prefix/1E34750D-38DB-4825-A38A-B60A345E591C",
           * "protocol": "http://iiif.io/api/image",
           * "height": 1024,
           * "width": 775,
           * "tiles" : [{"width":256, "scaleFactors":[1,2,4,8]}],
           *  "profile": ["http://iiif.io/api/image/2/level1.json", {
           *    "qualities": [ "native", "bitonal", "grey", "color" ],
           *    "formats": [ "jpg", "png", "gif" ]
           *   }]
           * }
           */
          configure: function(a, l, h) {
            if (e.isPlainObject(a)) {
              if (!a["@context"])
                a["@context"] = "http://iiif.io/api/image/1.0/context.json", a["@id"] = l.replace("/info.json", ""), a.version = 1;
              else {
                var f = a["@context"];
                if (Array.isArray(f)) {
                  for (var g = 0; g < f.length; g++)
                    if (typeof f[g] == "string" && (/^http:\/\/iiif\.io\/api\/image\/[1-3]\/context\.json$/.test(f[g]) || f[g] === "http://library.stanford.edu/iiif/image-api/1.1/context.json")) {
                      f = f[g];
                      break;
                    }
                }
                switch (f) {
                  case "http://iiif.io/api/image/1/context.json":
                  case "http://library.stanford.edu/iiif/image-api/1.1/context.json":
                    a.version = 1;
                    break;
                  case "http://iiif.io/api/image/2/context.json":
                    a.version = 2;
                    break;
                  case "http://iiif.io/api/image/3/context.json":
                    a.version = 3;
                    break;
                  default:
                    e.console.error("Data has a @context property which contains no known IIIF context URI.");
                }
              }
              if (a.preferredFormats) {
                for (var w = 0; w < a.preferredFormats.length; w++)
                  if (r.imageFormatSupported(a.preferredFormats[w])) {
                    a.tileFormat = a.preferredFormats[w];
                    break;
                  }
              }
              return a;
            } else {
              var d = n(a);
              return d["@context"] = "http://iiif.io/api/image/1.0/context.json", d["@id"] = l.replace("/info.xml", ""), d.version = 1, d;
            }
          },
          /**
           * Return the tileWidth for the given level.
           * @function
           * @param {Number} level
           */
          getTileWidth: function(a) {
            if (this.emulateLegacyImagePyramid)
              return e.TileSource.prototype.getTileWidth.call(this, a);
            var l = Math.pow(2, this.maxLevel - a);
            return this.tileSizePerScaleFactor && this.tileSizePerScaleFactor[l] ? this.tileSizePerScaleFactor[l].width : this._tileWidth;
          },
          /**
           * Return the tileHeight for the given level.
           * @function
           * @param {Number} level
           */
          getTileHeight: function(a) {
            if (this.emulateLegacyImagePyramid)
              return e.TileSource.prototype.getTileHeight.call(this, a);
            var l = Math.pow(2, this.maxLevel - a);
            return this.tileSizePerScaleFactor && this.tileSizePerScaleFactor[l] ? this.tileSizePerScaleFactor[l].height : this._tileHeight;
          },
          /**
           * @function
           * @param {Number} level
           */
          getLevelScale: function(a) {
            if (this.emulateLegacyImagePyramid) {
              var l = NaN;
              return this.levels.length > 0 && a >= this.minLevel && a <= this.maxLevel && (l = this.levels[a].width / this.levels[this.maxLevel].width), l;
            }
            return e.TileSource.prototype.getLevelScale.call(this, a);
          },
          /**
           * @function
           * @param {Number} level
           */
          getNumTiles: function(a) {
            if (this.emulateLegacyImagePyramid) {
              var l = this.getLevelScale(a);
              return l ? new e.Point(1, 1) : new e.Point(0, 0);
            }
            if (this.levelSizes) {
              var h = this.levelSizes[a], d = Math.ceil(h.width / this.getTileWidth(a)), f = Math.ceil(h.height / this.getTileHeight(a));
              return new e.Point(d, f);
            } else
              return e.TileSource.prototype.getNumTiles.call(this, a);
          },
          /**
           * @function
           * @param {Number} level
           * @param {OpenSeadragon.Point} point
           */
          getTileAtPoint: function(a, l) {
            if (this.emulateLegacyImagePyramid)
              return new e.Point(0, 0);
            if (this.levelSizes) {
              var h = l.x >= 0 && l.x <= 1 && l.y >= 0 && l.y <= 1 / this.aspectRatio;
              e.console.assert(h, "[TileSource.getTileAtPoint] must be called with a valid point.");
              var d = this.levelSizes[a].width, f = l.x * d, g = l.y * d, w = Math.floor(f / this.getTileWidth(a)), C = Math.floor(g / this.getTileHeight(a));
              l.x >= 1 && (w = this.getNumTiles(a).x - 1);
              var E = 1e-15;
              return l.y >= 1 / this.aspectRatio - E && (C = this.getNumTiles(a).y - 1), new e.Point(w, C);
            }
            return e.TileSource.prototype.getTileAtPoint.call(this, a, l);
          },
          /**
           * Responsible for retrieving the url which will return an image for the
           * region specified by the given x, y, and level components.
           * @function
           * @param {Number} level - z index
           * @param {Number} x
           * @param {Number} y
           * @throws {Error}
           */
          getTileUrl: function(a, l, h) {
            if (this.emulateLegacyImagePyramid) {
              var d = null;
              return this.levels.length > 0 && a >= this.minLevel && a <= this.maxLevel && (d = this.levels[a].url), d;
            }
            var f = "0", g = Math.pow(0.5, this.maxLevel - a), w, C, E, A, I, V, K, ce, re, he, pe, Te, Ae, He, Fe, ve;
            return this.levelSizes ? (w = this.levelSizes[a].width, C = this.levelSizes[a].height) : (w = Math.ceil(this.width * g), C = Math.ceil(this.height * g)), E = this.getTileWidth(a), A = this.getTileHeight(a), I = Math.round(E / g), V = Math.round(A / g), this.version === 1 ? Fe = "native." + this.tileFormat : Fe = "default." + this.tileFormat, w < E && C < A ? (this.version === 2 && w === this.width ? Te = "full" : this.version === 3 && w === this.width && C === this.height ? Te = "max" : this.version === 3 ? Te = w + "," + C : Te = w + ",", K = "full") : (ce = l * I, re = h * V, he = Math.min(I, this.width - ce), pe = Math.min(V, this.height - re), l === 0 && h === 0 && he === this.width && pe === this.height ? K = "full" : K = [ce, re, he, pe].join(","), Ae = Math.min(E, w - l * E), He = Math.min(A, C - h * A), this.version === 2 && Ae === this.width ? Te = "full" : this.version === 3 && Ae === this.width && He === this.height ? Te = "max" : this.version === 3 ? Te = Ae + "," + He : Te = Ae + ","), ve = [this._id, K, Te, f, Fe].join("/"), ve;
          },
          __testonly__: {
            canBeTiled: t,
            constructLevels: i
          }
        }
      );
      function t(a) {
        var l = [
          "http://library.stanford.edu/iiif/image-api/compliance.html#level0",
          "http://library.stanford.edu/iiif/image-api/1.1/compliance.html#level0",
          "http://iiif.io/api/image/2/level0.json",
          "level0",
          "https://iiif.io/api/image/3/level0.json"
        ], h = Array.isArray(a.profile) ? a.profile[0] : a.profile, d = l.indexOf(h) !== -1, f = !1;
        return a.version === 2 && a.profile.length > 1 && a.profile[1].supports && (f = a.profile[1].supports.indexOf("sizeByW") !== -1), a.version === 3 && a.extraFeatures && (f = a.extraFeatures.indexOf("sizeByWh") !== -1), !d || f;
      }
      function i(a) {
        for (var l = [], h = 0; h < a.sizes.length; h++)
          l.push({
            url: a._id + "/full/" + a.sizes[h].width + "," + (a.version === 3 ? a.sizes[h].height : "") + "/0/default." + a.tileFormat,
            width: a.sizes[h].width,
            height: a.sizes[h].height
          });
        return l.sort(function(d, f) {
          return d.width - f.width;
        });
      }
      function n(a) {
        if (!a || !a.documentElement)
          throw new Error(e.getString("Errors.Xml"));
        var l = a.documentElement, h = l.tagName, d = null;
        if (h === "info")
          try {
            return d = {}, o(l, d), d;
          } catch (f) {
            throw f instanceof Error ? f : new Error(e.getString("Errors.IIIF"));
          }
        throw new Error(e.getString("Errors.IIIF"));
      }
      function o(a, l, h) {
        var d, f;
        if (a.nodeType === 3 && h)
          f = a.nodeValue.trim(), f.match(/^\d*$/) && (f = Number(f)), l[h] ? (e.isArray(l[h]) || (l[h] = [l[h]]), l[h].push(f)) : l[h] = f;
        else if (a.nodeType === 1)
          for (d = 0; d < a.childNodes.length; d++)
            o(a.childNodes[d], l, a.nodeName);
      }
    }(r), function(e) {
      e.OsmTileSource = function(t, i, n, o, a) {
        var l;
        e.isPlainObject(t) ? l = t : l = {
          width: arguments[0],
          height: arguments[1],
          tileSize: arguments[2],
          tileOverlap: arguments[3],
          tilesUrl: arguments[4]
        }, (!l.width || !l.height) && (l.width = 65572864, l.height = 65572864), l.tileSize || (l.tileSize = 256, l.tileOverlap = 0), l.tilesUrl || (l.tilesUrl = "http://tile.openstreetmap.org/"), l.minLevel = 8, e.TileSource.apply(this, [l]);
      }, e.extend(
        e.OsmTileSource.prototype,
        e.TileSource.prototype,
        /** @lends OpenSeadragon.OsmTileSource.prototype */
        {
          /**
           * Determine if the data and/or url imply the image service is supported by
           * this tile source.
           * @function
           * @param {Object|Array} data
           * @param {String} optional - url
           */
          supports: function(t, i) {
            return t.type && t.type === "openstreetmaps";
          },
          /**
           *
           * @function
           * @param {Object} data - the raw configuration
           * @param {String} url - the url the data was retrieved from if any.
           * @param {String} postData - HTTP POST data in k=v&k2=v2... form or null
           * @returns {Object} options - A dictionary of keyword arguments sufficient
           *      to configure this tile sources constructor.
           */
          configure: function(t, i, n) {
            return t;
          },
          /**
           * @function
           * @param {Number} level
           * @param {Number} x
           * @param {Number} y
           */
          getTileUrl: function(t, i, n) {
            return this.tilesUrl + (t - 8) + "/" + i + "/" + n + ".png";
          }
        }
      );
    }(r), function(e) {
      e.TmsTileSource = function(t, i, n, o, a) {
        var l;
        e.isPlainObject(t) ? l = t : l = {
          width: arguments[0],
          height: arguments[1],
          tileSize: arguments[2],
          tileOverlap: arguments[3],
          tilesUrl: arguments[4]
        };
        var h = Math.ceil(l.width / 256) * 256, d = Math.ceil(l.height / 256) * 256, f;
        h > d ? f = h / 256 : f = d / 256, l.maxLevel = Math.ceil(Math.log(f) / Math.log(2)) - 1, l.tileSize = 256, l.width = h, l.height = d, e.TileSource.apply(this, [l]);
      }, e.extend(
        e.TmsTileSource.prototype,
        e.TileSource.prototype,
        /** @lends OpenSeadragon.TmsTileSource.prototype */
        {
          /**
           * Determine if the data and/or url imply the image service is supported by
           * this tile source.
           * @function
           * @param {Object|Array} data
           * @param {String} optional - url
           */
          supports: function(t, i) {
            return t.type && t.type === "tiledmapservice";
          },
          /**
           *
           * @function
           * @param {Object} data - the raw configuration
           * @param {String} url - the url the data was retrieved from if any.
           * @param {String} postData - HTTP POST data in k=v&k2=v2... form or null
           * @returns {Object} options - A dictionary of keyword arguments sufficient
           *      to configure this tile sources constructor.
           */
          configure: function(t, i, n) {
            return t;
          },
          /**
           * @function
           * @param {Number} level
           * @param {Number} x
           * @param {Number} y
           */
          getTileUrl: function(t, i, n) {
            var o = this.getNumTiles(t).y - 1;
            return this.tilesUrl + t + "/" + i + "/" + (o - n) + ".png";
          }
        }
      );
    }(r), function(e) {
      e.ZoomifyTileSource = function(t) {
        typeof t.tileSize > "u" && (t.tileSize = 256), typeof t.fileFormat > "u" && (t.fileFormat = "jpg", this.fileFormat = t.fileFormat);
        var i = {
          x: t.width,
          y: t.height
        };
        for (t.imageSizes = [{
          x: t.width,
          y: t.height
        }], t.gridSize = [this._getGridSize(t.width, t.height, t.tileSize)]; parseInt(i.x, 10) > t.tileSize || parseInt(i.y, 10) > t.tileSize; )
          i.x = Math.floor(i.x / 2), i.y = Math.floor(i.y / 2), t.imageSizes.push({
            x: i.x,
            y: i.y
          }), t.gridSize.push(this._getGridSize(i.x, i.y, t.tileSize));
        t.imageSizes.reverse(), t.gridSize.reverse(), t.minLevel = 0, t.maxLevel = t.gridSize.length - 1, r.TileSource.apply(this, [t]);
      }, e.extend(
        e.ZoomifyTileSource.prototype,
        e.TileSource.prototype,
        /** @lends OpenSeadragon.ZoomifyTileSource.prototype */
        {
          //private
          _getGridSize: function(t, i, n) {
            return {
              x: Math.ceil(t / n),
              y: Math.ceil(i / n)
            };
          },
          //private
          _calculateAbsoluteTileNumber: function(t, i, n) {
            for (var o = 0, a = {}, l = 0; l < t; l++)
              a = this.gridSize[l], o += a.x * a.y;
            return a = this.gridSize[t], o += a.x * n + i, o;
          },
          /**
           * Determine if the data and/or url imply the image service is supported by
           * this tile source.
           * @function
           * @param {Object|Array} data
           * @param {String} optional - url
           */
          supports: function(t, i) {
            return t.type && t.type === "zoomifytileservice";
          },
          /**
           *
           * @function
           * @param {Object} data - the raw configuration
           * @param {String} url - the url the data was retrieved from if any.
           * @param {String} postData - HTTP POST data in k=v&k2=v2... form or null
           * @returns {Object} options - A dictionary of keyword arguments sufficient
           *      to configure this tile sources constructor.
           */
          configure: function(t, i, n) {
            return t;
          },
          /**
           * @function
           * @param {Number} level
           * @param {Number} x
           * @param {Number} y
           */
          getTileUrl: function(t, i, n) {
            var o = 0, a = this._calculateAbsoluteTileNumber(t, i, n);
            return o = Math.floor(a / 256), this.tilesUrl + "TileGroup" + o + "/" + t + "-" + i + "-" + n + "." + this.fileFormat;
          }
        }
      );
    }(r), function(e) {
      e.LegacyTileSource = function(o) {
        var a, l, h;
        e.isArray(o) && (a = {
          type: "legacy-image-pyramid",
          levels: o
        }), a.levels = t(a.levels), a.levels.length > 0 ? (l = a.levels[a.levels.length - 1].width, h = a.levels[a.levels.length - 1].height) : (l = 0, h = 0, e.console.error("No supported image formats found")), e.extend(!0, a, {
          width: l,
          height: h,
          tileSize: Math.max(h, l),
          tileOverlap: 0,
          minLevel: 0,
          maxLevel: a.levels.length > 0 ? a.levels.length - 1 : 0
        }), e.TileSource.apply(this, [a]), this.levels = a.levels;
      }, e.extend(
        e.LegacyTileSource.prototype,
        e.TileSource.prototype,
        /** @lends OpenSeadragon.LegacyTileSource.prototype */
        {
          /**
           * Determine if the data and/or url imply the image service is supported by
           * this tile source.
           * @function
           * @param {Object|Array} data
           * @param {String} optional - url
           */
          supports: function(o, a) {
            return o.type && o.type === "legacy-image-pyramid" || o.documentElement && o.documentElement.getAttribute("type") === "legacy-image-pyramid";
          },
          /**
           *
           * @function
           * @param {Object|XMLDocument} configuration - the raw configuration
           * @param {String} dataUrl - the url the data was retrieved from if any.
           * @param {String} postData - HTTP POST data in k=v&k2=v2... form or null
           * @returns {Object} options - A dictionary of keyword arguments sufficient
           *      to configure this tile sources constructor.
           */
          configure: function(o, a, l) {
            var h;
            return e.isPlainObject(o) ? h = n(this, o) : h = i(this, o), h;
          },
          /**
           * @function
           * @param {Number} level
           */
          getLevelScale: function(o) {
            var a = NaN;
            return this.levels.length > 0 && o >= this.minLevel && o <= this.maxLevel && (a = this.levels[o].width / this.levels[this.maxLevel].width), a;
          },
          /**
           * @function
           * @param {Number} level
           */
          getNumTiles: function(o) {
            var a = this.getLevelScale(o);
            return a ? new e.Point(1, 1) : new e.Point(0, 0);
          },
          /**
           * This method is not implemented by this class other than to throw an Error
           * announcing you have to implement it.  Because of the variety of tile
           * server technologies, and various specifications for building image
           * pyramids, this method is here to allow easy integration.
           * @function
           * @param {Number} level
           * @param {Number} x
           * @param {Number} y
           * @throws {Error}
           */
          getTileUrl: function(o, a, l) {
            var h = null;
            return this.levels.length > 0 && o >= this.minLevel && o <= this.maxLevel && (h = this.levels[o].url), h;
          }
        }
      );
      function t(o) {
        var a = [], l, h;
        for (h = 0; h < o.length; h++)
          l = o[h], l.height && l.width && l.url ? a.push({
            url: l.url,
            width: Number(l.width),
            height: Number(l.height)
          }) : e.console.error("Unsupported image format: %s", l.url ? l.url : "<no URL>");
        return a.sort(function(d, f) {
          return d.height - f.height;
        });
      }
      function i(o, a) {
        if (!a || !a.documentElement)
          throw new Error(e.getString("Errors.Xml"));
        var l = a.documentElement, h = l.tagName, d = null, f = [], g, w;
        if (h === "image")
          try {
            for (d = {
              type: l.getAttribute("type"),
              levels: []
            }, f = l.getElementsByTagName("level"), w = 0; w < f.length; w++)
              g = f[w], d.levels.push({
                url: g.getAttribute("url"),
                width: parseInt(g.getAttribute("width"), 10),
                height: parseInt(g.getAttribute("height"), 10)
              });
            return n(o, d);
          } catch (C) {
            throw C instanceof Error ? C : new Error("Unknown error parsing Legacy Image Pyramid XML.");
          }
        else {
          if (h === "collection")
            throw new Error("Legacy Image Pyramid Collections not yet supported.");
          if (h === "error")
            throw new Error("Error: " + a);
        }
        throw new Error("Unknown element " + h);
      }
      function n(o, a) {
        return a.levels;
      }
    }(r), function(e) {
      e.ImageTileSource = function(t) {
        t = e.extend({
          buildPyramid: !0,
          crossOriginPolicy: !1,
          ajaxWithCredentials: !1
        }, t), e.TileSource.apply(this, [t]);
      }, e.extend(
        e.ImageTileSource.prototype,
        e.TileSource.prototype,
        /** @lends OpenSeadragon.ImageTileSource.prototype */
        {
          /**
           * Determine if the data and/or url imply the image service is supported by
           * this tile source.
           * @function
           * @param {Object|Array} data
           * @param {String} optional - url
           */
          supports: function(t, i) {
            return t.type && t.type === "image";
          },
          /**
           *
           * @function
           * @param {Object} options - the options
           * @param {String} dataUrl - the url the image was retrieved from, if any.
           * @param {String} postData - HTTP POST data in k=v&k2=v2... form or null
           * @returns {Object} options - A dictionary of keyword arguments sufficient
           *      to configure this tile sources constructor.
           */
          configure: function(t, i, n) {
            return t;
          },
          /**
           * Responsible for retrieving, and caching the
           * image metadata pertinent to this TileSources implementation.
           * @function
           * @param {String} url
           * @throws {Error}
           */
          getImageInfo: function(t) {
            var i = this._image = new Image(), n = this;
            this.crossOriginPolicy && (i.crossOrigin = this.crossOriginPolicy), this.ajaxWithCredentials && (i.useCredentials = this.ajaxWithCredentials), e.addEvent(i, "load", function() {
              n.width = i.naturalWidth, n.height = i.naturalHeight, n.aspectRatio = n.width / n.height, n.dimensions = new e.Point(n.width, n.height), n._tileWidth = n.width, n._tileHeight = n.height, n.tileOverlap = 0, n.minLevel = 0, n.levels = n._buildLevels(), n.maxLevel = n.levels.length - 1, n.ready = !0, n.raiseEvent("ready", { tileSource: n });
            }), e.addEvent(i, "error", function() {
              n.raiseEvent("open-failed", {
                message: "Error loading image at " + t,
                source: t
              });
            }), i.src = t;
          },
          /**
           * @function
           * @param {Number} level
           */
          getLevelScale: function(t) {
            var i = NaN;
            return t >= this.minLevel && t <= this.maxLevel && (i = this.levels[t].width / this.levels[this.maxLevel].width), i;
          },
          /**
           * @function
           * @param {Number} level
           */
          getNumTiles: function(t) {
            var i = this.getLevelScale(t);
            return i ? new e.Point(1, 1) : new e.Point(0, 0);
          },
          /**
           * Retrieves a tile url
           * @function
           * @param {Number} level Level of the tile
           * @param {Number} x x coordinate of the tile
           * @param {Number} y y coordinate of the tile
           */
          getTileUrl: function(t, i, n) {
            var o = null;
            return t >= this.minLevel && t <= this.maxLevel && (o = this.levels[t].url), o;
          },
          /**
           * Retrieves a tile context 2D
           * @function
           * @param {Number} level Level of the tile
           * @param {Number} x x coordinate of the tile
           * @param {Number} y y coordinate of the tile
           */
          getContext2D: function(t, i, n) {
            var o = null;
            return t >= this.minLevel && t <= this.maxLevel && (o = this.levels[t].context2D), o;
          },
          /**
           * Destroys ImageTileSource
           * @function
           * @param {OpenSeadragon.Viewer} viewer the viewer that is calling
           * destroy on the ImageTileSource
           */
          destroy: function(t) {
            this._freeupCanvasMemory(t);
          },
          // private
          //
          // Builds the different levels of the pyramid if possible
          // (i.e. if canvas API enabled and no canvas tainting issue).
          _buildLevels: function() {
            var t = [{
              url: this._image.src,
              width: this._image.naturalWidth,
              height: this._image.naturalHeight
            }];
            if (!this.buildPyramid || !e.supportsCanvas)
              return delete this._image, t;
            var i = this._image.naturalWidth, n = this._image.naturalHeight, o = document.createElement("canvas"), a = o.getContext("2d");
            if (o.width = i, o.height = n, a.drawImage(this._image, 0, 0, i, n), t[0].context2D = a, delete this._image, e.isCanvasTainted(o))
              return t;
            for (; i >= 2 && n >= 2; ) {
              i = Math.floor(i / 2), n = Math.floor(n / 2);
              var l = document.createElement("canvas"), h = l.getContext("2d");
              l.width = i, l.height = n, h.drawImage(o, 0, 0, i, n), t.splice(0, 0, {
                context2D: h,
                width: i,
                height: n
              }), o = l, a = h;
            }
            return t;
          },
          /**
           * Free up canvas memory
           * (iOS 12 or higher on 2GB RAM device has only 224MB canvas memory,
           * and Safari keeps canvas until its height and width will be set to 0).
           * @function
           */
          _freeupCanvasMemory: function(t) {
            for (var i = 0; i < this.levels.length; i++)
              this.levels[i].context2D && (this.levels[i].context2D.canvas.height = 0, this.levels[i].context2D.canvas.width = 0, t && t.raiseEvent("image-unloaded", {
                context2D: this.levels[i].context2D
              }));
          }
        }
      );
    }(r), function(e) {
      e.TileSourceCollection = function(t, i, n, o) {
        e.console.error("TileSourceCollection is deprecated; use World instead");
      };
    }(r), function(e) {
      e.ButtonState = {
        REST: 0,
        GROUP: 1,
        HOVER: 2,
        DOWN: 3
      }, e.Button = function(h) {
        var d = this;
        e.EventSource.call(this), e.extend(!0, this, {
          tooltip: null,
          srcRest: null,
          srcGroup: null,
          srcHover: null,
          srcDown: null,
          clickTimeThreshold: e.DEFAULT_SETTINGS.clickTimeThreshold,
          clickDistThreshold: e.DEFAULT_SETTINGS.clickDistThreshold,
          /**
           * How long to wait before fading.
           * @member {Number} fadeDelay
           * @memberof OpenSeadragon.Button#
           */
          fadeDelay: 0,
          /**
           * How long should it take to fade the button.
           * @member {Number} fadeLength
           * @memberof OpenSeadragon.Button#
           */
          fadeLength: 2e3,
          onPress: null,
          onRelease: null,
          onClick: null,
          onEnter: null,
          onExit: null,
          onFocus: null,
          onBlur: null,
          userData: null
        }, h), this.element = h.element || e.makeNeutralElement("div"), h.element || (this.imgRest = e.makeTransparentImage(this.srcRest), this.imgGroup = e.makeTransparentImage(this.srcGroup), this.imgHover = e.makeTransparentImage(this.srcHover), this.imgDown = e.makeTransparentImage(this.srcDown), this.imgRest.alt = this.imgGroup.alt = this.imgHover.alt = this.imgDown.alt = this.tooltip, e.setElementPointerEventsNone(this.imgRest), e.setElementPointerEventsNone(this.imgGroup), e.setElementPointerEventsNone(this.imgHover), e.setElementPointerEventsNone(this.imgDown), this.element.style.position = "relative", e.setElementTouchActionNone(this.element), this.imgGroup.style.position = this.imgHover.style.position = this.imgDown.style.position = "absolute", this.imgGroup.style.top = this.imgHover.style.top = this.imgDown.style.top = "0px", this.imgGroup.style.left = this.imgHover.style.left = this.imgDown.style.left = "0px", this.imgHover.style.visibility = this.imgDown.style.visibility = "hidden", this.element.appendChild(this.imgRest), this.element.appendChild(this.imgGroup), this.element.appendChild(this.imgHover), this.element.appendChild(this.imgDown)), this.addHandler("press", this.onPress), this.addHandler("release", this.onRelease), this.addHandler("click", this.onClick), this.addHandler("enter", this.onEnter), this.addHandler("exit", this.onExit), this.addHandler("focus", this.onFocus), this.addHandler("blur", this.onBlur), this.currentState = e.ButtonState.GROUP, this.fadeBeginTime = null, this.shouldFade = !1, this.element.style.display = "inline-block", this.element.style.position = "relative", this.element.title = this.tooltip, this.tracker = new e.MouseTracker({
          userData: "Button.tracker",
          element: this.element,
          clickTimeThreshold: this.clickTimeThreshold,
          clickDistThreshold: this.clickDistThreshold,
          enterHandler: function(f) {
            f.insideElementPressed ? (a(d, e.ButtonState.DOWN), d.raiseEvent("enter", { originalEvent: f.originalEvent })) : f.buttonDownAny || a(d, e.ButtonState.HOVER);
          },
          focusHandler: function(f) {
            d.tracker.enterHandler(f), d.raiseEvent("focus", { originalEvent: f.originalEvent });
          },
          leaveHandler: function(f) {
            l(d, e.ButtonState.GROUP), f.insideElementPressed && d.raiseEvent("exit", { originalEvent: f.originalEvent });
          },
          blurHandler: function(f) {
            d.tracker.leaveHandler(f), d.raiseEvent("blur", { originalEvent: f.originalEvent });
          },
          pressHandler: function(f) {
            a(d, e.ButtonState.DOWN), d.raiseEvent("press", { originalEvent: f.originalEvent });
          },
          releaseHandler: function(f) {
            f.insideElementPressed && f.insideElementReleased ? (l(d, e.ButtonState.HOVER), d.raiseEvent("release", { originalEvent: f.originalEvent })) : f.insideElementPressed ? l(d, e.ButtonState.GROUP) : a(d, e.ButtonState.HOVER);
          },
          clickHandler: function(f) {
            f.quick && d.raiseEvent("click", { originalEvent: f.originalEvent });
          },
          keyHandler: function(f) {
            f.keyCode === 13 ? (d.raiseEvent("click", { originalEvent: f.originalEvent }), d.raiseEvent("release", { originalEvent: f.originalEvent }), f.preventDefault = !0) : f.preventDefault = !1;
          }
        }), l(this, e.ButtonState.REST);
      }, e.extend(
        e.Button.prototype,
        e.EventSource.prototype,
        /** @lends OpenSeadragon.Button.prototype */
        {
          /**
           * Used by a button container element (e.g. a ButtonGroup) to transition the button state
           * to ButtonState.GROUP.
           * @function
           */
          notifyGroupEnter: function() {
            a(this, e.ButtonState.GROUP);
          },
          /**
           * Used by a button container element (e.g. a ButtonGroup) to transition the button state
           * to ButtonState.REST.
           * @function
           */
          notifyGroupExit: function() {
            l(this, e.ButtonState.REST);
          },
          /**
           * @function
           */
          disable: function() {
            this.notifyGroupExit(), this.element.disabled = !0, this.tracker.setTracking(!1), e.setElementOpacity(this.element, 0.2, !0);
          },
          /**
           * @function
           */
          enable: function() {
            this.element.disabled = !1, this.tracker.setTracking(!0), e.setElementOpacity(this.element, 1, !0), this.notifyGroupEnter();
          },
          destroy: function() {
            this.imgRest && (this.element.removeChild(this.imgRest), this.imgRest = null), this.imgGroup && (this.element.removeChild(this.imgGroup), this.imgGroup = null), this.imgHover && (this.element.removeChild(this.imgHover), this.imgHover = null), this.imgDown && (this.element.removeChild(this.imgDown), this.imgDown = null), this.removeAllHandlers(), this.tracker.destroy(), this.element = null;
          }
        }
      );
      function t(h) {
        e.requestAnimationFrame(function() {
          i(h);
        });
      }
      function i(h) {
        var d, f, g;
        h.shouldFade && (d = e.now(), f = d - h.fadeBeginTime, g = 1 - f / h.fadeLength, g = Math.min(1, g), g = Math.max(0, g), h.imgGroup && e.setElementOpacity(h.imgGroup, g, !0), g > 0 && t(h));
      }
      function n(h) {
        h.shouldFade = !0, h.fadeBeginTime = e.now() + h.fadeDelay, window.setTimeout(function() {
          t(h);
        }, h.fadeDelay);
      }
      function o(h) {
        h.shouldFade = !1, h.imgGroup && e.setElementOpacity(h.imgGroup, 1, !0);
      }
      function a(h, d) {
        h.element.disabled || (d >= e.ButtonState.GROUP && h.currentState === e.ButtonState.REST && (o(h), h.currentState = e.ButtonState.GROUP), d >= e.ButtonState.HOVER && h.currentState === e.ButtonState.GROUP && (h.imgHover && (h.imgHover.style.visibility = ""), h.currentState = e.ButtonState.HOVER), d >= e.ButtonState.DOWN && h.currentState === e.ButtonState.HOVER && (h.imgDown && (h.imgDown.style.visibility = ""), h.currentState = e.ButtonState.DOWN));
      }
      function l(h, d) {
        h.element.disabled || (d <= e.ButtonState.HOVER && h.currentState === e.ButtonState.DOWN && (h.imgDown && (h.imgDown.style.visibility = "hidden"), h.currentState = e.ButtonState.HOVER), d <= e.ButtonState.GROUP && h.currentState === e.ButtonState.HOVER && (h.imgHover && (h.imgHover.style.visibility = "hidden"), h.currentState = e.ButtonState.GROUP), d <= e.ButtonState.REST && h.currentState === e.ButtonState.GROUP && (n(h), h.currentState = e.ButtonState.REST));
      }
    }(r), function(e) {
      e.ButtonGroup = function(t) {
        e.extend(!0, this, {
          /**
           * An array containing the buttons themselves.
           * @member {Array} buttons
           * @memberof OpenSeadragon.ButtonGroup#
           */
          buttons: [],
          clickTimeThreshold: e.DEFAULT_SETTINGS.clickTimeThreshold,
          clickDistThreshold: e.DEFAULT_SETTINGS.clickDistThreshold,
          labelText: ""
        }, t);
        var i = this.buttons.concat([]), n = this, o;
        if (this.element = t.element || e.makeNeutralElement("div"), !t.group)
          for (this.element.style.display = "inline-block", o = 0; o < i.length; o++)
            this.element.appendChild(i[o].element);
        e.setElementTouchActionNone(this.element), this.tracker = new e.MouseTracker({
          userData: "ButtonGroup.tracker",
          element: this.element,
          clickTimeThreshold: this.clickTimeThreshold,
          clickDistThreshold: this.clickDistThreshold,
          enterHandler: function(a) {
            var l;
            for (l = 0; l < n.buttons.length; l++)
              n.buttons[l].notifyGroupEnter();
          },
          leaveHandler: function(a) {
            var l;
            if (!a.insideElementPressed)
              for (l = 0; l < n.buttons.length; l++)
                n.buttons[l].notifyGroupExit();
          }
        });
      }, e.ButtonGroup.prototype = {
        /**
         * Adds the given button to this button group.
         *
         * @function
         * @param {OpenSeadragon.Button} button
         */
        addButton: function(t) {
          this.buttons.push(t), this.element.appendChild(t.element);
        },
        /**
         * TODO: Figure out why this is used on the public API and if a more useful
         * api can be created.
         * @function
         * @private
         */
        emulateEnter: function() {
          this.tracker.enterHandler({ eventSource: this.tracker });
        },
        /**
         * TODO: Figure out why this is used on the public API and if a more useful
         * api can be created.
         * @function
         * @private
         */
        emulateLeave: function() {
          this.tracker.leaveHandler({ eventSource: this.tracker });
        },
        destroy: function() {
          for (; this.buttons.length; ) {
            var t = this.buttons.pop();
            this.element.removeChild(t.element), t.destroy();
          }
          this.tracker.destroy(), this.element = null;
        }
      };
    }(r), function(e) {
      e.Rect = function(t, i, n, o, a) {
        this.x = typeof t == "number" ? t : 0, this.y = typeof i == "number" ? i : 0, this.width = typeof n == "number" ? n : 0, this.height = typeof o == "number" ? o : 0, this.degrees = typeof a == "number" ? a : 0, this.degrees = e.positiveModulo(this.degrees, 360);
        var l, h;
        this.degrees >= 270 ? (l = this.getTopRight(), this.x = l.x, this.y = l.y, h = this.height, this.height = this.width, this.width = h, this.degrees -= 270) : this.degrees >= 180 ? (l = this.getBottomRight(), this.x = l.x, this.y = l.y, this.degrees -= 180) : this.degrees >= 90 && (l = this.getBottomLeft(), this.x = l.x, this.y = l.y, h = this.height, this.height = this.width, this.width = h, this.degrees -= 90);
      }, e.Rect.fromSummits = function(t, i, n) {
        var o = t.distanceTo(i), a = t.distanceTo(n), l = i.minus(t), h = Math.atan(l.y / l.x);
        return l.x < 0 ? h += Math.PI : l.y < 0 && (h += 2 * Math.PI), new e.Rect(
          t.x,
          t.y,
          o,
          a,
          h / Math.PI * 180
        );
      }, e.Rect.prototype = {
        /**
         * @function
         * @returns {OpenSeadragon.Rect} a duplicate of this Rect
         */
        clone: function() {
          return new e.Rect(
            this.x,
            this.y,
            this.width,
            this.height,
            this.degrees
          );
        },
        /**
         * The aspect ratio is simply the ratio of width to height.
         * @function
         * @returns {Number} The ratio of width to height.
         */
        getAspectRatio: function() {
          return this.width / this.height;
        },
        /**
         * Provides the coordinates of the upper-left corner of the rectangle as a
         * point.
         * @function
         * @returns {OpenSeadragon.Point} The coordinate of the upper-left corner of
         *  the rectangle.
         */
        getTopLeft: function() {
          return new e.Point(
            this.x,
            this.y
          );
        },
        /**
         * Provides the coordinates of the bottom-right corner of the rectangle as a
         * point.
         * @function
         * @returns {OpenSeadragon.Point} The coordinate of the bottom-right corner of
         *  the rectangle.
         */
        getBottomRight: function() {
          return new e.Point(this.x + this.width, this.y + this.height).rotate(this.degrees, this.getTopLeft());
        },
        /**
         * Provides the coordinates of the top-right corner of the rectangle as a
         * point.
         * @function
         * @returns {OpenSeadragon.Point} The coordinate of the top-right corner of
         *  the rectangle.
         */
        getTopRight: function() {
          return new e.Point(this.x + this.width, this.y).rotate(this.degrees, this.getTopLeft());
        },
        /**
         * Provides the coordinates of the bottom-left corner of the rectangle as a
         * point.
         * @function
         * @returns {OpenSeadragon.Point} The coordinate of the bottom-left corner of
         *  the rectangle.
         */
        getBottomLeft: function() {
          return new e.Point(this.x, this.y + this.height).rotate(this.degrees, this.getTopLeft());
        },
        /**
         * Computes the center of the rectangle.
         * @function
         * @returns {OpenSeadragon.Point} The center of the rectangle as represented
         *  as represented by a 2-dimensional vector (x,y)
         */
        getCenter: function() {
          return new e.Point(
            this.x + this.width / 2,
            this.y + this.height / 2
          ).rotate(this.degrees, this.getTopLeft());
        },
        /**
         * Returns the width and height component as a vector OpenSeadragon.Point
         * @function
         * @returns {OpenSeadragon.Point} The 2 dimensional vector representing the
         *  width and height of the rectangle.
         */
        getSize: function() {
          return new e.Point(this.width, this.height);
        },
        /**
         * Determines if two Rectangles have equivalent components.
         * @function
         * @param {OpenSeadragon.Rect} rectangle The Rectangle to compare to.
         * @returns {Boolean} 'true' if all components are equal, otherwise 'false'.
         */
        equals: function(t) {
          return t instanceof e.Rect && this.x === t.x && this.y === t.y && this.width === t.width && this.height === t.height && this.degrees === t.degrees;
        },
        /**
        * Multiply all dimensions (except degrees) in this Rect by a factor and
        * return a new Rect.
        * @function
        * @param {Number} factor The factor to multiply vector components.
        * @returns {OpenSeadragon.Rect} A new rect representing the multiplication
        *  of the vector components by the factor
        */
        times: function(t) {
          return new e.Rect(
            this.x * t,
            this.y * t,
            this.width * t,
            this.height * t,
            this.degrees
          );
        },
        /**
        * Translate/move this Rect by a vector and return new Rect.
        * @function
        * @param {OpenSeadragon.Point} delta The translation vector.
        * @returns {OpenSeadragon.Rect} A new rect with altered position
        */
        translate: function(t) {
          return new e.Rect(
            this.x + t.x,
            this.y + t.y,
            this.width,
            this.height,
            this.degrees
          );
        },
        /**
         * Returns the smallest rectangle that will contain this and the given
         * rectangle bounding boxes.
         * @param {OpenSeadragon.Rect} rect
         * @returns {OpenSeadragon.Rect} The new rectangle.
         */
        union: function(t) {
          var i = this.getBoundingBox(), n = t.getBoundingBox(), o = Math.min(i.x, n.x), a = Math.min(i.y, n.y), l = Math.max(
            i.x + i.width,
            n.x + n.width
          ), h = Math.max(
            i.y + i.height,
            n.y + n.height
          );
          return new e.Rect(
            o,
            a,
            l - o,
            h - a
          );
        },
        /**
         * Returns the bounding box of the intersection of this rectangle with the
         * given rectangle.
         * @param {OpenSeadragon.Rect} rect
         * @returns {OpenSeadragon.Rect} the bounding box of the intersection
         * or null if the rectangles don't intersect.
         */
        intersection: function(t) {
          var i = 1e-10, n = [], o = this.getTopLeft();
          t.containsPoint(o, i) && n.push(o);
          var a = this.getTopRight();
          t.containsPoint(a, i) && n.push(a);
          var l = this.getBottomLeft();
          t.containsPoint(l, i) && n.push(l);
          var h = this.getBottomRight();
          t.containsPoint(h, i) && n.push(h);
          var d = t.getTopLeft();
          this.containsPoint(d, i) && n.push(d);
          var f = t.getTopRight();
          this.containsPoint(f, i) && n.push(f);
          var g = t.getBottomLeft();
          this.containsPoint(g, i) && n.push(g);
          var w = t.getBottomRight();
          this.containsPoint(w, i) && n.push(w);
          for (var C = this._getSegments(), E = t._getSegments(), A = 0; A < C.length; A++)
            for (var I = C[A], V = 0; V < E.length; V++) {
              var K = E[V], ce = re(
                I[0],
                I[1],
                K[0],
                K[1]
              );
              ce && n.push(ce);
            }
          function re(ve, Re, Ze, Ue) {
            var We = Re.minus(ve), it = Ue.minus(Ze), Ve = -it.x * We.y + We.x * it.y;
            if (Ve === 0)
              return null;
            var rt = (We.x * (ve.y - Ze.y) - We.y * (ve.x - Ze.x)) / Ve, Ye = (it.x * (ve.y - Ze.y) - it.y * (ve.x - Ze.x)) / Ve;
            return -i <= rt && rt <= 1 - i && -i <= Ye && Ye <= 1 - i ? new e.Point(ve.x + Ye * We.x, ve.y + Ye * We.y) : null;
          }
          if (n.length === 0)
            return null;
          for (var he = n[0].x, pe = n[0].x, Te = n[0].y, Ae = n[0].y, He = 1; He < n.length; He++) {
            var Fe = n[He];
            Fe.x < he && (he = Fe.x), Fe.x > pe && (pe = Fe.x), Fe.y < Te && (Te = Fe.y), Fe.y > Ae && (Ae = Fe.y);
          }
          return new e.Rect(he, Te, pe - he, Ae - Te);
        },
        // private
        _getSegments: function() {
          var t = this.getTopLeft(), i = this.getTopRight(), n = this.getBottomLeft(), o = this.getBottomRight();
          return [
            [t, i],
            [i, o],
            [o, n],
            [n, t]
          ];
        },
        /**
         * Rotates a rectangle around a point.
         * @function
         * @param {Number} degrees The angle in degrees to rotate.
         * @param {OpenSeadragon.Point} [pivot] The point about which to rotate.
         * Defaults to the center of the rectangle.
         * @returns {OpenSeadragon.Rect}
         */
        rotate: function(t, i) {
          if (t = e.positiveModulo(t, 360), t === 0)
            return this.clone();
          i = i || this.getCenter();
          var n = this.getTopLeft().rotate(t, i), o = this.getTopRight().rotate(t, i), a = o.minus(n);
          a = a.apply(function(h) {
            var d = 1e-15;
            return Math.abs(h) < d ? 0 : h;
          });
          var l = Math.atan(a.y / a.x);
          return a.x < 0 ? l += Math.PI : a.y < 0 && (l += 2 * Math.PI), new e.Rect(
            n.x,
            n.y,
            this.width,
            this.height,
            l / Math.PI * 180
          );
        },
        /**
         * Retrieves the smallest horizontal (degrees=0) rectangle which contains
         * this rectangle.
         * @returns {OpenSeadragon.Rect}
         */
        getBoundingBox: function() {
          if (this.degrees === 0)
            return this.clone();
          var t = this.getTopLeft(), i = this.getTopRight(), n = this.getBottomLeft(), o = this.getBottomRight(), a = Math.min(t.x, i.x, n.x, o.x), l = Math.max(t.x, i.x, n.x, o.x), h = Math.min(t.y, i.y, n.y, o.y), d = Math.max(t.y, i.y, n.y, o.y);
          return new e.Rect(
            a,
            h,
            l - a,
            d - h
          );
        },
        /**
         * Retrieves the smallest horizontal (degrees=0) rectangle which contains
         * this rectangle and has integers x, y, width and height
         * @returns {OpenSeadragon.Rect}
         */
        getIntegerBoundingBox: function() {
          var t = this.getBoundingBox(), i = Math.floor(t.x), n = Math.floor(t.y), o = Math.ceil(t.width + t.x - i), a = Math.ceil(t.height + t.y - n);
          return new e.Rect(i, n, o, a);
        },
        /**
         * Determines whether a point is inside this rectangle (edge included).
         * @function
         * @param {OpenSeadragon.Point} point
         * @param {Number} [epsilon=0] the margin of error allowed
         * @returns {Boolean} true if the point is inside this rectangle, false
         * otherwise.
         */
        containsPoint: function(t, i) {
          i = i || 0;
          var n = this.getTopLeft(), o = this.getTopRight(), a = this.getBottomLeft(), l = o.minus(n), h = a.minus(n);
          return (t.x - n.x) * l.x + (t.y - n.y) * l.y >= -i && (t.x - o.x) * l.x + (t.y - o.y) * l.y <= i && (t.x - n.x) * h.x + (t.y - n.y) * h.y >= -i && (t.x - a.x) * h.x + (t.y - a.y) * h.y <= i;
        },
        /**
         * Provides a string representation of the rectangle which is useful for
         * debugging.
         * @function
         * @returns {String} A string representation of the rectangle.
         */
        toString: function() {
          return "[" + Math.round(this.x * 100) / 100 + ", " + Math.round(this.y * 100) / 100 + ", " + Math.round(this.width * 100) / 100 + "x" + Math.round(this.height * 100) / 100 + ", " + Math.round(this.degrees * 100) / 100 + "deg]";
        }
      };
    }(r), function(e) {
      var t = {};
      e.ReferenceStrip = function(g) {
        var w = this, C = g.viewer, E = e.getElementSize(C.element), A, I, V;
        for (g.id || (g.id = "referencestrip-" + e.now(), this.element = e.makeNeutralElement("div"), this.element.id = g.id, this.element.className = "referencestrip"), g = e.extend(!0, {
          sizeRatio: e.DEFAULT_SETTINGS.referenceStripSizeRatio,
          position: e.DEFAULT_SETTINGS.referenceStripPosition,
          scroll: e.DEFAULT_SETTINGS.referenceStripScroll,
          clickTimeThreshold: e.DEFAULT_SETTINGS.clickTimeThreshold
        }, g, {
          element: this.element
        }), e.extend(this, g), t[this.id] = {
          animating: !1
        }, this.minPixelRatio = this.viewer.minPixelRatio, this.element.tabIndex = 0, I = this.element.style, I.marginTop = "0px", I.marginRight = "0px", I.marginBottom = "0px", I.marginLeft = "0px", I.left = "0px", I.bottom = "0px", I.border = "0px", I.background = "#000", I.position = "relative", e.setElementTouchActionNone(this.element), e.setElementOpacity(this.element, 0.8), this.viewer = C, this.tracker = new e.MouseTracker({
          userData: "ReferenceStrip.tracker",
          element: this.element,
          clickHandler: e.delegate(this, i),
          dragHandler: e.delegate(this, n),
          scrollHandler: e.delegate(this, o),
          enterHandler: e.delegate(this, l),
          leaveHandler: e.delegate(this, h),
          keyDownHandler: e.delegate(this, d),
          keyHandler: e.delegate(this, f),
          preProcessEventHandler: function(K) {
            K.eventType === "wheel" && (K.preventDefault = !0);
          }
        }), g.width && g.height ? (this.element.style.width = g.width + "px", this.element.style.height = g.height + "px", C.addControl(
          this.element,
          { anchor: e.ControlAnchor.BOTTOM_LEFT }
        )) : g.scroll === "horizontal" ? (this.element.style.width = E.x * g.sizeRatio * C.tileSources.length + 12 * C.tileSources.length + "px", this.element.style.height = E.y * g.sizeRatio + "px", C.addControl(
          this.element,
          { anchor: e.ControlAnchor.BOTTOM_LEFT }
        )) : (this.element.style.height = E.y * g.sizeRatio * C.tileSources.length + 12 * C.tileSources.length + "px", this.element.style.width = E.x * g.sizeRatio + "px", C.addControl(
          this.element,
          { anchor: e.ControlAnchor.TOP_LEFT }
        )), this.panelWidth = E.x * this.sizeRatio + 8, this.panelHeight = E.y * this.sizeRatio + 8, this.panels = [], this.miniViewers = {}, V = 0; V < C.tileSources.length; V++)
          A = e.makeNeutralElement("div"), A.id = this.element.id + "-" + V, A.style.width = w.panelWidth + "px", A.style.height = w.panelHeight + "px", A.style.display = "inline", A.style.float = "left", A.style.cssFloat = "left", A.style.padding = "2px", e.setElementTouchActionNone(A), e.setElementPointerEventsNone(A), this.element.appendChild(A), A.activePanel = !1, this.panels.push(A);
        a(this, this.scroll === "vertical" ? E.y : E.x, 0), this.setFocus(0);
      }, e.ReferenceStrip.prototype = {
        /**
         * @function
         */
        setFocus: function(g) {
          var w = this.element.querySelector("#" + this.element.id + "-" + g), C = e.getElementSize(this.viewer.canvas), E = Number(this.element.style.width.replace("px", "")), A = Number(this.element.style.height.replace("px", "")), I = -Number(this.element.style.marginLeft.replace("px", "")), V = -Number(this.element.style.marginTop.replace("px", "")), K;
          this.currentSelected !== w && (this.currentSelected && (this.currentSelected.style.background = "#000"), this.currentSelected = w, this.currentSelected.style.background = "#999", this.scroll === "horizontal" ? (K = Number(g) * (this.panelWidth + 3), K > I + C.x - this.panelWidth ? (K = Math.min(K, E - C.x), this.element.style.marginLeft = -K + "px", a(this, C.x, -K)) : K < I && (K = Math.max(0, K - C.x / 2), this.element.style.marginLeft = -K + "px", a(this, C.x, -K))) : (K = Number(g) * (this.panelHeight + 3), K > V + C.y - this.panelHeight ? (K = Math.min(K, A - C.y), this.element.style.marginTop = -K + "px", a(this, C.y, -K)) : K < V && (K = Math.max(0, K - C.y / 2), this.element.style.marginTop = -K + "px", a(this, C.y, -K))), this.currentPage = g, l.call(this, { eventSource: this.tracker }));
        },
        /**
         * @function
         */
        update: function() {
          return !!t[this.id].animating;
        },
        destroy: function() {
          if (this.miniViewers)
            for (var g in this.miniViewers)
              this.miniViewers[g].destroy();
          this.tracker.destroy(), this.element && this.viewer.removeControl(this.element);
        }
      };
      function i(g) {
        if (g.quick) {
          var w;
          this.scroll === "horizontal" ? w = Math.floor(g.position.x / (this.panelWidth + 4)) : w = Math.floor(g.position.y / this.panelHeight), this.viewer.goToPage(w);
        }
        this.element.focus();
      }
      function n(g) {
        if (this.dragging = !0, this.element) {
          var w = Number(this.element.style.marginLeft.replace("px", "")), C = Number(this.element.style.marginTop.replace("px", "")), E = Number(this.element.style.width.replace("px", "")), A = Number(this.element.style.height.replace("px", "")), I = e.getElementSize(this.viewer.canvas);
          this.scroll === "horizontal" ? -g.delta.x > 0 ? w > -(E - I.x) && (this.element.style.marginLeft = w + g.delta.x * 2 + "px", a(this, I.x, w + g.delta.x * 2)) : -g.delta.x < 0 && w < 0 && (this.element.style.marginLeft = w + g.delta.x * 2 + "px", a(this, I.x, w + g.delta.x * 2)) : -g.delta.y > 0 ? C > -(A - I.y) && (this.element.style.marginTop = C + g.delta.y * 2 + "px", a(this, I.y, C + g.delta.y * 2)) : -g.delta.y < 0 && C < 0 && (this.element.style.marginTop = C + g.delta.y * 2 + "px", a(this, I.y, C + g.delta.y * 2));
        }
      }
      function o(g) {
        if (this.element) {
          var w = Number(this.element.style.marginLeft.replace("px", "")), C = Number(this.element.style.marginTop.replace("px", "")), E = Number(this.element.style.width.replace("px", "")), A = Number(this.element.style.height.replace("px", "")), I = e.getElementSize(this.viewer.canvas);
          this.scroll === "horizontal" ? g.scroll > 0 ? w > -(E - I.x) && (this.element.style.marginLeft = w - g.scroll * 60 + "px", a(this, I.x, w - g.scroll * 60)) : g.scroll < 0 && w < 0 && (this.element.style.marginLeft = w - g.scroll * 60 + "px", a(this, I.x, w - g.scroll * 60)) : g.scroll < 0 ? C > I.y - A && (this.element.style.marginTop = C + g.scroll * 60 + "px", a(this, I.y, C + g.scroll * 60)) : g.scroll > 0 && C < 0 && (this.element.style.marginTop = C + g.scroll * 60 + "px", a(this, I.y, C + g.scroll * 60)), g.preventDefault = !0;
        }
      }
      function a(g, w, C) {
        var E, A, I, V, K, ce;
        for (g.scroll === "horizontal" ? E = g.panelWidth : E = g.panelHeight, A = Math.ceil(w / E) + 5, I = Math.ceil((Math.abs(C) + w) / E) + 1, A = I - A, A = A < 0 ? 0 : A, K = A; K < I && K < g.panels.length; K++)
          if (ce = g.panels[K], !ce.activePanel) {
            var re, he = g.viewer.tileSources[K];
            he.referenceStripThumbnailUrl ? re = {
              type: "image",
              url: he.referenceStripThumbnailUrl
            } : re = he, V = new e.Viewer({
              id: ce.id,
              tileSources: [re],
              element: ce,
              navigatorSizeRatio: g.sizeRatio,
              showNavigator: !1,
              mouseNavEnabled: !1,
              showNavigationControl: !1,
              showSequenceControl: !1,
              immediateRender: !0,
              blendTime: 0,
              animationTime: 0,
              loadTilesWithAjax: g.viewer.loadTilesWithAjax,
              ajaxHeaders: g.viewer.ajaxHeaders,
              drawer: "canvas"
              //always use canvas for the reference strip
            }), e.setElementPointerEventsNone(V.canvas), e.setElementPointerEventsNone(V.container), V.innerTracker.setTracking(!1), V.outerTracker.setTracking(!1), g.miniViewers[ce.id] = V, ce.activePanel = !0;
          }
      }
      function l(g) {
        var w = g.eventSource.element;
        this.scroll === "horizontal" ? w.style.marginBottom = "0px" : w.style.marginLeft = "0px";
      }
      function h(g) {
        var w = g.eventSource.element;
        this.scroll === "horizontal" ? w.style.marginBottom = "-" + e.getElementSize(w).y / 2 + "px" : w.style.marginLeft = "-" + e.getElementSize(w).x / 2 + "px";
      }
      function d(g) {
        if (!g.ctrl && !g.alt && !g.meta)
          switch (g.keyCode) {
            case 38:
              o.call(this, { eventSource: this.tracker, position: null, scroll: 1, shift: null }), g.preventDefault = !0;
              break;
            case 40:
              o.call(this, { eventSource: this.tracker, position: null, scroll: -1, shift: null }), g.preventDefault = !0;
              break;
            case 37:
              o.call(this, { eventSource: this.tracker, position: null, scroll: -1, shift: null }), g.preventDefault = !0;
              break;
            case 39:
              o.call(this, { eventSource: this.tracker, position: null, scroll: 1, shift: null }), g.preventDefault = !0;
              break;
            default:
              g.preventDefault = !1;
              break;
          }
        else
          g.preventDefault = !1;
      }
      function f(g) {
        if (!g.ctrl && !g.alt && !g.meta)
          switch (g.keyCode) {
            case 61:
              o.call(this, { eventSource: this.tracker, position: null, scroll: 1, shift: null }), g.preventDefault = !0;
              break;
            case 45:
              o.call(this, { eventSource: this.tracker, position: null, scroll: -1, shift: null }), g.preventDefault = !0;
              break;
            case 48:
            //0|)
            case 119:
            //w
            case 87:
              o.call(this, { eventSource: this.tracker, position: null, scroll: 1, shift: null }), g.preventDefault = !0;
              break;
            case 115:
            //s
            case 83:
              o.call(this, { eventSource: this.tracker, position: null, scroll: -1, shift: null }), g.preventDefault = !0;
              break;
            case 97:
              o.call(this, { eventSource: this.tracker, position: null, scroll: -1, shift: null }), g.preventDefault = !0;
              break;
            case 100:
              o.call(this, { eventSource: this.tracker, position: null, scroll: 1, shift: null }), g.preventDefault = !0;
              break;
            default:
              g.preventDefault = !1;
              break;
          }
        else
          g.preventDefault = !1;
      }
    }(r), function(e) {
      e.DisplayRect = function(t, i, n, o, a, l) {
        e.Rect.apply(this, [t, i, n, o]), this.minLevel = a, this.maxLevel = l;
      }, e.extend(e.DisplayRect.prototype, e.Rect.prototype);
    }(r), function(e) {
      e.Spring = function(i) {
        var n = arguments;
        typeof i != "object" && (i = {
          initial: n.length && typeof n[0] == "number" ? n[0] : void 0,
          /**
           * Spring stiffness.
           * @member {Number} springStiffness
           * @memberof OpenSeadragon.Spring#
           */
          springStiffness: n.length > 1 ? n[1].springStiffness : 5,
          /**
           * Animation duration per spring.
           * @member {Number} animationTime
           * @memberof OpenSeadragon.Spring#
           */
          animationTime: n.length > 1 ? n[1].animationTime : 1.5
        }), e.console.assert(
          typeof i.springStiffness == "number" && i.springStiffness !== 0,
          "[OpenSeadragon.Spring] options.springStiffness must be a non-zero number"
        ), e.console.assert(
          typeof i.animationTime == "number" && i.animationTime >= 0,
          "[OpenSeadragon.Spring] options.animationTime must be a number greater than or equal to 0"
        ), i.exponential && (this._exponential = !0, delete i.exponential), e.extend(!0, this, i), this.current = {
          value: typeof this.initial == "number" ? this.initial : this._exponential ? 0 : 1,
          time: e.now()
          // always work in milliseconds
        }, e.console.assert(
          !this._exponential || this.current.value !== 0,
          "[OpenSeadragon.Spring] value must be non-zero for exponential springs"
        ), this.start = {
          value: this.current.value,
          time: this.current.time
        }, this.target = {
          value: this.current.value,
          time: this.current.time
        }, this._exponential && (this.start._logValue = Math.log(this.start.value), this.target._logValue = Math.log(this.target.value), this.current._logValue = Math.log(this.current.value));
      }, e.Spring.prototype = {
        /**
         * @function
         * @param {Number} target
         */
        resetTo: function(i) {
          e.console.assert(
            !this._exponential || i !== 0,
            "[OpenSeadragon.Spring.resetTo] target must be non-zero for exponential springs"
          ), this.start.value = this.target.value = this.current.value = i, this.start.time = this.target.time = this.current.time = e.now(), this._exponential && (this.start._logValue = Math.log(this.start.value), this.target._logValue = Math.log(this.target.value), this.current._logValue = Math.log(this.current.value));
        },
        /**
         * @function
         * @param {Number} target
         */
        springTo: function(i) {
          e.console.assert(
            !this._exponential || i !== 0,
            "[OpenSeadragon.Spring.springTo] target must be non-zero for exponential springs"
          ), this.start.value = this.current.value, this.start.time = this.current.time, this.target.value = i, this.target.time = this.start.time + 1e3 * this.animationTime, this._exponential && (this.start._logValue = Math.log(this.start.value), this.target._logValue = Math.log(this.target.value));
        },
        /**
         * @function
         * @param {Number} delta
         */
        shiftBy: function(i) {
          this.start.value += i, this.target.value += i, this._exponential && (e.console.assert(
            this.target.value !== 0 && this.start.value !== 0,
            "[OpenSeadragon.Spring.shiftBy] spring value must be non-zero for exponential springs"
          ), this.start._logValue = Math.log(this.start.value), this.target._logValue = Math.log(this.target.value));
        },
        setExponential: function(i) {
          this._exponential = i, this._exponential && (e.console.assert(
            this.current.value !== 0 && this.target.value !== 0 && this.start.value !== 0,
            "[OpenSeadragon.Spring.setExponential] spring value must be non-zero for exponential springs"
          ), this.start._logValue = Math.log(this.start.value), this.target._logValue = Math.log(this.target.value), this.current._logValue = Math.log(this.current.value));
        },
        /**
         * @function
         * @returns true if the spring is still updating its value, false if it is
         * already at the target value.
         */
        update: function() {
          this.current.time = e.now();
          let i, n;
          if (this._exponential ? (i = this.start._logValue, n = this.target._logValue) : (i = this.start.value, n = this.target.value), this.current.time >= this.target.time)
            this.current.value = this.target.value;
          else {
            let o = i + (n - i) * t(
              this.springStiffness,
              (this.current.time - this.start.time) / (this.target.time - this.start.time)
            );
            this._exponential ? this.current.value = Math.exp(o) : this.current.value = o;
          }
          return this.current.value !== this.target.value;
        },
        /**
         * Returns whether the spring is at the target value
         * @function
         * @returns {Boolean} True if at target value, false otherwise
         */
        isAtTargetValue: function() {
          return this.current.value === this.target.value;
        }
      };
      function t(i, n) {
        return (1 - Math.exp(i * -n)) / (1 - Math.exp(-i));
      }
    }(r), function(e) {
      e.ImageJob = function(i) {
        e.extend(!0, this, {
          timeout: e.DEFAULT_SETTINGS.timeout,
          jobId: null,
          tries: 0
        }, i), this.data = null, this.userData = {}, this.errorMsg = null;
      }, e.ImageJob.prototype = {
        /**
         * Starts the image job.
         * @method
         * @memberof OpenSeadragon.ImageJob#
         */
        start: function() {
          this.tries++;
          var i = this, n = this.abort;
          this.jobId = window.setTimeout(function() {
            i.finish(null, null, "Image load exceeded timeout (" + i.timeout + " ms)");
          }, this.timeout), this.abort = function() {
            i.source.downloadTileAbort(i), typeof n == "function" && n();
          }, this.source.downloadTileStart(this);
        },
        /**
         * Finish this job.
         * @param {*} data data that has been downloaded
         * @param {XMLHttpRequest} request reference to the request if used
         * @param {string} errorMessage description upon failure
         * @memberof OpenSeadragon.ImageJob#
         */
        finish: function(i, n, o) {
          this.data = i, this.request = n, this.errorMsg = o, this.jobId && window.clearTimeout(this.jobId), this.callback(this);
        }
      }, e.ImageLoader = function(i) {
        e.extend(!0, this, {
          jobLimit: e.DEFAULT_SETTINGS.imageLoaderLimit,
          timeout: e.DEFAULT_SETTINGS.timeout,
          jobQueue: [],
          failedTiles: [],
          jobsInProgress: 0
        }, i);
      }, e.ImageLoader.prototype = {
        /**
         * Add an unloaded image to the loader queue.
         * @method
         * @param {Object} options - Options for this job.
         * @param {String} [options.src] - URL of image to download.
         * @param {Tile} [options.tile] - Tile that belongs the data to. The tile instance
         *      is not internally used and serves for custom TileSources implementations.
         * @param {TileSource} [options.source] - Image loading strategy
         * @param {String} [options.loadWithAjax] - Whether to load this image with AJAX.
         * @param {String} [options.ajaxHeaders] - Headers to add to the image request if using AJAX.
         * @param {String|Boolean} [options.crossOriginPolicy] - CORS policy to use for downloads
         * @param {String} [options.postData] - POST parameters (usually but not necessarily in k=v&k2=v2... form,
         *      see TileSource::getPostData) or null
         * @param {Boolean} [options.ajaxWithCredentials] - Whether to set withCredentials on AJAX
         *      requests.
         * @param {Function} [options.callback] - Called once image has been downloaded.
         * @param {Function} [options.abort] - Called when this image job is aborted.
         */
        addJob: function(i) {
          if (!i.source) {
            e.console.error("ImageLoader.prototype.addJob() requires [options.source]. TileSource since new API defines how images are fetched. Creating a dummy TileSource.");
            var n = e.TileSource.prototype;
            i.source = {
              downloadTileStart: n.downloadTileStart,
              downloadTileAbort: n.downloadTileAbort
            };
          }
          var o = this, a = function(d) {
            t(o, d, i.callback);
          }, l = {
            src: i.src,
            tile: i.tile || {},
            source: i.source,
            loadWithAjax: i.loadWithAjax,
            ajaxHeaders: i.loadWithAjax ? i.ajaxHeaders : null,
            crossOriginPolicy: i.crossOriginPolicy,
            ajaxWithCredentials: i.ajaxWithCredentials,
            postData: i.postData,
            callback: a,
            abort: i.abort,
            timeout: this.timeout
          }, h = new e.ImageJob(l);
          !this.jobLimit || this.jobsInProgress < this.jobLimit ? (h.start(), this.jobsInProgress++) : this.jobQueue.push(h);
        },
        /**
         * Clear any unstarted image loading jobs from the queue.
         * @method
         */
        clear: function() {
          for (var i = 0; i < this.jobQueue.length; i++) {
            var n = this.jobQueue[i];
            typeof n.abort == "function" && n.abort();
          }
          this.jobQueue = [];
        }
      };
      function t(i, n, o) {
        n.errorMsg !== "" && (n.data === null || n.data === void 0) && n.tries < 1 + i.tileRetryMax && i.failedTiles.push(n);
        var a;
        i.jobsInProgress--, (!i.jobLimit || i.jobsInProgress < i.jobLimit) && i.jobQueue.length > 0 && (a = i.jobQueue.shift(), a.start(), i.jobsInProgress++), i.tileRetryMax > 0 && i.jobQueue.length === 0 && (!i.jobLimit || i.jobsInProgress < i.jobLimit) && i.failedTiles.length > 0 && (a = i.failedTiles.shift(), setTimeout(function() {
          a.start();
        }, i.tileRetryDelay), i.jobsInProgress++), o(n.data, n.errorMsg, n.request);
      }
    }(r), function(e) {
      e.Tile = function(t, i, n, o, a, l, h, d, f, g, w, C) {
        this.level = t, this.x = i, this.y = n, this.bounds = o, this.positionedBounds = new r.Rect(o.x, o.y, o.width, o.height), this.sourceBounds = g, this.exists = a, this._url = l, this.postData = w, this.context2D = h, this.loadWithAjax = d, this.ajaxHeaders = f, C === void 0 && (e.console.warn("Tile constructor needs 'cacheKey' variable: creation tile cache in Tile class is deprecated. TileSource.prototype.getTileHashKey will be used."), C = e.TileSource.prototype.getTileHashKey(t, i, n, l, f, w)), this.cacheKey = C, this.loaded = !1, this.loading = !1, this.element = null, this.imgElement = null, this.style = null, this.position = null, this.size = null, this.flipped = !1, this.blendStart = null, this.opacity = null, this.squaredDistance = null, this.visibility = null, this.hasTransparency = !1, this.beingDrawn = !1, this.lastTouchTime = 0, this.isRightMost = !1, this.isBottomMost = !1;
      }, e.Tile.prototype = {
        /**
         * Provides a string representation of this tiles level and (x,y)
         * components.
         * @function
         * @returns {String}
         */
        toString: function() {
          return this.level + "/" + this.x + "_" + this.y;
        },
        // private
        _hasTransparencyChannel: function() {
          return console.warn("Tile.prototype._hasTransparencyChannel() has been deprecated and will be removed in the future. Use TileSource.prototype.hasTransparency() instead."), !!this.context2D || this.getUrl().match(".png");
        },
        /**
         * The Image object for this tile.
         * @member {Object} image
         * @memberof OpenSeadragon.Tile#
         * @deprecated
         * @returns {Image}
         */
        get image() {
          return e.console.error("[Tile.image] property has been deprecated. Use [Tile.prototype.getImage] instead."), this.getImage();
        },
        /**
         * The URL of this tile's image.
         * @member {String} url
         * @memberof OpenSeadragon.Tile#
         * @deprecated
         * @returns {String}
         */
        get url() {
          return e.console.error("[Tile.url] property has been deprecated. Use [Tile.prototype.getUrl] instead."), this.getUrl();
        },
        /**
         * Get the Image object for this tile.
         * @returns {Image}
         */
        getImage: function() {
          return this.cacheImageRecord.getImage();
        },
        /**
         * Get the url string for this tile.
         * @returns {String}
         */
        getUrl: function() {
          return typeof this._url == "function" ? this._url() : this._url;
        },
        /**
         * Get the CanvasRenderingContext2D instance for tile image data drawn
         * onto Canvas if enabled and available
         * @returns {CanvasRenderingContext2D}
         */
        getCanvasContext: function() {
          return this.context2D || this.cacheImageRecord && this.cacheImageRecord.getRenderedContext();
        },
        /**
         * Get the ratio between current and original size.
         * @function
         * @returns {Float}
         */
        getScaleForEdgeSmoothing: function() {
          var t;
          if (this.cacheImageRecord)
            t = this.cacheImageRecord.getRenderedContext();
          else if (this.context2D)
            t = this.context2D;
          else
            return e.console.warn(
              "[Tile.drawCanvas] attempting to get tile scale %s when tile's not cached",
              this.toString()
            ), 1;
          return t.canvas.width / (this.size.x * e.pixelDensityRatio);
        },
        /**
         * Get a translation vector that when applied to the tile position produces integer coordinates.
         * Needed to avoid swimming and twitching.
         * @function
         * @param {Number} [scale=1] - Scale to be applied to position.
         * @returns {OpenSeadragon.Point}
         */
        getTranslationForEdgeSmoothing: function(t, i, n) {
          var o = Math.max(1, Math.ceil((n.x - i.x) / 2)), a = Math.max(1, Math.ceil((n.y - i.y) / 2));
          return new e.Point(o, a).minus(
            this.position.times(e.pixelDensityRatio).times(t || 1).apply(function(l) {
              return l % 1;
            })
          );
        },
        /**
         * Removes tile from its container.
         * @function
         */
        unload: function() {
          this.imgElement && this.imgElement.parentNode && this.imgElement.parentNode.removeChild(this.imgElement), this.element && this.element.parentNode && this.element.parentNode.removeChild(this.element), this.element = null, this.imgElement = null, this.loaded = !1, this.loading = !1;
        }
      };
    }(r), function(e) {
      e.OverlayPlacement = e.Placement, e.OverlayRotationMode = e.freezeObject({
        NO_ROTATION: 1,
        EXACT: 2,
        BOUNDING_BOX: 3
      }), e.Overlay = function(t, i, n) {
        var o;
        e.isPlainObject(t) ? o = t : o = {
          element: t,
          location: i,
          placement: n
        }, this.elementWrapper = document.createElement("div"), this.element = o.element, this.elementWrapper.appendChild(this.element), this.element.id ? this.elementWrapper.id = "overlay-wrapper-" + this.element.id : this.elementWrapper.id = "overlay-wrapper", this.style = this.elementWrapper.style, this._init(o);
      }, e.Overlay.prototype = {
        // private
        _init: function(t) {
          this.location = t.location, this.placement = t.placement === void 0 ? e.Placement.TOP_LEFT : t.placement, this.onDraw = t.onDraw, this.checkResize = t.checkResize === void 0 ? !0 : t.checkResize, this.width = t.width === void 0 ? null : t.width, this.height = t.height === void 0 ? null : t.height, this.rotationMode = t.rotationMode || e.OverlayRotationMode.EXACT, this.location instanceof e.Rect && (this.width = this.location.width, this.height = this.location.height, this.location = this.location.getTopLeft(), this.placement = e.Placement.TOP_LEFT), this.scales = this.width !== null && this.height !== null, this.bounds = new e.Rect(
            this.location.x,
            this.location.y,
            this.width,
            this.height
          ), this.position = this.location;
        },
        /**
         * Internal function to adjust the position of an overlay
         * depending on it size and placement.
         * @function
         * @param {OpenSeadragon.Point} position
         * @param {OpenSeadragon.Point} size
         */
        adjust: function(t, i) {
          var n = e.Placement.properties[this.placement];
          n && (n.isHorizontallyCentered ? t.x -= i.x / 2 : n.isRight && (t.x -= i.x), n.isVerticallyCentered ? t.y -= i.y / 2 : n.isBottom && (t.y -= i.y));
        },
        /**
         * @function
         */
        destroy: function() {
          var t = this.elementWrapper, i = this.style;
          t.parentNode && (t.parentNode.removeChild(t), t.prevElementParent && (i.display = "none", document.body.appendChild(t))), this.onDraw = null, i.top = "", i.left = "", i.position = "", this.width !== null && (i.width = ""), this.height !== null && (i.height = "");
          var n = e.getCssPropertyWithVendorPrefix(
            "transformOrigin"
          ), o = e.getCssPropertyWithVendorPrefix(
            "transform"
          );
          n && o && (i[n] = "", i[o] = "");
        },
        /**
         * @function
         * @param {Element} container
         */
        drawHTML: function(t, i) {
          var n = this.elementWrapper;
          n.parentNode !== t && (n.prevElementParent = n.parentNode, n.prevNextSibling = n.nextSibling, t.appendChild(n), this.style.position = "absolute", this.size = e.getElementSize(this.elementWrapper));
          var o = this._getOverlayPositionAndSize(i), a = o.position, l = this.size = o.size, h = "";
          i.overlayPreserveContentDirection && (h = i.flipped ? " scaleX(-1)" : " scaleX(1)");
          var d = i.flipped ? -o.rotate : o.rotate, f = i.flipped ? " scaleX(-1)" : "";
          if (this.onDraw)
            this.onDraw(a, l, this.element);
          else {
            var g = this.style, w = this.element.style;
            w.display = "block", g.left = a.x + "px", g.top = a.y + "px", this.width !== null && (w.width = l.x + "px"), this.height !== null && (w.height = l.y + "px");
            var C = e.getCssPropertyWithVendorPrefix(
              "transformOrigin"
            ), E = e.getCssPropertyWithVendorPrefix(
              "transform"
            );
            C && E && (d && !i.flipped ? (w[E] = "", g[C] = this._getTransformOrigin(), g[E] = "rotate(" + d + "deg)") : !d && i.flipped ? (w[E] = h, g[C] = this._getTransformOrigin(), g[E] = f) : d && i.flipped ? (w[E] = h, g[C] = this._getTransformOrigin(), g[E] = "rotate(" + d + "deg)" + f) : (w[E] = "", g[C] = "", g[E] = "")), g.display = "flex";
          }
        },
        // private
        _getOverlayPositionAndSize: function(t) {
          var i = t.pixelFromPoint(this.location, !0), n = this._getSizeInPixels(t);
          this.adjust(i, n);
          var o = 0;
          if (t.getRotation(!0) && this.rotationMode !== e.OverlayRotationMode.NO_ROTATION)
            if (this.rotationMode === e.OverlayRotationMode.BOUNDING_BOX && this.width !== null && this.height !== null) {
              var a = new e.Rect(i.x, i.y, n.x, n.y), l = this._getBoundingBox(a, t.getRotation(!0));
              i = l.getTopLeft(), n = l.getSize();
            } else
              o = t.getRotation(!0);
          return t.flipped && (i.x = t.getContainerSize().x - i.x), {
            position: i,
            size: n,
            rotate: o
          };
        },
        // private
        _getSizeInPixels: function(t) {
          var i = this.size.x, n = this.size.y;
          if (this.width !== null || this.height !== null) {
            var o = t.deltaPixelsFromPointsNoRotate(
              new e.Point(this.width || 0, this.height || 0),
              !0
            );
            this.width !== null && (i = o.x), this.height !== null && (n = o.y);
          }
          if (this.checkResize && (this.width === null || this.height === null)) {
            var a = this.size = e.getElementSize(this.elementWrapper);
            this.width === null && (i = a.x), this.height === null && (n = a.y);
          }
          return new e.Point(i, n);
        },
        // private
        _getBoundingBox: function(t, i) {
          var n = this._getPlacementPoint(t);
          return t.rotate(i, n).getBoundingBox();
        },
        // private
        _getPlacementPoint: function(t) {
          var i = new e.Point(t.x, t.y), n = e.Placement.properties[this.placement];
          return n && (n.isHorizontallyCentered ? i.x += t.width / 2 : n.isRight && (i.x += t.width), n.isVerticallyCentered ? i.y += t.height / 2 : n.isBottom && (i.y += t.height)), i;
        },
        // private
        _getTransformOrigin: function() {
          var t = "", i = e.Placement.properties[this.placement];
          return i && (i.isLeft ? t = "left" : i.isRight && (t = "right"), i.isTop ? t += " top" : i.isBottom && (t += " bottom")), t;
        },
        /**
         * Changes the overlay settings.
         * @function
         * @param {OpenSeadragon.Point|OpenSeadragon.Rect|Object} location
         * If an object is specified, the options are the same than the constructor
         * except for the element which can not be changed.
         * @param {OpenSeadragon.Placement} placement
         */
        update: function(t, i) {
          var n = e.isPlainObject(t) ? t : {
            location: t,
            placement: i
          };
          this._init({
            location: n.location || this.location,
            placement: n.placement !== void 0 ? n.placement : this.placement,
            onDraw: n.onDraw || this.onDraw,
            checkResize: n.checkResize || this.checkResize,
            width: n.width !== void 0 ? n.width : this.width,
            height: n.height !== void 0 ? n.height : this.height,
            rotationMode: n.rotationMode || this.rotationMode
          });
        },
        /**
         * Returns the current bounds of the overlay in viewport coordinates
         * @function
         * @param {OpenSeadragon.Viewport} viewport the viewport
         * @returns {OpenSeadragon.Rect} overlay bounds
         */
        getBounds: function(t) {
          e.console.assert(
            t,
            "A viewport must now be passed to Overlay.getBounds."
          );
          var i = this.width, n = this.height;
          if (i === null || n === null) {
            var o = t.deltaPointsFromPixelsNoRotate(this.size, !0);
            i === null && (i = o.x), n === null && (n = o.y);
          }
          var a = this.location.clone();
          return this.adjust(a, new e.Point(i, n)), this._adjustBoundsForRotation(
            t,
            new e.Rect(a.x, a.y, i, n)
          );
        },
        // private
        _adjustBoundsForRotation: function(t, i) {
          if (!t || t.getRotation(!0) === 0 || this.rotationMode === e.OverlayRotationMode.EXACT)
            return i;
          if (this.rotationMode === e.OverlayRotationMode.BOUNDING_BOX) {
            if (this.width === null || this.height === null)
              return i;
            var n = this._getOverlayPositionAndSize(t);
            return t.viewerElementToViewportRectangle(new e.Rect(
              n.position.x,
              n.position.y,
              n.size.x,
              n.size.y
            ));
          }
          return i.rotate(
            -t.getRotation(!0),
            this._getPlacementPoint(i)
          );
        }
      };
    }(r), function(e) {
      const t = e;
      t.DrawerBase = class {
        constructor(n) {
          e.console.assert(n.viewer, "[Drawer] options.viewer is required"), e.console.assert(n.viewport, "[Drawer] options.viewport is required"), e.console.assert(n.element, "[Drawer] options.element is required"), this.viewer = n.viewer, this.viewport = n.viewport, this.debugGridColor = typeof n.debugGridColor == "string" ? [n.debugGridColor] : n.debugGridColor || e.DEFAULT_SETTINGS.debugGridColor, this.options = n.options || {}, this.container = e.getElement(n.element), this._renderingTarget = this._createDrawingElement(), this.canvas.style.width = "100%", this.canvas.style.height = "100%", this.canvas.style.position = "absolute", this.canvas.style.left = "0", e.setElementOpacity(this.canvas, this.viewer.opacity, !0), e.setElementPointerEventsNone(this.canvas), e.setElementTouchActionNone(this.canvas), this.container.style.textAlign = "left", this.container.appendChild(this.canvas), this._checkForAPIOverrides();
        }
        // protect the canvas member with a getter
        get canvas() {
          return this._renderingTarget;
        }
        get element() {
          return e.console.error("Drawer.element is deprecated. Use Drawer.container instead."), this.container;
        }
        /**
         * @abstract
         * @returns {String | undefined} What type of drawer this is. Must be overridden by extending classes.
         */
        getType() {
          e.console.error("Drawer.getType must be implemented by child class");
        }
        /**
         * @abstract
         * @returns {Boolean} Whether the drawer implementation is supported by the browser. Must be overridden by extending classes.
         */
        static isSupported() {
          e.console.error("Drawer.isSupported must be implemented by child class");
        }
        /**
         * @abstract
         * @returns {Element} the element to draw into
         * @private
         */
        _createDrawingElement() {
          return e.console.error("Drawer._createDrawingElement must be implemented by child class"), null;
        }
        /**
         * @abstract
         * @param {Array} tiledImages - An array of TiledImages that are ready to be drawn.
         * @private
         */
        draw(n) {
          e.console.error("Drawer.draw must be implemented by child class");
        }
        /**
         * @abstract
         * @returns {Boolean} True if rotation is supported.
         */
        canRotate() {
          e.console.error("Drawer.canRotate must be implemented by child class");
        }
        /**
         * @abstract
         */
        destroy() {
          e.console.error("Drawer.destroy must be implemented by child class");
        }
        /**
         * @param {TiledImage} tiledImage the tiled image that is calling the function
         * @returns {Boolean} Whether this drawer requires enforcing minimum tile overlap to avoid showing seams.
         * @private
         */
        minimumOverlapRequired(n) {
          return !1;
        }
        /**
         * @abstract
         * @param {Boolean} [imageSmoothingEnabled] - Whether or not the image is
         * drawn smoothly on the canvas; see imageSmoothingEnabled in
         * {@link OpenSeadragon.Options} for more explanation.
         */
        setImageSmoothingEnabled(n) {
          e.console.error("Drawer.setImageSmoothingEnabled must be implemented by child class");
        }
        /**
         * Optional public API to draw a rectangle (e.g. for debugging purposes)
         * Child classes can override this method if they wish to support this
         * @param {OpenSeadragon.Rect} rect
         */
        drawDebuggingRect(n) {
          e.console.warn("[drawer].drawDebuggingRect is not implemented by this drawer");
        }
        // Deprecated functions
        clear() {
          e.console.warn("[drawer].clear() is deprecated. The drawer is responsible for clearing itself as needed before drawing tiles.");
        }
        // Private functions
        /**
         * Ensures that child classes have provided implementations for public API methods
         * draw, canRotate, destroy, and setImageSmoothinEnabled. Throws an exception if the original
         * placeholder methods are still in place.
         * @private
         *
         */
        _checkForAPIOverrides() {
          if (this._createDrawingElement === e.DrawerBase.prototype._createDrawingElement)
            throw new Error("[drawer]._createDrawingElement must be implemented by child class");
          if (this.draw === e.DrawerBase.prototype.draw)
            throw new Error("[drawer].draw must be implemented by child class");
          if (this.canRotate === e.DrawerBase.prototype.canRotate)
            throw new Error("[drawer].canRotate must be implemented by child class");
          if (this.destroy === e.DrawerBase.prototype.destroy)
            throw new Error("[drawer].destroy must be implemented by child class");
          if (this.setImageSmoothingEnabled === e.DrawerBase.prototype.setImageSmoothingEnabled)
            throw new Error("[drawer].setImageSmoothingEnabled must be implemented by child class");
        }
        // Utility functions
        /**
         * Scale from OpenSeadragon viewer rectangle to drawer rectangle
         * (ignoring rotation)
         * @param {OpenSeadragon.Rect} rectangle - The rectangle in viewport coordinate system.
         * @returns {OpenSeadragon.Rect} Rectangle in drawer coordinate system.
         */
        viewportToDrawerRectangle(n) {
          var o = this.viewport.pixelFromPointNoRotate(n.getTopLeft(), !0), a = this.viewport.deltaPixelsFromPointsNoRotate(n.getSize(), !0);
          return new e.Rect(
            o.x * e.pixelDensityRatio,
            o.y * e.pixelDensityRatio,
            a.x * e.pixelDensityRatio,
            a.y * e.pixelDensityRatio
          );
        }
        /**
         * This function converts the given point from to the drawer coordinate by
         * multiplying it with the pixel density.
         * This function does not take rotation into account, thus assuming provided
         * point is at 0 degree.
         * @param {OpenSeadragon.Point} point - the pixel point to convert
         * @returns {OpenSeadragon.Point} Point in drawer coordinate system.
         */
        viewportCoordToDrawerCoord(n) {
          var o = this.viewport.pixelFromPointNoRotate(n, !0);
          return new e.Point(
            o.x * e.pixelDensityRatio,
            o.y * e.pixelDensityRatio
          );
        }
        // Internal utility functions
        /**
         * Calculate width and height of the canvas based on viewport dimensions
         * and pixelDensityRatio
         * @private
         * @returns {OpenSeadragon.Point} {x, y} size of the canvas
         */
        _calculateCanvasSize() {
          var n = e.pixelDensityRatio, o = this.viewport.getContainerSize();
          return new t.Point(Math.round(o.x * n), Math.round(o.y * n));
        }
        /**
         * Called by implementations to fire the tiled-image-drawn event (used by tests)
         * @private
         */
        _raiseTiledImageDrawnEvent(n, o) {
          this.viewer && this.viewer.raiseEvent("tiled-image-drawn", {
            tiledImage: n,
            tiles: o
          });
        }
        /**
         * Called by implementations to fire the drawer-error event
         * @private
         */
        _raiseDrawerErrorEvent(n, o) {
          this.viewer && this.viewer.raiseEvent("drawer-error", {
            tiledImage: n,
            drawer: this,
            error: o
          });
        }
      };
    }(r), function(e) {
      const t = e;
      class i extends t.DrawerBase {
        constructor(o) {
          super(o), this.viewer.rejectEventHandler("tile-drawing", "The HTMLDrawer does not raise the tile-drawing event"), this.viewer.allowEventHandler("tile-drawn");
        }
        /**
         * @returns {Boolean} always true
         */
        static isSupported() {
          return !0;
        }
        /**
         *
         * @returns 'html'
         */
        getType() {
          return "html";
        }
        /**
         * @param {TiledImage} tiledImage the tiled image that is calling the function
         * @returns {Boolean} Whether this drawer requires enforcing minimum tile overlap to avoid showing seams.
         * @private
         */
        minimumOverlapRequired(o) {
          return !0;
        }
        /**
         * create the HTML element (e.g. canvas, div) that the image will be drawn into
         * @returns {Element} the div to draw into
         */
        _createDrawingElement() {
          return e.makeNeutralElement("div");
        }
        /**
         * Draws the TiledImages
         */
        draw(o) {
          var a = this;
          this._prepareNewFrame(), o.forEach(function(l) {
            l.opacity !== 0 && a._drawTiles(l);
          });
        }
        /**
         * @returns {Boolean} False - rotation is not supported.
         */
        canRotate() {
          return !1;
        }
        /**
         * Destroy the drawer (unload current loaded tiles)
         */
        destroy() {
          this.container.removeChild(this.canvas);
        }
        /**
         * This function is ignored by the HTML Drawer. Implementing it is required by DrawerBase.
         * @param {Boolean} [imageSmoothingEnabled] - Whether or not the image is
         * drawn smoothly on the canvas; see imageSmoothingEnabled in
         * {@link OpenSeadragon.Options} for more explanation.
         */
        setImageSmoothingEnabled() {
        }
        /**
         * Clears the Drawer so it's ready to draw another frame.
         * @private
         *
         */
        _prepareNewFrame() {
          this.canvas.innerHTML = "";
        }
        /**
         * Draws a TiledImage.
         * @private
         *
         */
        _drawTiles(o) {
          var a = o.getTilesToDraw().map((d) => d.tile);
          if (!(o.opacity === 0 || a.length === 0 && !o.placeholderFillStyle))
            for (var l = a.length - 1; l >= 0; l--) {
              var h = a[l];
              this._drawTile(h), this.viewer && this.viewer.raiseEvent("tile-drawn", {
                tiledImage: o,
                tile: h
              });
            }
        }
        /**
         * Draws the given tile.
         * @private
         * @param {OpenSeadragon.Tile} tile - The tile to draw.
         * @param {Function} drawingHandler - Method for firing the drawing event if using canvas.
         * drawingHandler({context, tile, rendered})
         */
        _drawTile(o) {
          e.console.assert(o, "[Drawer._drawTile] tile is required");
          let a = this.canvas;
          if (!o.cacheImageRecord) {
            e.console.warn(
              "[Drawer._drawTileToHTML] attempting to draw tile %s when it's not cached",
              o.toString()
            );
            return;
          }
          if (!o.loaded) {
            e.console.warn(
              "Attempting to draw tile %s when it's not yet loaded.",
              o.toString()
            );
            return;
          }
          if (!o.element) {
            var l = o.getImage();
            if (!l)
              return;
            o.element = e.makeNeutralElement("div"), o.imgElement = l.cloneNode(), o.imgElement.style.msInterpolationMode = "nearest-neighbor", o.imgElement.style.width = "100%", o.imgElement.style.height = "100%", o.style = o.element.style, o.style.position = "absolute";
          }
          o.element.parentNode !== a && a.appendChild(o.element), o.imgElement.parentNode !== o.element && o.element.appendChild(o.imgElement), o.style.top = o.position.y + "px", o.style.left = o.position.x + "px", o.style.height = o.size.y + "px", o.style.width = o.size.x + "px", o.flipped && (o.style.transform = "scaleX(-1)"), e.setElementOpacity(o.element, o.opacity);
        }
      }
      e.HTMLDrawer = i;
    }(r), function(e) {
      const t = e;
      class i extends t.DrawerBase {
        constructor(d) {
          super(d), this.context = this.canvas.getContext("2d"), this.sketchCanvas = null, this.sketchContext = null, this._imageSmoothingEnabled = !0, this.viewer.allowEventHandler("tile-drawn"), this.viewer.allowEventHandler("tile-drawing");
        }
        /**
         * @returns {Boolean} true if canvas is supported by the browser, otherwise false
         */
        static isSupported() {
          return e.supportsCanvas;
        }
        getType() {
          return "canvas";
        }
        /**
         * create the HTML element (e.g. canvas, div) that the image will be drawn into
         * @returns {Element} the canvas to draw into
         */
        _createDrawingElement() {
          let d = e.makeNeutralElement("canvas"), f = this._calculateCanvasSize();
          return d.width = f.x, d.height = f.y, d;
        }
        /**
         * Draws the TiledImages
         */
        draw(d) {
          this._prepareNewFrame(), this.viewer.viewport.getFlip() !== this._viewportFlipped && this._flip();
          for (const f of d)
            f.opacity !== 0 && this._drawTiles(f);
        }
        /**
         * @returns {Boolean} True - rotation is supported.
         */
        canRotate() {
          return !0;
        }
        /**
         * Destroy the drawer (unload current loaded tiles)
         */
        destroy() {
          this.canvas.width = 1, this.canvas.height = 1, this.sketchCanvas = null, this.sketchContext = null, this.container.removeChild(this.canvas);
        }
        /**
         * @param {TiledImage} tiledImage the tiled image that is calling the function
         * @returns {Boolean} Whether this drawer requires enforcing minimum tile overlap to avoid showing seams.
         * @private
         */
        minimumOverlapRequired(d) {
          return !0;
        }
        /**
         * Turns image smoothing on or off for this viewer. Note: Ignored in some (especially older) browsers that do not support this property.
         *
         * @function
         * @param {Boolean} [imageSmoothingEnabled] - Whether or not the image is
         * drawn smoothly on the canvas; see imageSmoothingEnabled in
         * {@link OpenSeadragon.Options} for more explanation.
         */
        setImageSmoothingEnabled(d) {
          this._imageSmoothingEnabled = !!d, this._updateImageSmoothingEnabled(this.context), this.viewer.forceRedraw();
        }
        /**
         * Draw a rectangle onto the canvas
         * @param {OpenSeadragon.Rect} rect
         */
        drawDebuggingRect(d) {
          var f = this.context;
          f.save(), f.lineWidth = 2 * e.pixelDensityRatio, f.strokeStyle = this.debugGridColor[0], f.fillStyle = this.debugGridColor[0], f.strokeRect(
            d.x * e.pixelDensityRatio,
            d.y * e.pixelDensityRatio,
            d.width * e.pixelDensityRatio,
            d.height * e.pixelDensityRatio
          ), f.restore();
        }
        /**
         * Test whether the current context is flipped or not
         * @private
         */
        get _viewportFlipped() {
          return this.context.getTransform().a < 0;
        }
        /**
         * Fires the tile-drawing event.
         * @private
         */
        _raiseTileDrawingEvent(d, f, g, w) {
          this.viewer.raiseEvent("tile-drawing", {
            tiledImage: d,
            context: f,
            tile: g,
            rendered: w
          });
        }
        /**
         * Clears the Drawer so it's ready to draw another frame.
         * @private
         *
         */
        _prepareNewFrame() {
          var d = this._calculateCanvasSize();
          if ((this.canvas.width !== d.x || this.canvas.height !== d.y) && (this.canvas.width = d.x, this.canvas.height = d.y, this._updateImageSmoothingEnabled(this.context), this.sketchCanvas !== null)) {
            var f = this._calculateSketchCanvasSize();
            this.sketchCanvas.width = f.x, this.sketchCanvas.height = f.y, this._updateImageSmoothingEnabled(this.sketchContext);
          }
          this._clear();
        }
        /**
         * @private
         * @param {Boolean} useSketch Whether to clear sketch canvas or main canvas
         * @param {OpenSeadragon.Rect} [bounds] The rectangle to clear
         */
        _clear(d, f) {
          var g = this._getContext(d);
          if (f)
            g.clearRect(f.x, f.y, f.width, f.height);
          else {
            var w = g.canvas;
            g.clearRect(0, 0, w.width, w.height);
          }
        }
        /**
         * Draws a TiledImage.
         * @private
         *
         */
        _drawTiles(d) {
          var f = d.getTilesToDraw().map((ve) => ve.tile);
          if (!(d.opacity === 0 || f.length === 0 && !d.placeholderFillStyle)) {
            var g = f[0], w;
            g && (w = d.opacity < 1 || d.compositeOperation && d.compositeOperation !== "source-over" || !d._isBottomItem() && d.source.hasTransparency(g.context2D, g.getUrl(), g.ajaxHeaders, g.postData));
            var C, E, A = this.viewport.getZoom(!0), I = d.viewportToImageZoom(A);
            f.length > 1 && I > d.smoothTileEdgesMinZoom && !d.iOSDevice && d.getRotation(!0) % 360 === 0 && (w = !0, C = g.getScaleForEdgeSmoothing(), E = g.getTranslationForEdgeSmoothing(
              C,
              this._getCanvasSize(!1),
              this._getCanvasSize(!0)
            ));
            var V;
            w && (C || (V = this.viewport.viewportToViewerElementRectangle(
              d.getClippedBounds(!0)
            ).getIntegerBoundingBox(), V = V.times(e.pixelDensityRatio)), this._clear(!0, V)), C || this._setRotations(d, w);
            var K = !1;
            if (d._clip) {
              this._saveContext(w);
              var ce = d.imageToViewportRectangle(d._clip, !0);
              ce = ce.rotate(-d.getRotation(!0), d._getRotationPoint(!0));
              var re = this.viewportToDrawerRectangle(ce);
              C && (re = re.times(C)), E && (re = re.translate(E)), this._setClip(re, w), K = !0;
            }
            if (d._croppingPolygons) {
              var he = this;
              K || this._saveContext(w);
              try {
                var pe = d._croppingPolygons.map(function(ve) {
                  return ve.map(function(Re) {
                    var Ze = d.imageToViewportCoordinates(Re.x, Re.y, !0).rotate(-d.getRotation(!0), d._getRotationPoint(!0)), Ue = he.viewportCoordToDrawerCoord(Ze);
                    return C && (Ue = Ue.times(C)), E && (Ue = Ue.plus(E)), Ue;
                  });
                });
                this._clipWithPolygons(pe, w);
              } catch (ve) {
                e.console.error(ve);
              }
              K = !0;
            }
            if (d._hasOpaqueTile = !1, d.placeholderFillStyle && d._hasOpaqueTile === !1) {
              let ve = this.viewportToDrawerRectangle(d.getBoundsNoRotate(!0));
              C && (ve = ve.times(C)), E && (ve = ve.translate(E));
              let Re = null;
              typeof d.placeholderFillStyle == "function" ? Re = d.placeholderFillStyle(d, this.context) : Re = d.placeholderFillStyle, this._drawRectangle(ve, Re, w);
            }
            var Te = l(d.subPixelRoundingForTransparency), Ae = !1;
            if (Te === e.SUBPIXEL_ROUNDING_OCCURRENCES.ALWAYS)
              Ae = !0;
            else if (Te === e.SUBPIXEL_ROUNDING_OCCURRENCES.ONLY_AT_REST) {
              var He = this.viewer && this.viewer.isAnimating();
              Ae = !He;
            }
            for (var Fe = 0; Fe < f.length; Fe++)
              g = f[Fe], this._drawTile(
                g,
                d,
                w,
                C,
                E,
                Ae,
                d.source
              ), this.viewer && this.viewer.raiseEvent("tile-drawn", {
                tiledImage: d,
                tile: g
              });
            K && this._restoreContext(w), C || (d.getRotation(!0) % 360 !== 0 && this._restoreRotationChanges(w), this.viewport.getRotation(!0) % 360 !== 0 && this._restoreRotationChanges(w)), w && (C && this._setRotations(d), this.blendSketch({
              opacity: d.opacity,
              scale: C,
              translate: E,
              compositeOperation: d.compositeOperation,
              bounds: V
            }), C && (d.getRotation(!0) % 360 !== 0 && this._restoreRotationChanges(!1), this.viewport.getRotation(!0) % 360 !== 0 && this._restoreRotationChanges(!1))), this._drawDebugInfo(d, f), this._raiseTiledImageDrawnEvent(d, f);
          }
        }
        /**
         * Draws special debug information for a TiledImage if in debug mode.
         * @private
         * @param {OpenSeadragon.Tile[]} lastDrawn - An unordered list of Tiles drawn last frame.
         */
        _drawDebugInfo(d, f) {
          if (d.debugMode)
            for (var g = f.length - 1; g >= 0; g--) {
              var w = f[g];
              try {
                this._drawDebugInfoOnTile(w, f.length, g, d);
              } catch (C) {
                e.console.error(C);
              }
            }
        }
        /**
         * This function will create multiple polygon paths on the drawing context by provided polygons,
         * then clip the context to the paths.
         * @private
         * @param {OpenSeadragon.Point[][]} polygons - an array of polygons. A polygon is an array of OpenSeadragon.Point
         * @param {Boolean} useSketch - Whether to use the sketch canvas or not.
         */
        _clipWithPolygons(d, f) {
          var g = this._getContext(f);
          g.beginPath();
          for (const w of d)
            for (const [C, E] of w.entries())
              g[C === 0 ? "moveTo" : "lineTo"](E.x, E.y);
          g.clip();
        }
        /**
         * Draws the given tile.
         * @private
         * @param {OpenSeadragon.Tile} tile - The tile to draw.
         * @param {OpenSeadragon.TiledImage} tiledImage - The tiled image being drawn.
         * @param {Boolean} useSketch - Whether to use the sketch canvas or not.
         * where <code>rendered</code> is the context with the pre-drawn image.
         * @param {Float} [scale=1] - Apply a scale to tile position and size. Defaults to 1.
         * @param {OpenSeadragon.Point} [translate] A translation vector to offset tile position
         * @param {Boolean} [shouldRoundPositionAndSize] - Tells whether to round
         * position and size of tiles supporting alpha channel in non-transparency
         * context.
         * @param {OpenSeadragon.TileSource} source - The source specification of the tile.
         */
        _drawTile(d, f, g, w, C, E, A) {
          e.console.assert(d, "[Drawer._drawTile] tile is required"), e.console.assert(f, "[Drawer._drawTile] drawingHandler is required");
          var I = this._getContext(g);
          w = w || 1, this._drawTileToCanvas(d, I, f, w, C, E, A);
        }
        /**
         * Renders the tile in a canvas-based context.
         * @private
         * @function
         * @param {OpenSeadragon.Tile} tile - the tile to draw to the canvas
         * @param {Canvas} context
         * @param {OpenSeadragon.TiledImage} tiledImage - Method for firing the drawing event.
         * drawingHandler({context, tile, rendered})
         * where <code>rendered</code> is the context with the pre-drawn image.
         * @param {Number} [scale=1] - Apply a scale to position and size
         * @param {OpenSeadragon.Point} [translate] - A translation vector
         * @param {Boolean} [shouldRoundPositionAndSize] - Tells whether to round
         * position and size of tiles supporting alpha channel in non-transparency
         * context.
         * @param {OpenSeadragon.TileSource} source - The source specification of the tile.
         */
        _drawTileToCanvas(d, f, g, w, C, E, A) {
          var I = d.position.times(e.pixelDensityRatio), V = d.size.times(e.pixelDensityRatio), K;
          if (!d.context2D && !d.cacheImageRecord) {
            e.console.warn(
              "[Drawer._drawTileToCanvas] attempting to draw tile %s when it's not cached",
              d.toString()
            );
            return;
          }
          if (K = d.getCanvasContext(), !d.loaded || !K) {
            e.console.warn(
              "Attempting to draw tile %s when it's not yet loaded.",
              d.toString()
            );
            return;
          }
          f.save(), typeof w == "number" && w !== 1 && (I = I.times(w), V = V.times(w)), C instanceof e.Point && (I = I.plus(C)), f.globalAlpha === 1 && d.hasTransparency && (E && (I.x = Math.round(I.x), I.y = Math.round(I.y), V.x = Math.round(V.x), V.y = Math.round(V.y)), f.clearRect(
            I.x,
            I.y,
            V.x,
            V.y
          )), this._raiseTileDrawingEvent(g, f, d, K);
          var ce, re;
          d.sourceBounds ? (ce = Math.min(d.sourceBounds.width, K.canvas.width), re = Math.min(d.sourceBounds.height, K.canvas.height)) : (ce = K.canvas.width, re = K.canvas.height), f.translate(I.x + V.x / 2, 0), d.flipped && f.scale(-1, 1), f.drawImage(
            K.canvas,
            0,
            0,
            ce,
            re,
            -V.x / 2,
            I.y,
            V.x,
            V.y
          ), f.restore();
        }
        /**
         * Get the context of the main or sketch canvas
         * @private
         * @param {Boolean} useSketch
         * @returns {CanvasRenderingContext2D}
         */
        _getContext(d) {
          var f = this.context;
          if (d) {
            if (this.sketchCanvas === null) {
              this.sketchCanvas = document.createElement("canvas");
              var g = this._calculateSketchCanvasSize();
              if (this.sketchCanvas.width = g.x, this.sketchCanvas.height = g.y, this.sketchContext = this.sketchCanvas.getContext("2d"), this.viewport.getRotation() === 0) {
                var w = this;
                this.viewer.addHandler("rotate", function C() {
                  if (w.viewport.getRotation() !== 0) {
                    w.viewer.removeHandler("rotate", C);
                    var E = w._calculateSketchCanvasSize();
                    w.sketchCanvas.width = E.x, w.sketchCanvas.height = E.y;
                  }
                });
              }
              this._updateImageSmoothingEnabled(this.sketchContext);
            }
            f = this.sketchContext;
          }
          return f;
        }
        /**
         * Save the context of the main or sketch canvas
         * @private
         * @param {Boolean} useSketch
         */
        _saveContext(d) {
          this._getContext(d).save();
        }
        /**
         * Restore the context of the main or sketch canvas
         * @private
         * @param {Boolean} useSketch
         */
        _restoreContext(d) {
          this._getContext(d).restore();
        }
        // private
        _setClip(d, f) {
          var g = this._getContext(f);
          g.beginPath(), g.rect(d.x, d.y, d.width, d.height), g.clip();
        }
        // private
        // used to draw a placeholder rectangle
        _drawRectangle(d, f, g) {
          var w = this._getContext(g);
          w.save(), w.fillStyle = f, w.fillRect(d.x, d.y, d.width, d.height), w.restore();
        }
        /**
         * Blends the sketch canvas in the main canvas.
         * @param {Object} options The options
         * @param {Float} options.opacity The opacity of the blending.
         * @param {Float} [options.scale=1] The scale at which tiles were drawn on
         * the sketch. Default is 1.
         * Use scale to draw at a lower scale and then enlarge onto the main canvas.
         * @param {OpenSeadragon.Point} [options.translate] A translation vector
         * that was used to draw the tiles
         * @param {String} [options.compositeOperation] - How the image is
         * composited onto other images; see compositeOperation in
         * {@link OpenSeadragon.Options} for possible values.
         * @param {OpenSeadragon.Rect} [options.bounds] The part of the sketch
         * canvas to blend in the main canvas. If specified, options.scale and
         * options.translate get ignored.
         */
        blendSketch(d, f, g, w) {
          var C = d;
          e.isPlainObject(C) || (C = {
            opacity: d,
            scale: f,
            translate: g,
            compositeOperation: w
          }), d = C.opacity, w = C.compositeOperation;
          var E = C.bounds;
          if (this.context.save(), this.context.globalAlpha = d, w && (this.context.globalCompositeOperation = w), E)
            E.x < 0 && (E.width += E.x, E.x = 0), E.x + E.width > this.canvas.width && (E.width = this.canvas.width - E.x), E.y < 0 && (E.height += E.y, E.y = 0), E.y + E.height > this.canvas.height && (E.height = this.canvas.height - E.y), this.context.drawImage(
              this.sketchCanvas,
              E.x,
              E.y,
              E.width,
              E.height,
              E.x,
              E.y,
              E.width,
              E.height
            );
          else {
            f = C.scale || 1, g = C.translate;
            var A = g instanceof e.Point ? g : new e.Point(0, 0), I = 0, V = 0;
            if (g) {
              var K = this.sketchCanvas.width - this.canvas.width, ce = this.sketchCanvas.height - this.canvas.height;
              I = Math.round(K / 2), V = Math.round(ce / 2);
            }
            this.context.drawImage(
              this.sketchCanvas,
              A.x - I * f,
              A.y - V * f,
              (this.canvas.width + 2 * I) * f,
              (this.canvas.height + 2 * V) * f,
              -I,
              -V,
              this.canvas.width + 2 * I,
              this.canvas.height + 2 * V
            );
          }
          this.context.restore();
        }
        // private
        _drawDebugInfoOnTile(d, f, g, w) {
          var C = this.viewer.world.getIndexOfItem(w) % this.debugGridColor.length, E = this.context;
          E.save(), E.lineWidth = 2 * e.pixelDensityRatio, E.font = "small-caps bold " + 13 * e.pixelDensityRatio + "px arial", E.strokeStyle = this.debugGridColor[C], E.fillStyle = this.debugGridColor[C], this._setRotations(w), this._viewportFlipped && this._flip({ point: d.position.plus(d.size.divide(2)) }), E.strokeRect(
            d.position.x * e.pixelDensityRatio,
            d.position.y * e.pixelDensityRatio,
            d.size.x * e.pixelDensityRatio,
            d.size.y * e.pixelDensityRatio
          );
          var A = (d.position.x + d.size.x / 2) * e.pixelDensityRatio, I = (d.position.y + d.size.y / 2) * e.pixelDensityRatio;
          E.translate(A, I);
          const V = this.viewport.getRotation(!0);
          E.rotate(Math.PI / 180 * -V), E.translate(-A, -I), d.x === 0 && d.y === 0 && (E.fillText(
            "Zoom: " + this.viewport.getZoom(),
            d.position.x * e.pixelDensityRatio,
            (d.position.y - 30) * e.pixelDensityRatio
          ), E.fillText(
            "Pan: " + this.viewport.getBounds().toString(),
            d.position.x * e.pixelDensityRatio,
            (d.position.y - 20) * e.pixelDensityRatio
          )), E.fillText(
            "Level: " + d.level,
            (d.position.x + 10) * e.pixelDensityRatio,
            (d.position.y + 20) * e.pixelDensityRatio
          ), E.fillText(
            "Column: " + d.x,
            (d.position.x + 10) * e.pixelDensityRatio,
            (d.position.y + 30) * e.pixelDensityRatio
          ), E.fillText(
            "Row: " + d.y,
            (d.position.x + 10) * e.pixelDensityRatio,
            (d.position.y + 40) * e.pixelDensityRatio
          ), E.fillText(
            "Order: " + g + " of " + f,
            (d.position.x + 10) * e.pixelDensityRatio,
            (d.position.y + 50) * e.pixelDensityRatio
          ), E.fillText(
            "Size: " + d.size.toString(),
            (d.position.x + 10) * e.pixelDensityRatio,
            (d.position.y + 60) * e.pixelDensityRatio
          ), E.fillText(
            "Position: " + d.position.toString(),
            (d.position.x + 10) * e.pixelDensityRatio,
            (d.position.y + 70) * e.pixelDensityRatio
          ), this.viewport.getRotation(!0) % 360 !== 0 && this._restoreRotationChanges(), w.getRotation(!0) % 360 !== 0 && this._restoreRotationChanges(), E.restore();
        }
        // private
        _updateImageSmoothingEnabled(d) {
          d.msImageSmoothingEnabled = this._imageSmoothingEnabled, d.imageSmoothingEnabled = this._imageSmoothingEnabled;
        }
        /**
         * Get the canvas size
         * @private
         * @param {Boolean} sketch If set to true return the size of the sketch canvas
         * @returns {OpenSeadragon.Point} The size of the canvas
         */
        _getCanvasSize(d) {
          var f = this._getContext(d).canvas;
          return new e.Point(f.width, f.height);
        }
        /**
         * Get the canvas center
         * @private
         * @param {Boolean} sketch If set to true return the center point of the sketch canvas
         * @returns {OpenSeadragon.Point} The center point of the canvas
         */
        _getCanvasCenter() {
          return new e.Point(this.canvas.width / 2, this.canvas.height / 2);
        }
        /**
         * Set rotations for viewport & tiledImage
         * @private
         * @param {OpenSeadragon.TiledImage} tiledImage
         * @param {Boolean} [useSketch=false]
         */
        _setRotations(d, f = !1) {
          var g = !1;
          this.viewport.getRotation(!0) % 360 !== 0 && (this._offsetForRotation({
            degrees: this.viewport.getRotation(!0),
            useSketch: f,
            saveContext: g
          }), g = !1), d.getRotation(!0) % 360 !== 0 && this._offsetForRotation({
            degrees: d.getRotation(!0),
            point: this.viewport.pixelFromPointNoRotate(
              d._getRotationPoint(!0),
              !0
            ),
            useSketch: f,
            saveContext: g
          });
        }
        // private
        _offsetForRotation(d) {
          var f = d.point ? d.point.times(e.pixelDensityRatio) : this._getCanvasCenter(), g = this._getContext(d.useSketch);
          g.save(), g.translate(f.x, f.y), g.rotate(Math.PI / 180 * d.degrees), g.translate(-f.x, -f.y);
        }
        // private
        _flip(d) {
          d = d || {};
          var f = d.point ? d.point.times(e.pixelDensityRatio) : this._getCanvasCenter(), g = this._getContext(d.useSketch);
          g.translate(f.x, 0), g.scale(-1, 1), g.translate(-f.x, 0);
        }
        // private
        _restoreRotationChanges(d) {
          var f = this._getContext(d);
          f.restore();
        }
        // private
        _calculateCanvasSize() {
          var d = e.pixelDensityRatio, f = this.viewport.getContainerSize();
          return {
            // canvas width and height are integers
            x: Math.round(f.x * d),
            y: Math.round(f.y * d)
          };
        }
        // private
        _calculateSketchCanvasSize() {
          var d = this._calculateCanvasSize();
          if (this.viewport.getRotation() === 0)
            return d;
          var f = Math.ceil(Math.sqrt(
            d.x * d.x + d.y * d.y
          ));
          return {
            x: f,
            y: f
          };
        }
      }
      e.CanvasDrawer = i;
      var n = e.SUBPIXEL_ROUNDING_OCCURRENCES.NEVER;
      function o(h) {
        return h !== e.SUBPIXEL_ROUNDING_OCCURRENCES.ALWAYS && h !== e.SUBPIXEL_ROUNDING_OCCURRENCES.ONLY_AT_REST && h !== e.SUBPIXEL_ROUNDING_OCCURRENCES.NEVER;
      }
      function a(h) {
        return o(h) ? n : h;
      }
      function l(h) {
        if (typeof h == "number")
          return a(h);
        if (!h || !e.Browser)
          return n;
        var d = h[e.Browser.vendor];
        return o(d) && (d = h["*"]), a(d);
      }
    }(r), function(e) {
      const t = e;
      t.WebGLDrawer = class extends t.DrawerBase {
        constructor(n) {
          super(n), this._destroyed = !1, this._TextureMap = /* @__PURE__ */ new Map(), this._TileMap = /* @__PURE__ */ new Map(), this._gl = null, this._firstPass = null, this._secondPass = null, this._glFrameBuffer = null, this._renderToTexture = null, this._glFramebufferToCanvasTransform = null, this._outputCanvas = null, this._outputContext = null, this._clippingCanvas = null, this._clippingContext = null, this._renderingCanvas = null, this._backupCanvasDrawer = null, this._imageSmoothingEnabled = !0, this._boundToTileReady = (o) => this._tileReadyHandler(o), this._boundToImageUnloaded = (o) => this._imageUnloadedHandler(o), this.viewer.addHandler("tile-ready", this._boundToTileReady), this.viewer.addHandler("image-unloaded", this._boundToImageUnloaded), this.viewer.rejectEventHandler("tile-drawn", "The WebGLDrawer does not raise the tile-drawn event"), this.viewer.rejectEventHandler("tile-drawing", "The WebGLDrawer does not raise the tile-drawing event"), this._setupCanvases(), this._setupRenderer(), this.context = this._outputContext;
        }
        // Public API required by all Drawer implementations
        /**
        * Clean up the renderer, removing all resources
        */
        destroy() {
          if (this._destroyed)
            return;
          let n = this._gl;
          var o = n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS);
          for (let l = 0; l < o; ++l)
            n.activeTexture(n.TEXTURE0 + l), n.bindTexture(n.TEXTURE_2D, null), n.bindTexture(n.TEXTURE_CUBE_MAP, null);
          n.bindBuffer(n.ARRAY_BUFFER, null), n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, null), n.bindRenderbuffer(n.RENDERBUFFER, null), n.bindFramebuffer(n.FRAMEBUFFER, null), this._unloadTextures(), n.deleteBuffer(this._secondPass.bufferOutputPosition), n.deleteFramebuffer(this._glFrameBuffer), this._renderingCanvas.width = this._renderingCanvas.height = 1, this._clippingCanvas.width = this._clippingCanvas.height = 1, this._outputCanvas.width = this._outputCanvas.height = 1, this._renderingCanvas = null, this._clippingCanvas = this._clippingContext = null, this._outputCanvas = this._outputContext = null;
          let a = n.getExtension("WEBGL_lose_context");
          a && a.loseContext(), this.viewer.removeHandler("tile-ready", this._boundToTileReady), this.viewer.removeHandler("image-unloaded", this._boundToImageUnloaded), this.viewer.removeHandler("resize", this._resizeHandler), this._gl = null, this._backupCanvasDrawer && (this._backupCanvasDrawer.destroy(), this._backupCanvasDrawer = null), this.container.removeChild(this.canvas), this.viewer.drawer === this && (this.viewer.drawer = null), this._destroyed = !0;
        }
        // Public API required by all Drawer implementations
        /**
        *
        * @returns {Boolean} true
        */
        canRotate() {
          return !0;
        }
        // Public API required by all Drawer implementations
        /**
        * @returns {Boolean} true if canvas and webgl are supported
        */
        static isSupported() {
          let n = document.createElement("canvas"), o = e.isFunction(n.getContext) && n.getContext("webgl"), a = o && o.getExtension("WEBGL_lose_context");
          return a && a.loseContext(), !!o;
        }
        /**
         *
         * @returns 'webgl'
         */
        getType() {
          return "webgl";
        }
        /**
         * @param {TiledImage} tiledImage the tiled image that is calling the function
         * @returns {Boolean} Whether this drawer requires enforcing minimum tile overlap to avoid showing seams.
         * @private
         */
        minimumOverlapRequired(n) {
          return n.isTainted();
        }
        /**
        * create the HTML element (canvas in this case) that the image will be drawn into
        * @private
        * @returns {Element} the canvas to draw into
        */
        _createDrawingElement() {
          let n = e.makeNeutralElement("canvas"), o = this._calculateCanvasSize();
          return n.width = o.x, n.height = o.y, n;
        }
        /**
         * Get the backup renderer (CanvasDrawer) to use if data cannot be used by webgl
         * Lazy loaded
         * @private
         * @returns {CanvasDrawer}
         */
        _getBackupCanvasDrawer() {
          return this._backupCanvasDrawer || (this._backupCanvasDrawer = this.viewer.requestDrawer("canvas", { mainDrawer: !1 }), this._backupCanvasDrawer.canvas.style.setProperty("visibility", "hidden")), this._backupCanvasDrawer;
        }
        /**
        *
        * @param {Array} tiledImages Array of TiledImage objects to draw
        */
        draw(n) {
          let o = this._gl;
          const a = this.viewport.getBoundsNoRotateWithMargins(!0);
          let l = {
            bounds: a,
            center: new t.Point(a.x + a.width / 2, a.y + a.height / 2),
            rotation: this.viewport.getRotation(!0) * Math.PI / 180
          }, h = this.viewport.flipped ? -1 : 1, d = e.Mat3.makeTranslation(-l.center.x, -l.center.y), f = e.Mat3.makeScaling(2 / l.bounds.width * h, -2 / l.bounds.height), g = e.Mat3.makeRotation(-l.rotation), w = f.multiply(g).multiply(d);
          o.bindFramebuffer(o.FRAMEBUFFER, null), o.clear(o.COLOR_BUFFER_BIT), this._outputContext.clearRect(0, 0, this._outputCanvas.width, this._outputCanvas.height);
          let C = !1;
          n.forEach((E, A) => {
            if (E.isTainted()) {
              C && (this._outputContext.drawImage(this._renderingCanvas, 0, 0), o.bindFramebuffer(o.FRAMEBUFFER, null), o.clear(o.COLOR_BUFFER_BIT), C = !1);
              const I = this._getBackupCanvasDrawer();
              I.draw([E]), this._outputContext.drawImage(I.canvas, 0, 0);
            } else {
              let I = E.getTilesToDraw();
              if (E.placeholderFillStyle && E._hasOpaqueTile === !1 && this._drawPlaceholder(E), I.length === 0 || E.getOpacity() === 0)
                return;
              let V = I[0], K = E.compositeOperation || this.viewer.compositeOperation || E._clip || E._croppingPolygons || E.debugMode, ce = K || E.opacity < 1 || V.hasTransparency;
              K && (C && this._outputContext.drawImage(this._renderingCanvas, 0, 0), o.bindFramebuffer(o.FRAMEBUFFER, null), o.clear(o.COLOR_BUFFER_BIT)), o.useProgram(this._firstPass.shaderProgram), ce ? (o.bindFramebuffer(o.FRAMEBUFFER, this._glFrameBuffer), o.clear(o.COLOR_BUFFER_BIT)) : o.bindFramebuffer(o.FRAMEBUFFER, null);
              let re = w, he = E.getRotation(!0);
              if (he % 360 !== 0) {
                let ve = e.Mat3.makeRotation(-he * Math.PI / 180), Re = E.getBoundsNoRotate(!0).getCenter(), Ze = e.Mat3.makeTranslation(Re.x, Re.y), Ue = e.Mat3.makeTranslation(-Re.x, -Re.y), We = Ze.multiply(ve).multiply(Ue);
                re = w.multiply(We);
              }
              let pe = this._gl.getParameter(this._gl.MAX_TEXTURE_IMAGE_UNITS);
              if (pe <= 0)
                throw new Error(`WegGL error: bad value for gl parameter MAX_TEXTURE_IMAGE_UNITS (${pe}). This could happen
                        if too many contexts have been created and not released, or there is another problem with the graphics card.`);
              let Te = new Float32Array(pe * 12), Ae = new Array(pe), He = new Array(pe), Fe = new Array(pe);
              for (let ve = 0; ve < I.length; ve++) {
                let Re = I[ve].tile, Ze = ve % pe, Ue = Ze + 1, We = Re.getCanvasContext(), it = We ? this._TextureMap.get(We.canvas) : null;
                if (it || (this._tileReadyHandler({ tile: Re, tiledImage: E }), it = We ? this._TextureMap.get(We.canvas) : null), it && this._getTileData(Re, E, it, re, Ze, Te, Ae, He, Fe), Ue === pe || ve === I.length - 1) {
                  for (let Ve = 0; Ve <= Ue; Ve++)
                    o.activeTexture(o.TEXTURE0 + Ve), o.bindTexture(o.TEXTURE_2D, Ae[Ve]);
                  o.bindBuffer(o.ARRAY_BUFFER, this._firstPass.bufferTexturePosition), o.bufferData(o.ARRAY_BUFFER, Te, o.DYNAMIC_DRAW), He.forEach((Ve, rt) => {
                    o.uniformMatrix3fv(this._firstPass.uTransformMatrices[rt], !1, Ve);
                  }), o.uniform1fv(this._firstPass.uOpacities, new Float32Array(Fe)), o.bindBuffer(o.ARRAY_BUFFER, this._firstPass.bufferOutputPosition), o.vertexAttribPointer(this._firstPass.aOutputPosition, 2, o.FLOAT, !1, 0, 0), o.bindBuffer(o.ARRAY_BUFFER, this._firstPass.bufferTexturePosition), o.vertexAttribPointer(this._firstPass.aTexturePosition, 2, o.FLOAT, !1, 0, 0), o.bindBuffer(o.ARRAY_BUFFER, this._firstPass.bufferIndex), o.vertexAttribPointer(this._firstPass.aIndex, 1, o.FLOAT, !1, 0, 0), o.drawArrays(o.TRIANGLES, 0, 6 * Ue);
                }
              }
              ce && (o.useProgram(this._secondPass.shaderProgram), o.bindFramebuffer(o.FRAMEBUFFER, null), o.activeTexture(o.TEXTURE0), o.bindTexture(o.TEXTURE_2D, this._renderToTexture), this._gl.uniform1f(this._secondPass.uOpacityMultiplier, E.opacity), o.bindBuffer(o.ARRAY_BUFFER, this._secondPass.bufferTexturePosition), o.vertexAttribPointer(this._secondPass.aTexturePosition, 2, o.FLOAT, !1, 0, 0), o.bindBuffer(o.ARRAY_BUFFER, this._secondPass.bufferOutputPosition), o.vertexAttribPointer(this._secondPass.aOutputPosition, 2, o.FLOAT, !1, 0, 0), o.drawArrays(o.TRIANGLES, 0, 6)), C = !0, K && (this._applyContext2dPipeline(E, I, A), C = !1, o.bindFramebuffer(o.FRAMEBUFFER, null), o.clear(o.COLOR_BUFFER_BIT)), A === 0 && this._raiseTiledImageDrawnEvent(E, I.map((ve) => ve.tile));
            }
          }), C && this._outputContext.drawImage(this._renderingCanvas, 0, 0);
        }
        // Public API required by all Drawer implementations
        /**
        * Sets whether image smoothing is enabled or disabled
        * @param {Boolean} enabled If true, uses gl.LINEAR as the TEXTURE_MIN_FILTER and TEXTURE_MAX_FILTER, otherwise gl.NEAREST.
        */
        setImageSmoothingEnabled(n) {
          this._imageSmoothingEnabled !== n && (this._imageSmoothingEnabled = n, this._unloadTextures(), this.viewer.world.draw());
        }
        /**
        * Draw a rect onto the output canvas for debugging purposes
        * @param {OpenSeadragon.Rect} rect
        */
        drawDebuggingRect(n) {
          let o = this._outputContext;
          o.save(), o.lineWidth = 2 * e.pixelDensityRatio, o.strokeStyle = this.debugGridColor[0], o.fillStyle = this.debugGridColor[0], o.strokeRect(
            n.x * e.pixelDensityRatio,
            n.y * e.pixelDensityRatio,
            n.width * e.pixelDensityRatio,
            n.height * e.pixelDensityRatio
          ), o.restore();
        }
        // private
        _getTextureDataFromTile(n) {
          return n.getCanvasContext().canvas;
        }
        /**
        * Draw data from the rendering canvas onto the output canvas, with clipping,
        * cropping and/or debug info as requested.
        * @private
        * @param {OpenSeadragon.TiledImage} tiledImage - the tiledImage to draw
        * @param {Array} tilesToDraw - array of objects containing tiles that were drawn
        */
        _applyContext2dPipeline(n, o, a) {
          if (this._outputContext.save(), this._outputContext.globalCompositeOperation = a === 0 ? null : n.compositeOperation || this.viewer.compositeOperation, n._croppingPolygons || n._clip ? (this._renderToClippingCanvas(n), this._outputContext.drawImage(this._clippingCanvas, 0, 0)) : this._outputContext.drawImage(this._renderingCanvas, 0, 0), this._outputContext.restore(), n.debugMode) {
            const l = this.viewer.viewport.getFlip();
            l && this._flip(), this._drawDebugInfo(o, n, l), l && this._flip();
          }
        }
        // private
        _getTileData(n, o, a, l, h, d, f, g, w) {
          let C = a.texture, E = a.position;
          d.set(E, h * 12);
          let A = this._calculateOverlapFraction(n, o), I = n.positionedBounds.width * A.x, V = n.positionedBounds.height * A.y, K = n.positionedBounds.x + (n.x === 0 ? 0 : I), ce = n.positionedBounds.y + (n.y === 0 ? 0 : V), re = n.positionedBounds.x + n.positionedBounds.width - (n.isRightMost ? 0 : I), he = n.positionedBounds.y + n.positionedBounds.height - (n.isBottomMost ? 0 : V), pe = re - K, Te = he - ce, Ae = new e.Mat3([
            pe,
            0,
            0,
            0,
            Te,
            0,
            K,
            ce,
            1
          ]);
          if (n.flipped) {
            let Fe = e.Mat3.makeTranslation(0.5, 0), ve = e.Mat3.makeTranslation(-0.5, 0), Re = Fe.multiply(e.Mat3.makeScaling(-1, 1)).multiply(ve);
            Ae = Ae.multiply(Re);
          }
          let He = l.multiply(Ae);
          w[h] = n.opacity, f[h] = C, g[h] = He.values;
        }
        // private
        _textureFilter() {
          return this._imageSmoothingEnabled ? this._gl.LINEAR : this._gl.NEAREST;
        }
        // private
        _setupRenderer() {
          let n = this._gl;
          n || e.console.error("_setupCanvases must be called before _setupRenderer"), this._unitQuad = this._makeQuadVertexBuffer(0, 1, 0, 1), this._makeFirstPassShaderProgram(), this._makeSecondPassShaderProgram(), this._renderToTexture = n.createTexture(), n.activeTexture(n.TEXTURE0), n.bindTexture(n.TEXTURE_2D, this._renderToTexture), n.texImage2D(n.TEXTURE_2D, 0, n.RGBA, this._renderingCanvas.width, this._renderingCanvas.height, 0, n.RGBA, n.UNSIGNED_BYTE, null), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, this._textureFilter()), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE), this._glFrameBuffer = n.createFramebuffer(), n.bindFramebuffer(n.FRAMEBUFFER, this._glFrameBuffer), n.framebufferTexture2D(
            n.FRAMEBUFFER,
            n.COLOR_ATTACHMENT0,
            // attach texture as COLOR_ATTACHMENT0
            n.TEXTURE_2D,
            // attach a 2D texture
            this._renderToTexture,
            // the texture to attach
            0
          ), n.enable(n.BLEND), n.blendFunc(n.ONE, n.ONE_MINUS_SRC_ALPHA);
        }
        //private
        _makeFirstPassShaderProgram() {
          let n = this._glNumTextures = this._gl.getParameter(this._gl.MAX_TEXTURE_IMAGE_UNITS), o = () => [...Array(n).keys()].map((C) => `uniform mat3 u_matrix_${C};`).join(`
`), a = () => [...Array(n).keys()].map((C) => `${C > 0 ? "else " : ""}if(int(a_index) == ${C}) { transform_matrix = u_matrix_${C}; }`).join(`
`);
          const l = `
            attribute vec2 a_output_position;
            attribute vec2 a_texture_position;
            attribute float a_index;

            ${o()} // create a uniform mat3 for each potential tile to draw

            varying vec2 v_texture_position;
            varying float v_image_index;

            void main() {

                mat3 transform_matrix; // value will be set by the if/elses in makeConditional()

                ${a()}

                gl_Position = vec4(transform_matrix * vec3(a_output_position, 1), 1);

                v_texture_position = a_texture_position;
                v_image_index = a_index;
            }
            `, h = `
            precision mediump float;

            // our textures
            uniform sampler2D u_images[${n}];
            // our opacities
            uniform float u_opacities[${n}];

            // the varyings passed in from the vertex shader.
            varying vec2 v_texture_position;
            varying float v_image_index;

            void main() {
                // can't index directly with a variable, need to use a loop iterator hack
                for(int i = 0; i < ${n}; ++i){
                    if(i == int(v_image_index)){
                        gl_FragColor = texture2D(u_images[i], v_texture_position) * u_opacities[i];
                    }
                }
            }
            `;
          let d = this._gl, f = this.constructor.initShaderProgram(d, l, h);
          d.useProgram(f), this._firstPass = {
            shaderProgram: f,
            aOutputPosition: d.getAttribLocation(f, "a_output_position"),
            aTexturePosition: d.getAttribLocation(f, "a_texture_position"),
            aIndex: d.getAttribLocation(f, "a_index"),
            uTransformMatrices: [...Array(this._glNumTextures).keys()].map((C) => d.getUniformLocation(f, `u_matrix_${C}`)),
            uImages: d.getUniformLocation(f, "u_images"),
            uOpacities: d.getUniformLocation(f, "u_opacities"),
            bufferOutputPosition: d.createBuffer(),
            bufferTexturePosition: d.createBuffer(),
            bufferIndex: d.createBuffer()
          }, d.uniform1iv(this._firstPass.uImages, [...Array(n).keys()]);
          let g = new Float32Array(n * 12);
          for (let C = 0; C < n; ++C)
            g.set(Float32Array.from(this._unitQuad), C * 12);
          d.bindBuffer(d.ARRAY_BUFFER, this._firstPass.bufferOutputPosition), d.bufferData(d.ARRAY_BUFFER, g, d.STATIC_DRAW), d.enableVertexAttribArray(this._firstPass.aOutputPosition), d.bindBuffer(d.ARRAY_BUFFER, this._firstPass.bufferTexturePosition), d.enableVertexAttribArray(this._firstPass.aTexturePosition), d.bindBuffer(d.ARRAY_BUFFER, this._firstPass.bufferIndex);
          let w = [...Array(this._glNumTextures).keys()].map((C) => Array(6).fill(C)).flat();
          d.bufferData(d.ARRAY_BUFFER, new Float32Array(w), d.STATIC_DRAW), d.enableVertexAttribArray(this._firstPass.aIndex);
        }
        // private
        _makeSecondPassShaderProgram() {
          const n = `
            attribute vec2 a_output_position;
            attribute vec2 a_texture_position;

            uniform mat3 u_matrix;

            varying vec2 v_texture_position;

            void main() {
                gl_Position = vec4(u_matrix * vec3(a_output_position, 1), 1);

                v_texture_position = a_texture_position;
            }
            `, o = `
            precision mediump float;

            // our texture
            uniform sampler2D u_image;

            // the texCoords passed in from the vertex shader.
            varying vec2 v_texture_position;

            // the opacity multiplier for the image
            uniform float u_opacity_multiplier;

            void main() {
                gl_FragColor = texture2D(u_image, v_texture_position);
                gl_FragColor *= u_opacity_multiplier;
            }
            `;
          let a = this._gl, l = this.constructor.initShaderProgram(a, n, o);
          a.useProgram(l), this._secondPass = {
            shaderProgram: l,
            aOutputPosition: a.getAttribLocation(l, "a_output_position"),
            aTexturePosition: a.getAttribLocation(l, "a_texture_position"),
            uMatrix: a.getUniformLocation(l, "u_matrix"),
            uImage: a.getUniformLocation(l, "u_image"),
            uOpacityMultiplier: a.getUniformLocation(l, "u_opacity_multiplier"),
            bufferOutputPosition: a.createBuffer(),
            bufferTexturePosition: a.createBuffer()
          }, a.bindBuffer(a.ARRAY_BUFFER, this._secondPass.bufferOutputPosition), a.bufferData(a.ARRAY_BUFFER, this._unitQuad, a.STATIC_DRAW), a.enableVertexAttribArray(this._secondPass.aOutputPosition), a.bindBuffer(a.ARRAY_BUFFER, this._secondPass.bufferTexturePosition), a.bufferData(a.ARRAY_BUFFER, this._unitQuad, a.DYNAMIC_DRAW), a.enableVertexAttribArray(this._secondPass.aTexturePosition);
          let h = e.Mat3.makeScaling(2, 2).multiply(e.Mat3.makeTranslation(-0.5, -0.5));
          a.uniformMatrix3fv(this._secondPass.uMatrix, !1, h.values);
        }
        // private
        _resizeRenderer() {
          let n = this._gl, o = this._renderingCanvas.width, a = this._renderingCanvas.height;
          n.viewport(0, 0, o, a), n.deleteTexture(this._renderToTexture), this._renderToTexture = n.createTexture(), n.activeTexture(n.TEXTURE0), n.bindTexture(n.TEXTURE_2D, this._renderToTexture), n.texImage2D(n.TEXTURE_2D, 0, n.RGBA, o, a, 0, n.RGBA, n.UNSIGNED_BYTE, null), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, this._textureFilter()), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE), n.bindFramebuffer(n.FRAMEBUFFER, this._glFrameBuffer), n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, this._renderToTexture, 0);
        }
        // private
        _setupCanvases() {
          let n = this;
          this._outputCanvas = this.canvas, this._outputContext = this._outputCanvas.getContext("2d"), this._renderingCanvas = document.createElement("canvas"), this._clippingCanvas = document.createElement("canvas"), this._clippingContext = this._clippingCanvas.getContext("2d"), this._renderingCanvas.width = this._clippingCanvas.width = this._outputCanvas.width, this._renderingCanvas.height = this._clippingCanvas.height = this._outputCanvas.height, this._gl = this._renderingCanvas.getContext("webgl"), this._resizeHandler = function() {
            n._outputCanvas !== n.viewer.drawer.canvas && (n._outputCanvas.style.width = n.viewer.drawer.canvas.clientWidth + "px", n._outputCanvas.style.height = n.viewer.drawer.canvas.clientHeight + "px");
            let o = n._calculateCanvasSize();
            (n._outputCanvas.width !== o.x || n._outputCanvas.height !== o.y) && (n._outputCanvas.width = o.x, n._outputCanvas.height = o.y), n._renderingCanvas.style.width = n._outputCanvas.clientWidth + "px", n._renderingCanvas.style.height = n._outputCanvas.clientHeight + "px", n._renderingCanvas.width = n._clippingCanvas.width = n._outputCanvas.width, n._renderingCanvas.height = n._clippingCanvas.height = n._outputCanvas.height, n._resizeRenderer();
          }, this.viewer.addHandler("resize", this._resizeHandler);
        }
        // private
        _makeQuadVertexBuffer(n, o, a, l) {
          return new Float32Array([
            n,
            l,
            o,
            l,
            n,
            a,
            n,
            a,
            o,
            l,
            o,
            a
          ]);
        }
        // private
        _tileReadyHandler(n) {
          let o = n.tile, a = n.tiledImage;
          if (a.isTainted())
            return;
          let l = o.getCanvasContext(), h = l && l.canvas;
          if (!h || e.isCanvasTainted(h)) {
            a.isTainted() || (a.setTainted(!0), e.console.warn("WebGL cannot be used to draw this TiledImage because it has tainted data. Does crossOriginPolicy need to be set?"), this._raiseDrawerErrorEvent(a, "Tainted data cannot be used by the WebGLDrawer. Falling back to CanvasDrawer for this TiledImage."));
            return;
          }
          if (!this._TextureMap.get(h)) {
            let f = this._gl, g = f.createTexture(), w, C = a.source.tileOverlap, E, A;
            if (o.sourceBounds ? (E = Math.min(o.sourceBounds.width, h.width) / h.width, A = Math.min(o.sourceBounds.height, h.height) / h.height) : (E = 1, A = 1), C > 0) {
              let V = this._calculateOverlapFraction(o, a), K = (o.x === 0 ? 0 : V.x) * E, ce = (o.y === 0 ? 0 : V.y) * A, re = (o.isRightMost ? 1 : 1 - V.x) * E, he = (o.isBottomMost ? 1 : 1 - V.y) * A;
              w = this._makeQuadVertexBuffer(K, re, ce, he);
            } else E === 1 && A === 1 ? w = this._unitQuad : w = this._makeQuadVertexBuffer(0, E, 0, A);
            let I = {
              texture: g,
              position: w
            };
            this._TextureMap.set(h, I), f.activeTexture(f.TEXTURE0), f.bindTexture(f.TEXTURE_2D, g), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_S, f.CLAMP_TO_EDGE), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_T, f.CLAMP_TO_EDGE), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MIN_FILTER, this._textureFilter()), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MAG_FILTER, this._textureFilter()), this._uploadImageData(l);
          }
        }
        // private
        _calculateOverlapFraction(n, o) {
          let a = o.source.tileOverlap, l = n.sourceBounds.width, h = n.sourceBounds.height, d = (n.x === 0 ? 0 : a) + (n.isRightMost ? 0 : a), f = (n.y === 0 ? 0 : a) + (n.isBottomMost ? 0 : a), g = a / (l + d), w = a / (h + f);
          return {
            x: g,
            y: w
          };
        }
        // private
        _unloadTextures() {
          Array.from(this._TextureMap.keys()).forEach((o) => {
            this._cleanupImageData(o);
          });
        }
        // private
        _uploadImageData(n) {
          let o = this._gl, a = n.canvas;
          try {
            if (!a)
              throw n;
            o.texImage2D(o.TEXTURE_2D, 0, o.RGBA, o.RGBA, o.UNSIGNED_BYTE, a);
          } catch (l) {
            e.console.error("Error uploading image data to WebGL", l);
          }
        }
        // private
        _imageUnloadedHandler(n) {
          let o = n.context2D.canvas;
          this._cleanupImageData(o);
        }
        // private
        _cleanupImageData(n) {
          let o = this._TextureMap.get(n);
          this._TextureMap.delete(n), o && this._gl.deleteTexture(o.texture);
        }
        // private
        _setClip() {
        }
        // private
        _renderToClippingCanvas(n) {
          if (this._clippingContext.clearRect(0, 0, this._clippingCanvas.width, this._clippingCanvas.height), this._clippingContext.save(), this.viewer.viewport.getFlip()) {
            const o = new e.Point(this.canvas.width / 2, this.canvas.height / 2);
            this._clippingContext.translate(o.x, 0), this._clippingContext.scale(-1, 1), this._clippingContext.translate(-o.x, 0);
          }
          if (n._clip) {
            let a = [
              { x: n._clip.x, y: n._clip.y },
              { x: n._clip.x + n._clip.width, y: n._clip.y },
              { x: n._clip.x + n._clip.width, y: n._clip.y + n._clip.height },
              { x: n._clip.x, y: n._clip.y + n._clip.height }
            ].map((l) => {
              let h = n.imageToViewportCoordinates(l.x, l.y, !0).rotate(this.viewer.viewport.getRotation(!0), this.viewer.viewport.getCenter(!0));
              return this.viewportCoordToDrawerCoord(h);
            });
            this._clippingContext.beginPath(), a.forEach((l, h) => {
              this._clippingContext[h === 0 ? "moveTo" : "lineTo"](l.x, l.y);
            }), this._clippingContext.clip(), this._setClip();
          }
          if (n._croppingPolygons) {
            let o = n._croppingPolygons.map((a) => a.map((l) => {
              let h = n.imageToViewportCoordinates(l.x, l.y, !0).rotate(this.viewer.viewport.getRotation(!0), this.viewer.viewport.getCenter(!0));
              return this.viewportCoordToDrawerCoord(h);
            }));
            this._clippingContext.beginPath(), o.forEach((a) => {
              a.forEach((l, h) => {
                this._clippingContext[h === 0 ? "moveTo" : "lineTo"](l.x, l.y);
              });
            }), this._clippingContext.clip();
          }
          if (this.viewer.viewport.getFlip()) {
            const o = new e.Point(this.canvas.width / 2, this.canvas.height / 2);
            this._clippingContext.translate(o.x, 0), this._clippingContext.scale(-1, 1), this._clippingContext.translate(-o.x, 0);
          }
          this._clippingContext.drawImage(this._renderingCanvas, 0, 0), this._clippingContext.restore();
        }
        /**
         * Set rotations for viewport & tiledImage
         * @private
         * @param {OpenSeadragon.TiledImage} tiledImage
         */
        _setRotations(n) {
          var o = !1;
          this.viewport.getRotation(!0) % 360 !== 0 && (this._offsetForRotation({
            degrees: this.viewport.getRotation(!0),
            saveContext: o
          }), o = !1), n.getRotation(!0) % 360 !== 0 && this._offsetForRotation({
            degrees: n.getRotation(!0),
            point: this.viewport.pixelFromPointNoRotate(
              n._getRotationPoint(!0),
              !0
            ),
            saveContext: o
          });
        }
        // private
        _offsetForRotation(n) {
          var o = n.point ? n.point.times(e.pixelDensityRatio) : this._getCanvasCenter(), a = this._outputContext;
          a.save(), a.translate(o.x, o.y), a.rotate(Math.PI / 180 * n.degrees), a.translate(-o.x, -o.y);
        }
        // private
        _flip(n) {
          n = n || {};
          var o = n.point ? n.point.times(e.pixelDensityRatio) : this._getCanvasCenter(), a = this._outputContext;
          a.translate(o.x, 0), a.scale(-1, 1), a.translate(-o.x, 0);
        }
        // private
        _drawDebugInfo(n, o, a) {
          for (var l = n.length - 1; l >= 0; l--) {
            var h = n[l].tile;
            try {
              this._drawDebugInfoOnTile(h, n.length, l, o, a);
            } catch (d) {
              e.console.error(d);
            }
          }
        }
        // private
        _drawDebugInfoOnTile(n, o, a, l, h) {
          var d = this.viewer.world.getIndexOfItem(l) % this.debugGridColor.length, f = this.context;
          f.save(), f.lineWidth = 2 * e.pixelDensityRatio, f.font = "small-caps bold " + 13 * e.pixelDensityRatio + "px arial", f.strokeStyle = this.debugGridColor[d], f.fillStyle = this.debugGridColor[d], this._setRotations(l), h && this._flip({ point: n.position.plus(n.size.divide(2)) }), f.strokeRect(
            n.position.x * e.pixelDensityRatio,
            n.position.y * e.pixelDensityRatio,
            n.size.x * e.pixelDensityRatio,
            n.size.y * e.pixelDensityRatio
          );
          var g = (n.position.x + n.size.x / 2) * e.pixelDensityRatio, w = (n.position.y + n.size.y / 2) * e.pixelDensityRatio;
          f.translate(g, w);
          const C = this.viewport.getRotation(!0);
          f.rotate(Math.PI / 180 * -C), f.translate(-g, -w), n.x === 0 && n.y === 0 && (f.fillText(
            "Zoom: " + this.viewport.getZoom(),
            n.position.x * e.pixelDensityRatio,
            (n.position.y - 30) * e.pixelDensityRatio
          ), f.fillText(
            "Pan: " + this.viewport.getBounds().toString(),
            n.position.x * e.pixelDensityRatio,
            (n.position.y - 20) * e.pixelDensityRatio
          )), f.fillText(
            "Level: " + n.level,
            (n.position.x + 10) * e.pixelDensityRatio,
            (n.position.y + 20) * e.pixelDensityRatio
          ), f.fillText(
            "Column: " + n.x,
            (n.position.x + 10) * e.pixelDensityRatio,
            (n.position.y + 30) * e.pixelDensityRatio
          ), f.fillText(
            "Row: " + n.y,
            (n.position.x + 10) * e.pixelDensityRatio,
            (n.position.y + 40) * e.pixelDensityRatio
          ), f.fillText(
            "Order: " + a + " of " + o,
            (n.position.x + 10) * e.pixelDensityRatio,
            (n.position.y + 50) * e.pixelDensityRatio
          ), f.fillText(
            "Size: " + n.size.toString(),
            (n.position.x + 10) * e.pixelDensityRatio,
            (n.position.y + 60) * e.pixelDensityRatio
          ), f.fillText(
            "Position: " + n.position.toString(),
            (n.position.x + 10) * e.pixelDensityRatio,
            (n.position.y + 70) * e.pixelDensityRatio
          ), this.viewport.getRotation(!0) % 360 !== 0 && this._restoreRotationChanges(), l.getRotation(!0) % 360 !== 0 && this._restoreRotationChanges(), f.restore();
        }
        _drawPlaceholder(n) {
          const o = n.getBounds(!0), a = this.viewportToDrawerRectangle(n.getBounds(!0)), l = this._outputContext;
          let h;
          typeof n.placeholderFillStyle == "function" ? h = n.placeholderFillStyle(n, l) : h = n.placeholderFillStyle, this._offsetForRotation({ degrees: this.viewer.viewport.getRotation(!0) }), l.fillStyle = h, l.translate(a.x, a.y), l.rotate(Math.PI / 180 * o.degrees), l.translate(-a.x, -a.y), l.fillRect(a.x, a.y, a.width, a.height), this._restoreRotationChanges();
        }
        /**
         * Get the canvas center
         * @private
         * @returns {OpenSeadragon.Point} The center point of the canvas
         */
        _getCanvasCenter() {
          return new e.Point(this.canvas.width / 2, this.canvas.height / 2);
        }
        // private
        _restoreRotationChanges() {
          var n = this._outputContext;
          n.restore();
        }
        // modified from https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Tutorial/Adding_2D_content_to_a_WebGL_context
        static initShaderProgram(n, o, a) {
          function l(g, w, C) {
            const E = g.createShader(w);
            return g.shaderSource(E, C), g.compileShader(E), g.getShaderParameter(E, g.COMPILE_STATUS) ? E : (e.console.error(
              `An error occurred compiling the shaders: ${g.getShaderInfoLog(E)}`
            ), g.deleteShader(E), null);
          }
          const h = l(n, n.VERTEX_SHADER, o), d = l(n, n.FRAGMENT_SHADER, a), f = n.createProgram();
          return n.attachShader(f, h), n.attachShader(f, d), n.linkProgram(f), n.getProgramParameter(f, n.LINK_STATUS) ? f : (e.console.error(
            `Unable to initialize the shader program: ${n.getProgramInfoLog(
              f
            )}`
          ), null);
        }
      };
    }(r), function(e) {
      e.Viewport = function(t) {
        var i = arguments;
        i.length && i[0] instanceof e.Point && (t = {
          containerSize: i[0],
          contentSize: i[1],
          config: i[2]
        }), t.config && (e.extend(!0, t, t.config), delete t.config), this._margins = e.extend({
          left: 0,
          top: 0,
          right: 0,
          bottom: 0
        }, t.margins || {}), delete t.margins, t.initialDegrees = t.degrees, delete t.degrees, e.extend(!0, this, {
          //required settings
          containerSize: null,
          contentSize: null,
          //internal state properties
          zoomPoint: null,
          rotationPivot: null,
          viewer: null,
          //configurable options
          springStiffness: e.DEFAULT_SETTINGS.springStiffness,
          animationTime: e.DEFAULT_SETTINGS.animationTime,
          minZoomImageRatio: e.DEFAULT_SETTINGS.minZoomImageRatio,
          maxZoomPixelRatio: e.DEFAULT_SETTINGS.maxZoomPixelRatio,
          visibilityRatio: e.DEFAULT_SETTINGS.visibilityRatio,
          wrapHorizontal: e.DEFAULT_SETTINGS.wrapHorizontal,
          wrapVertical: e.DEFAULT_SETTINGS.wrapVertical,
          defaultZoomLevel: e.DEFAULT_SETTINGS.defaultZoomLevel,
          minZoomLevel: e.DEFAULT_SETTINGS.minZoomLevel,
          maxZoomLevel: e.DEFAULT_SETTINGS.maxZoomLevel,
          initialDegrees: e.DEFAULT_SETTINGS.degrees,
          flipped: e.DEFAULT_SETTINGS.flipped,
          homeFillsViewer: e.DEFAULT_SETTINGS.homeFillsViewer,
          silenceMultiImageWarnings: e.DEFAULT_SETTINGS.silenceMultiImageWarnings
        }, t), this._updateContainerInnerSize(), this.centerSpringX = new e.Spring({
          initial: 0,
          springStiffness: this.springStiffness,
          animationTime: this.animationTime
        }), this.centerSpringY = new e.Spring({
          initial: 0,
          springStiffness: this.springStiffness,
          animationTime: this.animationTime
        }), this.zoomSpring = new e.Spring({
          exponential: !0,
          initial: 1,
          springStiffness: this.springStiffness,
          animationTime: this.animationTime
        }), this.degreesSpring = new e.Spring({
          initial: t.initialDegrees,
          springStiffness: this.springStiffness,
          animationTime: this.animationTime
        }), this._oldCenterX = this.centerSpringX.current.value, this._oldCenterY = this.centerSpringY.current.value, this._oldZoom = this.zoomSpring.current.value, this._oldDegrees = this.degreesSpring.current.value, this._setContentBounds(new e.Rect(0, 0, 1, 1), 1), this.goHome(!0), this.update();
      }, e.Viewport.prototype = {
        // deprecated
        get degrees() {
          return e.console.warn("Accessing [Viewport.degrees] is deprecated. Use viewport.getRotation instead."), this.getRotation();
        },
        // deprecated
        set degrees(t) {
          e.console.warn("Setting [Viewport.degrees] is deprecated. Use viewport.rotateTo, viewport.rotateBy, or viewport.setRotation instead."), this.rotateTo(t);
        },
        /**
         * Updates the viewport's home bounds and constraints for the given content size.
         * @function
         * @param {OpenSeadragon.Point} contentSize - size of the content in content units
         * @returns {OpenSeadragon.Viewport} Chainable.
         * @fires OpenSeadragon.Viewer.event:reset-size
         */
        resetContentSize: function(t) {
          return e.console.assert(t, "[Viewport.resetContentSize] contentSize is required"), e.console.assert(t instanceof e.Point, "[Viewport.resetContentSize] contentSize must be an OpenSeadragon.Point"), e.console.assert(t.x > 0, "[Viewport.resetContentSize] contentSize.x must be greater than 0"), e.console.assert(t.y > 0, "[Viewport.resetContentSize] contentSize.y must be greater than 0"), this._setContentBounds(new e.Rect(0, 0, 1, t.y / t.x), t.x), this;
        },
        // deprecated
        setHomeBounds: function(t, i) {
          e.console.error("[Viewport.setHomeBounds] this function is deprecated; The content bounds should not be set manually."), this._setContentBounds(t, i);
        },
        // Set the viewport's content bounds
        // @param {OpenSeadragon.Rect} bounds - the new bounds in viewport coordinates
        // without rotation
        // @param {Number} contentFactor - how many content units per viewport unit
        // @fires OpenSeadragon.Viewer.event:reset-size
        // @private
        _setContentBounds: function(t, i) {
          e.console.assert(t, "[Viewport._setContentBounds] bounds is required"), e.console.assert(t instanceof e.Rect, "[Viewport._setContentBounds] bounds must be an OpenSeadragon.Rect"), e.console.assert(t.width > 0, "[Viewport._setContentBounds] bounds.width must be greater than 0"), e.console.assert(t.height > 0, "[Viewport._setContentBounds] bounds.height must be greater than 0"), this._contentBoundsNoRotate = t.clone(), this._contentSizeNoRotate = this._contentBoundsNoRotate.getSize().times(
            i
          ), this._contentBounds = t.rotate(this.getRotation()).getBoundingBox(), this._contentSize = this._contentBounds.getSize().times(i), this._contentAspectRatio = this._contentSize.x / this._contentSize.y, this.viewer && this.viewer.raiseEvent("reset-size", {
            contentSize: this._contentSizeNoRotate.clone(),
            contentFactor: i,
            homeBounds: this._contentBoundsNoRotate.clone(),
            contentBounds: this._contentBounds.clone()
          });
        },
        /**
         * Returns the home zoom in "viewport zoom" value.
         * @function
         * @returns {Number} The home zoom in "viewport zoom".
         */
        getHomeZoom: function() {
          if (this.defaultZoomLevel)
            return this.defaultZoomLevel;
          var t = this._contentAspectRatio / this.getAspectRatio(), i;
          return this.homeFillsViewer ? i = t >= 1 ? t : 1 : i = t >= 1 ? 1 : t, i / this._contentBounds.width;
        },
        /**
         * Returns the home bounds in viewport coordinates.
         * @function
         * @returns {OpenSeadragon.Rect} The home bounds in vewport coordinates.
         */
        getHomeBounds: function() {
          return this.getHomeBoundsNoRotate().rotate(-this.getRotation());
        },
        /**
         * Returns the home bounds in viewport coordinates.
         * This method ignores the viewport rotation. Use
         * {@link OpenSeadragon.Viewport#getHomeBounds} to take it into account.
         * @function
         * @returns {OpenSeadragon.Rect} The home bounds in vewport coordinates.
         */
        getHomeBoundsNoRotate: function() {
          var t = this._contentBounds.getCenter(), i = 1 / this.getHomeZoom(), n = i / this.getAspectRatio();
          return new e.Rect(
            t.x - i / 2,
            t.y - n / 2,
            i,
            n
          );
        },
        /**
         * @function
         * @param {Boolean} immediately
         * @fires OpenSeadragon.Viewer.event:home
         */
        goHome: function(t) {
          return this.viewer && this.viewer.raiseEvent("home", {
            immediately: t
          }), this.fitBounds(this.getHomeBounds(), t);
        },
        /**
         * @function
         */
        getMinZoom: function() {
          var t = this.getHomeZoom(), i = this.minZoomLevel ? this.minZoomLevel : this.minZoomImageRatio * t;
          return i;
        },
        /**
         * @function
         */
        getMaxZoom: function() {
          var t = this.maxZoomLevel;
          return t || (t = this._contentSize.x * this.maxZoomPixelRatio / this._containerInnerSize.x, t /= this._contentBounds.width), Math.max(t, this.getHomeZoom());
        },
        /**
         * @function
         */
        getAspectRatio: function() {
          return this._containerInnerSize.x / this._containerInnerSize.y;
        },
        /**
         * @function
         * @returns {OpenSeadragon.Point} The size of the container, in screen coordinates.
         */
        getContainerSize: function() {
          return new e.Point(
            this.containerSize.x,
            this.containerSize.y
          );
        },
        /**
         * The margins push the "home" region in from the sides by the specified amounts.
         * @function
         * @returns {Object} Properties (Numbers, in screen coordinates): left, top, right, bottom.
         */
        getMargins: function() {
          return e.extend({}, this._margins);
        },
        /**
         * The margins push the "home" region in from the sides by the specified amounts.
         * @function
         * @param {Object} margins - Properties (Numbers, in screen coordinates): left, top, right, bottom.
         */
        setMargins: function(t) {
          e.console.assert(e.type(t) === "object", "[Viewport.setMargins] margins must be an object"), this._margins = e.extend({
            left: 0,
            top: 0,
            right: 0,
            bottom: 0
          }, t), this._updateContainerInnerSize(), this.viewer && this.viewer.forceRedraw();
        },
        /**
         * Returns the bounds of the visible area in viewport coordinates.
         * @function
         * @param {Boolean} current - Pass true for the current location; defaults to false (target location).
         * @returns {OpenSeadragon.Rect} The location you are zoomed/panned to, in viewport coordinates.
         */
        getBounds: function(t) {
          return this.getBoundsNoRotate(t).rotate(-this.getRotation(t));
        },
        /**
         * Returns the bounds of the visible area in viewport coordinates.
         * This method ignores the viewport rotation. Use
         * {@link OpenSeadragon.Viewport#getBounds} to take it into account.
         * @function
         * @param {Boolean} current - Pass true for the current location; defaults to false (target location).
         * @returns {OpenSeadragon.Rect} The location you are zoomed/panned to, in viewport coordinates.
         */
        getBoundsNoRotate: function(t) {
          var i = this.getCenter(t), n = 1 / this.getZoom(t), o = n / this.getAspectRatio();
          return new e.Rect(
            i.x - n / 2,
            i.y - o / 2,
            n,
            o
          );
        },
        /**
         * @function
         * @param {Boolean} current - Pass true for the current location; defaults to false (target location).
         * @returns {OpenSeadragon.Rect} The location you are zoomed/panned to,
         * including the space taken by margins, in viewport coordinates.
         */
        getBoundsWithMargins: function(t) {
          return this.getBoundsNoRotateWithMargins(t).rotate(
            -this.getRotation(t),
            this.getCenter(t)
          );
        },
        /**
         * @function
         * @param {Boolean} current - Pass true for the current location; defaults to false (target location).
         * @returns {OpenSeadragon.Rect} The location you are zoomed/panned to,
         * including the space taken by margins, in viewport coordinates.
         */
        getBoundsNoRotateWithMargins: function(t) {
          var i = this.getBoundsNoRotate(t), n = this._containerInnerSize.x * this.getZoom(t);
          return i.x -= this._margins.left / n, i.y -= this._margins.top / n, i.width += (this._margins.left + this._margins.right) / n, i.height += (this._margins.top + this._margins.bottom) / n, i;
        },
        /**
         * @function
         * @param {Boolean} current - Pass true for the current location; defaults to false (target location).
         */
        getCenter: function(t) {
          var i = new e.Point(
            this.centerSpringX.current.value,
            this.centerSpringY.current.value
          ), n = new e.Point(
            this.centerSpringX.target.value,
            this.centerSpringY.target.value
          ), o, a, l, h, d, f, g, w;
          return t ? i : this.zoomPoint ? (o = this.pixelFromPoint(this.zoomPoint, !0), a = this.getZoom(), l = 1 / a, h = l / this.getAspectRatio(), d = new e.Rect(
            i.x - l / 2,
            i.y - h / 2,
            l,
            h
          ), f = this._pixelFromPoint(this.zoomPoint, d), g = f.minus(o).rotate(-this.getRotation(!0)), w = g.divide(this._containerInnerSize.x * a), n.plus(w)) : n;
        },
        /**
         * @function
         * @param {Boolean} current - Pass true for the current location; defaults to false (target location).
         */
        getZoom: function(t) {
          return t ? this.zoomSpring.current.value : this.zoomSpring.target.value;
        },
        // private
        _applyZoomConstraints: function(t) {
          return Math.max(
            Math.min(t, this.getMaxZoom()),
            this.getMinZoom()
          );
        },
        /**
         * @function
         * @private
         * @param {OpenSeadragon.Rect} bounds
         * @returns {OpenSeadragon.Rect} constrained bounds.
         */
        _applyBoundaryConstraints: function(t) {
          var i = this.viewportToViewerElementRectangle(t).getBoundingBox(), n = this.viewportToViewerElementRectangle(this._contentBoundsNoRotate).getBoundingBox(), o = !1, a = !1;
          if (!this.wrapHorizontal) {
            var l = i.x + i.width, h = n.x + n.width, d, f, g;
            i.width > n.width ? d = this.visibilityRatio * n.width : d = this.visibilityRatio * i.width, f = n.x - l + d, g = h - i.x - d, d > n.width ? (i.x += (f + g) / 2, o = !0) : g < 0 ? (i.x += g, o = !0) : f > 0 && (i.x += f, o = !0);
          }
          if (!this.wrapVertical) {
            var w = i.y + i.height, C = n.y + n.height, E, A, I;
            i.height > n.height ? E = this.visibilityRatio * n.height : E = this.visibilityRatio * i.height, A = n.y - w + E, I = C - i.y - E, E > n.height ? (i.y += (A + I) / 2, a = !0) : I < 0 ? (i.y += I, a = !0) : A > 0 && (i.y += A, a = !0);
          }
          var V = o || a, K = V ? this.viewerElementToViewportRectangle(i) : t.clone();
          return K.xConstrained = o, K.yConstrained = a, K.constraintApplied = V, K;
        },
        /**
         * @function
         * @private
         * @param {Boolean} [immediately=false] - whether the function that triggered this event was
         * called with the "immediately" flag
         */
        _raiseConstraintsEvent: function(t) {
          this.viewer && this.viewer.raiseEvent("constrain", {
            immediately: t
          });
        },
        /**
         * Enforces the minZoom, maxZoom and visibilityRatio constraints by
         * zooming and panning to the closest acceptable zoom and location.
         * @function
         * @param {Boolean} [immediately=false]
         * @returns {OpenSeadragon.Viewport} Chainable.
         * @fires OpenSeadragon.Viewer.event:constrain if constraints were applied
         */
        applyConstraints: function(t) {
          var i = this.getZoom(), n = this._applyZoomConstraints(i);
          i !== n && this.zoomTo(n, this.zoomPoint, t);
          var o = this.getConstrainedBounds(!1);
          return o.constraintApplied && (this.fitBounds(o, t), this._raiseConstraintsEvent(t)), this;
        },
        /**
         * Equivalent to {@link OpenSeadragon.Viewport#applyConstraints}
         * @function
         * @param {Boolean} [immediately=false]
         * @returns {OpenSeadragon.Viewport} Chainable.
         * @fires OpenSeadragon.Viewer.event:constrain
         */
        ensureVisible: function(t) {
          return this.applyConstraints(t);
        },
        /**
         * @function
         * @private
         * @param {OpenSeadragon.Rect} bounds
         * @param {Object} options (immediately=false, constraints=false)
         * @returns {OpenSeadragon.Viewport} Chainable.
         */
        _fitBounds: function(t, i) {
          i = i || {};
          var n = i.immediately || !1, o = i.constraints || !1, a = this.getAspectRatio(), l = t.getCenter(), h = new e.Rect(
            t.x,
            t.y,
            t.width,
            t.height,
            t.degrees + this.getRotation()
          ).getBoundingBox();
          h.getAspectRatio() >= a ? h.height = h.width / a : h.width = h.height * a, h.x = l.x - h.width / 2, h.y = l.y - h.height / 2;
          var d = 1 / h.width;
          if (n)
            return this.panTo(l, !0), this.zoomTo(d, null, !0), o && this.applyConstraints(!0), this;
          var f = this.getCenter(!0), g = this.getZoom(!0);
          this.panTo(f, !0), this.zoomTo(g, null, !0);
          var w = this.getBounds(), C = this.getZoom();
          if (C === 0 || Math.abs(d / C - 1) < 1e-8)
            return this.zoomTo(d, null, !0), this.panTo(l, n), o && this.applyConstraints(!1), this;
          if (o) {
            this.panTo(l, !1), d = this._applyZoomConstraints(d), this.zoomTo(d, null, !1);
            var E = this.getConstrainedBounds();
            this.panTo(f, !0), this.zoomTo(g, null, !0), this.fitBounds(E);
          } else {
            var A = h.rotate(-this.getRotation()), I = A.getTopLeft().times(d).minus(w.getTopLeft().times(C)).divide(d - C);
            this.zoomTo(d, I, n);
          }
          return this;
        },
        /**
         * Makes the viewport zoom and pan so that the specified bounds take
         * as much space as possible in the viewport.
         * Note: this method ignores the constraints (minZoom, maxZoom and
         * visibilityRatio).
         * Use {@link OpenSeadragon.Viewport#fitBoundsWithConstraints} to enforce
         * them.
         * @function
         * @param {OpenSeadragon.Rect} bounds
         * @param {Boolean} [immediately=false]
         * @returns {OpenSeadragon.Viewport} Chainable.
         */
        fitBounds: function(t, i) {
          return this._fitBounds(t, {
            immediately: i,
            constraints: !1
          });
        },
        /**
         * Makes the viewport zoom and pan so that the specified bounds take
         * as much space as possible in the viewport while enforcing the constraints
         * (minZoom, maxZoom and visibilityRatio).
         * Note: because this method enforces the constraints, part of the
         * provided bounds may end up outside of the viewport.
         * Use {@link OpenSeadragon.Viewport#fitBounds} to ignore them.
         * @function
         * @param {OpenSeadragon.Rect} bounds
         * @param {Boolean} [immediately=false]
         * @returns {OpenSeadragon.Viewport} Chainable.
         */
        fitBoundsWithConstraints: function(t, i) {
          return this._fitBounds(t, {
            immediately: i,
            constraints: !0
          });
        },
        /**
         * Zooms so the image just fills the viewer vertically.
         * @param {Boolean} immediately
         * @returns {OpenSeadragon.Viewport} Chainable.
         */
        fitVertically: function(t) {
          var i = new e.Rect(
            this._contentBounds.x + this._contentBounds.width / 2,
            this._contentBounds.y,
            0,
            this._contentBounds.height
          );
          return this.fitBounds(i, t);
        },
        /**
         * Zooms so the image just fills the viewer horizontally.
         * @param {Boolean} immediately
         * @returns {OpenSeadragon.Viewport} Chainable.
         */
        fitHorizontally: function(t) {
          var i = new e.Rect(
            this._contentBounds.x,
            this._contentBounds.y + this._contentBounds.height / 2,
            this._contentBounds.width,
            0
          );
          return this.fitBounds(i, t);
        },
        /**
         * Returns bounds taking constraints into account
         * Added to improve constrained panning
         * @param {Boolean} current - Pass true for the current location; defaults to false (target location).
         * @returns {OpenSeadragon.Rect} The bounds in viewport coordinates after applying constraints. The returned $.Rect
         *                               contains additional properties constraintsApplied, xConstrained and yConstrained.
         *                               These flags indicate whether the viewport bounds were modified by the constraints
         *                               of the viewer rectangle, and in which dimension(s).
         */
        getConstrainedBounds: function(t) {
          var i, n;
          return i = this.getBounds(t), n = this._applyBoundaryConstraints(i), n;
        },
        /**
         * @function
         * @param {OpenSeadragon.Point} delta
         * @param {Boolean} immediately
         * @returns {OpenSeadragon.Viewport} Chainable.
         * @fires OpenSeadragon.Viewer.event:pan
         */
        panBy: function(t, i) {
          var n = new e.Point(
            this.centerSpringX.target.value,
            this.centerSpringY.target.value
          );
          return this.panTo(n.plus(t), i);
        },
        /**
         * @function
         * @param {OpenSeadragon.Point} center
         * @param {Boolean} immediately
         * @returns {OpenSeadragon.Viewport} Chainable.
         * @fires OpenSeadragon.Viewer.event:pan
         */
        panTo: function(t, i) {
          return i ? (this.centerSpringX.resetTo(t.x), this.centerSpringY.resetTo(t.y)) : (this.centerSpringX.springTo(t.x), this.centerSpringY.springTo(t.y)), this.viewer && this.viewer.raiseEvent("pan", {
            center: t,
            immediately: i
          }), this;
        },
        /**
         * @function
         * @returns {OpenSeadragon.Viewport} Chainable.
         * @fires OpenSeadragon.Viewer.event:zoom
         */
        zoomBy: function(t, i, n) {
          return this.zoomTo(
            this.zoomSpring.target.value * t,
            i,
            n
          );
        },
        /**
         * Zooms to the specified zoom level
         * @function
         * @param {Number} zoom The zoom level to zoom to.
         * @param {OpenSeadragon.Point} [refPoint] The point which will stay at
         * the same screen location. Defaults to the viewport center.
         * @param {Boolean} [immediately=false]
         * @returns {OpenSeadragon.Viewport} Chainable.
         * @fires OpenSeadragon.Viewer.event:zoom
         */
        zoomTo: function(t, i, n) {
          var o = this;
          return this.zoomPoint = i instanceof e.Point && !isNaN(i.x) && !isNaN(i.y) ? i : null, n ? this._adjustCenterSpringsForZoomPoint(function() {
            o.zoomSpring.resetTo(t);
          }) : this.zoomSpring.springTo(t), this.viewer && this.viewer.raiseEvent("zoom", {
            zoom: t,
            refPoint: i,
            immediately: n
          }), this;
        },
        /**
         * Rotates this viewport to the angle specified.
         * @function
         * @param {Number} degrees The degrees to set the rotation to.
         * @param {Boolean} [immediately=false] Whether to animate to the new angle
         * or rotate immediately.
         * * @returns {OpenSeadragon.Viewport} Chainable.
         */
        setRotation: function(t, i) {
          return this.rotateTo(t, null, i);
        },
        /**
         * Gets the current rotation in degrees.
         * @function
         * @param {Boolean} [current=false] True for current rotation, false for target.
         * @returns {Number} The current rotation in degrees.
         */
        getRotation: function(t) {
          return t ? this.degreesSpring.current.value : this.degreesSpring.target.value;
        },
        /**
         * Rotates this viewport to the angle specified around a pivot point. Alias for rotateTo.
         * @function
         * @param {Number} degrees The degrees to set the rotation to.
         * @param {OpenSeadragon.Point} [pivot] (Optional) point in viewport coordinates
         * around which the rotation should be performed. Defaults to the center of the viewport.
         * @param {Boolean} [immediately=false] Whether to animate to the new angle
         * or rotate immediately.
         * * @returns {OpenSeadragon.Viewport} Chainable.
         */
        setRotationWithPivot: function(t, i, n) {
          return this.rotateTo(t, i, n);
        },
        /**
         * Rotates this viewport to the angle specified.
         * @function
         * @param {Number} degrees The degrees to set the rotation to.
         * @param {OpenSeadragon.Point} [pivot] (Optional) point in viewport coordinates
         * around which the rotation should be performed. Defaults to the center of the viewport.
         * @param {Boolean} [immediately=false] Whether to animate to the new angle
         * or rotate immediately.
         * @returns {OpenSeadragon.Viewport} Chainable.
         */
        rotateTo: function(t, i, n) {
          if (!this.viewer || !this.viewer.drawer.canRotate())
            return this;
          if (this.degreesSpring.target.value === t && this.degreesSpring.isAtTargetValue())
            return this;
          if (this.rotationPivot = i instanceof e.Point && !isNaN(i.x) && !isNaN(i.y) ? i : null, n)
            if (this.rotationPivot) {
              var o = t - this._oldDegrees;
              if (!o)
                return this.rotationPivot = null, this;
              this._rotateAboutPivot(t);
            } else
              this.degreesSpring.resetTo(t);
          else {
            var a = e.positiveModulo(this.degreesSpring.current.value, 360), l = e.positiveModulo(t, 360), h = l - a;
            h > 180 ? l -= 360 : h < -180 && (l += 360);
            var d = a - l;
            this.degreesSpring.resetTo(t + d), this.degreesSpring.springTo(t);
          }
          return this._setContentBounds(
            this.viewer.world.getHomeBounds(),
            this.viewer.world.getContentFactor()
          ), this.viewer.forceRedraw(), this.viewer.raiseEvent("rotate", { degrees: t, immediately: !!n, pivot: this.rotationPivot || this.getCenter() }), this;
        },
        /**
         * Rotates this viewport by the angle specified.
         * @function
         * @param {Number} degrees The degrees by which to rotate the viewport.
         * @param {OpenSeadragon.Point} [pivot] (Optional) point in viewport coordinates
         * around which the rotation should be performed. Defaults to the center of the viewport.
         * * @param {Boolean} [immediately=false] Whether to animate to the new angle
         * or rotate immediately.
         * @returns {OpenSeadragon.Viewport} Chainable.
         */
        rotateBy: function(t, i, n) {
          return this.rotateTo(this.degreesSpring.target.value + t, i, n);
        },
        /**
         * @function
         * @returns {OpenSeadragon.Viewport} Chainable.
         * @fires OpenSeadragon.Viewer.event:resize
         */
        resize: function(t, i) {
          var n = this.getBoundsNoRotate(), o = n, a;
          this.containerSize.x = t.x, this.containerSize.y = t.y, this._updateContainerInnerSize(), i && (a = t.x / this.containerSize.x, o.width = n.width * a, o.height = o.width / this.getAspectRatio()), this.viewer && this.viewer.raiseEvent("resize", {
            newContainerSize: t,
            maintain: i
          });
          var l = this.fitBounds(o, !0);
          return this.viewer && this.viewer.raiseEvent("after-resize", {
            newContainerSize: t,
            maintain: i
          }), l;
        },
        // private
        _updateContainerInnerSize: function() {
          this._containerInnerSize = new e.Point(
            Math.max(1, this.containerSize.x - (this._margins.left + this._margins.right)),
            Math.max(1, this.containerSize.y - (this._margins.top + this._margins.bottom))
          );
        },
        /**
         * Update the zoom, degrees, and center (X and Y) springs.
         * @function
         * @returns {Boolean} True if the viewport is still animating, false otherwise.
         */
        update: function() {
          var t = this;
          this._adjustCenterSpringsForZoomPoint(function() {
            t.zoomSpring.update();
          }), this.degreesSpring.isAtTargetValue() && (this.rotationPivot = null), this.centerSpringX.update(), this.centerSpringY.update(), this.rotationPivot ? this._rotateAboutPivot(!0) : this.degreesSpring.update();
          var i = this.centerSpringX.current.value !== this._oldCenterX || this.centerSpringY.current.value !== this._oldCenterY || this.zoomSpring.current.value !== this._oldZoom || this.degreesSpring.current.value !== this._oldDegrees;
          this._oldCenterX = this.centerSpringX.current.value, this._oldCenterY = this.centerSpringY.current.value, this._oldZoom = this.zoomSpring.current.value, this._oldDegrees = this.degreesSpring.current.value;
          var n = i || !this.zoomSpring.isAtTargetValue() || !this.centerSpringX.isAtTargetValue() || !this.centerSpringY.isAtTargetValue() || !this.degreesSpring.isAtTargetValue();
          return n;
        },
        // private - pass true to use spring, or a number for degrees for immediate rotation
        _rotateAboutPivot: function(t) {
          var i = t === !0, n = this.rotationPivot.minus(this.getCenter());
          this.centerSpringX.shiftBy(n.x), this.centerSpringY.shiftBy(n.y), i ? this.degreesSpring.update() : this.degreesSpring.resetTo(t);
          var o = this.degreesSpring.current.value - this._oldDegrees, a = n.rotate(o * -1).times(-1);
          this.centerSpringX.shiftBy(a.x), this.centerSpringY.shiftBy(a.y);
        },
        // private
        _adjustCenterSpringsForZoomPoint: function(t) {
          if (this.zoomPoint) {
            var i = this.pixelFromPoint(this.zoomPoint, !0);
            t();
            var n = this.pixelFromPoint(this.zoomPoint, !0), o = n.minus(i), a = this.deltaPointsFromPixels(
              o,
              !0
            );
            this.centerSpringX.shiftBy(a.x), this.centerSpringY.shiftBy(a.y), this.zoomSpring.isAtTargetValue() && (this.zoomPoint = null);
          } else
            t();
        },
        /**
         * Convert a delta (translation vector) from viewport coordinates to pixels
         * coordinates. This method does not take rotation into account.
         * Consider using deltaPixelsFromPoints if you need to account for rotation.
         * @param {OpenSeadragon.Point} deltaPoints - The translation vector to convert.
         * @param {Boolean} [current=false] - Pass true for the current location;
         * defaults to false (target location).
         * @returns {OpenSeadragon.Point}
         */
        deltaPixelsFromPointsNoRotate: function(t, i) {
          return t.times(
            this._containerInnerSize.x * this.getZoom(i)
          );
        },
        /**
         * Convert a delta (translation vector) from viewport coordinates to pixels
         * coordinates.
         * @param {OpenSeadragon.Point} deltaPoints - The translation vector to convert.
         * @param {Boolean} [current=false] - Pass true for the current location;
         * defaults to false (target location).
         * @returns {OpenSeadragon.Point}
         */
        deltaPixelsFromPoints: function(t, i) {
          return this.deltaPixelsFromPointsNoRotate(
            t.rotate(this.getRotation(i)),
            i
          );
        },
        /**
         * Convert a delta (translation vector) from pixels coordinates to viewport
         * coordinates. This method does not take rotation into account.
         * Consider using deltaPointsFromPixels if you need to account for rotation.
         * @param {OpenSeadragon.Point} deltaPixels - The translation vector to convert.
         * @param {Boolean} [current=false] - Pass true for the current location;
         * defaults to false (target location).
         * @returns {OpenSeadragon.Point}
         */
        deltaPointsFromPixelsNoRotate: function(t, i) {
          return t.divide(
            this._containerInnerSize.x * this.getZoom(i)
          );
        },
        /**
         * Convert a delta (translation vector) from pixels coordinates to viewport
         * coordinates.
         * @param {OpenSeadragon.Point} deltaPixels - The translation vector to convert.
         * @param {Boolean} [current=false] - Pass true for the current location;
         * defaults to false (target location).
         * @returns {OpenSeadragon.Point}
         */
        deltaPointsFromPixels: function(t, i) {
          return this.deltaPointsFromPixelsNoRotate(t, i).rotate(-this.getRotation(i));
        },
        /**
         * Convert viewport coordinates to pixels coordinates.
         * This method does not take rotation into account.
         * Consider using pixelFromPoint if you need to account for rotation.
         * @param {OpenSeadragon.Point} point the viewport coordinates
         * @param {Boolean} [current=false] - Pass true for the current location;
         * defaults to false (target location).
         * @returns {OpenSeadragon.Point}
         */
        pixelFromPointNoRotate: function(t, i) {
          return this._pixelFromPointNoRotate(
            t,
            this.getBoundsNoRotate(i)
          );
        },
        /**
         * Convert viewport coordinates to pixel coordinates.
         * @param {OpenSeadragon.Point} point the viewport coordinates
         * @param {Boolean} [current=false] - Pass true for the current location;
         * defaults to false (target location).
         * @returns {OpenSeadragon.Point}
         */
        pixelFromPoint: function(t, i) {
          return this._pixelFromPoint(t, this.getBoundsNoRotate(i));
        },
        // private
        _pixelFromPointNoRotate: function(t, i) {
          return t.minus(
            i.getTopLeft()
          ).times(
            this._containerInnerSize.x / i.width
          ).plus(
            new e.Point(this._margins.left, this._margins.top)
          );
        },
        // private
        _pixelFromPoint: function(t, i) {
          return this._pixelFromPointNoRotate(
            t.rotate(this.getRotation(!0), this.getCenter(!0)),
            i
          );
        },
        /**
         * Convert pixel coordinates to viewport coordinates.
         * This method does not take rotation into account.
         * Consider using pointFromPixel if you need to account for rotation.
         * @param {OpenSeadragon.Point} pixel Pixel coordinates
         * @param {Boolean} [current=false] - Pass true for the current location;
         * defaults to false (target location).
         * @returns {OpenSeadragon.Point}
         */
        pointFromPixelNoRotate: function(t, i) {
          var n = this.getBoundsNoRotate(i);
          return t.minus(
            new e.Point(this._margins.left, this._margins.top)
          ).divide(
            this._containerInnerSize.x / n.width
          ).plus(
            n.getTopLeft()
          );
        },
        /**
         * Convert pixel coordinates to viewport coordinates.
         * @param {OpenSeadragon.Point} pixel Pixel coordinates
         * @param {Boolean} [current=false] - Pass true for the current location;
         * defaults to false (target location).
         * @returns {OpenSeadragon.Point}
         */
        pointFromPixel: function(t, i) {
          return this.pointFromPixelNoRotate(t, i).rotate(
            -this.getRotation(i),
            this.getCenter(i)
          );
        },
        // private
        _viewportToImageDelta: function(t, i) {
          var n = this._contentBoundsNoRotate.width;
          return new e.Point(
            t * this._contentSizeNoRotate.x / n,
            i * this._contentSizeNoRotate.x / n
          );
        },
        /**
         * Translates from OpenSeadragon viewer coordinate system to image coordinate system.
         * This method can be called either by passing X,Y coordinates or an
         * OpenSeadragon.Point
         * Note: not accurate with multi-image; use TiledImage.viewportToImageCoordinates instead.
         * @function
         * @param {(OpenSeadragon.Point|Number)} viewerX either a point or the X
         * coordinate in viewport coordinate system.
         * @param {Number} [viewerY] Y coordinate in viewport coordinate system.
         * @returns {OpenSeadragon.Point} a point representing the coordinates in the image.
         */
        viewportToImageCoordinates: function(t, i) {
          if (t instanceof e.Point)
            return this.viewportToImageCoordinates(t.x, t.y);
          if (this.viewer) {
            var n = this.viewer.world.getItemCount();
            if (n > 1)
              this.silenceMultiImageWarnings || e.console.error("[Viewport.viewportToImageCoordinates] is not accurate with multi-image; use TiledImage.viewportToImageCoordinates instead.");
            else if (n === 1) {
              var o = this.viewer.world.getItemAt(0);
              return o.viewportToImageCoordinates(t, i, !0);
            }
          }
          return this._viewportToImageDelta(
            t - this._contentBoundsNoRotate.x,
            i - this._contentBoundsNoRotate.y
          );
        },
        // private
        _imageToViewportDelta: function(t, i) {
          var n = this._contentBoundsNoRotate.width;
          return new e.Point(
            t / this._contentSizeNoRotate.x * n,
            i / this._contentSizeNoRotate.x * n
          );
        },
        /**
         * Translates from image coordinate system to OpenSeadragon viewer coordinate system
         * This method can be called either by passing X,Y coordinates or an
         * OpenSeadragon.Point
         * Note: not accurate with multi-image; use TiledImage.imageToViewportCoordinates instead.
         * @function
         * @param {(OpenSeadragon.Point | Number)} imageX the point or the
         * X coordinate in image coordinate system.
         * @param {Number} [imageY] Y coordinate in image coordinate system.
         * @returns {OpenSeadragon.Point} a point representing the coordinates in the viewport.
         */
        imageToViewportCoordinates: function(t, i) {
          if (t instanceof e.Point)
            return this.imageToViewportCoordinates(t.x, t.y);
          if (this.viewer) {
            var n = this.viewer.world.getItemCount();
            if (n > 1)
              this.silenceMultiImageWarnings || e.console.error("[Viewport.imageToViewportCoordinates] is not accurate with multi-image; use TiledImage.imageToViewportCoordinates instead.");
            else if (n === 1) {
              var o = this.viewer.world.getItemAt(0);
              return o.imageToViewportCoordinates(t, i, !0);
            }
          }
          var a = this._imageToViewportDelta(t, i);
          return a.x += this._contentBoundsNoRotate.x, a.y += this._contentBoundsNoRotate.y, a;
        },
        /**
         * Translates from a rectangle which describes a portion of the image in
         * pixel coordinates to OpenSeadragon viewport rectangle coordinates.
         * This method can be called either by passing X,Y,width,height or an
         * OpenSeadragon.Rect
         * Note: not accurate with multi-image; use TiledImage.imageToViewportRectangle instead.
         * @function
         * @param {(OpenSeadragon.Rect | Number)} imageX the rectangle or the X
         * coordinate of the top left corner of the rectangle in image coordinate system.
         * @param {Number} [imageY] the Y coordinate of the top left corner of the rectangle
         * in image coordinate system.
         * @param {Number} [pixelWidth] the width in pixel of the rectangle.
         * @param {Number} [pixelHeight] the height in pixel of the rectangle.
         * @returns {OpenSeadragon.Rect} This image's bounds in viewport coordinates
         */
        imageToViewportRectangle: function(t, i, n, o) {
          var a = t;
          if (a instanceof e.Rect || (a = new e.Rect(t, i, n, o)), this.viewer) {
            var l = this.viewer.world.getItemCount();
            if (l > 1)
              this.silenceMultiImageWarnings || e.console.error("[Viewport.imageToViewportRectangle] is not accurate with multi-image; use TiledImage.imageToViewportRectangle instead.");
            else if (l === 1) {
              var h = this.viewer.world.getItemAt(0);
              return h.imageToViewportRectangle(
                t,
                i,
                n,
                o,
                !0
              );
            }
          }
          var d = this.imageToViewportCoordinates(a.x, a.y), f = this._imageToViewportDelta(a.width, a.height);
          return new e.Rect(
            d.x,
            d.y,
            f.x,
            f.y,
            a.degrees
          );
        },
        /**
         * Translates from a rectangle which describes a portion of
         * the viewport in point coordinates to image rectangle coordinates.
         * This method can be called either by passing X,Y,width,height or an
         * OpenSeadragon.Rect
         * Note: not accurate with multi-image; use TiledImage.viewportToImageRectangle instead.
         * @function
         * @param {(OpenSeadragon.Rect | Number)} viewerX either a rectangle or
         * the X coordinate of the top left corner of the rectangle in viewport
         * coordinate system.
         * @param {Number} [viewerY] the Y coordinate of the top left corner of the rectangle
         * in viewport coordinate system.
         * @param {Number} [pointWidth] the width of the rectangle in viewport coordinate system.
         * @param {Number} [pointHeight] the height of the rectangle in viewport coordinate system.
         */
        viewportToImageRectangle: function(t, i, n, o) {
          var a = t;
          if (a instanceof e.Rect || (a = new e.Rect(t, i, n, o)), this.viewer) {
            var l = this.viewer.world.getItemCount();
            if (l > 1)
              this.silenceMultiImageWarnings || e.console.error("[Viewport.viewportToImageRectangle] is not accurate with multi-image; use TiledImage.viewportToImageRectangle instead.");
            else if (l === 1) {
              var h = this.viewer.world.getItemAt(0);
              return h.viewportToImageRectangle(
                t,
                i,
                n,
                o,
                !0
              );
            }
          }
          var d = this.viewportToImageCoordinates(a.x, a.y), f = this._viewportToImageDelta(a.width, a.height);
          return new e.Rect(
            d.x,
            d.y,
            f.x,
            f.y,
            a.degrees
          );
        },
        /**
         * Convert pixel coordinates relative to the viewer element to image
         * coordinates.
         * Note: not accurate with multi-image.
         * @param {OpenSeadragon.Point} pixel
         * @returns {OpenSeadragon.Point}
         */
        viewerElementToImageCoordinates: function(t) {
          var i = this.pointFromPixel(t, !0);
          return this.viewportToImageCoordinates(i);
        },
        /**
         * Convert pixel coordinates relative to the image to
         * viewer element coordinates.
         * Note: not accurate with multi-image.
         * @param {OpenSeadragon.Point} pixel
         * @returns {OpenSeadragon.Point}
         */
        imageToViewerElementCoordinates: function(t) {
          var i = this.imageToViewportCoordinates(t);
          return this.pixelFromPoint(i, !0);
        },
        /**
         * Convert pixel coordinates relative to the window to image coordinates.
         * Note: not accurate with multi-image.
         * @param {OpenSeadragon.Point} pixel
         * @returns {OpenSeadragon.Point}
         */
        windowToImageCoordinates: function(t) {
          e.console.assert(
            this.viewer,
            "[Viewport.windowToImageCoordinates] the viewport must have a viewer."
          );
          var i = t.minus(
            e.getElementPosition(this.viewer.element)
          );
          return this.viewerElementToImageCoordinates(i);
        },
        /**
         * Convert image coordinates to pixel coordinates relative to the window.
         * Note: not accurate with multi-image.
         * @param {OpenSeadragon.Point} pixel
         * @returns {OpenSeadragon.Point}
         */
        imageToWindowCoordinates: function(t) {
          e.console.assert(
            this.viewer,
            "[Viewport.imageToWindowCoordinates] the viewport must have a viewer."
          );
          var i = this.imageToViewerElementCoordinates(t);
          return i.plus(
            e.getElementPosition(this.viewer.element)
          );
        },
        /**
         * Convert pixel coordinates relative to the viewer element to viewport
         * coordinates.
         * @param {OpenSeadragon.Point} pixel
         * @returns {OpenSeadragon.Point}
         */
        viewerElementToViewportCoordinates: function(t) {
          return this.pointFromPixel(t, !0);
        },
        /**
         * Convert viewport coordinates to pixel coordinates relative to the
         * viewer element.
         * @param {OpenSeadragon.Point} point
         * @returns {OpenSeadragon.Point}
         */
        viewportToViewerElementCoordinates: function(t) {
          return this.pixelFromPoint(t, !0);
        },
        /**
         * Convert a rectangle in pixel coordinates relative to the viewer element
         * to viewport coordinates.
         * @param {OpenSeadragon.Rect} rectangle the rectangle to convert
         * @returns {OpenSeadragon.Rect} the converted rectangle
         */
        viewerElementToViewportRectangle: function(t) {
          return e.Rect.fromSummits(
            this.pointFromPixel(t.getTopLeft(), !0),
            this.pointFromPixel(t.getTopRight(), !0),
            this.pointFromPixel(t.getBottomLeft(), !0)
          );
        },
        /**
         * Convert a rectangle in viewport coordinates to pixel coordinates relative
         * to the viewer element.
         * @param {OpenSeadragon.Rect} rectangle the rectangle to convert
         * @returns {OpenSeadragon.Rect} the converted rectangle
         */
        viewportToViewerElementRectangle: function(t) {
          return e.Rect.fromSummits(
            this.pixelFromPoint(t.getTopLeft(), !0),
            this.pixelFromPoint(t.getTopRight(), !0),
            this.pixelFromPoint(t.getBottomLeft(), !0)
          );
        },
        /**
         * Convert pixel coordinates relative to the window to viewport coordinates.
         * @param {OpenSeadragon.Point} pixel
         * @returns {OpenSeadragon.Point}
         */
        windowToViewportCoordinates: function(t) {
          e.console.assert(
            this.viewer,
            "[Viewport.windowToViewportCoordinates] the viewport must have a viewer."
          );
          var i = t.minus(
            e.getElementPosition(this.viewer.element)
          );
          return this.viewerElementToViewportCoordinates(i);
        },
        /**
         * Convert viewport coordinates to pixel coordinates relative to the window.
         * @param {OpenSeadragon.Point} point
         * @returns {OpenSeadragon.Point}
         */
        viewportToWindowCoordinates: function(t) {
          e.console.assert(
            this.viewer,
            "[Viewport.viewportToWindowCoordinates] the viewport must have a viewer."
          );
          var i = this.viewportToViewerElementCoordinates(t);
          return i.plus(
            e.getElementPosition(this.viewer.element)
          );
        },
        /**
         * Convert a viewport zoom to an image zoom.
         * Image zoom: ratio of the original image size to displayed image size.
         * 1 means original image size, 0.5 half size...
         * Viewport zoom: ratio of the displayed image's width to viewport's width.
         * 1 means identical width, 2 means image's width is twice the viewport's width...
         * Note: not accurate with multi-image.
         * @function
         * @param {Number} viewportZoom The viewport zoom
         * target zoom.
         * @returns {Number} imageZoom The image zoom
         */
        viewportToImageZoom: function(t) {
          if (this.viewer) {
            var i = this.viewer.world.getItemCount();
            if (i > 1)
              this.silenceMultiImageWarnings || e.console.error("[Viewport.viewportToImageZoom] is not accurate with multi-image.");
            else if (i === 1) {
              var n = this.viewer.world.getItemAt(0);
              return n.viewportToImageZoom(t);
            }
          }
          var o = this._contentSizeNoRotate.x, a = this._containerInnerSize.x, l = this._contentBoundsNoRotate.width, h = a / o * l;
          return t * h;
        },
        /**
         * Convert an image zoom to a viewport zoom.
         * Image zoom: ratio of the original image size to displayed image size.
         * 1 means original image size, 0.5 half size...
         * Viewport zoom: ratio of the displayed image's width to viewport's width.
         * 1 means identical width, 2 means image's width is twice the viewport's width...
         * Note: not accurate with multi-image; use [TiledImage.imageToViewportZoom] for the specific image of interest.
         * @function
         * @param {Number} imageZoom The image zoom
         * target zoom.
         * @returns {Number} viewportZoom The viewport zoom
         */
        imageToViewportZoom: function(t) {
          if (this.viewer) {
            var i = this.viewer.world.getItemCount();
            if (i > 1)
              this.silenceMultiImageWarnings || e.console.error("[Viewport.imageToViewportZoom] is not accurate with multi-image. Instead, use [TiledImage.imageToViewportZoom] for the specific image of interest");
            else if (i === 1) {
              var n = this.viewer.world.getItemAt(0);
              return n.imageToViewportZoom(t);
            }
          }
          var o = this._contentSizeNoRotate.x, a = this._containerInnerSize.x, l = this._contentBoundsNoRotate.width, h = o / a / l;
          return t * h;
        },
        /**
         * Toggles flip state and demands a new drawing on navigator and viewer objects.
         * @function
         * @returns {OpenSeadragon.Viewport} Chainable.
         */
        toggleFlip: function() {
          return this.setFlip(!this.getFlip()), this;
        },
        /**
         * Get flip state stored on viewport.
         * @function
         * @returns {Boolean} Flip state.
         */
        getFlip: function() {
          return this.flipped;
        },
        /**
         * Sets flip state according to the state input argument.
         * @function
         * @param {Boolean} state - Flip state to set.
         * @returns {OpenSeadragon.Viewport} Chainable.
         */
        setFlip: function(t) {
          return this.flipped === t ? this : (this.flipped = t, this.viewer.navigator && this.viewer.navigator.setFlip(this.getFlip()), this.viewer.forceRedraw(), this.viewer.raiseEvent("flip", { flipped: t }), this);
        },
        /**
         * Gets current max zoom pixel ratio
         * @function
         * @returns {Number} Max zoom pixel ratio
         */
        getMaxZoomPixelRatio: function() {
          return this.maxZoomPixelRatio;
        },
        /**
         * Sets max zoom pixel ratio
         * @function
         * @param {Number} ratio - Max zoom pixel ratio
         * @param {Boolean} [applyConstraints=true] - Apply constraints after setting ratio;
         * Takes effect only if current zoom is greater than set max zoom pixel ratio
         * @param {Boolean} [immediately=false] - Whether to animate to new zoom
         */
        setMaxZoomPixelRatio: function(t, i = !0, n = !1) {
          e.console.assert(!isNaN(t), "[Viewport.setMaxZoomPixelRatio] ratio must be a number"), !isNaN(t) && (this.maxZoomPixelRatio = t, i && this.getZoom() > this.getMaxZoom() && this.applyConstraints(n));
        }
      };
    }(r), function(e) {
      e.TiledImage = function(t) {
        this._initialized = !1, e.console.assert(t.tileCache, "[TiledImage] options.tileCache is required"), e.console.assert(t.drawer, "[TiledImage] options.drawer is required"), e.console.assert(t.viewer, "[TiledImage] options.viewer is required"), e.console.assert(t.imageLoader, "[TiledImage] options.imageLoader is required"), e.console.assert(t.source, "[TiledImage] options.source is required"), e.console.assert(
          !t.clip || t.clip instanceof e.Rect,
          "[TiledImage] options.clip must be an OpenSeadragon.Rect if present"
        ), e.EventSource.call(this), this._tileCache = t.tileCache, delete t.tileCache, this._drawer = t.drawer, delete t.drawer, this._imageLoader = t.imageLoader, delete t.imageLoader, t.clip instanceof e.Rect && (this._clip = t.clip.clone()), delete t.clip;
        var i = t.x || 0;
        delete t.x;
        var n = t.y || 0;
        delete t.y, this.normHeight = t.source.dimensions.y / t.source.dimensions.x, this.contentAspectX = t.source.dimensions.x / t.source.dimensions.y;
        var o = 1;
        t.width ? (o = t.width, delete t.width, t.height && (e.console.error("specifying both width and height to a tiledImage is not supported"), delete t.height)) : t.height && (o = t.height / this.normHeight, delete t.height);
        var a = t.fitBounds;
        delete t.fitBounds;
        var l = t.fitBoundsPlacement || r.Placement.CENTER;
        delete t.fitBoundsPlacement;
        var h = t.degrees || 0;
        delete t.degrees;
        var d = t.ajaxHeaders;
        delete t.ajaxHeaders, e.extend(!0, this, {
          //internal state properties
          viewer: null,
          tilesMatrix: {},
          // A '3d' dictionary [level][x][y] --> Tile.
          coverage: {},
          // A '3d' dictionary [level][x][y] --> Boolean; shows what areas have been drawn.
          loadingCoverage: {},
          // A '3d' dictionary [level][x][y] --> Boolean; shows what areas are loaded or are being loaded/blended.
          lastDrawn: [],
          // An unordered list of Tiles drawn last frame.
          lastResetTime: 0,
          // Last time for which the tiledImage was reset.
          _needsDraw: !0,
          // Does the tiledImage need to be drawn again?
          _needsUpdate: !0,
          // Does the tiledImage need to update the viewport again?
          _hasOpaqueTile: !1,
          // Do we have even one fully opaque tile?
          _tilesLoading: 0,
          // The number of pending tile requests.
          _tilesToDraw: [],
          // info about the tiles currently in the viewport, two deep: array[level][tile]
          _lastDrawn: [],
          // array of tiles that were last fetched by the drawer
          _isBlending: !1,
          // Are any tiles still being blended?
          _wasBlending: !1,
          // Were any tiles blending before the last draw?
          _isTainted: !1,
          // Has a Tile been found with tainted data?
          //configurable settings
          springStiffness: e.DEFAULT_SETTINGS.springStiffness,
          animationTime: e.DEFAULT_SETTINGS.animationTime,
          minZoomImageRatio: e.DEFAULT_SETTINGS.minZoomImageRatio,
          wrapHorizontal: e.DEFAULT_SETTINGS.wrapHorizontal,
          wrapVertical: e.DEFAULT_SETTINGS.wrapVertical,
          immediateRender: e.DEFAULT_SETTINGS.immediateRender,
          blendTime: e.DEFAULT_SETTINGS.blendTime,
          alwaysBlend: e.DEFAULT_SETTINGS.alwaysBlend,
          minPixelRatio: e.DEFAULT_SETTINGS.minPixelRatio,
          smoothTileEdgesMinZoom: e.DEFAULT_SETTINGS.smoothTileEdgesMinZoom,
          iOSDevice: e.DEFAULT_SETTINGS.iOSDevice,
          debugMode: e.DEFAULT_SETTINGS.debugMode,
          crossOriginPolicy: e.DEFAULT_SETTINGS.crossOriginPolicy,
          ajaxWithCredentials: e.DEFAULT_SETTINGS.ajaxWithCredentials,
          placeholderFillStyle: e.DEFAULT_SETTINGS.placeholderFillStyle,
          opacity: e.DEFAULT_SETTINGS.opacity,
          preload: e.DEFAULT_SETTINGS.preload,
          compositeOperation: e.DEFAULT_SETTINGS.compositeOperation,
          subPixelRoundingForTransparency: e.DEFAULT_SETTINGS.subPixelRoundingForTransparency,
          maxTilesPerFrame: e.DEFAULT_SETTINGS.maxTilesPerFrame
        }, t), this._preload = this.preload, delete this.preload, this._fullyLoaded = !1, this._xSpring = new e.Spring({
          initial: i,
          springStiffness: this.springStiffness,
          animationTime: this.animationTime
        }), this._ySpring = new e.Spring({
          initial: n,
          springStiffness: this.springStiffness,
          animationTime: this.animationTime
        }), this._scaleSpring = new e.Spring({
          initial: o,
          springStiffness: this.springStiffness,
          animationTime: this.animationTime
        }), this._degreesSpring = new e.Spring({
          initial: h,
          springStiffness: this.springStiffness,
          animationTime: this.animationTime
        }), this._updateForScale(), a && this.fitBounds(a, l, !0), this._ownAjaxHeaders = {}, this.setAjaxHeaders(d, !1), this._initialized = !0;
      }, e.extend(
        e.TiledImage.prototype,
        e.EventSource.prototype,
        /** @lends OpenSeadragon.TiledImage.prototype */
        {
          /**
           * @returns {Boolean} Whether the TiledImage needs to be drawn.
           */
          needsDraw: function() {
            return this._needsDraw;
          },
          /**
           * Mark the tiled image as needing to be (re)drawn
           */
          redraw: function() {
            this._needsDraw = !0;
          },
          /**
           * @returns {Boolean} Whether all tiles necessary for this TiledImage to draw at the current view have been loaded.
           */
          getFullyLoaded: function() {
            return this._fullyLoaded;
          },
          // private
          _setFullyLoaded: function(t) {
            t !== this._fullyLoaded && (this._fullyLoaded = t, this.raiseEvent("fully-loaded-change", {
              fullyLoaded: this._fullyLoaded
            }));
          },
          /**
           * Clears all tiles and triggers an update on the next call to
           * {@link OpenSeadragon.TiledImage#update}.
           */
          reset: function() {
            this._tileCache.clearTilesFor(this), this.lastResetTime = e.now(), this._needsDraw = !0;
          },
          /**
           * Updates the TiledImage's bounds, animating if needed. Based on the new
           * bounds, updates the levels and tiles to be drawn into the viewport.
           * @param viewportChanged Whether the viewport changed meaning tiles need to be updated.
           * @returns {Boolean} Whether the TiledImage needs to be drawn.
           */
          update: function(t) {
            let i = this._xSpring.update(), n = this._ySpring.update(), o = this._scaleSpring.update(), a = this._degreesSpring.update(), l = i || n || o || a || this._needsUpdate;
            if (l || t || !this._fullyLoaded) {
              let h = this._updateLevelsForViewport();
              this._setFullyLoaded(h);
            }
            return this._needsUpdate = !1, l ? (this._updateForScale(), this._raiseBoundsChange(), this._needsDraw = !0, !0) : !1;
          },
          /**
           * Mark this TiledImage as having been drawn, so that it will only be drawn
           * again if something changes about the image. If the image is still blending,
           * this will have no effect.
           * @returns {Boolean} whether the item still needs to be drawn due to blending
           */
          setDrawn: function() {
            return this._needsDraw = this._isBlending || this._wasBlending, this._needsDraw;
          },
          /**
           * Set the internal _isTainted flag for this TiledImage. Lazy loaded - not
           * checked each time a Tile is loaded, but can be set if a consumer of the
           * tiles (e.g. a Drawer) discovers a Tile to have tainted data so that further
           * checks are not needed and alternative rendering strategies can be used.
           * @private
           */
          setTainted(t) {
            this._isTainted = t;
          },
          /**
           * @private
           * @returns {Boolean} whether the TiledImage has been marked as tainted
           */
          isTainted() {
            return this._isTainted;
          },
          /**
           * Destroy the TiledImage (unload current loaded tiles).
           */
          destroy: function() {
            this.reset(), this.source.destroy && this.source.destroy(this.viewer);
          },
          /**
           * Get this TiledImage's bounds in viewport coordinates.
           * @param {Boolean} [current=false] - Pass true for the current location;
           * false for target location.
           * @returns {OpenSeadragon.Rect} This TiledImage's bounds in viewport coordinates.
           */
          getBounds: function(t) {
            return this.getBoundsNoRotate(t).rotate(this.getRotation(t), this._getRotationPoint(t));
          },
          /**
           * Get this TiledImage's bounds in viewport coordinates without taking
           * rotation into account.
           * @param {Boolean} [current=false] - Pass true for the current location;
           * false for target location.
           * @returns {OpenSeadragon.Rect} This TiledImage's bounds in viewport coordinates.
           */
          getBoundsNoRotate: function(t) {
            return t ? new e.Rect(
              this._xSpring.current.value,
              this._ySpring.current.value,
              this._worldWidthCurrent,
              this._worldHeightCurrent
            ) : new e.Rect(
              this._xSpring.target.value,
              this._ySpring.target.value,
              this._worldWidthTarget,
              this._worldHeightTarget
            );
          },
          // deprecated
          getWorldBounds: function() {
            return e.console.error("[TiledImage.getWorldBounds] is deprecated; use TiledImage.getBounds instead"), this.getBounds();
          },
          /**
           * Get the bounds of the displayed part of the tiled image.
           * @param {Boolean} [current=false] Pass true for the current location,
           * false for the target location.
           * @returns {$.Rect} The clipped bounds in viewport coordinates.
           */
          getClippedBounds: function(t) {
            var i = this.getBoundsNoRotate(t);
            if (this._clip) {
              var n = t ? this._worldWidthCurrent : this._worldWidthTarget, o = n / this.source.dimensions.x, a = this._clip.times(o);
              i = new e.Rect(
                i.x + a.x,
                i.y + a.y,
                a.width,
                a.height
              );
            }
            return i.rotate(this.getRotation(t), this._getRotationPoint(t));
          },
          /**
           * @function
           * @param {Number} level
           * @param {Number} x
           * @param {Number} y
           * @returns {OpenSeadragon.Rect} Where this tile fits (in normalized coordinates).
           */
          getTileBounds: function(t, i, n) {
            var o = this.source.getNumTiles(t), a = (o.x + i % o.x) % o.x, l = (o.y + n % o.y) % o.y, h = this.source.getTileBounds(t, a, l);
            return this.getFlip() && (h.x = Math.max(0, 1 - h.x - h.width)), h.x += (i - a) / o.x, h.y += this._worldHeightCurrent / this._worldWidthCurrent * ((n - l) / o.y), h;
          },
          /**
           * @returns {OpenSeadragon.Point} This TiledImage's content size, in original pixels.
           */
          getContentSize: function() {
            return new e.Point(this.source.dimensions.x, this.source.dimensions.y);
          },
          /**
           * @returns {OpenSeadragon.Point} The TiledImage's content size, in window coordinates.
           */
          getSizeInWindowCoordinates: function() {
            var t = this.imageToWindowCoordinates(new e.Point(0, 0)), i = this.imageToWindowCoordinates(this.getContentSize());
            return new e.Point(i.x - t.x, i.y - t.y);
          },
          // private
          _viewportToImageDelta: function(t, i, n) {
            var o = n ? this._scaleSpring.current.value : this._scaleSpring.target.value;
            return new e.Point(
              t * (this.source.dimensions.x / o),
              i * (this.source.dimensions.y * this.contentAspectX / o)
            );
          },
          /**
           * Translates from OpenSeadragon viewer coordinate system to image coordinate system.
           * This method can be called either by passing X,Y coordinates or an {@link OpenSeadragon.Point}.
           * @param {Number|OpenSeadragon.Point} viewerX - The X coordinate or point in viewport coordinate system.
           * @param {Number} [viewerY] - The Y coordinate in viewport coordinate system.
           * @param {Boolean} [current=false] - Pass true to use the current location; false for target location.
           * @returns {OpenSeadragon.Point} A point representing the coordinates in the image.
           */
          viewportToImageCoordinates: function(t, i, n) {
            var o;
            return t instanceof e.Point ? (n = i, o = t) : o = new e.Point(t, i), o = o.rotate(-this.getRotation(n), this._getRotationPoint(n)), n ? this._viewportToImageDelta(
              o.x - this._xSpring.current.value,
              o.y - this._ySpring.current.value
            ) : this._viewportToImageDelta(
              o.x - this._xSpring.target.value,
              o.y - this._ySpring.target.value
            );
          },
          // private
          _imageToViewportDelta: function(t, i, n) {
            var o = n ? this._scaleSpring.current.value : this._scaleSpring.target.value;
            return new e.Point(
              t / this.source.dimensions.x * o,
              i / this.source.dimensions.y / this.contentAspectX * o
            );
          },
          /**
           * Translates from image coordinate system to OpenSeadragon viewer coordinate system
           * This method can be called either by passing X,Y coordinates or an {@link OpenSeadragon.Point}.
           * @param {Number|OpenSeadragon.Point} imageX - The X coordinate or point in image coordinate system.
           * @param {Number} [imageY] - The Y coordinate in image coordinate system.
           * @param {Boolean} [current=false] - Pass true to use the current location; false for target location.
           * @returns {OpenSeadragon.Point} A point representing the coordinates in the viewport.
           */
          imageToViewportCoordinates: function(t, i, n) {
            t instanceof e.Point && (n = i, i = t.y, t = t.x);
            var o = this._imageToViewportDelta(t, i, n);
            return n ? (o.x += this._xSpring.current.value, o.y += this._ySpring.current.value) : (o.x += this._xSpring.target.value, o.y += this._ySpring.target.value), o.rotate(this.getRotation(n), this._getRotationPoint(n));
          },
          /**
           * Translates from a rectangle which describes a portion of the image in
           * pixel coordinates to OpenSeadragon viewport rectangle coordinates.
           * This method can be called either by passing X,Y,width,height or an {@link OpenSeadragon.Rect}.
           * @param {Number|OpenSeadragon.Rect} imageX - The left coordinate or rectangle in image coordinate system.
           * @param {Number} [imageY] - The top coordinate in image coordinate system.
           * @param {Number} [pixelWidth] - The width in pixel of the rectangle.
           * @param {Number} [pixelHeight] - The height in pixel of the rectangle.
           * @param {Boolean} [current=false] - Pass true to use the current location; false for target location.
           * @returns {OpenSeadragon.Rect} A rect representing the coordinates in the viewport.
           */
          imageToViewportRectangle: function(t, i, n, o, a) {
            var l = t;
            l instanceof e.Rect ? a = i : l = new e.Rect(t, i, n, o);
            var h = this.imageToViewportCoordinates(l.getTopLeft(), a), d = this._imageToViewportDelta(l.width, l.height, a);
            return new e.Rect(
              h.x,
              h.y,
              d.x,
              d.y,
              l.degrees + this.getRotation(a)
            );
          },
          /**
           * Translates from a rectangle which describes a portion of
           * the viewport in point coordinates to image rectangle coordinates.
           * This method can be called either by passing X,Y,width,height or an {@link OpenSeadragon.Rect}.
           * @param {Number|OpenSeadragon.Rect} viewerX - The left coordinate or rectangle in viewport coordinate system.
           * @param {Number} [viewerY] - The top coordinate in viewport coordinate system.
           * @param {Number} [pointWidth] - The width in viewport coordinate system.
           * @param {Number} [pointHeight] - The height in viewport coordinate system.
           * @param {Boolean} [current=false] - Pass true to use the current location; false for target location.
           * @returns {OpenSeadragon.Rect} A rect representing the coordinates in the image.
           */
          viewportToImageRectangle: function(t, i, n, o, a) {
            var l = t;
            t instanceof e.Rect ? a = i : l = new e.Rect(t, i, n, o);
            var h = this.viewportToImageCoordinates(l.getTopLeft(), a), d = this._viewportToImageDelta(l.width, l.height, a);
            return new e.Rect(
              h.x,
              h.y,
              d.x,
              d.y,
              l.degrees - this.getRotation(a)
            );
          },
          /**
           * Convert pixel coordinates relative to the viewer element to image
           * coordinates.
           * @param {OpenSeadragon.Point} pixel
           * @returns {OpenSeadragon.Point}
           */
          viewerElementToImageCoordinates: function(t) {
            var i = this.viewport.pointFromPixel(t, !0);
            return this.viewportToImageCoordinates(i);
          },
          /**
           * Convert pixel coordinates relative to the image to
           * viewer element coordinates.
           * @param {OpenSeadragon.Point} pixel
           * @returns {OpenSeadragon.Point}
           */
          imageToViewerElementCoordinates: function(t) {
            var i = this.imageToViewportCoordinates(t);
            return this.viewport.pixelFromPoint(i, !0);
          },
          /**
           * Convert pixel coordinates relative to the window to image coordinates.
           * @param {OpenSeadragon.Point} pixel
           * @returns {OpenSeadragon.Point}
           */
          windowToImageCoordinates: function(t) {
            var i = t.minus(
              r.getElementPosition(this.viewer.element)
            );
            return this.viewerElementToImageCoordinates(i);
          },
          /**
           * Convert image coordinates to pixel coordinates relative to the window.
           * @param {OpenSeadragon.Point} pixel
           * @returns {OpenSeadragon.Point}
           */
          imageToWindowCoordinates: function(t) {
            var i = this.imageToViewerElementCoordinates(t);
            return i.plus(
              r.getElementPosition(this.viewer.element)
            );
          },
          // private
          // Convert rectangle in viewport coordinates to this tiled image point
          // coordinates (x in [0, 1] and y in [0, aspectRatio])
          _viewportToTiledImageRectangle: function(t) {
            var i = this._scaleSpring.current.value;
            return t = t.rotate(-this.getRotation(!0), this._getRotationPoint(!0)), new e.Rect(
              (t.x - this._xSpring.current.value) / i,
              (t.y - this._ySpring.current.value) / i,
              t.width / i,
              t.height / i,
              t.degrees
            );
          },
          /**
           * Convert a viewport zoom to an image zoom.
           * Image zoom: ratio of the original image size to displayed image size.
           * 1 means original image size, 0.5 half size...
           * Viewport zoom: ratio of the displayed image's width to viewport's width.
           * 1 means identical width, 2 means image's width is twice the viewport's width...
           * @function
           * @param {Number} viewportZoom The viewport zoom
           * @returns {Number} imageZoom The image zoom
           */
          viewportToImageZoom: function(t) {
            var i = this._scaleSpring.current.value * this.viewport._containerInnerSize.x / this.source.dimensions.x;
            return i * t;
          },
          /**
           * Convert an image zoom to a viewport zoom.
           * Image zoom: ratio of the original image size to displayed image size.
           * 1 means original image size, 0.5 half size...
           * Viewport zoom: ratio of the displayed image's width to viewport's width.
           * 1 means identical width, 2 means image's width is twice the viewport's width...
           * Note: not accurate with multi-image.
           * @function
           * @param {Number} imageZoom The image zoom
           * @returns {Number} viewportZoom The viewport zoom
           */
          imageToViewportZoom: function(t) {
            var i = this._scaleSpring.current.value * this.viewport._containerInnerSize.x / this.source.dimensions.x;
            return t / i;
          },
          /**
           * Sets the TiledImage's position in the world.
           * @param {OpenSeadragon.Point} position - The new position, in viewport coordinates.
           * @param {Boolean} [immediately=false] - Whether to animate to the new position or snap immediately.
           * @fires OpenSeadragon.TiledImage.event:bounds-change
           */
          setPosition: function(t, i) {
            var n = this._xSpring.target.value === t.x && this._ySpring.target.value === t.y;
            if (i) {
              if (n && this._xSpring.current.value === t.x && this._ySpring.current.value === t.y)
                return;
              this._xSpring.resetTo(t.x), this._ySpring.resetTo(t.y), this._needsDraw = !0, this._needsUpdate = !0;
            } else {
              if (n)
                return;
              this._xSpring.springTo(t.x), this._ySpring.springTo(t.y), this._needsDraw = !0, this._needsUpdate = !0;
            }
            n || this._raiseBoundsChange();
          },
          /**
           * Sets the TiledImage's width in the world, adjusting the height to match based on aspect ratio.
           * @param {Number} width - The new width, in viewport coordinates.
           * @param {Boolean} [immediately=false] - Whether to animate to the new size or snap immediately.
           * @fires OpenSeadragon.TiledImage.event:bounds-change
           */
          setWidth: function(t, i) {
            this._setScale(t, i);
          },
          /**
           * Sets the TiledImage's height in the world, adjusting the width to match based on aspect ratio.
           * @param {Number} height - The new height, in viewport coordinates.
           * @param {Boolean} [immediately=false] - Whether to animate to the new size or snap immediately.
           * @fires OpenSeadragon.TiledImage.event:bounds-change
           */
          setHeight: function(t, i) {
            this._setScale(t / this.normHeight, i);
          },
          /**
           * Sets an array of polygons to crop the TiledImage during draw tiles.
           * The render function will use the default non-zero winding rule.
           * @param {OpenSeadragon.Point[][]} polygons - represented in an array of point object in image coordinates.
           * Example format: [
           *  [{x: 197, y:172}, {x: 226, y:172}, {x: 226, y:198}, {x: 197, y:198}], // First polygon
           *  [{x: 328, y:200}, {x: 330, y:199}, {x: 332, y:201}, {x: 329, y:202}]  // Second polygon
           *  [{x: 321, y:201}, {x: 356, y:205}, {x: 341, y:250}] // Third polygon
           * ]
           */
          setCroppingPolygons: function(t) {
            var i = function(o) {
              return o instanceof e.Point || typeof o.x == "number" && typeof o.y == "number";
            }, n = function(o) {
              return o.map(function(a) {
                try {
                  if (i(a))
                    return { x: a.x, y: a.y };
                  throw new Error();
                } catch {
                  throw new Error("A Provided cropping polygon point is not supported");
                }
              });
            };
            try {
              if (!e.isArray(t))
                throw new Error("Provided cropping polygon is not an array");
              this._croppingPolygons = t.map(function(o) {
                return n(o);
              }), this._needsDraw = !0;
            } catch (o) {
              e.console.error("[TiledImage.setCroppingPolygons] Cropping polygon format not supported"), e.console.error(o), this.resetCroppingPolygons();
            }
          },
          /**
           * Resets the cropping polygons, thus next render will remove all cropping
           * polygon effects.
           */
          resetCroppingPolygons: function() {
            this._croppingPolygons = null, this._needsDraw = !0;
          },
          /**
           * Positions and scales the TiledImage to fit in the specified bounds.
           * Note: this method fires OpenSeadragon.TiledImage.event:bounds-change
           * twice
           * @param {OpenSeadragon.Rect} bounds The bounds to fit the image into.
           * @param {OpenSeadragon.Placement} [anchor=OpenSeadragon.Placement.CENTER]
           * How to anchor the image in the bounds.
           * @param {Boolean} [immediately=false] Whether to animate to the new size
           * or snap immediately.
           * @fires OpenSeadragon.TiledImage.event:bounds-change
           */
          fitBounds: function(t, i, n) {
            i = i || e.Placement.CENTER;
            var o = e.Placement.properties[i], a = this.contentAspectX, l = 0, h = 0, d = 1, f = 1;
            if (this._clip && (a = this._clip.getAspectRatio(), d = this._clip.width / this.source.dimensions.x, f = this._clip.height / this.source.dimensions.y, t.getAspectRatio() > a ? (l = this._clip.x / this._clip.height * t.height, h = this._clip.y / this._clip.height * t.height) : (l = this._clip.x / this._clip.width * t.width, h = this._clip.y / this._clip.width * t.width)), t.getAspectRatio() > a) {
              var g = t.height / f, w = 0;
              o.isHorizontallyCentered ? w = (t.width - t.height * a) / 2 : o.isRight && (w = t.width - t.height * a), this.setPosition(
                new e.Point(t.x - l + w, t.y - h),
                n
              ), this.setHeight(g, n);
            } else {
              var C = t.width / d, E = 0;
              o.isVerticallyCentered ? E = (t.height - t.width / a) / 2 : o.isBottom && (E = t.height - t.width / a), this.setPosition(
                new e.Point(t.x - l, t.y - h + E),
                n
              ), this.setWidth(C, n);
            }
          },
          /**
           * @returns {OpenSeadragon.Rect|null} The TiledImage's current clip rectangle,
           * in image pixels, or null if none.
           */
          getClip: function() {
            return this._clip ? this._clip.clone() : null;
          },
          /**
           * @param {OpenSeadragon.Rect|null} newClip - An area, in image pixels, to clip to
           * (portions of the image outside of this area will not be visible). Only works on
           * browsers that support the HTML5 canvas.
           * @fires OpenSeadragon.TiledImage.event:clip-change
           */
          setClip: function(t) {
            e.console.assert(
              !t || t instanceof e.Rect,
              "[TiledImage.setClip] newClip must be an OpenSeadragon.Rect or null"
            ), t instanceof e.Rect ? this._clip = t.clone() : this._clip = null, this._needsUpdate = !0, this._needsDraw = !0, this.raiseEvent("clip-change");
          },
          /**
           * @returns {Boolean} Whether the TiledImage should be flipped before rendering.
           */
          getFlip: function() {
            return this.flipped;
          },
          /**
           * @param {Boolean} flip Whether the TiledImage should be flipped before rendering.
           * @fires OpenSeadragon.TiledImage.event:bounds-change
           */
          setFlip: function(t) {
            this.flipped = t;
          },
          get flipped() {
            return this._flipped;
          },
          set flipped(t) {
            let i = this._flipped !== !!t;
            this._flipped = !!t, i && (this.update(!0), this._needsDraw = !0, this._raiseBoundsChange());
          },
          get wrapHorizontal() {
            return this._wrapHorizontal;
          },
          set wrapHorizontal(t) {
            let i = this._wrapHorizontal !== !!t;
            this._wrapHorizontal = !!t, this._initialized && i && (this.update(!0), this._needsDraw = !0);
          },
          get wrapVertical() {
            return this._wrapVertical;
          },
          set wrapVertical(t) {
            let i = this._wrapVertical !== !!t;
            this._wrapVertical = !!t, this._initialized && i && (this.update(!0), this._needsDraw = !0);
          },
          get debugMode() {
            return this._debugMode;
          },
          set debugMode(t) {
            this._debugMode = !!t, this._needsDraw = !0;
          },
          /**
           * @returns {Number} The TiledImage's current opacity.
           */
          getOpacity: function() {
            return this.opacity;
          },
          /**
           * @param {Number} opacity Opacity the tiled image should be drawn at.
           * @fires OpenSeadragon.TiledImage.event:opacity-change
           */
          setOpacity: function(t) {
            this.opacity = t;
          },
          get opacity() {
            return this._opacity;
          },
          set opacity(t) {
            t !== this.opacity && (this._opacity = t, this._needsDraw = !0, this.raiseEvent("opacity-change", {
              opacity: this.opacity
            }));
          },
          /**
           * @returns {Boolean} whether the tiledImage can load its tiles even when it has zero opacity.
           */
          getPreload: function() {
            return this._preload;
          },
          /**
           * Set true to load even when hidden. Set false to block loading when hidden.
           */
          setPreload: function(t) {
            this._preload = !!t, this._needsDraw = !0;
          },
          /**
           * Get the rotation of this tiled image in degrees.
           * @param {Boolean} [current=false] True for current rotation, false for target.
           * @returns {Number} the rotation of this tiled image in degrees.
           */
          getRotation: function(t) {
            return t ? this._degreesSpring.current.value : this._degreesSpring.target.value;
          },
          /**
           * Set the current rotation of this tiled image in degrees.
           * @param {Number} degrees the rotation in degrees.
           * @param {Boolean} [immediately=false] Whether to animate to the new angle
           * or rotate immediately.
           * @fires OpenSeadragon.TiledImage.event:bounds-change
           */
          setRotation: function(t, i) {
            this._degreesSpring.target.value === t && this._degreesSpring.isAtTargetValue() || (i ? this._degreesSpring.resetTo(t) : this._degreesSpring.springTo(t), this._needsDraw = !0, this._needsUpdate = !0, this._raiseBoundsChange());
          },
          /**
           * Get the region of this tiled image that falls within the viewport.
           * @returns {OpenSeadragon.Rect} the region of this tiled image that falls within the viewport.
           * Returns false for images with opacity==0 unless preload==true
           */
          getDrawArea: function() {
            if (this._opacity === 0 && !this._preload)
              return !1;
            var t = this._viewportToTiledImageRectangle(
              this.viewport.getBoundsWithMargins(!0)
            );
            if (!this.wrapHorizontal && !this.wrapVertical) {
              var i = this._viewportToTiledImageRectangle(
                this.getClippedBounds(!0)
              );
              t = t.intersection(i);
            }
            return t;
          },
          /**
           *
           * @returns {Array} Array of Tiles that make up the current view
           */
          getTilesToDraw: function() {
            let t = this._tilesToDraw.flat();
            return this._updateTilesInViewport(t), t = this._tilesToDraw.flat(), t.forEach((i) => {
              i.tile.beingDrawn = !0;
            }), this._lastDrawn = t, t;
          },
          /**
           * Get the point around which this tiled image is rotated
           * @private
           * @param {Boolean} current True for current rotation point, false for target.
           * @returns {OpenSeadragon.Point}
           */
          _getRotationPoint: function(t) {
            return this.getBoundsNoRotate(t).getCenter();
          },
          get compositeOperation() {
            return this._compositeOperation;
          },
          set compositeOperation(t) {
            t !== this._compositeOperation && (this._compositeOperation = t, this._needsDraw = !0, this.raiseEvent("composite-operation-change", {
              compositeOperation: this._compositeOperation
            }));
          },
          /**
           * @returns {String} The TiledImage's current compositeOperation.
           */
          getCompositeOperation: function() {
            return this._compositeOperation;
          },
          /**
           * @param {String} compositeOperation the tiled image should be drawn with this globalCompositeOperation.
           * @fires OpenSeadragon.TiledImage.event:composite-operation-change
           */
          setCompositeOperation: function(t) {
            this.compositeOperation = t;
          },
          /**
           * Update headers to include when making AJAX requests.
           *
           * Unless `propagate` is set to false (which is likely only useful in rare circumstances),
           * the updated headers are propagated to all tiles and queued image loader jobs.
           *
           * Note that the rules for merging headers still apply, i.e. headers returned by
           * {@link OpenSeadragon.TileSource#getTileAjaxHeaders} take precedence over
           * the headers here in the tiled image (`TiledImage.ajaxHeaders`).
           *
           * @function
           * @param {Object} ajaxHeaders Updated AJAX headers, which will be merged over any headers specified in {@link OpenSeadragon.Options}.
           * @param {Boolean} [propagate=true] Whether to propagate updated headers to existing tiles and queued image loader jobs.
           */
          setAjaxHeaders: function(t, i) {
            if (t === null && (t = {}), !e.isPlainObject(t)) {
              console.error("[TiledImage.setAjaxHeaders] Ignoring invalid headers, must be a plain object");
              return;
            }
            this._ownAjaxHeaders = t, this._updateAjaxHeaders(i);
          },
          /**
           * Update headers to include when making AJAX requests.
           *
           * This function has the same effect as calling {@link OpenSeadragon.TiledImage#setAjaxHeaders},
           * except that the headers for this tiled image do not change. This is especially useful
           * for propagating updated headers from {@link OpenSeadragon.TileSource#getTileAjaxHeaders}
           * to existing tiles.
           *
           * @private
           * @function
           * @param {Boolean} [propagate=true] Whether to propagate updated headers to existing tiles and queued image loader jobs.
           */
          _updateAjaxHeaders: function(t) {
            if (t === void 0 && (t = !0), e.isPlainObject(this.viewer.ajaxHeaders) ? this.ajaxHeaders = e.extend({}, this.viewer.ajaxHeaders, this._ownAjaxHeaders) : this.ajaxHeaders = this._ownAjaxHeaders, t) {
              var i, n, o, a;
              for (var l in this.tilesMatrix) {
                i = this.source.getNumTiles(l);
                for (var h in this.tilesMatrix[l]) {
                  n = (i.x + h % i.x) % i.x;
                  for (var d in this.tilesMatrix[l][h])
                    if (o = (i.y + d % i.y) % i.y, a = this.tilesMatrix[l][h][d], a.loadWithAjax = this.loadTilesWithAjax, a.loadWithAjax) {
                      var f = this.source.getTileAjaxHeaders(l, n, o);
                      a.ajaxHeaders = e.extend({}, this.ajaxHeaders, f);
                    } else
                      a.ajaxHeaders = null;
                }
              }
              for (var g = 0; g < this._imageLoader.jobQueue.length; g++) {
                var w = this._imageLoader.jobQueue[g];
                w.loadWithAjax = w.tile.loadWithAjax, w.ajaxHeaders = w.tile.loadWithAjax ? w.tile.ajaxHeaders : null;
              }
            }
          },
          // private
          _setScale: function(t, i) {
            var n = this._scaleSpring.target.value === t;
            if (i) {
              if (n && this._scaleSpring.current.value === t)
                return;
              this._scaleSpring.resetTo(t), this._updateForScale(), this._needsDraw = !0, this._needsUpdate = !0;
            } else {
              if (n)
                return;
              this._scaleSpring.springTo(t), this._updateForScale(), this._needsDraw = !0, this._needsUpdate = !0;
            }
            n || this._raiseBoundsChange();
          },
          // private
          _updateForScale: function() {
            this._worldWidthTarget = this._scaleSpring.target.value, this._worldHeightTarget = this.normHeight * this._scaleSpring.target.value, this._worldWidthCurrent = this._scaleSpring.current.value, this._worldHeightCurrent = this.normHeight * this._scaleSpring.current.value;
          },
          // private
          _raiseBoundsChange: function() {
            this.raiseEvent("bounds-change");
          },
          // private
          _isBottomItem: function() {
            return this.viewer.world.getItemAt(0) === this;
          },
          // private
          _getLevelsInterval: function() {
            var t = Math.max(
              this.source.minLevel,
              Math.floor(Math.log(this.minZoomImageRatio) / Math.log(2))
            ), i = this.viewport.deltaPixelsFromPointsNoRotate(
              this.source.getPixelRatio(0),
              !0
            ).x * this._scaleSpring.current.value, n = Math.min(
              Math.abs(this.source.maxLevel),
              Math.abs(Math.floor(
                Math.log(i / this.minPixelRatio) / Math.log(2)
              ))
            );
            return n = Math.max(n, this.source.minLevel || 0), t = Math.min(t, n), {
              lowestLevel: t,
              highestLevel: n
            };
          },
          // returns boolean flag of whether the image should be marked as fully loaded
          _updateLevelsForViewport: function() {
            var t = this._getLevelsInterval(), i = t.lowestLevel, n = t.highestLevel, o = [], a = this.getDrawArea(), l = e.now();
            if (this._lastDrawn.forEach((re) => {
              re.tile.beingDrawn = !1;
            }), this._tilesToDraw = [], this._tilesLoading = 0, this.loadingCoverage = {}, !a)
              return this._needsDraw = !1, this._fullyLoaded;
            var h = new Array(n - i + 1);
            for (let re = 0, he = n; he >= i; he--, re++)
              h[re] = he;
            for (let re = n + 1; re <= this.source.maxLevel; re++) {
              var d = this.tilesMatrix[re] && this.tilesMatrix[re][0] && this.tilesMatrix[re][0][0];
              if (d && d.isBottomMost && d.isRightMost && d.loaded) {
                h.push(re);
                break;
              }
            }
            let f = !1;
            for (let re = 0; re < h.length; re++) {
              let he = h[re];
              var g = this.viewport.deltaPixelsFromPointsNoRotate(
                this.source.getPixelRatio(he),
                !0
              ).x * this._scaleSpring.current.value;
              if (re === h.length - 1 || g >= this.minPixelRatio)
                f = !0;
              else if (!f)
                continue;
              var w = this.viewport.deltaPixelsFromPointsNoRotate(
                this.source.getPixelRatio(he),
                !1
              ).x * this._scaleSpring.current.value, C = this.viewport.deltaPixelsFromPointsNoRotate(
                this.source.getPixelRatio(
                  Math.max(
                    this.source.getClosestLevel(),
                    0
                  )
                ),
                !1
              ).x * this._scaleSpring.current.value, E = this.immediateRender ? 1 : C, A = Math.min(1, (g - 0.5) / 0.5), I = E / Math.abs(
                E - w
              ), V = this._updateLevel(
                he,
                A,
                I,
                a,
                l,
                o
              );
              o = V.bestTiles;
              var K = V.updatedTiles.filter((pe) => pe.loaded), ce = /* @__PURE__ */ function(pe, Te, Ae) {
                return function(He) {
                  return {
                    tile: He,
                    level: pe,
                    levelOpacity: Te,
                    currentTime: Ae
                  };
                };
              }(he, A, l);
              if (this._tilesToDraw[he] = K.map(ce), this._providesCoverage(this.coverage, he))
                break;
            }
            return o && o.length > 0 ? (o.forEach(function(re) {
              re && !re.context2D && this._loadTile(re, l);
            }, this), this._needsDraw = !0, !1) : this._tilesLoading === 0;
          },
          /**
           * Update all tiles that contribute to the current view
           * @private
           *
           */
          _updateTilesInViewport: function(t) {
            let i = e.now(), n = this;
            this._tilesLoading = 0, this._wasBlending = this._isBlending, this._isBlending = !1, this.loadingCoverage = {};
            let o = t.length ? t[0].level : 0;
            if (!this.getDrawArea())
              return;
            function l(d) {
              let f = d.tile;
              if (f && f.loaded) {
                let g = n._blendTile(
                  f,
                  f.x,
                  f.y,
                  d.level,
                  d.levelOpacity,
                  i,
                  o
                );
                n._isBlending = n._isBlending || g, n._needsDraw = n._needsDraw || g || n._wasBlending;
              }
            }
            let h = 0;
            for (let d = 0; d < t.length; d++) {
              let f = t[d];
              l(f), this._providesCoverage(this.coverage, f.level) && (h = Math.max(h, f.level));
            }
            if (h > 0)
              for (let d in this._tilesToDraw)
                d < h && delete this._tilesToDraw[d];
          },
          /**
           * Updates the opacity of a tile according to the time it has been on screen
           * to perform a fade-in.
           * Updates coverage once a tile is fully opaque.
           * Returns whether the fade-in has completed.
           * @private
           *
           * @param {OpenSeadragon.Tile} tile
           * @param {Number} x
           * @param {Number} y
           * @param {Number} level
           * @param {Number} levelOpacity
           * @param {Number} currentTime
           * @param {Boolean} lowestLevel
           * @returns {Boolean} true if blending did not yet finish
           */
          _blendTile: function(t, i, n, o, a, l, h) {
            let d = 1e3 * this.blendTime, f, g;
            return t.blendStart || (t.blendStart = l), f = l - t.blendStart, g = d ? Math.min(1, f / d) : 1, o === h && (g = 1, f = d), this.alwaysBlend && (g *= a), t.opacity = g, g === 1 && (this._setCoverage(this.coverage, o, i, n, !0), this._hasOpaqueTile = !0), f < d;
          },
          /**
           * Updates all tiles at a given resolution level.
           * @private
           * @param {Number} level
           * @param {Number} levelOpacity
           * @param {Number} levelVisibility
           * @param {OpenSeadragon.Rect} drawArea
           * @param {Number} currentTime
           * @param {OpenSeadragon.Tile[]} best Array of the current best tiles
           * @returns {Object} Dictionary {bestTiles: OpenSeadragon.Tile - the current "best" tiles to draw, updatedTiles: OpenSeadragon.Tile) - the updated tiles}.
           */
          _updateLevel: function(t, i, n, o, a, l) {
            var h = o.getBoundingBox().getTopLeft(), d = o.getBoundingBox().getBottomRight();
            this.viewer && this.viewer.raiseEvent("update-level", {
              tiledImage: this,
              havedrawn: !0,
              // deprecated, kept for backwards compatibility
              level: t,
              opacity: i,
              visibility: n,
              drawArea: o,
              topleft: h,
              bottomright: d,
              currenttime: a,
              best: l
            }), this._resetCoverage(this.coverage, t), this._resetCoverage(this.loadingCoverage, t);
            var f = this._getCornerTiles(t, h, d), g = f.topLeft, w = f.bottomRight, C = this.source.getNumTiles(t), E = this.viewport.pixelFromPoint(this.viewport.getCenter());
            this.getFlip() && (w.x += 1, this.wrapHorizontal || (w.x = Math.min(w.x, C.x - 1)));
            for (var A = Math.max(0, (w.x - g.x) * (w.y - g.y)), I = new Array(A), V = 0, K = g.x; K <= w.x; K++)
              for (var ce = g.y; ce <= w.y; ce++) {
                var re;
                if (this.getFlip()) {
                  var he = (C.x + K % C.x) % C.x;
                  re = K + C.x - he - he - 1;
                } else
                  re = K;
                if (o.intersection(this.getTileBounds(t, re, ce)) !== null) {
                  var pe = this._updateTile(
                    re,
                    ce,
                    t,
                    n,
                    E,
                    C,
                    a,
                    l
                  );
                  l = pe.bestTiles, I[V] = pe.tile, V += 1;
                }
              }
            return {
              bestTiles: l,
              updatedTiles: I
            };
          },
          /**
           * @private
           * @param {OpenSeadragon.Tile} tile
           * @param {Boolean} overlap
           * @param {OpenSeadragon.Viewport} viewport
           * @param {OpenSeadragon.Point} viewportCenter
           * @param {Number} levelVisibility
           */
          _positionTile: function(t, i, n, o, a) {
            var l = t.bounds.getTopLeft();
            l.x *= this._scaleSpring.current.value, l.y *= this._scaleSpring.current.value, l.x += this._xSpring.current.value, l.y += this._ySpring.current.value;
            var h = t.bounds.getSize();
            h.x *= this._scaleSpring.current.value, h.y *= this._scaleSpring.current.value, t.positionedBounds.x = l.x, t.positionedBounds.y = l.y, t.positionedBounds.width = h.x, t.positionedBounds.height = h.y;
            var d = n.pixelFromPointNoRotate(l, !0), f = n.pixelFromPointNoRotate(l, !1), g = n.deltaPixelsFromPointsNoRotate(h, !0), w = n.deltaPixelsFromPointsNoRotate(h, !1), C = f.plus(w.divide(2)), E = o.squaredDistanceTo(C);
            this.viewer.drawer.minimumOverlapRequired(this) && (i || (g = g.plus(new e.Point(1, 1))), t.isRightMost && this.wrapHorizontal && (g.x += 0.75), t.isBottomMost && this.wrapVertical && (g.y += 0.75)), t.position = d, t.size = g, t.squaredDistance = E, t.visibility = a;
          },
          /**
           * Update a single tile at a particular resolution level.
           * @private
           * @param {Number} x
           * @param {Number} y
           * @param {Number} level
           * @param {Number} levelVisibility
           * @param {OpenSeadragon.Point} viewportCenter
           * @param {Number} numberOfTiles
           * @param {Number} currentTime
           * @param {OpenSeadragon.Tile} best - The current "best" tile to draw.
           * @returns {Object} Dictionary {bestTiles: OpenSeadragon.Tile[] - the current best tiles, tile: OpenSeadragon.Tile the current tile}
           */
          _updateTile: function(t, i, n, o, a, l, h, d) {
            var f = this._getTile(
              t,
              i,
              n,
              h,
              l
            );
            this.viewer && this.viewer.raiseEvent("update-tile", {
              tiledImage: this,
              tile: f
            }), this._setCoverage(this.coverage, n, t, i, !1);
            var g = f.loaded || f.loading || this._isCovered(this.loadingCoverage, n, t, i);
            if (this._setCoverage(this.loadingCoverage, n, t, i, g), !f.exists)
              return {
                bestTiles: d,
                tile: f
              };
            if (f.loaded && f.opacity === 1 && this._setCoverage(this.coverage, n, t, i, !0), this._positionTile(
              f,
              this.source.tileOverlap,
              this.viewport,
              a,
              o
            ), !f.loaded)
              if (f.context2D)
                this._setTileLoaded(f);
              else {
                var w = this._tileCache.getImageRecord(f.cacheKey);
                w && this._setTileLoaded(f, w.getData());
              }
            return f.loading ? this._tilesLoading++ : g || (d = this._compareTiles(d, f, this.maxTilesPerFrame)), {
              bestTiles: d,
              tile: f
            };
          },
          // private
          _getCornerTiles: function(t, i, n) {
            var o, a;
            this.wrapHorizontal ? (o = e.positiveModulo(i.x, 1), a = e.positiveModulo(n.x, 1)) : (o = Math.max(0, i.x), a = Math.min(1, n.x));
            var l, h, d = 1 / this.source.aspectRatio;
            this.wrapVertical ? (l = e.positiveModulo(i.y, d), h = e.positiveModulo(n.y, d)) : (l = Math.max(0, i.y), h = Math.min(d, n.y));
            var f = this.source.getTileAtPoint(t, new e.Point(o, l)), g = this.source.getTileAtPoint(t, new e.Point(a, h)), w = this.source.getNumTiles(t);
            return this.wrapHorizontal && (f.x += w.x * Math.floor(i.x), g.x += w.x * Math.floor(n.x)), this.wrapVertical && (f.y += w.y * Math.floor(i.y / d), g.y += w.y * Math.floor(n.y / d)), {
              topLeft: f,
              bottomRight: g
            };
          },
          /**
           * Obtains a tile at the given location.
           * @private
           * @param {Number} x
           * @param {Number} y
           * @param {Number} level
           * @param {Number} time
           * @param {Number} numTiles
           * @returns {OpenSeadragon.Tile}
           */
          _getTile: function(t, i, n, o, a) {
            var l, h, d, f, g, w, C, E, A, I, V = this.tilesMatrix, K = this.source;
            return V[n] || (V[n] = {}), V[n][t] || (V[n][t] = {}), (!V[n][t][i] || !V[n][t][i].flipped != !this.flipped) && (l = (a.x + t % a.x) % a.x, h = (a.y + i % a.y) % a.y, d = this.getTileBounds(n, t, i), f = K.getTileBounds(n, l, h, !0), g = K.tileExists(n, l, h), w = K.getTileUrl(n, l, h), C = K.getTilePostData(n, l, h), this.loadTilesWithAjax ? (E = K.getTileAjaxHeaders(n, l, h), e.isPlainObject(this.ajaxHeaders) && (E = e.extend({}, this.ajaxHeaders, E))) : E = null, A = K.getContext2D ? K.getContext2D(n, l, h) : void 0, I = new e.Tile(
              n,
              t,
              i,
              d,
              g,
              w,
              A,
              this.loadTilesWithAjax,
              E,
              f,
              C,
              K.getTileHashKey(n, l, h, w, E, C)
            ), this.getFlip() ? l === 0 && (I.isRightMost = !0) : l === a.x - 1 && (I.isRightMost = !0), h === a.y - 1 && (I.isBottomMost = !0), I.flipped = this.flipped, V[n][t][i] = I), I = V[n][t][i], I.lastTouchTime = o, I;
          },
          /**
           * Dispatch a job to the ImageLoader to load the Image for a Tile.
           * @private
           * @param {OpenSeadragon.Tile} tile
           * @param {Number} time
           */
          _loadTile: function(t, i) {
            var n = this;
            t.loading = !0, this._imageLoader.addJob({
              src: t.getUrl(),
              tile: t,
              source: this.source,
              postData: t.postData,
              loadWithAjax: t.loadWithAjax,
              ajaxHeaders: t.ajaxHeaders,
              crossOriginPolicy: this.crossOriginPolicy,
              ajaxWithCredentials: this.ajaxWithCredentials,
              callback: function(o, a, l) {
                n._onTileLoad(t, i, o, a, l);
              },
              abort: function() {
                t.loading = !1;
              }
            });
          },
          /**
           * Callback fired when a Tile's Image finished downloading.
           * @private
           * @param {OpenSeadragon.Tile} tile
           * @param {Number} time
           * @param {*} data image data
           * @param {String} errorMsg
           * @param {XMLHttpRequest} tileRequest
           */
          _onTileLoad: function(t, i, n, o, a) {
            if (n)
              t.exists = !0;
            else {
              e.console.error("Tile %s failed to load: %s - error: %s", t, t.getUrl(), o), this.viewer.raiseEvent("tile-load-failed", {
                tile: t,
                tiledImage: this,
                time: i,
                message: o,
                tileRequest: a
              }), t.loading = !1, t.exists = !1;
              return;
            }
            if (i < this.lastResetTime) {
              e.console.warn("Ignoring tile %s loaded before reset: %s", t, t.getUrl()), t.loading = !1;
              return;
            }
            var l = this, h = function() {
              var d = l.source, f = d.getClosestLevel();
              l._setTileLoaded(t, n, f, a);
            };
            h();
          },
          /**
           * @private
           * @param {OpenSeadragon.Tile} tile
           * @param {*} data image data, the data sent to ImageJob.prototype.finish(), by default an Image object
           * @param {Number|undefined} cutoff
           * @param {XMLHttpRequest|undefined} tileRequest
           */
          _setTileLoaded: function(t, i, n, o) {
            var a = 0, l = !1, h = this;
            function d() {
              return l && e.console.error("Event 'tile-loaded' argument getCompletionCallback must be called synchronously. Its return value should be called asynchronously."), a++, f;
            }
            function f() {
              a--, a === 0 && (t.loading = !1, t.loaded = !0, t.hasTransparency = h.source.hasTransparency(
                t.context2D,
                t.getUrl(),
                t.ajaxHeaders,
                t.postData
              ), t.context2D || h._tileCache.cacheTile({
                data: i,
                tile: t,
                cutoff: n,
                tiledImage: h
              }), h.viewer.raiseEvent("tile-ready", {
                tile: t,
                tiledImage: h,
                tileRequest: o
              }), h._needsDraw = !0);
            }
            var g = d();
            this.viewer.raiseEvent("tile-loaded", {
              tile: t,
              tiledImage: this,
              tileRequest: o,
              get image() {
                return e.console.error("[tile-loaded] event 'image' has been deprecated. Use 'data' property instead."), i;
              },
              data: i,
              getCompletionCallback: d
            }), l = !0, g();
          },
          /**
           * Determines the 'best tiles' from the given 'last best' tiles and the
           * tile in question.
           * @private
           *
           * @param {OpenSeadragon.Tile[]} previousBest The best tiles so far.
           * @param {OpenSeadragon.Tile} tile The new tile to consider.
           * @param {Number} maxNTiles The max number of best tiles.
           * @returns {OpenSeadragon.Tile[]} The new best tiles.
           */
          _compareTiles: function(t, i, n) {
            return t ? (t.push(i), this._sortTiles(t), t.length > n && t.pop(), t) : [i];
          },
          /**
           * Sorts tiles in an array according to distance and visibility.
           * @private
           *
           * @param {OpenSeadragon.Tile[]} tiles The tiles.
           */
          _sortTiles: function(t) {
            t.sort(function(i, n) {
              return i === null ? 1 : n === null ? -1 : i.visibility === n.visibility ? i.squaredDistance - n.squaredDistance : n.visibility - i.visibility;
            });
          },
          /**
           * Returns true if the given tile provides coverage to lower-level tiles of
           * lower resolution representing the same content. If neither x nor y is
           * given, returns true if the entire visible level provides coverage.
           *
           * Note that out-of-bounds tiles provide coverage in this sense, since
           * there's no content that they would need to cover. Tiles at non-existent
           * levels that are within the image bounds, however, do not.
           * @private
           *
           * @param {Object} coverage - A '3d' dictionary [level][x][y] --> Boolean.
           * @param {Number} level - The resolution level of the tile.
           * @param {Number} x - The X position of the tile.
           * @param {Number} y - The Y position of the tile.
           * @returns {Boolean}
           */
          _providesCoverage: function(t, i, n, o) {
            var a, l, h, d;
            if (!t[i])
              return !1;
            if (n === void 0 || o === void 0) {
              a = t[i];
              for (h in a)
                if (Object.prototype.hasOwnProperty.call(a, h)) {
                  l = a[h];
                  for (d in l)
                    if (Object.prototype.hasOwnProperty.call(l, d) && !l[d])
                      return !1;
                }
              return !0;
            }
            return t[i][n] === void 0 || t[i][n][o] === void 0 || t[i][n][o] === !0;
          },
          /**
           * Returns true if the given tile is completely covered by higher-level
           * tiles of higher resolution representing the same content. If neither x
           * nor y is given, returns true if the entire visible level is covered.
           * @private
           *
           * @param {Object} coverage - A '3d' dictionary [level][x][y] --> Boolean.
           * @param {Number} level - The resolution level of the tile.
           * @param {Number} x - The X position of the tile.
           * @param {Number} y - The Y position of the tile.
           * @returns {Boolean}
           */
          _isCovered: function(t, i, n, o) {
            return n === void 0 || o === void 0 ? this._providesCoverage(t, i + 1) : this._providesCoverage(t, i + 1, 2 * n, 2 * o) && this._providesCoverage(t, i + 1, 2 * n, 2 * o + 1) && this._providesCoverage(t, i + 1, 2 * n + 1, 2 * o) && this._providesCoverage(t, i + 1, 2 * n + 1, 2 * o + 1);
          },
          /**
           * Sets whether the given tile provides coverage or not.
           * @private
           *
           * @param {Object} coverage - A '3d' dictionary [level][x][y] --> Boolean.
           * @param {Number} level - The resolution level of the tile.
           * @param {Number} x - The X position of the tile.
           * @param {Number} y - The Y position of the tile.
           * @param {Boolean} covers - Whether the tile provides coverage.
           */
          _setCoverage: function(t, i, n, o, a) {
            if (!t[i]) {
              e.console.warn(
                "Setting coverage for a tile before its level's coverage has been reset: %s",
                i
              );
              return;
            }
            t[i][n] || (t[i][n] = {}), t[i][n][o] = a;
          },
          /**
           * Resets coverage information for the given level. This should be called
           * after every draw routine. Note that at the beginning of the next draw
           * routine, coverage for every visible tile should be explicitly set.
           * @private
           *
           * @param {Object} coverage - A '3d' dictionary [level][x][y] --> Boolean.
           * @param {Number} level - The resolution level of tiles to completely reset.
           */
          _resetCoverage: function(t, i) {
            t[i] = {};
          }
        }
      );
    }(r), function(e) {
      var t = function(n) {
        e.console.assert(n, "[TileCache.cacheTile] options is required"), e.console.assert(n.tile, "[TileCache.cacheTile] options.tile is required"), e.console.assert(n.tiledImage, "[TileCache.cacheTile] options.tiledImage is required"), this.tile = n.tile, this.tiledImage = n.tiledImage;
      }, i = function(n) {
        e.console.assert(n, "[ImageRecord] options is required"), e.console.assert(n.data, "[ImageRecord] options.data is required"), this._tiles = [], n.create.apply(null, [this, n.data, n.ownerTile]), this._destroyImplementation = n.destroy.bind(null, this), this.getImage = n.getImage.bind(null, this), this.getData = n.getData.bind(null, this), this.getRenderedContext = n.getRenderedContext.bind(null, this);
      };
      i.prototype = {
        destroy: function() {
          this._destroyImplementation(), this._tiles = null;
        },
        addTile: function(n) {
          e.console.assert(n, "[ImageRecord.addTile] tile is required"), this._tiles.push(n);
        },
        removeTile: function(n) {
          for (var o = 0; o < this._tiles.length; o++)
            if (this._tiles[o] === n) {
              this._tiles.splice(o, 1);
              return;
            }
          e.console.warn("[ImageRecord.removeTile] trying to remove unknown tile", n);
        },
        getTileCount: function() {
          return this._tiles.length;
        }
      }, e.TileCache = function(n) {
        n = n || {}, this._maxImageCacheCount = n.maxImageCacheCount || e.DEFAULT_SETTINGS.maxImageCacheCount, this._tilesLoaded = [], this._imagesLoaded = [], this._imagesLoadedCount = 0;
      }, e.TileCache.prototype = {
        /**
         * @returns {Number} The total number of tiles that have been loaded by
         * this TileCache.
         */
        numTilesLoaded: function() {
          return this._tilesLoaded.length;
        },
        /**
         * Caches the specified tile, removing an old tile if necessary to stay under the
         * maxImageCacheCount specified on construction. Note that if multiple tiles reference
         * the same image, there may be more tiles than maxImageCacheCount; the goal is to keep
         * the number of images below that number. Note, as well, that even the number of images
         * may temporarily surpass that number, but should eventually come back down to the max specified.
         * @param {Object} options - Tile info.
         * @param {OpenSeadragon.Tile} options.tile - The tile to cache.
         * @param {String} options.tile.cacheKey - The unique key used to identify this tile in the cache.
         * @param {Image} options.image - The image of the tile to cache.
         * @param {OpenSeadragon.TiledImage} options.tiledImage - The TiledImage that owns that tile.
         * @param {Number} [options.cutoff=0] - If adding this tile goes over the cache max count, this
         * function will release an old tile. The cutoff option specifies a tile level at or below which
         * tiles will not be released.
         */
        cacheTile: function(n) {
          e.console.assert(n, "[TileCache.cacheTile] options is required"), e.console.assert(n.tile, "[TileCache.cacheTile] options.tile is required"), e.console.assert(n.tile.cacheKey, "[TileCache.cacheTile] options.tile.cacheKey is required"), e.console.assert(n.tiledImage, "[TileCache.cacheTile] options.tiledImage is required");
          var o = n.cutoff || 0, a = this._tilesLoaded.length, l = this._imagesLoaded[n.tile.cacheKey];
          if (l || (n.data || (e.console.error("[TileCache.cacheTile] options.image was renamed to options.data. '.image' attribute has been deprecated and will be removed in the future."), n.data = n.image), e.console.assert(n.data, "[TileCache.cacheTile] options.data is required to create an ImageRecord"), l = this._imagesLoaded[n.tile.cacheKey] = new i({
            data: n.data,
            ownerTile: n.tile,
            create: n.tiledImage.source.createTileCache,
            destroy: n.tiledImage.source.destroyTileCache,
            getImage: n.tiledImage.source.getTileCacheDataAsImage,
            getData: n.tiledImage.source.getTileCacheData,
            getRenderedContext: n.tiledImage.source.getTileCacheDataAsContext2D
          }), this._imagesLoadedCount++), l.addTile(n.tile), n.tile.cacheImageRecord = l, this._imagesLoadedCount > this._maxImageCacheCount) {
            for (var h = null, d = -1, f = null, g, w, C, E, A, I, V = this._tilesLoaded.length - 1; V >= 0; V--)
              if (I = this._tilesLoaded[V], g = I.tile, !(g.level <= o || g.beingDrawn)) {
                if (!h) {
                  h = g, d = V, f = I;
                  continue;
                }
                E = g.lastTouchTime, w = h.lastTouchTime, A = g.level, C = h.level, (E < w || E === w && A > C) && (h = g, d = V, f = I);
              }
            h && d >= 0 && (this._unloadTile(f), a = d);
          }
          this._tilesLoaded[a] = new t({
            tile: n.tile,
            tiledImage: n.tiledImage
          });
        },
        /**
         * Clears all tiles associated with the specified tiledImage.
         * @param {OpenSeadragon.TiledImage} tiledImage
         */
        clearTilesFor: function(n) {
          e.console.assert(n, "[TileCache.clearTilesFor] tiledImage is required");
          for (var o, a = 0; a < this._tilesLoaded.length; ++a)
            o = this._tilesLoaded[a], o.tiledImage === n && (this._unloadTile(o), this._tilesLoaded.splice(a, 1), a--);
        },
        // private
        getImageRecord: function(n) {
          return e.console.assert(n, "[TileCache.getImageRecord] cacheKey is required"), this._imagesLoaded[n];
        },
        // private
        _unloadTile: function(n) {
          e.console.assert(n, "[TileCache._unloadTile] tileRecord is required");
          var o = n.tile, a = n.tiledImage;
          let l = o.getCanvasContext && o.getCanvasContext();
          o.unload(), o.cacheImageRecord = null;
          var h = this._imagesLoaded[o.cacheKey];
          h && (h.removeTile(o), h.getTileCount() || (h.destroy(), delete this._imagesLoaded[o.cacheKey], this._imagesLoadedCount--, l && (l.canvas.width = 0, l.canvas.height = 0, a.viewer.raiseEvent("image-unloaded", {
            context2D: l,
            tile: o
          }))), a.viewer.raiseEvent("tile-unloaded", {
            tile: o,
            tiledImage: a
          }));
        }
      };
    }(r), function(e) {
      e.World = function(t) {
        var i = this;
        e.console.assert(t.viewer, "[World] options.viewer is required"), e.EventSource.call(this), this.viewer = t.viewer, this._items = [], this._needsDraw = !1, this._autoRefigureSizes = !0, this._needsSizesFigured = !1, this._delegatedFigureSizes = function(n) {
          i._autoRefigureSizes ? i._figureSizes() : i._needsSizesFigured = !0;
        }, this._figureSizes();
      }, e.extend(
        e.World.prototype,
        e.EventSource.prototype,
        /** @lends OpenSeadragon.World.prototype */
        {
          /**
           * Add the specified item.
           * @param {OpenSeadragon.TiledImage} item - The item to add.
           * @param {Number} [options.index] - Index for the item. If not specified, goes at the top.
           * @fires OpenSeadragon.World.event:add-item
           * @fires OpenSeadragon.World.event:metrics-change
           */
          addItem: function(t, i) {
            if (e.console.assert(t, "[World.addItem] item is required"), e.console.assert(t instanceof e.TiledImage, "[World.addItem] only TiledImages supported at this time"), i = i || {}, i.index !== void 0) {
              var n = Math.max(0, Math.min(this._items.length, i.index));
              this._items.splice(n, 0, t);
            } else
              this._items.push(t);
            this._autoRefigureSizes ? this._figureSizes() : this._needsSizesFigured = !0, this._needsDraw = !0, t.addHandler("bounds-change", this._delegatedFigureSizes), t.addHandler("clip-change", this._delegatedFigureSizes), this.raiseEvent("add-item", {
              item: t
            });
          },
          /**
           * Get the item at the specified index.
           * @param {Number} index - The item's index.
           * @returns {OpenSeadragon.TiledImage} The item at the specified index.
           */
          getItemAt: function(t) {
            return e.console.assert(t !== void 0, "[World.getItemAt] index is required"), this._items[t];
          },
          /**
           * Get the index of the given item or -1 if not present.
           * @param {OpenSeadragon.TiledImage} item - The item.
           * @returns {Number} The index of the item or -1 if not present.
           */
          getIndexOfItem: function(t) {
            return e.console.assert(t, "[World.getIndexOfItem] item is required"), e.indexOf(this._items, t);
          },
          /**
           * @returns {Number} The number of items used.
           */
          getItemCount: function() {
            return this._items.length;
          },
          /**
           * Change the index of a item so that it appears over or under others.
           * @param {OpenSeadragon.TiledImage} item - The item to move.
           * @param {Number} index - The new index.
           * @fires OpenSeadragon.World.event:item-index-change
           */
          setItemIndex: function(t, i) {
            e.console.assert(t, "[World.setItemIndex] item is required"), e.console.assert(i !== void 0, "[World.setItemIndex] index is required");
            var n = this.getIndexOfItem(t);
            if (i >= this._items.length)
              throw new Error("Index bigger than number of layers.");
            i === n || n === -1 || (this._items.splice(n, 1), this._items.splice(i, 0, t), this._needsDraw = !0, this.raiseEvent("item-index-change", {
              item: t,
              previousIndex: n,
              newIndex: i
            }));
          },
          /**
           * Remove an item.
           * @param {OpenSeadragon.TiledImage} item - The item to remove.
           * @fires OpenSeadragon.World.event:remove-item
           * @fires OpenSeadragon.World.event:metrics-change
           */
          removeItem: function(t) {
            e.console.assert(t, "[World.removeItem] item is required");
            var i = e.indexOf(this._items, t);
            i !== -1 && (t.removeHandler("bounds-change", this._delegatedFigureSizes), t.removeHandler("clip-change", this._delegatedFigureSizes), t.destroy(), this._items.splice(i, 1), this._figureSizes(), this._needsDraw = !0, this._raiseRemoveItem(t));
          },
          /**
           * Remove all items.
           * @fires OpenSeadragon.World.event:remove-item
           * @fires OpenSeadragon.World.event:metrics-change
           */
          removeAll: function() {
            this.viewer._cancelPendingImages();
            var t, i;
            for (i = 0; i < this._items.length; i++)
              t = this._items[i], t.removeHandler("bounds-change", this._delegatedFigureSizes), t.removeHandler("clip-change", this._delegatedFigureSizes), t.destroy();
            var n = this._items;
            for (this._items = [], this._figureSizes(), this._needsDraw = !0, i = 0; i < n.length; i++)
              t = n[i], this._raiseRemoveItem(t);
          },
          /**
           * Clears all tiles and triggers updates for all items.
           */
          resetItems: function() {
            for (var t = 0; t < this._items.length; t++)
              this._items[t].reset();
          },
          /**
           * Updates (i.e. animates bounds of) all items.
           * @function
           * @param viewportChanged Whether the viewport changed, which indicates that
           * all TiledImages need to be updated.
           */
          update: function(t) {
            for (var i = !1, n = 0; n < this._items.length; n++)
              i = this._items[n].update(t) || i;
            return i;
          },
          /**
           * Draws all items.
           */
          draw: function() {
            this.viewer.drawer.draw(this._items), this._needsDraw = !1, this._items.forEach((t) => {
              this._needsDraw = t.setDrawn() || this._needsDraw;
            });
          },
          /**
           * @returns {Boolean} true if any items need updating.
           */
          needsDraw: function() {
            for (var t = 0; t < this._items.length; t++)
              if (this._items[t].needsDraw())
                return !0;
            return this._needsDraw;
          },
          /**
           * @returns {OpenSeadragon.Rect} The smallest rectangle that encloses all items, in viewport coordinates.
           */
          getHomeBounds: function() {
            return this._homeBounds.clone();
          },
          /**
           * To facilitate zoom constraints, we keep track of the pixel density of the
           * densest item in the World (i.e. the item whose content size to viewport size
           * ratio is the highest) and save it as this "content factor".
           * @returns {Number} the number of content units per viewport unit.
           */
          getContentFactor: function() {
            return this._contentFactor;
          },
          /**
           * As a performance optimization, setting this flag to false allows the bounds-change event handler
           * on tiledImages to skip calculations on the world bounds. If a lot of images are going to be positioned in
           * rapid succession, this is a good idea. When finished, setAutoRefigureSizes should be called with true
           * or the system may behave oddly.
           * @param {Boolean} [value] The value to which to set the flag.
           */
          setAutoRefigureSizes: function(t) {
            this._autoRefigureSizes = t, t & this._needsSizesFigured && (this._figureSizes(), this._needsSizesFigured = !1);
          },
          /**
           * Arranges all of the TiledImages with the specified settings.
           * @param {Object} options - Specifies how to arrange.
           * @param {Boolean} [options.immediately=false] - Whether to animate to the new arrangement.
           * @param {String} [options.layout] - See collectionLayout in {@link OpenSeadragon.Options}.
           * @param {Number} [options.rows] - See collectionRows in {@link OpenSeadragon.Options}.
           * @param {Number} [options.columns] - See collectionColumns in {@link OpenSeadragon.Options}.
           * @param {Number} [options.tileSize] - See collectionTileSize in {@link OpenSeadragon.Options}.
           * @param {Number} [options.tileMargin] - See collectionTileMargin in {@link OpenSeadragon.Options}.
           * @fires OpenSeadragon.World.event:metrics-change
           */
          arrange: function(t) {
            t = t || {};
            var i = t.immediately || !1, n = t.layout || e.DEFAULT_SETTINGS.collectionLayout, o = t.rows || e.DEFAULT_SETTINGS.collectionRows, a = t.columns || e.DEFAULT_SETTINGS.collectionColumns, l = t.tileSize || e.DEFAULT_SETTINGS.collectionTileSize, h = t.tileMargin || e.DEFAULT_SETTINGS.collectionTileMargin, d = l + h, f;
            !t.rows && a ? f = a : f = Math.ceil(this._items.length / o);
            var g = 0, w = 0, C, E, A, I, V;
            this.setAutoRefigureSizes(!1);
            for (var K = 0; K < this._items.length; K++)
              K && K % f === 0 && (n === "horizontal" ? (w += d, g = 0) : (g += d, w = 0)), C = this._items[K], E = C.getBounds(), E.width > E.height ? A = l : A = l * (E.width / E.height), I = A * (E.height / E.width), V = new e.Point(
                g + (l - A) / 2,
                w + (l - I) / 2
              ), C.setPosition(V, i), C.setWidth(A, i), n === "horizontal" ? g += d : w += d;
            this.setAutoRefigureSizes(!0);
          },
          // private
          _figureSizes: function() {
            var t = this._homeBounds ? this._homeBounds.clone() : null, i = this._contentSize ? this._contentSize.clone() : null, n = this._contentFactor || 0;
            if (!this._items.length)
              this._homeBounds = new e.Rect(0, 0, 1, 1), this._contentSize = new e.Point(1, 1), this._contentFactor = 1;
            else {
              var o = this._items[0], a = o.getBounds();
              this._contentFactor = o.getContentSize().x / a.width;
              for (var l = o.getClippedBounds().getBoundingBox(), h = l.x, d = l.y, f = l.x + l.width, g = l.y + l.height, w = 1; w < this._items.length; w++)
                o = this._items[w], a = o.getBounds(), this._contentFactor = Math.max(
                  this._contentFactor,
                  o.getContentSize().x / a.width
                ), l = o.getClippedBounds().getBoundingBox(), h = Math.min(h, l.x), d = Math.min(d, l.y), f = Math.max(f, l.x + l.width), g = Math.max(g, l.y + l.height);
              this._homeBounds = new e.Rect(h, d, f - h, g - d), this._contentSize = new e.Point(
                this._homeBounds.width * this._contentFactor,
                this._homeBounds.height * this._contentFactor
              );
            }
            (this._contentFactor !== n || !this._homeBounds.equals(t) || !this._contentSize.equals(i)) && this.raiseEvent("metrics-change", {});
          },
          // private
          _raiseRemoveItem: function(t) {
            this.raiseEvent("remove-item", { item: t });
          }
        }
      );
    }(r);
  }(zn)), zn.exports;
}
var Km = qm();
const Zm = /* @__PURE__ */ vh(Km);
var Ym = Object.defineProperty, Xm = Object.getOwnPropertyDescriptor, Jm = Object.getPrototypeOf, Qm = Reflect.get, St = (s, r, e, t) => {
  for (var i = t > 1 ? void 0 : t ? Xm(r, e) : r, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (t ? o(r, e, i) : o(i)) || i);
  return t && i && Ym(r, e, i), i;
}, $m = (s, r, e) => Qm(Jm(s), e, r);
let ct = class extends Qi {
  constructor() {
    super(...arguments), this.firstTile = !1, this.viewer = void 0, this.openseadragonImagePath = "/static/assets/images/lightbox/", this.eof = !1, this.bof = !1, this.hideUI = !1, this.navDeferred = !1, this.darkMode = !0, this.open = !1, this.dataVisible = !1, this.hasData = !1;
  }
  setURLProvider(s) {
    this.urlProvider = s;
  }
  initOpenSeaDragon() {
    var t;
    this.viewer && this.viewer.destroy(), this.navDeferred = !1;
    const s = (t = this.shadowRoot) == null ? void 0 : t.getElementById("open-sea-dragon"), r = this.apiContext.getHeaders("application/json");
    let e = {};
    r.forEach((i, n) => {
      e[n] = i;
    }), s && (this.firstTile = !1, this.viewer = Zm({
      element: s,
      id: "open-sea-dragon",
      prefixUrl: this.openseadragonImagePath,
      showFullPageControl: !1,
      showRotationControl: !0,
      loadTilesWithAjax: !0,
      ajaxHeaders: e,
      crossOriginPolicy: "Anonymous"
    }), this.viewer.addHandler("open", () => {
      console.log("success");
    }), this.viewer.addHandler("open-failed", (i) => {
      this.opened(!1, i.message);
    }), this.viewer.addHandler("tile-load-failed", (i) => {
      console.log("tile load failure"), this.firstTile && this.opened(!1, i.message), this.firstTile = !1;
    }), this.viewer.addHandler("tile-loaded", () => {
      console.log("tile loaded successfully"), this.firstTile && this.opened(!0, ""), this.firstTile = !1;
    }));
  }
  nextFile(s) {
    let r;
    if (this.viewerError = void 0, !this.viewer) {
      this.viewerError = "The viewer instance was not successfully initialized, so I can't show anything.";
      return;
    }
    if (!this.urlProvider) {
      this.viewerError = "The urlProvider is missing. That's a programming error.";
      return;
    }
    try {
      s == "next" ? r = this.urlProvider.next() : r = this.urlProvider.prev();
    } catch (e) {
      this.viewerError = `An error occurred, so I don't know what file to fetch: ${e}`;
      return;
    }
    r ? this._openFile() : this.viewerError = "there is nowhere to go";
  }
  reloadFile() {
    this._openFile();
  }
  showHideUI(s = null) {
    this.hideUI = s === null ? !this.hideUI : s;
  }
  _openFile() {
    this.tryOpen(() => {
      var s;
      if ((s = this.urlProvider) != null && s.url && this.viewer) {
        this.eof = this.urlProvider.eof(), this.bof = this.urlProvider.bof();
        let r, e;
        try {
          r = this.urlProvider.height, e = this.urlProvider.width;
        } catch {
          r = 5e3, e = 5e3;
        }
        try {
          this.firstTile = !0, this.viewer.open(
            {
              type: "legacy-image-pyramid",
              levels: [
                {
                  url: this.urlProvider.url,
                  height: r,
                  width: e
                }
              ]
            }
          );
        } catch (t) {
          this.viewerError = `An error occurred: ${t}`;
        }
      } else
        this.viewerError = "An error occurred: no url provider or no viewer in _openFile.";
    });
  }
  disconnectedCallback() {
    this.viewer && this.viewer.destroy();
  }
  updated(s) {
    s.has("open") && (this.open ? (this.initOpenSeaDragon(), this.nextFile("next")) : this.viewer && (this.viewer.destroy(), setTimeout(() => {
      const r = new CustomEvent("closed", {
        bubbles: !0,
        cancelable: !0,
        detail: this
      });
      this.dispatchEvent(r);
    }, 10))), s.has("dataVisible") && (this.dataVisible || this.scroll(0, 0));
  }
  willUpdate(s) {
  }
  apiConnected() {
  }
  openDialog() {
    this.open = !0;
  }
  tryOpen(s) {
    this.emitBeforeEvent(
      "beforeOpen",
      {},
      () => {
        this.navDeferred = !1;
      },
      () => {
        this.navDeferred = !1, s();
      }
    ) || (this.navDeferred = !0);
  }
  opened(s, r) {
    setTimeout(() => {
      const e = new CustomEvent("opened", {
        bubbles: !0,
        cancelable: !1,
        detail: {
          component: this,
          result: s,
          errMsg: r
        }
      });
      this.dispatchEvent(e);
    }, 10);
  }
  splitterClicked() {
    this.dataVisible = !this.dataVisible;
  }
  renderError() {
    return this.viewerError ? mt`
            <div class="kiosk-lightbox-error">
                <p>${this.viewerError}</p>
            </div>` : ze;
  }
  doClose() {
    this.open = !1, this.navDeferred = !1;
  }
  doNext() {
    try {
      this.nextFile("next");
    } catch (s) {
      console.log(s);
    }
    this.navDeferred = !1;
  }
  doPrev() {
    try {
      this.nextFile("prev");
    } catch (s) {
      console.log(s);
    }
    this.navDeferred = !1;
  }
  tryClose() {
    this.emitBeforeEvent(
      "beforeClose",
      {},
      () => {
        this.navDeferred = !1;
      },
      () => {
        this.doClose();
      }
    ) || (this.navDeferred = !0);
  }
  tryNext() {
    this.emitBeforeEvent(
      "beforeNext",
      {},
      () => {
        this.navDeferred = !1;
      },
      () => {
        this.doNext();
      }
    ) || (this.navDeferred = !0);
  }
  tryPrev() {
    this.emitBeforeEvent(
      "beforePrev",
      {},
      () => {
        this.navDeferred = !1;
      },
      () => {
        this.doPrev();
      }
    ) || (this.navDeferred = !0);
  }
  close(s = !1) {
    this.navDeferred = !1, s ? this.tryClose() : this.doClose();
  }
  toggleBackground() {
    this.darkMode = !this.darkMode;
  }
  renderNavButtons() {
    return mt`<div class="kiosk-lightbox-buttons ${this.hideUI ? "hide-ui" : ""}">
                        <div class="kiosk-lightbox-button" @click="${this.toggleBackground}"><i class="fa-circle-half-stroke"></i></div>
                        ${this.bof ? ze : mt`<div class = "kiosk-lightbox-button" @click="${this.tryPrev}"><i class="fa-prev"></i> </div>`}
                        ${this.eof ? ze : mt`<div class = "kiosk-lightbox-button" @click="${this.tryNext}"> <i class="fa-next"></i></div>`}
                        <div class="kiosk-lightbox-button" @click="${this.tryClose}"><i class="fa-close"></i></div>
                    </div>
                `;
  }
  renderOpenSeaDragon() {
    const s = { expanded: this.dataVisible, collapsed: !this.dataVisible, nodata: !this.hasData };
    return mt`
            <div class="kiosk-lightbox-outer ${this.darkMode ? "background-dark" : "background-light"}">
                ${this.navDeferred ? ze : this.renderNavButtons()}
                ${this.renderError()}
                <div class="kiosk-lightbox-inner ${this.hideUI ? "hide-ui" : ze}" 
                     style="${this.viewerError ? "visibility: hidden" : ze}">
                    <div id="open-sea-dragon"
                         class="kiosk-lightbox-viewer ${jm(s)}">
                    </div>
                </div>
                ${this.hasData ? mt`
                    <div class="kiosk-lightbox-data" style="${this.viewerError ? "visibility: hidden" : ze}">
                        <div class="kiosk-lightbox-splitter" @click="${this.splitterClicked}">
                            <i class="fa-view-list"></i>
                        </div>
                        <slot></slot>
                    </div>` : ze}
            </div>`;
  }
  apiRender() {
    return this.open ? mt`${this.renderOpenSeaDragon()}` : mt``;
  }
};
ct.styles = Hr(Wm);
ct.properties = {
  ...$m(ct, ct, "properties")
};
St([
  ei()
], ct.prototype, "viewerError", 2);
St([
  ei()
], ct.prototype, "eof", 2);
St([
  ei()
], ct.prototype, "bof", 2);
St([
  ei()
], ct.prototype, "hideUI", 2);
St([
  ei()
], ct.prototype, "navDeferred", 2);
St([
  ei()
], ct.prototype, "darkMode", 2);
St([
  et({ type: Boolean, reflect: !0 })
], ct.prototype, "open", 2);
St([
  et()
], ct.prototype, "dataVisible", 2);
St([
  et({ type: Boolean })
], ct.prototype, "hasData", 2);
ct = St([
  ro("kiosk-lightbox")
], ct);
export {
  Og as ComboBox,
  Ap as Grid,
  at as KioskContextSelector,
  yi as KioskDialog,
  ct as KioskLightbox,
  bt as KioskTZComboBox
};
